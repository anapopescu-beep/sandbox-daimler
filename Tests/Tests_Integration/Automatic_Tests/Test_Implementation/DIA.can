/*@!Encoding:1252*/
includes
{
  #include "..\Includes\SW_Modules\SW_Modules_Project\Project_Includes_Configuration.cin"
}


variables
{
  long debugger_variable = 0;
  int64 bReset_Cause;
  int64 diagResponseDataLenght = 0;
  int64 pi64Data;
  
}

testcase InitTestModule()
{
 ConfigureTestModuleInformation(CGA);
 strncpy(cLogPath, "S:\\Tools\\CANoe\\Config\\DAIMLER_MMA_INTEGRATION\\Logs\\DIA\\", elcount(cLogPath));
}


testcase SW_IT_DIA_runDidF18C_EcuSerialNumberRead_01() // Symbols file
{
  int64 i64NVP_BLOCK_ID_AEE_TRACEABILITY_RamBlockData;
  ////***********************************Test report header*********************************
  testReportAddMiscInfoBlock("AUTOLIV ELECTRONICS document");
  TestReportAddMiscInfo("Nightly test", "No");
  TestReportAddMiscInfo("Test type", "Requirement-Based test");
  TestReportAddMiscInfo("Regression Test", "No");
  TestReportAddMiscInfo("Fault injection method used", "No");
  TestReportAddMiscInfo("Resource usage evaluation", "No");
  TestReportAddMiscInfo("Priority", "No");
  TestReportAddMiscInfo("Safety relevant", "No");
  
  AddRequirementInfo("Requirement under test", "ARCH_SW_DIA_0000; ARCH_SW_DIA_0051; ARCH_SW_DIA_0052, ARCH_SW_NVP_0003");
  AddRequirementInfo("ARCH_SW_DIA_0000", "Service 0x22 will be implemented for DID F18C");
  AddRequirementInfo("ARCH_SW_DIA_0051", "Service should be available in Default and extended session");
  AddRequirementInfo("ARCH_SW_DIA_0052", "NVP_BLOCK_ID_AEE_TRACEABILITY_RamBlockData will be read.");
  AddRequirementInfo("ARCH_SW_NVP_0003", "NVP_BLOCK_ID_AEE_TRACEABILITY block shall be configured. Parameter NVP_au8AeeTraceabilityNumber should have 12 bytes and should store AEE ECU Traceability number. (default values 0xFF).");

  ////***************************************************************************************

  testCaseComment("Preconditions");
  testStep("STEP", "Bench Initialization");
  RunPreTs();
  ////====================================================

  testCaseComment("Action: ARCH_SW_DIA_0000; ARCH_SW_DIA_0051; ARCH_SW_DIA_0052, ARCH_SW_NVP_0003");
  testStep("STEP", "Enter default or extended session.");
  EnterDiagnosticSession("default");
  
  testStep("STEP", "Set BP in function *DIA_runDidF18C_ECUSerialNumberRead* --> BP was reached.");
  debugger_setRelativeFunctionBpAtLine("DIA_runDidF18C_EcuSerialNumberRead", 4);
  debugger_run();
 
  testStep("STEP", "Send diag request for 22 F18C and wait for timeout error --> Request sent and timeout received.");
  SendDiagnosticRequest(dECUSerialNumberReadRequest, dECUSerialNumberReadResponse, TRUE);
  debugger_waitUntilBPisReached(5000);
  
  testStep("STEP", "Read first byte of NVP_BLOCK_ID_AEE_TRACEABILITY_RamBlockData --> Byte was read.");
  i64NVP_BLOCK_ID_AEE_TRACEABILITY_RamBlockData = debugger_readGlobalVariable("uint8", "NVP_BLOCK_ID_AEE_TRACEABILITY_RamBlockData,,app.elf", 0);
  EvalManStepEqual("Byte was read", i64NVP_BLOCK_ID_AEE_TRACEABILITY_RamBlockData);
  
    ////====================================================
  testCaseComment("Postcondition");
  testStep("STEP", "Return ECU to default values");
  RunPostTs();
}

testcase SW_IT_DIA_runDidF18C_EcuSerialNumberReadDataLength_01()
{
  ////***********************************Test report header*********************************
  testReportAddMiscInfoBlock("AUTOLIV ELECTRONICS document");
  TestReportAddMiscInfo("Nightly test", "No");
  TestReportAddMiscInfo("Test type", "Requirement-Based test");
  TestReportAddMiscInfo("Regression Test", "No");
  TestReportAddMiscInfo("Fault injection method used", "No");
  TestReportAddMiscInfo("Resource usage evaluation", "No");
  TestReportAddMiscInfo("Priority", "No");
  TestReportAddMiscInfo("Safety relevant", "No");
  
  AddRequirementInfo("Requirement under test", "ARCH_SW_DIA_0000; ARCH_SW_DIA_0053");
  AddRequirementInfo("ARCH_SW_DIA_0000", "Service 0x22 will be implemented for DID F18C");
  AddRequirementInfo("ARCH_SW_DIA_0053", "Runnable shall set response length to 12");

  ////***************************************************************************************

  testCaseComment("Preconditions");
  testStep("STEP", "Bench Initialization");
  RunPreTs();
  ////====================================================

  testCaseComment("Action: ARCH_SW_DIA_0000, ARCH_SW_DIA_0053");
  testStep("STEP", "Set BP in function *DIA_runDidF18C_EcuSerialNumberReadDataLength* --> BP was reached.");
  debugger_setRelativeFunctionBpAtLine("DIA_runDidF18C_EcuSerialNumberReadDataLength", 3);
  
  testStep("STEP", "Send diag request for 22 F18C and wait for timeout error --> Timeout received.");
  debugger_run();
  SendDiagnosticRequest(dECUSerialNumberReadRequest, dECUSerialNumberReadResponse, TRUE);
  debugger_waitUntilBPisReached(5000);
  debugger_isCPUStoppedAtFunction("DIA_runDidF18C_EcuSerialNumberReadDataLength");
  
  testStep("STEP", "Evaluate response data lenght. --> response data lenght is 12.");
  diagResponseDataLenght = debugger_readLocalVariable("*DataLength");
  EvalManStepEqual("Response lenght is 12", diagResponseDataLenght, 12);

  ////====================================================
  testCaseComment("Postcondition");
  testStep("STEP", "Return ECU to default values");
  RunPostTs();
}

testcase SW_IT_DIA_runDid0340_UniqueSeatbeltSerialNumberRead_01()
{
  int64 i64NVP_BLOCK_ID_BELT_ASSEMBLY_MANUF_DATE_AND_SN_RamBlockData;
  ////***********************************Test report header*********************************
  testReportAddMiscInfoBlock("AUTOLIV ELECTRONICS document");
  TestReportAddMiscInfo("Nightly test", "No");
  TestReportAddMiscInfo("Test type", "Requirement-Based test");
  TestReportAddMiscInfo("Regression Test", "No");
  TestReportAddMiscInfo("Fault injection method used", "No");
  TestReportAddMiscInfo("Resource usage evaluation", "No");
  TestReportAddMiscInfo("Priority", "No");
  TestReportAddMiscInfo("Safety relevant", "No");
  
  AddRequirementInfo("Requirement under test", "ARCH_SW_DIA_0001; ARCH_SW_DIA_0054; ARCH_SW_DIA_0055; ARCH_SW_NVP_0001");
  AddRequirementInfo("ARCH_SW_DIA_0001", "Service 0x22 will be implemented for DID 0340.");
  AddRequirementInfo("ARCH_SW_DIA_0054", "The Read Belt Assembly Serial Number shall be available in the following sessions: Default Session & Extended Session");
  AddRequirementInfo("ARCH_SW_DIA_0055", "Response data length shall be 28 bytes long.");
  AddRequirementInfo("ARCH_SW_NVP_0001", "NVP_BLOCK_ID_BELT_ASSEMBLY_MANUF_DATE_AND_SN block shall be configured. Parameter NVP_au8AssemblySerialNumber should have 28 bytes and should store belt assembly Serial Number written at ANG (default values 0xFF).");

  ////***************************************************************************************

  testCaseComment("Preconditions");
  testStep("STEP", "Bench Initialization");
  RunPreTs();
  ////====================================================

  testCaseComment("Action: ARCH_SW_DIA_0001; ARCH_SW_DIA_0054; ARCH_SW_DIA_0055; ARCH_SW_NVP_0001");
  
  testStep("STEP", "Enter default or extended session.");
  EnterDiagnosticSession("default");
  
  testStep("STEP", "Set breakpoint in function *DIA_runDid0340_UniqueSeatbeltSerialNumberRead*.");
  debugger_setRelativeFunctionBpAtLine("DIA_runDid0340_UniqueSeatbeltSerialNumberRead", 4);
  debugger_run();
 
  testStep("STEP", "Send diag request for 22 0340 and wait for timeout error --> Timeout reached.");
  SendDiagnosticRequest(dSeatBeltSerialNumberReadRequest, dSeatBeltSerialNumberReadResponse, TRUE);

  testStep("STEP", "Check if breakpoint from function DIA_runDid0340_UniqueSeatbeltSerialNumberRead was reached. --> BP was reached.");
  debugger_waitUntilBPisReached(5000);
  debugger_isCPUStoppedAtFunction("DIA_runDid0340_UniqueSeatbeltSerialNumberRead");
  
  testStep("STEP", "Read first byte of NVP_BLOCK_ID_BELT_ASSEMBLY_MANUF_DATE_AND_SN_RamBlockData --> Variable read.");
  i64NVP_BLOCK_ID_BELT_ASSEMBLY_MANUF_DATE_AND_SN_RamBlockData = debugger_readGlobalVariable("uint8", "NVP_BLOCK_ID_BELT_ASSEMBLY_MANUF_DATE_AND_SN_RamBlockData,,app.elf", 0);
  EvalManStepEqual("Byte was read", i64NVP_BLOCK_ID_BELT_ASSEMBLY_MANUF_DATE_AND_SN_RamBlockData);
  
  testStep("STEP", "Read last byte (index = 27) of NVP_BLOCK_ID_BELT_ASSEMBLY_MANUF_DATE_AND_SN_RamBlockData --> Variable read.");
  i64NVP_BLOCK_ID_BELT_ASSEMBLY_MANUF_DATE_AND_SN_RamBlockData = debugger_readGlobalVariable("uint8", "NVP_BLOCK_ID_BELT_ASSEMBLY_MANUF_DATE_AND_SN_RamBlockData,,app.elf", 27);
  EvalManStepEqual("Byte was read", i64NVP_BLOCK_ID_BELT_ASSEMBLY_MANUF_DATE_AND_SN_RamBlockData);

  ////====================================================
  testCaseComment("Postcondition");
  testStep("STEP", "Return ECU to default values");
  RunPostTs();
}

testcase SW_IT_DIA_runDidFD2F_EcuLocationRead_01()
{
  int64 i64NVP_BLOCK_ID_ECU_LOCATION_RamBlockData;
  //***********************************Test report header*********************************
  testReportAddMiscInfoBlock("AUTOLIV ELECTRONICS document");
  TestReportAddMiscInfo("Nightly test", "No");
  TestReportAddMiscInfo("Test type", "Requirement-Based test");
  TestReportAddMiscInfo("Regression Test", "No");
  TestReportAddMiscInfo("Fault injection method used", "No");
  TestReportAddMiscInfo("Resource usage evaluation", "No");
  TestReportAddMiscInfo("Priority", "No");
  TestReportAddMiscInfo("Safety relevant", "No");
  
  AddRequirementInfo("Requirement under test", "ARCH_SW_DIA_0002; ARCH_SW_DIA_0062; ARCH_SW_DIA_0063; ARCH_SW_NVP_0000");
  AddRequirementInfo("ARCH_SW_DIA_0002", "Service 0x22 will be implemented for DID FD2F.");
  AddRequirementInfo("ARCH_SW_DIA_0062", "Service should be available in Default and extended session");
  AddRequirementInfo("ARCH_SW_DIA_0063", "NVP_BLOCK_ID_ECU_LOCATION_RamBlockData will be read.");
  AddRequirementInfo("ARCH_SW_NVP_0000", "NVP_BLOCK_ID_ECU_LOCATION block shall be configured");


  //***************************************************************************************

  testCaseComment("Preconditions");
  testStep("STEP", "Bench Initialization");
  RunPreTs();
  //====================================================

  testCaseComment("Action: ARCH_SW_DIA_0002; ARCH_SW_DIA_0062; ARCH_SW_DIA_0063; ARCH_SW_NVP_0000");
  
  testStep("STEP", "Enter default or extended session.");
  EnterDiagnosticSession("extended");
  
  testStep("STEP", "Set breakpoint in function *DIA_runDidFD2F_EcuLocationRead*.");
  debugger_setRelativeFunctionBpAtLine("DIA_runDidFD2F_EcuLocationRead", 4);
  debugger_run();
 
  testStep("STEP", "Send diag request for 22 FD2F and wait for timeout error --> Timeout reached.");
  SendDiagnosticRequest(dReadECULocationRequest, dReadECULocationResponse, TRUE);

  testStep("STEP", "Check if breakpoint from function DIA_runDidFD2F_EcuLocationRead was reached. --> BP was reached.");
  debugger_waitUntilBPisReached(5000);
  debugger_isCPUStoppedAtFunction("DIA_runDidFD2F_EcuLocationRead");
  
  testStep("STEP", "Read first byte of NVP_BLOCK_ID_ECU_LOCATION_RamBlockData --> Variable read.");
  i64NVP_BLOCK_ID_ECU_LOCATION_RamBlockData = debugger_readGlobalVariable("uint8", "NVP_BLOCK_ID_ECU_LOCATION_RamBlockData,,app.elf", 0);
  EvalManStepEqual("Byte was read", i64NVP_BLOCK_ID_ECU_LOCATION_RamBlockData);

  //====================================================
  testCaseComment("Postcondition");
  testStep("STEP", "Return ECU to default values");
  RunPostTs();
}

testcase SW_IT_DIA_runDidFD10_CycleConfigurationRead_01()
{
  int64 i64NVP_BLOCK_ID_CYCLE_0_RamBlockData;
  ////***********************************Test report header*********************************
  testReportAddMiscInfoBlock("AUTOLIV ELECTRONICS document");
  TestReportAddMiscInfo("Nightly test", "No");
  TestReportAddMiscInfo("Test type", "Requirement-Based test");
  TestReportAddMiscInfo("Regression Test", "No");
  TestReportAddMiscInfo("Fault injection method used", "No");
  TestReportAddMiscInfo("Resource usage evaluation", "No");
  TestReportAddMiscInfo("Priority", "No");
  TestReportAddMiscInfo("Safety relevant", "No");
  
  AddRequirementInfo("Requirement under test", "ARCH_SW_DIA_0004; ARCH_SW_DIA_0064; ARCH_SW_DIA_0065; ARCH_SW_NVP_0017; ARCH_SW_DIA_0082");
  AddRequirementInfo("ARCH_SW_DIA_0004", "Service 0x22 will be implemented for DID FD10.");
  AddRequirementInfo("ARCH_SW_DIA_0064", "Service should be available in Development Session");
  AddRequirementInfo("ARCH_SW_DIA_0065", "NVP_BLOCK_ID_CYCLE0-34_RamBlockData will be read.");
  AddRequirementInfo("ARCH_SW_NVP_0006", "NVP_BLOCK_ID_CYCLE_0  34 blocks should be configured. Parameter NVP_au8BeltProfilesDefinitions should have 420 bytes.");
  AddRequirementInfo("ARCH_SW_NVP_0017", "NVP_BLOCK_ID_CYCLE_5 shall be configured with max duration of 5 sec and no following cycle.");
  AddRequirementInfo("ARCH_SW_DIA_0082", "Data Length shall be 420 bytes long.");

  ////***************************************************************************************

  testCaseComment("Preconditions");
  testStep("STEP", "Bench Initialization");
  RunPreTs();
  ////====================================================
  
  testCaseComment("Action: ARCH_SW_DIA_0004; ARCH_SW_DIA_0064; ARCH_SW_DIA_0065; ARCH_SW_NVP_0017; ARCH_SW_DIA_0082");
  testStep("STEP", "Enter development session.");
  EnterDiagnosticSession("development");

  testStep("STEP", "Set breakpoint in function *DIA_runDidFD10_CycleConfigurationRead*.");
  debugger_setRelativeFunctionBpAtLine("DIA_runDidFD10_CycleConfigurationRead", 4);
  debugger_run();

  testStep("STEP", "Send diag request for 22 FD10 and wait for timeout error --> Timeout received.");
  SendDiagnosticRequest(dCycleConfigReadRequest, dCycleConfigReadResponse, TRUE);

  testStep("STEP", "Check if breakpoint from function DIA_runDidFD10_CycleConfigurationRead was reached. --> BP was reached.");
  debugger_waitUntilBPisReached(5000);
  debugger_isCPUStoppedAtFunction("DIA_runDidFD10_CycleConfigurationRead");
  
  testStep("STEP", "Read first byte of NVP_BLOCK_ID_CYCLE_0_RamBlockData --> Byte was read.");
  i64NVP_BLOCK_ID_CYCLE_0_RamBlockData = debugger_readGlobalVariable("uint8", "NVP_BLOCK_ID_CYCLE_0_RamBlockData,,app.elf", 0);
  EvalManStepEqual("Byte was read", i64NVP_BLOCK_ID_CYCLE_0_RamBlockData);
  
  testStep("STEP", "Read last byte (index = 420) of NVP_BLOCK_ID_CYCLE_0_RamBlockData --> Byte was read.");
  i64NVP_BLOCK_ID_CYCLE_0_RamBlockData = debugger_readGlobalVariable("uint8", "NVP_BLOCK_ID_CYCLE_0_RamBlockData,,app.elf", 419);
  EvalManStepEqual("Byte was read", i64NVP_BLOCK_ID_CYCLE_0_RamBlockData);

  //====================================================
  testCaseComment("Postcondition");
  testStep("STEP", "Return ECU to default values");
  RunPostTs();
}



testcase SW_IT_DIA_runDidFD2A_StepsLibraryRead_01()
{
  int64 i64NVP_BLOCK_ID_STEP_0_RamBlockData;
  ////***********************************Test report header*********************************
  testReportAddMiscInfoBlock("AUTOLIV ELECTRONICS document");
  TestReportAddMiscInfo("Nightly test", "No");
  TestReportAddMiscInfo("Test type", "Requirement-Based test");
  TestReportAddMiscInfo("Regression Test", "No");
  TestReportAddMiscInfo("Fault injection method used", "No");
  TestReportAddMiscInfo("Resource usage evaluation", "No");
  TestReportAddMiscInfo("Priority", "No");
  TestReportAddMiscInfo("Safety relevant", "No");
  
  AddRequirementInfo("Requirement under test", "ARCH_SW_DIA_0006; ARCH_SW_DIA_0068; ARCH_SW_DIA_0069; ARCH_SW_NVP_0020l; ARCH_SW_DIA_0083");
  AddRequirementInfo("ARCH_SW_DIA_0006", "Service 0x22 will be implemented for DID FD2A.");
  AddRequirementInfo("ARCH_SW_DIA_0068", "Service should be available in Development Session.");
  AddRequirementInfo("ARCH_SW_DIA_0069", "NVP_BLOCK_ID_STEPS0 - 144_RamBlockData will be read.");
  AddRequirementInfo("ARCH_SW_NVP_0020", "Steps parameters shall be configured like : Byte 4 = velocity control order type if 0x02 = Velocity control order type enabled 0x03 = Velocity control and PWM backup 0x05 = velocity control and current backup 0x06 = velocity control and Volatge backup Ã¢â‚¬Â¢ Byte 7 = velocity control order value [120 grades/s l 1200 grades/s] ");
  AddRequirementInfo("ARCH_SW_DIA_0083", "Data Length shall be 1160 bytes long.");
  ////***************************************************************************************

  testCaseComment("Preconditions");
  testStep("STEP", "Bench Initialization");
  RunPreTs();
  ////====================================================

  testCaseComment("Action: ARCH_SW_DIA_0006; ARCH_SW_DIA_0068; ARCH_SW_DIA_0069; ARCH_SW_NVP_0020l; ARCH_SW_DIA_0083");
  testStep("STEP", "Enter development session.");
  EnterDiagnosticSession("development");
  
  testStep("STEP", "Set breakpoint in function *DIA_runDidFD2A_StepsLibraryRead*.");
  debugger_setRelativeFunctionBpAtLine("DIA_runDidFD2A_StepsLibraryRead", 4);
  debugger_run();
 
  testStep("STEP", "Send diag request for 22 FD2A and wait for timeout error --> Timeout received.");
  SendDiagnosticRequest(dReadStepsConfigRequest, dReadStepsConfigResponse, TRUE);

  testStep("STEP", "Check if breakpoint from function DIA_runDidFD2A_StepsLibraryRead was reached. --> BP was reached.");
  debugger_waitUntilBPisReached(5000);
  debugger_isCPUStoppedAtFunction("DIA_runDidFD2A_StepsLibraryRead");
  
  testStep("STEP", "Read first byte of NVP_BLOCK_ID_STEP_0_RamBlockData --> Byte was read.");
  i64NVP_BLOCK_ID_STEP_0_RamBlockData = debugger_readGlobalVariable("uint8", "NVP_BLOCK_ID_STEP_0_RamBlockData,,app.elf", 0);
  EvalManStepEqual("Byte was read", i64NVP_BLOCK_ID_STEP_0_RamBlockData);
  
  testStep("STEP", "Read last byte (index = 1159) of NVP_BLOCK_ID_STEP_0_RamBlockData --> Byte was read.");
  i64NVP_BLOCK_ID_STEP_0_RamBlockData = debugger_readGlobalVariable("uint8", "NVP_BLOCK_ID_STEP_0_RamBlockData,,app.elf", 1159);
  EvalManStepEqual("Byte was read", i64NVP_BLOCK_ID_STEP_0_RamBlockData);
  
  ////====================================================
  testCaseComment("Postcondition");
  testStep("STEP", "Return ECU to default values");
  RunPostTs();
}


testcase SW_IT_DIA_runDid0244_PreSafeCounterRead_01() // PR: Could not find symbol: DIA_runDid0244_PreSafeCounterRead
{
  int64 i64NVP_BLOCK_ID_EXECUTION_COUNTERS_RamBlockData;
  //***********************************Test report header*********************************
  testReportAddMiscInfoBlock("AUTOLIV ELECTRONICS document");
  TestReportAddMiscInfo("Nightly test", "No");
  TestReportAddMiscInfo("Test type", "Requirement-Based test");
  TestReportAddMiscInfo("Regression Test", "No");
  TestReportAddMiscInfo("Fault injection method used", "No");
  TestReportAddMiscInfo("Resource usage evaluation", "No");
  TestReportAddMiscInfo("Priority", "No");
  TestReportAddMiscInfo("Safety relevant", "No");
  
  AddRequirementInfo("Requirement under test", "ARCH_SW_DIA_0011; ARCH_SW_DIA_0076; ARCH_SW_DIA_0077; ARCH_SW_DIA_0366; ARCH_SW_DIA_0367; ARCH_SW_NVP_0004");
  AddRequirementInfo("ARCH_SW_DIA_0011", "Service 0x22 will be implemented for DID 0244.");
  AddRequirementInfo("ARCH_SW_DIA_0076", "Service should be available in Default, Extended and Development Session.");
  AddRequirementInfo("ARCH_SW_DIA_0077", "NVP_BLOCK_ID_EXECUTION_COUNTERS_RamBlockData will be read.");
  AddRequirementInfo("ARCH_SW_DIA_0366", "Bytes 0-1 shall return the “request counter value.");
  AddRequirementInfo("ARCH_SW_DIA_0367", "Bytes 6-7 shall return the “Max Force counter value.");
  AddRequirementInfo("ARCH_SW_NVP_0004", "NVP_BLOCK_ID_EXECUTION_COUNTERS block shall be configured. Parameter NVP_au32ExecutedCycleCounters should have 20 bytes and should store executed cycle counter. ");
  //***************************************************************************************

  testCaseComment("Preconditions");
  testStep("STEP", "Bench Initialization");
  RunPreTs();
  //====================================================

  testCaseComment("Action: ARCH_SW_DIA_0011; ARCH_SW_DIA_0076; ARCH_SW_DIA_0077; ARCH_SW_DIA_0366; ARCH_SW_DIA_0367; ARCH_SW_NVP_0004");
  
  testStep("STEP", "Enter development session.");
  EnterDiagnosticSession("development");
  
  testStep("STEP", "Set breakpoint in function *DIA_runDid0244_PreSafeCounterRead*.");
  debugger_setRelativeFunctionBpAtLine("DIA_runDid0244_PreSafeCounterRead", 4);
  debugger_run();
 
  testStep("STEP", "Send diag request for 22 0244 and wait for timeout error --> Timeout received.");
  SendDiagnosticRequest(dPresafeCounterReadRequest, dPresafeCounterReadResponse, TRUE);

  testStep("STEP", "Check if breakpoint from function DIA_runDid0244_PreSafeCounterRead was reached. --> BP was reached.");
  debugger_waitUntilBPisReached(5000);
  debugger_isCPUStoppedAtFunction("DIA_runDid0244_PreSafeCounterRead");
  
  testStep("STEP", "Read first byte of NVP_BLOCK_ID_EXECUTION_COUNTERS_RamBlockData --> Byte was read.");
  i64NVP_BLOCK_ID_EXECUTION_COUNTERS_RamBlockData = debugger_readGlobalVariable("uint8", "NVP_BLOCK_ID_EXECUTION_COUNTERS_RamBlockData,,app.elf", 0);
  EvalManStepEqual("Byte was read", i64NVP_BLOCK_ID_EXECUTION_COUNTERS_RamBlockData);
  ;
  testStep("STEP", "Read last byte of NVP_BLOCK_ID_EXECUTION_COUNTERS_RamBlockData --> Byte was read.");
  i64NVP_BLOCK_ID_EXECUTION_COUNTERS_RamBlockData = debugger_readGlobalVariable("uint8", "NVP_BLOCK_ID_EXECUTION_COUNTERS_RamBlockData,,app.elf", 7);
  EvalManStepEqual("Byte was read", i64NVP_BLOCK_ID_EXECUTION_COUNTERS_RamBlockData);
  
  //====================================================
  testCaseComment("Postcondition");
  testStep("STEP", "Return ECU to default values");
  RunPostTs();
}

testcase SW_IT_DIA_runDid0244_PreSafeCounterReadDataLength_01()
{
  ////***********************************Test report header*********************************
  testReportAddMiscInfoBlock("AUTOLIV ELECTRONICS document");
  TestReportAddMiscInfo("Nightly test", "No");
  TestReportAddMiscInfo("Test type", "Requirement-Based test");
  TestReportAddMiscInfo("Regression Test", "No");
  TestReportAddMiscInfo("Fault injection method used", "No");
  TestReportAddMiscInfo("Resource usage evaluation", "No");
  TestReportAddMiscInfo("Priority", "No");
  TestReportAddMiscInfo("Safety relevant", "No");
  
  AddRequirementInfo("Requirement under test", "ARCH_SW_DIA_0011; ARCH_SW_DIA_0078");
  AddRequirementInfo("ARCH_SW_DIA_0011", "Service 0x22 will be implemented for DID 0244");
  AddRequirementInfo("ARCH_SW_DIA_0078", "Response data length shall be 8 bytes long");

  ////***************************************************************************************

  testCaseComment("Preconditions");
  testStep("STEP", "Bench Initialization");
  RunPreTs();
  ////====================================================

  testCaseComment("Action: ARCH_SW_DIA_0011; ARCH_SW_DIA_0078");
  testStep("STEP", "Set BP in function *DIA_runDid0244_PreSafeCounterReadDataLenght* --> BP was reached.");
  debugger_setRelativeFunctionBpAtLine("DIA_runDid0244_PreSafeCounterReadDataLenght", 3);
  
  testStep("STEP", "Send diag request for 22 0244, and wait for timeout error --> Timeout received");
  SendDiagnosticRequest(dPresafeCounterReadRequest, dPresafeCounterReadResponse);

  testStep("STEP", "Evaluate response data lenght. --> Response data size is 8 bytes.");
  diagResponseDataLenght = debugger_readLocalVariable("*DataLength");
  EvalManStepEqual("Response lenght is 12", diagResponseDataLenght, 12);

  ////====================================================
  testCaseComment("Postcondition");
  testStep("STEP", "Return ECU to default values");
  RunPostTs();
}



testcase SW_IT_DIA_runDid0243_BSRCounterRead_01()
{
int64 i64NVP_BLOCK_ID_EXECUTION_COUNTERS_RamBlockData;
  //***********************************Test report header*********************************
  testReportAddMiscInfoBlock("AUTOLIV ELECTRONICS document");
  TestReportAddMiscInfo("Nightly test", "No");
  TestReportAddMiscInfo("Test type", "Requirement-Based test");
  TestReportAddMiscInfo("Regression Test", "No");
  TestReportAddMiscInfo("Fault injection method used", "No");
  TestReportAddMiscInfo("Resource usage evaluation", "No");
  TestReportAddMiscInfo("Priority", "No");
  TestReportAddMiscInfo("Safety relevant", "No");
  
  AddRequirementInfo("Requirement under test", "ARCH_SW_DIA_0012; ARCH_SW_DIA_0079; ARCH_SW_DIA_0080; ARCH_SW_DIA_0081");
  AddRequirementInfo("ARCH_SW_DIA_0012", "Service 0x22 will be implemented for DID 0243");
  AddRequirementInfo("ARCH_SW_DIA_0079", "Service should be available in Default, Extended and Development Session.");
  AddRequirementInfo("ARCH_SW_DIA_0080", "Response Data Length shall be 3 bytes.");
  AddRequirementInfo("ARCH_SW_DIA_0081", "NVP_BLOCK_ID_EXECUTION_COUNTERS_RamBlockData.ComfortCounter will be read.");
  
  //***************************************************************************************

  testCaseComment("Preconditions");
  testStep("STEP", "Bench Initialization");
  RunPreTs();
  //====================================================

  testStep("STEP", "Set breakpoint in function *DIA_runDid0243_BSRCounterRead*.");
  debugger_setRelativeFunctionBpAtLine("DIA_runDid0243_BSRCounterRead", 4);
  debugger_run();
 
  testCaseComment("Action: ARCH_SW_DIA_0012; ARCH_SW_DIA_0079; ARCH_SW_DIA_0080; ARCH_SW_DIA_0081");
  testStep("STEP", "Send diag request for 22 0243 and wait for timeout error --> Timeout received.");
  SendDiagnosticRequest(dBSRCounterReadRequest, dBSRCounterReadResponse, TRUE);

  testStep("STEP", "Check if breakpoint from function DIA_runDid0243_BSRCounterRead was reached. --> BP was reached.");
  debugger_waitUntilBPisReached(5000);
  debugger_isCPUStoppedAtFunction("DIA_runDid0243_BSRCounterRead");

  testStep("STEP", "Read first byte of NVP_BLOCK_ID_EXECUTION_COUNTERS_RamBlockData --> Byte was read.");
  i64NVP_BLOCK_ID_EXECUTION_COUNTERS_RamBlockData = debugger_readGlobalVariable("uint8", "NVP_BLOCK_ID_EXECUTION_COUNTERS_RamBlockData,,app.elf", 0);
  EvalManStepEqual("Byte was read", i64NVP_BLOCK_ID_EXECUTION_COUNTERS_RamBlockData);
  
  testStep("STEP", "Read last byte (index = 4) of NVP_BLOCK_ID_EXECUTION_COUNTERS_RamBlockData --> Byte was read.");
  i64NVP_BLOCK_ID_EXECUTION_COUNTERS_RamBlockData = debugger_readGlobalVariable("uint8", "NVP_BLOCK_ID_EXECUTION_COUNTERS_RamBlockData,,app.elf", 4);
  EvalManStepEqual("Byte was read", i64NVP_BLOCK_ID_EXECUTION_COUNTERS_RamBlockData);
  
  //====================================================
  testCaseComment("Postcondition");
  testStep("STEP", "Return ECU to default values");
  RunPostTs();
}

testcase SW_IT_DIA_DataServices_PreSafe_Cycles_Level_1_8_CombinedSignal_ReadData_01()
{
  int64 i64NVP_BLOCK_ID_CYCLE_0_RamBlockData = 0;
  int64 i64NVP_BLOCK_ID_STEP_0_RamBlockData = 0;
  //***********************************Test report header*********************************
  testReportAddMiscInfoBlock("AUTOLIV ELECTRONICS document");
  TestReportAddMiscInfo("Nightly test", "No");
  TestReportAddMiscInfo("Test type", "Requirement-Based test");
  TestReportAddMiscInfo("Regression Test", "No");
  TestReportAddMiscInfo("Fault injection method used", "No");
  TestReportAddMiscInfo("Resource usage evaluation", "No");
  TestReportAddMiscInfo("Priority", "No");
  TestReportAddMiscInfo("Safety relevant", "No");
  
  AddRequirementInfo("Requirement under test", "ARCH_SW_DIA_0021; ARCH_SW_DIA_0086; ARCH_SW_DIA_0202;");
  AddRequirementInfo("ARCH_SW_DIA_0021", "Service 0x22 will be implemented for DID 0300");
  AddRequirementInfo("ARCH_SW_DIA_0086", "Service shall be available in Default, Extended and Development session");
  AddRequirementInfo("ARCH_SW_DIA_0202", "Data contained in NVP_BLOCK_ID_CYCLE_0 to NVP_BLOCK_ID_CYCLE_25 and NVP_BLOCK_ID_STEP_0 to NVP_BLOCK_ID_STEP_91 shall be returned");

  //***************************************************************************************

  testCaseComment("Preconditions");
  testStep("STEP", "Bench Initialization");
  RunPreTs();
  //====================================================

  testCaseComment("Action: ARCH_SW_DIA_0021; ARCH_SW_DIA_0086; ARCH_SW_DIA_0087; ARCH_SW_DIA_0202;");

  testStep("STEP", "Enter development session.");
  EnterDiagnosticSession("development");
  
  testStep("STEP", "Set breakpoint in function *DataServices_PreSafe_Cycles_Level_1_8_CombinedSignal_ReadData*.");
  debugger_setRelativeFunctionBpAtLine("DataServices_PreSafe_Cycles_Level_1_8_CombinedSignal_ReadData", 0);
  debugger_run();
 
  testStep("STEP", "Send diag request for 22 0300 and wait for timeout error --> Timeout received.");
  SendDiagnosticRequest(dPresafeCycleReadRequest, dPresafeCycleReadResponse, TRUE);

  testStep("STEP", "Check if breakpoint from function DataServices_PreSafe_Cycles_Level_1_8_CombinedSignal_ReadData was reached. --> BP was reached.");
  debugger_waitUntilBPisReached(5000);
  debugger_isCPUStoppedAtFunction("DataServices_PreSafe_Cycles_Level_1_8_CombinedSignal_ReadData");
  
  testStep("STEP", "Read first byte of NVP_BLOCK_ID_CYCLE_0_RamBlockData --> Byte was read.");
  i64NVP_BLOCK_ID_CYCLE_0_RamBlockData = debugger_readGlobalVariable("uint8", "NVP_BLOCK_ID_CYCLE_0_RamBlockData,,app.elf", 0);
  EvalManStepEqual("Byte was read", i64NVP_BLOCK_ID_CYCLE_0_RamBlockData);
  
  testStep("STEP", "Read 25th byte of NVP_BLOCK_ID_CYCLE_0_RamBlockData --> Byte was read.");
  i64NVP_BLOCK_ID_CYCLE_0_RamBlockData = debugger_readGlobalVariable("uint8", "NVP_BLOCK_ID_CYCLE_0_RamBlockData,,app.elf", 24);
  EvalManStepEqual("Byte was read", i64NVP_BLOCK_ID_CYCLE_0_RamBlockData);
  
  testStep("STEP", "Read first byte of NVP_BLOCK_ID_STEP_0_RamBlockData --> Byte was read.");
  i64NVP_BLOCK_ID_STEP_0_RamBlockData = debugger_readGlobalVariable("uint8", "NVP_BLOCK_ID_STEP_0_RamBlockData,,app.elf", 0);
  EvalManStepEqual("Byte was read", i64NVP_BLOCK_ID_STEP_0_RamBlockData);
  
  testStep("STEP", "Read 91st byte of NVP_BLOCK_ID_STEP_0_RamBlockData --> Byte was read.");
  i64NVP_BLOCK_ID_STEP_0_RamBlockData = debugger_readGlobalVariable("uint8", "NVP_BLOCK_ID_STEP_0_RamBlockData,,app.elf", 91);
  EvalManStepEqual("Byte was read", i64NVP_BLOCK_ID_STEP_0_RamBlockData);

  //====================================================
  testCaseComment("Postcondition");
  testStep("STEP", "Return ECU to default values");
  RunPostTs();
}

testcase SW_IT_DIA_DataServices_PreSafe_Cycles_Level_1_8_CombinedSignal_ReadData_02()
{
  ////***********************************Test report header*********************************
  testReportAddMiscInfoBlock("AUTOLIV ELECTRONICS document");
  TestReportAddMiscInfo("Nightly test", "No");
  TestReportAddMiscInfo("Test type", "Requirement-Based test");
  TestReportAddMiscInfo("Regression Test", "No");
  TestReportAddMiscInfo("Fault injection method used", "No");
  TestReportAddMiscInfo("Resource usage evaluation", "No");
  TestReportAddMiscInfo("Priority", "No");
  TestReportAddMiscInfo("Safety relevant", "No");
  
  AddRequirementInfo("Requirement under test", "ARCH_SW_DIA_0087");
  AddRequirementInfo("ARCH_SW_DIA_0087", "Response data shall be 1048 bytes long. From R6.0 Response data shall be 1072 bytes long");

  ////***************************************************************************************

  testCaseComment("Preconditions");
  testStep("STEP", "Bench Initialization");
  RunPreTs();
  ////====================================================

  testCaseComment("Action: ARCH_SW_DIA_0087");
  
  testStep("STEP", "Enter development session.");
  EnterDiagnosticSession("development");
  
  testStep("STEP", "Send diag request for 22 0300, and evaluate response --> Request sent.");
  SendDiagnosticRequest(dPresafeCycleReadRequest, dPresafeCycleReadResponse);

  testStep("STEP", "Evaluate response data lenght. --> Response data size is 1072 bytes.");
  CheckResponseLength(dPresafeCycleReadRequest, dPresafeCycleReadResponse, 1073);

  ////====================================================
  testCaseComment("Postcondition");
  testStep("STEP", "Return ECU to default values");
  RunPostTs();
}


testcase SW_IT_DIA_DataServices_Release_Cycles_BSR_and_PreSafe_CombinedSignal_ReadData_01()
{
  int64 i64NVP_BLOCK_ID_CYCLE_0_RamBlockData = 0;
  int64 i64NVP_BLOCK_ID_STEP_0_RamBlockData = 0;
  ////***********************************Test report header*********************************
  testReportAddMiscInfoBlock("AUTOLIV ELECTRONICS document");
  TestReportAddMiscInfo("Nightly test", "No");
  TestReportAddMiscInfo("Test type", "Requirement-Based test");
  TestReportAddMiscInfo("Regression Test", "No");
  TestReportAddMiscInfo("Fault injection method used", "No");
  TestReportAddMiscInfo("Resource usage evaluation", "No");
  TestReportAddMiscInfo("Priority", "No");
  TestReportAddMiscInfo("Safety relevant", "No");
  
  AddRequirementInfo("Requirement under test", "ARCH_SW_DIA_0023; ARCH_SW_DIA_0090; ARCH_SW_DIA_0092;");
  AddRequirementInfo("ARCH_SW_DIA_0023", "Service 0x22 will be implemented for DID 0301");
  AddRequirementInfo("ARCH_SW_DIA_0090", "Service shall be available in Default, Extended and Development session");
  AddRequirementInfo("ARCH_SW_DIA_0092", "Data contained in NVP_BLOCK_ID_CYCLE_29 to NVP_BLOCK_ID_CYCLE_32 and NVP_BLOCK_ID_STEP_92 to NVP_BLOCK_ID_STEP_115 shall be returned");
  
  ////***************************************************************************************

  testCaseComment("Preconditions");
  testStep("STEP", "Bench Initialization");
  RunPreTs();
  ////====================================================

  testStep("STEP", "Enter development session.");
  EnterDiagnosticSession("development");
  
  testStep("STEP", "Set breakpoint in function *DataServices_Release_Cycles_BSR_and_PreSafe_CombinedSignal_ReadData*.");
  debugger_setRelativeFunctionBpAtLine("DataServices_Release_Cycles_BSR_and_PreSafe_CombinedSignal_ReadData", 4);
  debugger_run();
 
  testCaseComment("Action: ARCH_SW_DIA_0023; ARCH_SW_DIA_0090; ARCH_SW_DIA_0091; ARCH_SW_DIA_0092;");
  testStep("STEP", "Send diag request for 22 0301 and wait for timeout error --> Timeout received.");
  SendDiagnosticRequest(dReleaseCyclesBSRandPresafeReadRequest, dReleaseCyclesBSRandPresafeReadResponse, TRUE);

  testStep("STEP", "Check if breakpoint from function DataServices_Release_Cycles_BSR_and_PreSafe_CombinedSignal_ReadData. --> BP was reached.");
  debugger_waitUntilBPisReached(5000);
  debugger_isCPUStoppedAtFunction("DataServices_Release_Cycles_BSR_and_PreSafe_CombinedSignal_ReadData");
   
  testStep("STEP", "Read 29th byte of NVP_BLOCK_ID_CYCLE_0_RamBlockData --> Byte was read.");
  debugger_readGlobalVariable("uint8", "NVP_BLOCK_ID_CYCLE_0_RamBlockData,,app.elf", 29);
  EvalManStepEqual("Byte was read", i64NVP_BLOCK_ID_CYCLE_0_RamBlockData);
  
  testStep("STEP", "Read 32th byte of NVP_BLOCK_ID_CYCLE_0_RamBlockData --> Byte was read.");
  debugger_readGlobalVariable("uint8", "NVP_BLOCK_ID_CYCLE_0_RamBlockData,,app.elf", 32);
  EvalManStepEqual("Byte was read", i64NVP_BLOCK_ID_CYCLE_0_RamBlockData);
  
  testStep("STEP", "Read 92nd byte of NVP_BLOCK_ID_STEP_0_RamBlockData --> Byte was read.");
  debugger_readGlobalVariable("uint8", "NVP_BLOCK_ID_STEP_0_RamBlockData,,app.elf", 92);
  EvalManStepEqual("Byte was read", i64NVP_BLOCK_ID_STEP_0_RamBlockData);
  
  testStep("STEP", "Read 115th byte of NVP_BLOCK_ID_STEP_0_RamBlockData --> Byte was read.");
  debugger_readGlobalVariable("uint8", "NVP_BLOCK_ID_STEP_0_RamBlockData,,app.elf", 115);
  EvalManStepEqual("Byte was read", i64NVP_BLOCK_ID_STEP_0_RamBlockData);
  
  ////====================================================
  testCaseComment("Postcondition");
  testStep("STEP", "Return ECU to default values");
  RunPostTs();
}


testcase SW_IT_DIA_DataServices_Release_Cycles_BSR_and_PreSafe_CombinedSignal_ReadData_02()
{
  ////***********************************Test report header*********************************
  testReportAddMiscInfoBlock("AUTOLIV ELECTRONICS document");
  TestReportAddMiscInfo("Nightly test", "No");
  TestReportAddMiscInfo("Test type", "Requirement-Based test");
  TestReportAddMiscInfo("Regression Test", "No");
  TestReportAddMiscInfo("Fault injection method used", "No");
  TestReportAddMiscInfo("Resource usage evaluation", "No");
  TestReportAddMiscInfo("Priority", "No");
  TestReportAddMiscInfo("Safety relevant", "No");
  
  AddRequirementInfo("Requirement under test", "ARCH_SW_DIA_0091");
  AddRequirementInfo("ARCH_SW_DIA_0091", "Response data shall be 144 bytes long");

  ////***************************************************************************************

  testCaseComment("Preconditions");
  testStep("STEP", "Bench Initialization");
  RunPreTs();
  ////====================================================

  testCaseComment("Action: ARCH_SW_DIA_0091;");
  
  testStep("STEP", "Enter development session.");
  EnterDiagnosticSession("development");
  
  testStep("STEP", "Send diag request for 22 0301, and evaluate response --> Request sent.");
  SendDiagnosticRequest(dReleaseCyclesBSRandPresafeReadRequest, dReleaseCyclesBSRandPresafeReadResponse);

  testStep("STEP", "Evaluate response data lenght. --> Response data size is 144 bytes.");
  CheckResponseLength(dReleaseCyclesBSRandPresafeReadRequest, dReleaseCyclesBSRandPresafeReadResponse, 144);

  ////====================================================
  testCaseComment("Postcondition");
  testStep("STEP", "Return ECU to default values");
  RunPostTs();
}

testcase SW_IT_DIA_DataServices_Tensioning_Cycle_BSR_CombinedSignal_ReadData_01()
{
    int64 i64NVP_BLOCK_ID_CYCLE_0_RamBlockData = 0;
  int64 i64NVP_BLOCK_ID_STEP_0_RamBlockData = 0;
  ////***********************************Test report header*********************************
  testReportAddMiscInfoBlock("AUTOLIV ELECTRONICS document");
  TestReportAddMiscInfo("Nightly test", "No");
  TestReportAddMiscInfo("Test type", "Requirement-Based test");
  TestReportAddMiscInfo("Regression Test", "No");
  TestReportAddMiscInfo("Fault injection method used", "No");
  TestReportAddMiscInfo("Resource usage evaluation", "No");
  TestReportAddMiscInfo("Priority", "No");
  TestReportAddMiscInfo("Safety relevant", "No");
  
  AddRequirementInfo("Requirement under test", "ARCH_SW_DIA_0025; ARCH_SW_DIA_0096; ARCH_SW_DIA_0097; ARCH_SW_DIA_0098;");
  AddRequirementInfo("ARCH_SW_DIA_0025", "Service 0x22 will be implemented for DID 0302");
  AddRequirementInfo("ARCH_SW_DIA_0096", "Service shall be available in Default, Extended and Development session");
  AddRequirementInfo("ARCH_SW_DIA_0097", "Response data shall be 228 bytes long. From R6.0 Response data shall be 233 bytes long");
  AddRequirementInfo("ARCH_SW_DIA_0098", "Data contained in NVP_BLOCK_ID_CYCLE_26 to NVP_BLOCK_ID_CYCLE_28 and NVP_BLOCK_ID_STEP_116 to NVP_BLOCK_ID_STEP_144 shall be returned");

  ////***************************************************************************************

  testCaseComment("Preconditions");
  testStep("STEP", "Bench Initialization");
  RunPreTs();
  ////====================================================

  testStep("STEP", "Enter development session.");
  EnterDiagnosticSession("development");
  
  testStep("STEP", "Set breakpoint in function *DataServices_Tensioning_Cycle_BSR_CombinedSignal_ReadData*.");
  debugger_setRelativeFunctionBpAtLine("DataServices_Tensioning_Cycle_BSR_CombinedSignal_ReadData", 0);
  debugger_run();
 
  testCaseComment("Action: ARCH_SW_DIA_0025; ARCH_SW_DIA_0096; ARCH_SW_DIA_0097; ARCH_SW_DIA_0098;");
  testStep("STEP", "Send diag request for 22 0302 and wait for timeout error --> Timeout received.");
  SendDiagnosticRequest(dTensioningCycleBSRReadRequest, dTensioningCycleBSRReadResponse, TRUE);

  testStep("STEP", "Check if breakpoint from function DataServices_Tensioning_Cycle_BSR_CombinedSignal_ReadData. --> BP was reached.");
  debugger_waitUntilBPisReached(5000);
  debugger_isCPUStoppedAtFunction("DataServices_Tensioning_Cycle_BSR_CombinedSignal_ReadData");
  
  testStep("STEP", "Read 26th byte of NVP_BLOCK_ID_CYCLE_0_RamBlockData --> Byte was read.");
  debugger_readGlobalVariable("uint8", "NVP_BLOCK_ID_CYCLE_0_RamBlockData,,app.elf", 25);
  EvalManStepEqual("Byte was read", i64NVP_BLOCK_ID_CYCLE_0_RamBlockData);
  
  testStep("STEP", "Read 28th byte of NVP_BLOCK_ID_CYCLE_0_RamBlockData --> Byte was read.");
  debugger_readGlobalVariable("uint8", "NVP_BLOCK_ID_CYCLE_0_RamBlockData,,app.elf", 27);
  EvalManStepEqual("Byte was read", i64NVP_BLOCK_ID_CYCLE_0_RamBlockData);
  
  testStep("STEP", "Read 116th byte of NVP_BLOCK_ID_STEP_0_RamBlockData --> Byte was read.");
  debugger_readGlobalVariable("uint8", "NVP_BLOCK_ID_STEP_0_RamBlockData,,app.elf", 115);
  EvalManStepEqual("Byte was read", i64NVP_BLOCK_ID_STEP_0_RamBlockData);
  
  testStep("STEP", "Read 144th byte of NVP_BLOCK_ID_STEP_0_RamBlockData --> Byte was read.");
  debugger_readGlobalVariable("uint8", "NVP_BLOCK_ID_STEP_0_RamBlockData,,app.elf", 143);
  EvalManStepEqual("Byte was read", i64NVP_BLOCK_ID_STEP_0_RamBlockData);
  
  ////====================================================
  testCaseComment("Postcondition");
  testStep("STEP", "Return ECU to default values");
  RunPostTs();
}

testcase SW_IT_DIA_DataServices_Tensioning_Cycle_BSR_CombinedSignal_ReadData_02()
{
  ////***********************************Test report header*********************************
  testReportAddMiscInfoBlock("AUTOLIV ELECTRONICS document");
  TestReportAddMiscInfo("Nightly test", "No");
  TestReportAddMiscInfo("Test type", "Requirement-Based test");
  TestReportAddMiscInfo("Regression Test", "No");
  TestReportAddMiscInfo("Fault injection method used", "No");
  TestReportAddMiscInfo("Resource usage evaluation", "No");
  TestReportAddMiscInfo("Priority", "No");
  TestReportAddMiscInfo("Safety relevant", "No");
  
  AddRequirementInfo("Requirement under test", "ARCH_SW_DIA_0097");
  AddRequirementInfo("ARCH_SW_DIA_0097", "Response data shall be 228 bytes long. From R6.0 Response data shall be 233 bytes long");

  ////***************************************************************************************

  testCaseComment("Preconditions");
  testStep("STEP", "Bench Initialization");
  RunPreTs();
  ////====================================================

  testCaseComment("Action: ARCH_SW_DIA_0097;");
  
  testStep("STEP", "Enter development session.");
  EnterDiagnosticSession("development");
  
  testStep("STEP", "Send diag request for 22 0302, and evaluate response --> Request sent.");
  SendDiagnosticRequest(dTensioningCycleBSRReadRequest, dTensioningCycleBSRReadResponse);

  testStep("STEP", "Evaluate response data lenght. --> Response data size is 233 bytes.");
  CheckResponseLength(dTensioningCycleBSRReadRequest, dTensioningCycleBSRReadResponse, 233);

  ////====================================================
  testCaseComment("Postcondition");
  testStep("STEP", "Return ECU to default values");
  RunPostTs();
}


testcase SW_IT_DIA_DataServices_Vehicle_Equipment_Read_Equipment_1_ReadData_01()
{
  int64 i64Rte_Ct_MBBL_SsaAppl_Coding_VehicleEquipment;
  ////***********************************Test report header*********************************
  testReportAddMiscInfoBlock("AUTOLIV ELECTRONICS document");
  TestReportAddMiscInfo("Nightly test", "No");
  TestReportAddMiscInfo("Test type", "Requirement-Based test");
  TestReportAddMiscInfo("Regression Test", "No");
  TestReportAddMiscInfo("Fault injection method used", "No");
  TestReportAddMiscInfo("Resource usage evaluation", "No");
  TestReportAddMiscInfo("Priority", "No");
  TestReportAddMiscInfo("Safety relevant", "No");
  
  AddRequirementInfo("Requirement under test", "ARCH_SW_DIA_0027; ARCH_SW_DIA_0102; ARCH_SW_DIA_0103; ARCH_SW_DIA_0104; ARCH_SW_DIA_0368; ARCH_SW_DIA_0045");
  AddRequirementInfo("ARCH_SW_DIA_0027", "Service 0x22 will be implemented for DID 0310");
  AddRequirementInfo("ARCH_SW_DIA_0102", "Service shall be available in Default, Extended and Development session");
  AddRequirementInfo("ARCH_SW_DIA_0103", "Response data shall be 1 byte long");
  AddRequirementInfo("ARCH_SW_DIA_0104", "Data returned shall represent Equipment 1 stored in Rte_Ct_MBBL_SsaAppl_Coding_VehicleEquipment.Equipment1");
  AddRequirementInfo("ARCH_SW_DIA_0368", "Byte 0 shall represent Equipment 1, byte encoded as follows: Byte0_bit0  Configuration of Left right hand drive (steering style of the vehicle) 0x00  right hand drive 0x01  left hand drive  Byte0_bit1  Activation / Deactivation of BSR 0x00  yes  enabled   0x01  no  disabled  Byte0_bit2 Belt Handover ngagedngy 0x00 yes Belt hand over available 0x01 no Belt hand over not available Byte0_bit3 Reserved Byte0_bit4 Activation / Deactivation Haptic Warning left 0x00 yes enabled 0x01 no disabled Byte0_bit5 Activation / Deactivation Haptic Warning right 0x00 yes enabled 0x01 no disabled Byte0_bit6 - Activation / Deactivation of Service Provider (API) 0x00 yes enabled 0x01 no disabled Byte0_bit7 Reserved ");
  AddRequirementInfo("ARCH_SW_DIA_0045", "There shall be 2 reserved bytes located between Equipment 6 and Uberspannungsabbruchschwelle for response of DID 0310");
  //***************************************************************************************
  
  /*------------------------- Test scenario start ------------------------------*/
  testCaseComment("Preconditions");
  testStep("STEP", "Bench Initialization");
  RunPreTs();
  //====================================================

  testStep("STEP", "Enter development session.");
  EnterDiagnosticSession("development");
  
  testStep("STEP", "Set breakpoint in function *DataServices_Vehicle_Equipment_Read_Equipment_1_ReadData*.");
  debugger_setRelativeFunctionBpAtLine("DataServices_Vehicle_Equipment_Read_Equipment_1_ReadData", 18);
  debugger_run();
 
  testCaseComment("Action: ARCH_SW_DIA_0027; ARCH_SW_DIA_0102; ARCH_SW_DIA_0103; ARCH_SW_DIA_0104; ARCH_SW_DIA_0368; ARCH_SW_DIA_0045");
  testStep("STEP", "Use the Read service 0x22 for DID 0310 and wait for timeout. --> Timeout is occured because breakpoint was reached.");
  SendDiagnosticRequest (dVehicleEquipmentReadRequest, dVehicleEquipmentReadResponse, TRUE);
  
  debugger_waitUntilBPisReached(5000);
  debugger_isCPUStoppedAtFunction("DataServices_Vehicle_Equipment_Read_Equipment_1_ReadData");
  
  testStep("STEP", "Read Equipment 1 byte of Rte_Ct_MBBL_SsaAppl_Coding_VehicleEquipment --> Byte was read.");
  i64Rte_Ct_MBBL_SsaAppl_Coding_VehicleEquipment = debugger_readGlobalVariable("uint8", "Rte_Ct_MBBL_SsaAppl_Coding_VehicleEquipment,,app.elf", 0);
  EvalManStepEqual("Byte was read", i64Rte_Ct_MBBL_SsaAppl_Coding_VehicleEquipment);
  
  debugger_run();
  debugger_deleteAllBP();
  testStep("STEP", "Use the Read service 0x22 for DID 0310. --> Response is received.");
  SendDiagnosticRequest(dVehicleEquipmentReadRequest, dVehicleEquipmentReadResponse);
  CheckPositiveResponse("", dVehicleEquipmentReadRequest,dVehicleEquipmentReadResponse);
  
  //====================================================
 testCaseComment("Postcondition");
 testStep("STEP", "Return ECU to default values");
  RunPostTs();
}

testcase SW_IT_DIA_DataServices_Vehicle_Equipment_Read_Equipment_2_ReadData_01()
{
  int64 i64Rte_Ct_MBBL_SsaAppl_Coding_VehicleEquipment;
  ////***********************************Test report header*********************************
  testReportAddMiscInfoBlock("AUTOLIV ELECTRONICS document");
  TestReportAddMiscInfo("Nightly test", "No");
  TestReportAddMiscInfo("Test type", "Requirement-Based test");
  TestReportAddMiscInfo("Regression Test", "No");
  TestReportAddMiscInfo("Fault injection method used", "No");
  TestReportAddMiscInfo("Resource usage evaluation", "No");
  TestReportAddMiscInfo("Priority", "No");
  TestReportAddMiscInfo("Safety relevant", "No");
  
  AddRequirementInfo("Requirement under test", "ARCH_SW_DIA_0027; ARCH_SW_DIA_0108; ARCH_SW_DIA_0109");
  AddRequirementInfo("ARCH_SW_DIA_0027", "Service 0x22 will be implemented for DID 0310");
  AddRequirementInfo("ARCH_SW_DIA_0108", "Response data shall be 1 byte long");
  AddRequirementInfo("ARCH_SW_DIA_0109", "Response data shall be 1 byte long");
  ////***************************************************************************************
  
  /*------------------------- Test scenario start ------------------------------*/
  testCaseComment("Preconditions");
  testStep("STEP", "Bench Initialization");
  RunPreTs();
  //====================================================

  testStep("STEP", "Enter development session.");
  EnterDiagnosticSession("development");
  
  testStep("STEP", "Set breakpoint in function *DataServices_Vehicle_Equipment_Read_Equipment_2_ReadData*.");
  debugger_setRelativeFunctionBpAtLine("DataServices_Vehicle_Equipment_Read_Equipment_2_ReadData", 18);
  debugger_run();
 
  testCaseComment("Action: ARCH_SW_DIA_0027; ARCH_SW_DIA_0108; ARCH_SW_DIA_0109;");
  testStep("STEP", "Use the Read service 0x22 for DID 0310 and wait for timeout. --> Timeout is occured because breakpoint was reached.");
  SendDiagnosticRequest (dVehicleEquipmentReadRequest, dVehicleEquipmentReadResponse, TRUE);

  debugger_waitUntilBPisReached(5000);
  debugger_isCPUStoppedAtFunction("DataServices_Vehicle_Equipment_Read_Equipment_2_ReadData");
  
  testStep("STEP", "Read Equipment 2 byte of Rte_Ct_MBBL_SsaAppl_Coding_VehicleEquipment --> Byte was read.");
  i64Rte_Ct_MBBL_SsaAppl_Coding_VehicleEquipment = debugger_readGlobalVariable("uint8", "Rte_Ct_MBBL_SsaAppl_Coding_VehicleEquipment,,app.elf", 1);
  EvalManStepEqual("Byte was read", i64Rte_Ct_MBBL_SsaAppl_Coding_VehicleEquipment);
  
  debugger_run();
  debugger_deleteAllBP();
  testStep("STEP", "Use the Read service 0x22 for DID 0310. --> Response is received.");
  SendDiagnosticRequest(dVehicleEquipmentReadRequest, dVehicleEquipmentReadResponse);
  CheckPositiveResponse("", dVehicleEquipmentReadRequest,dVehicleEquipmentReadResponse);
  
  //====================================================
 testCaseComment("Postcondition");
 testStep("STEP", "Return ECU to default values");
  RunPostTs();
}

testcase SW_IT_DIA_DataServices_Vehicle_Equipment_Read_Equipment_3_ReadData_01()
{
  int64 i64Rte_Ct_MBBL_SsaAppl_Coding_VehicleEquipment;
  ////***********************************Test report header*********************************
  testReportAddMiscInfoBlock("AUTOLIV ELECTRONICS document");
  TestReportAddMiscInfo("Nightly test", "No");
  TestReportAddMiscInfo("Test type", "Requirement-Based test");
  TestReportAddMiscInfo("Regression Test", "No");
  TestReportAddMiscInfo("Fault injection method used", "No");
  TestReportAddMiscInfo("Resource usage evaluation", "No");
  TestReportAddMiscInfo("Priority", "No");
  TestReportAddMiscInfo("Safety relevant", "No");
  
  AddRequirementInfo("Requirement under test", "ARCH_SW_DIA_0027; ARCH_SW_DIA_0112; ARCH_SW_DIA_0113");
  AddRequirementInfo("ARCH_SW_DIA_0027", "Service 0x22 will be implemented for DID 0310");
  AddRequirementInfo("ARCH_SW_DIA_0112", "Response data shall be 1 byte long");
  AddRequirementInfo("ARCH_SW_DIA_0113", "Data returned shall represent Equipment 3 stored in Rte_Ct_MBBL_SsaAppl_Coding_VehicleEquipment.Equipment3");
  ////***************************************************************************************
  
  /*------------------------- Test scenario start ------------------------------*/
  testCaseComment("Preconditions");
  testStep("STEP", "Bench Initialization");
  RunPreTs();
  //====================================================

  testStep("STEP", "Enter development session.");
  EnterDiagnosticSession("development");
  
  testStep("STEP", "Set breakpoint in function *DataServices_Vehicle_Equipment_Read_Equipment_3_ReadData*.");
  debugger_setRelativeFunctionBpAtLine("DataServices_Vehicle_Equipment_Read_Equipment_3_ReadData", 18);
  debugger_run();
 
  testCaseComment("Action: ARCH_SW_DIA_0027; ARCH_SW_DIA_0112; ARCH_SW_DIA_0113;");
  testStep("STEP", "Use the Read service 0x22 for DID 0310 and wait for timeout. --> Timeout is occured because breakpoint was reached.");
  SendDiagnosticRequest (dVehicleEquipmentReadRequest, dVehicleEquipmentReadResponse, TRUE);

  debugger_waitUntilBPisReached(5000);
  debugger_isCPUStoppedAtFunction("DataServices_Vehicle_Equipment_Read_Equipment_3_ReadData");
  
  testStep("STEP", "Read Equipment 3 byte of Rte_Ct_MBBL_SsaAppl_Coding_VehicleEquipment --> Byte was read.");
  i64Rte_Ct_MBBL_SsaAppl_Coding_VehicleEquipment = debugger_readGlobalVariable("uint8", "Rte_Ct_MBBL_SsaAppl_Coding_VehicleEquipment,,app.elf", 2);
  EvalManStepEqual("Byte was read", i64Rte_Ct_MBBL_SsaAppl_Coding_VehicleEquipment);
  
  debugger_run();
  debugger_deleteAllBP();
  testStep("STEP", "Use the Read service 0x22 for DID 0310. --> Response is received.");
  SendDiagnosticRequest(dVehicleEquipmentReadRequest, dVehicleEquipmentReadResponse);
  CheckPositiveResponse("", dVehicleEquipmentReadRequest,dVehicleEquipmentReadResponse);
  
  //====================================================
 testCaseComment("Postcondition");
 testStep("STEP", "Return ECU to default values");
  RunPostTs();
}

testcase SW_IT_DIA_DataServices_Vehicle_Equipment_Read_Equipment_4_ReadData_01()
{
  int64 i64Rte_Ct_MBBL_SsaAppl_Coding_VehicleEquipment;
  ////***********************************Test report header*********************************
  testReportAddMiscInfoBlock("AUTOLIV ELECTRONICS document");
  TestReportAddMiscInfo("Nightly test", "No");
  TestReportAddMiscInfo("Test type", "Requirement-Based test");
  TestReportAddMiscInfo("Regression Test", "No");
  TestReportAddMiscInfo("Fault injection method used", "No");
  TestReportAddMiscInfo("Resource usage evaluation", "No");
  TestReportAddMiscInfo("Priority", "No");
  TestReportAddMiscInfo("Safety relevant", "No");
  
  AddRequirementInfo("Requirement under test", "ARCH_SW_DIA_0027; ARCH_SW_DIA_0116; ARCH_SW_DIA_0117");
  AddRequirementInfo("ARCH_SW_DIA_0027", "Service 0x22 will be implemented for DID 0310");
  AddRequirementInfo("ARCH_SW_DIA_0116", "Response data shall be 1 byte long");
  AddRequirementInfo("ARCH_SW_DIA_0117", "Data returned shall represent Equipment 4 stored in Rte_Ct_MBBL_SsaAppl_Coding_VehicleEquipment.Equipment4");
  ////***************************************************************************************
  
  /*------------------------- Test scenario start ------------------------------*/
  testCaseComment("Preconditions");
  testStep("STEP", "Bench Initialization");
  RunPreTs();
  //====================================================

  testStep("STEP", "Enter development session.");
  EnterDiagnosticSession("development");
  
  testStep("STEP", "Set breakpoint in function *DataServices_Vehicle_Equipment_Read_Equipment_4_ReadData*.");
  debugger_setRelativeFunctionBpAtLine("DataServices_Vehicle_Equipment_Read_Equipment_4_ReadData", 18);
  debugger_run();
 
  testCaseComment("Action: ARCH_SW_DIA_0027; ARCH_SW_DIA_0116; ARCH_SW_DIA_0117;");
  testStep("STEP", "Use the Read service 0x22 for DID 0310 and wait for timeout. --> Timeout is occured because breakpoint was reached.");
  SendDiagnosticRequest (dVehicleEquipmentReadRequest, dVehicleEquipmentReadResponse, TRUE);

  debugger_waitUntilBPisReached(5000);
  debugger_isCPUStoppedAtFunction("DataServices_Vehicle_Equipment_Read_Equipment_4_ReadData");
  
  testStep("STEP", "Read Equipment 4 byte of Rte_Ct_MBBL_SsaAppl_Coding_VehicleEquipment --> Byte was read.");
  i64Rte_Ct_MBBL_SsaAppl_Coding_VehicleEquipment = debugger_readGlobalVariable("uint8", "Rte_Ct_MBBL_SsaAppl_Coding_VehicleEquipment,,app.elf", 3);
  EvalManStepEqual("Byte was read", i64Rte_Ct_MBBL_SsaAppl_Coding_VehicleEquipment);
  
  debugger_run();
  debugger_deleteAllBP();
  testStep("STEP", "Use the Read service 0x22 for DID 0310. --> Response is received.");
  SendDiagnosticRequest(dVehicleEquipmentReadRequest, dVehicleEquipmentReadResponse);
  CheckPositiveResponse("", dVehicleEquipmentReadRequest,dVehicleEquipmentReadResponse);
  
  //====================================================
 testCaseComment("Postcondition");
 testStep("STEP", "Return ECU to default values");
  RunPostTs();
}

testcase SW_IT_DIA_DataServices_Vehicle_Equipment_Read_Equipment_5_ReadData_01()
{
  int64 i64Rte_Ct_MBBL_SsaAppl_Coding_VehicleEquipment;
  ////***********************************Test report header*********************************
  testReportAddMiscInfoBlock("AUTOLIV ELECTRONICS document");
  TestReportAddMiscInfo("Nightly test", "No");
  TestReportAddMiscInfo("Test type", "Requirement-Based test");
  TestReportAddMiscInfo("Regression Test", "No");
  TestReportAddMiscInfo("Fault injection method used", "No");
  TestReportAddMiscInfo("Resource usage evaluation", "No");
  TestReportAddMiscInfo("Priority", "No");
  TestReportAddMiscInfo("Safety relevant", "No");
  
  AddRequirementInfo("Requirement under test", "ARCH_SW_DIA_0027; ARCH_SW_DIA_0120; ARCH_SW_DIA_0121");
  AddRequirementInfo("ARCH_SW_DIA_0027", "Service 0x22 will be implemented for DID 0310");
  AddRequirementInfo("ARCH_SW_DIA_0120", "Response data shall be 1 byte long");
  AddRequirementInfo("ARCH_SW_DIA_0121", "Data returned shall represent Equipment 5 stored in Rte_Ct_MBBL_SsaAppl_Coding_VehicleEquipment.Equipment5");
  ////***************************************************************************************
  
  /*------------------------- Test scenario start ------------------------------*/
  testCaseComment("Preconditions");
  testStep("STEP", "Bench Initialization");
  RunPreTs();
  //====================================================

  testStep("STEP", "Enter development session.");
  EnterDiagnosticSession("development");
  
  testStep("STEP", "Set breakpoint in function *DataServices_Vehicle_Equipment_Read_Equipment_5_ReadData*.");
  debugger_setRelativeFunctionBpAtLine("DataServices_Vehicle_Equipment_Read_Equipment_5_ReadData", 0);
  debugger_run();
 
  testCaseComment("Action: ARCH_SW_DIA_0027; ARCH_SW_DIA_0120; ARCH_SW_DIA_0121;");
  testStep("STEP", "Use the Read service 0x22 for DID 0310 and wait for timeout. --> Timeout is occured because breakpoint was reached.");
  SendDiagnosticRequest (dVehicleEquipmentReadRequest, dVehicleEquipmentReadResponse, TRUE);

  debugger_waitUntilBPisReached(5000);
  debugger_isCPUStoppedAtFunction("DataServices_Vehicle_Equipment_Read_Equipment_5_ReadData");
  
  testStep("STEP", "Read Equipment 5 byte of Rte_Ct_MBBL_SsaAppl_Coding_VehicleEquipment --> Byte was read.");
  i64Rte_Ct_MBBL_SsaAppl_Coding_VehicleEquipment = debugger_readGlobalVariable("uint8", "Rte_Ct_MBBL_SsaAppl_Coding_VehicleEquipment,,app.elf", 4);
  EvalManStepEqual("Byte was read", i64Rte_Ct_MBBL_SsaAppl_Coding_VehicleEquipment);
  
  debugger_run();
  debugger_deleteAllBP();
  testStep("STEP", "Use the Read service 0x22 for DID 0310. --> Response is received.");
  SendDiagnosticRequest(dVehicleEquipmentReadRequest, dVehicleEquipmentReadResponse);
  CheckPositiveResponse("", dVehicleEquipmentReadRequest,dVehicleEquipmentReadResponse);
  
  //====================================================
 testCaseComment("Postcondition");
 testStep("STEP", "Return ECU to default values");
  RunPostTs();
}

testcase SW_IT_DIA_DataServices_Vehicle_Equipment_Read_Equipment_6_ReadData_01()
{
  int64 i64Rte_Ct_MBBL_SsaAppl_Coding_VehicleEquipment;
  ////***********************************Test report header*********************************
  testReportAddMiscInfoBlock("AUTOLIV ELECTRONICS document");
  TestReportAddMiscInfo("Nightly test", "No");
  TestReportAddMiscInfo("Test type", "Requirement-Based test");
  TestReportAddMiscInfo("Regression Test", "No");
  TestReportAddMiscInfo("Fault injection method used", "No");
  TestReportAddMiscInfo("Resource usage evaluation", "No");
  TestReportAddMiscInfo("Priority", "No");
  TestReportAddMiscInfo("Safety relevant", "No");
  
  AddRequirementInfo("Requirement under test", "ARCH_SW_DIA_0027; ARCH_SW_DIA_0124; ARCH_SW_DIA_0125");
  AddRequirementInfo("ARCH_SW_DIA_0027", "Service 0x22 will be implemented for DID 0310");
  AddRequirementInfo("ARCH_SW_DIA_0124", "Response data shall be 1 byte long");
  AddRequirementInfo("ARCH_SW_DIA_0125", "Data returned shall represent Equipment 6 stored in Rte_Ct_MBBL_SsaAppl_Coding_VehicleEquipment.Equipment6");
  ////***************************************************************************************
  
  /*------------------------- Test scenario start ------------------------------*/
  testCaseComment("Preconditions");
  testStep("STEP", "Bench Initialization");
  RunPreTs();
  //====================================================

  testStep("STEP", "Enter development session.");
  EnterDiagnosticSession("development");
  
  testStep("STEP", "Set breakpoint in function *DataServices_Vehicle_Equipment_Read_Equipment_6_ReadData*.");
  debugger_setRelativeFunctionBpAtLine("DataServices_Vehicle_Equipment_Read_Equipment_6_ReadData", 0);
  debugger_run();
 
  testCaseComment("Action: ARCH_SW_DIA_0027; ARCH_SW_DIA_0124; ARCH_SW_DIA_0125;");
  testStep("STEP", "Use the Read service 0x22 for DID 0310 and wait for timeout. --> Timeout is occured because breakpoint was reached.");
  SendDiagnosticRequest (dVehicleEquipmentReadRequest, dVehicleEquipmentReadResponse, TRUE);

  debugger_waitUntilBPisReached(5000);
  debugger_isCPUStoppedAtFunction("DataServices_Vehicle_Equipment_Read_Equipment_6_ReadData");
  
  testStep("STEP", "Read Equipment 6 byte of Rte_Ct_MBBL_SsaAppl_Coding_VehicleEquipment --> Byte was read.");
  i64Rte_Ct_MBBL_SsaAppl_Coding_VehicleEquipment = debugger_readGlobalVariable("uint8", "Rte_Ct_MBBL_SsaAppl_Coding_VehicleEquipment,,app.elf", 5);
  EvalManStepEqual("Byte was read", i64Rte_Ct_MBBL_SsaAppl_Coding_VehicleEquipment);
  
  debugger_run();
  debugger_deleteAllBP();
  testStep("STEP", "Use the Read service 0x22 for DID 0310. --> Response is received.");
  SendDiagnosticRequest(dVehicleEquipmentReadRequest, dVehicleEquipmentReadResponse);
  CheckPositiveResponse("", dVehicleEquipmentReadRequest,dVehicleEquipmentReadResponse);
  
  //====================================================
 testCaseComment("Postcondition");
 testStep("STEP", "Return ECU to default values");
  RunPostTs();
}

testcase SW_IT_DIA_DataServices_Vehicle_Equipment_Read_Uberspannungsabbruchschwelle_ReadData_01()
{
  int64 i64Rte_Ct_MBBL_SsaAppl_Coding_VehicleEquipment;
  ////***********************************Test report header*********************************
  testReportAddMiscInfoBlock("AUTOLIV ELECTRONICS document");
  TestReportAddMiscInfo("Nightly test", "No");
  TestReportAddMiscInfo("Test type", "Requirement-Based test");
  TestReportAddMiscInfo("Regression Test", "No");
  TestReportAddMiscInfo("Fault injection method used", "No");
  TestReportAddMiscInfo("Resource usage evaluation", "No");
  TestReportAddMiscInfo("Priority", "No");
  TestReportAddMiscInfo("Safety relevant", "No");
  
  AddRequirementInfo("Requirement under test", "ARCH_SW_DIA_0027; ARCH_SW_DIA_0128; ARCH_SW_DIA_0129");
  AddRequirementInfo("ARCH_SW_DIA_0027", "Service 0x22 will be implemented for DID 0310");
  AddRequirementInfo("ARCH_SW_DIA_0128", "Response data shall be 2 bytes long");
  AddRequirementInfo("ARCH_SW_DIA_0129", "Data returned shall represent Uberspannungsabbruchschwelle stored in Rte_Ct_MBBL_SsaAppl_Coding_VehicleEquipment. Uberspannungsabbruchschwelle");
  ////***************************************************************************************
  
  /*------------------------- Test scenario start ------------------------------*/
  testCaseComment("Preconditions");
  testStep("STEP", "Bench Initialization");
  RunPreTs();
  //====================================================

  testStep("STEP", "Enter development session.");
  EnterDiagnosticSession("development");
  
  testStep("STEP", "Set breakpoint in function *DataServices_Vehicle_Equipment_Read_Uberspannungsabbruchschwelle_ReadData*.");
  debugger_setRelativeFunctionBpAtLine("DataServices_Vehicle_Equipment_Read_Uberspannungsabbruchschwelle_ReadData", 18);
  debugger_run();
 
  testCaseComment("Action: ARCH_SW_DIA_0027; ARCH_SW_DIA_0128; ARCH_SW_DIA_0129");
  testStep("STEP", "Use the Read service 0x22 for DID 0310 and wait for timeout. --> Timeout is occured because breakpoint was reached.");
  SendDiagnosticRequest (dVehicleEquipmentReadRequest, dVehicleEquipmentReadResponse, TRUE);

  debugger_waitUntilBPisReached(5000);
  debugger_isCPUStoppedAtFunction("DataServices_Vehicle_Equipment_Read_Uberspannungsabbruchschwelle_ReadData");
  
  testStep("STEP", "Read Uberspannungsabbruchschwelle bytes of Rte_Ct_MBBL_SsaAppl_Coding_VehicleEquipment --> Byte was read.");
  i64Rte_Ct_MBBL_SsaAppl_Coding_VehicleEquipment = debugger_readGlobalVariable("uint16", "Rte_Ct_MBBL_SsaAppl_Coding_VehicleEquipment,,app.elf", 6);
  EvalManStepEqual("Byte was read", i64Rte_Ct_MBBL_SsaAppl_Coding_VehicleEquipment);
  
  debugger_run();
  debugger_deleteAllBP();
  testStep("STEP", "Use the Read service 0x22 for DID 0310. --> Response is received.");
  SendDiagnosticRequest(dVehicleEquipmentReadRequest, dVehicleEquipmentReadResponse);
  CheckPositiveResponse("", dVehicleEquipmentReadRequest,dVehicleEquipmentReadResponse);
  
  //====================================================
 testCaseComment("Postcondition");
 testStep("STEP", "Return ECU to default values");
  RunPostTs();
}

testcase SW_IT_DIA_DataServices_Vehicle_Equipment_Read_Uberspannungsbereichsschwelle_ReadData_01()
{
  int64 i64Rte_Ct_MBBL_SsaAppl_Coding_VehicleEquipment;
  ////***********************************Test report header*********************************
  testReportAddMiscInfoBlock("AUTOLIV ELECTRONICS document");
  TestReportAddMiscInfo("Nightly test", "No");
  TestReportAddMiscInfo("Test type", "Requirement-Based test");
  TestReportAddMiscInfo("Regression Test", "No");
  TestReportAddMiscInfo("Fault injection method used", "No");
  TestReportAddMiscInfo("Resource usage evaluation", "No");
  TestReportAddMiscInfo("Priority", "No");
  TestReportAddMiscInfo("Safety relevant", "No");
  
  AddRequirementInfo("Requirement under test", "ARCH_SW_DIA_0027; ARCH_SW_DIA_0132; ARCH_SW_DIA_0133");
  AddRequirementInfo("ARCH_SW_DIA_0027", "Service 0x22 will be implemented for DID 0310");
  AddRequirementInfo("ARCH_SW_DIA_0132", "Response data shall be 2 bytes long");
  AddRequirementInfo("ARCH_SW_DIA_0133", "Data returned shall represent Uberspannungsbereichsschwelle stored in Rte_Ct_MBBL_SsaAppl_Coding_VehicleEquipment. Uberspannungsbereichsschwelle");
  ////***************************************************************************************
  
  /*------------------------- Test scenario start ------------------------------*/
  testCaseComment("Preconditions");
  testStep("STEP", "Bench Initialization");
  RunPreTs();
  //====================================================

  testStep("STEP", "Enter development session.");
  EnterDiagnosticSession("development");
  
  testStep("STEP", "Set breakpoint in function *DataServices_Vehicle_Equipment_Read_Uberspannungsbereichsschwelle_ReadData*.");
  debugger_setRelativeFunctionBpAtLine("DataServices_Vehicle_Equipment_Read_Uberspannungsbereichsschwelle_ReadData", 0);
  debugger_run();
 
  testCaseComment("Action: ARCH_SW_DIA_0027; ARCH_SW_DIA_0132; ARCH_SW_DIA_0133");
  testStep("STEP", "Use the Read service 0x22 for DID 0310 and wait for timeout. --> Timeout is occured because breakpoint was reached.");
  SendDiagnosticRequest (dVehicleEquipmentReadRequest, dVehicleEquipmentReadResponse, TRUE);

  debugger_waitUntilBPisReached(5000);
  debugger_isCPUStoppedAtFunction("DataServices_Vehicle_Equipment_Read_Uberspannungsbereichsschwelle_ReadData");
  
  testStep("STEP", "Read Uberspannungsbereichsschwelle bytes of Rte_Ct_MBBL_SsaAppl_Coding_VehicleEquipment --> Byte was read.");
  i64Rte_Ct_MBBL_SsaAppl_Coding_VehicleEquipment = debugger_readGlobalVariable("uint16", "Rte_Ct_MBBL_SsaAppl_Coding_VehicleEquipment,,app.elf", 7);
  EvalManStepEqual("Byte was read", i64Rte_Ct_MBBL_SsaAppl_Coding_VehicleEquipment);
  
  debugger_run();
  debugger_deleteAllBP();
  testStep("STEP", "Use the Read service 0x22 for DID 0310. --> Response is received.");
  SendDiagnosticRequest(dVehicleEquipmentReadRequest, dVehicleEquipmentReadResponse);
  CheckPositiveResponse("", dVehicleEquipmentReadRequest,dVehicleEquipmentReadResponse);
  
  //====================================================
 testCaseComment("Postcondition");
 testStep("STEP", "Return ECU to default values");
  RunPostTs();
}

testcase SW_IT_DIA_DataServices_Vehicle_Equipment_Read_Unterspannungsabbruchschwelle_ReadData_01()
{
  int64 i64Rte_Ct_MBBL_SsaAppl_Coding_VehicleEquipment;
  ////***********************************Test report header*********************************
  testReportAddMiscInfoBlock("AUTOLIV ELECTRONICS document");
  TestReportAddMiscInfo("Nightly test", "No");
  TestReportAddMiscInfo("Test type", "Requirement-Based test");
  TestReportAddMiscInfo("Regression Test", "No");
  TestReportAddMiscInfo("Fault injection method used", "No");
  TestReportAddMiscInfo("Resource usage evaluation", "No");
  TestReportAddMiscInfo("Priority", "No");
  TestReportAddMiscInfo("Safety relevant", "No");
  
  AddRequirementInfo("Requirement under test", "ARCH_SW_DIA_0027; ARCH_SW_DIA_0136; ARCH_SW_DIA_0137");
  AddRequirementInfo("ARCH_SW_DIA_0027", "Service 0x22 will be implemented for DID 0310");
  AddRequirementInfo("ARCH_SW_DIA_0136", "Response data shall be 2 bytes long");
  AddRequirementInfo("ARCH_SW_DIA_0137", "Data returned shall represent ÃƒÅ“berspannungsbereichsschwelle stored in Rte_Ct_MBBL_SsaAppl_Coding_VehicleEquipment. ÃƒÅ“berspannungsbereichsschwelle");
  ////***************************************************************************************
  
  /*------------------------- Test scenario start ------------------------------*/
  testCaseComment("Preconditions");
  testStep("STEP", "Bench Initialization");
  RunPreTs();
  //====================================================

  testStep("STEP", "Set breakpoint in function *DataServices_Vehicle_Equipment_Read_Unterspannungsabbruchschwelle_ReadData*.");
  debugger_setRelativeFunctionBpAtLine("DataServices_Vehicle_Equipment_Read_Unterspannungsabbruchschwelle_ReadData", 0);
  debugger_run();
 
  testCaseComment("Action: ARCH_SW_DIA_0027; ARCH_SW_DIA_0136; ARCH_SW_DIA_0137");
  testStep("STEP", "Use the Read service 0x22 for DID 0310 and wait for timeout. --> Timeout is occured because breakpoint was reached.");
  SendDiagnosticRequest (dVehicleEquipmentReadRequest, dVehicleEquipmentReadResponse, TRUE);

  debugger_waitUntilBPisReached(5000);
  debugger_isCPUStoppedAtFunction("DataServices_Vehicle_Equipment_Read_Unterspannungsabbruchschwelle_ReadData");
  
  
  testStep("STEP", "Read Unterspannungsbereichsschwelle bytes of Rte_Ct_MBBL_SsaAppl_Coding_VehicleEquipment --> Byte was read.");
  i64Rte_Ct_MBBL_SsaAppl_Coding_VehicleEquipment = debugger_readGlobalVariable("uint16", "Rte_Ct_MBBL_SsaAppl_Coding_VehicleEquipment,,app.elf", 8);
  EvalManStepEqual("Byte was read", i64Rte_Ct_MBBL_SsaAppl_Coding_VehicleEquipment);
  
  debugger_run();
  debugger_deleteAllBP();
  testStep("STEP", "Use the Read service 0x22 for DID 0310. --> Response is received.");
  SendDiagnosticRequest(dVehicleEquipmentReadRequest, dVehicleEquipmentReadResponse);
  CheckPositiveResponse("", dVehicleEquipmentReadRequest,dVehicleEquipmentReadResponse);
  
  //====================================================
 testCaseComment("Postcondition");
 testStep("STEP", "Return ECU to default values");
  RunPostTs();
}

testcase SW_IT_DIA_DataServices_Vehicle_Equipment_Read_Unterspannungsbereichsschwelle_ReadData_01()
{
  int64 i64Rte_Ct_MBBL_SsaAppl_Coding_VehicleEquipment;
  ////***********************************Test report header*********************************
  testReportAddMiscInfoBlock("AUTOLIV ELECTRONICS document");
  TestReportAddMiscInfo("Nightly test", "No");
  TestReportAddMiscInfo("Test type", "Requirement-Based test");
  TestReportAddMiscInfo("Regression Test", "No");
  TestReportAddMiscInfo("Fault injection method used", "No");
  TestReportAddMiscInfo("Resource usage evaluation", "No");
  TestReportAddMiscInfo("Priority", "No");
  TestReportAddMiscInfo("Safety relevant", "No");
  
  AddRequirementInfo("Requirement under test", "ARCH_SW_DIA_0027; ARCH_SW_DIA_0140; ARCH_SW_DIA_0141");
  AddRequirementInfo("ARCH_SW_DIA_0027", "Service 0x22 will be implemented for DID 0310");
  AddRequirementInfo("ARCH_SW_DIA_0140", "Response data shall be 2 bytes long");
  AddRequirementInfo("ARCH_SW_DIA_0141", "Data returned shall represent ÃƒÅ“berspannungsabbruchschwelle stored in Rte_Ct_MBBL_SsaAppl_Coding_VehicleEquipment. ÃƒÅ“berspannungsabbruchschwelle");
  ////***************************************************************************************
  
  /*------------------------- Test scenario start ------------------------------*/
  testCaseComment("Preconditions");
  testStep("STEP", "Bench Initialization");
  RunPreTs();
  //====================================================

  testStep("STEP", "Enter development session.");
  EnterDiagnosticSession("development");
  
  testStep("STEP", "Set breakpoint in function *DataServices_Vehicle_Equipment_Read_Unterspannungsbereichsschwelle_ReadData*.");
  debugger_setRelativeFunctionBpAtLine("DataServices_Vehicle_Equipment_Read_Unterspannungsbereichsschwelle_ReadData", 0);
  debugger_run();
 
  testCaseComment("Action: ARCH_SW_DIA_0027; ARCH_SW_DIA_0140; ARCH_SW_DIA_0141");
  testStep("STEP", "Use the Read service 0x22 for DID 0310 and wait for timeout. --> Timeout is occured because breakpoint was reached.");
  SendDiagnosticRequest (dVehicleEquipmentReadRequest, dVehicleEquipmentReadResponse, TRUE);

  debugger_waitUntilBPisReached(5000);
  debugger_isCPUStoppedAtFunction("DataServices_Vehicle_Equipment_Read_Unterspannungsbereichsschwelle_ReadData");
  
  testStep("STEP", "Read Unterspannungsabbruchschwelle bytes of Rte_Ct_MBBL_SsaAppl_Coding_VehicleEquipment --> Byte was read.");
  i64Rte_Ct_MBBL_SsaAppl_Coding_VehicleEquipment = debugger_readGlobalVariable("uint16", "Rte_Ct_MBBL_SsaAppl_Coding_VehicleEquipment,,app.elf", 9);
  EvalManStepEqual("Byte was read", i64Rte_Ct_MBBL_SsaAppl_Coding_VehicleEquipment);
  
  debugger_run();
  debugger_deleteAllBP();
  testStep("STEP", "Use the Read service 0x22 for DID 0310. --> Response is received.");
  SendDiagnosticRequest(dVehicleEquipmentReadRequest, dVehicleEquipmentReadResponse);
  CheckPositiveResponse("", dVehicleEquipmentReadRequest,dVehicleEquipmentReadResponse);
  
  //====================================================
 testCaseComment("Postcondition");
 testStep("STEP", "Return ECU to default values");
  RunPostTs();
}

testcase SW_IT_DIA_DataServices_ZZZ_Vehicle_Equipment_Development_Read_Zykluszeit_Messtechnik_ReadData_01()
{
  int64 i64Rte_Ct_MBBL_SsaAppl_Coding_ZZZ_VehicleEquipment_Development;
  ////***********************************Test report header*********************************
  testReportAddMiscInfoBlock("AUTOLIV ELECTRONICS document");
  TestReportAddMiscInfo("Nightly test", "No");
  TestReportAddMiscInfo("Test type", "Requirement-Based test");
  TestReportAddMiscInfo("Regression Test", "No");
  TestReportAddMiscInfo("Fault injection method used", "No");
  TestReportAddMiscInfo("Resource usage evaluation", "No");
  TestReportAddMiscInfo("Priority", "No");
  TestReportAddMiscInfo("Safety relevant", "No");
  
  AddRequirementInfo("Requirement under test", "ARCH_SW_DIA_0029; ARCH_SW_DIA_0150; ARCH_SW_DIA_0151");
  AddRequirementInfo("ARCH_SW_DIA_0029", "Service 0x22 will be implemented for DID 0311");
  AddRequirementInfo("ARCH_SW_DIA_0150", "Response data shall be 1 byte long");
  AddRequirementInfo("ARCH_SW_DIA_0151", "Data returned shall represent Zykluszeit Messtechnikstored in Rte_Ct_MBBL_SsaAppl_Coding_ZZZ_VehicleEquipment_Development. Zykluszeit_Messtechnik");
  ////***************************************************************************************

  testCaseComment("Preconditions");
  testStep("STEP", "Bench Initialization");
  RunPreTs();
  ////====================================================

  testStep("STEP", "Enter development session.");
  EnterDiagnosticSession("development");
  
  testStep("STEP", "Set breakpoint in function *DataServices_ZZZ_Vehicle_Equipment_Development_Read_Zykluszeit_Messtechnik_ReadData*.");
  debugger_setRelativeFunctionBpAtLine("DataServices_ZZZ_Vehicle_Equipment_Development_Read_Zykluszeit_Messtechnik_ReadData", 18);
  debugger_run();
 
  testCaseComment("Action: ARCH_SW_DIA_0029; ARCH_SW_DIA_0150; ARCH_SW_DIA_0151");
  testStep("STEP", "Send diag request for 22 0311 and wait for timeout error --> Timeout received.");
  SendDiagnosticRequest(dZZZVehicleEquipmentReadRequest, dZZZVehicleEquipmentReadResponse, TRUE);

  testStep("STEP", "Check if breakpoint from function DataServices_ZZZ_Vehicle_Equipment_Development_Read_Zykluszeit_Messtechnik_ReadData was reached. --> BP was reached.");
  debugger_waitUntilBPisReached(5000);
  debugger_isCPUStoppedAtFunction("DataServices_ZZZ_Vehicle_Equipment_Development_Read_Zykluszeit_Messtechnik_ReadData");
  
  
  testStep("STEP", "Read byte Zykluszeit_Messtechnik --> Byte was read.");
  i64Rte_Ct_MBBL_SsaAppl_Coding_ZZZ_VehicleEquipment_Development = debugger_readGlobalVariable("uint8", "Rte_Ct_MBBL_SsaAppl_Coding_ZZZ_VehicleEquipment_Development,,app.elf", 3);
  EvalManStepEqual("Byte was read", i64Rte_Ct_MBBL_SsaAppl_Coding_ZZZ_VehicleEquipment_Development);
  
  ////====================================================
  testCaseComment("Postcondition");
  testStep("STEP", "Return ECU to default values");
  RunPostTs();
}

testcase SW_IT_DIA_DataServices_ZZZ_Vehicle_Equipment_Development_Read_Bitfield_ReadData_01()
{
  int64 i64Rte_Ct_MBBL_SsaAppl_Coding_ZZZ_VehicleEquipment_Development;
  ////***********************************Test report header*********************************
  testReportAddMiscInfoBlock("AUTOLIV ELECTRONICS document");
  TestReportAddMiscInfo("Nightly test", "No");
  TestReportAddMiscInfo("Test type", "Requirement-Based test");
  TestReportAddMiscInfo("Regression Test", "No");
  TestReportAddMiscInfo("Fault injection method used", "No");
  TestReportAddMiscInfo("Resource usage evaluation", "No");
  TestReportAddMiscInfo("Priority", "No");
  TestReportAddMiscInfo("Safety relevant", "No");
  
  AddRequirementInfo("Requirement under test", "ARCH_SW_DIA_0029; ARCH_SW_DIA_0144; ARCH_SW_DIA_0145; ARCH_SW_DIA_0146");
  AddRequirementInfo("ARCH_SW_DIA_0029", "Service 0x22 will be implemented for DID 0311");
  AddRequirementInfo("ARCH_SW_DIA_0144", "Service shall be available in Default, Extended and Development session");
  AddRequirementInfo("ARCH_SW_DIA_0145", "Response data shall be 2 bytes long");
  AddRequirementInfo("ARCH_SW_DIA_0146", "Data returned shall represent Bitfield stored in Rte_Ct_MBBL_SsaAppl_Coding_ZZZ_VehicleEquipment_Development.Bitfield");
  ////***************************************************************************************

  testCaseComment("Preconditions");
  testStep("STEP", "Bench Initialization");
  RunPreTs();
  ////====================================================

  testStep("STEP", "Enter development session.");
  EnterDiagnosticSession("development");
  
  testStep("STEP", "Set breakpoint in function *DataServices_ZZZ_Vehicle_Equipment_Development_Read_Bitfield_ReadData*.");;
  debugger_setRelativeFunctionBpAtLine("DataServices_ZZZ_Vehicle_Equipment_Development_Read_Bitfield_ReadData", 18);
  debugger_run();
 
  testCaseComment("Action: ARCH_SW_DIA_0029; ARCH_SW_DIA_0144; ARCH_SW_DIA_0145; ARCH_SW_DIA_0146");
  testStep("STEP", "Send diag request for 22 0311 and wait for timeout error --> Timeout received.");
  SendDiagnosticRequest(dZZZVehicleEquipmentReadRequest, dZZZVehicleEquipmentReadResponse, TRUE);

  testStep("STEP", "Check if breakpoint from function DataServices_ZZZ_Vehicle_Equipment_Development_Read_Zykluszeit_Messtechnik_ReadData was reached. --> BP was reached.");
  debugger_waitUntilBPisReached(5000);
  debugger_isCPUStoppedAtFunction("DataServices_ZZZ_Vehicle_Equipment_Development_Read_Bitfield_ReadData");
  
  testStep("STEP", "Read byte Bitfield --> Byte was read.");
  i64Rte_Ct_MBBL_SsaAppl_Coding_ZZZ_VehicleEquipment_Development = debugger_readGlobalVariable("uint16", "Rte_Ct_MBBL_SsaAppl_Coding_ZZZ_VehicleEquipment_Development,,app.elf", 0);
  EvalManStepEqual("Byte was read", i64Rte_Ct_MBBL_SsaAppl_Coding_ZZZ_VehicleEquipment_Development);
  
  ////====================================================
  testCaseComment("Postcondition");
  testStep("STEP", "Return ECU to default values");
  RunPostTs();
}

testcase SW_IT_DIA_runDidFD08_ResetCauseManagementRead_01()
{
  ////***********************************Test report header*********************************
  testReportAddMiscInfoBlock("AUTOLIV ELECTRONICS document");
  TestReportAddMiscInfo("Nightly test", "No");
  TestReportAddMiscInfo("Test type", "Requirement-Based test");
  TestReportAddMiscInfo("Regression Test", "Yes");
  TestReportAddMiscInfo("Fault injection method used", "No");
  TestReportAddMiscInfo("Resource usage evaluation", "No");
  TestReportAddMiscInfo("Priority", "No");
  TestReportAddMiscInfo("Safety relevant", "No");
  
  AddRequirementInfo("Requirement under test", "ARCH_SW_DIA_0031; ARCH_SW_DIA_0154; ARCH_SW_DIA_0155; ARCH_SW_DIA_0156");
  AddRequirementInfo("ARCH_SW_DIA_0031", "Service 0x22 will be implemented for DID FD08");
  AddRequirementInfo("ARCH_SW_DIA_0154", "Service shall be available in Development session");
  AddRequirementInfo("ARCH_SW_DIA_0155", "Response data shall be 1 byte long");
  AddRequirementInfo("ARCH_SW_DIA_0156", "Response shall return Last SW Reset Cause");
  //***************************************************************************************
  
  /*------------------------- Test scenario start ------------------------------*/
  testCaseComment("Preconditions");
  testStep("STEP", "Bench Initialization");
  RunPreTs();
  //====================================================

  
 debugger_setRelativeFunctionBpAtLine("DIA_runDidFD08_ResetCauseManagementRead", 0);
  testStep("STEP", "Set breakpoint in the function *DIA_runDidFD08_ResetCauseManagementRead* where the local u32WarmResetCause is assigned the warm reset cause from NVP. --> BP was reached.");
  debugger_run();
 
  testCaseComment("Action: ARCH_SW_DIA_0031; ARCH_SW_DIA_0154; ARCH_SW_DIA_0155; ARCH_SW_DIA_0156");
  testStep("STEP", "Start Development Session.");
  EnterDiagnosticSession("development");
  
  testStep("STEP", "Use the Read service 0x22 for DID FD08 and wait for timeout. --> Timeout is occured because breakpoint was reached.");
  SendDiagnosticRequest (dResetCauseManagementRequest, dResetCauseManagementResponse, TRUE);
  debugger_waitUntilBPisReached(2000);
  debugger_isCPUStoppedAtFunction("DIA_runDidFD08_ResetCauseManagementRead");
  
  debugger_deleteAllBP();
  testStep("STEP", "Overwrite u32WarmResetCause with the mask mapped to the desired warm reset cause. --> Variable overwritten with KU32_OS_EXCEPTION_MASK.");
  debugger_writeGlobalVariable("uint32", "NVP_BLOCK_ID_WARM_RESET_RamBlockData,,app.elf", 0 , 400);
  debugger_run();
  
  testStep("STEP", "Use the Read service 0x22 for DID FD08. --> Response is received.");
  SendDiagnosticRequest(dResetCauseManagementRequest, dResetCauseManagementResponse);
  CheckPositiveResponse("", dResetCauseManagementRequest,dResetCauseManagementResponse);
  
  ////====================================================
  testCaseComment("Postcondition");
  testStep("STEP", "Return ECU to default values");
  RunPostTs();
}


testcase SW_IT_DIA_runDidFD09_LastWarmResetRead_LastDetectedWarmResetCause_01()
{
  int64 i64LastWarmResetCause;
  //***********************************Test report header*********************************
  testReportAddMiscInfoBlock("AUTOLIV ELECTRONICS document");
  TestReportAddMiscInfo("Nightly test", "No");
  TestReportAddMiscInfo("Test type", "Requirement-Based test");
  TestReportAddMiscInfo("Regression Test", "Yes");
  TestReportAddMiscInfo("Fault injection method used", "No");
  TestReportAddMiscInfo("Resource usage evaluation", "No");
  TestReportAddMiscInfo("Priority", "No");
  TestReportAddMiscInfo("Safety relevant", "No");
  
  AddRequirementInfo("Requirement under test", "ARCH_SW_DIA_0032; ARCH_SW_DIA_0157; ARCH_SW_DIA_0158; ARCH_SW_DIA_0159, ARCH_SW_NVP_0011");
  AddRequirementInfo("ARCH_SW_DIA_0032", "Service 0x22 will be implemented for DID FD09.");
  AddRequirementInfo("ARCH_SW_DIA_0157", "Service shall be available in Development session.");
  AddRequirementInfo("ARCH_SW_DIA_0158", "Response data shall be 4 bytes long.");
  AddRequirementInfo("ARCH_SW_DIA_0159", "Response shall return Last Detected Warm Reset Cause.");
  AddRequirementInfo("ARCH_SW_NVP_0011", "NVP_BLOCK_ID_WARM_RESET shall be used to store last warm reset cause and counter.");
  //***************************************************************************************
  
  /*------------------------- Test scenario start ------------------------------*/
  testCaseComment("Preconditions");
  testStep("STEP", "Bench Initialization");
  RunPreTs();
  //====================================================

  EnterDiagnosticSession("development");
  testStep("STEP", "Set breakpoint in function *DIA_runDidFD09_LastWarmResetRead_LastDetectedWarmResetCause*.");
  debugger_setRelativeFunctionBpAtLine("DIA_runDidFD09_LastWarmResetRead_LastDetectedWarmResetCause", 6);
  debugger_run();
 
  testCaseComment("Action: ARCH_SW_DIA_0032; ARCH_SW_DIA_0157; ARCH_SW_DIA_0158; ARCH_SW_DIA_0159, ARCH_SW_NVP_0011");
  testStep("STEP", "Send diag request for 22 FD09 and wait for timeout error --> Timeout received.");
  SendDiagnosticRequest(dReadLastWarmResetParametersRequest, dReadLastWarmResetParametersResponse, TRUE);

  testStep("STEP", "Check if breakpoint from function DIA_runDidFD09_LastWarmResetRead_LastDetectedWarmResetCause was reached. --> BP was reached.");
  debugger_waitUntilBPisReached(5000);
  debugger_isCPUStoppedAtFunction("DIA_runDidFD09_LastWarmResetRead_LastDetectedWarmResetCause");
    
  testStep("STEP", "Read first byte of NVP_BLOCK_ID_WARM_RESET_RamBlockData --> Byte was read.");
  i64LastWarmResetCause = debugger_readGlobalVariable("uint8", "NVP_BLOCK_ID_WARM_RESET_RamBlockData,,app.elf", 0);
  EvalManStepEqual("Warm reset cause received", i64LastWarmResetCause);
  
  //====================================================
  testCaseComment("Postcondition");
  testStep("STEP", "Return ECU to default values");
  RunPostTs();
}

testcase SW_IT_DIA_runDidFD09_LastWarmResetRead_ResetCauseCounter_01()
{
  
  int64 i64LastWarmResetCauseCounter;
  //***********************************Test report header*********************************
  testReportAddMiscInfoBlock("AUTOLIV ELECTRONICS document");
  TestReportAddMiscInfo("Nightly test", "No");
  TestReportAddMiscInfo("Test type", "Requirement-Based test");
  TestReportAddMiscInfo("Regression Test", "No");
  TestReportAddMiscInfo("Fault injection method used", "No");
  TestReportAddMiscInfo("Resource usage evaluation", "No");
  TestReportAddMiscInfo("Priority", "No");
  TestReportAddMiscInfo("Safety relevant", "No");
  
  AddRequirementInfo("Requirement under test", "ARCH_SW_DIA_0032; ARCH_SW_DIA_0160; ARCH_SW_DIA_0161; ARCH_SW_NVP_0011");
  AddRequirementInfo("ARCH_SW_DIA_0032", "Service 0x22 will be implemented for DID FD09.");
  AddRequirementInfo("ARCH_SW_DIA_0160", "Response data shall be 4 bytes long.");
  AddRequirementInfo("ARCH_SW_DIA_0161", "Response shall return Reset Cause Counter.");
  AddRequirementInfo("ARCH_SW_NVP_0011", "NVP_BLOCK_ID_WARM_RESET shall be used to store last warm reset cause and counter.");
  //***************************************************************************************

  testCaseComment("Preconditions");
  testStep("STEP", "Bench Initialization");
  RunPreTs();
  //====================================================

  EnterDiagnosticSession("development");
  testStep("STEP", "Set breakpoint in function *DIA_runDidFD09_LastWarmResetRead_LastDetectedWarmResetCause*.");
  debugger_setRelativeFunctionBpAtLine("DIA_runDidFD09_LastWarmResetRead_LastDetectedWarmResetCause", 6);
  debugger_run();
 
  testCaseComment("Action: ARCH_SW_DIA_0032; ARCH_SW_DIA_0160; ARCH_SW_DIA_0161; ARCH_SW_NVP_0011");
  testStep("STEP", "Send diag request for 22 FD09 and wait for timeout error --> Timeout received.");
  SendDiagnosticRequest(dReadLastWarmResetParametersRequest, dReadLastWarmResetParametersResponse, TRUE);

  testStep("STEP", "Check if breakpoint from function DIA_runDidFD09_LastWarmResetRead_LastDetectedWarmResetCause was reached. --> BP was reached.");
  debugger_waitUntilBPisReached(5000);
  debugger_isCPUStoppedAtFunction("DIA_runDidFD09_LastWarmResetRead_LastDetectedWarmResetCause");
  
  testWaitForTimeout(2000);
  testStep("STEP", "Read 3rd byte of NVP_BLOCK_ID_WARM_RESET_RamBlockData --> Byte was read.");
  i64LastWarmResetCauseCounter = debugger_readGlobalVariable("uint16", "NVP_BLOCK_ID_WARM_RESET_RamBlockData,,app.elf", 1);
  EvalManStepEqual(" Warm reset cause counter read", i64LastWarmResetCauseCounter);
  
  //====================================================
  testCaseComment("Postcondition");
  testStep("STEP", "Return ECU to default values");
  RunPostTs();

}

testcase SW_IT_DIA_runDidFD31_HBCalibrationRead_01()
{
  int64 i64NVP_BLOCK_ID_HB_CALIBRATION_RamBlockData;
  ////***********************************Test report header*********************************
  testReportAddMiscInfoBlock("AUTOLIV ELECTRONICS document");
  TestReportAddMiscInfo("Nightly test", "No");
  TestReportAddMiscInfo("Test type", "Requirement-Based test");
  TestReportAddMiscInfo("Regression Test", "Yes");
  TestReportAddMiscInfo("Fault injection method used", "No");
  TestReportAddMiscInfo("Resource usage evaluation", "No");
  TestReportAddMiscInfo("Priority", "No");
  TestReportAddMiscInfo("Safety relevant", "No");
  
  AddRequirementInfo("Requirement under test", "ARCH_SW_DIA_0033; ARCH_SW_DIA_0162; ARCH_SW_DIA_0163; ARCH_SW_DIA_0164, ARCH_SW_NVP_0002");
  AddRequirementInfo("ARCH_SW_DIA_0033", "Service 0x22 will be implemented for DID FD31.");
  AddRequirementInfo("ARCH_SW_DIA_0162", "Service shall be available in Development session.");
  AddRequirementInfo("ARCH_SW_DIA_0163", "Response data shall be 40 bytes long.");
  AddRequirementInfo("ARCH_SW_DIA_0164", "Response data shall return HB Calibration parameters stored in NVP_BLOCK_ID_HB_CALIBRATION.");
  AddRequirementInfo("ARCH_SW_NVP_0002", "NVP_BLOCK_ID_HB_CALIBRATION shall be configured.");
  //***************************************************************************************
  
  /*------------------------- Test scenario start ------------------------------*/
  testCaseComment("Preconditions");
  testStep("STEP", "Bench Initialization");
  RunPreTs();
  //====================================================

  testStep("STEP", "Set breakpoint in function *DIA_runDidFD31_HBCalibrationRead*.");
  debugger_setRelativeFunctionBpAtLine("DIA_runDidFD31_HBCalibrationRead", 4);
  debugger_run();
 
  testStep("STEP", "Start Development Session.");
  EnterDiagnosticSession("development");
  
  testCaseComment("Action: ARCH_SW_DIA_0033; ARCH_SW_DIA_0162; ARCH_SW_DIA_0163; ARCH_SW_DIA_0164, ARCH_SW_NVP_0002");
  testStep("STEP", "Send diag request for 22 FD31 and wait for timeout error --> Timeout received.");
  SendDiagnosticRequest(dReadECUCalibParamRequest, dReadECUCalibParamResponse, TRUE);

  testStep("STEP", "Check if breakpoint from function DIA_runDidFD31_HBCalibrationRead was reached. --> BP was reached.");
  debugger_waitUntilBPisReached(5000);
  debugger_isCPUStoppedAtFunction("DIA_runDidFD31_HBCalibrationRead");
  
  testStep("STEP", "Read first byte of NVP_BLOCK_ID_HB_CALIBRATION_RamBlockData --> Byte was read.");
  i64NVP_BLOCK_ID_HB_CALIBRATION_RamBlockData = debugger_readGlobalVariable("uint8", "NVP_BLOCK_ID_HB_CALIBRATION_RamBlockData,,app.elf", 0);
  
  testStep("STEP", "Read last byte (index = 39) of NVP_BLOCK_ID_HB_CALIBRATION_RamBlockData --> Byte was read.");
  i64NVP_BLOCK_ID_HB_CALIBRATION_RamBlockData = debugger_readGlobalVariable("uint8", "NVP_BLOCK_ID_HB_CALIBRATION_RamBlockData,,app.elf", 39);
  
  debugger_deleteAllBP();
  debugger_run();
  testStep("STEP", "Use the Read service 0x22 for DID FD31. --> Response is received.");
  SendDiagnosticRequest(dReadECUCalibParamRequest, dReadECUCalibParamResponse);
  CheckPositiveResponse("", dReadECUCalibParamRequest,dReadECUCalibParamResponse);
  
  ////====================================================
  testCaseComment("Postcondition");
  testStep("STEP", "Return ECU to default values");
  RunPostTs();
}


testcase SW_IT_DIA_runDidFE00_AECStatusRead_01()
{
  int64 i64AEC_id = 0;
  int64 i64AEC_status = 0;
  ////***********************************Test report header*********************************
  testReportAddMiscInfoBlock("AUTOLIV ELECTRONICS document");
  TestReportAddMiscInfo("Nightly test", "No");
  TestReportAddMiscInfo("Test type", "Requirement-Based test");
  TestReportAddMiscInfo("Regression Test", "No");
  TestReportAddMiscInfo("Fault injection method used", "No");
  TestReportAddMiscInfo("Resource usage evaluation", "No");
  TestReportAddMiscInfo("Priority", "No");
  TestReportAddMiscInfo("Safety relevant", "No");
  
  AddRequirementInfo("Requirement under test", "ARCH_SW_DIA_0035; ARCH_SW_DIA_0165; ARCH_SW_DIA_0166");
  AddRequirementInfo("ARCH_SW_DIA_0035", "Service 0x22 will be implemented for DID FE00");
  AddRequirementInfo("ARCH_SW_DIA_0165", "Service shall be available in Development session");
  AddRequirementInfo("ARCH_SW_DIA_0166", "Response data shall return AEC_ID_X and Status_X of said AEC");

  
  ////***************************************************************************************

  testCaseComment("Preconditions");
  testStep("STEP", "Bench Initialization");
  RunPreTs();
  ////====================================================

  testStep("STEP", "Start Development Session.");
  EnterDiagnosticSession("development");
  
  testStep("STEP", "Set breakpoint in function *DIA_runDidFE00_AECStatusRead*.");
  debugger_setRelativeFunctionBpAtLine("DIA_runDidFE00_AECStatusRead", 28);
  debugger_run();
 
  testCaseComment("Action: ARCH_SW_DIA_0035; ARCH_SW_DIA_0165; ARCH_SW_DIA_0166");
  testStep("STEP", "Send diag request for 22 FE00 and wait for timeout error --> Timeout received.");
  SendDiagnosticRequest(dReadAllAECStatusRequest, dReadAllAECStatusResponse, TRUE);

  testwaitforTimeout(1000);
  testStep("STEP", "Check if breakpoint from function DIA_runDidFE00_AECStatusRead was reached. --> BP was reached.");
  debugger_waitUntilBPisReached(5000);
  debugger_isCPUStoppedAtFunction("DIA_runDidFE00_AECStatusRead");
  
  testStep("STEP", "Read AEC_ID. --> Byte was read");
  i64AEC_id = debugger_readLocalVariable("u8EventID");
  EvalManStepEqual("Byte was read", i64AEC_id);
  
  testStep("STEP", "Read AEC_Status. --> Byte was read");
  i64AEC_status = debugger_readLocalVariable("*(Data)");
  EvalManStepEqual("Byte was read", i64AEC_status);
  
  ////====================================================
  testCaseComment("Postcondition");
  testStep("STEP", "Return ECU to default values");
  RunPostTs();
}


testcase SW_IT_DIA_runDidFE00_AECStatusReadDataLength_01()
{
  ////***********************************Test report header*********************************
  testReportAddMiscInfoBlock("AUTOLIV ELECTRONICS document");
  TestReportAddMiscInfo("Nightly test", "No");
  TestReportAddMiscInfo("Test type", "Requirement-Based test");
  TestReportAddMiscInfo("Regression Test", "No");
  TestReportAddMiscInfo("Fault injection method used", "No");
  TestReportAddMiscInfo("Resource usage evaluation", "No");
  TestReportAddMiscInfo("Priority", "No");
  TestReportAddMiscInfo("Safety relevant", "No");
  
  AddRequirementInfo("Requirement under test", "ARCH_SW_DIA_0035; ARCH_SW_DIA_0167");
  AddRequirementInfo("ARCH_SW_DIA_0035", "Service 0x22 will be implemented for DID FE00");
  AddRequirementInfo("ARCH_SW_DIA_0166", "Response data shall return AEC_ID_X and Status_X of said AEC");

  ////***************************************************************************************

  testCaseComment("Preconditions");
  testStep("STEP", "Bench Initialization");
  RunPreTs();
  ////====================================================

  testStep("STEP", "Start Development Session.");
  EnterDiagnosticSession("development");
  
  testCaseComment("Action: ARCH_SW_DIA_0035; ARCH_SW_DIA_0167");
  testStep("STEP", "Set BP in function *DIA_runDidF18C_EcuSerialNumberReadDataLength* --> BP was reached.");
  debugger_setRelativeFunctionBpAtLine("DIA_runDidFE00_AECStatusReadDataLength", 4);
  
  testStep("STEP", "Send diag request for 22 FE00 and wait for timeout error --> Timeout received.");
  debugger_run();
  SendDiagnosticRequest(dReadAllAECStatusRequest, dReadAllAECStatusResponse, TRUE);
  debugger_waitUntilBPisReached(5000);
  
  testStep("STEP", "Evaluate response data lenght. --> response data lenght is 168.");
  diagResponseDataLenght = debugger_readLocalVariable("*DataLength");
  EvalManStepEqual("Response lenght is 168", diagResponseDataLenght, 168);
  
  ////====================================================
  testCaseComment("Postcondition");
  testStep("STEP", "Return ECU to default values");
  RunPostTs();
}

testcase SW_IT_DIA_runDidFEFF_MeasuruementFrameConfigurationRead_01()
{
  int64 i64NVP_BLOCK_ID_MEASUREMENT_FRAME_CONFIG_RamBlockData;
  ////***********************************Test report header*********************************
  testReportAddMiscInfoBlock("AUTOLIV ELECTRONICS document");
  TestReportAddMiscInfo("Nightly test", "No");
  TestReportAddMiscInfo("Test type", "Requirement-Based test");
  TestReportAddMiscInfo("Regression Test", "Yes");
  TestReportAddMiscInfo("Fault injection method used", "No");
  TestReportAddMiscInfo("Resource usage evaluation", "No");
  TestReportAddMiscInfo("Priority", "No");
  TestReportAddMiscInfo("Safety relevant", "No");
  
  AddRequirementInfo("Requirement under test", "ARCH_SW_DIA_0036; ARCH_SW_DIA_0168; ARCH_SW_DIA_0169; ARCH_SW_DIA_0170, ARCH_SW_NVP_0012; ARCH_SW_DIA_0038");
  AddRequirementInfo("ARCH_SW_DIA_0036", "Service 0x22 will be implemented for DID FEFF.");
  AddRequirementInfo("ARCH_SW_DIA_0168", "Service shall be available in Development session.");
  AddRequirementInfo("ARCH_SW_DIA_0169", "Response data shall be 4 bytes long.");
  AddRequirementInfo("ARCH_SW_DIA_0170", "Response shall return Timing and Block Config stored in NVP_BLOCK_ID_MEASUREMENT_FRAME_CONFIG.");
  AddRequirementInfo("ARCH_SW_NVP_0012", "NVP_BLOCK_ID_MEASUREMENT_FRAME_CONFIG shall be used to configure measurement frames blocks. ");
  AddRequirementInfo("ARCH_SW_DIA_0038", "Service 0x2E will be implemented for DID FEFF. ");
  //***************************************************************************************
  
  /*------------------------- Test scenario start ------------------------------*/
  testCaseComment("Preconditions");
  testStep("STEP", "Bench Initialization");
  RunPreTs();
  //====================================================

  testStep("STEP", "Set breakpoint in function *DIA_runDidFEFF_MeasuruementFrameConfigurationRead*.");
  debugger_setRelativeFunctionBpAtLine("DIA_runDidFEFF_MeasuruementFrameConfigurationRead", 4);
  debugger_run();
 
  testStep("STEP", "Start Development Session.");
  EnterDiagnosticSession("development");
  
  testCaseComment("Action: ARCH_SW_DIA_0036; ARCH_SW_DIA_0168; ARCH_SW_DIA_0169; ARCH_SW_DIA_0170, ARCH_SW_NVP_0012; ARCH_SW_DIA_0038;");
  testStep("STEP", "Send diag request for 22 FEFF and wait for timeout error --> Timeout received.");
  SendDiagnosticRequest(dMeasurementFrameReadRequest, dMeasurementFrameReadResponse, TRUE);
  
  testStep("STEP", "Check if breakpoint from function DIA_runDidFEFF_MeasuruementFrameConfigurationRead was reached. --> BP was reached.");
  debugger_waitUntilBPisReached(5000);
  debugger_isCPUStoppedAtFunction("DIA_runDidFEFF_MeasuruementFrameConfigurationRead");
  
  testStep("STEP", "Read first byte (NVP_u8MeasFrameTiming) of NVP_BLOCK_ID_MEASUREMENT_FRAME_CONFIG_RamBlockData --> Byte was read.");
  i64NVP_BLOCK_ID_MEASUREMENT_FRAME_CONFIG_RamBlockData = debugger_readGlobalVariable("uint8", "NVP_BLOCK_ID_MEASUREMENT_FRAME_CONFIG_RamBlockData,,app.elf", 0);
  EvalManStepEqual("Evaluate byte.", debugger_variable);
  
  testStep("STEP", "Read 4th byte of (NVP_au8MeasFrameBlockConfig) of NVP_BLOCK_ID_MEASUREMENT_FRAME_CONFIG_RamBlockData --> Byte was read.");
  i64NVP_BLOCK_ID_MEASUREMENT_FRAME_CONFIG_RamBlockData = debugger_readGlobalVariable("uint8", "NVP_BLOCK_ID_MEASUREMENT_FRAME_CONFIG_RamBlockData,,app.elf", 3);
  EvalManStepEqual("Evaluate byte.", debugger_variable);
  
  debugger_deleteAllBP();
  debugger_run();
  testStep("STEP", "Use the Read service 0x22 for DID FEFF. --> Response is received.");
  SendDiagnosticRequest(dMeasurementFrameReadRequest, dMeasurementFrameReadResponse);
  CheckPositiveResponse("", dMeasurementFrameReadRequest,dMeasurementFrameReadResponse);
  
  ////====================================================
  testCaseComment("Postcondition");
  testStep("STEP", "Return ECU to default values");
  RunPostTs();
}

testcase SW_IT_DIA_runDidFDFF_MeasurementFrameBlock12ConfigRead_01()
{
  int64 i64NVP_BLOCK_ID_MEASUREMENT_FRAME_12_CONFIG_DefaultData;
  ////***********************************Test report header*********************************
  testReportAddMiscInfoBlock("AUTOLIV ELECTRONICS document");
  TestReportAddMiscInfo("Nightly test", "No");
  TestReportAddMiscInfo("Test type", "Requirement-Based test");
  TestReportAddMiscInfo("Regression Test", "Yes");
  TestReportAddMiscInfo("Fault injection method used", "No");
  TestReportAddMiscInfo("Resource usage evaluation", "No");
  TestReportAddMiscInfo("Priority", "No");
  TestReportAddMiscInfo("Safety relevant", "No");
  
  AddRequirementInfo("Requirement under test", "ARCH_SW_DIA_0037; ARCH_SW_DIA_0171; ARCH_SW_DIA_0172; ARCH_SW_DIA_0173");
  AddRequirementInfo("ARCH_SW_DIA_0037", "Service 0x22 will be implemented for DID FDFF");
  AddRequirementInfo("ARCH_SW_DIA_0171", "Service shall be available in Development session");
  AddRequirementInfo("ARCH_SW_DIA_0172", "Response data shall be 5 bytes long");
  AddRequirementInfo("ARCH_SW_DIA_0173", "Response shall return Ram Address and Size stored in NVP_BLOCK_ID_MEASUREMENT_FRAME_12_CONFIG");
  //***************************************************************************************
  
  /*------------------------- Test scenario start ------------------------------*/
  testCaseComment("Preconditions");
  testStep("STEP", "Bench Initialization");
  RunPreTs();
  //====================================================

  testStep("STEP", "Set breakpoint in function *DIA_runDidFDFF_MeasurementFrameBlock12ConfigRead*.");
  debugger_setRelativeFunctionBpAtLine("DIA_runDidFDFF_MeasurementFrameBlock12ConfigRead", 4);
  debugger_run();
 
  testStep("STEP", "Start Development Session.");
  EnterDiagnosticSession("development");
  
  testCaseComment("Action: ARCH_SW_DIA_0037; ARCH_SW_DIA_0171; ARCH_SW_DIA_0172; ARCH_SW_DIA_0173");
  testStep("STEP", "Send diag request for 22 FDFF and wait for timeout error --> Timeout received.");
  SendDiagnosticRequest(dReadMFBlock12ConfigRequest, dReadMFBlock12ConfigResponse, TRUE);

  testStep("STEP", "Check if breakpoint from function DIA_runDidFDFF_MeasurementFrameBlock12ConfigRead was reached. --> BP was reached.");
  debugger_waitUntilBPisReached(5000);
  
  
  testStep("STEP", "Read 1st of variable NVP_u32MeasFrame12RAMAddress of NVP_BLOCK_ID_MEASUREMENT_FRAME_12_CONFIG_DefaultData --> Variable read.");
  i64NVP_BLOCK_ID_MEASUREMENT_FRAME_12_CONFIG_DefaultData = debugger_readGlobalVariable("uint32", "NVP_BLOCK_ID_MEASUREMENT_FRAME_12_CONFIG_DefaultData,,app.elf", 0);
  EvalManStepEqual("Evaluate byte", debugger_variable);
  
  testStep("STEP", "Read 5th of variable of NVP_u8BlockSize NVP_BLOCK_ID_MEASUREMENT_FRAME_12_CONFIG_DefaultData --> Variable read.");
  i64NVP_BLOCK_ID_MEASUREMENT_FRAME_12_CONFIG_DefaultData = debugger_readGlobalVariable("uint8", "NVP_BLOCK_ID_MEASUREMENT_FRAME_12_CONFIG_DefaultData,,app.elf", 4);
  EvalManStepEqual("Evaluate byte", debugger_variable);
  
  debugger_deleteAllBP();
  debugger_run();
  testStep("STEP", "Use the Read service 0x22 for DID FDFF. --> Response is received.");
  SendDiagnosticRequest(dReadMFBlock12ConfigRequest, dReadMFBlock12ConfigResponse);
  CheckPositiveResponse("", dReadMFBlock12ConfigRequest,dReadMFBlock12ConfigResponse);
  
  ////====================================================
  testCaseComment("Postcondition");
  testStep("STEP", "Return ECU to default values");
  RunPostTs();
}

testcase SW_IT_DIA_runDid0142_AvailabilityDataRead_01()
{
  int64 pi64Data;
  ////***********************************Test report header*********************************
  testReportAddMiscInfoBlock("AUTOLIV ELECTRONICS document");
  TestReportAddMiscInfo("Nightly test", "No");
  TestReportAddMiscInfo("Test type", "Requirement-Based test");
  TestReportAddMiscInfo("Regression Test", "No");
  TestReportAddMiscInfo("Fault injection method used", "No");
  TestReportAddMiscInfo("Resource usage evaluation", "No");
  TestReportAddMiscInfo("Priority", "No");
  TestReportAddMiscInfo("Safety relevant", "No");
  
  AddRequirementInfo("Requirement under test", "ARCH_SW_DIA_0235; ARCH_SW_DIA_0236; ARCH_SW_DIA_0237; ARCH_SW_DIA_0238; ARCH_SW_DIA_0336; ARCH_SW_DIA_0337");
  AddRequirementInfo("ARCH_SW_DIA_0235", "Service 0x22 (Read Data By Identifier) will be implemented for DID 0x0142 (Availability Data)");
  AddRequirementInfo("ARCH_SW_DIA_0236", "Service shall be available in Default session, Extended session Update session and Development session");
  AddRequirementInfo("ARCH_SW_DIA_0237", "Service shall be available in the following forms of Authentication: Development ENHANCED, Production After-Sales ENHANCED, After-Sales After-Sales BASIC, Internal Diagnostic Test Tool, ePTI Test Tol");
  AddRequirementInfo("ARCH_SW_DIA_0238", "Result can have the following values: 0x00, 0x01 and 0x02");
  AddRequirementInfo("ARCH_SW_DIA_0337", "Positive Response: Green no DTC or DTC without Warning indicator. Yellow is not used Red Display message is requested -> DTC with Warning indicator is set");
  
  ////***************************************************************************************

  testCaseComment("Preconditions");
  testStep("STEP", "Bench Initialization");
  RunPreTs();
  ////====================================================

  testStep("STEP", "Set breakpoint in function *DIA_runDid0142_AvailabilityDataRead*.");
  debugger_setRelativeFunctionBpAtLine("DIA_runDid0142_AvailabilityDataRead", 6);
  debugger_run();
 
  testCaseComment("Action: ARCH_SW_DIA_0235; ARCH_SW_DIA_0236; ARCH_SW_DIA_0237; ARCH_SW_DIA_0238; ARCH_SW_DIA_0336; ARCH_SW_DIA_0337");
  testStep("STEP", "Send diag request for 22 0142 and wait for timeout error --> Timeout received.");
  SendDiagnosticRequest(dAvailabilityDataReadRequest, dAvailabilityDataReadResponse, TRUE);

  testWaitForTimeout(2000);
  testStep("STEP", "Check if breakpoint from function DIA_runDid0142_AvailabilityDataRead was reached. --> BP was reached.");
  debugger_waitUntilBPisReached(5000);
  debugger_isCPUStoppedAtFunction("DIA_runDid0142_AvailabilityDataRead");
  
  testStep("STEP", "Evaluate *Data pointer --> Byte was read.");
  pi64Data = debugger_readLocalVariable("*Data");
  EvalManStepEqual("Data pointer read", pi64Data);

  ////====================================================
  testCaseComment("Postcondition");
  testStep("STEP", "Return ECU to default values");
  RunPostTs();
}

testcase SW_IT_DIA_runDid0241_PRE_SAFE_Recorder_1_ReadDataLength_01()
{

  //***********************************Test report header*********************************
  testReportAddMiscInfoBlock("AUTOLIV ELECTRONICS document");
  TestReportAddMiscInfo("Nightly test", "No");
  TestReportAddMiscInfo("Test type", "Requirement-Based test");
  TestReportAddMiscInfo("Regression Test", "No");
  TestReportAddMiscInfo("Fault injection method used", "No");
  TestReportAddMiscInfo("Resource usage evaluation", "No");
  TestReportAddMiscInfo("Priority", "No");
  TestReportAddMiscInfo("Safety relevant", "No");
  
  AddRequirementInfo("Requirement under test", "ARCH_SW_DIA_0240; ARCH_SW_DIA_0246; ARCH_SW_DIA_0247");
  AddRequirementInfo("ARCH_SW_DIA_0240", "Service 0x22 (Read Data By Identifier) & 0x2E (Write Data By Identifier) for DID 0x0241 will be implemented");
  AddRequirementInfo("ARCH_SW_DIA_0241", "Service shall be available in Default session, Extended session Update session and Development session");
  AddRequirementInfo("ARCH_SW_DIA_0242", "Service shall be available in the following forms of Authentication: Development ENHANCED, Production After-Sales ENHANCED, After-Sales After-Sales BASIC, Internal Diagnostic Test Tool, ePTI Test Tool");
  AddRequirementInfo("ARCH_SW_DIA_0243", "Response data shall be 22 bytes long");
  
  //***************************************************************************************

  testCaseComment("Preconditions");
  testStep("STEP", "Bench Initialization");
  RunPreTs();
  //====================================================

  testStep("STEP", "Set breakpoint in function *DIA_runDid0241_PRE_SAFE_Recorder_1_ReadDataLength*.");
  debugger_setRelativeFunctionBpAtLine("DIA_runDid0241_PRE_SAFE_Recorder_1_ReadDataLength", 4);
  debugger_run();
  
  testStep("STEP", "Send diag request for 22 02 41, and wait for timeout error. --> Timeout error.");
  SendDiagnosticRequest(dPresafeRecorder1ReadRequest, dPresafeRecorder1ReadResponse, TRUE);
  debugger_waitUntilBPisReached(5000);
  debugger_isCPUStoppedAtFunction("DIA_runDid0241_PRE_SAFE_Recorder_1_ReadDataLength");
  
  testStep("STEP", "Evaluate response data lenght. --> response data lenght is 22.");
  diagResponseDataLenght = debugger_readLocalVariable("*DataLength");
  EvalManStepEqual("Response lenght is 22", diagResponseDataLenght, 22);
  
  //====================================================
  testCaseComment("Postcondition");
  testStep("STEP", "Return ECU to default values");
  RunPostTs();
}

testcase SW_IT_DIA_runDid0241_PRE_SAFE_Recorder_1_ConditionCheckRead_01()
{

  //***********************************Test report header*********************************
  testReportAddMiscInfoBlock("AUTOLIV ELECTRONICS document");
  TestReportAddMiscInfo("Nightly test", "No");
  TestReportAddMiscInfo("Test type", "Requirement-Based test");
  TestReportAddMiscInfo("Regression Test", "No");
  TestReportAddMiscInfo("Fault injection method used", "No");
  TestReportAddMiscInfo("Resource usage evaluation", "No");
  TestReportAddMiscInfo("Priority", "No");
  TestReportAddMiscInfo("Safety relevant", "No");
  
  AddRequirementInfo("Requirement under test", "ARCH_SW_DIA_0240; ARCH_SW_DIA_0244; ARCH_SW_DIA_0245;");
  AddRequirementInfo("ARCH_SW_DIA_0240", "Service 0x22 (Read Data By Identifier) & 0x2E (Write Data By Identifier) for DID 0x0241 will be implemented");
  AddRequirementInfo("ARCH_SW_DIA_0244", "Service shall be available in Default session, Extended session Update session and Development session");
  AddRequirementInfo("ARCH_SW_DIA_0245", "Service shall be available in the following forms of Authentication:Development ENHANCED, Production After-Sales ENHANCED, After-Sales After-Sales BASIC, Internal Diagnostic Test Tool, ePTI Test Tool");
  
  //***************************************************************************************

  testCaseComment("Preconditions");
  testStep("STEP", "Bench Initialization");
  RunPreTs();
  //====================================================

  testStep("STEP", "Start Development Session.");
  EnterDiagnosticSession("development");
  
  testCaseComment("Action: ARCH_SW_DIA_0240; ARCH_SW_DIA_0244; ARCH_SW_DIA_0245;");
  testStep("STEP", "Send diag request for 22 0241 and wait for timeout error --> Timeout received.");
  SendDiagnosticRequest(dPresafeRecorder1ReadRequest, dPresafeRecorder1ReadResponse, TRUE);
  CheckPositiveResponse("", dPresafeRecorder1ReadRequest, dPresafeRecorder1ReadResponse);


  //====================================================
  testCaseComment("Postcondition");
  testStep("STEP", "Return ECU to default values");
  RunPostTs();
}

testcase SW_IT_DIA_runDid0241_PRE_SAFE_Recorder_1_ReadData_01()
{
  int64 i64NVP_BLOCK_ID_PRE_SAFE_RECORDER_1_RamBlockData;
  ////***********************************Test report header*********************************
  testReportAddMiscInfoBlock("AUTOLIV ELECTRONICS document");
  TestReportAddMiscInfo("Nightly test", "No");
  TestReportAddMiscInfo("Test type", "Requirement-Based test");
  TestReportAddMiscInfo("Regression Test", "No");
  TestReportAddMiscInfo("Fault injection method used", "No");
  TestReportAddMiscInfo("Resource usage evaluation", "No");
  TestReportAddMiscInfo("Priority", "No");
  TestReportAddMiscInfo("Safety relevant", "No");
  
  AddRequirementInfo("Requirement under test", "ARCH_SW_DIA_0240; ARCH_SW_DIA_0246; ARCH_SW_DIA_0247, ARCH_SW_NVP_0015");
  AddRequirementInfo("ARCH_SW_DIA_0240", "Service 0x22 (Read Data By Identifier) & 0x2E (Write Data By Identifier) for DID 0x0241 will be implemented");
  AddRequirementInfo("ARCH_SW_DIA_0246", "Service shall be available in Default session, Extended session Update session and Development session");
  AddRequirementInfo("ARCH_SW_DIA_0247", "Service shall be available in the following forms of Authentication: Development ENHANCED, Production After-Sales ENHANCED, After-Sales After-Sales BASIC, Internal Diagnostic Test Tool, ePTI Test Tool");

  ////***************************************************************************************

  testCaseComment("Preconditions");
  testStep("STEP", "Bench Initialization");
  RunPreTs();
  ////====================================================

  testStep("STEP", "Start Development Session.");
  EnterDiagnosticSession("development");
  
  testStep("STEP", "Set breakpoint in function *DIA_runDid0241_PRE_SAFE_Recorder_1_ReadData*.");
  debugger_setRelativeFunctionBpAtLine("DIA_runDid0241_PRE_SAFE_Recorder_1_ReadData", 4);
  debugger_run();
 
  testCaseComment("Action: ARCH_SW_DIA_0240; ARCH_SW_DIA_0246; ARCH_SW_DIA_0247, ARCH_SW_NVP_0015");
  testStep("STEP", "Send diag request for 22 0241 and wait for timeout error --> Timeout received.");
  SendDiagnosticRequest(dPresafeRecorder1ReadRequest, dPresafeRecorder1ReadResponse, TRUE);

  testWaitForTimeout(2000);
  testStep("STEP", "Check if breakpoint from function DIA_runDid0241_PRE_SAFE_Recorder_1_ReadData was reached. --> BP was reached.");
  debugger_waitUntilBPisReached(5000);
  debugger_isCPUStoppedAtFunction("DIA_runDid0241_PRE_SAFE_Recorder_1_ReadData");
  
  
  testStep("STEP", "Evaluate NVP_BLOCK_ID_PRE_SAFE_RECORDER_1_RamBlockData --> Byte was read.");
  i64NVP_BLOCK_ID_PRE_SAFE_RECORDER_1_RamBlockData = debugger_readGlobalVariable("uint8", "NVP_BLOCK_ID_PRE_SAFE_RECORDER_1_RamBlockData,,app.elf", 0);
  EvalManStepEqual("Byte read", i64NVP_BLOCK_ID_PRE_SAFE_RECORDER_1_RamBlockData);

  ////====================================================
  testCaseComment("Postcondition");
  testStep("STEP", "Return ECU to default values");
  RunPostTs();
}

testcase SW_IT_DIA_runDid0242_PRE_SAFE_Recorder_2_ReadDataLength_01()
{
  ////***********************************Test report header*********************************
  testReportAddMiscInfoBlock("AUTOLIV ELECTRONICS document");
  TestReportAddMiscInfo("Nightly test", "No");
  TestReportAddMiscInfo("Test type", "Requirement-Based test");
  TestReportAddMiscInfo("Regression Test", "No");
  TestReportAddMiscInfo("Fault injection method used", "No");
  TestReportAddMiscInfo("Resource usage evaluation", "No");
  TestReportAddMiscInfo("Priority", "No");
  TestReportAddMiscInfo("Safety relevant", "No");
  
  AddRequirementInfo("Requirement under test", "ARCH_SW_DIA_0250; ARCH_SW_DIA_0251; ARCH_SW_DIA_0252; ARCH_SW_DIA_0253");
  AddRequirementInfo("ARCH_SW_DIA_0250", "Service 0x22 (Read Data By Identifier) & 0x2E (Write Data By Identifier) for DID 0x0242 will be implemented");
  AddRequirementInfo("ARCH_SW_DIA_0251", "Service shall be available in Default session, Extended session Update session and Development session");
  AddRequirementInfo("ARCH_SW_DIA_0252", "Service shall be available in the following forms of Authentication: Development ENHANCED, Production After-Sales ENHANCED, After-Sales After-Sales BASIC, Internal Diagnostic Test Tool, ePTI Test Tool");
  AddRequirementInfo("ARCH_SW_DIA_0253", "Response data shall be 22 bytes long");
  
  ////***************************************************************************************

  testCaseComment("Preconditions");
  testStep("STEP", "Bench Initialization");
  RunPreTs();
  ////====================================================

  testStep("STEP", "Start Development Session.");
  EnterDiagnosticSession("development");
  
  testStep("STEP", "Set breakpoint in function *DIA_runDid0241_PRE_SAFE_Recorder_2_ReadDataLength*.");
  debugger_setRelativeFunctionBpAtLine("DIA_runDid0242_PRE_SAFE_Recorder_2_ReadDataLength", 4);
  debugger_run();
  
  testStep("STEP", "Send diag request for 22 02 42, and wait for timeout error. --> Timeout error.");
  SendDiagnosticRequest(dPresafeRecorder2ReadRequest, dPresafeRecorder2ReadResponse, TRUE);
  debugger_waitUntilBPisReached(5000);
  debugger_isCPUStoppedAtFunction("DIA_runDid0241_PRE_SAFE_Recorder_2_ReadDataLength");
  
  testStep("STEP", "Evaluate response data lenght. --> response data lenght is 22.");
  diagResponseDataLenght = debugger_readLocalVariable("*DataLength");
  EvalManStepEqual("Response lenght is 22", diagResponseDataLenght, 22);

  ////====================================================
  testCaseComment("Postcondition");
  testStep("STEP", "Return ECU to default values");
  RunPostTs();
}

testcase SW_IT_DIA_runDid0242_PRE_SAFE_Recorder_2_ConditionCheckRead_01()
{
  //***********************************Test report header*********************************
  testReportAddMiscInfoBlock("AUTOLIV ELECTRONICS document");
  TestReportAddMiscInfo("Nightly test", "No");
  TestReportAddMiscInfo("Test type", "Requirement-Based test");
  TestReportAddMiscInfo("Regression Test", "No");
  TestReportAddMiscInfo("Fault injection method used", "No");
  TestReportAddMiscInfo("Resource usage evaluation", "No");
  TestReportAddMiscInfo("Priority", "No");
  TestReportAddMiscInfo("Safety relevant", "No");
  
  AddRequirementInfo("Requirement under test", "ARCH_SW_DIA_0250; ARCH_SW_DIA_0254; ARCH_SW_DIA_0255");
  AddRequirementInfo("ARCH_SW_DIA_0250", "Service 0x22 (Read Data By Identifier) & 0x2E (Write Data By Identifier) for DID 0x0242 will be implemented");
  AddRequirementInfo("ARCH_SW_DIA_0254", "Service shall be available in Default session, Extended session Update session and Development session");
  AddRequirementInfo("ARCH_SW_DIA_0255", "Service shall be available in the following forms of Authentication: Development ENHANCED, Production After-Sales ENHANCED, After-Sales After-Sales BASIC, Internal Diagnostic Test Tool, ePTI Test Tool");
  
  //***************************************************************************************

  testCaseComment("Preconditions");
  testStep("STEP", "Bench Initialization");
  RunPreTs();
  //====================================================

  testStep("STEP", "Start Development Session.");
  EnterDiagnosticSession("development");
  
  testStep("STEP", "Set breakpoint in function *DIA_runDid0242_PRE_SAFE_Recorder_2_ConditionCheckRead*.");
  debugger_setRelativeFunctionBpAtLine("DIA_runDid0242_PRE_SAFE_Recorder_2_ConditionCheckRead", 0);
  debugger_run();
 
  testCaseComment("Action: ARCH_SW_DIA_0250; ARCH_SW_DIA_0254; ARCH_SW_DIA_0255");
  testStep("STEP", "Send diag request for 22 0242 and wait for timeout error --> Timeout received.");
  SendDiagnosticRequest(dPresafeRecorder2ReadRequest, dPresafeRecorder2ReadResponse, TRUE);

  testWaitForTimeout(2000);
  testStep("STEP", "Check if breakpoint from function DIA_runDid0242_PRE_SAFE_Recorder_2_ConditionCheckRead was reached. --> BP was reached.");
  debugger_waitUntilBPisReached(5000);
  debugger_isCPUStoppedAtFunction("DIA_runDid0242_PRE_SAFE_Recorder_2_ConditionCheckRead");
  

  //====================================================
  testCaseComment("Postcondition");
  testStep("STEP", "Return ECU to default values");
  RunPostTs();
}

testcase SW_IT_DIA_runDid0242_PRE_SAFE_Recorder_2_ReadData_01()
{
  int64 i64NVP_BLOCK_ID_PRE_SAFE_RECORDER_2_RamBlockData;
  ////***********************************Test report header*********************************
  testReportAddMiscInfoBlock("AUTOLIV ELECTRONICS document");
  TestReportAddMiscInfo("Nightly test", "No");
  TestReportAddMiscInfo("Test type", "Requirement-Based test");
  TestReportAddMiscInfo("Regression Test", "No");
  TestReportAddMiscInfo("Fault injection method used", "No");
  TestReportAddMiscInfo("Resource usage evaluation", "No");
  TestReportAddMiscInfo("Priority", "No");
  TestReportAddMiscInfo("Safety relevant", "No");
  
  AddRequirementInfo("Requirement under test", "ARCH_SW_DIA_0250; ARCH_SW_DIA_0256; ARCH_SW_DIA_0257, ARCH_SW_NVP_0016");
  AddRequirementInfo("ARCH_SW_DIA_0250", "Service 0x22 (Read Data By Identifier) & 0x2E (Write Data By Identifier) for DID 0x0242 will be implemented.");
  AddRequirementInfo("ARCH_SW_DIA_0256", "Service shall be available in Default session, Extended session");
  AddRequirementInfo("ARCH_SW_DIA_0257", "Service shall be available in the following forms of Authentication: Development ENHANCED, Production After-Sales ENHANCED, After-Sales After-Sales BASIC, Internal Diagnostic Test Tool, ePTI Test Tool");
  AddRequirementInfo("ARCH_SW_NVP_0016", "NVP_BLOCK_ID_PRE_SAFE_RECORDER_2 should be defined.");

  ////***************************************************************************************

  testCaseComment("Preconditions");
  testStep("STEP", "Bench Initialization");
  RunPreTs();
  ////====================================================

  testStep("STEP", "Set breakpoint in function *DIA_runDid0242_PRE_SAFE_Recorder_2_ReadData*.");
  debugger_setRelativeFunctionBpAtLine("DIA_runDid0242_PRE_SAFE_Recorder_2_ReadData", 4);
  debugger_run();
 
  testCaseComment("Action: ARCH_SW_DIA_0250; ARCH_SW_DIA_0256; ARCH_SW_DIA_0257, ARCH_SW_NVP_0016");
  testStep("STEP", "Send diag request for 22 0242 and wait for timeout error --> Timeout received.");
  SendDiagnosticRequest(dPresafeRecorder2ReadRequest, dPresafeRecorder2ReadResponse, TRUE);

  testWaitForTimeout(2000);
  testStep("STEP", "Check if breakpoint from function DIA_runDid0242_PRE_SAFE_Recorder_2_ReadData was reached. --> BP was reached.");
  debugger_waitUntilBPisReached(5000);
  debugger_isCPUStoppedAtFunction("DIA_runDid0242_PRE_SAFE_Recorder_2_ReadData");
  
  
  testStep("STEP", "Evaluate NVP_BLOCK_ID_PRE_SAFE_RECORDER_2_RamBlockData --> Byte was read.");
  i64NVP_BLOCK_ID_PRE_SAFE_RECORDER_2_RamBlockData = debugger_readGlobalVariable("uint8", "NVP_BLOCK_ID_PRE_SAFE_RECORDER_2_RamBlockData,,app.elf", 0);
  EvalManStepEqual("Variable read", i64NVP_BLOCK_ID_PRE_SAFE_RECORDER_2_RamBlockData);

  ////====================================================
  testCaseComment("Postcondition");
  testStep("STEP", "Return ECU to default values");
  RunPostTs();
  
}


testcase SW_IT_DIA_runDidFD01_SWVersionRead_01()
{

  //***********************************Test report header*********************************
  testReportAddMiscInfoBlock("AUTOLIV ELECTRONICS document");
  TestReportAddMiscInfo("Nightly test", "No");
  TestReportAddMiscInfo("Test type", "Requirement-Based test");
  TestReportAddMiscInfo("Regression Test", "No");
  TestReportAddMiscInfo("Fault injection method used", "No");
  TestReportAddMiscInfo("Resource usage evaluation", "No");
  TestReportAddMiscInfo("Priority", "No");
  TestReportAddMiscInfo("Safety relevant", "No");
  
  AddRequirementInfo("Requirement under test", "ARCH_SW_DIA_0285; ARCH_SW_DIA_0286; ARCH_SW_DIA_0287; ARCH_SW_DIA_0288; ARCH_SW_DIA_0289; ARCH_SW_DIA_0290; ARCH_SW_DIA_0291");
  AddRequirementInfo("ARCH_SW_DIA_0285", "Service 0x22 (Read Data By Identifier) will be implemented for DID FD01 (SW Version)");
  AddRequirementInfo("ARCH_SW_DIA_0286", "The Read SW Version shall be available in the following sessions: Supplier Session/Development Session (0x7E)");
  AddRequirementInfo("ARCH_SW_DIA_0287", "Service Read SW Version shall be processed with or without Any form of Authentication.");
  AddRequirementInfo("ARCH_SW_DIA_0288", "DataIdentifier of SW Version shall be 0xFD01");
  AddRequirementInfo("ARCH_SW_DIA_0289", "Read SW Version service Response DataRecord shall have 12 bytes length");
  AddRequirementInfo("ARCH_SW_DIA_0290", "DataRecord: SW Version Bytes 'SN1' to 'SN12' are coded in ASCII and shall reflect the SW Identification (letters and digits allowed)");
  AddRequirementInfo("ARCH_SW_DIA_0291", "SNx shall be ordered from MSB to LSB, ASCI coded i.e. bytes #4 to #15 form a string in that order that can be read directly. It will be formatted as follow:Ã‚Â Ã‚Â   Ã¢Â¦ÂÃ‚ Ã‚ Ã‚ Ã‚ Ã‚ Ã‚ Ã‚ Ã‚ Ã‚ Ã‚ AABCCZWH.YYY Where: AA-reflects product code, e.g. ER for ECU PP (a.k.a. ERR) B -reflects BM identification according to current software version, e.g. 0 for PP4G Extended CC-reflects customer code, e.g. 18 for DAI Group Z-reflects software type code, 6 for DAI MMA W-Digit subject to change in case the SW release have been modified between SW Freeze and M2 Milestone. H-defines a FLASHED software version YYY-reflects the software version over 3 digit");

  //***************************************************************************************

  testCaseComment("Preconditions");
  testStep("STEP", "Bench Initialization");
  RunPreTs();
  //====================================================

  testStep("STEP", "Set breakpoint in function *DIA_runDidFD01_SWVersionRead*.");
  debugger_setRelativeFunctionBpAtLine("DIA_runDidFD01_SWVersionRead", 2);
  debugger_run();
  
  testStep("STEP", "Enter development session*.");
  EnterDiagnosticSession("development");
 
  testCaseComment("Action: ARCH_SW_DIA_0285; ARCH_SW_DIA_0286; ARCH_SW_DIA_0287; ARCH_SW_DIA_0288; ARCH_SW_DIA_0289; ARCH_SW_DIA_0290; ARCH_SW_DIA_0291");
  testStep("STEP", "Send diag request for 22 0242 and wait for timeout error --> Timeout received.");
  SendDiagnosticRequest(dSWVersionReadRequest, dSWVersionReadResponse, TRUE);

  testWaitForTimeout(2000);
  testStep("STEP", "Check if breakpoint from function DIA_runDidFD01_SWVersionRead was reached. --> BP was reached.");
  debugger_waitUntilBPisReached(5000);
  debugger_isCPUStoppedAtFunction("DIA_runDidFD01_SWVersionRead");
  
  testStep("STEP", "Evaluate Data Record --> Variable was read.");
  pi64Data = debugger_readLocalVariable("*Data");
  EvalManStepEqual("Data variable read", pi64Data);
 
  //====================================================
  testCaseComment("Postcondition");
  testStep("STEP", "Return ECU to default values");
  RunPostTs();
}

testcase SW_IT_DataServices_Current_Operating_Time_Read_Current_Operating_Time_ReadData_01()
{
  ////***********************************Test report header*********************************
  testReportAddMiscInfoBlock("AUTOLIV ELECTRONICS document");
  TestReportAddMiscInfo("Nightly test", "No");
  TestReportAddMiscInfo("Test type", "Requirement-Based test");
  TestReportAddMiscInfo("Regression Test", "No");
  TestReportAddMiscInfo("Fault injection method used", "No");
  TestReportAddMiscInfo("Resource usage evaluation", "No");
  TestReportAddMiscInfo("Priority", "No");
  TestReportAddMiscInfo("Safety relevant", "No");
  
  AddRequirementInfo("Requirement under test", "ARCH_SW_DIA_0325; ARCH_SW_DIA_0326; ARCH_SW_DIA_0327; ARCH_SW_DIA_0467; ARCH_SW_DIA_0468; ARCH_SW_DIA_0469; ARCH_SW_DIA_0470");
  AddRequirementInfo("ARCH_SW_DIA_0467", "DataIdentifier shall be 0x0133");
  AddRequirementInfo("ARCH_SW_DIA_0468", "The DID shall be available in the following sessions: Ã¢Â¦ÂDefault Session Ã¢Â¦ÂProgramming Ã¢Â¦ÂExtended session Ã¢Â¦ÂUpdate Session Ã¢Â¦ÂDevelopment Session");
  AddRequirementInfo("ARCH_SW_DIA_0469", "This service shall be available under the following forms of Authentication: Ã¢Â¦ÂSupplier Ã¢Â¦ÂDevelopment ENHANCED Ã¢Â¦ÂProduction Ã¢Â¦ÂAfter-Sales ENHANCED Ã¢Â¦ÂAfter-Sales Ã¢Â¦ÂInternal Diagnostic Test Tool");
  AddRequirementInfo("ARCH_SW_DIA_0326", "Response data shall be 5 bytes long.");
  AddRequirementInfo("ARCH_SW_DIA_0470", "Bytes 0-3 of the positive response shall represent the Current Operating Time.");
  AddRequirementInfo("ARCH_SW_DIA_0325", "Service 0x22 (Read Data By Identifier) will be implemented for DID 0133 (Current Operating Time)");
  AddRequirementInfo("ARCH_SW_DIA_0326", "Response data shall be 5 bytes long.");
  AddRequirementInfo("ARCH_SW_DIA_0327", "Byte 4 of the positive response shall represent the Operating Time Status, defined as follows: Ã¢Â¦Â Bits 0 3: converted value based on timeBaseStatus Ã¢Â¦Â Bits 4 7: value of userByte0");


  ////***************************************************************************************

  testCaseComment("Preconditions");
  testStep("STEP", "Bench Initialization");
  RunPreTs();
  ////====================================================

  testStep("STEP", "Start Development Session.");
  EnterDiagnosticSession("development");
  
  testStep("STEP", "Set breakpoint in function *DataServices_Current_Operating_Time_Read_Current_Operating_Time_ReadData*.");
  debugger_setRelativeFunctionBpAtLine("DataServices_Current_Operating_Time_Read_Current_Operating_Time_ReadData", 34);
  debugger_run();
 
  testCaseComment("Action: ARCH_SW_DIA_0325; ARCH_SW_DIA_0326; ARCH_SW_DIA_0327; ARCH_SW_DIA_0467; ARCH_SW_DIA_0468; ARCH_SW_DIA_0469; ARCH_SW_DIA_0470");
  testStep("STEP", "Send diag request for security access --> Timeout received.");
  SendDiagnosticRequest(dCurrentOperatingTimeReadRequest, dCurrentOperatingTimeReadResponse, TRUE);
  
  testStep("STEP", "Check if breakpoint from function DataServices_Current_Operating_Time_Read_Current_Operating_Time_ReadData was reached. --> BP was reached.");
  debugger_waitUntilBPisReached(5000);
  debugger_isCPUStoppedAtFunction("DataServices_Current_Operating_Time_Read_Current_Operating_Time_ReadData");
  
  testStep("STEP", "Evaluate Data Record --> Variable was read.");
  pi64Data = debugger_readLocalVariable("*Data");
  EvalManStepEqual("Data variable read", pi64Data);
  

  ////====================================================
  testCaseComment("Postcondition");
  testStep("STEP", "Return ECU to default values");
  RunPostTs();
}

testcase SW_IT_DIA_runDid00140_Obsolence_Data_Current_Value_Read_01()
{
  int64 i64stObsolescenseData_Current_Value;
  ////***********************************Test report header*********************************
  testReportAddMiscInfoBlock("AUTOLIV ELECTRONICS document");
  TestReportAddMiscInfo("Nightly test", "No");
  TestReportAddMiscInfo("Test type", "Requirement-Based test");
  TestReportAddMiscInfo("Regression Test", "No");
  TestReportAddMiscInfo("Fault injection method used", "No");
  TestReportAddMiscInfo("Resource usage evaluation", "No");
  TestReportAddMiscInfo("Priority", "No");
  TestReportAddMiscInfo("Safety relevant", "No");
  
  AddRequirementInfo("Requirement under test", "ARCH_SW_DIA_0330; ARCH_SW_DIA_0331; ARCH_SW_DIA_0332; ARCH_SW_DIA_0333");
  AddRequirementInfo("ARCH_SW_DIA_0330", "Service 0x22 (Read Data By Identifier) will be implemented for DID 0140 (Obsolescence Data)");
  AddRequirementInfo("ARCH_SW_DIA_0331", "The Read Obsolescence Data service shall be available in the following sessions: Default Session (0x01) Programming (0x02) Extended Session (0x03) Supplier Session/Development Session (0x7E) Update Session (0x42)");
  AddRequirementInfo("ARCH_SW_DIA_0332", "Read Obsolescence Data service shall be available under the following forms of Authentication: Supplier Development ENHANCED Production After-Sales ENHANCED After-Sales After-Sales BASIC Internal Diagnostic Test Tool ePTI Test Tool");
  AddRequirementInfo("ARCH_SW_DIA_0333", "DataIdentifier of the Read Obsolescence Data shall be: 0x0140");

  ////***************************************************************************************

  testCaseComment("Preconditions");
  testStep("STEP", "Bench Inityialization");
  RunPreTs();
  ////====================================================

  testStep("STEP", "Start Development Session.");
  EnterDiagnosticSession("development");
  
  testStep("STEP", "Set breakpoint in function *DIA_runDid00140_Obsolescence_Data_BSR_Current_Value_Read*.");
  debugger_setRelativeFunctionBpAtLine("DIA_runDid00140_Obsolescence_Data_BSR_Current_Value_Read", 8);
  debugger_run();
 
  testCaseComment("Action: ARCH_SW_DIA_0330; ARCH_SW_DIA_0331; ARCH_SW_DIA_0332; ARCH_SW_DIA_0333");
  testStep("STEP", "Send diag request for 01 40 --> Timeout received.");
  SendDiagnosticRequest(dObsolenceDataReadRequest, dObsolenceDataReadResponse, TRUE);

  testWaitForTimeout(2000);
  testStep("STEP", "Check if breakpoint from function DataServices_Current_Operating_Time_Read_Current_Operating_Time_ReadData was reached. --> BP was reached.");
  debugger_waitUntilBPisReached(5000);
  debugger_isCPUStoppedAtFunction("DIA_runDid00140_Obsolescence_Data_BSR_Current_Value_Read");
  
  testStep("STEP", "Read stObsolescenseData.BSR.Current_Value --> Variable read.");
  i64stObsolescenseData_Current_Value = debugger_readLocalVariable("stObsolescenseData.BSR.Current_Value");
  EvalManStepEqual("Variable read", i64stObsolescenseData_Current_Value);

  ////====================================================
  testCaseComment("Postcondition");
  testStep("STEP", "Return ECU to default values");
  RunPostTs();
}

testcase SW_IT_DIA_runDid00140_Obsolence_Data_Threshold_Read_01()
{
  //***********************************Test report header*********************************
  testReportAddMiscInfoBlock("AUTOLIV ELECTRONICS document");
  TestReportAddMiscInfo("Nightly test", "No");
  TestReportAddMiscInfo("Test type", "Requirement-Based test");
  TestReportAddMiscInfo("Regression Test", "No");
  TestReportAddMiscInfo("Fault injection method used", "No");
  TestReportAddMiscInfo("Resource usage evaluation", "No");
  TestReportAddMiscInfo("Priority", "No");
  TestReportAddMiscInfo("Safety relevant", "No");
  
  AddRequirementInfo("Requirement under test", "ARCH_SW_DIA_0330; ARCH_SW_DIA_0334; ARCH_SW_DIA_0335");
  AddRequirementInfo("ARCH_SW_DIA_0330", "Service 0x22 (Read Data By Identifier) will be implemented for DID 0140 (Obsolescence Data)");
  AddRequirementInfo("ARCH_SW_DIA_0334", "Response data length shall be 24 bytes long: Bytes #2-#3: DataIdentifier of the Read Obsolescence Data shall be: 0x0140 Bytes #4 - #5 = Remaining BSR Activations [2bytes] : Bytes #6 - #7 = Threshold Green to Yellow for Remaining BSR Activation [2bytes] = 0x00 0x00 Bytes #8 - #9 = Threshold Yellow to Red for Remaining BSR Activation [2bytes] = 0x00 0x00 Bytes #10 - #11 = Remaining Low Force Activations [2bytes] : Bytes #12 - #13 = Threshold Green to Yellow for Remaining Low Force Activation [2bytes] = 0x00 0x00 Bytes #14 - #15 = Threshold Yellow to Red for Remaining Low Force Activation [2bytes] = 0x00 0x00 Bytes #16 - #17 = Remaining high Force Activations [2bytes] : Bytes #18 - #19 = Threshold Green to Yellow for Remaining High Force Activation [2bytes] = 0x00 0x00 Bytes #20 - #21 = Threshold Yellow to Red for Remaining High Force Activation [2bytes] = 0x00 0x00 Bytes #22 - #23 = Remaining Max Force Activations [2bytes] : Bytes #24 - #25 = Threshold Green to Yellow for Remaining Max Force Activation [2bytes] = 0x00 0x00 Bytes #26 - #27 = Threshold Yellow to Red for Remaining Max Force Activation [2bytes] = 0x00 0x00. Note: Full Response length = 3 bytes + Response data length");
  AddRequirementInfo("ARCH_SW_DIA_0335", "Read Obsolescence Data service shall return the number of remaing BSR(Comfort), Low Force, High Force, Max Force possible activation.");
  //***************************************************************************************

  testCaseComment("Preconditions");
  testStep("STEP", "Bench Initialization");
  RunPreTs();
  //====================================================

  testStep("STEP", "Set breakpoint in function *DIA_runDid00140_Obsolescence_Data_PRE_SAFE_Lvl_4_5_Treshold_Yellow_To_Red_Read*. --> BP is reached");
  debugger_setRelativeFunctionBpAtLine("DIA_runDid00140_Obsolescence_Data_PRE_SAFE_Lvl_4_5_Treshold_Yellow_To_Red_Read", 0);
  debugger_run();
 
  testCaseComment("Action: ARCH_SW_DIA_0330; ARCH_SW_DIA_0334; ARCH_SW_DIA_0335");
  testStep("STEP", "Send diag request for 01 40 --> Timeout received.");
  SendDiagnosticRequest(dObsolenceDataReadRequest, dObsolenceDataReadResponse, TRUE);
  
  testWaitForTimeout(2000);
  debugger_waitUntilBPisReached(5000);
  debugger_isCPUStoppedAtFunction("DIA_runDid00140_Obsolescence_Data_PRE_SAFE_Lvl_4_5_Treshold_Yellow_To_Red_Read");
  
  testStep("STEP", "Evaluate Data Record --> Variable was read.");
  pi64Data = debugger_readLocalVariable("*Data");
  EvalManStepEqual("Data variable read", pi64Data);
  

  //====================================================
  testCaseComment("Postcondition");
  testStep("STEP", "Return ECU to default values");
  RunPostTs();
}
  
testcase SW_IT_DIA_DataServices_CPU_Load_Read_CPU_load_histograms_ReadData_01()
{
  ////***********************************Test report header*********************************
  testReportAddMiscInfoBlock("AUTOLIV ELECTRONICS document");
  TestReportAddMiscInfo("Nightly test", "No");
  TestReportAddMiscInfo("Test type", "Requirement-Based test");
  TestReportAddMiscInfo("Regression Test", "No");
  TestReportAddMiscInfo("Fault injection method used", "No");
  TestReportAddMiscInfo("Resource usage evaluation", "No");
  TestReportAddMiscInfo("Priority", "No");
  TestReportAddMiscInfo("Safety relevant", "No");
  
  AddRequirementInfo("Requirement under test", "ARCH_SW_DIA_0340; ARCH_SW_DIA_0341; ARCH_SW_DIA_0342; ARCH_SW_DIA_0343; ARCH_SW_DIA_0344");
  AddRequirementInfo("ARCH_SW_DIA_0340", "Service 0x22 (Read Data By Identifier) will be implemented for DID 01E1 (CPU Load)");
  AddRequirementInfo("ARCH_SW_DIA_0341", "The Read CPU Load service shall be available in the following sessions: Default Session (0x01) Programming (0x02) Extended Session (0x03) Supplier Session/Development Session (0x7E) Update Session (0x42)");
  AddRequirementInfo("ARCH_SW_DIA_0342", "Read CPU Load service shall be available under the following forms of Authentication: Supplier Development ENHANCED Internal Diagnostic Test Tool");
  AddRequirementInfo("ARCH_SW_DIA_0343", "DataIdentifier of the Read CPU Load shall be: 0x01E1");
  AddRequirementInfo("ARCH_SW_DIA_0344", "Response data length shall be 12 bytes long: Bytes #2-#3: DataIdentifier of the Read CPU Load shall be: 0x01E1 Byte #4 = CPU ID [1byte]: [0x00] Core 1 Bytes #5 - #15 = CPU Load [11 bytes]: [Byte1] 0-9%, PercentUpdate [Byte2] 10-19%, PercentUpdate [Byte3] 20-29%, PercentUpdate [Byte4] 30-39%, PercentUpdate [Byte5] 40-49%, PercentUpdate [Byte6] 50-59%, PercentUpdate [Byte7] 60-69%, PercentUpdate [Byte8] 70-79%, PercentUpdate [Byte9] 80-89%, PercentUpdate [Byte10] 90-99%, PercentUpdate [Byte11] 100%, PercentUpdate Note: Full Response length = 3 bytes + Response data length");


  ////***************************************************************************************

  testCaseComment("Preconditions");
  testStep("STEP", "Bench Initialization");
  RunPreTs();
  ////====================================================

  testStep("STEP", "Set breakpoint in function *DataServices_CPU_Load_Read_CPU_load_histograms_ReadData*.");
  debugger_setRelativeFunctionBpAtLine("DataServices_CPU_Load_Read_CPU_load_histograms_ReadData", 21);
  debugger_run();
 
  testCaseComment("Action: ARCH_SW_DIA_0340; ARCH_SW_DIA_0341; ARCH_SW_DIA_0342; ARCH_SW_DIA_0343; ARCH_SW_DIA_0344");
  testStep("STEP", "Send diag request for 22 01 E1 --> Timeout received.");
  SendDiagnosticRequest(dCPULoadReadRequest, dCPULoadReadResponse, TRUE);

  testWaitForTimeout(2000);
  testStep("STEP", "Check if breakpoint from function DataServices_CPU_Load_Read_CPU_load_histograms_ReadData was reached. --> BP was reached.");
  debugger_waitUntilBPisReached(5000);
  debugger_isCPUStoppedAtFunction("DataServices_CPU_Load_Read_CPU_load_histograms_ReadData");
  
  testStep("STEP", "Read Data variable --> Variable read.");
  pi64Data = debugger_readLocalVariable("*Data");
  EvalManStepEqual("Data pointer read.", pi64Data);
  
    //====================================================
  testCaseComment("Postcondition");
  testStep("STEP", "Return ECU to default values");
  RunPostTs();
}

testcase SW_IT_DIA_DataServices_E2E_Timing_Read_Maximum_ReadDataLength_01()
{
  ////***********************************Test report header*********************************
  testReportAddMiscInfoBlock("AUTOLIV ELECTRONICS document");
  TestReportAddMiscInfo("Nightly test", "No");
  TestReportAddMiscInfo("Test type", "Requirement-Based test");
  TestReportAddMiscInfo("Regression Test", "No");
  TestReportAddMiscInfo("Fault injection method used", "No");
  TestReportAddMiscInfo("Resource usage evaluation", "No");
  TestReportAddMiscInfo("Priority", "No");
  TestReportAddMiscInfo("Safety relevant", "No");
  
  AddRequirementInfo("Requirement under test", "ARCH_SW_DIA_0345; ARCH_SW_DIA_0346; ARCH_SW_DIA_0347; ARCH_SW_DIA_0348; ARCH_SW_DIA_0349");
  AddRequirementInfo("ARCH_SW_DIA_0345", "Service 0x22 (Read Data By Identifier) will be implemented for DID 01E2 (E2E Timing)");
  AddRequirementInfo("ARCH_SW_DIA_0346", "The Read E2E Timing service shall be available in the following sessions: Default Session (0x01) Programming (0x02) Extended Session (0x03) Supplier Session/Development Session (0x7E) Update Session (0x42)");
  AddRequirementInfo("ARCH_SW_DIA_0347", "Read E2E Timing service shall be available under the following forms of Authentication: Supplier Development ENHANCED Internal Diagnostic Test Tool");
  AddRequirementInfo("ARCH_SW_DIA_0348", "DataIdentifier of the Read E2E Timing shall be: 0x01E2");
  AddRequirementInfo("ARCH_SW_DIA_0349", "Response data length shall be 2 bytes long: Bytes #2-#3: DataIdentifier of the Read E2E Timing shall be: 0x01E2 Byte #4 = E2E ID [1byte] : [0x00] Please insert KPI name (Please insert E2E KPI value) [0x01] Please insert KPI name (Please insert E2E KPI value) [0x02] Please insert KPI name (Please insert E2E KPI value) [0x03] Please insert KPI name (Please insert E2E KPI value) Bytes #5 = Maximum [1 byte] Note: Full Response length = 3 bytes + Response data length");

  ////***************************************************************************************

  testCaseComment("Preconditions");
  testStep("STEP", "Bench Initialization");
  RunPreTs();
  ////====================================================

  testStep("STEP", "Set breakpoint in function *DataServices_E2E_Timing_Read_Maximum_ReadData*.");
  debugger_setRelativeFunctionBpAtLine("DataServices_E2E_Timing_Read_Maximum_ReadData", 8);
  debugger_run();
 
  testCaseComment("Action: ARCH_SW_DIA_0345; ARCH_SW_DIA_0346; ARCH_SW_DIA_0347; ARCH_SW_DIA_0348; ARCH_SW_DIA_0349");
  testStep("STEP", "Send diag request for 22 01 E2 --> Timeout received.");
  SendDiagnosticRequest(dE2ETimingReadRequest, dE2ETimingReadResponse, TRUE);

  testWaitForTimeout(2000);
  testStep("STEP", "Check if breakpoint from function DataServices_E2E_Timing_Read_Maximum_ReadData was reached. --> BP was reached.");
  debugger_waitUntilBPisReached(5000);
  debugger_isCPUStoppedAtFunction("DataServices_E2E_Timing_Read_Maximum_ReadData");
  
  testStep("STEP", "Read Data variable --> Variable read.");
  pi64Data = debugger_readLocalVariable("*Data");
  EvalManStepEqual("Data pointer read.", pi64Data);

  ////====================================================
  testCaseComment("Postcondition");
  testStep("STEP", "Return ECU to default values");
  RunPostTs();
}

testcase SW_IT_DIA_DataServices_Stack_Load_Read_Maximum_ReadData_01()
{
  ////***********************************Test report header*********************************
  testReportAddMiscInfoBlock("AUTOLIV ELECTRONICS document");
  TestReportAddMiscInfo("Nightly test", "No");
  TestReportAddMiscInfo("Test type", "Requirement-Based test");
  TestReportAddMiscInfo("Regression Test", "No");
  TestReportAddMiscInfo("Fault injection method used", "No");
  TestReportAddMiscInfo("Resource usage evaluation", "No");
  TestReportAddMiscInfo("Priority", "No");
  TestReportAddMiscInfo("Safety relevant", "No");
  
  AddRequirementInfo("Requirement under test", "ARCH_SW_DIA_0350; ARCH_SW_DIA_0351; ARCH_SW_DIA_0352; ARCH_SW_DIA_0353; ARCH_SW_DIA_0354");
  AddRequirementInfo("ARCH_SW_DIA_0350", "Service 0x22 (Read Data By Identifier) will be implemented for DID 01E3 (Stack Load)");
  AddRequirementInfo("ARCH_SW_DIA_0351", "The Read Stack Load service shall be available in the following sessions: Default Session (0x01) Programming (0x02) Extended Session (0x03) Supplier Session/Development Session (0x7E) Update Session (0x42)");
  AddRequirementInfo("ARCH_SW_DIA_0352", "Read Stack Load service shall be available under the following forms of Authentication: Supplier Development ENHANCED Internal Diagnostic Test Tool");
  AddRequirementInfo("ARCH_SW_DIA_0353", "DataIdentifier of the Read Stack Load shall be: 0x01E3");
  AddRequirementInfo("ARCH_SW_DIA_0354", "Response data length shall be 2 bytes long: Bytes #2-#3: DataIdentifier of the Read Stack Load shall be: 0x01E3 Byte #4 = Task Stack ID [1byte] [0x00] Core 1 Byte #5 = Maximum[1 byte] Note: Full Response length = 3 bytes + Response data length");

  ////***************************************************************************************

  testCaseComment("Preconditions");
  testStep("STEP", "Bench Initialization");
  RunPreTs();
  ////====================================================

  testStep("STEP", "Set breakpoint in function *DataServices_Stack_Load_Read_Maximum_ReadData*.");
  debugger_setRelativeFunctionBpAtLine("DataServices_Stack_Load_Read_Maximum_ReadData", 22);
  debugger_run();
 
  testCaseComment("Action: ARCH_SW_DIA_0350; ARCH_SW_DIA_0351; ARCH_SW_DIA_0352; ARCH_SW_DIA_0353; ARCH_SW_DIA_0354");
  testStep("STEP", "Send diag request for 22 01 E3 --> Timeout received.");
  SendDiagnosticRequest(dStackLoadReadRequest, dStackLoadReadResponse, TRUE);

  testWaitForTimeout(2000);
  testStep("STEP", "Check if breakpoint from function DataServices_Stack_Load_Read_Maximum_ReadData was reached. --> BP was reached.");
  debugger_waitUntilBPisReached(5000);
  debugger_isCPUStoppedAtFunction("DataServices_Stack_Load_Read_Maximum_ReadData");

  testStep("STEP", "Read Data variable --> Variable read.");
  pi64Data = debugger_readLocalVariable("*Data");
  EvalManStepEqual("Data pointer read.", pi64Data);

  ////====================================================
  testCaseComment("Postcondition");
  testStep("STEP", "Return ECU to default values");
  RunPostTs();
}

testcase SW_IT_DIA_DataServices_Memory_Usage_Cycles_Read_Memory_Usage_Cycles_ReadData_01()
{
  ////***********************************Test report header*********************************
  testReportAddMiscInfoBlock("AUTOLIV ELECTRONICS document");
  TestReportAddMiscInfo("Nightly test", "No");
  TestReportAddMiscInfo("Test type", "Requirement-Based test");
  TestReportAddMiscInfo("Regression Test", "No");
  TestReportAddMiscInfo("Fault injection method used", "No");
  TestReportAddMiscInfo("Resource usage evaluation", "No");
  TestReportAddMiscInfo("Priority", "No");
  TestReportAddMiscInfo("Safety relevant", "No");
  
  AddRequirementInfo("Requirement under test", "ARCH_SW_DIA_0355; ARCH_SW_DIA_0356; ARCH_SW_DIA_0357; ARCH_SW_DIA_0358; ARCH_SW_DIA_0359");
  AddRequirementInfo("ARCH_SW_DIA_0355", "Service 0x22 (Read Data By Identifier) will be implemented for DID 01E4 (Memory Usage Cycles)");
  AddRequirementInfo("ARCH_SW_DIA_0356", "The Read Memory usage Cycles service shall be available in the following sessions: Default Session (0x01) Programming (0x02) Extended Session (0x03) Supplier Session/Development Session (0x7E) Update Session (0x42)");
  AddRequirementInfo("ARCH_SW_DIA_0357", "Read Memory usage Cycles service shall be available under the following forms of Authentication: Supplier Development ENHANCED Internal Diagnostic Test Tool");
  AddRequirementInfo("ARCH_SW_DIA_0358", "DataIdentifier of the Read Memory usage Cycles shall be: 0x01E4");
  AddRequirementInfo("ARCH_SW_DIA_0359", "Response data length shall be 5 bytes long: DataIdentifier of the Read Memory Usage Cycles shall be: 0x01E4 For each block there is a 5 byte response: Memory Block ID [1byte]: Ã¢Â¦Â[0x00] Please insert memory ID (e.g. Data Flash Bank0) Memory Usage Cycles [4 bytes] Note: Full Response length = 3 bytes + Response data length");

  ////***************************************************************************************

  testCaseComment("Preconditions");
  testStep("STEP", "Bench Initialization");
  RunPreTs();
  ////====================================================

  testStep("STEP", "Set breakpoint in function *DataServices_Memory_Usage_Cycles_Read_Memory_Usage_Cycles_ReadData*.");
  debugger_setRelativeFunctionBpAtLine("DataServices_Memory_Usage_Cycles_Read_Memory_Usage_Cycles_ReadData", 32);
  debugger_run();
 
  testCaseComment("Action: ARCH_SW_DIA_0355; ARCH_SW_DIA_0356; ARCH_SW_DIA_0357; ARCH_SW_DIA_0358; ARCH_SW_DIA_0359");
  testStep("STEP", "Send diag request for 22 01 E4 --> Timeout received.");
  SendDiagnosticRequest(dMemoryUsageCyclesReadRequest, dMemoryUsageCyclesReadResponse, TRUE);

  testWaitForTimeout(2000);
  testStep("STEP", "Check if breakpoint from function DataServices_Memory_Usage_Cycles_Read_Memory_Usage_Cycles_ReadData was reached. --> BP was reached.");
  debugger_waitUntilBPisReached(5000);
  debugger_isCPUStoppedAtFunction("DataServices_Memory_Usage_Cycles_Read_Memory_Usage_Cycles_ReadData");
  
  testStep("STEP", "Read Data variable --> Variable read.");
  pi64Data = debugger_readLocalVariable("*Data");
  EvalManStepEqual("Data pointer read.", pi64Data);
  
  ////====================================================
  testCaseComment("Postcondition");
  testStep("STEP", "Return ECU to default values");
  RunPostTs();
}

testcase SW_IT_DIA_DIA_runDid0200_CAN_input_Read_Neues_Bitfeld_ReadData_01()
{
  //***********************************Test report header*********************************
  testReportAddMiscInfoBlock("AUTOLIV ELECTRONICS document");
  TestReportAddMiscInfo("Nightly test", "No");
  TestReportAddMiscInfo("Test type", "Requirement-Based test");
  TestReportAddMiscInfo("Regression Test", "No");
  TestReportAddMiscInfo("Fault injection method used", "No");
  TestReportAddMiscInfo("Resource usage evaluation", "No");
  TestReportAddMiscInfo("Priority", "No");
  TestReportAddMiscInfo("Safety relevant", "No");
  
  AddRequirementInfo("Requirement under test", "ARCH_SW_DIA_0360; ARCH_SW_DIA_0361; ARCH_SW_DIA_0362; ARCH_SW_DIA_0363; ARCH_SW_DIA_0364; ARCH_SW_DIA_0365; ARCH_SW_DIA_0441; ARCH_SW_DIA_0442; ARCH_SW_DIA_0443; ARCH_SW_DIA_0444; ARCH_SW_DIA_0445; ARCH_SW_DIA_0446; ARCH_SW_DIA_0447; ARCH_SW_DIA_0448; ARCH_SW_DIA_0449; ARCH_SW_DIA_0450; ARCH_SW_DIA_0451; ARCH_SW_DIA_0452; ARCH_SW_DIA_0453; ARCH_SW_DIA_0454;ARCH_SW_DIA_0455; ARCH_SW_DIA_0456; ARCH_SW_DIA_0457; ARCH_SW_DIA_0458; ARCH_SW_DIA_0497; ARCH_SW_DIA_0498; ARCH_SW_DIA_0499; ARCH_SW_DIA_0500; ARCH_SW_DIA_0501; ARCH_SW_DIA_0502; ARCH_SW_DIA_0503; ARCH_SW_DIA_0504; ARCH_SW_DIA_0505; ARCH_SW_DIA_0506; ARCH_SW_DIA_0535;ARCH_SW_DIA_0536; ARCH_SW_DIA_0537; ARCH_SW_DIA_0538; ARCH_SW_DIA_0539; ARCH_SW_DIA_0540; ARCH_SW_DIA_0541; ARCH_SW_DIA_0542");
  AddRequirementInfo("ARCH_SW_DIA_0360", "Service 0x22 (Read Data By Identifier) will be implemented for DID 0200 (CAN Input)");
  AddRequirementInfo("ARCH_SW_DIA_0361", "The Read CAN Input service shall be available in the following sessions: Default Session (0x01) Extended Session (0x03) Supplier Session/Development Session (0x7E) Update Session (0x42)");
  AddRequirementInfo("ARCH_SW_DIA_0362", "Read CAN Input service shall be available under the following forms of Authentication: Supplier Development ENHANCED Production After-Sales ENHANCED After-Sales After-Sales BASIC Internal Diagnostic Test Tool ePTI Test Tool");
  AddRequirementInfo("ARCH_SW_DIA_0363", "DataIdentifier of the Read CAN Input shall be: 0x0200");
  AddRequirementInfo("ARCH_SW_DIA_0364", "Response data length shall be 9 bytes long: Bytes #2-#3: DataIdentifier of the Read CAN Input shall be: 0x0200 Byte #4 : bits 0-2: Ignition switch state (Isw_Stat_ST3 signal) bit 3 : Reserved (set to 0) bits 4-5 : Buckle switch driver state (Bckl_Sw_D_Stat_ST3) bits 6-7 : Buckle switch front passenger state (Bckl_Sw_FP_Stat_ST3) Byte #5 : bits 0-1 : Presafe enabled (Presf_Enbl_ST3) bits 2-3 : Presafe actuator RBTM_FL tensioning suppress request (PresfAct_TensSupp_Rq_ST3) bits 4-7 : Presafe level (Presf_Lvl_ST3) Byte #6 : bits 0-1 : Belt hand over left state (BeltHdOvr_FL_Stat_ST3) bits 2-3 : Belt hand over right state (BeltHdOvr_FR_Stat_ST3) bits 4-6 : Engine start state (PT4_PTCoor_EngStartPN14_Stat_ST3) bit 7 : Reserved (set to 0) Byte #7 : bit 0 : Impact event X (Impact_X_ST3) bit 1 : Reserved (set to 0) bit 2 : Turn over event 1 RO_type1 (Impact_RO_type1_ST3) bit 3 : Turn over event 2 RO_type2 (Impact_RO_type2_ST3) bits 4-5 : Steering variant (EVC_List03_StStyle_ST3) bits 6-7 : Reserved (set to 0) Byte #8 : bits 0-7 : Supply battery voltage (ngagedng of PN14_SupBat_Volt_ST3 signal with 0.1V resolution) Byte #9 : bits 0-2: Supply battery cutoff switch status ((PN14_DDP_Sw_Stat_ST3) bits3-5 : Powernet Production mode status (PN14_ProdMd_Stat_ST3) bits 6-7 : Powernet transport mode status (PN14_TransMd_Stat_ST3) Byte #10 : bits 0-1: Belt slack decreasing mode request (BltSlckDec_Md_Rq_HU_ST3) bits 2-3 : Powertrain ready (PT4_PTCoor_PT_Rdy_ST3) bits 4-7 : Reverse gear ngaged (PT4_PTCoor_DrvPosn_Stat_ST3) Byte #11 : bits 0-5: RBTMFL_SP_Lvl_Rq_ST35 bits 6-7: DidA external tester present (DidA_ExtTest_Pres_ST3) Byte #12 : bits 0-5: RBTMFR_SP_Lvl_Rq_ST35 bits 6-7: Presafe acceleration threshold (PresfAccelReset_NotExcd_ST3)");
  AddRequirementInfo("ARCH_SW_DIA_0365", "Read CAN Input service shall return the current values of the mentioned CAN signals.");
  AddRequirementInfo("ARCH_SW_DIA_0441", "Signal PT4_PTCoor_EngStartPN14_Stat_ST3 Position: Ã¢Â¦Â StartByte = 4; Ã¢Â¦Â StartBit = 4; Ã¢Â¦Â SignalLength = 3; Note:StartByte starts from 1 and StartBit starts from 0");
  AddRequirementInfo("ARCH_SW_DIA_0442", "Signal Values: 0 = NO_COMBUSTIONSTART_RQ (No combustion start required) 1 = CUSTOMER_START_RQ(Customer start required) 2 = AUTO_START_NO_PN_SUP_RQ(Automatic start without Powernet support required) 3 = AUTO_START_PN_SUP_RQ(Automatic start with Powernet support required) 7 = Signal not Available (SNA)");
  AddRequirementInfo("ARCH_SW_DIA_0443", "PT4_PTCoor_EngStartPN14_Stat_ST3 signal shall be read by both Front LEFT ECU and Front RIGHT ECU and reported via CAN Input Service (0x0200)");
  AddRequirementInfo("ARCH_SW_DIA_0444", "Signal DidA_ExtTest_Pres_ST3 Position: Ã¢Â¦Â StartByte = 1 Ã¢Â¦Â StartBit = 2; Ã¢Â¦Â SignalLength = 2 Note:StartByte starts from 1 and StartBit starts from 0");
  AddRequirementInfo("ARCH_SW_DIA_0445", "Signal Values: 0x01= FALSE 0x02 = TRUE 0x03 = default / Signal not Available (SNA)");
  AddRequirementInfo("ARCH_SW_DIA_0446", "DidA_ExtTest_Pres_ST3 signal shall be read by both Front LEFT ECU and Front RIGHT ECU and reported via CAN Input Service (0x0200)");
  AddRequirementInfo("ARCH_SW_DIA_0447", "Signal PN14_DDP_Sw_Stat_ST3 Position: Ã¢Â¦Â StartByte = 1 Ã¢Â¦Â StartBit = 2; Ã¢Â¦Â SignalLength = 3 Ã¢Â¦Â Note:StartByte starts from 1 and StartBit starts from 0");
  AddRequirementInfo("ARCH_SW_DIA_0448", "Signal Values: 0 = CLS TDP (switch is closed) 1 = PRE_RESET (Pre-Reset warning) 2 = RESET (Reset active) 3 = PRE_OPN (Pre-Open warning) 4 = OPN (TDP switch is open) 7 = default / Signal not Available (SNA)");
  AddRequirementInfo("ARCH_SW_DIA_0449", "PN14_DDP_Sw_Stat_ST3 signal shall be read by both Front LEFT ECU and Front RIGHT ECU and reported via CAN Input Service (0x0200)");
  AddRequirementInfo("ARCH_SW_DIA_0450", "Signal PN14_SupBat_Volt_ST3 Position: Ã¢Â¦Â StartByte = 3 Ã¢Â¦Â StartBit = 6; Ã¢Â¦Â SignalLength = 10 Note:StartBytes starts from 1 and StartBits starts from 0");
  AddRequirementInfo("ARCH_SW_DIA_0451", "Signal Values: 0x00...0x3FE (0..25.55 V) 0x03FF = default / Signal not Available (SNA) unit: 0.025 V");
  AddRequirementInfo("ARCH_SW_DIA_0452", "PN14_SupBat_Volt_ST3 signal shall be read by both Front LEFT ECU and Front RIGHT ECU and reported via CAN Input Service (0x0200)");
  AddRequirementInfo("ARCH_SW_DIA_0453", "Signal PN14_ProdMd_Stat_ST3 Position: Ã¢Â¦Â StartByte = 1 Ã¢Â¦Â StartBit = 5; Ã¢Â¦Â SignalLength = 3; Note:StartBytes starts from 1 and StartBits starts from 0");
  AddRequirementInfo("ARCH_SW_DIA_0454", "Signal Values: 0 = OFF (Productionmode off) 1 = ON (Productionmode active) 2 = SF01 (Productionmode Special Funcion 1) 3 = SF02 (Productionmode Special Funcion 2) 4 = SF03 (Productionmode Special Funcion 3) 7 = default / Signal not Available (SNA)");
  AddRequirementInfo("ARCH_SW_DIA_0455", "PN14_ProdMd_Stat_ST3 signal shall be read by both Front LEFT ECU and Front RIGHT ECU and reported via CAN Input Service (0x0200)");
  AddRequirementInfo("ARCH_SW_DIA_0456", "Signal PN14_TransMd_Stat_ST3 Position: Ã¢Â¦Â StartByte = 1 Ã¢Â¦Â StartBit = 0; Ã¢Â¦Â SignalLength = 2; Note:StartBytes starts from 1 and StartBits starts from 0");
  AddRequirementInfo("ARCH_SW_DIA_0457", "Signal Values: 0 = OFF (Transport mode permanently off) 1 = TEMP_OFF (Transport mode temporarily off) 2 = ACTV (Transport mode active) 3 = default / Signal not Available (SNA)");
  AddRequirementInfo("ARCH_SW_DIA_0458", "PN14_TransMd_Stat_ST3 signal shall be read by both Front LEFT ECU and Front RIGHT ECU and reported via CAN Input Service (0x0200)");
  AddRequirementInfo("ARCH_SW_DIA_0497", "CAN Frame DIAG_Stat_ST3 shall be identified with the address 0x6D0");
  AddRequirementInfo("ARCH_SW_DIA_0498", "CAN Frame PN14_Master_Stat1_ST3 shall be identified with the address 0x464");
  AddRequirementInfo("ARCH_SW_DIA_0499", "Diagnostic request frame DIAG_RBTM_FL_03_ExtEth_RQ_ST3 identifier shall be 0x18E1A488 if ECU is configured as FRONT LEFT side");
  AddRequirementInfo("ARCH_SW_DIA_0500", "DIAG_RBTM_FL_03_ExtEth_RQ_ST3 Frame size: variable, max 8 bytes");
  AddRequirementInfo("ARCH_SW_DIA_0501", "Diagnostic request frame DIAG_RBTM_FR_03_ExtEth_RQ_ST3 identifier shall be 0x18E1A588 if ECU is configured as FRONT RIGHT side");
  AddRequirementInfo("ARCH_SW_DIA_0502", "DIAG_RBTM_FR_03_ExtEth_RQ_ST3 Frame size: variable, max 8 bytes");
  AddRequirementInfo("ARCH_SW_DIA_0503", "If a diagnostic service request is received via CAN Frame DIAG_RBTM_xy_03_ExtEth_RQ_ST3 then RGS shall respond via DIAG_RBTM_FL_03_ExtEth_RS_ST3 (Id: 0x18E1A480) frame");
  AddRequirementInfo("ARCH_SW_DIA_0504", "DIAG_RBTM_FL_03_ExtEth_RS_ST3 Frame size: variable max 8 bytes");
  AddRequirementInfo("ARCH_SW_DIA_0505", "If a diagnostic service request is received via CAN Frame DIAG_RBTM_FR_03_ExtEth_RQ_ST3 then RGS shall respond via DIAG_RBTM_FR_03_ExtEth_RS_ST3 (Id: 0x18E1A580) frame");
  AddRequirementInfo("ARCH_SW_DIA_0506", "DIAG_RBTM_FR_03_ExtEth_RS_ST3 Frame size: variable max 8 bytes");
  AddRequirementInfo("ARCH_SW_DIA_0535", "Diagnostic request frame DIAG_RBTM_FL_03_ExtCAN_RQ_ST3 identifier shall be 0x18E1A489 if ECU is configured as FRONT LEFT side.");
  AddRequirementInfo("ARCH_SW_DIA_0536", "DIAG_RBTM_FL_03_ExtCAN_RQ_ST3 Frame size: variable, max 8 bytes");
  AddRequirementInfo("ARCH_SW_DIA_0537", "Diagnostic request frame DIAG_RBTM_FR_03_ExtCAN_RQ_ST3 identifier shall be 0x18E1A589 if ECU is configured as FRONT LEFT side");
  AddRequirementInfo("ARCH_SW_DIA_0538", "DIAG_RBTM_FR_03_ExtCAN_RQ_ST3 Frame size: variable, max 8 bytes");
  AddRequirementInfo("ARCH_SW_DIA_0539", "Diagnostic request frame DIAG_RBTM_FL_03_IntEth_RQ_ST3 identifier shall be 0x18E1A48D if ECU is configured as FRONT LEFT side");
  AddRequirementInfo("ARCH_SW_DIA_0540", "DIAG_RBTM_FL_03_IntEth_RQ_ST3 Frame size: variable, max 8 bytes");
  AddRequirementInfo("ARCH_SW_DIA_0541", "Diagnostic request frame DIAG_RBTM_FR_03_IntEth_RQ_ST3 identifier shall be 0x18E1A58D if ECU is configured as FRONT LEFT side");
  AddRequirementInfo("ARCH_SW_DIA_0542", "DIAG_RBTM_FR_03_IntEth_RQ_ST3 Frame size: variable, max 8 bytes");

  //***************************************************************************************

  testCaseComment("Preconditions");
  testStep("STEP", "Bench Initialization");
  RunPreTs();
  //====================================================

  testStep("STEP", "Set breakpoint in function *DIA_runDid0200_CAN_input_Read_Neues_Bitfeld_1_ReadData*.");
  debugger_setRelativeFunctionBpAtLine("DIA_runDid0200_CAN_input_Read_Neues_Bitfeld_1_ReadData", 31);
  debugger_run();
 
  testCaseComment("Action: ARCH_SW_DIA_0360; ARCH_SW_DIA_0361; ARCH_SW_DIA_0362; ARCH_SW_DIA_0363; ARCH_SW_DIA_0364; ARCH_SW_DIA_0365");
  testStep("STEP", "Send diag request for 22 02 00 --> Timeout received.");
  SendDiagnosticRequest(dCANinputReadRequest, dCANinputReadResponse, TRUE);

  testWaitForTimeout(2000);
  testStep("STEP", "Check if breakpoint from function DIA_runDid0200_CAN_input_Read_Neues_Bitfeld_1_ReadData was reached. --> BP was reached.");
  debugger_waitUntilBPisReached(5000);
  debugger_isCPUStoppedAtFunction("DIA_runDid0200_CAN_input_Read_Neues_Bitfeld_1_ReadData");
  
  testStep("STEP", "Read Data variable --> Variable read.");
  pi64Data = debugger_readLocalVariable("*Data");
  EvalManStepEqual("Data pointer read.", pi64Data);
  
  debugger_deleteAllBP();
  debugger_setRelativeFunctionBpAtLine("DIA_runDid0200_CAN_input_Read_Neues_Bitfeld_2_ReadData", 36);
  debugger_run();
 
  testCaseComment("Action: ARCH_SW_DIA_0360; ARCH_SW_DIA_0361; ARCH_SW_DIA_0362; ARCH_SW_DIA_0363; ARCH_SW_DIA_0364; ARCH_SW_DIA_0365");
  testStep("STEP", "Send diag request for 22 02 00 --> Timeout received.");
  SendDiagnosticRequest(dCANinputReadRequest, dCANinputReadResponse, TRUE);

  testWaitForTimeout(2000);
  testStep("STEP", "Check if breakpoint from function DIA_runDid0200_CAN_input_Read_Neues_Bitfeld_2_ReadData was reached. --> BP was reached.");
  debugger_waitUntilBPisReached(5000);
  debugger_isCPUStoppedAtFunction("DIA_runDid0200_CAN_input_Read_Neues_Bitfeld_2_ReadData");

  testStep("STEP", "Read Data variable --> Variable read.");
  pi64Data = debugger_readLocalVariable("*Data");
  EvalManStepEqual("Data pointer read.", pi64Data);
  
  debugger_deleteAllBP();
  debugger_setRelativeFunctionBpAtLine("DIA_runDid0200_CAN_input_Read_Neues_Bitfeld_3_ReadData", 41);
  debugger_run();
 
  testCaseComment("Action: ARCH_SW_DIA_0360; ARCH_SW_DIA_0361; ARCH_SW_DIA_0362; ARCH_SW_DIA_0363; ARCH_SW_DIA_0364; ARCH_SW_DIA_0365; ARCH_SW_DIA_0441; ARCH_SW_DIA_0442; ARCH_SW_DIA_0443");
  testStep("STEP", "Send diag request for 22 02 00 --> Timeout received.");
  SendDiagnosticRequest(dCANinputReadRequest, dCANinputReadResponse, TRUE);

  testWaitForTimeout(2000);
  testStep("STEP", "Check if breakpoint from function DIA_runDid0200_CAN_input_Read_Neues_Bitfeld_3_ReadData was reached. --> BP was reached.");
  debugger_waitUntilBPisReached(5000);
  debugger_isCPUStoppedAtFunction("DIA_runDid0200_CAN_input_Read_Neues_Bitfeld_3_ReadData");

  testStep("STEP", "Read Data variable --> Variable read.");
  pi64Data = debugger_readLocalVariable("*Data");
  EvalManStepEqual("Data pointer read.", pi64Data);
  
  debugger_deleteAllBP();
  debugger_setRelativeFunctionBpAtLine("DIA_runDid0200_CAN_input_Read_Neues_Bitfeld_4_ReadData", 36);
  debugger_run();
 
  testCaseComment("Action: ARCH_SW_DIA_0360; ARCH_SW_DIA_0361; ARCH_SW_DIA_0362; ARCH_SW_DIA_0363; ARCH_SW_DIA_0364; ARCH_SW_DIA_0365");
  testStep("STEP", "Send diag request for 22 02 00 --> Timeout received.");
  SendDiagnosticRequest(dCANinputReadRequest, dCANinputReadResponse, TRUE);

  testWaitForTimeout(2000);
  testStep("STEP", "Check if breakpoint from function DIA_runDid0200_CAN_input_Read_Neues_Bitfeld_4_ReadData was reached. --> BP was reached.");
  debugger_waitUntilBPisReached(5000);
  debugger_isCPUStoppedAtFunction("DIA_runDid0200_CAN_input_Read_Neues_Bitfeld_4_ReadData");
  
  testStep("STEP", "Read Data variable --> Variable read.");
  pi64Data = debugger_readLocalVariable("*Data");
  EvalManStepEqual("Data pointer read.", pi64Data);
  
  debugger_deleteAllBP();
  debugger_setRelativeFunctionBpAtLine("DIA_runDid0200_CAN_input_Read_Neues_Bitfeld_5_ReadData", 32);
  debugger_run();
 
  testCaseComment("Action: ARCH_SW_DIA_0360; ARCH_SW_DIA_0361; ARCH_SW_DIA_0362; ARCH_SW_DIA_0363; ARCH_SW_DIA_0364; ARCH_SW_DIA_0365; ARCH_SW_DIA_0447; ARCH_SW_DIA_0448; ARCH_SW_DIA_0449; ARCH_SW_DIA_0453; ARCH_SW_DIA_0454; ARCH_SW_DIA_0455; ARCH_SW_DIA_0456; ARCH_SW_DIA_0457; ARCH_SW_DIA_0458");
  testStep("STEP", "Send diag request for 22 02 00 --> Timeout received.");
  SendDiagnosticRequest(dCANinputReadRequest, dCANinputReadResponse, TRUE);

  testWaitForTimeout(2000);
  testStep("STEP", "Check if breakpoint from function DIA_runDid0200_CAN_input_Read_Neues_Bitfeld_5_ReadData was reached. --> BP was reached.");
  debugger_waitUntilBPisReached(5000);
  debugger_isCPUStoppedAtFunction("DIA_runDid0200_CAN_input_Read_Neues_Bitfeld_5_ReadData");
  
  testStep("STEP", "Read Data variable --> Variable read.");
  pi64Data = debugger_readLocalVariable("*Data");
  EvalManStepEqual("Data pointer read.", pi64Data);
  
  debugger_deleteAllBP();
  debugger_setRelativeFunctionBpAtLine("DIA_runDid0200_CAN_input_Read_Neues_Bitfeld_6_ReadData", 33);
  debugger_run();
 
  testCaseComment("Action: ARCH_SW_DIA_0360; ARCH_SW_DIA_0361; ARCH_SW_DIA_0362; ARCH_SW_DIA_0363; ARCH_SW_DIA_0364; ARCH_SW_DIA_0365");
  testStep("STEP", "Send diag request for 22 02 00 --> Timeout received.");
  SendDiagnosticRequest(dCANinputReadRequest, dCANinputReadResponse, TRUE);

  testWaitForTimeout(2000);
  testStep("STEP", "Check if breakpoint from function DIA_runDid0200_CAN_input_Read_Neues_Bitfeld_6_ReadData was reached. --> BP was reached.");
  debugger_waitUntilBPisReached(5000);
  debugger_isCPUStoppedAtFunction("DIA_runDid0200_CAN_input_Read_Neues_Bitfeld_6_ReadData");
  
  testStep("STEP", "Read Data variable --> Variable read.");
  pi64Data = debugger_readLocalVariable("*Data");
  EvalManStepEqual("Data pointer read.", pi64Data);
  
  debugger_deleteAllBP();
  debugger_setRelativeFunctionBpAtLine("DIA_runDid0200_CAN_input_Read_Supply_battery_voltage_ReadData", 21);
  debugger_run();
 
  testCaseComment("Action: ARCH_SW_DIA_0360; ARCH_SW_DIA_0361; ARCH_SW_DIA_0362; ARCH_SW_DIA_0363; ARCH_SW_DIA_0364; ARCH_SW_DIA_0365; ARCH_SW_DIA_0450; ARCH_SW_DIA_0451; ARCH_SW_DIA_0452");
  testStep("STEP", "Send diag request for 22 02 00 --> Timeout received.");
  SendDiagnosticRequest(dCANinputReadRequest, dCANinputReadResponse, TRUE);

  testWaitForTimeout(2000);
  testStep("STEP", "Check if breakpoint from function DIA_runDid0200_CAN_input_Read_Supply_battery_voltage_ReadData was reached. --> BP was reached.");
  debugger_waitUntilBPisReached(5000);
  debugger_isCPUStoppedAtFunction("DIA_runDid0200_CAN_input_Read_Supply_battery_voltage_ReadData");
  
  testStep("STEP", "Read Data variable --> Variable read.");
  pi64Data = debugger_readLocalVariable("*Data");
  EvalManStepEqual("Data pointer read.", pi64Data);
  
  debugger_deleteAllBP();
  debugger_setRelativeFunctionBpAtLine("DIA_runDid0200_CAN_input_Read_Neues_Bitfeld_7_ReadData", 47);
  debugger_run();
 
  testCaseComment("Action: ARCH_SW_DIA_0360; ARCH_SW_DIA_0361; ARCH_SW_DIA_0362; ARCH_SW_DIA_0363; ARCH_SW_DIA_0364; ARCH_SW_DIA_0365; ARCH_SW_DIA_0444; ARCH_SW_DIA_0445; ARCH_SW_DIA_0446");
  testStep("STEP", "Send diag request for 22 02 00 --> Timeout received.");
  SendDiagnosticRequest(dCANinputReadRequest, dCANinputReadResponse, TRUE);

  testWaitForTimeout(2000);
  testStep("STEP", "Check if breakpoint from function DIA_runDid0200_CAN_input_Read_Neues_Bitfeld_7_ReadData was reached. --> BP was reached.");
  debugger_waitUntilBPisReached(5000);
  debugger_isCPUStoppedAtFunction("DIA_runDid0200_CAN_input_Read_Neues_Bitfeld_7_ReadData");
  
  testStep("STEP", "Read Data variable --> Variable read.");
  pi64Data = debugger_readLocalVariable("*Data");
  EvalManStepEqual("Data pointer read.", pi64Data);
  
  debugger_deleteAllBP();
  debugger_setRelativeFunctionBpAtLine("DIA_runDid0200_CAN_input_Read_Neues_Bitfeld_8_ReadData", 24);
  debugger_run();
 
  testCaseComment("Action: ARCH_SW_DIA_0360; ARCH_SW_DIA_0361; ARCH_SW_DIA_0362; ARCH_SW_DIA_0363; ARCH_SW_DIA_0364; ARCH_SW_DIA_0365; ARCH_SW_DIA_0535;ARCH_SW_DIA_0536; ARCH_SW_DIA_0537; ARCH_SW_DIA_0538; ARCH_SW_DIA_0539; ARCH_SW_DIA_0540; ARCH_SW_DIA_0541; ARCH_SW_DIA_0542");
  testStep("STEP", "Send diag request for 22 02 00 --> Timeout received.");
  SendDiagnosticRequest(dCANinputReadRequest, dCANinputReadResponse, TRUE);

  testWaitForTimeout(2000);
  testStep("STEP", "Check if breakpoint from function DIA_runDid0200_CAN_input_Read_Neues_Bitfeld_8_ReadData was reached. --> BP was reached.");
  debugger_waitUntilBPisReached(5000);
  debugger_isCPUStoppedAtFunction("DIA_runDid0200_CAN_input_Read_Neues_Bitfeld_8_ReadData");
  
  testStep("STEP", "Read Data variable --> Variable read.");
  pi64Data = debugger_readLocalVariable("*Data");
  EvalManStepEqual("Data pointer read.", pi64Data);
  //====================================================
  testCaseComment("Postcondition");
  testStep("STEP", "Return ECU to default values");
  RunPostTs();
}

testcase SW_IT_DIA_DataServices_HardwareVersion_Read_HW_ReadData_01()
{
  ////***********************************Test report header*********************************
  testReportAddMiscInfoBlock("AUTOLIV ELECTRONICS document");
  TestReportAddMiscInfo("Nightly test", "No");
  TestReportAddMiscInfo("Test type", "Requirement-Based test");
  TestReportAddMiscInfo("Regression Test", "No");
  TestReportAddMiscInfo("Fault injection method used", "No");
  TestReportAddMiscInfo("Resource usage evaluation", "No");
  TestReportAddMiscInfo("Priority", "No");
  TestReportAddMiscInfo("Safety relevant", "No");
  
  AddRequirementInfo("Requirement under test", "ARCH_SW_DIA_0370; ARCH_SW_DIA_0371; ARCH_SW_DIA_0372; ARCH_SW_DIA_0373; ARCH_SW_DIA_0374; ARCH_SW_DIA_0471; ARCH_SW_DIA_0472; ARCH_SW_DIA_0473");
  AddRequirementInfo("ARCH_SW_DIA_0370", "Service 0x22 (Read Data By Identifier) will be implemented for DID F150 (Hardware Version Information)");
  AddRequirementInfo("ARCH_SW_DIA_0471", "DataIdentifier shall be 0xF150");
  AddRequirementInfo("ARCH_SW_DIA_0472", "The DID shall be available in the following sessions: Ã¢Â¦ÂDefault Session Ã¢Â¦ÂProgramming Ã¢Â¦ÂExtended session Ã¢Â¦ÂUpdate Session Ã¢Â¦ÂDevelopment Session");
  AddRequirementInfo("ARCH_SW_DIA_0473", "This service shall be available with or without Any form of Authentication.");
  AddRequirementInfo("ARCH_SW_DIA_0371", "Response data shall be 3 bytes long");
  AddRequirementInfo("ARCH_SW_DIA_0372", "Byte 0 of the positive response shall represent the year when the HW was designed.");
  AddRequirementInfo("ARCH_SW_DIA_0373", "Byte 1 of the positive response shall represent the week when the HW was designed.");
  AddRequirementInfo("ARCH_SW_DIA_0374", "Byte 2 of the positive response shall represent the current patch level of the HW.");
  
  ////***************************************************************************************

  testCaseComment("Preconditions");
  testStep("STEP", "Bench Initialization");
  RunPreTs();
  ////====================================================

  testStep("STEP", "Set breakpoint in function *DataServices_HardwareVersion_Read_HW_patch_level_ReadData*.");
  debugger_setRelativeFunctionBpAtLine("DataServices_HardwareVersion_Read_HW_patch_level_ReadData", 3);
  debugger_run();
 
  testCaseComment("Action: ARCH_SW_DIA_0370; ARCH_SW_DIA_0371; ARCH_SW_DIA_0372; ARCH_SW_DIA_0373");
  testStep("STEP", "Send diag request for 22 F1 50 --> Timeout received.");
  SendDiagnosticRequest(dReadHWVersionReadRequest, dReadHWVersionReadResponse, TRUE);

  testWaitForTimeout(2000);
  testStep("STEP", "Check if breakpoint from function DataServices_HardwareVersion_Read_HW_patch_level_ReadData was reached. --> BP was reached.");
  debugger_waitUntilBPisReached(5000);
  debugger_isCPUStoppedAtFunction("DataServices_HardwareVersion_Read_HW_patch_level_ReadData");
  
  testStep("STEP", "Read Data variable --> Variable read.");
  pi64Data = debugger_readLocalVariable("*Data");
  EvalManStepEqual("Data pointer read.", pi64Data);
  
  debugger_deleteAllBP();
  debugger_setRelativeFunctionBpAtLine("DataServices_HardwareVersion_Read_HW_year_ReadData", 3);
  debugger_run();
 
  testCaseComment("Action: ARCH_SW_DIA_0370; ARCH_SW_DIA_0371; ARCH_SW_DIA_0372; ARCH_SW_DIA_0373; ARCH_SW_DIA_0374; ARCH_SW_DIA_0471; ARCH_SW_DIA_0472; ARCH_SW_DIA_0473");
  testStep("STEP", "Send diag request for 22 F1 50 --> Timeout received.");
  SendDiagnosticRequest(dReadHWVersionReadRequest, dReadHWVersionReadResponse, TRUE);

  testWaitForTimeout(2000);
  testStep("STEP", "Check if breakpoint from function DataServices_HardwareVersion_Read_HW_year_ReadData was reached. --> BP was reached.");
  debugger_waitUntilBPisReached(5000);
  debugger_isCPUStoppedAtFunction("DataServices_HardwareVersion_Read_HW_year_ReadData");
  
  testStep("STEP", "Read Data variable --> Variable read.");
  pi64Data = debugger_readLocalVariable("*Data");
  EvalManStepEqual("Data pointer read.", pi64Data);

  ////====================================================
  testCaseComment("Postcondition");
  testStep("STEP", "Return ECU to default values");
  RunPostTs();
}

testcase SW_IT_DIA_DataServices_SoftwareVersion_Read_Software_Logical_Block_Version_Information_ReadData_01()
{
  ////***********************************Test report header*********************************
  testReportAddMiscInfoBlock("AUTOLIV ELECTRONICS document");
  TestReportAddMiscInfo("Nightly test", "No");
  TestReportAddMiscInfo("Test type", "Requirement-Based test");
  TestReportAddMiscInfo("Regression Test", "No");
  TestReportAddMiscInfo("Fault injection method used", "No");
  TestReportAddMiscInfo("Resource usage evaluation", "No");
  TestReportAddMiscInfo("Priority", "No");
  TestReportAddMiscInfo("Safety relevant", "No");
  
  AddRequirementInfo("Requirement under test", "ARCH_SW_DIA_0375; ARCH_SW_DIA_0376; ARCH_SW_DIA_0377; ARCH_SW_DIA_0378; ARCH_SW_DIA_0379; ARCH_SW_DIA_0474; ARCH_SW_DIA_0475; ARCH_SW_DIA_0476");
  AddRequirementInfo("ARCH_SW_DIA_0375", "Service 0x22 (Read Data By Identifier) will be implemented for DID F151 (Software Version Information)");
  AddRequirementInfo("ARCH_SW_DIA_0474", "DataIdentifier shall be 0xF151");
  AddRequirementInfo("ARCH_SW_DIA_0475", "The DID shall be available in the following sessions: Ã¢Â¦ÂDefault Session Ã¢Â¦ÂProgramming Ã¢Â¦ÂExtended session Ã¢Â¦ÂUpdate Session Ã¢Â¦ÂDevelopment Session");
  AddRequirementInfo("ARCH_SW_DIA_0476", "This service shall be available with or without Any form of Authentication.");
  AddRequirementInfo("ARCH_SW_DIA_0376", "Response data shall be 6 bytes long");
  AddRequirementInfo("ARCH_SW_DIA_0377", "Byte 0 of the positive response shall represent the year when the Boot SW Version was designed.Byte 1 of the positive response shall represent the week when the Boot SW Version was designed. Byte 2 of the positive response shall represent the current patch level of the Boot SW. ");
  AddRequirementInfo("ARCH_SW_DIA_0378", "Byte 3 of the positive response shall represent the year when the Application SW Version was designed. Byte 4 of the positive response shall represent the week when the Application SW Version was designed. Byte 5 of the positive response shall represent the current patch level of the Application SW. ");
  AddRequirementInfo("ARCH_SW_DIA_0379", "Byte 6 of the positive response shall represent the year when the HSM SW Version was designed.  Byte 7 of the positive response shall represent the week when the HSM SW Version was designed. Byte 8 of the positive response shall represent the current patch level of the HSM SW.");

  ////***************************************************************************************

  testCaseComment("Preconditions");
  testStep("STEP", "Bench Initialization");
  RunPreTs();
  ////====================================================

  testStep("STEP", "Set breakpoint in function *DataServices_SoftwareVersion_Read_Software_Logical_Block_Version_Information_ReadData*.");
  debugger_setRelativeFunctionBpAtLine("DataServices_SoftwareVersion_Read_Software_Logical_Block_Version_Information_ReadData", 40);
  debugger_run();
 
  testCaseComment("Action: ARCH_SW_DIA_0375; ARCH_SW_DIA_0376; ARCH_SW_DIA_0377; ARCH_SW_DIA_0378; ARCH_SW_DIA_0379; ARCH_SW_DIA_0474; ARCH_SW_DIA_0475; ARCH_SW_DIA_0476");
  testStep("STEP", "Send diag request for 22 F1 51 --> Timeout received.");
  SendDiagnosticRequest(dSofwareVersionInformationRequest, dSofwareVersionInformationResponse, TRUE);

  testWaitForTimeout(2000);
  testStep("STEP", "Check if breakpoint from function DataServices_SoftwareVersion_Read_Software_Logical_Block_Version_Information_ReadData was reached. --> BP was reached.");
  debugger_waitUntilBPisReached(5000);
  debugger_isCPUStoppedAtFunction("DataServices_SoftwareVersion_Read_Software_Logical_Block_Version_Information_ReadData");
  

  testStep("STEP", "Read Data variable --> Variable read.");
  pi64Data = debugger_readLocalVariable("*Data");
  EvalManStepEqual("Data pointer read.", pi64Data);

  ////====================================================
  testCaseComment("Postcondition");
  testStep("STEP", "Return ECU to default values");
  RunPostTs();
}

testcase SW_IT_DIA_DataServices_BootSoftwareVersion_Read_Boot_SW_ReadData_01()
{
  //***********************************Test report header*********************************
  testReportAddMiscInfoBlock("AUTOLIV ELECTRONICS document");
  TestReportAddMiscInfo("Nightly test", "No");
  TestReportAddMiscInfo("Test type", "Requirement-Based test");
  TestReportAddMiscInfo("Regression Test", "No");
  TestReportAddMiscInfo("Fault injection method used", "No");
  TestReportAddMiscInfo("Resource usage evaluation", "No");
  TestReportAddMiscInfo("Priority", "No");
  TestReportAddMiscInfo("Safety relevant", "No");
  
  AddRequirementInfo("Requirement under test", "ARCH_SW_DIA_0380; ARCH_SW_DIA_0381; ARCH_SW_DIA_0382; ARCH_SW_DIA_0383; ARCH_SW_DIA_0477; ARCH_SW_DIA_0478; ARCH_SW_DIA_0479;");
  AddRequirementInfo("ARCH_SW_DIA_0477", "DataIdentifier shall be 0xF153");
  AddRequirementInfo("ARCH_SW_DIA_0478", "The DID shall be available in the following sessions: Ã¢Â¦ÂDefault Session Ã¢Â¦ÂProgramming Ã¢Â¦ÂExtended session Ã¢Â¦ÂUpdate Session Ã¢Â¦ÂDevelopment Session");
  AddRequirementInfo("ARCH_SW_DIA_0479", "This service shall be available under the following forms of Authentication: Ã¢Â¦ÂSupplier Ã¢Â¦ÂDevelopment ENHANCED Ã¢Â¦ÂProduction Ã¢Â¦ÂAfter-Sales ENHANCED Ã¢Â¦ÂAfter-Sales Ã¢Â¦ÂAfter-Sales BASIC Ã¢Â¦ÂInternal Diagnostic Test Tool Ã¢Â¦ÂePTI Test Tool");
  AddRequirementInfo("ARCH_SW_DIA_0381", "Response data shall be 3 bytes long");
  AddRequirementInfo("ARCH_SW_DIA_0382", "Byte 0 of the positive response shall represent the year when the Boot SW was designed.");
  AddRequirementInfo("ARCH_SW_DIA_0383", "Byte 1 of the positive response shall represent the week when the Boot SW was designed.");
  AddRequirementInfo("ARCH_SW_DIA_0384", "Byte 2 of the positive response shall represent the current patch level of the Boot SW.");

  //***************************************************************************************

  testCaseComment("Preconditions");
  testStep("STEP", "Bench Initialization");
  RunPreTs();
  //====================================================

  testStep("STEP", "Set breakpoint in function *DataServices_BootSoftwareVersion_Read_Boot_SW_patch_level_ReadData*.");
  debugger_setRelativeFunctionBpAtLine("DataServices_BootSoftwareVersion_Read_Boot_SW_patch_level_ReadData", 3);
  debugger_run();
 
  testCaseComment("Action: ARCH_SW_DIA_0380; ARCH_SW_DIA_0381; ARCH_SW_DIA_0382; ARCH_SW_DIA_0383; ARCH_SW_DIA_0477; ARCH_SW_DIA_0478; ARCH_SW_DIA_0479;");
  testStep("STEP", "Send diag request for 22 F1 53 --> Timeout received.");
  SendDiagnosticRequest(dBootSWVersionReadRequest, dBootSWVersionReadResponse, TRUE);

  testWaitForTimeout(2000);
  testStep("STEP", "Check if breakpoint from function DataServices_BootSoftwareVersion_Read_Boot_SW_patch_level_ReadData was reached. --> BP was reached.");
  debugger_waitUntilBPisReached(5000);
  debugger_isCPUStoppedAtFunction("DataServices_BootSoftwareVersion_Read_Boot_SW_patch_level_ReadData");

  testStep("STEP", "Read Data variable --> Variable read.");
  pi64Data = debugger_readLocalVariable("*Data");
  EvalManStepEqual("Data pointer read.", pi64Data);

  debugger_deleteAllBP();
  debugger_setRelativeFunctionBpAtLine("DataServices_BootSoftwareVersion_Read_Boot_SW_week_ReadData", 3);
  debugger_run();
 
  testCaseComment("Action: ARCH_SW_DIA_0380; ARCH_SW_DIA_0381; ARCH_SW_DIA_0382; ARCH_SW_DIA_0383");
  testStep("STEP", "Send diag request for 22 F1 53 --> Timeout received.");
  SendDiagnosticRequest(dBootSWVersionReadRequest, dBootSWVersionReadResponse, TRUE);

  testWaitForTimeout(2000);
  testStep("STEP", "Check if breakpoint from function DataServices_BootSoftwareVersion_Read_Boot_SW_patch_level_ReadData was reached. --> BP was reached.");
  debugger_waitUntilBPisReached(5000);
  debugger_isCPUStoppedAtFunction("DataServices_BootSoftwareVersion_Read_Boot_SW_week_ReadData");
  
  testStep("STEP", "Read Data variable --> Variable read.");
  pi64Data = debugger_readLocalVariable("*Data");
  EvalManStepEqual("Data pointer read.", pi64Data);
  
  debugger_deleteAllBP();
  debugger_setRelativeFunctionBpAtLine("DataServices_BootSoftwareVersion_Read_Boot_SW_year_ReadData", 3);
  debugger_run();
 
  testCaseComment("Action: ARCH_SW_DIA_0380; ARCH_SW_DIA_0381; ARCH_SW_DIA_0382; ARCH_SW_DIA_0383; ARCH_SW_DIA_0477; ARCH_SW_DIA_0478; ARCH_SW_DIA_0479");
  testStep("STEP", "Send diag request for 22 F1 53 --> Timeout received.");
  SendDiagnosticRequest(dBootSWVersionReadRequest, dBootSWVersionReadResponse, TRUE);

  testWaitForTimeout(2000);
  testStep("STEP", "Check if breakpoint from function DataServices_BootSoftwareVersion_Read_Boot_SW_year_ReadData was reached. --> BP was reached.");
  debugger_waitUntilBPisReached(5000);
  debugger_isCPUStoppedAtFunction("DataServices_BootSoftwareVersion_Read_Boot_SW_year_ReadData");
  
  testStep("STEP", "Read Data variable --> Variable read.");
  pi64Data = debugger_readLocalVariable("*Data");
  EvalManStepEqual("Data pointer read.", pi64Data);
  //====================================================
  
  testCaseComment("Postcondition");
  testStep("STEP", "Return ECU to default values");
  RunPostTs();
}

testcase SW_IT_DIA_DataServices_Global_Time_Sync_Measured_Values_ReadData()
{

  //***********************************Test report header*********************************
  testReportAddMiscInfoBlock("AUTOLIV ELECTRONICS document");
  TestReportAddMiscInfo("Nightly test", "No");
  TestReportAddMiscInfo("Test type", "Requirement-Based test");
  TestReportAddMiscInfo("Regression Test", "No");
  TestReportAddMiscInfo("Fault injection method used", "No");
  TestReportAddMiscInfo("Resource usage evaluation", "No");
  TestReportAddMiscInfo("Priority", "No");
  TestReportAddMiscInfo("Safety relevant", "No");
  
  AddRequirementInfo("Requirement under test", "ARCH_SW_DIA_0460; ARCH_SW_DIA_0461; ARCH_SW_DIA_0462; ARCH_SW_DIA_0463; ARCH_SW_DIA_0464; ARCH_SW_DIA_0465; ARCH_SW_DIA_0466");
  AddRequirementInfo("ARCH_SW_DIA_0460", "Service 0x22 (Read Data By Identifier) will be implemented for DID 0107 (Global Time Sync Measured Values)");
  AddRequirementInfo("ARCH_SW_DIA_0460", "ARCH_SW_DIA_0460");
  AddRequirementInfo("ARCH_SW_DIA_0461", "DataIdentifier shall be 0x0107");
  AddRequirementInfo("ARCH_SW_DIA_0462", "The DID shall be available in the following sessions: Ã¢Â¦ÂDefault Session Ã¢Â¦ÂProgramming Ã¢Â¦ÂExtended session Ã¢Â¦ÂUpdate Session Ã¢Â¦ÂDevelopment Session");
  AddRequirementInfo("ARCH_SW_DIA_0463", "This service shall be available with or without Any form of Authentication.");
  AddRequirementInfo("ARCH_SW_DIA_0464", "Byte 0 of the positive response shall represent the Source Domain Information for Interpretation");
  AddRequirementInfo("ARCH_SW_DIA_0465", "Bytes 1-201 of the positive response shall represent the Global Time Sync Measured Values.");
  AddRequirementInfo("ARCH_SW_DIA_0466", "Response data shall be 201 bytes long.");

  //***************************************************************************************

  testCaseComment("Preconditions");
  testStep("STEP", "Bench Initialization");
  RunPreTs();
  //====================================================

  testStep("STEP", "Set breakpoint in function *DataServices_Global_Time_Sync_Measured_Values_ReadData*.");
  debugger_setRelativeFunctionBpAtLine("DataServices_Global_Time_Sync_Measured_Values_ReadData", 0);
  debugger_run();
 
  testCaseComment("Action: ARCH_SW_DIA_0460; ARCH_SW_DIA_0461; ARCH_SW_DIA_0462; ARCH_SW_DIA_0463; ARCH_SW_DIA_0464; ARCH_SW_DIA_0465; ARCH_SW_DIA_0466");
  testStep("STEP", "Send diag request for 22 0107 and wait for timeout error --> Timeout received.");
  SendDiagnosticRequest(dGlobalTimeSyncMeasuredValuesReadRequest, dGlobalTimeSyncMeasuredValuesReadResponse, TRUE);

  testStep("STEP", "Check if breakpoint from function DataServices_Global_Time_Sync_Measured_Values_ReadData was reached. --> BP was reached.");
  debugger_waitUntilBPisReached(5000);
  debugger_isCPUStoppedAtFunction("DataServices_Global_Time_Sync_Measured_Values_ReadData");
  
  testStep("STEP", "Read Data pointer value --> Byte was read.");
  pi64Data = debugger_readLocalVariable("*Data");
  EvalManStepEqual("Data pointer value read.", pi64Data);
  //====================================================
  testCaseComment("Postcondition");
  testStep("STEP", "Return ECU to default values");
  RunPostTs();
}

testcase SW_IT_DIA_runDid0340_UniqueSeatbeltSerialNumberWrite_01()
{
  int64 i64NVP_BLOCK_ID_BELT_ASSEMBLY_MANUF_DATE_AND_SN_RamBlockData;

  //***********************************Test report header*********************************
  testReportAddMiscInfoBlock("AUTOLIV ELECTRONICS document");
  TestReportAddMiscInfo("Nightly test", "No");
  TestReportAddMiscInfo("Test type", "Requirement-Based test");
  TestReportAddMiscInfo("Regression Test", "No");
  TestReportAddMiscInfo("Fault injection method used", "No");
  TestReportAddMiscInfo("Resource usage evaluation", "No");
  TestReportAddMiscInfo("Priority", "No");
  TestReportAddMiscInfo("Safety relevant", "No");
  
  AddRequirementInfo("Requirement under test", "ARCH_SW_DIA_0008; ARCH_SW_DIA_0056; ARCH_SW_NVP_0001; ARCH_SW_DIA_1020");
  AddRequirementInfo("ARCH_SW_DIA_0008", "Service 0x2E will be implemented for DID 0340.");
  AddRequirementInfo("ARCH_SW_DIA_0056", "Response data will corespond to: Unique Seatbelt Serial number, data contained in BELT_ASSEMBLY_MANUF_DATE_AND_SN NVM block. Note edit: block will be written using the 0x2E Write Service.");
  AddRequirementInfo("ARCH_SW_NVP_0001", "NVP_BLOCK_ID_BELT_ASSEMBLY_MANUF_DATE_AND_SN block shall be configured. Parameter NVP_au8AssemblySerialNumber should have 28 bytes and should store belt assembly Serial Number written at ANG (default values 0xFF).");
  AddRequirementInfo("ARCH_SW_DIA_1020", "Service 0x2E (Write Data By Identifier) will be implemented for DID 0340 (Seat Belt Serial Number).");


  //***************************************************************************************

  testCaseComment("Preconditions");
  testStep("STEP", "Bench Initialization");
  RunPreTs();
  //====================================================

  testStep("STEP", "Enter default or extended session.");
  EnterDiagnosticSession("extended");
  
  testStep("STEP", "Set breakpoint in function *DIA_runDid0340_UniqueSeatbeltSerialNumberWrite*.");
  debugger_setRelativeFunctionBpAtLine("DIA_runDid0340_UniqueSeatbeltSerialNumberWrite", 6);
  debugger_run();
 
  testCaseComment("Action: ARCH_SW_DIA_0008; ARCH_SW_DIA_0056; ARCH_SW_NVP_0001; ARCH_SW_DIA_1020");
  testStep("STEP", "Send diag request for 2E 0340 and wait for timeout error --> Timeout reached.");
  SendDiagnosticRequest(dSeatBeltSerialNumberWriteRequest, dSeatBeltSerialNumberWriteResponse, TRUE);

  testStep("STEP", "Check if breakpoint from function DIA_runDid0340_UniqueSeatbeltSerialNumberWrite was reached. --> BP was reached.");
  debugger_waitUntilBPisReached(5000);
  
  
  testStep("STEP", "Write first byte of NVP_BLOCK_ID_BELT_ASSEMBLY_MANUF_DATE_AND_SN_RamBlockData --> Variable overwritten with 0x1.");
  debugger_writeGlobalVariable("uint8", "NVP_BLOCK_ID_BELT_ASSEMBLY_MANUF_DATE_AND_SN_RamBlockData,,app.elf", 0, 1);
  i64NVP_BLOCK_ID_BELT_ASSEMBLY_MANUF_DATE_AND_SN_RamBlockData = debugger_readGlobalVariable("uint8", "NVP_BLOCK_ID_BELT_ASSEMBLY_MANUF_DATE_AND_SN_RamBlockData,,app.elf", 0);
  EvalManStepEqual("Byte was read", i64NVP_BLOCK_ID_BELT_ASSEMBLY_MANUF_DATE_AND_SN_RamBlockData);
  
  testStep("STEP", "Send diag request for 2E 0340 --> Response received.");
  debugger_deleteAllBP();
  debugger_run();
  SendDiagnosticRequest(dSeatBeltSerialNumberWriteRequest, dSeatBeltSerialNumberWriteResponse);
  CheckPositiveResponse(dSeatBeltSerialNumberWriteRequest, dSeatBeltSerialNumberWriteResponse);

  //====================================================
  testCaseComment("Postcondition");
  testStep("STEP", "Return ECU to default values");
  RunPostTs();
}

testcase SW_IT_DIA_runDidFD10_CycleConfigurationWrite_01()
{
  int64 i64NVP_BLOCK_ID_CYCLE_0_RamBlockData;
  ////***********************************Test report header*********************************
  testReportAddMiscInfoBlock("AUTOLIV ELECTRONICS document");
  TestReportAddMiscInfo("Nightly test", "No");
  TestReportAddMiscInfo("Test type", "Requirement-Based test");
  TestReportAddMiscInfo("Regression Test", "No");
  TestReportAddMiscInfo("Fault injection method used", "No");
  TestReportAddMiscInfo("Resource usage evaluation", "No");
  TestReportAddMiscInfo("Priority", "No");
  TestReportAddMiscInfo("Safety relevant", "No");
  
  AddRequirementInfo("Requirement under test", "ARCH_SW_DIA_0005; ARCH_SW_DIA_0066; ARCH_SW_DIA_0084; ARCH_SW_DIA_0067");
  AddRequirementInfo("ARCH_SW_DIA_0005", "Service 0x2E will be implemented for DID FD10.");
  AddRequirementInfo("ARCH_SW_DIA_0066", "Service should be available in Development Session");
  AddRequirementInfo("ARCH_SW_DIA_0084", "Data Length shall be 420 bytes long.");
  AddRequirementInfo("ARCH_SW_DIA_0067", "NVP_BLOCK_ID_CYCLE0-34_RamBlockData will be Written.");


  ////***************************************************************************************

  testCaseComment("Preconditions");
  testStep("STEP", "Bench Initialization");
  RunPreTs();
  ////====================================================
  testStep("STEP", "Enter development session.");
  EnterDiagnosticSession("development");
  
  testStep("STEP", "Set breakpoint in function *DIA_runDidFD10_CycleConfigurationWrite*.");
  debugger_setRelativeFunctionBpAtLine("DIA_runDidFD10_CycleConfigurationWrite", 10);
  debugger_run();
 
  testCaseComment("Action: ARCH_SW_DIA_0005; ARCH_SW_DIA_0066; ARCH_SW_DIA_0084; ARCH_SW_DIA_0067");
  testStep("STEP", "Send diag request for 2E FD10 and wait for timeout error --> Timeout reached.");
  SendDiagnosticRequest(dCycleConfigWriteRequest, dCycleConfigWriteResponse, TRUE);

  testWaitForTimeout(2000);
  testStep("STEP", "Check if breakpoint from function DIA_runDidFD10_CycleConfigurationWrite was reached. --> BP was reached.");
  debugger_waitUntilBPisReached(5000);
  
  
  testStep("STEP", "Write first byte of NVP_BLOCK_ID_CYCLE_0_RamBlockData --> Variable overwritten with 0x1.");
  debugger_writeGlobalVariable("uint8", "NVP_BLOCK_ID_CYCLE_0_RamBlockData,,app.elf", 0, 1);
  i64NVP_BLOCK_ID_CYCLE_0_RamBlockData = debugger_readGlobalVariable("uint8", "NVP_BLOCK_ID_CYCLE_0_RamBlockData,,app.elf", 0);
  EvalManStepEqual("Byte was read", i64NVP_BLOCK_ID_CYCLE_0_RamBlockData);
  
  testStep("STEP", "Send diag request for 2E FD10 --> Response received.");
  debugger_deleteAllBP();
  debugger_run();
  SendDiagnosticRequest(dCycleConfigWriteRequest, dCycleConfigWriteResponse);
  CheckPositiveResponse("",dCycleConfigWriteRequest, dCycleConfigWriteResponse);

  ////====================================================
  testCaseComment("Postcondition");
  testStep("STEP", "Return ECU to default values");
  RunPostTs();
}

testcase SW_IT_DIA_runDidFD2A_StepsLibraryWrite_01()
{
  int64 i64NVP_BLOCK_ID_STEP_0_RamBlockData;
  ////***********************************Test report header*********************************
  testReportAddMiscInfoBlock("AUTOLIV ELECTRONICS document");
  TestReportAddMiscInfo("Nightly test", "No");
  TestReportAddMiscInfo("Test type", "Requirement-Based test");
  TestReportAddMiscInfo("Regression Test", "No");
  TestReportAddMiscInfo("Fault injection method used", "No");
  TestReportAddMiscInfo("Resource usage evaluation", "No");
  TestReportAddMiscInfo("Priority", "No");
  TestReportAddMiscInfo("Safety relevant", "No");
  
  AddRequirementInfo("Requirement under test", "ARCH_SW_DIA_0007; ARCH_SW_DIA_0070; ARCH_SW_DIA_0085; ARCH_SW_DIA_0071");
  AddRequirementInfo("ARCH_SW_DIA_0007", "Service 0x2E will be implemented for DID FD2A.");
  AddRequirementInfo("ARCH_SW_DIA_0070", "Service should be available in Development Session");
  AddRequirementInfo("ARCH_SW_DIA_0085", "Data Length shall be 1160 bytes long.");
  AddRequirementInfo("ARCH_SW_DIA_0071", "NVP_BLOCK_ID_STEPS0-144_RamBlockData will be Written.");


  ////***************************************************************************************

  testCaseComment("Preconditions");
  testStep("STEP", "Bench Initialization");
  RunPreTs();
  ////====================================================
    testStep("STEP", "Enter development session.");
  EnterDiagnosticSession("development");
  
  testStep("STEP", "Set breakpoint in function *DIA_runDidFD2A_StepsLibraryWrite*.");
  debugger_setRelativeFunctionBpAtLine("DIA_runDidFD2A_StepsLibraryWrite", 11);
  debugger_run();
 
  testCaseComment("Action: ARCH_SW_DIA_0007; ARCH_SW_DIA_0070; ARCH_SW_DIA_0085; ARCH_SW_DIA_0071");
  testStep("STEP", "Send diag request for 2E FD2A and wait for timeout error --> Timeout reached.");
  SendDiagnosticRequest(dWriteStepsConfigRequest, dWriteStepsConfigResponse, TRUE);

  testWaitForTimeout(2000);
  testStep("STEP", "Check if breakpoint from function DIA_runDidFD2A_StepsLibraryWrite was reached. --> BP was reached.");
  debugger_waitUntilBPisReached(5000);
  
  testStep("STEP", "Write first byte of NVP_BLOCK_ID_STEP_0_RamBlockData --> Variable overwritten with 0x1.");
  debugger_writeGlobalVariable("uint8", "NVP_BLOCK_ID_STEP_0_RamBlockData,,app.elf", 0, 1);
  i64NVP_BLOCK_ID_STEP_0_RamBlockData = debugger_readGlobalVariable("uint8", "NVP_BLOCK_ID_STEP_0_RamBlockData,,app.elf", 0);
  EvalManStepEqual("Byte was read", i64NVP_BLOCK_ID_STEP_0_RamBlockData);
  
  testStep("STEP", "Send diag request for 2E FD2A --> Response received.");
  debugger_deleteAllBP();
  debugger_run();
  testWaitForTimeout(2000);
  SendDiagnosticRequest(dWriteStepsConfigRequest, dWriteStepsConfigResponse);
  CheckPositiveResponse("",dWriteStepsConfigRequest, dWriteStepsConfigResponse);

  ////====================================================
  testCaseComment("Postcondition");
  testStep("STEP", "Return ECU to default values");
  RunPostTs();
}

testcase SW_IT_DIA_runDidFD03_AEETraceabilityNumberWrite_01()
{
  int64 i64NVP_BLOCK_ID_AEE_TRACEABILITY_RamBlockData;
  ////***********************************Test report header*********************************
  testReportAddMiscInfoBlock("AUTOLIV ELECTRONICS document");
  TestReportAddMiscInfo("Nightly test", "No");
  TestReportAddMiscInfo("Test type", "Requirement-Based test");
  TestReportAddMiscInfo("Regression Test", "No");
  TestReportAddMiscInfo("Fault injection method used", "No");
  TestReportAddMiscInfo("Resource usage evaluation", "No");
  TestReportAddMiscInfo("Priority", "No");
  TestReportAddMiscInfo("Safety relevant", "No");
  
  AddRequirementInfo("Requirement under test", "ARCH_SW_DIA_0009; ARCH_SW_DIA_0074; ARCH_SW_DIA_0075");
  AddRequirementInfo("ARCH_SW_DIA_0009", "Service 0x2E will be implemented for DID FD03");
  AddRequirementInfo("ARCH_SW_DIA_0074", "Service should be available in Default and extended session");
  AddRequirementInfo("ARCH_SW_DIA_0075", "NVP_BLOCK_ID_AEE_TRACEABILITY_RamBlockData will be Written.");
  ////***************************************************************************************

  testCaseComment("Preconditions");
  testStep("STEP", "Bench Initialization");
  RunPreTs();
  ////====================================================
  
  testCaseComment("Action: ARCH_SW_DIA_0009; ARCH_SW_DIA_0074; ARCH_SW_DIA_0075");
  
  testStep("STEP", "Enter development session.");
  EnterDiagnosticSession("development");
  
  testStep("STEP", "Set breakpoint in function *DIA_runDidFD03_AEETraceabilityNumbeWrite*.");
  debugger_setRelativeFunctionBpAtLine("DIA_runDidFD03_AEETraceabilityNumbeWrite", 6);
  debugger_run();
  testWaitForTimeout(2000);
 
  testStep("STEP", "Send diag request for 2E FD03 and wait for timeout error --> Timeout reached.");
  SendDiagnosticRequest(dECUSerialNumberWriteRequest, dECUSerialNumberWriteResponse, TRUE);

  testStep("STEP", "Check if breakpoint from function DIA_runDidFD03_AEETraceabilityNumbeWrite was reached. --> BP was reached.");
  debugger_waitUntilBPisReached(5000);
  
  testStep("STEP", "Write first byte of NVP_BLOCK_ID_AEE_TRACEABILITY_RamBlockData --> Variable overwritten with 0x1.");
  debugger_writeGlobalVariable("uint8", "NVP_BLOCK_ID_AEE_TRACEABILITY_RamBlockData,,app.elf", 0, 1);
  i64NVP_BLOCK_ID_AEE_TRACEABILITY_RamBlockData = debugger_readGlobalVariable("uint8", "NVP_BLOCK_ID_AEE_TRACEABILITY_RamBlockData,,app.elf", 0);
  EvalManStepEqual("Byte was read", i64NVP_BLOCK_ID_AEE_TRACEABILITY_RamBlockData);
  
  testStep("STEP", "Send diag request for 2E FD03 --> Response received.");
  debugger_deleteAllBP();
  debugger_run();
  testWaitForTimeout(2000);
  SendDiagnosticRequest(dECUSerialNumberWriteRequest, dECUSerialNumberWriteResponse);
  CheckPositiveResponse("",dECUSerialNumberWriteRequest, dECUSerialNumberWriteResponse);

  ////====================================================
  testCaseComment("Postcondition");
  testStep("STEP", "Return ECU to default values");
  RunPostTs();
}

testcase SW_IT_DIA_DataServices_PreSafe_Cycles_Level_1_8_CombinedSignal_WriteData_01()
{
  int64 i64NVP_BLOCK_ID_STEP_0_RamBlockData;
  ////***********************************Test report header*********************************
  testReportAddMiscInfoBlock("AUTOLIV ELECTRONICS document");
  TestReportAddMiscInfo("Nightly test", "No");
  TestReportAddMiscInfo("Test type", "Requirement-Based test");
  TestReportAddMiscInfo("Regression Test", "No");
  TestReportAddMiscInfo("Fault injection method used", "No");
  TestReportAddMiscInfo("Resource usage evaluation", "No");
  TestReportAddMiscInfo("Priority", "No");
  TestReportAddMiscInfo("Safety relevant", "No");
  
  AddRequirementInfo("Requirement under test", "ARCH_SW_DIA_0022; ARCH_SW_DIA_0088; ARCH_SW_DIA_0089; ARCH_SW_DIA_0203");
  AddRequirementInfo("ARCH_SW_DIA_0022", "Service 0x2E will be implemented for DID 0300");
  AddRequirementInfo("ARCH_SW_DIA_0088", "Service shall be available in Default, Extended and Development session");
  AddRequirementInfo("ARCH_SW_DIA_0089", "Request data shall be 1048 bytes long For R6.0 Request Data shall be 1072 bytes long");
  AddRequirementInfo("ARCH_SW_DIA_0203", "Blocks NVP_BLOCK_ID_CYCLE_0 to NVP_BLOCK_ID_CYCLE_25 and NVP_BLOCK_ID_STEP_0 to NVP_BLOCK_ID_STEP_91 shall be written");

  ////***************************************************************************************

  testCaseComment("Preconditions");
  testStep("STEP", "Bench Initialization");
  RunPreTs();
  ////====================================================
  testCaseComment("Action: ARCH_SW_DIA_0022; ARCH_SW_DIA_0088; ARCH_SW_DIA_0089; ARCH_SW_DIA_0203");
  
  testStep("STEP", "Enter development session.");
  EnterDiagnosticSession("development");
  
  testStep("STEP", "Set breakpoint in function *DataServices_PreSafe_Cycles_Level_1_8_CombinedSignal_WriteData*.");
  debugger_setRelativeFunctionBpAtLine("DataServices_PreSafe_Cycles_Level_1_8_CombinedSignal_WriteData", 42);
  
  testStep("STEP", "Send diag request for 2E 0300 and wait for timeout error --> Timeout reached.");
  SendDiagnosticRequest(dPresafeCycleWriteRequest, dPresafeCycleWriteResponse, TRUE);

  testWaitForTimeout(2000);
  testStep("STEP", "Check if breakpoint from function DataServices_PreSafe_Cycles_Level_1_8_CombinedSignal_WriteData was reached. --> BP was reached.");
  debugger_waitUntilBPisReached(5000);

  testStep("STEP", "Write first byte of NVP_BLOCK_ID_STEP_0_RamBlockData --> Variable overwritten with 0x1.");
  debugger_writeGlobalVariable("uint8", "NVP_BLOCK_ID_STEP_0_RamBlockData,,app.elf", 0, 1);
  i64NVP_BLOCK_ID_STEP_0_RamBlockData = debugger_readGlobalVariable("uint8", "NVP_BLOCK_ID_STEP_0_RamBlockData,,app.elf", 0);
  EvalManStepEqual("Byte was read", i64NVP_BLOCK_ID_STEP_0_RamBlockData);
  
  testStep("STEP", "Send diag request for 2E 0300 --> Response received.");
  debugger_deleteAllBP();
  debugger_run();
  testWaitForTimeout(2000);
  SendDiagnosticRequest(dPresafeCycleWriteRequest, dPresafeCycleWriteResponse);
  CheckPositiveResponse("",dPresafeCycleWriteRequest, dPresafeCycleWriteResponse);
  
  ////====================================================
  testCaseComment("Postcondition");
  testStep("STEP", "Return ECU to default values");
  RunPostTs();
}

testcase SW_IT_DIA_DataServices_Release_Cycles_BSR_and_PreSafe_CombinedSignal_ReadData_WriteData_01()
{
  int64 i64NVP_BLOCK_ID_CYCLE_0_RamBlockData;
  //***********************************Test report header*********************************
  testReportAddMiscInfoBlock("AUTOLIV ELECTRONICS document");
  TestReportAddMiscInfo("Nightly test", "No");
  TestReportAddMiscInfo("Test type", "Requirement-Based test");
  TestReportAddMiscInfo("Regression Test", "No");
  TestReportAddMiscInfo("Fault injection method used", "No");
  TestReportAddMiscInfo("Resource usage evaluation", "No");
  TestReportAddMiscInfo("Priority", "No");
  TestReportAddMiscInfo("Safety relevant", "No");
  
  AddRequirementInfo("Requirement under test", "ARCH_SW_DIA_0024; ARCH_SW_DIA_0093; ARCH_SW_DIA_0094; ARCH_SW_DIA_0095");
  AddRequirementInfo("ARCH_SW_DIA_0024", "Service 0x2E will be implemented for DID 0301");
  AddRequirementInfo("ARCH_SW_DIA_0093", "Service shall be available in Default, Extended and Development session");
  AddRequirementInfo("ARCH_SW_DIA_0094", "Request data shall be 144 bytes long");
  AddRequirementInfo("ARCH_SW_DIA_0095", "Blocks NVP_BLOCK_ID_CYCLE_29 to NVP_BLOCK_ID_CYCLE_32 and NVP_BLOCK_ID_STEP_92 to NVP_BLOCK_ID_STEP_115 shall be written");

  //***************************************************************************************

  testCaseComment("Preconditions");
  testStep("STEP", "Bench Initialization");
  RunPreTs();
  //====================================================
  testStep("STEP", "Set breakpoint in function *DataServices_Release_Cycles_BSR_and_PreSafe_CombinedSignal_ReadData_WriteData*.");
  debugger_setRelativeFunctionBpAtLine("DataServices_Release_Cycles_BSR_and_PreSafe_CombinedSignal_ReadData_WriteData", 37);
  debugger_run();
 
  testCaseComment("Action: ARCH_SW_DIA_0024; ARCH_SW_DIA_0093; ARCH_SW_DIA_0094; ARCH_SW_DIA_0095");
  testStep("STEP", "Send diag request for 2E 0301 and wait for timeout error --> Timeout reached.");
  SendDiagnosticRequest(dReleaseCyclesBSRandPresafeWriteRequest, dReleaseCyclesBSRandPresafeWriteResponse, TRUE);

  testWaitForTimeout(2000);
  testStep("STEP", "Check if breakpoint from function DataServices_Release_Cycles_BSR_and_PreSafe_CombinedSignal_ReadData_WriteData was reached. --> BP was reached.");
  debugger_waitUntilBPisReached(5000);
  
  
  testStep("STEP", "Write 29th byte of NVP_BLOCK_ID_CYCLE_0_RamBlockData --> Variable overwritten with 0x1.");
  debugger_writeGlobalVariable("uint8", "NVP_BLOCK_ID_CYCLE_0_RamBlockData,,app.elf,,app.elf", 29, 1);
  i64NVP_BLOCK_ID_CYCLE_0_RamBlockData = debugger_readGlobalVariable("uint8", "NVP_BLOCK_ID_CYCLE_0_RamBlockData,,app.elf", 0);
  EvalManStepEqual("Byte was read", i64NVP_BLOCK_ID_CYCLE_0_RamBlockData);

  testStep("STEP", "Send diag request for 2E 0301 --> Response received.");
  debugger_deleteAllBP();
  debugger_run();
  testWaitForTimeout(2000);
  SendDiagnosticRequest(dReleaseCyclesBSRandPresafeWriteRequest, dReleaseCyclesBSRandPresafeWriteResponse);
  CheckPositiveResponse("",dReleaseCyclesBSRandPresafeWriteRequest, dReleaseCyclesBSRandPresafeWriteResponse);
  //====================================================
  testCaseComment("Postcondition");
  testStep("STEP", "Return ECU to default values");
  RunPostTs();
}


testcase SW_IT_DIA_DataServices_Tensioning_Cycle_BSR_CombinedSignal_WriteData_01()
{
  int64 i64NVP_BLOCK_ID_CYCLE_0_RamBlockData;
  ////***********************************Test report header*********************************
  testReportAddMiscInfoBlock("AUTOLIV ELECTRONICS document");
  TestReportAddMiscInfo("Nightly test", "No");
  TestReportAddMiscInfo("Test type", "Requirement-Based test");
  TestReportAddMiscInfo("Regression Test", "No");
  TestReportAddMiscInfo("Fault injection method used", "No");
  TestReportAddMiscInfo("Resource usage evaluation", "No");
  TestReportAddMiscInfo("Priority", "No");
  TestReportAddMiscInfo("Safety relevant", "No");
  
  AddRequirementInfo("Requirement under test", "ARCH_SW_DIA_0026; ARCH_SW_DIA_0099; ARCH_SW_DIA_0100; ARCH_SW_DIA_0101;");
  AddRequirementInfo("ARCH_SW_DIA_0026", "Service 0x2E will be implemented for DID 0302");
  AddRequirementInfo("ARCH_SW_DIA_0099", "Service shall be available in Default, Extended and Development session");
  AddRequirementInfo("ARCH_SW_DIA_0100", "Request data shall be 228 bytes long For R6.0 Request Data shall be 233 bytes long");
  AddRequirementInfo("ARCH_SW_DIA_0101", "Blocks NVP_BLOCK_ID_CYCLE_26 to NVP_BLOCK_ID_CYCLE_28 and NVP_BLOCK_ID_STEP_116 to NVP_BLOCK_ID_STEP_144 shall be written");

  ////***************************************************************************************

  testCaseComment("Preconditions");
  testStep("STEP", "Bench Initialization");
  RunPreTs();
  ////====================================================
    testStep("STEP", "Enter development session.");
  EnterDiagnosticSession("development");
  
  testStep("STEP", "Set breakpoint in function *DataServices_Tensioning_Cycle_BSR_CombinedSignal_WriteData*.");
  debugger_setRelativeFunctionBpAtLine("DataServices_Tensioning_Cycle_BSR_CombinedSignal_WriteData", 37);
  debugger_run();
 
  testCaseComment("Action: ARCH_SW_DIA_0026; ARCH_SW_DIA_0099; ARCH_SW_DIA_0100; ARCH_SW_DIA_0101");
  testStep("STEP", "Send diag request for 2E 0302 and wait for timeout error --> Timeout reached.");
  SendDiagnosticRequest(dTensioningCycleBSRWriteRequest, dTensioningCycleBSRWriteResponse, TRUE);

  testWaitForTimeout(2000);
  testStep("STEP", "Check if breakpoint from function DataServices_Tensioning_Cycle_BSR_CombinedSignal_WriteData was reached. --> BP was reached.");
  debugger_waitUntilBPisReached(5000);
  
  
  testStep("STEP", "Write 26th byte of NVP_BLOCK_ID_CYCLE_0_RamBlockData --> Variable overwritten with 0x1.");
  debugger_writeGlobalVariable("uint8", "NVP_BLOCK_ID_CYCLE_0_RamBlockData,,app.elf,,app.elf", 26, 1);
  i64NVP_BLOCK_ID_CYCLE_0_RamBlockData = debugger_readGlobalVariable("uint8", "NVP_BLOCK_ID_CYCLE_0_RamBlockData,,app.elf,,app.elf", 26);
  EvalManStepEqual("Byte was read", i64NVP_BLOCK_ID_CYCLE_0_RamBlockData);

  testStep("STEP", "Send diag request for 2E 0302 --> Response received.");
  debugger_deleteAllBP();
  debugger_run();
  testWaitForTimeout(2000);
  SendDiagnosticRequest(dTensioningCycleBSRWriteRequest, dTensioningCycleBSRWriteResponse);
  CheckPositiveResponse("",dTensioningCycleBSRWriteRequest, dTensioningCycleBSRWriteResponse);
  ////====================================================
  testCaseComment("Postcondition");
  testStep("STEP", "Return ECU to default values");
  RunPostTs();
}

testcase SW_IT_DIA_DataServices_Vehicle_Equipment_Read_Equipment_1_WriteData_01()
{

  //***********************************Test report header*********************************
  testReportAddMiscInfoBlock("AUTOLIV ELECTRONICS document");
  TestReportAddMiscInfo("Nightly test", "No");
  TestReportAddMiscInfo("Test type", "Requirement-Based test");
  TestReportAddMiscInfo("Regression Test", "No");
  TestReportAddMiscInfo("Fault injection method used", "No");
  TestReportAddMiscInfo("Resource usage evaluation", "No");
  TestReportAddMiscInfo("Priority", "No");
  TestReportAddMiscInfo("Safety relevant", "No");
  
  AddRequirementInfo("Requirement under test", "ARCH_SW_DIA_0028; ARCH_SW_DIA_0105; ARCH_SW_DIA_0106; ARCH_SW_DIA_0107; ARCH_SW_DIA_0393; ARCH_SW_DIA_0046");
  AddRequirementInfo("ARCH_SW_DIA_0028", "Service 0x2E will be implemented for DID 0310");
  AddRequirementInfo("ARCH_SW_DIA_0105", "Service shall be available in Default, Extended and Development session");
  AddRequirementInfo("ARCH_SW_DIA_0106", "Request data shall be 1 byte long");
  AddRequirementInfo("ARCH_SW_DIA_0107", "Runnable shall write Equipment 1 stored in Rte_Ct_MBBL_SsaAppl_Coding_VehicleEquipment.Equipment1");
  AddRequirementInfo("ARCH_SW_DIA_0393", "The new data written by Vehicle Equipment Configuration Data service (0x2E 0310) shall be stored in non-volatile memoy and shall be available only after reset.");
  AddRequirementInfo("ARCH_SW_DIA_0046", "There shall be 2 reserved bytes located between Equipment 6 and Uberspannungsabbruchschwelle for request write of DID 0310");

  //***************************************************************************************

  testCaseComment("Preconditions");
  testStep("STEP", "Bench Initialization");
  RunPreTs();
  //====================================================
 
  testStep("STEP", "Enter development session.");
  EnterDiagnosticSession("development");
  
  testStep("STEP", "Set breakpoint in function *DataServices_Vehicle_Equipment_Read_Equipment_1_WriteData*.");
  debugger_setRelativeFunctionBpAtLine("DataServices_Vehicle_Equipment_Read_Equipment_1_WriteData", 11);
  debugger_run();
 
  testCaseComment("Action: ARCH_SW_DIA_0028; ARCH_SW_DIA_0105; ARCH_SW_DIA_0106; ARCH_SW_DIA_0107; ARCH_SW_DIA_0393; ARCH_SW_DIA_0046");
  testStep("STEP", "Send diag request for 2E 0310 and wait for timeout error --> Timeout reached.");
  SendDiagnosticRequest(dVehicleEquipmentWriteRequest, dVehicleEquipmentWriteResponse, TRUE);

  testWaitForTimeout(2000);
  testStep("STEP", "Check if breakpoint from function DataServices_Vehicle_Equipment_Read_Equipment_1_WriteData was reached. --> BP was reached.");
  debugger_waitUntilBPisReached(5000);
  debugger_isCPUStoppedAtFunction("DataServices_Vehicle_Equipment_Read_Equipment_1_WriteData");

  //====================================================
  testCaseComment("Postcondition");
  testStep("STEP", "Return ECU to default values");
  RunPostTs();
}

testcase SW_IT_DIA_DataServices_Vehicle_Equipment_Read_Equipment_2_WriteData_01()
{

  //***********************************Test report header*********************************
  testReportAddMiscInfoBlock("AUTOLIV ELECTRONICS document");
  TestReportAddMiscInfo("Nightly test", "No");
  TestReportAddMiscInfo("Test type", "Requirement-Based test");
  TestReportAddMiscInfo("Regression Test", "No");
  TestReportAddMiscInfo("Fault injection method used", "No");
  TestReportAddMiscInfo("Resource usage evaluation", "No");
  TestReportAddMiscInfo("Priority", "No");
  TestReportAddMiscInfo("Safety relevant", "No");
  
  AddRequirementInfo("Requirement under test", "ARCH_SW_DIA_0028; ARCH_SW_DIA_0110; ARCH_SW_DIA_0111;");
  AddRequirementInfo("ARCH_SW_DIA_0028", "Service 0x2E will be implemented for DID 0310");
  AddRequirementInfo("ARCH_SW_DIA_0110", "Request data shall be 1 byte long");
  AddRequirementInfo("ARCH_SW_DIA_0111", "Runnable shall write Equipment 2 stored in Rte_Ct_MBBL_SsaAppl_Coding_VehicleEquipment.Equipment2");

  //***************************************************************************************

  testCaseComment("Preconditions");
  testStep("STEP", "Bench Initialization");
  RunPreTs();
  //====================================================
  testStep("STEP", "Enter development session.");
  EnterDiagnosticSession("development");

  testStep("STEP", "Set breakpoint in function *DataServices_Vehicle_Equipment_Read_Equipment_2_WriteData*.");
  debugger_setRelativeFunctionBpAtLine("DataServices_Vehicle_Equipment_Read_Equipment_2_WriteData", 11);
  debugger_run();
 
  testCaseComment("Action: ARCH_SW_DIA_0028; ARCH_SW_DIA_0110; ARCH_SW_DIA_0111;");
  testStep("STEP", "Send diag request for 2E 0310 and wait for timeout error --> Timeout reached.");
  SendDiagnosticRequest(dVehicleEquipmentWriteRequest, dVehicleEquipmentWriteResponse, TRUE);

  testWaitForTimeout(2000);
  testStep("STEP", "Check if breakpoint from function DataServices_Vehicle_Equipment_Read_Equipment_2_WriteData was reached. --> BP was reached.");
  debugger_waitUntilBPisReached(5000);
  

  //====================================================
  testCaseComment("Postcondition");
  testStep("STEP", "Return ECU to default values");
  RunPostTs();
}

testcase SW_IT_DIA_DataServices_Vehicle_Equipment_Read_Equipment_3_WriteData_01()
{
  
  //***********************************Test report header*********************************
  testReportAddMiscInfoBlock("AUTOLIV ELECTRONICS document");
  TestReportAddMiscInfo("Nightly test", "No");
  TestReportAddMiscInfo("Test type", "Requirement-Based test");
  TestReportAddMiscInfo("Regression Test", "No");
  TestReportAddMiscInfo("Fault injection method used", "No");
  TestReportAddMiscInfo("Resource usage evaluation", "No");
  TestReportAddMiscInfo("Priority", "No");
  TestReportAddMiscInfo("Safety relevant", "No");
  
  AddRequirementInfo("Requirement under test", "ARCH_SW_DIA_0028; ARCH_SW_DIA_0114;");
  AddRequirementInfo("ARCH_SW_DIA_0028", "Service 0x2E will be implemented for DID 0310");
  AddRequirementInfo("ARCH_SW_DIA_0114", "Request data shall be 1 byte long");
  AddRequirementInfo("ARCH_SW_DIA_0115", "Runnable shall write Equipment 3 stored in Rte_Ct_MBBL_SsaAppl_Coding_VehicleEquipment.Equipment3");

  //***************************************************************************************

  testCaseComment("Preconditions");
  testStep("STEP", "Bench Initialization");
  RunPreTs();
  //====================================================
  testStep("STEP", "Enter development session.");
  EnterDiagnosticSession("development");
  
  testStep("STEP", "Set breakpoint in function *DataServices_Vehicle_Equipment_Read_Equipment_3_WriteData*.");
  debugger_setRelativeFunctionBpAtLine("DataServices_Vehicle_Equipment_Read_Equipment_3_WriteData", 11);
  debugger_run();
 
  testCaseComment("Action:ARCH_SW_DIA_0028; ARCH_SW_DIA_0114; ARCH_SW_DIA_0115");
  testStep("STEP", "Send diag request for 2E 0310 and wait for timeout error --> Timeout reached.");
  SendDiagnosticRequest(dVehicleEquipmentWriteRequest, dVehicleEquipmentWriteResponse, TRUE);

  testWaitForTimeout(2000);
  testStep("STEP", "Check if breakpoint from function DataServices_Vehicle_Equipment_Read_Equipment_3_WriteData was reached. --> BP was reached.");
  debugger_waitUntilBPisReached(5000);
  
  
  //====================================================
  testCaseComment("Postcondition");
  testStep("STEP", "Return ECU to default values");
  RunPostTs();
}

testcase SW_IT_DIA_DataServices_Vehicle_Equipment_Read_Equipment_4_WriteData_01()
{
  //***********************************Test report header*********************************
  testReportAddMiscInfoBlock("AUTOLIV ELECTRONICS document");
  TestReportAddMiscInfo("Nightly test", "No");
  TestReportAddMiscInfo("Test type", "Requirement-Based test");
  TestReportAddMiscInfo("Regression Test", "No");
  TestReportAddMiscInfo("Fault injection method used", "No");
  TestReportAddMiscInfo("Resource usage evaluation", "No");
  TestReportAddMiscInfo("Priority", "No");
  TestReportAddMiscInfo("Safety relevant", "No");
  
  AddRequirementInfo("Requirement under test", "ARCH_SW_DIA_0028; ARCH_SW_DIA_0118; ARCH_SW_DIA_0119;");
  AddRequirementInfo("ARCH_SW_DIA_0028", "Service 0x2E will be implemented for DID 0310");
  AddRequirementInfo("ARCH_SW_DIA_0118", "Request data shall be 1 byte long");
  AddRequirementInfo("ARCH_SW_DIA_0119", "Runnable shall write Equipment 4 stored in Rte_Ct_MBBL_SsaAppl_Coding_VehicleEquipment.Equipment4");

  //***************************************************************************************

  testCaseComment("Preconditions");
  testStep("STEP", "Bench Initialization");
  RunPreTs();
  //====================================================
  testStep("STEP", "Enter development session.");
  EnterDiagnosticSession("development");
  
  testStep("STEP", "Set breakpoint in function *DataServices_Vehicle_Equipment_Read_Equipment_4_WriteData*.");
  debugger_setRelativeFunctionBpAtLine("DataServices_Vehicle_Equipment_Read_Equipment_4_WriteData", 11);
  debugger_run();
 
  testCaseComment("Action: ARCH_SW_DIA_0028; ARCH_SW_DIA_0118; ARCH_SW_DIA_0119;");
  testStep("STEP", "Send diag request for 2E 0310 and wait for timeout error --> Timeout reached.");
  SendDiagnosticRequest(dVehicleEquipmentWriteRequest, dVehicleEquipmentWriteResponse, TRUE);

  testWaitForTimeout(2000);
  testStep("STEP", "Check if breakpoint from function DataServices_Vehicle_Equipment_Read_Equipment_4_WriteData was reached. --> BP was reached.");
  debugger_waitUntilBPisReached(5000);
  
  
  //====================================================
  testCaseComment("Postcondition");
  testStep("STEP", "Return ECU to default values");
  RunPostTs();
}

testcase SW_IT_DIA_DataServices_Vehicle_Equipment_Read_Equipment_5_WriteData_01()
{
  //***********************************Test report header*********************************
  testReportAddMiscInfoBlock("AUTOLIV ELECTRONICS document");
  TestReportAddMiscInfo("Nightly test", "No");
  TestReportAddMiscInfo("Test type", "Requirement-Based test");
  TestReportAddMiscInfo("Regression Test", "No");
  TestReportAddMiscInfo("Fault injection method used", "No");
  TestReportAddMiscInfo("Resource usage evaluation", "No");
  TestReportAddMiscInfo("Priority", "No");
  TestReportAddMiscInfo("Safety relevant", "No");
  
  AddRequirementInfo("Requirement under test", "ARCH_SW_DIA_0028; ARCH_SW_DIA_0122; ARCH_SW_DIA_0123;");
  AddRequirementInfo("ARCH_SW_DIA_0028", "Service 0x2E will be implemented for DID 0310");
  AddRequirementInfo("ARCH_SW_DIA_0122", "Request data shall be 1 byte long");
  AddRequirementInfo("ARCH_SW_DIA_0123", "Runnable shall write Equipment 5 stored in Rte_Ct_MBBL_SsaAppl_Coding_VehicleEquipment.Equipment5");

  //***************************************************************************************

  testCaseComment("Preconditions");
  testStep("STEP", "Bench Initialization");
  RunPreTs();
  //====================================================
  testStep("STEP", "Enter development session.");
  EnterDiagnosticSession("development");
  
  @SecVarCodingPanel::Button_CodingStart = 1;
  testWaitForTimeout(2000);
  
  testStep("STEP", "Set breakpoint in function *DataServices_Vehicle_Equipment_Read_Equipment_5_WriteData*.");
  debugger_setRelativeFunctionBpAtLine("DataServices_Vehicle_Equipment_Read_Equipment_5_WriteData", 11);
  debugger_run();
 
  testCaseComment("Action: ARCH_SW_DIA_0028; ARCH_SW_DIA_0122; ARCH_SW_DIA_0123;");
  testStep("STEP", "Send diag request for 2E 0310 and wait for timeout error --> Timeout reached.");
  SendDiagnosticRequest(dVehicleEquipmentWriteRequest, dVehicleEquipmentWriteResponse, TRUE);

  testWaitForTimeout(2000);
  testStep("STEP", "Check if breakpoint from function DataServices_Vehicle_Equipment_Read_Equipment_5_WriteData was reached. --> BP was reached.");
  debugger_waitUntilBPisReached(5000);
  
 
  //====================================================
  testCaseComment("Postcondition");
  testStep("STEP", "Return ECU to default values");
  RunPostTs();
}

testcase SW_IT_DIA_DataServices_Vehicle_Equipment_Read_Equipment_6_WriteData_01()
{
  //***********************************Test report header*********************************
  testReportAddMiscInfoBlock("AUTOLIV ELECTRONICS document");
  TestReportAddMiscInfo("Nightly test", "No");
  TestReportAddMiscInfo("Test type", "Requirement-Based test");
  TestReportAddMiscInfo("Regression Test", "No");
  TestReportAddMiscInfo("Fault injection method used", "No");
  TestReportAddMiscInfo("Resource usage evaluation", "No");
  TestReportAddMiscInfo("Priority", "No");
  TestReportAddMiscInfo("Safety relevant", "No");
  
  AddRequirementInfo("Requirement under test", "ARCH_SW_DIA_0028; ARCH_SW_DIA_0126; ARCH_SW_DIA_0127;");
  AddRequirementInfo("ARCH_SW_DIA_0028", "Service 0x2E will be implemented for DID 0310");
  AddRequirementInfo("ARCH_SW_DIA_0126", "Request data shall be 1 byte long");
  AddRequirementInfo("ARCH_SW_DIA_0127", "Runnable shall write Equipment 6 stored in Rte_Ct_MBBL_SsaAppl_Coding_VehicleEquipment.Equipment6");

  //***************************************************************************************

  testCaseComment("Preconditions");
  testStep("STEP", "Bench Initialization");
  RunPreTs();
  //====================================================
  testStep("STEP", "Enter development session.");
  EnterDiagnosticSession("development");
  
  testStep("STEP", "Set breakpoint in function *DataServices_Vehicle_Equipment_Read_Equipment_6_WriteData*.");
  debugger_setRelativeFunctionBpAtLine("DataServices_Vehicle_Equipment_Read_Equipment_6_WriteData", 11);
  debugger_run();
 
  testCaseComment("Action: ARCH_SW_DIA_0028; ARCH_SW_DIA_0126; ARCH_SW_DIA_0127;");
  testStep("STEP", "Send diag request for 2E 0310 and wait for timeout error --> Timeout reached.");
  SendDiagnosticRequest(dVehicleEquipmentWriteRequest, dVehicleEquipmentWriteResponse, TRUE);

  testWaitForTimeout(2000);
  testStep("STEP", "Check if breakpoint from function DataServices_Vehicle_Equipment_Read_Equipment_6_WriteData was reached. --> BP was reached.");
  debugger_waitUntilBPisReached(5000);
  
  
  //====================================================
  testCaseComment("Postcondition");
  testStep("STEP", "Return ECU to default values");
  RunPostTs();
}

testcase SW_IT_DIA_DataServices_Vehicle_Equipment_Read_Uberspannungsabbruchschwelle_WriteData_01()
{
  //***********************************Test report header*********************************
  testReportAddMiscInfoBlock("AUTOLIV ELECTRONICS document");
  TestReportAddMiscInfo("Nightly test", "No");
  TestReportAddMiscInfo("Test type", "Requirement-Based test");
  TestReportAddMiscInfo("Regression Test", "No");
  TestReportAddMiscInfo("Fault injection method used", "No");
  TestReportAddMiscInfo("Resource usage evaluation", "No");
  TestReportAddMiscInfo("Priority", "No");
  TestReportAddMiscInfo("Safety relevant", "No");
  
  AddRequirementInfo("Requirement under test", "ARCH_SW_DIA_0028; ARCH_SW_DIA_0130; ARCH_SW_DIA_0131;");
  AddRequirementInfo("ARCH_SW_DIA_0028", "Service 0x2E will be implemented for DID 0310");
  AddRequirementInfo("ARCH_SW_DIA_0130", "Request data shall be 2 bytes long");
  AddRequirementInfo("ARCH_SW_DIA_0131", "Runanble shall write Uberspannungsabbruchschwelle stored in Rte_Ct_MBBL_SsaAppl_Coding_VehicleEquipment. Uberspannungsabbruchschwelle");

  //***************************************************************************************

  testCaseComment("Preconditions");
  testStep("STEP", "Bench Initialization");
  RunPreTs();
  //====================================================
  testStep("STEP", "Enter development session.");
  EnterDiagnosticSession("development");
  
  testStep("STEP", "Set breakpoint in function *DataServices_Vehicle_Equipment_Read_Uberspannungsabbruchschwelle_WriteData*.");
  debugger_setRelativeFunctionBpAtLine("DataServices_Vehicle_Equipment_Read_Uberspannungsabbruchschwelle_WriteData", 11);
  debugger_run();
 
  testCaseComment("Action: ARCH_SW_DIA_0028; ARCH_SW_DIA_0130; ARCH_SW_DIA_0131;");
  testStep("STEP", "Send diag request for 2E 0310 and wait for timeout error --> Timeout reached.");
  SendDiagnosticRequest(dVehicleEquipmentWriteRequest, dVehicleEquipmentWriteResponse, TRUE);

  testWaitForTimeout(2000);
  testStep("STEP", "Check if breakpoint from function DataServices_Vehicle_Equipment_Read_Uberspannungsabbruchschwelle_WriteData was reached. --> BP was reached.");
  debugger_waitUntilBPisReached(5000);
  
  
  //====================================================
  testCaseComment("Postcondition");
  testStep("STEP", "Return ECU to default values");
  RunPostTs();
}

testcase SW_IT_DIA_DataServices_Vehicle_Equipment_Read_Uberspannungsbereichsschwelle_WriteData_01()
{
  //***********************************Test report header*********************************
  testReportAddMiscInfoBlock("AUTOLIV ELECTRONICS document");
  TestReportAddMiscInfo("Nightly test", "No");
  TestReportAddMiscInfo("Test type", "Requirement-Based test");
  TestReportAddMiscInfo("Regression Test", "No");
  TestReportAddMiscInfo("Fault injection method used", "No");
  TestReportAddMiscInfo("Resource usage evaluation", "No");
  TestReportAddMiscInfo("Priority", "No");
  TestReportAddMiscInfo("Safety relevant", "No");
  
  AddRequirementInfo("Requirement under test", "ARCH_SW_DIA_0028; ARCH_SW_DIA_0134; ARCH_SW_DIA_0135;");
  AddRequirementInfo("ARCH_SW_DIA_0028", "Service 0x2E will be implemented for DID 0310");
  AddRequirementInfo("ARCH_SW_DIA_0134", "Request data shall be 2 bytes long");
  AddRequirementInfo("ARCH_SW_DIA_0135", "Runanble shall write Uberspannungsbereichsschwelle stored in Rte_Ct_MBBL_SsaAppl_Coding_VehicleEquipment. Uberspannungsbereichsschwelle");

  //***************************************************************************************

  testCaseComment("Preconditions");
  testStep("STEP", "Bench Initialization");
  RunPreTs();
  //====================================================
  testStep("STEP", "Enter development session.");
  EnterDiagnosticSession("development");

  testStep("STEP", "Set breakpoint in function *DataServices_Vehicle_Equipment_Read_Uberspannungsabbruchschwelle_WriteData*.");
  debugger_setRelativeFunctionBpAtLine("DataServices_Vehicle_Equipment_Read_Uberspannungsabbruchschwelle_WriteData", 11);
  debugger_run();
 
  testCaseComment("Action: ARCH_SW_DIA_0028; ARCH_SW_DIA_0134; ARCH_SW_DIA_0135;");
  testStep("STEP", "Send diag request for 2E 0310 and wait for timeout error --> Timeout reached.");
  SendDiagnosticRequest(dVehicleEquipmentWriteRequest, dVehicleEquipmentWriteResponse, TRUE);

  testWaitForTimeout(2000);
  testStep("STEP", "Check if breakpoint from function DataServices_Vehicle_Equipment_Read_Uberspannungsabbruchschwelle_WriteData was reached. --> BP was reached.");
  debugger_waitUntilBPisReached(5000);
  debugger_isCPUStoppedAtFunction("DataServices_Vehicle_Equipment_Read_Uberspannungsabbruchschwelle_WriteData");
  
  
  //====================================================
  testCaseComment("Postcondition");
  testStep("STEP", "Return ECU to default values");
  RunPostTs();
}

testcase SW_IT_DIA_DataServices_Vehicle_Equipment_Read_Unterspannungsabbruchschwelle_WriteData_01()
{
  //***********************************Test report header*********************************
  testReportAddMiscInfoBlock("AUTOLIV ELECTRONICS document");
  TestReportAddMiscInfo("Nightly test", "No");
  TestReportAddMiscInfo("Test type", "Requirement-Based test");
  TestReportAddMiscInfo("Regression Test", "No");
  TestReportAddMiscInfo("Fault injection method used", "No");
  TestReportAddMiscInfo("Resource usage evaluation", "No");
  TestReportAddMiscInfo("Priority", "No");
  TestReportAddMiscInfo("Safety relevant", "No");
  
  AddRequirementInfo("Requirement under test", "ARCH_SW_DIA_0028; ARCH_SW_DIA_0138; ARCH_SW_DIA_0139;");
  AddRequirementInfo("ARCH_SW_DIA_0028", "Service 0x2E will be implemented for DID 0310");
  AddRequirementInfo("ARCH_SW_DIA_0138", "Request data shall be 2 bytes long");
  AddRequirementInfo("ARCH_SW_DIA_0139", "Runanble shall write Unterspannungsabbruchschwelle stored in Rte_Ct_MBBL_SsaAppl_Coding_VehicleEquipment. Unterspannungsabbruchschwelle");

  //***************************************************************************************

  testCaseComment("Preconditions");
  testStep("STEP", "Bench Initialization");
  

  RunPreTs();
  //====================================================
  testStep("STEP", "Enter development session.");
  EnterDiagnosticSession("development");
  
  @SecVarCodingPanel::Button_CodingStart = 1;
  testWaitForTimeout(2000);
  
  testStep("STEP", "Set breakpoint in function *DataServices_Vehicle_Equipment_Read_Unterspannungsabbruchschwelle_WriteData*.");
  debugger_setRelativeFunctionBpAtLine("DataServices_Vehicle_Equipment_Read_Unterspannungsabbruchschwelle_WriteData", 11);
  debugger_run();
 
  testCaseComment("Action: ARCH_SW_DIA_0028; ARCH_SW_DIA_0138; ARCH_SW_DIA_0139;");
  testStep("STEP", "Send diag request for 2E 0310 and wait for timeout error --> Timeout reached.");
  SendDiagnosticRequest(dVehicleEquipmentWriteRequest, dVehicleEquipmentWriteResponse, TRUE);

  testWaitForTimeout(2000);
  testStep("STEP", "Check if breakpoint from function DataServices_Vehicle_Equipment_Read_Unterspannungsabbruchschwelle_WriteData was reached. --> BP was reached.");
  debugger_waitUntilBPisReached(5000);
  
  
  @SecVarCodingPanel::Button_CancelSequence = 1;
  testWaitForTimeout(2000);
  //====================================================
  testCaseComment("Postcondition");
  testStep("STEP", "Return ECU to default values");
  RunPostTs();
}

testcase SW_IT_DIA_DataServices_Vehicle_Equipment_Read_Unterspannungsbereichsschwelle_WriteData_01()
{
  //***********************************Test report header*********************************
  testReportAddMiscInfoBlock("AUTOLIV ELECTRONICS document");
  TestReportAddMiscInfo("Nightly test", "No");
  TestReportAddMiscInfo("Test type", "Requirement-Based test");
  TestReportAddMiscInfo("Regression Test", "No");
  TestReportAddMiscInfo("Fault injection method used", "No");
  TestReportAddMiscInfo("Resource usage evaluation", "No");
  TestReportAddMiscInfo("Priority", "No");
  TestReportAddMiscInfo("Safety relevant", "No");
  
  AddRequirementInfo("Requirement under test", "ARCH_SW_DIA_0028; ARCH_SW_DIA_0142; ARCH_SW_DIA_0143");
  AddRequirementInfo("ARCH_SW_DIA_0028", "Service 0x2E will be implemented for DID 0310");
  AddRequirementInfo("ARCH_SW_DIA_0142", "Request data shall be 2 bytes long");
  AddRequirementInfo("ARCH_SW_DIA_0143", "Runanble shall write Unterspannungsbereichsschwelle stored in Rte_Ct_MBBL_SsaAppl_Coding_VehicleEquipment. Unterspannungsbereichsschwelle");

  //***************************************************************************************

  testCaseComment("Preconditions");
  testStep("STEP", "Bench Initialization");
  RunPreTs();
  //====================================================
  testStep("STEP", "Enter development session.");
  EnterDiagnosticSession("development");
  
  testStep("STEP", "Set breakpoint in function *DataServices_Vehicle_Equipment_Read_Unterspannungsbereichsschwelle_WriteData*.");
  debugger_setRelativeFunctionBpAtLine("DataServices_Vehicle_Equipment_Read_Unterspannungsbereichsschwelle_WriteData", 11);
  debugger_run();
 
  testCaseComment("Action: ARCH_SW_DIA_0028; ARCH_SW_DIA_0142; ARCH_SW_DIA_0143;");
  testStep("STEP", "Send diag request for 2E 0310 and wait for timeout error --> Timeout reached.");
  SendDiagnosticRequest(dVehicleEquipmentWriteRequest, dVehicleEquipmentWriteResponse, TRUE);

  testWaitForTimeout(2000);
  testStep("STEP", "Check if breakpoint from function DataServices_Vehicle_Equipment_Read_Unterspannungsbereichsschwelle_WriteData was reached. --> BP was reached.");
  debugger_waitUntilBPisReached(5000);
  
  
  //====================================================
  testCaseComment("Postcondition");
  testStep("STEP", "Return ECU to default values");
  RunPostTs();
}

testcase SW_IT_DIA_DataServices_ZZZ_Vehicle_Equipment_Development_Read_Zykluszeit_Messtechnik_WriteData_01()
{
  int64 i64Rte_Ct_MBBL_SsaAppl_Coding_ZZZ_VehicleEquipment_Development;
  //***********************************Test report header*********************************
  testReportAddMiscInfoBlock("AUTOLIV ELECTRONICS document");
  TestReportAddMiscInfo("Nightly test", "No");
  TestReportAddMiscInfo("Test type", "Requirement-Based test");
  TestReportAddMiscInfo("Regression Test", "No");
  TestReportAddMiscInfo("Fault injection method used", "No");
  TestReportAddMiscInfo("Resource usage evaluation", "No");
  TestReportAddMiscInfo("Priority", "No");
  TestReportAddMiscInfo("Safety relevant", "No");
  
  AddRequirementInfo("Requirement under test", "ARCH_SW_DIA_0030; ARCH_SW_DIA_0152; ARCH_SW_DIA_0153; ARCH_SW_DIA_0394; ARCH_SW_DIA_0507");
  AddRequirementInfo("ARCH_SW_DIA_0030", "Service 0x2E will be implemented for DID 0311");
  AddRequirementInfo("ARCH_SW_DIA_0152", "Request data shall be 3 byte long");
  AddRequirementInfo("ARCH_SW_DIA_0153", "Runnable shall write Zykluszeit Messtechnik stored in Rte_Ct_MBBL_SsaAppl_Coding_ZZZ_VehicleEquipment_Development. Zykluszeit_Messtechnik");
  AddRequirementInfo("ARCH_SW_DIA_0394", "The new data written by Vehicle Equipment Configuration Data service (0x2E 0311) shall be stored in non-volatile memoy and shall be available only after reset.");
  AddRequirementInfo("ARCH_SW_DIA_0395", "Service 0x2E (Write Data By Identifier) will be implemented for DID 0244 (Reset Pre-Safe Counter)");
  AddRequirementInfo("ARCH_SW_DIA_0394", "The new data written by Vehicle Equipment Configuration Data service (0x2E 0311) shall be stored in non-volatile memoy and shall be available only after reset.");
  AddRequirementInfo("ARCH_SW_DIA_0507", "Byte 0: Reserved (shall not be used) ----------------------------------------------- Byte1_bit0 - Activation/deactivation of PRE-SAFE function 0x00 - yes - PRE-SAFE function activated 0x01 - no - PRE-SAFE function not activated Byte1_bit1 - Activation/deactivation of Display message (signal RBTM_xy_Disp_Rq_ST3) 0x00 - yes - Display message activated 0x01 - no - Display message not activated Byte1_bit2 - Activation / deactivation of counter limit. 0x00 - yes - counter limit deactivated 0x01 - no - counter limit activated Byte1_bit3 - CRC Fault monitoring 0x00 - yes - deactivated 0x01 - no - Activated Byte1_bits4-7: Reserved ----------------------------------------------- Byte 2: Reserved (shall not be used)");


  //***************************************************************************************

  testCaseComment("Preconditions");
  testStep("STEP", "Bench Initialization");
  RunPreTs();
  //====================================================
  testStep("STEP", "Enter development session.");
  EnterDiagnosticSession("development");

  testStep("STEP", "Set breakpoint in function *DataServices_ZZZ_Vehicle_Equipment_Development_Read_Zykluszeit_Messtechnik_WriteData*.");
  debugger_setRelativeFunctionBpAtLine("DataServices_ZZZ_Vehicle_Equipment_Development_Read_Zykluszeit_Messtechnik_WriteData", 11);
  debugger_run();
 
  testCaseComment("Action: ARCH_SW_DIA_0030; ARCH_SW_DIA_0152; ARCH_SW_DIA_0153; ARCH_SW_DIA_0394; ARCH_SW_DIA_0507;");
  testStep("STEP", "Send diag request for 2E 0311 and wait for timeout error --> Timeout reached.");
  SendDiagnosticRequest(dWriteVehicleEquipmentDevelopmentDataRequest, dWriteVehicleEquipmentDevelopmentDataResponse, TRUE);

  testWaitForTimeout(2000);
  testStep("STEP", "Check if breakpoint from function DataServices_ZZZ_Vehicle_Equipment_Development_Read_Zykluszeit_Messtechnik_WriteData was reached. --> BP was reached.");
  debugger_waitUntilBPisReached(5000);
  
  
  testStep("STEP", "Overwrite Rte_Ct_MBBL_SsaAppl_Coding_ZZZ_VehicleEquipment_Development with 0x1");
  debugger_writeGlobalVariable("uint8", "Rte_Ct_MBBL_SsaAppl_Coding_ZZZ_VehicleEquipment_Development,,app.elf", 3, 1);
  i64Rte_Ct_MBBL_SsaAppl_Coding_ZZZ_VehicleEquipment_Development = debugger_readGlobalVariable("uint8", "Rte_Ct_MBBL_SsaAppl_Coding_ZZZ_VehicleEquipment_Development,,app.elf", 3);
  EvalManStepEqual("Byte was read", i64Rte_Ct_MBBL_SsaAppl_Coding_ZZZ_VehicleEquipment_Development);
  
  testStep("STEP", "Send diag request for 2E 0311 --> Response received.");
  debugger_deleteAllBP();
  debugger_run();
  SendDiagnosticRequest(dWriteVehicleEquipmentDevelopmentDataRequest, dWriteVehicleEquipmentDevelopmentDataResponse);
  CheckPositiveResponse(dWriteVehicleEquipmentDevelopmentDataRequest, dWriteVehicleEquipmentDevelopmentDataResponse);
  //====================================================
  testCaseComment("Postcondition");
  testStep("STEP", "Return ECU to default values");
  RunPostTs();
}

testcase SW_IT_DIA_DataServices_ZZZ_Vehicle_Equipment_Development_Read_Bitfield_WriteData_01()
{
  int64 i64Rte_Ct_MBBL_SsaAppl_Coding_ZZZ_VehicleEquipment_Development;

  //***********************************Test report header*********************************
  testReportAddMiscInfoBlock("AUTOLIV ELECTRONICS document");
  TestReportAddMiscInfo("Nightly test", "No");
  TestReportAddMiscInfo("Test type", "Requirement-Based test");
  TestReportAddMiscInfo("Regression Test", "No");
  TestReportAddMiscInfo("Fault injection method used", "No");
  TestReportAddMiscInfo("Resource usage evaluation", "No");
  TestReportAddMiscInfo("Priority", "No");
  TestReportAddMiscInfo("Safety relevant", "No");
  
  AddRequirementInfo("Requirement under test", "ARCH_SW_DIA_0030; ARCH_SW_DIA_0147; ARCH_SW_DIA_0148; ARCH_SW_DIA_0149");
  AddRequirementInfo("ARCH_SW_DIA_0030", "Service 0x2E will be implemented for DID 0311");
  AddRequirementInfo("ARCH_SW_DIA_0147", "Service shall be available in Default, Extended and Development session");
  AddRequirementInfo("ARCH_SW_DIA_0148", "Request data shall be 3 byte long");
  AddRequirementInfo("ARCH_SW_DIA_0149", "Runnable shall write Bitfield stored in Rte_Ct_MBBL_SsaAppl_Coding_ZZZ_VehicleEquipment_Development.Bitfield");

  //***************************************************************************************

  testCaseComment("Preconditions");
  testStep("STEP", "Bench Initialization");
  RunPreTs();
  //====================================================
  testStep("STEP", "Enter development session.");
  EnterDiagnosticSession("development");
  
  testStep("STEP", "Set breakpoint in function *DataServices_ZZZ_Vehicle_Equipment_Development_Read_Bitfield_WriteData*.");
  debugger_setRelativeFunctionBpAtLine("DataServices_ZZZ_Vehicle_Equipment_Development_Read_Bitfield_WriteData", 11);
  debugger_run();
 
  testCaseComment("Action: ARCH_SW_DIA_0030; ARCH_SW_DIA_0147; ARCH_SW_DIA_0148; ARCH_SW_DIA_0149");
  testStep("STEP", "Send diag request for 2E 0311 and wait for timeout error --> Timeout reached.");
  SendDiagnosticRequest(dWriteVehicleEquipmentDevelopmentDataRequest, dWriteVehicleEquipmentDevelopmentDataResponse, TRUE);

  testWaitForTimeout(2000);
  testStep("STEP", "Check if breakpoint from function DataServices_ZZZ_Vehicle_Equipment_Development_Read_Bitfield_WriteData was reached. --> BP was reached.");
  debugger_waitUntilBPisReached(5000);
  
  
  testStep("STEP", "Overwrite Rte_Ct_MBBL_SsaAppl_Coding_ZZZ_VehicleEquipment_Development with 0x1");
  debugger_writeGlobalVariable("uint8", "Rte_Ct_MBBL_SsaAppl_Coding_ZZZ_VehicleEquipment_Development,,app.elf", 0, 1);
  i64Rte_Ct_MBBL_SsaAppl_Coding_ZZZ_VehicleEquipment_Development = debugger_readGlobalVariable("uint8", "Rte_Ct_MBBL_SsaAppl_Coding_ZZZ_VehicleEquipment_Development,,app.elf", 0);
  EvalManStepEqual("Byte was read", i64Rte_Ct_MBBL_SsaAppl_Coding_ZZZ_VehicleEquipment_Development);
  
  testStep("STEP", "Send diag request for 2E 0311 --> Response received.");
  debugger_deleteAllBP();
  debugger_run();
  SendDiagnosticRequest(dWriteVehicleEquipmentDevelopmentDataRequest, dWriteVehicleEquipmentDevelopmentDataResponse);
  CheckPositiveResponse(dWriteVehicleEquipmentDevelopmentDataRequest, dWriteVehicleEquipmentDevelopmentDataResponse);
  //====================================================
  testCaseComment("Postcondition");
  testStep("STEP", "Return ECU to default values");
  RunPostTs();
}

testcase SW_IT_DIA_runDidFDFF_MeasurementFrameBlock12ConfigWrite_01()
{
  ////***********************************Test report header*********************************
  testReportAddMiscInfoBlock("AUTOLIV ELECTRONICS document");
  TestReportAddMiscInfo("Nightly test", "No");
  TestReportAddMiscInfo("Test type", "Requirement-Based test");
  TestReportAddMiscInfo("Regression Test", "No");
  TestReportAddMiscInfo("Fault injection method used", "No");
  TestReportAddMiscInfo("Resource usage evaluation", "No");
  TestReportAddMiscInfo("Priority", "No");
  TestReportAddMiscInfo("Safety relevant", "No");
  
  AddRequirementInfo("Requirement under test", "ARCH_SW_DIA_0039; ARCH_SW_DIA_0174; ARCH_SW_DIA_0175, ARCH_SW_NVP_0012; ARCH_SW_DIA_0176");
  AddRequirementInfo("ARCH_SW_DIA_0039", "Service 0x2E will be implemented for DID FDFF");
  AddRequirementInfo("ARCH_SW_DIA_0174", "Service shall be available in Development session");
  AddRequirementInfo("ARCH_SW_DIA_0175", "Request data shall be 5 bytes long");
  AddRequirementInfo("ARCH_SW_DIA_0176", "Runnable shall write Ram Address and Size stored in NVP_BLOCK_ID_MEASUREMENT_FRAME_12_CONFIG");

  ////***************************************************************************************

  testCaseComment("Preconditions");
  testStep("STEP", "Bench Initialization");
  RunPreTs();
  
  ////====================================================
  testStep("STEP", "Enter development session.");
  EnterDiagnosticSession("development");
  
  testStep("STEP", "Set breakpoint in function *DIA_runDidFDFF_MeasurementFrameBlock12ConfigWrite*.");
  debugger_setRelativeFunctionBpAtLine("DIA_runDidFDFF_MeasurementFrameBlock12ConfigWrite", 40);
  debugger_run();
 
  testCaseComment("Action: ARCH_SW_DIA_0039; ARCH_SW_DIA_0174; ARCH_SW_DIA_0175, ARCH_SW_NVP_0012; ARCH_SW_DIA_0176");
  testStep("STEP", "Send diag request for 2E FDFF and wait for timeout error --> Timeout reached.");
  SendDiagnosticRequest(dWriteMFBlock12ConfigRequest, dWriteMFBlock12ConfigResponse, TRUE);

  testWaitForTimeout(2000);
  testStep("STEP", "Check if breakpoint from function DIA_runDidFDFF_MeasurementFrameBlock12ConfigWrite was reached. --> BP was reached.");
  debugger_waitUntilBPisReached(5000);
  
    
  ////====================================================
  testCaseComment("Postcondition");
  testStep("STEP", "Return ECU to default values");
  RunPostTs();
}

testcase SW_IT_DIA_runDid0241_PRE_SAFE_Recorder_1_WriteData_01()
{
  //***********************************Test report header*********************************
  testReportAddMiscInfoBlock("AUTOLIV ELECTRONICS document");
  TestReportAddMiscInfo("Nightly test", "No");
  TestReportAddMiscInfo("Test type", "Requirement-Based test");
  TestReportAddMiscInfo("Regression Test", "No");
  TestReportAddMiscInfo("Fault injection method used", "No");
  TestReportAddMiscInfo("Resource usage evaluation", "No");
  TestReportAddMiscInfo("Priority", "No");
  TestReportAddMiscInfo("Safety relevant", "No");
  
  AddRequirementInfo("Requirement under test", "ARCH_SW_DIA_0240; ARCH_SW_DIA_0248; ARCH_SW_DIA_0249; ARCH_SW_DIA_0385; ARCH_SW_DIA_0386; ARCH_SW_DIA_0387; ARCH_SW_DIA_0480; ARCH_SW_DIA_0481; ARCH_SW_DIA_0482; ARCH_SW_DIA_0483");
  AddRequirementInfo("ARCH_SW_DIA_0240", "Service 0x22 (Read Data By Identifier) & 0x2E (Write Data By Identifier) for DID 0x0241 will be implemented");
  AddRequirementInfo("ARCH_SW_DIA_0248", "Service shall be available in Default session, Extended session Update session and Development session");
  AddRequirementInfo("ARCH_SW_DIA_0249", "Service shall be available in the following forms of Authentication: Development ENHANCED, Production After-Sales ENHANCED, After-Sales After-Sales BASIC, Internal Diagnostic Test Tool, ePTI Test Tool");
  AddRequirementInfo("ARCH_SW_DIA_0385", "Service 0x2E (Write Data By Identifier) will be implemented for DID 0241 (Reset Pre-Safe Recorder 1)");
  AddRequirementInfo("ARCH_SW_DIA_0386", "Request data shall be 1 byte long.");
  AddRequirementInfo("ARCH_SW_DIA_0387", "Byte 0 shall be defined as the Erase Pre-Safe Memory command and shall always have value 0x01.");
  AddRequirementInfo("ARCH_SW_DIA_0480", "DataIdentifier shall be 0x0241");
  AddRequirementInfo("ARCH_SW_DIA_0481", "Using this service shall lead to the Pre-Safe Recorder 1 to be set to default value.");
  AddRequirementInfo("ARCH_SW_DIA_0482", "The DID shall be available in the following sessions: Ã¢Â¦ÂExtended session Ã¢Â¦ÂUpdate Session Ã¢Â¦ÂDevelopment Session");
  AddRequirementInfo("ARCH_SW_DIA_0483", "This service shall be available under the following forms of Authentication: Ã¢Â¦ÂSupplier Ã¢Â¦ÂDevelopment ENHANCED Ã¢Â¦ÂProduction Ã¢Â¦ÂAfter-Sales ENHANCED Ã¢Â¦ÂAfter-Sales");

  //***************************************************************************************

  testCaseComment("Preconditions");
  testStep("STEP", "Bench Initialization");
  RunPreTs();
  
  //====================================================
  testStep("STEP", "Enter development session.");
  EnterDiagnosticSession("development");
  
  testStep("STEP", "Set breakpoint in function *DIA_runDid0241_PRE_SAFE_Recorder_1_WriteData*.");
  debugger_setRelativeFunctionBpAtLine("DIA_runDid0241_PRE_SAFE_Recorder_1_WriteData", 0);
  debugger_run();
 
  testCaseComment("Action: ARCH_SW_DIA_0240; ARCH_SW_DIA_0248; ARCH_SW_DIA_0249; ARCH_SW_DIA_0385; ARCH_SW_DIA_0386; ARCH_SW_DIA_0387; ARCH_SW_DIA_0480; ARCH_SW_DIA_0481; ARCH_SW_DIA_0482; ARCH_SW_DIA_0483");
  testStep("STEP", "Send diag request for 2E 0241 and wait for timeout error --> Timeout reached.");
  SendDiagnosticRequest(dPresafeRecorder1WriteRequest, dPresafeRecorder1WriteResponse, TRUE);

  testWaitForTimeout(2000);
  testStep("STEP", "Check if breakpoint from function DIA_runDid0241_PRE_SAFE_Recorder_1_WriteData was reached. --> BP was reached.");
  debugger_waitUntilBPisReached(5000);
  debugger_isCPUStoppedAtFunction("DIA_runDid0241_PRE_SAFE_Recorder_1_WriteData");
  
    
  //====================================================
  testCaseComment("Postcondition");
  testStep("STEP", "Return ECU to default values");
  RunPostTs();
}

testcase SW_IT_DIA_runDid0242_PRE_SAFE_Recorder_2_WriteData_01()
{
  ////***********************************Test report header*********************************
  testReportAddMiscInfoBlock("AUTOLIV ELECTRONICS document");
  TestReportAddMiscInfo("Nightly test", "No");
  TestReportAddMiscInfo("Test type", "Requirement-Based test");
  TestReportAddMiscInfo("Regression Test", "No");
  TestReportAddMiscInfo("Fault injection method used", "No");
  TestReportAddMiscInfo("Resource usage evaluation", "No");
  TestReportAddMiscInfo("Priority", "No");
  TestReportAddMiscInfo("Safety relevant", "No");
  
  AddRequirementInfo("Requirement under test", "ARCH_SW_DIA_0250; ARCH_SW_DIA_0258; ARCH_SW_DIA_0259; ARCH_SW_DIA_0390; ARCH_SW_DIA_0391; ARCH_SW_DIA_0392; ARCH_SW_DIA_0484; ARCH_SW_DIA_0485; ARCH_SW_DIA_0486; ARCH_SW_DIA_0487");
  AddRequirementInfo("ARCH_SW_DIA_0250", "Service 0x22 (Read Data By Identifier) & 0x2E (Write Data By Identifier) for DID 0x0242 will be implemented");
  AddRequirementInfo("ARCH_SW_DIA_0258", "Service shall be available in Default session, Extended session Update session and Development session");
  AddRequirementInfo("ARCH_SW_DIA_0259", "Service shall be available in the following forms of Authentication: Development ENHANCED, Production After-Sales ENHANCED, After-Sales After-Sales BASIC, Internal Diagnostic Test Tool, ePTI Test Tool");
  AddRequirementInfo("ARCH_SW_DIA_0390", "Service 0x2E (Write Data By Identifier) will be implemented for DID 0242 (Reset Pre-Safe Recorder 2)");
  AddRequirementInfo("ARCH_SW_DIA_0391", "Request data shall be 1 byte long.");
  AddRequirementInfo("ARCH_SW_DIA_0392", "Byte 0 shall be defined as the Erase Pre-Safe Memory command and shall always have value 0x01.");
  AddRequirementInfo("ARCH_SW_DIA_0484", "DataIdentifier shall be 0x0242");
  AddRequirementInfo("ARCH_SW_DIA_0485", "Using this service shall lead to the Pre-Safe Recorder 2 to be set to default value.");
  AddRequirementInfo("ARCH_SW_DIA_0486", "The DID shall be available in the following sessions: Ã¢Â¦ÂExtended session Ã¢Â¦ÂUpdate Session Ã¢Â¦ÂDevelopment Session");
  AddRequirementInfo("ARCH_SW_DIA_0487", "This service shall be available under the following forms of Authentication: Ã¢Â¦ÂSupplier Ã¢Â¦ÂDevelopment ENHANCED Ã¢Â¦ÂProduction Ã¢Â¦ÂAfter-Sales ENHANCED Ã¢Â¦ÂAfter-Sales");

  ////***************************************************************************************

  testCaseComment("Preconditions");
  testStep("STEP", "Bench Initialization");
  RunPreTs();
  ////====================================================
    testStep("STEP", "Enter development session.");
  EnterDiagnosticSession("development");

  testStep("STEP", "Set breakpoint in function *DIA_runDid0242_PRE_SAFE_Recorder_2_WriteData*.");
  debugger_setRelativeFunctionBpAtLine("DIA_runDid0242_PRE_SAFE_Recorder_2_WriteData", 18);
  debugger_run();
 
  testCaseComment("Action: ARCH_SW_DIA_0250; ARCH_SW_DIA_0258; ARCH_SW_DIA_0259; ARCH_SW_DIA_0390; ARCH_SW_DIA_0391; ARCH_SW_DIA_0392; ARCH_SW_DIA_0484; ARCH_SW_DIA_0485; ARCH_SW_DIA_0486; ARCH_SW_DIA_0487");
  testStep("STEP", "Send diag request for 2E 0242 and wait for timeout error --> Timeout reached.");
  SendDiagnosticRequest(dPresafeRecorder2WriteRequest, dPresafeRecorder2WriteResponse, TRUE);

  testWaitForTimeout(2000);
  testStep("STEP", "Check if breakpoint from function DIA_runDid0242_PRE_SAFE_Recorder_2_WriteData was reached. --> BP was reached.");
  debugger_waitUntilBPisReached(5000);
  debugger_isCPUStoppedAtFunction("DIA_runDid0242_PRE_SAFE_Recorder_2_WriteData");
  
    
  ////====================================================
  testCaseComment("Postcondition");
  testStep("STEP", "Return ECU to default values");
  RunPostTs();
}

testcase SW_IT_DIA_runDidFD31_HBCalibrationWrite_01()
{
  ////***********************************Test report header*********************************
  testReportAddMiscInfoBlock("AUTOLIV ELECTRONICS document");
  TestReportAddMiscInfo("Nightly test", "No");
  TestReportAddMiscInfo("Test type", "Requirement-Based test");
  TestReportAddMiscInfo("Regression Test", "No");
  TestReportAddMiscInfo("Fault injection method used", "No");
  TestReportAddMiscInfo("Resource usage evaluation", "No");
  TestReportAddMiscInfo("Priority", "No");
  TestReportAddMiscInfo("Safety relevant", "No");
  
  AddRequirementInfo("Requirement under test", "ARCH_SW_DIA_0315; ARCH_SW_DIA_0316; ARCH_SW_DIA_0317; ARCH_SW_DIA_0318; ARCH_SW_DIA_0319; ARCH_SW_DIA_0320; ARCH_SW_DIA_0321");
  AddRequirementInfo("ARCH_SW_DIA_0315", "Service 0x2E (Write Data By Identifier) will be implemented for DID FD31 (ECU Calibration Parameters)");
  AddRequirementInfo("ARCH_SW_DIA_0316", "The ECU calibration parameters shall be modified in non-volatile and RAM memories. It means the changes will immediately affect the current SW session (ECU reset is not necessary to take into account the modifications).");
  AddRequirementInfo("ARCH_SW_DIA_0317", "The Write ECU Calibration Parameters service shall be available in the following sessions: Supplier Session/Development Session (0x7E)");
  AddRequirementInfo("ARCH_SW_DIA_0318", "Service Write ECU Location shall be available under the following forms of Authentication: Supplier Development ENHANCED Production");
  AddRequirementInfo("ARCH_SW_DIA_0319", "Data Identifier of Write ECU Calibration Parameters shall be: 0xFD31");
  AddRequirementInfo("ARCH_SW_DIA_0320", "Write ECU Calibration Parameters Request data shall be 40 bytes long.");
  AddRequirementInfo("ARCH_SW_DIA_0321", "Bytes #2-#3:  DataIdentifier of the Write ECU Calibration Parameters shall be: 0xFD31");


  ////***************************************************************************************

  testCaseComment("Preconditions");
  testStep("STEP", "Bench Initialization");
  RunPreTs();
  ////====================================================

  testStep("STEP", "Enter development session.");
  EnterDiagnosticSession("development");
  
  testStep("STEP", "Set breakpoint in function *DIA_runDidFD31_HBCalibrationWrite*.");
  debugger_setRelativeFunctionBpAtLine("DIA_runDidFD31_HBCalibrationWrite", 18);
  debugger_run();
 
  testCaseComment("Action: ARCH_SW_DIA_0315; ARCH_SW_DIA_0316; ARCH_SW_DIA_0317; ARCH_SW_DIA_0318; ARCH_SW_DIA_0319; ARCH_SW_DIA_0320; ARCH_SW_DIA_0321");
  testStep("STEP", "Send diag request for 2E FD31 and wait for timeout error --> Timeout reached.");
  SendDiagnosticRequest(dWriteECUCalibParamRequest, dWriteECUCalibParamResponse, TRUE);

  testWaitForTimeout(2000);
  testStep("STEP", "Check if breakpoint from function DIA_runDidFD31_HBCalibrationWrite was reached. --> BP was reached.");
  debugger_waitUntilBPisReached(5000);
  
    
  ////====================================================
  testCaseComment("Postcondition");
  testStep("STEP", "Return ECU to default values");
  RunPostTs();
}

testcase SW_IT_DIA_runDidFD2F_EcuLocationWrite_01()
{
  ////***********************************Test report header*********************************
  testReportAddMiscInfoBlock("AUTOLIV ELECTRONICS document");
  TestReportAddMiscInfo("Nightly test", "No");
  TestReportAddMiscInfo("Test type", "Requirement-Based test");
  TestReportAddMiscInfo("Regression Test", "No");
  TestReportAddMiscInfo("Fault injection method used", "No");
  TestReportAddMiscInfo("Resource usage evaluation", "No");
  TestReportAddMiscInfo("Priority", "No");
  TestReportAddMiscInfo("Safety relevant", "No");
  
  AddRequirementInfo("Requirement under test", "ARCH_SW_DIA_0305; ARCH_SW_DIA_0306; ARCH_SW_DIA_0307; ARCH_SW_DIA_0308; ARCH_SW_DIA_0309; ARCH_SW_DIA_0310; ARCH_SW_DIA_0311");
  AddRequirementInfo("ARCH_SW_DIA_0305", "Service 0x2E (Write Data By Identifier) will be implemented for DID FD2F (ECU Location)");
  AddRequirementInfo("ARCH_SW_DIA_0306", "The Write ECU Location service shall be available in the following sessions: Supplier Session/Development Session (0x7E)");
  AddRequirementInfo("ARCH_SW_DIA_0307", "Service Write ECU Location shall be available under the following forms of Authentication: Supplier Development ENHANCED Production");
  AddRequirementInfo("ARCH_SW_DIA_0308", "Data Identifier of Write ECU Location shall be: 0xFD2F");
  AddRequirementInfo("ARCH_SW_DIA_0309", "The SIDE parameter shall be 1 byte and shall correspond to the side the ECU shall be configured to: 0x99 RIGHT SIDE 0x9C LEFT SIDE");
  AddRequirementInfo("ARCH_SW_DIA_0310", "Bytes #2-#3:  DataIdentifier of the Write ECU location service shall be: 0xFD2F");
  AddRequirementInfo("ARCH_SW_DIA_0311", "If positive answer is sent, then value of SIDE shall be taken into account after reset.");
  ////***************************************************************************************

  testCaseComment("Preconditions");
  testStep("STEP", "Bench Initialization");
  RunPreTs();
  ////====================================================

  testStep("STEP", "Enter development session.");
  EnterDiagnosticSession("development");
  
  testStep("STEP", "Set breakpoint in function *DIA_runDidFD2F_EcuLocationWrite*.");
  debugger_setRelativeFunctionBpAtLine("DIA_runDidFD2F_EcuLocationWrite", 11);
  debugger_run();
 
  testCaseComment("Action: ARCH_SW_DIA_0305; ARCH_SW_DIA_0306; ARCH_SW_DIA_0307; ARCH_SW_DIA_0308; ARCH_SW_DIA_0309; ARCH_SW_DIA_0310; ARCH_SW_DIA_0311");
  testStep("STEP", "Send diag request for 2E FD2F and wait for timeout error --> Timeout reached.");
  SendDiagnosticRequest(dECULocationWriteRequest, dECULocationWriteResponse, TRUE);

  testWaitForTimeout(2000);
  testStep("STEP", "Check if breakpoint from function DIA_runDidFD2F_EcuLocationWrite was reached. --> BP was reached.");
  debugger_waitUntilBPisReached(5000);
  debugger_isCPUStoppedAtFunction("DIA_runDidFD2F_EcuLocationWrite");
    
  ////====================================================
  testCaseComment("Postcondition");
  testStep("STEP", "Return ECU to default values");
  RunPostTs();
}

testcase SW_IT_DIA_DataServices_PRE_SAFE_Counter_read_Read_CombinedDataElement_WriteData_01()
{

  //***********************************Test report header*********************************
  testReportAddMiscInfoBlock("AUTOLIV ELECTRONICS document");
  TestReportAddMiscInfo("Nightly test", "No");
  TestReportAddMiscInfo("Test type", "Requirement-Based test");
  TestReportAddMiscInfo("Regression Test", "No");
  TestReportAddMiscInfo("Fault injection method used", "No");
  TestReportAddMiscInfo("Resource usage evaluation", "No");
  TestReportAddMiscInfo("Priority", "No");
  TestReportAddMiscInfo("Safety relevant", "No");
  
  AddRequirementInfo("Requirement under test", "ARCH_SW_DIA_0396; ARCH_SW_DIA_0397; ARCH_SW_DIA_0488; ARCH_SW_DIA_0489; ARCH_SW_DIA_0490; ARCH_SW_DIA_0491;");
  AddRequirementInfo("ARCH_SW_DIA_0396", "Request data shall be 1 byte long.");
  AddRequirementInfo("ARCH_SW_DIA_0397", "Byte 0 shall be defined as the Pre-Safe Request Counter Reset command and shall always have value 0x01.");
  AddRequirementInfo("ARCH_SW_DIA_0488", "DataIdentifier shall be 0x0244");
  AddRequirementInfo("ARCH_SW_DIA_0489", "Using this service shall lead to the Pre-Safe Counter to be set to default value (i.e. 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00)");
  AddRequirementInfo("ARCH_SW_DIA_0490", "The DID shall be available in the following sessions: Ã¢Â¦ÂExtended session Ã¢Â¦ÂUpdate Session Ã¢Â¦ÂDevelopment Session");
  AddRequirementInfo("ARCH_SW_DIA_0491", "This service shall be available under the following forms of Authentication: Ã¢Â¦ÂSupplier Ã¢Â¦ÂDevelopment ENHANCED Ã¢Â¦ÂProductionn");

  //***************************************************************************************

  testCaseComment("Preconditions");
  testStep("STEP", "Bench Initialization");
  RunPreTs();
  //====================================================
  testStep("STEP", "Set breakpoint in function *DataServices_PRE_SAFE_Counter_read_Read_CombinedDataElement_WriteData*.");
  debugger_setRelativeFunctionBpAtLine("DataServices_PRE_SAFE_Counter_read_Read_CombinedDataElement_WriteData", 0);
  
  testStep("STEP", "Enter development session.");
  EnterDiagnosticSession("development");

  testCaseComment("Action: ARCH_SW_DIA_0396; ARCH_SW_DIA_0397; ARCH_SW_DIA_0488; ARCH_SW_DIA_0489; ARCH_SW_DIA_0490; ARCH_SW_DIA_0491;");
  testStep("STEP", "Send diag request for 2E 0244 and wait for timeout error --> Timeout reached.");
  SendDiagnosticRequest(dPresafeRequestCounterResetWriteRequest, dPresafeRequestCounterResetWriteResponse, TRUE);

  testWaitForTimeout(2000);
  testStep("STEP", "Check if breakpoint from function DataServices_PRE_SAFE_Counter_read_Read_CombinedDataElement_WriteData was reached. --> BP was reached.");
  debugger_waitUntilBPisReached(5000);
  debugger_isCPUStoppedAtFunction("DataServices_PRE_SAFE_Counter_read_Read_CombinedDataElement_WriteData");

  //====================================================
  testCaseComment("Postcondition");
  testStep("STEP", "Return ECU to default values");
  RunPostTs();
}

testcase SW_IT_DIA_ResetServiceExecution_01()
{
  ////***********************************Test report header*********************************
  testReportAddMiscInfoBlock("AUTOLIV ELECTRONICS document");
  TestReportAddMiscInfo("Nightly test", "No");
  TestReportAddMiscInfo("Test type", "Requirement-Based test");
  TestReportAddMiscInfo("Regression Test", "No");
  TestReportAddMiscInfo("Fault injection method used", "No");
  TestReportAddMiscInfo("Resource usage evaluation", "No");
  TestReportAddMiscInfo("Priority", "No");
  TestReportAddMiscInfo("Safety relevant", "No");
  
  AddRequirementInfo("Requirement under test", "ARCH_SW_DIA_0265; ARCH_SW_DIA_0266; ARCH_SW_DIA_0267; ARCH_SW_DIA_0268; ARCH_SW_DIA_0269; ARCH_SW_DIA_0270; ARCH_SW_DIA_0271");
  AddRequirementInfo("ARCH_SW_DIA_0265", "Service 0x11 (ECU Reset) will be implemented");
  AddRequirementInfo("ARCH_SW_DIA_0266", "The ECUReset service shall be available in the following sessions:");
  AddRequirementInfo("ARCH_SW_DIA_0267", "The ECUReset service shall be available under the following forms of Authentication: Supplier Development ENHANCED Production After-Sales ENHANCED After-Sales");
  AddRequirementInfo("ARCH_SW_DIA_0268", "ResetType of the Reset service shall be: 0x01  Hardware Reset");
  AddRequirementInfo("ARCH_SW_DIA_0269", "ResetType of the Reset service shall be: 0x03  Software Reset");
  AddRequirementInfo("ARCH_SW_DIA_0270", "Bytes #2:  Reset type should be an echo of the 'ResetType' parameter in the request message.");
  AddRequirementInfo("ARCH_SW_DIA_0271", "After a successful ECU Reset, ECU shall be in DefaultSession.");
  //***************************************************************************************
  
  /*------------------------- Test scenario start ------------------------------*/
  testCaseComment("Preconditions");
  testStep("STEP", "Bench Initialization");
  RunPreTs();
  //====================================================

  testStep("STEP", "Set breakpoint in function *ResetServiceExecution*.");
  debugger_setRelativeFunctionBpAtLine("ResetServiceExecution", 0);
 
  testCaseComment("Action: ARCH_SW_DIA_0265; ARCH_SW_DIA_0266; ARCH_SW_DIA_0267; ARCH_SW_DIA_0268; ARCH_SW_DIA_0269; ARCH_SW_DIA_0270; ARCH_SW_DIA_0271");
  testStep("STEP", "Use the Soft Reset Service.");
  SendDiagnosticRequest(dSoftResetRequest, dSoftResetResponse, TRUE);
  
  testStep("STEP", "Check if breakpoint from function ResetServiceExecution was reached. --> BP was reached.");
  debugger_waitUntilBPisReached(5000);
  debugger_isCPUStoppedAtFunction("ResetServiceExecution");
  
  ////====================================================
  testCaseComment("Postcondition");
  testStep("STEP", "Return ECU to default values");
  RunPostTs();
}

testcase SW_IT_DIA_ResetServiceExecution_02()
{
  ////***********************************Test report header*********************************
  testReportAddMiscInfoBlock("AUTOLIV ELECTRONICS document");
  TestReportAddMiscInfo("Nightly test", "No");
  TestReportAddMiscInfo("Test type", "Requirement-Based test");
  TestReportAddMiscInfo("Regression Test", "No");
  TestReportAddMiscInfo("Fault injection method used", "No");
  TestReportAddMiscInfo("Resource usage evaluation", "No");
  TestReportAddMiscInfo("Priority", "No");
  TestReportAddMiscInfo("Safety relevant", "No");
  
  AddRequirementInfo("Requirement under test", "ARCH_SW_DIA_0265; ARCH_SW_DIA_0266; ARCH_SW_DIA_0267; ARCH_SW_DIA_0268; ARCH_SW_DIA_0269; ARCH_SW_DIA_0270; ARCH_SW_DIA_0271");
  AddRequirementInfo("ARCH_SW_DIA_0265", "Service 0x11 (ECU Reset) will be implemented");
  AddRequirementInfo("ARCH_SW_DIA_0266", "The ECUReset service shall be available in the following sessions:");
  AddRequirementInfo("ARCH_SW_DIA_0267", "The ECUReset service shall be available under the following forms of Authentication: Supplier Development ENHANCED Production After-Sales ENHANCED After-Sales");
  AddRequirementInfo("ARCH_SW_DIA_0268", "ResetType of the Reset service shall be: 0x01  Hardware Reset");
  AddRequirementInfo("ARCH_SW_DIA_0269", "ResetType of the Reset service shall be: 0x03  Software Reset");
  AddRequirementInfo("ARCH_SW_DIA_0270", "Bytes #2:  Reset type should be an echo of the 'ResetType' parameter in the request message.");
  AddRequirementInfo("ARCH_SW_DIA_0271", "After a successful ECU Reset, ECU shall be in DefaultSession.");
  //***************************************************************************************
  
  /*------------------------- Test scenario start ------------------------------*/
  testCaseComment("Preconditions");
  testStep("STEP", "Bench Initialization");
  RunPreTs();
  //====================================================

  testStep("STEP", "Set breakpoint in function *ResetServiceExecution*.");
  debugger_setRelativeFunctionBpAtLine("ResetServiceExecution", 0);
  debugger_run();
 
  testCaseComment("Action: ARCH_SW_DIA_0265; ARCH_SW_DIA_0266; ARCH_SW_DIA_0267; ARCH_SW_DIA_0268; ARCH_SW_DIA_0269; ARCH_SW_DIA_0270; ARCH_SW_DIA_0271");
  testStep("STEP", "Send hard reset request.");
  SendDiagnosticRequest(dHardResetRequest, dHardResetResponse, TRUE);

  testWaitForTimeout(2000);
  testStep("STEP", "Check if breakpoint from function ResetServiceExecution was reached. --> BP was reached.");
  debugger_waitUntilBPisReached(5000);
  debugger_isCPUStoppedAtFunction("ResetServiceExecution");
  
  ////====================================================
  testCaseComment("Postcondition");
  testStep("STEP", "Return ECU to default values");
  RunPostTs();
}

testcase SW_IT_DIA_Dcm_Svc14Handler_01()
{
  //***********************************Test report header*********************************
  testReportAddMiscInfoBlock("AUTOLIV ELECTRONICS document");
  TestReportAddMiscInfo("Nightly test", "No");
  TestReportAddMiscInfo("Test type", "Requirement-Based test");
  TestReportAddMiscInfo("Regression Test", "No");
  TestReportAddMiscInfo("Fault injection method used", "No");
  TestReportAddMiscInfo("Resource usage evaluation", "No");
  TestReportAddMiscInfo("Priority", "No");
  TestReportAddMiscInfo("Safety relevant", "No");
  
  AddRequirementInfo("Requirement under test", "ARCH_SW_DIA_0275; ARCH_SW_DIA_0276; ARCH_SW_DIA_0277; ARCH_SW_DIA_0278; ARCH_SW_DIA_0279; ARCH_SW_DIA_0280;");
  AddRequirementInfo("ARCH_SW_DIA_0275", "Service 0x14 (Clear Diagnostic Information) will be implemented");
  AddRequirementInfo("ARCH_SW_DIA_0276", "The ClearDiagnosticInformation service shall be available in the following sessions: Default Session (0x01) Extended Session (0x03) Supplier Session/Development Session (0x7E) Update Session (0x42)");
  AddRequirementInfo("ARCH_SW_DIA_0277", "This service shall be available with or without any form of Authentication.");
  AddRequirementInfo("ARCH_SW_DIA_0278", "The ECU shall send a Positive Response when the ClearDiagnosticInformation service is completely processed Explanation: ClearDiagnosticInformation service is considered completely processed when the data used by the ReadDiagnosticInformation (0x19) are cleared");
  AddRequirementInfo("ARCH_SW_DIA_0279", "The ECU shall send a Positive Response even if no DTCs are stored in the serverÃ¢â‚¬â„¢s memory");
  AddRequirementInfo("ARCH_SW_DIA_0279", "The ECU shall send a Positive Response even if no DTCs are stored in the serverÃ¢â‚¬â„¢s memory");
  AddRequirementInfo("ARCH_SW_DIA_0280", "Each bit mask corresponds to the following DTC Groups: 0x000000 = GROUP_EMISSION_RELATED 0x000002 = GROUP_POWERTRAIN 0x000004 = GROUP_CHASSIS 0x000006 = GROUP_BODY 0x000008 = GROUP_NETWORK_COM 0xA00000 = GROUP_SBE 0XFFFFFF = ALL DTC GROUP");
  //***************************************************************************************
  
  /*------------------------- Test scenario start ------------------------------*/
  testCaseComment("Preconditions");
  testStep("STEP", "Bench Initialization");
  RunPreTs();
  //====================================================
  testStep("STEP", "Set breakpoint in function *Dcm_Svc14Handler*.");
  debugger_setBpAtLine("S:\\Components\\Application\\Supplier\\Dcm\\Dcm_Utils.h", 519);
 
  testCaseComment("Action: ARCH_SW_DIA_0275; ARCH_SW_DIA_0276; ARCH_SW_DIA_0277; ARCH_SW_DIA_0278; ARCH_SW_DIA_0279; ARCH_SW_DIA_0280;");
  testStep("STEP", "Send fault memory clear request.");
  SendDiagnosticRequest(dClearAllDTCsRequest, dClearAllDTCsResponse, TRUE);

  testWaitForTimeout(2000);
  testStep("STEP", "Check if BP was reached. --> BP was reached.");
  debugger_waitUntilBPisReached(5000);
  
  
  //====================================================
  testCaseComment("Postcondition");
  testStep("STEP", "Return ECU to default values");
  RunPostTs();
}

testcase SW_IT_DIA_Dcm_Svc19Handler_01()
{
  ////***********************************Test report header*********************************
  testReportAddMiscInfoBlock("AUTOLIV ELECTRONICS document");
  TestReportAddMiscInfo("Nightly test", "No");
  TestReportAddMiscInfo("Test type", "Requirement-Based test");
  TestReportAddMiscInfo("Regression Test", "No");
  TestReportAddMiscInfo("Fault injection method used", "No");
  TestReportAddMiscInfo("Resource usage evaluation", "No");
  TestReportAddMiscInfo("Priority", "No");
  TestReportAddMiscInfo("Safety relevant", "No");
  
  AddRequirementInfo("Requirement under test", "ARCH_SW_DIA_0281; ARCH_SW_DIA_0282; ARCH_SW_DIA_0283; ARCH_SW_DIA_0284; ARCH_SW_DIA_0525; ARCH_SW_DIA_0526; ARCH_SW_DIA_0527; ARCH_SW_DIA_0528; ARCH_SW_DIA_0530; ARCH_SW_DIA_0531; ARCH_SW_DIA_0532; ARCH_SW_DIA_0775; ARCH_SW_DIA_0776; ARCH_SW_DIA_0777; ARCH_SW_DIA_0778; ARCH_SW_DIA_0779; ARCH_SW_DIA_0780; ARCH_SW_DIA_0781; ARCH_SW_DIA_0782; ARCH_SW_DIA_0783; ARCH_SW_DIA_0785; ARCH_SW_DIA_0786; ARCH_SW_DIA_0787; ARCH_SW_DIA_0788; ARCH_SW_DIA_0789; ARCH_SW_DIA_0790; ARCH_SW_DIA_0791; ARCH_SW_DIA_0792; ARCH_SW_DIA_0793; ARCH_SW_DIA_0794; ARCH_SW_DIA_0795; ARCH_SW_DIA_0796; ARCH_SW_DIA_0800; ARCH_SW_DIA_0801; ARCH_SW_DIA_0802; ARCH_SW_DIA_0803 ");
  AddRequirementInfo("ARCH_SW_DIA_0010", "Service Read DTC Information shall be implemented with subfunction 0x02 ReportDTCByStatusMask.");
  AddRequirementInfo("ARCH_SW_DIA_0281", "Service 0x19 (Read DTC Information) will be implemented for ReportDTCByStatusMask (RDTCBST  0x02)");
  AddRequirementInfo("ARCH_SW_DIA_0282", "The ReportDTCByStatusMask shall be available in the following sessions: Update session");
  AddRequirementInfo("ARCH_SW_DIA_0283", "The byte 3 shall be reserved for the DTCStatusAvailabilityMask of the ReadDiagnosticInformation service.");
  AddRequirementInfo("ARCH_SW_DIA_0284", "DTCStatusAvailabilityMask shall be 0x39. REVAS supported status bits are the following ones: - Test Failed (bit 0) - Confirmed DTC (bit 3) - Test Not Completed SinÃ…â€œ Last Clear (bit 4) - Test Failed this Operation Cycle (bit 5)");
  AddRequirementInfo("ARCH_SW_DIA_0525", "Service 0x19 (Read DTC Information) will be implemented for ReportNumberOfDTCByStatusMask (RNODTCBSM  0x01)");
  AddRequirementInfo("ARCH_SW_DIA_0526", "The byte 1 shall be reserved for the SID-RQ of the ReadDiagnosticInformation service: Ã¢Â¦Â The value 0x19 shall correspond to the SID-RQ of the ReadDiagnosticInformation service.");
  AddRequirementInfo("ARCH_SW_DIA_0527", "The byte 2 shall be reserved for the ReportType of the ReadDiagnosticInformation service: Ã¢Â¦Â The value 0x01 shall correspond to the ReportType: ReportNumberOfDTCByStatusMask");
  AddRequirementInfo("ARCH_SW_DIA_0528", "The byte 3 shall be reserved for the DTCStatusMask of the ReadDiagnosticInformation service: Ã¢Â¦ÂThe bit 0 shall correspond to 'Test failed' Ã¢Â¦ÂThe bit 1 shall correspond to 'Test failed this Operation cycle' Ã¢Â¦ÂThe bit 2 shall correspond to 'Pending DTC' Ã¢Â¦ÂThe bit 3 shall correspond to 'Confirmed DTC' Ã¢Â¦ÂThe bit 4 shall correspond to 'Test not completed since last clear' Ã¢Â¦ÂThe bit 5 shall correspond to 'Test failed since last clear' Ã¢Â¦ÂThe bit 6 shall correspond to 'Test not completed this operation cycle' Ã¢Â¦ÂThe bit 7 shall correspond to 'Warning indicator requested'");
  AddRequirementInfo("ARCH_SW_DIA_0530", "Service 0x19 (Read DTC Information) will be implemented for ReportSupportedDTC (RSDTC) - 0x0A");
  AddRequirementInfo("ARCH_SW_DIA_0531", "The byte 1 shall be reserved for the SID-RQ of the ReadDiagnosticInformation service: Ã¢Â¦ÂThe value 0x19 shall correspond to the SID-RQ of theReadDiagnosticInformation service");
  AddRequirementInfo("ARCH_SW_DIA_0532", "The byte 2 shall be reserved for the ReportType of the ReadDiagnosticInformation service: Ã¢Â¦ÂThe value 0x0A shall correspond to the ReportType: ReportSupportedDTC");
  AddRequirementInfo("ARCH_SW_DIA_0775", "Service 0x19 (Read DTC Information) will be implemented for ReportDTCSnapshotRecordByDTCNumber (RDTCSRBDTCN) - 0x04");
  AddRequirementInfo("ARCH_SW_DIA_0785", "Service 0x19 (Read DTC Information) will be implemented for ReportDTCExtendedDataRecordByDTCNumber (RDTCEDRBDTCN) - 0x06");
  AddRequirementInfo("ARCH_SW_DIA_0800", "Service 0x19 (Read DTC Information) will be implemented for ReportDTCFaultDetectionCounte (RDTCFDC) - 0x14");
  AddRequirementInfo("ARCH_SW_DIA_0776", "The ReportDTCSnapshotRecordByDTCNumber shall be available in the following diagnostic sessions: ?Default Session ?Extended Session ?Development Session Service shall be available under any form of Authentication ");  
  AddRequirementInfo("ARCH_SW_DIA_0777", "?The value 0x19 shall correspond to the SID-RQ of theReadDiagnosticInformation service. ?The value 0x04 shall correspond to the ReportType: ReportDTCSnapshotRecordByDTCNumber ");
  AddRequirementInfo("ARCH_SW_DIA_0778", "The bytes #3...#5 shall be reserved for the DTCRecord of the ReadDiagnosticInformation service.");
  AddRequirementInfo("ARCH_SW_DIA_0779", "The byte #6 shall be reserved for the DTCSnapshotRecordNumber of the ReadDiagnosticInformation service. 0x10 = First Occurence (triggered on CONFIRMED) 0x20 = Last Occurence (triggered on TEST_FAILED) 0xFF = All Snapshot records ");
  AddRequirementInfo("ARCH_SW_DIA_0780", "The byte #6 shall be reserved for the StatusOfDTC of the ReadDiagnosticInformation service.");
  AddRequirementInfo("ARCH_SW_DIA_0781", "The byte #7 shall be reserved for the DTCSnapshotRecordNumber");
  AddRequirementInfo("ARCH_SW_DIA_0782", "The byte #8 shall be reserved for DTCSnapshotRecordNumberOfIdentifiers");
  AddRequirementInfo("ARCH_SW_DIA_0783", "The bytes #9 ... #9 + length(DTCSnapshotRecord #x) -1 shall be reserved for DTCSnapshotRecord Note: DTCSnapshotRecord contains several dataIdentifiers and their returned data. Each DTC has its specific dataidentifiers which can be found in CDD. x= DTCSnapshotRecordNumber ");
  AddRequirementInfo("ARCH_SW_DIA_0786", "The ReportDTCExtendedDataRecordByDTCNumber shall be available in the following diagnostic sessions: ?Default Session ?Extended Session ?Development Session Service shall be available under any form of Authentication ");
  AddRequirementInfo("ARCH_SW_DIA_0787", " The value 0x19 (byte1) shall correspond to the SID-RQ of theReadDiagnosticInformation service. ? The value 0x06 (byte2) shall correspond to the ReportType: ReportDTCExtendedDataRecordByDTCNumber ");
  AddRequirementInfo("ARCH_SW_DIA_0788", "The bytes #3..#5 shall be reserved for the DTCRecord of the ReadDiagnosticInformation service.");
  AddRequirementInfo("ARCH_SW_DIA_0789", "The byte #6 shall be reserved for the DTCExtendedDataRecordNumber of the ReadDiagnosticInformation service. 0x01 = StandardEnvironmentalData 0xFF = All environmental data ");
  AddRequirementInfo("ARCH_SW_DIA_0790", "The bytes #3...#5 shall be reserved for the DTCRecord of the ReadDiagnosticInformation service.");
  AddRequirementInfo("ARCH_SW_DIA_0791", "The byte #6 shall be reserved for the StatusOfDTC of the ReadDiagnosticInformation service.");
  AddRequirementInfo("ARCH_SW_DIA_0792", "The byte #7 shall be reserved for the ExtDataRecordlist of the ReadDiagnosticInformation service. byte #7 shall be set to 0x01 because the list of ExtendedDataRecordNumber contains only one element: StandardEnvironmentalData ");
  AddRequirementInfo("ARCH_SW_DIA_0793", "?Standardized DTCExtendedData byte #8 shall correspond to 'Occurrence Flag' 0x00 - Occurence 0x01 - Fault ");
  AddRequirementInfo("ARCH_SW_DIA_0794", "?Standardized DTCExtendedData byte #9 shall correspond to 'External tester present Flag' 0x00 - Not present 0x01 - Present ");
  AddRequirementInfo("ARCH_SW_DIA_0795", "?Standardized DTCExtendedData byte #10 shall correspond to 'Frequency Counter");
  AddRequirementInfo("ARCH_SW_DIA_0796", "?Standardized DTCExtendedData byte #11 shall correspond to 'Ignition Cycle Counter'");
  AddRequirementInfo("ARCH_SW_DIA_0801", "?The value 0x14 shall correspond to the ReportType: ReportDTCFaultDetectionCounter");
  AddRequirementInfo("ARCH_SW_DIA_0802", "The bytes #3..#5 shall be reserved for the DTCRecord of the ReadDiagnosticInformation service.");
  AddRequirementInfo("ARCH_SW_DIA_0803", "The byte #6 shall be reserved for the DTCFaultDetectionCounter of the ReadDiagnosticInformation service. (The DTCFaultDetectionCounter reports the number of fault detection counts of a DTC.) See SYS_DAI_MF09_692 for more details ");
  AddRequirementInfo("ARCH_SW_DIA_0826", "Each Root Cause will be reported on 1 byte and will have a dependency with AEC Groups and DTCs:?1 byte: AEC ID (#)");    
  //***************************************************************************************
  
  /*------------------------- Test scenario start ------------------------------*/
  testCaseComment("Preconditions");
  testStep("STEP", "Bench Initialization");
  RunPreTs();
  //====================================================

  testStep("STEP", "Set breakpoint in function *Dcm_Svc19Handler*.");
  debugger_setBpAtLine("S:\\Components\\Application\\Supplier\\Dcm\\Dcm_Svc19.c", 168);
 
  testCaseComment("Action: ARCH_SW_DIA_0281; ARCH_SW_DIA_0282; ARCH_SW_DIA_0283; ARCH_SW_DIA_0284; ARCH_SW_DIA_0525; ARCH_SW_DIA_0526; ARCH_SW_DIA_0527; ARCH_SW_DIA_0528; ARCH_SW_DIA_0530; ARCH_SW_DIA_0531; ARCH_SW_DIA_0532; ARCH_SW_DIA_0775; ARCH_SW_DIA_0776; ARCH_SW_DIA_0777; ARCH_SW_DIA_0778; ARCH_SW_DIA_0779; ARCH_SW_DIA_0780; ARCH_SW_DIA_0781; ARCH_SW_DIA_0782; ARCH_SW_DIA_0783; ARCH_SW_DIA_0785; ARCH_SW_DIA_0786; ARCH_SW_DIA_0787; ARCH_SW_DIA_0788; ARCH_SW_DIA_0789; ARCH_SW_DIA_0790; ARCH_SW_DIA_0791; ARCH_SW_DIA_0792; ARCH_SW_DIA_0793; ARCH_SW_DIA_0794; ARCH_SW_DIA_0795; ARCH_SW_DIA_0796; ARCH_SW_DIA_0800; ARCH_SW_DIA_0801; ARCH_SW_DIA_0802; ARCH_SW_DIA_0803");
  testStep("STEP", "Send fault memory clear request.");
  SendDiagnosticRequest(dReportDTCByStatusMaskRequest, dReportDTCByStatusMaskResponse, TRUE);
  
  testWaitForTimeout(2000);
  testStep("STEP", "Check if BP was reached. --> BP was reached.");
  debugger_waitUntilBPisReached(5000);
  

  ////====================================================
  testCaseComment("Postcondition");
  testStep("STEP", "Return ECU to default values");
  RunPostTs();
}

testcase SW_IT_DIA_Dcm_Service27Processor_01()
{
  //***********************************Test report header*********************************
  testReportAddMiscInfoBlock("AUTOLIV ELECTRONICS document");
  TestReportAddMiscInfo("Nightly test", "No");
  TestReportAddMiscInfo("Test type", "Requirement-Based test");
  TestReportAddMiscInfo("Regression Test", "No");
  TestReportAddMiscInfo("Fault injection method used", "No");
  TestReportAddMiscInfo("Resource usage evaluation", "No");
  TestReportAddMiscInfo("Priority", "No");
  TestReportAddMiscInfo("Safety relevant", "No");
  
  AddRequirementInfo("Requirement under test", "ARCH_SW_DIA_0295; ARCH_SW_DIA_0296; ARCH_SW_DIA_0297; ARCH_SW_DIA_0298; ARCH_SW_DIA_0299; ARCH_SW_DIA_0300; ARCH_SW_DIA_0301; ARCH_SW_DIA_0302; ARCH_SW_DIA_0303");
  AddRequirementInfo("ARCH_SW_DIA_0295", "Service 0x27 (Security Access) will be implemented for Get Seed and Send Key");
  AddRequirementInfo("ARCH_SW_DIA_0296", "The Security Access service shall only be available in the following sessions: Programming Session (0x02)");
  AddRequirementInfo("ARCH_SW_DIA_0297", "Security Access service shall be available under the following forms of Authentication:");
  AddRequirementInfo("ARCH_SW_DIA_0298", "SecurityAccessType of the SecurityAccess service shall be 0x11 for Get Programming Seed.");
  AddRequirementInfo("ARCH_SW_DIA_0299", "Bytes #2-#3:  SecurityAccessType shall be: 0x11");
  AddRequirementInfo("ARCH_SW_DIA_0300", "Bytes #3-#34:  Shall contain SecuritySeed");
  AddRequirementInfo("ARCH_SW_DIA_0301", "SecurityAccessType of the SecurityAccess service shall be 0x12 for Get Programming Key.");
  AddRequirementInfo("ARCH_SW_DIA_0302", "The bytes from 3 to 66 shall be reserved for the SecurityKey of the SecurityAccess service.");
  AddRequirementInfo("ARCH_SW_DIA_0303", "Bytes #2-#3:  SecurityAccessType shall be: 0x12");

  //***************************************************************************************

  testCaseComment("Preconditions");
  testStep("STEP", "Bench Initialization");
  RunPreTs();
  //====================================================

  EnterDiagnosticSession("development");
  
  testStep("STEP", "Set breakpoint in function *Dcm_Service27Processor*.");
  debugger_setRelativeFunctionBpAtLine("Dcm_Service27Processor", 0);
  debugger_run();
 
  testCaseComment("Action: ARCH_SW_DIA_0295; ARCH_SW_DIA_0296; ARCH_SW_DIA_0297; ARCH_SW_DIA_0298; ARCH_SW_DIA_0299; ARCH_SW_DIA_0300; ARCH_SW_DIA_0301; ARCH_SW_DIA_0302; ARCH_SW_DIA_0303");
  testStep("STEP", "Send diag request for security access --> Timeout received.");
  SendDiagnosticRequest(dSendKeyReprogrammingRequest, dSendKeyReprogrammingResponse, TRUE);

  testWaitForTimeout(2000);
  testStep("STEP", "Check if breakpoint from function Dcm_Service27Processor was reached. --> BP was reached.");
  debugger_waitUntilBPisReached(5000);
  debugger_isCPUStoppedAtFunction("Dcm_Service27Processor");
  
  //====================================================
  testCaseComment("Postcondition");
  testStep("STEP", "Return ECU to default values");
  RunPostTs();
}

testcase SW_IT_DIA_Dcm_Svc28Handler_01()
{
  ////***********************************Test report header*********************************
  testReportAddMiscInfoBlock("AUTOLIV ELECTRONICS document");
  TestReportAddMiscInfo("Nightly test", "No");
  TestReportAddMiscInfo("Test type", "Requirement-Based test");
  TestReportAddMiscInfo("Regression Test", "No");
  TestReportAddMiscInfo("Fault injection method used", "No");
  TestReportAddMiscInfo("Resource usage evaluation", "No");
  TestReportAddMiscInfo("Priority", "No");
  TestReportAddMiscInfo("Safety relevant", "No");
  
  AddRequirementInfo("Requirement under test", "ARCH_SW_DIA_0400; ARCH_SW_DIA_0401; ARCH_SW_DIA_0402; ARCH_SW_DIA_0403; ARCH_SW_DIA_0404; ARCH_SW_DIA_0405; ARCH_SW_DIA_0406; ARCH_SW_DIA_0407");
  AddRequirementInfo("ARCH_SW_DIA_0401", "The Communication control service shall be available in the following sessions: Extended Session (0x03) Supplier Session/Development Session (0x7E)");
  AddRequirementInfo("ARCH_SW_DIA_0402", "Communication control service shall be available under the following forms of Authentication: Supplier Development ENHANCED Production After-Sales ENHANCED");
  AddRequirementInfo("ARCH_SW_DIA_0403", "Control Type = 0x00 correspond to the Enable Rx and Tx Note: This value indicates that the reception and transmission of messages shall be enabled for the specified communicationType.");
  AddRequirementInfo("ARCH_SW_DIA_0404", "Control Type = 0x01 correspond to the  Enable Rx and Disable Tx Note: This value indicates that the reception of messages shall be enabled and the transmission shall be disabled for the specified communicationType");
  AddRequirementInfo("ARCH_SW_DIA_0405", "Service 0x28 (Communication Control) will be implemented");
  AddRequirementInfo("ARCH_SW_DIA_0405", "Communication Type = 0x01 correspond to Normal Communication type. Note: Normal Communication is referring to all application-related communication signals");
  AddRequirementInfo("ARCH_SW_DIA_0406", "Byte #2:  Control Type of the Communication control shall be an echo of 'Control Type' parameter from the request message.");
  AddRequirementInfo("ARCH_SW_DIA_0407", "If positive response of the Communication Control service has been received, then the transmission / reception of messages shall be done according the 'Control Type' and 'Communication Type' requested.");

  ////***************************************************************************************

  testCaseComment("Preconditions");
  testStep("STEP", "Bench Initialization");
  RunPreTs();
  ////====================================================

  testStep("STEP", "Set breakpoint in function *Dcm_Svc28Handler*.");
  debugger_setBpAtLine("s:\\Components\\Application\\Supplier\\Dcm\\Dcm_Svc28.c", 192);
  debugger_run();
 
  testCaseComment("Action: ARCH_SW_DIA_0400; ARCH_SW_DIA_0401; ARCH_SW_DIA_0402; ARCH_SW_DIA_0403; ARCH_SW_DIA_0404; ARCH_SW_DIA_0405; ARCH_SW_DIA_0406; ARCH_SW_DIA_0407;");
  testStep("STEP", "Send request.");
  SendDiagnosticRequest(dEnableRxAndEnableTxReadRequest, dEnableRxAndEnableTxReadResponse, TRUE);

  testWaitForTimeout(2000);
  testStep("STEP", "Check if  was reached. --> BP was reached.");
  debugger_waitUntilBPisReached(5000);
  
  
  ////====================================================
  testCaseComment("Postcondition");
  testStep("STEP", "Return ECU to default values");
  RunPostTs();
}

testcase SW_IT_DIA_Dcm_Svc85Handler_01()
{
  ////***********************************Test report header*********************************
  testReportAddMiscInfoBlock("AUTOLIV ELECTRONICS document");
  TestReportAddMiscInfo("Nightly test", "No");
  TestReportAddMiscInfo("Test type", "Requirement-Based test");
  TestReportAddMiscInfo("Regression Test", "No");
  TestReportAddMiscInfo("Fault injection method used", "No");
  TestReportAddMiscInfo("Resource usage evaluation", "No");
  TestReportAddMiscInfo("Priority", "No");
  TestReportAddMiscInfo("Safety relevant", "No");
  
  AddRequirementInfo("Requirement under test", "ARCH_SW_DIA_0410; ARCH_SW_DIA_0411; ARCH_SW_DIA_0412; ARCH_SW_DIA_0413; ARCH_SW_DIA_0414; ARCH_SW_DIA_0415; ARCH_SW_DIA_0416; ARCH_SW_DIA_0417; ARCH_SW_DIA_0418; ARCH_SW_DIA_0492; ARCH_SW_DIA_0493; ARCH_SW_DIA_0494; ARCH_SW_DIA_0495; ARCH_SW_DIA_0496");
  AddRequirementInfo("ARCH_SW_DIA_0492", "The DID shall be available in the following sessions: Ã¢Â¦ÂExtended session Ã¢Â¦ÂDevelopment Session");
  AddRequirementInfo("ARCH_SW_DIA_0493", "This service shall be available under the following forms of Authentication: Ã¢Â¦ÂSupplier Ã¢Â¦ÂDevelopment ENHANCED Ã¢Â¦ÂProduction Ã¢Â¦ÂAfter-Sales ENHANCED");
  AddRequirementInfo("ARCH_SW_DIA_0494", "Ã¢Â¦ÂThe value 0x85 shall correspond to the SID-RQ of the ControlDTCSetings Service");
  AddRequirementInfo("ARCH_SW_DIA_0495", "Ã¢Â¦ÂThe value 0x01 shall correspond to the DTCSettingType: DTC Setting Enabled");
  AddRequirementInfo("ARCH_SW_DIA_0496", "Ã¢Â¦ÂThe value 0x02 shall correspond to the DTCSettingType: DTC Setting Disabled");
  AddRequirementInfo("ARCH_SW_DIA_0411", "The byte 1 shall be reserved for the SID-PR of the ControlDTCSetting service: The value 0xC5 shall correspond to the SID-PR of the ControlDTCSetting service.");
  AddRequirementInfo("ARCH_SW_DIA_0412", "The byte 2 shall be reserved for the DTCSettingType of the ControlDTCSetting service:The value 0x01 shall correspond to the DTCSettingType: DTC Setting Enabled. The value 0x02 shall correspond to the DTCSettingType: DTC Setting Disabled. ");
  AddRequirementInfo("ARCH_SW_DIA_0413", "If positive response has been received for 'DTC Setting Disabled' then the status of the DTCs shall be frozen. Note: ControlDTCSetting deactivates only the updating of the StatusOfDTC bits. The service is not used to deactivate substitute functions.");
  AddRequirementInfo("ARCH_SW_DIA_0414", "If positive response has been received for 'DTC Setting Enabled' then the status of the DTCs shall be resumed.");
  AddRequirementInfo("ARCH_SW_DIA_0415", "Service 0x85 (ControlDTCSetting Service) will be implemented");
  AddRequirementInfo("ARCH_SW_DIA_0415", "If a clearDiagnosticInformation (14 hex) service is sent by the client, the ControlDTCSetting shall not prohibit resetting the server's DTC memory.If a successful ECUReset is performed, then this re-enables the setting of DTCs.");
  AddRequirementInfo("ARCH_SW_DIA_0416", "The byte 1 shall be reserved for the SID-NR of the ControlDTCSetting service: Ã¢Â¦Â	The value 0x7F shall correspond to the SID-NR of the ControlDTcSetting service.");
  AddRequirementInfo("ARCH_SW_DIA_0417", "The byte 2 shall be reserved for the SID-RQ-NR of the ControlDTCSetting service: The value 0x85 shall correspond to the SID-RQ-NR of the ControlDTCSetting service.");
  AddRequirementInfo("ARCH_SW_DIA_0418", "The byte 3 shall be reserved for the NRC-CDTCS of the ControlDTCSetting service: The value 0x12 shall correspond to the NRC-CDTCS: SubFunctionNotSupported The value 0x13 shall correspond to the NRC-CDTCS: IncorrectMessageLengthOrInvalidFormat The value 0x22 shall correspond to the NRC-CDTCS: ConditionsNotCorrect The value 0x7E shall correspond to the NRC-CDTCS: SubfunctionNotSupportedInActiveSession The value 0x7F shall correspond to the NRC-CDTCS: ServiceNotSupportedInActiveSession");
  //***************************************************************************************
  
  /*------------------------- Test scenario start ------------------------------*/
  testCaseComment("Preconditions");
  testStep("STEP", "Bench Initialization");
  RunPreTs();
  //====================================================

  testStep("STEP", "Set breakpoint in function *Dcm_Svc85Handler*.");
  debugger_setBpAtLine("S:\\Components\\Application\\Supplier\\Dcm\\Dcm_Svc85.c", 174);
  debugger_run();
  
    testStep("STEP", "Start Development Session.");
  EnterDiagnosticSession("development");
 
  testCaseComment("Action: ARCH_SW_DIA_0410; ARCH_SW_DIA_0411; ARCH_SW_DIA_0412; ARCH_SW_DIA_0413; ARCH_SW_DIA_0414; ARCH_SW_DIA_0415; ARCH_SW_DIA_0416; ARCH_SW_DIA_0417; ARCH_SW_DIA_0418; ARCH_SW_DIA_0492; ARCH_SW_DIA_0493; ARCH_SW_DIA_0494; ARCH_SW_DIA_0495; ARCH_SW_DIA_0496;");
  testStep("STEP", "Send request.");
  SendDiagnosticRequest(dDTCSettingModeOnControlRequest, dDTCSettingModeOnControlResponse, TRUE);

  testWaitForTimeout(2000);
  testStep("STEP", "Check if BP was reached. --> BP was reached.");
  debugger_waitUntilBPisReached(5000);
  
  ////====================================================
  testCaseComment("Postcondition");
  testStep("STEP", "Return ECU to default values");
  RunPostTs();
}

testcase SW_IT_DIA_RoELite_ObsolescenceDataHandler_01()
{
  
  int64 i64roe_XX;
  //***********************************Test report header*********************************
  testReportAddMiscInfoBlock("AUTOLIV ELECTRONICS document");
  TestReportAddMiscInfo("Nightly test", "No");
  TestReportAddMiscInfo("Test type", "Requirement-Based test");
  TestReportAddMiscInfo("Regression Test", "No");
  TestReportAddMiscInfo("Fault injection method used", "No");
  TestReportAddMiscInfo("Resource usage evaluation", "No");
  TestReportAddMiscInfo("Priority", "No");
  TestReportAddMiscInfo("Safety relevant", "No");
  
  AddRequirementInfo("Requirement under test", "ARCH_SW_DIA_0420; ARCH_SW_DIA_0421; ARCH_SW_DIA_0422; ARCH_SW_DIA_0423; ARCH_SW_DIA_0424; ARCH_SW_DIA_0425; ARCH_SW_DIA_0426");
  AddRequirementInfo("ARCH_SW_DIA_0420", "RoELite for ObsolescenceData will be implemented");
  AddRequirementInfo("ARCH_SW_DIA_0421", "Frame contents shall be transmitted depending on the event detect (Type).");
  AddRequirementInfo("ARCH_SW_DIA_0422", "If more than one RoE-lite PDU needs to be transmitted within one Transmission Cycle, the associated RoE-Lite PDUs shall be transmitted as depicted in figure [Transmitting RoE-lite PDUs from the transmission queue].");
  AddRequirementInfo("ARCH_SW_DIA_0423", "ROE_0_RBTM_xy_ST3 (Byte 1) signal shall be transmitted with the value 0x02 - Obsolescence_DATA if availability data has been changed. Byte 2 of the ROE_RBTM_xy_ST3 frame shall contain the block number. Bytes 3-4 of the ROE_RBTM_xy_ST3 frame shall contain the current value Bytes 5-6 of the ROE_RBTM_xy_ST3 frame shall be threshold 'Green to Yellow' Bytes 7-8 of the ROE_RBTM_xy_ST3 frame shall be threshold 'Yellow to Red'");
  AddRequirementInfo("ARCH_SW_DIA_0424", "Block number:BSR: 0x00 PRE-SAFE 1-3: 0x01 PRE-SAFE 4-5: 0x02 PRE-SAFE 6-8: 0x03");
  AddRequirementInfo("ARCH_SW_DIA_0425", "Threshold 'Green to Yellow' = 'Yellow to Red' = 0");
  AddRequirementInfo("ARCH_SW_DIA_0426", "Only when the Obsolescence changes from- 'Green' to 'Red' the ECU shall send the corresponding RoE-Lite PDU.");
  //***************************************************************************************
  
  /*------------------------- Test scenario start ------------------------------*/
  testCaseComment("Preconditions");
  testStep("STEP", "Bench Initialization");
  RunPreTs();
  //====================================================

  testCaseComment("Action: ARCH_SW_DIA_0420; ARCH_SW_DIA_0421; ARCH_SW_DIA_0422; ARCH_SW_DIA_0423; ARCH_SW_DIA_0424; ARCH_SW_DIA_0425; ARCH_SW_DIA_0426;");
  debugger_setRelativeFunctionBpAtLine("RoELight_DTCStatusChanged_Callback", 0);
  debugger_reset();
  debugger_run();
  debugger_waitUntilBPisReached(2000);
  
  testStep("STEP", "Evaluate roe_XX data buffer (1st byte). --> Variable equal to 0x00.");
  i64roe_XX = debugger_readLocalVariable("roe_XX.ROE_0");
  EvalManStepEqual("Byte read", i64roe_XX);

  testStep("STEP", "Evaluate roe_XX data buffer (2nd byte). --> Variable equal to 0x00.");
  i64roe_XX = debugger_readLocalVariable("roe_XX.ROE_1");
  EvalManStepEqual("Byte read", i64roe_XX);
  
  testStep("STEP", "Evaluate roe_XX data buffer (3rd byte). --> Variable equal to 0x00.");
  i64roe_XX = debugger_readLocalVariable("roe_XX.ROE_2");
  EvalManStepEqual("Byte read", i64roe_XX);

  testStep("STEP", "Evaluate roe_XX data buffer (4th byte). --> Variable equal to 0x00.");
  i64roe_XX = debugger_readLocalVariable("roe_XX.ROE_3");
  EvalManStepEqual("Byte read", i64roe_XX);
  
  testStep("STEP", "Evaluate roe_XX data buffer (5th byte). --> Variable equal to 0x00.");
  i64roe_XX = debugger_readLocalVariable("roe_XX.ROE_4");
  EvalManStepEqual("Byte read", i64roe_XX);
  
  testStep("STEP", "Evaluate roe_XX data buffer (6th byte). --> Variable equal to 0x00.");
  i64roe_XX = debugger_readLocalVariable("roe_XX.ROE_5");
  EvalManStepEqual("Byte read", i64roe_XX);
  
  testStep("STEP", "Evaluate roe_XX data buffer (7th byte). --> Variable equal to 0x00.");
  i64roe_XX = debugger_readLocalVariable("roe_XX.ROE_6");
  EvalManStepEqual("Byte read", i64roe_XX);
  
  testStep("STEP", "Evaluate roe_XX data buffer (8th byte). --> Variable equal to 0x00.");
  i64roe_XX = debugger_readLocalVariable("roe_XX.ROE_7");
  EvalManStepEqual("Byte read", i64roe_XX);
  

  
  //====================================================
  testCaseComment("Postcondition");
  testStep("STEP", "Return ECU to default values");
  RunPostTs();
}

testcase SW_IT_DIA_RoELite_AvailabilityDataHandler_01()
{
  int64 i64roe_AvailabilityData;
  
  //***********************************Test report header*********************************
  testReportAddMiscInfoBlock("AUTOLIV ELECTRONICS document");
  TestReportAddMiscInfo("Nightly test", "No");
  TestReportAddMiscInfo("Test type", "Requirement-Based test");
  TestReportAddMiscInfo("Regression Test", "No");
  TestReportAddMiscInfo("Fault injection method used", "No");
  TestReportAddMiscInfo("Resource usage evaluation", "No");
  TestReportAddMiscInfo("Priority", "No");
  TestReportAddMiscInfo("Safety relevant", "No");
  
  AddRequirementInfo("Requirement under test", "ARCH_SW_DIA_0430; ARCH_SW_DIA_0431; ARCH_SW_DIA_0432; ARCH_SW_DIA_0433, ARCH_SW_DIA_0435; ARCH_SW_DIA_0436; ARCH_SW_DIA_0437; ARCH_SW_DIA_0438");
  AddRequirementInfo("ARCH_SW_DIA_0430", "RoELite for AvailabilityData will be implemented");
  AddRequirementInfo("ARCH_SW_DIA_0431", "ROE_0_RBTM_xy_ST3 (Byte 1) signal shall be transmitted with the value 0x04 - AVAILABILITY_DATA if availability data has been changed. Byte 2 of the ROE_RBTM_xy_ST3 frame shall contain the function number. Bytes 3 of the ROE_RBTM_xy_ST3 frame shall contain the category (yelow, green, red) Bytes 4-8 of the ROE_RBTM_xy_ST3 frame shall be 0x0000000000.");
  AddRequirementInfo("ARCH_SW_DIA_0432", "Function number: BSR: 0x00 PRE-SAFE 1-3: 0x00 PRE-SAFE 4-5: 0x00 PRE-SAFE 6-8: 0x00");
  AddRequirementInfo("ARCH_SW_DIA_0433", "Only when the Availability changes from - 'Green' to 'Red' the ECU shall send the corresponding RoE-Lite PDU.");
  AddRequirementInfo("ARCH_SW_DIA_0435", "RoELite for DiagSessionChange will be implemented");
  AddRequirementInfo("ARCH_SW_DIA_0436", "ROE_0_RBTM_xy_ST3 (Byte 1) signal shall be transmitted with the value 05 - DIAG_SESSION_CHANGE if diagnostic sesion has been changed. Byte 2 of the ROE_RBTM_xy_ST3 frame shall contain the new Diagnostic session. Bytes 3-8 of the ROE_RBTM_xy_ST3 frame shall be 0x000000000000.");
  AddRequirementInfo("ARCH_SW_DIA_0437", "On ECU start-up the ECU shall transmit a RoE-lite PDU containing the DiagnosticSessionType of the target session. (This includes ECU start-ups for example due to ECUReset or watchdog resets.)");
  AddRequirementInfo("ARCH_SW_DIA_0438", "RoE-lite PDUs indicating Diagnostic Session Changes shall only be sent from Application Software, not from Boot Software.");

  //***************************************************************************************

  testCaseComment("Preconditions");
  testStep("STEP", "Bench Initialization");
  RunPreTs();
  //====================================================

  testStep("STEP", "Set breakpoint in function *RoELite_AvailabilityDataHandler*.");
  debugger_setRelativeFunctionBpAtLine("RoELite_AvailabilityDataHandler", 20);
 
  testCaseComment("Action: ARCH_SW_DIA_0430; ARCH_SW_DIA_0431; ARCH_SW_DIA_0432; ARCH_SW_DIA_0433, ARCH_SW_DIA_0435; ARCH_SW_DIA_0436; ARCH_SW_DIA_0437; ARCH_SW_DIA_0438");
  testStep("STEP", "Send diag request for 22 01 42 --> Timeout received.");
  SendDiagnosticRequest(dAvailabilityDataReadRequest, dAvailabilityDataReadResponse, TRUE);

  testWaitForTimeout(2000);
  testStep("STEP", "Check if breakpoint from function RoELite_AvailabilityDataHandler was reached. --> BP was reached.");
  debugger_waitUntilBPisReached(5000);
  

  testStep("STEP", "Read roe_AvailabilityData byte 1 --> Variable read.");
  i64roe_AvailabilityData = debugger_readLocalVariable("roe_AvailabilityData.ROE_0");
  EvalManStepEqual("Byte was read", i64roe_AvailabilityData);

  testStep("STEP", "Read roe_AvailabilityData byte 2 --> Variable read.");
  i64roe_AvailabilityData = debugger_readLocalVariable("roe_AvailabilityData.ROE_1");
  EvalManStepEqual("Byte was read", i64roe_AvailabilityData);
  
  testStep("STEP", "Read roe_AvailabilityData byte 3 --> Variable read.");
  i64roe_AvailabilityData = debugger_readLocalVariable("roe_AvailabilityData.ROE_2");
  EvalManStepEqual("Byte was read", i64roe_AvailabilityData);
  
  testStep("STEP", "Read roe_AvailabilityData byte 4 --> Variable read.");
  i64roe_AvailabilityData = debugger_readLocalVariable("roe_AvailabilityData.ROE_3");
  EvalManStepEqual("Byte was read", i64roe_AvailabilityData);
  
  testStep("STEP", "Read roe_AvailabilityData byte 5 --> Variable read.");
  i64roe_AvailabilityData = debugger_readLocalVariable("roe_AvailabilityData.ROE_4");
  EvalManStepEqual("Byte was read", i64roe_AvailabilityData);
  
  testStep("STEP", "Read roe_AvailabilityData byte 6 --> Variable read.");
  i64roe_AvailabilityData = debugger_readLocalVariable("roe_AvailabilityData.ROE_5");
  EvalManStepEqual("Byte was read", i64roe_AvailabilityData);
  
  testStep("STEP", "Read roe_AvailabilityData byte 7--> Variable read.");
  i64roe_AvailabilityData = debugger_readLocalVariable("roe_AvailabilityData.ROE_6");
  EvalManStepEqual("Byte was read", i64roe_AvailabilityData);
  
  testStep("STEP", "Read roe_AvailabilityData byte 8--> Variable read.");
  i64roe_AvailabilityData = debugger_readLocalVariable("roe_AvailabilityData.ROE_7");
  EvalManStepEqual("Byte was read", i64roe_AvailabilityData);
  
  //====================================================
  testCaseComment("Postcondition");
  testStep("STEP", "Return ECU to default values");
  RunPostTs();
}



testcase SW_IT_DIA_runSid23_WriteMemoryByAddress_01()
{
  ////***********************************Test report header*********************************
  testReportAddMiscInfoBlock("AUTOLIV ELECTRONICS document");
  TestReportAddMiscInfo("Nightly test", "No");
  TestReportAddMiscInfo("Test type", "Requirement-Based test");
  TestReportAddMiscInfo("Regression Test", "No");
  TestReportAddMiscInfo("Fault injection method used", "No");
  TestReportAddMiscInfo("Resource usage evaluation", "No");
  TestReportAddMiscInfo("Priority", "No");
  TestReportAddMiscInfo("Safety relevant", "No");
  
  AddRequirementInfo("Requirement under test", "ARCH_SW_DIA_0041; ARCH_SW_DIA_0183; ARCH_SW_DIA_0184; ARCH_SW_DIA_0185; ARCH_SW_DIA_0186; ARCH_SW_DIA_0187");
  AddRequirementInfo("ARCH_SW_DIA_0041", "Service 0x3D will be implemented");
  AddRequirementInfo("ARCH_SW_DIA_0183", "Service shall be available in Development session");
  AddRequirementInfo("ARCH_SW_DIA_0184", "MemoryIdentifier shall represent Address and Length format identifier");
  AddRequirementInfo("ARCH_SW_DIA_0185", "MemoryAddress shall represent the address to write to");
  AddRequirementInfo("ARCH_SW_DIA_0186", "MemorySize shall represent the size to write");
  AddRequirementInfo("ARCH_SW_DIA_0187", "New R8.1 Feature: MemoryAddress also works with the EEPROM Alias. Hence, the MemoryAddress range for the EEPROM Alias is between: 0xEE000000 - 0xFF000000 EEPROM Alias for each block can be taken from the NVP Excel file on the column U from Dynamic EEPROM. There are in total 27 Blocks that can be modified via the EEPROM Alias. When writing to an EEPROM Alias Block, the Request should look like this: 3D 24 EE 12 00 00 00 01 9C Legend: EEPROM ALIAS BLOCK ADDRESS Data Note: Service 3D supports from DCM several other ALFIDs (Address and Length Format Identifiers). For example, if you want to write 1 byte length of Data the request should be: 3D 14 EE 12 00 00 01 9C Only works via Raw Request.");


  ////***************************************************************************************

  testCaseComment("Preconditions");
  testStep("STEP", "Bench Initialization");
  RunPreTs();
  ////====================================================
    testStep("STEP", "Enter development session.");
  EnterDiagnosticSession("development");
 
  testCaseComment("Action: ARCH_SW_DIA_0041; ARCH_SW_DIA_0183; ARCH_SW_DIA_0184; ARCH_SW_DIA_0185; ARCH_SW_DIA_0186; ARCH_SW_DIA_0187");
  testStep("STEP", "Send diag request for 3D and wait for timeout error --> Timeout reached.");
  SendDiagnosticRequest(dWriteMemoryByAddressRequest, dWriteMemoryByAddressResponse);
  CheckPositiveResponse(dWriteMemoryByAddressRequest, dWriteMemoryByAddressResponse);

  ////====================================================
  testCaseComment("Postcondition");
  testStep("STEP", "Return ECU to default values");
  RunPostTs();
}


testcase SW_IT_DIA_runSid23_ReadMemoryByAddress_01()
{

  //***********************************Test report header*********************************
  testReportAddMiscInfoBlock("AUTOLIV ELECTRONICS document");
  TestReportAddMiscInfo("Nightly test", "No");
  TestReportAddMiscInfo("Test type", "Requirement-Based test");
  TestReportAddMiscInfo("Regression Test", "No");
  TestReportAddMiscInfo("Fault injection method used", "No");
  TestReportAddMiscInfo("Resource usage evaluation", "No");
  TestReportAddMiscInfo("Priority", "No");
  TestReportAddMiscInfo("Safety relevant", "No");
  
  AddRequirementInfo("Requirement under test", "ARCH_SW_DIA_0040; ARCH_SW_DIA_0177; ARCH_SW_DIA_0178; ARCH_SW_DIA_0179; ARCH_SW_DIA_0180; ARCH_SW_DIA_0181; ARCH_SW_DIA_0182; ARCH_SW_DIA_0042; ARCH_SW_DIA_0043; ARCH_SW_DIA_0044");
  AddRequirementInfo("ARCH_SW_DIA_0040", "Service 0x23 will be implemented");
  AddRequirementInfo("ARCH_SW_DIA_0177", "Service shall be available in Development session");
  AddRequirementInfo("ARCH_SW_DIA_0178", "Runnable shall return data with the length of maximum 300 byes");
  AddRequirementInfo("ARCH_SW_DIA_0179", "MemoryIdentifier shall represent Address and Length format identifier");
  AddRequirementInfo("ARCH_SW_DIA_0180", "MemoryAddress shall represent the address to read from");
  AddRequirementInfo("ARCH_SW_DIA_0181", "MemorySize shall represent the size to read");
  AddRequirementInfo("ARCH_SW_DIA_0182", "MemoryData shall return data to be read with parameters above");
  AddRequirementInfo("ARCH_SW_DIA_0042", "Service 10 shall support the following sessions: Default, Programming, Extended and Development Session");
  AddRequirementInfo("ARCH_SW_DIA_0043", "Service 10 shall be available in the following sessions: Default, Programming, Extended, Development Session and DefaultSession (of the Bootloader)");
  AddRequirementInfo("ARCH_SW_DIA_0044", "Transition to Development Session will be done only with authentication");

  //***************************************************************************************

  testCaseComment("Preconditions");
  testStep("STEP", "Bench Initialization");
  RunPreTs();
  //====================================================

  testStep("STEP", "Enter development session.");
  EnterDiagnosticSession("development");
 
  testCaseComment("Action: ARCH_SW_DIA_0040; ARCH_SW_DIA_0177; ARCH_SW_DIA_0178; ARCH_SW_DIA_0179; ARCH_SW_DIA_0180; ARCH_SW_DIA_0181; ARCH_SW_DIA_0182; ARCH_SW_DIA_0042; ARCH_SW_DIA_0043; ARCH_SW_DIA_0044");
  testStep("STEP", "Send diag request for Memory Read and wait for timeout error --> Timeout reached.");
  SendDiagnosticRequest(dMemoryReadRequest, dMemoryReadResponse);
  CheckPositiveResponse(dMemoryReadRequest, dMemoryReadResponse);
  //====================================================
  testCaseComment("Postcondition");
  testStep("STEP", "Return ECU to default values");
  RunPostTs();
}

testcase SW_IT_DIA_RoELight_DTCStatusChanged_Callback_01()
{
  int64 i64roe_XX;
  ////***********************************Test report header*********************************
  testReportAddMiscInfoBlock("AUTOLIV ELECTRONICS document");
  TestReportAddMiscInfo("Nightly test", "No");
  TestReportAddMiscInfo("Test type", "Requirement-Based test");
  TestReportAddMiscInfo("Regression Test", "Yes");
  TestReportAddMiscInfo("Fault injection method used", "No");
  TestReportAddMiscInfo("Resource usage evaluation", "No");
  TestReportAddMiscInfo("Priority", "No");
  TestReportAddMiscInfo("Safety relevant", "No");
  
  AddRequirementInfo("Requirement under test", "ARCH_SW_DIA_0210; ARCH_SW_DIA_0211; ARCH_SW_DIA_0212; ARCH_SW_DIA_0213; ARCH_SW_DIA_0260; ARCH_SW_DIA_0261; ARCH_SW_DIA_0262");
  AddRequirementInfo("ARCH_SW_DIA_0210", "ROE on Dtc Status change implemented");
  AddRequirementInfo("ARCH_SW_DIA_0211", "This frame shall be identified with the address: Left side: 0x18E1A400 ROE_RBTM_FL_ST3 Right side: 0x18E1A500 ROE_RBTM_FR_ST3");
  AddRequirementInfo("ARCH_SW_DIA_0213", "Default value: 0");
  AddRequirementInfo("ARCH_SW_DIA_0260", "Clear Diag Request Cycle Function");
  AddRequirementInfo("ARCH_SW_DIA_0261", "Get Diag Request Cycle Function");
  AddRequirementInfo("ARCH_SW_DIA_0262", "Cyclic processing task of the Tensioning Routines");
  //***************************************************************************************
  
  /*------------------------- Test scenario start ------------------------------*/
  testCaseComment("Preconditions");
  testStep("STEP", "Bench Initialization");
  RunPreTs();
  //====================================================
  
  debugger_setRelativeFunctionBpAtLine("RoELight_DTCStatusChanged_Callback", 0);
  debugger_reset();
  debugger_run();
  debugger_waitUntilBPisReached(2000);
  
  testStep("STEP", "Evaluate roe_XX data buffer (1st byte). --> Variable equal to 0x00.");
  i64roe_XX = debugger_readLocalVariable("roe_XX.ROE_0");
  EvalManStepEqual("Byte read", i64roe_XX);

  testStep("STEP", "Evaluate roe_XX data buffer (2nd byte). --> Variable equal to 0x00.");
  i64roe_XX = debugger_readLocalVariable("roe_XX.ROE_1");
  EvalManStepEqual("Byte read", i64roe_XX);
  
  testStep("STEP", "Evaluate roe_XX data buffer (3rd byte). --> Variable equal to 0x00.");
  i64roe_XX = debugger_readLocalVariable("roe_XX.ROE_2");
  EvalManStepEqual("Byte read", i64roe_XX);

  testStep("STEP", "Evaluate roe_XX data buffer (4th byte). --> Variable equal to 0x00.");
  i64roe_XX = debugger_readLocalVariable("roe_XX.ROE_3");
  EvalManStepEqual("Byte read", i64roe_XX);
  
  testStep("STEP", "Evaluate roe_XX data buffer (5th byte). --> Variable equal to 0x00.");
  i64roe_XX = debugger_readLocalVariable("roe_XX.ROE_4");
  EvalManStepEqual("Byte read", i64roe_XX);
  
  testStep("STEP", "Evaluate roe_XX data buffer (6th byte). --> Variable equal to 0x00.");
  i64roe_XX = debugger_readLocalVariable("roe_XX.ROE_5");
  EvalManStepEqual("Byte read", i64roe_XX);
  
  testStep("STEP", "Evaluate roe_XX data buffer (7th byte). --> Variable equal to 0x00.");
  i64roe_XX = debugger_readLocalVariable("roe_XX.ROE_6");
  EvalManStepEqual("Byte read", i64roe_XX);
  
  testStep("STEP", "Evaluate roe_XX data buffer (8th byte). --> Variable equal to 0x00.");
  i64roe_XX = debugger_readLocalVariable("roe_XX.ROE_7");
  EvalManStepEqual("Byte read", i64roe_XX);
    
  ////====================================================
  testCaseComment("Postcondition");
  testStep("STEP", "Return ECU to default values");
  RunPostTs();
}

testcase SW_IT_DIA_runRidF703_CycleExecutionStart_01()
{

  //***********************************Test report header*********************************
  testReportAddMiscInfoBlock("AUTOLIV ELECTRONICS document");
  TestReportAddMiscInfo("Nightly test", "No");
  TestReportAddMiscInfo("Test type", "Requirement-Based test");
  TestReportAddMiscInfo("Regression Test", "No");
  TestReportAddMiscInfo("Fault injection method used", "No");
  TestReportAddMiscInfo("Resource usage evaluation", "No");
  TestReportAddMiscInfo("Priority", "No");
  TestReportAddMiscInfo("Safety relevant", "No");
  
  AddRequirementInfo("Requirement under test", "ARCH_SW_DIA_0013; ARCH_SW_DIA_0188; ARCH_SW_DIA_0189; ARCH_SW_DIA_0190");
  AddRequirementInfo("ARCH_SW_DIA_0013", "Service 0x31 01 will be implemented for RID F703");
  AddRequirementInfo("ARCH_SW_DIA_0188", "Service shall be available in Development session");
  AddRequirementInfo("ARCH_SW_DIA_0189", "The RoutineControlOptionRecord shall reflect the selected cycle");
  AddRequirementInfo("ARCH_SW_DIA_0190", "RoutineInfo can have the following values: 0x00, 0x01, 0x02 and 0xFF");

  //***************************************************************************************

  testCaseComment("Preconditions");
  testStep("STEP", "Bench Initialization");
  RunPreTs();
  //====================================================

  testCaseComment("Action: ARCH_SW_DIA_0013; ARCH_SW_DIA_0188; ARCH_SW_DIA_0189; ARCH_SW_DIA_0190"); 
  testStep("STEP", "Enter development session.");
  EnterDiagnosticSession("development");
  
  testStep("STEP", "Set breakpoint in function *DIA_runRidF703_CycleExecutionStart*.");
  debugger_setRelativeFunctionBpAtLine("DIA_runRidF703_CycleExecutionStart", 0);
 
  testStep("STEP", "Send diag request for RID F7 03 and wait for timeout error --> Timeout reached.");
  SendDiagnosticRequest(dCycleExecutionStartRequest, dCycleExecutionStartResponse, TRUE);

  testWaitForTimeout(2000);
  testStep("STEP", "Check if breakpoint from function DIA_runRidF703_CycleExecutionStart was reached. --> BP was reached.");
  debugger_waitUntilBPisReached(5000);

  //====================================================
  testCaseComment("Postcondition");
  testStep("STEP", "Return ECU to default values");
  RunPostTs();
}

testcase SW_IT_DIA_runRidF703_CycleExecutionStop_01()
{
  ////***********************************Test report header*********************************
  testReportAddMiscInfoBlock("AUTOLIV ELECTRONICS document");
  TestReportAddMiscInfo("Nightly test", "No");
  TestReportAddMiscInfo("Test type", "Requirement-Based test");
  TestReportAddMiscInfo("Regression Test", "No");
  TestReportAddMiscInfo("Fault injection method used", "No");
  TestReportAddMiscInfo("Resource usage evaluation", "No");
  TestReportAddMiscInfo("Priority", "No");
  TestReportAddMiscInfo("Safety relevant", "No");
  
  AddRequirementInfo("Requirement under test", "ARCH_SW_DIA_0013; ARCH_SW_DIA_0188; ARCH_SW_DIA_0189; ARCH_SW_DIA_0190; ARCH_SW_DIA_0014; ARCH_SW_DIA_0191");
  AddRequirementInfo("ARCH_SW_DIA_0013", "Service 0x31 01 will be implemented for RID F703");
  AddRequirementInfo("ARCH_SW_DIA_0188", "Service shall be available in Development session");
  AddRequirementInfo("ARCH_SW_DIA_0189", "The RoutineControlOptionRecord shall reflect the selected cycle");
  AddRequirementInfo("ARCH_SW_DIA_0190", "RoutineInfo can have the following values: 0x00, 0x01, 0x02 and 0xFF");
  AddRequirementInfo("ARCH_SW_DIA_0014", "Service 0x31 02 will be implemented for RID F703");
  AddRequirementInfo("ARCH_SW_DIA_0191", "Service shall be available in Development session");

  ////***************************************************************************************

  testCaseComment("Preconditions");
  testStep("STEP", "Bench Initialization");
  RunPreTs();
  ////====================================================

  testStep("STEP", "Enter development session.");
  EnterDiagnosticSession("development");
  
  testStep("STEP", "Set breakpoint in function *DIA_runRidF703_CycleExecutionStop*.");
  debugger_setRelativeFunctionBpAtLine("DIA_runRidF703_CycleExecutionStop", 0);
  debugger_run();
 
  testCaseComment("Action: ARCH_SW_DIA_0013; ARCH_SW_DIA_0188; ARCH_SW_DIA_0189; ARCH_SW_DIA_0190; ARCH_SW_DIA_0014; ARCH_SW_DIA_0191");
  testStep("STEP", "Send diag request for RID F7 03 Start --> Request Sent.");
  SendDiagnosticRequest(dCycleExecutionStartRequest, dCycleExecutionStartResponse);

  testStep("STEP", "Send diag request for RID F7 03 stop and wait for timeout error --> Timeout reached.");
  SendDiagnosticRequest(dCycleExecutionStopRequest, dCycleExecutionStopResponse, TRUE);
  
  testWaitForTimeout(2000);
  testStep("STEP", "Check if breakpoint from function DIA_runRidF703_CycleExecutionStop was reached. --> BP was reached.");
  debugger_waitUntilBPisReached(5000);
  
  
  ////====================================================
  testCaseComment("Postcondition");
  testStep("STEP", "Return ECU to default values");
  RunPostTs();
}

testcase SW_IT_DIA_runRid0329_TriggerBSRStart_01()
{
  ////***********************************Test report header*********************************
  testReportAddMiscInfoBlock("AUTOLIV ELECTRONICS document");
  TestReportAddMiscInfo("Nightly test", "No");
  TestReportAddMiscInfo("Test type", "Requirement-Based test");
  TestReportAddMiscInfo("Regression Test", "No");
  TestReportAddMiscInfo("Fault injection method used", "No");
  TestReportAddMiscInfo("Resource usage evaluation", "No");
  TestReportAddMiscInfo("Priority", "No");
  TestReportAddMiscInfo("Safety relevant", "No");
  
  AddRequirementInfo("Requirement under test", "ARCH_SW_DIA_0015; ARCH_SW_DIA_0192; ARCH_SW_DIA_0193");
  AddRequirementInfo("ARCH_SW_DIA_0015", "Service 0x31 01 will be implemented for RID 0329");
  AddRequirementInfo("ARCH_SW_DIA_0192", "Service shall be available in Extended and Development session");
  AddRequirementInfo("ARCH_SW_DIA_0193", "Result can have the following values: 0x00, 0x01 and 0x02");

  ////***************************************************************************************

  testCaseComment("Preconditions");
  testStep("STEP", "Bench Initialization");
  RunPreTs();
  ////====================================================

  testCaseComment("Action: ARCH_SW_DIA_0015; ARCH_SW_DIA_0192; ARCH_SW_DIA_0193");
  testStep("STEP", "Enter development session.");
  EnterDiagnosticSession("development");
  
  testStep("STEP", "Set breakpoint in function *DIA_runRid0329_TriggerBSRStart*.");
  debugger_setRelativeFunctionBpAtLine("DIA_runRid0329_TriggerBSRStart", 0);
 
  testStep("STEP", "Send diag request for RID 03 29 Start --> Request Sent.");
  SendDiagnosticRequest(dTriggerBSRStartRequest, dTriggerBSRStartResponse, TRUE);
  
  testWaitForTimeout(2000);
  testStep("STEP", "Check if breakpoint from function DIA_runRid0329_TriggerBSRStart was reached. --> BP was reached.");
  debugger_waitUntilBPisReached(5000);
  
  
  ////====================================================
  testCaseComment("Postcondition");
  testStep("STEP", "Return ECU to default values");
  RunPostTs();
}

testcase SW_IT_DIA_runRid0329_TriggerBSRStop_01()
{
  //***********************************Test report header*********************************
  testReportAddMiscInfoBlock("AUTOLIV ELECTRONICS document");
  TestReportAddMiscInfo("Nightly test", "No");
  TestReportAddMiscInfo("Test type", "Requirement-Based test");
  TestReportAddMiscInfo("Regression Test", "No");
  TestReportAddMiscInfo("Fault injection method used", "No");
  TestReportAddMiscInfo("Resource usage evaluation", "No");
  TestReportAddMiscInfo("Priority", "No");
  TestReportAddMiscInfo("Safety relevant", "No");
  
  AddRequirementInfo("Requirement under test", "ARCH_SW_DIA_0016; ARCH_SW_DIA_0194");
  AddRequirementInfo("ARCH_SW_DIA_0016", "Service 0x31 02 will be implemented for RID 0329");
  AddRequirementInfo("ARCH_SW_DIA_0194", "Service shall be available in Extended and Development session");

  //***************************************************************************************

  testCaseComment("Preconditions");
  testStep("STEP", "Bench Initialization");
  RunPreTs();
  //====================================================

  testCaseComment("Action: ARCH_SW_DIA_0016; ARCH_SW_DIA_0194");
  testStep("STEP", "Enter development session.");
  EnterDiagnosticSession("development");
  
  testStep("STEP", "Set breakpoint in function *DIA_runRid0329_TriggerBSRStop*.");
  debugger_setRelativeFunctionBpAtLine("DIA_runRid0329_TriggerBSRStop", 0);
  debugger_run();
 
  testStep("STEP", "Send diag request for RID 03 29 Start --> Request Sent.");
  SendDiagnosticRequest(dTriggerBSRStartRequest, dTriggerBSRStartResponse);
  
  testStep("STEP", "Send diag request for RID 03 29 Stop --> Timeout error.");
  SendDiagnosticRequest(dTriggerBSRStopRequest, dTriggerBSRStopResponse, TRUE);
  
  testWaitForTimeout(2000);
  testStep("STEP", "Check if breakpoint from function DIA_runRid0329_TriggerBSRStop was reached. --> BP was reached.");
  debugger_waitUntilBPisReached(5000);
  
  
  //====================================================
  testCaseComment("Postcondition");
  testStep("STEP", "Return ECU to default values");
  RunPostTs();
}

testcase SW_IT_DIA_runRid0329_TriggerBSRRequestResults_01()
{
  //***********************************Test report header*********************************
  testReportAddMiscInfoBlock("AUTOLIV ELECTRONICS document");
  TestReportAddMiscInfo("Nightly test", "No");
  TestReportAddMiscInfo("Test type", "Requirement-Based test");
  TestReportAddMiscInfo("Regression Test", "No");
  TestReportAddMiscInfo("Fault injection method used", "No");
  TestReportAddMiscInfo("Resource usage evaluation", "No");
  TestReportAddMiscInfo("Priority", "No");
  TestReportAddMiscInfo("Safety relevant", "No");
  
  AddRequirementInfo("Requirement under test", "ARCH_SW_DIA_0017; ARCH_SW_DIA_0195; ARCH_SW_DIA_0196");
  AddRequirementInfo("ARCH_SW_DIA_0017", "Service 0x31 03 will be implemented for RID 0329");
  AddRequirementInfo("ARCH_SW_DIA_0195", "Service shall be available in Extended and Development session");
  AddRequirementInfo("ARCH_SW_DIA_0196", "Result can have the following values: 0x00, 0x01 and 0x02");

  //***************************************************************************************

  testCaseComment("Preconditions");
  testStep("STEP", "Bench Initialization");
  RunPreTs();
  //====================================================

  testStep("STEP", "Enter development session.");
  EnterDiagnosticSession("development");
  
  testStep("STEP", "Set breakpoint in function *DIA_runRid0329_TriggerBSRRequestResults*.");
  debugger_setRelativeFunctionBpAtLine("DIA_runRid0329_TriggerBSRRequestResults", 0);
 
  testStep("STEP", "Send diag request for RID 03 29 Start --> Request Sent.");
  SendDiagnosticRequest(dTriggerBSRStartRequest, dTriggerBSRStartResponse);
  
  testStep("STEP", "Send diag request for RID 03 29 Request Results --> Timeout error.");
//  SendDiagnosticRequest(dTriggerBSRRequestRequest, dTriggerBSRRequestResponse, TRUE);
  
  testWaitForTimeout(2000);
  testCaseComment("Action: ARCH_SW_DIA_0017; ARCH_SW_DIA_0195; ARCH_SW_DIA_0196");
  testStep("STEP", "Check if breakpoint from function DIA_runRid0330_TriggerTensioningCycleRequestResults was reached. --> BP was reached.");
  debugger_waitUntilBPisReached(5000);
  
  
  //====================================================
  testCaseComment("Postcondition");
  testStep("STEP", "Return ECU to default values");
  RunPostTs();
  
}

testcase SW_IT_DIA_runRid0330_TriggerTensioningCycleStart_01()
{
  ////***********************************Test report header*********************************
  testReportAddMiscInfoBlock("AUTOLIV ELECTRONICS document");
  TestReportAddMiscInfo("Nightly test", "No");
  TestReportAddMiscInfo("Test type", "Requirement-Based test");
  TestReportAddMiscInfo("Regression Test", "No");
  TestReportAddMiscInfo("Fault injection method used", "No");
  TestReportAddMiscInfo("Resource usage evaluation", "No");
  TestReportAddMiscInfo("Priority", "No");
  TestReportAddMiscInfo("Safety relevant", "No");
  
  AddRequirementInfo("Requirement under test", "ARCH_SW_DIA_0019; ARCH_SW_DIA_0197; ARCH_SW_DIA_0198; ARCH_SW_DIA_0199; ARCH_SW_DIA_0200");
  AddRequirementInfo("ARCH_SW_DIA_0019", "Service 0x31 02 will be implemented for RID 0330");
  AddRequirementInfo("ARCH_SW_DIA_0197", "Service shall be available in Extended and Development session");
  AddRequirementInfo("ARCH_SW_DIA_0198", "Type of Tensioning Cycle shall accept only values between 0x01 and 0x05.");
  AddRequirementInfo("ARCH_SW_DIA_0199", "Presafe Duration shall determine the time of the tensioning cycle");
  AddRequirementInfo("ARCH_SW_DIA_0200", "Result can have the following values: 0x00, 0x01 and 0x02");

  ////***************************************************************************************

  testCaseComment("Preconditions");
  testStep("STEP", "Bench Initialization");
  RunPreTs();
  ////====================================================

  testStep("STEP", "Enter development session.");
  EnterDiagnosticSession("development");
  
  testStep("STEP", "Set breakpoint in function *DIA_runRid0330_TriggerTensioningCycleStart*.");
  debugger_setRelativeFunctionBpAtLine("DIA_runRid0330_TriggerTensioningCycleStart", 0);
  debugger_run();
 
  testCaseComment("Action: ARCH_SW_DIA_0019; ARCH_SW_DIA_0197; ARCH_SW_DIA_0198; ARCH_SW_DIA_0199; ARCH_SW_DIA_0200");
  testStep("STEP", "Send diag request for RID 03 30 Start --> Request Sent.");
  SendDiagnosticRequest(dTriggerTensioningCycleStartRequest, dTriggerTensioningCycleStartResponse, TRUE);
  
  testWaitForTimeout(2000);
  testStep("STEP", "Check if breakpoint from function DIA_runRid0330_TriggerTensioningCycleStart was reached. --> BP was reached.");
  debugger_waitUntilBPisReached(5000);
  
  
  ////====================================================
  testCaseComment("Postcondition");
  testStep("STEP", "Return ECU to default values");
  RunPostTs();
}

testcase SW_IT_DIA_runRid0330_TriggerTensioningCycleStop_01()
{
  ////***********************************Test report header*********************************
  testReportAddMiscInfoBlock("AUTOLIV ELECTRONICS document");
  TestReportAddMiscInfo("Nightly test", "No");
  TestReportAddMiscInfo("Test type", "Requirement-Based test");
  TestReportAddMiscInfo("Regression Test", "No");
  TestReportAddMiscInfo("Fault injection method used", "No");
  TestReportAddMiscInfo("Resource usage evaluation", "No");
  TestReportAddMiscInfo("Priority", "No");
  TestReportAddMiscInfo("Safety relevant", "No");
  
  AddRequirementInfo("Requirement under test", "ARCH_SW_DIA_0018; ARCH_SW_DIA_0201");
  AddRequirementInfo("ARCH_SW_DIA_0018", "Service 0x31 01 will be implemented for RID 0330");
  AddRequirementInfo("ARCH_SW_DIA_0201", "Service shall be available in Extended and Development session");

  ////***************************************************************************************

  testCaseComment("Preconditions");
  testStep("STEP", "Bench Initialization");
  RunPreTs();
  ////====================================================

  testStep("STEP", "Enter development session.");
  EnterDiagnosticSession("development");
  
  testStep("STEP", "Set breakpoint in function *DIA_runRid0330_TriggerTensioningCycleStop*.");
  debugger_setRelativeFunctionBpAtLine("DIA_runRid0330_TriggerTensioningCycleStop", 0);

  testStep("STEP", "Send diag request for RID 03 30 Start --> Request Sent.");
  SendDiagnosticRequest(dTriggerTensioningCycleStartRequest, dTriggerTensioningCycleStartResponse);
  
  testStep("STEP", "Send diag request for RID 03 30 Stop --> Timeout error.");
  SendDiagnosticRequest(dTriggerTensioningCycleStopRequest, dTriggerTensioningCycleStopResponse, TRUE);
  
  testCaseComment("Action: ARCH_SW_DIA_0018; ARCH_SW_DIA_0201");
  testStep("STEP", "Check if breakpoint from function DIA_runRid0330_TriggerTensioningCycleStop was reached. --> BP was reached.");
  debugger_waitUntilBPisReached(5000);
  
  
  ////====================================================
  testCaseComment("Postcondition");
  testStep("STEP", "Return ECU to default values");
  RunPostTs();
}

testcase SW_IT_DIA_runRid0330_TriggerTensioningCycleRequestResults_01()
{

  //***********************************Test report header*********************************
  testReportAddMiscInfoBlock("AUTOLIV ELECTRONICS document");
  TestReportAddMiscInfo("Nightly test", "No");
  TestReportAddMiscInfo("Test type", "Requirement-Based test");
  TestReportAddMiscInfo("Regression Test", "No");
  TestReportAddMiscInfo("Fault injection method used", "No");
  TestReportAddMiscInfo("Resource usage evaluation", "No");
  TestReportAddMiscInfo("Priority", "No");
  TestReportAddMiscInfo("Safety relevant", "No");
  
  AddRequirementInfo("Requirement under test", "ARCH_SW_DIA_0020; ARCH_SW_DIA_0204; ARCH_SW_DIA_0205");
  AddRequirementInfo("ARCH_SW_DIA_0020", "Service 0x31 03 will be implemented for RID 0330");
  AddRequirementInfo("ARCH_SW_DIA_0204", "Service shall be available in Extended and Development session");
  AddRequirementInfo("ARCH_SW_DIA_0205", "Result can have the following values: 0x00, 0x01 and 0x02");

  //***************************************************************************************

  testCaseComment("Preconditions");
  testStep("STEP", "Bench Initialization");
  RunPreTs();
  //====================================================

  testStep("STEP", "Enter development session.");
  EnterDiagnosticSession("development");
  
  testStep("STEP", "Set breakpoint in function *DIA_runRid0330_TriggerTensioningCycleRequestResults*.");
  debugger_setRelativeFunctionBpAtLine("DIA_runRid0330_TriggerTensioningCycleRequestResults", 0);
 
  testStep("STEP", "Send diag request for RID 03 30 Start --> Request Sent.");
  SendDiagnosticRequest(dTriggerTensioningCycleStartRequest, dTriggerTensioningCycleStartResponse);
  
  testStep("STEP", "Send diag request for RID 03 30 Request Results --> Timeout error.");
  SendDiagnosticRequest(dTriggerTensioningCycleResponseRequest, dTriggerTensioningCycleResponseResponse, TRUE);
  
  testCaseComment("Action: ARCH_SW_DIA_0020; ARCH_SW_DIA_0204; ARCH_SW_DIA_0205");
  testStep("STEP", "Check if breakpoint from function DIA_runRid0330_TriggerTensioningCycleRequestResults was reached. --> BP was reached.");
  debugger_waitUntilBPisReached(5000);
  
 
  //====================================================
  testCaseComment("Postcondition");
  testStep("STEP", "Return ECU to default values");
  RunPostTs();
  
}

testcase SW_IT_DIA_runRid0302_TriggerPresafeDisplayRequestStart_01()
{
  //***********************************Test report header*********************************
  testReportAddMiscInfoBlock("AUTOLIV ELECTRONICS document");
  TestReportAddMiscInfo("Nightly test", "No");
  TestReportAddMiscInfo("Test type", "Requirement-Based test");
  TestReportAddMiscInfo("Regression Test", "No");
  TestReportAddMiscInfo("Fault injection method used", "No");
  TestReportAddMiscInfo("Resource usage evaluation", "No");
  TestReportAddMiscInfo("Priority", "No");
  TestReportAddMiscInfo("Safety relevant", "No");
  
  AddRequirementInfo("Requirement under test", "ARCH_SW_DIA_0220; ARCH_SW_DIA_0225; ARCH_SW_DIA_0226; ARCH_SW_DIA_0227; ARCH_SW_DIA_0228");
  AddRequirementInfo("ARCH_SW_DIA_0220", "Service 0x31 (Routine Control) 0x31 01 0x31 02 0x31 03 for RID 0x0302 (Trigger Pre-Safe Display Request) will be implemented");
  AddRequirementInfo("ARCH_SW_DIA_0225", "Service shall be available in Default session, Extended session Update session and Development session");
  AddRequirementInfo("ARCH_SW_DIA_0226", "Service shall be available in the following forms of Authentication: Supplier, Development ENHANCED, Production, After-Sales ENHANCED, After-Sales");
  AddRequirementInfo("ARCH_SW_DIA_0227", "Successful Authentication is a pre-condition for running this Service");
  AddRequirementInfo("ARCH_SW_DIA_0228", "Result can have the following values: 0x00, 0x01 and 0x02");

  //***************************************************************************************

  testCaseComment("Preconditions");
  testStep("STEP", "Bench Initialization");
  RunPreTs();
  //====================================================

  testStep("STEP", "Enter development session.");
  EnterDiagnosticSession("development");
  
  testStep("STEP", "Set breakpoint in function *DIA_runRid0302_TriggerPresafeDisplayRequestStart*.");
  debugger_setRelativeFunctionBpAtLine("DIA_runRid0302_TriggerPresafeDisplayRequestStart", 0);
 
  testCaseComment("Action: ARCH_SW_DIA_0220; ARCH_SW_DIA_0225; ARCH_SW_DIA_0226; ARCH_SW_DIA_0227; ARCH_SW_DIA_0228");
  testStep("STEP", "Send diag request for RID 03 02 Start --> Request Sent.");
  SendDiagnosticRequest(dTriggerPresafeDisplayStartRequest, dTriggerPresafeDisplayStartResponse, TRUE);
  
  testWaitForTimeout(2000);
  testStep("STEP", "Check if breakpoint from function DIA_runRid0302_TriggerPresafeDisplayRequestStart was reached. --> BP was reached.");
  debugger_waitUntilBPisReached(5000);
  debugger_isCPUStoppedAtFunction("DIA_runRid0302_TriggerPresafeDisplayRequestStart");
  
  
  //====================================================
  testCaseComment("Postcondition");
  testStep("STEP", "Return ECU to default values");
  RunPostTs();
}

testcase SW_IT_DIA_runRid0302_TriggerPresafeDisplayRequestStop_01()
{
  ////***********************************Test report header*********************************
  testReportAddMiscInfoBlock("AUTOLIV ELECTRONICS document");
  TestReportAddMiscInfo("Nightly test", "No");
  TestReportAddMiscInfo("Test type", "Requirement-Based test");
  TestReportAddMiscInfo("Regression Test", "No");
  TestReportAddMiscInfo("Fault injection method used", "No");
  TestReportAddMiscInfo("Resource usage evaluation", "No");
  TestReportAddMiscInfo("Priority", "No");
  TestReportAddMiscInfo("Safety relevant", "No");
  
  AddRequirementInfo("Requirement under test", "ARCH_SW_DIA_0220; ARCH_SW_DIA_0229; ARCH_SW_DIA_0230; ARCH_SW_DIA_0231; ARCH_SW_DIA_0232");
  AddRequirementInfo("ARCH_SW_DIA_0220", "Service 0x31 (Routine Control) 0x31 01 0x31 02 0x31 03 for RID 0x0302 (Trigger Pre-Safe Display Request) will be implemented");
  AddRequirementInfo("ARCH_SW_DIA_0229", "Service shall be available in Default session, Extended session Update session and Development session");
  AddRequirementInfo("ARCH_SW_DIA_0230", "Service shall be available in the following forms of Authentication: Supplier, Development ENHANCED, Production, After-Sales ENHANCED, After-Sales");
  AddRequirementInfo("ARCH_SW_DIA_0231", "Successful Authentication is a pre-condition for running this Service");
  AddRequirementInfo("ARCH_SW_DIA_0232", "Result can have the following values: 0x00, 0x01 and 0x02");

  ////***************************************************************************************

  testCaseComment("Preconditions");
  testStep("STEP", "Bench Initialization");
  RunPreTs();
  ////====================================================

  testStep("STEP", "Enter development session.");
  EnterDiagnosticSession("development");
  
  testStep("STEP", "Set breakpoint in function *DIA_runRid0302_TriggerPresafeDisplayRequestStop*.");
  debugger_setRelativeFunctionBpAtLine("DIA_runRid0302_TriggerPresafeDisplayRequestStop", 0);
  debugger_run();
 
  testStep("STEP", "Send diag request for RID 03 02 Start --> Request Sent.");
  SendDiagnosticRequest(dTriggerPresafeDisplayStartRequest, dTriggerPresafeDisplayStartResponse);
  
  testStep("STEP", "Send diag request for RID 03 02 Stop --> Timeout error.");
  SendDiagnosticRequest(dTriggerPresafeDisplayStopRequest, dTriggerPresafeDisplayStopResponse, TRUE);
  
  testCaseComment("Action: ARCH_SW_DIA_0220; ARCH_SW_DIA_0229; ARCH_SW_DIA_0230; ARCH_SW_DIA_0231; ARCH_SW_DIA_0232");
  testStep("STEP", "Check if breakpoint from function DIA_runRid0302_TriggerPresafeDisplayRequestStop was reached. --> BP was reached.");
  debugger_waitUntilBPisReached(5000);
  
  
  ////====================================================
  testCaseComment("Postcondition");
  testStep("STEP", "Return ECU to default values");
  RunPostTs();
}

testcase SW_IT_DIA_runRid0302_TriggerPresafeDisplayRequestRequestResults_01()
{
  ////***********************************Test report header*********************************
  testReportAddMiscInfoBlock("AUTOLIV ELECTRONICS document");
  TestReportAddMiscInfo("Nightly test", "No");
  TestReportAddMiscInfo("Test type", "Requirement-Based test");
  TestReportAddMiscInfo("Regression Test", "No");
  TestReportAddMiscInfo("Fault injection method used", "No");
  TestReportAddMiscInfo("Resource usage evaluation", "No");
  TestReportAddMiscInfo("Priority", "No");
  TestReportAddMiscInfo("Safety relevant", "No");
  
  AddRequirementInfo("Requirement under test", "ARCH_SW_DIA_0220; ARCH_SW_DIA_0221; ARCH_SW_DIA_0222; ARCH_SW_DIA_0223; ARCH_SW_DIA_0224");
  AddRequirementInfo("ARCH_SW_DIA_0220", "Service 0x31 (Routine Control) 0x31 01 0x31 02 0x31 03 for RID 0x0302 (Trigger Pre-Safe Display Request) will be implemented");
  AddRequirementInfo("ARCH_SW_DIA_0221", "Service shall be available in Default session, Extended session Update session and Development session");
  AddRequirementInfo("ARCH_SW_DIA_0222", "Service shall be available in the following forms of Authentication: Supplier, Development ENHANCED, Production, After-Sales ENHANCED, After-Sales");
  AddRequirementInfo("ARCH_SW_DIA_0224", "Result can have the following values: 0x00, 0x01 and 0x02");
  AddRequirementInfo("ARCH_SW_DIA_0223", "Successful Authentication is a pre-condition for running this Service");

  ////***************************************************************************************

  testCaseComment("Preconditions");
  testStep("STEP", "Bench Initialization");
  RunPreTs();
  ////====================================================

  testStep("STEP", "Enter development session.");
  EnterDiagnosticSession("development");
  
  testStep("STEP", "Set breakpoint in function *DIA_runRid0302_TriggerPresafeDisplayRequestRequestResults*.");
  debugger_setRelativeFunctionBpAtLine("DIA_runRid0302_TriggerPresafeDisplayRequestRequestResults", 0);
  debugger_run();
 
  testStep("STEP", "Send diag request for RID 03 02 Start --> Request Sent.");
  SendDiagnosticRequest(dTriggerPresafeDisplayStartRequest, dTriggerPresafeDisplayStartResponse);
  
  testStep("STEP", "Send diag request for RID 03 02 Request Results --> Timeout error.");
  SendDiagnosticRequest(dTriggerPresafeDisplayResponseRequest, dTriggerPresafeDisplayResponseResponse, TRUE);
  
  testWaitForTimeout(2000);
  
  testCaseComment("Action: ARCH_SW_DIA_0220; ARCH_SW_DIA_0221; ARCH_SW_DIA_0222; ARCH_SW_DIA_0223; ARCH_SW_DIA_0224");
  testStep("STEP", "Check if breakpoint from function DIA_runRid0302_TriggerPresafeDisplayRequestRequestResults was reached. --> BP was reached.");
  debugger_waitUntilBPisReached(5000);
  
  
  ////====================================================
  testCaseComment("Postcondition");
  testStep("STEP", "Return ECU to default values");
  RunPostTs();
}


testcase SW_IT_DIA_runDid0210_CAN_output_Read_CANoutput1_ReadData_01()
{
  ////***********************************Test report header*********************************
  testReportAddMiscInfoBlock("AUTOLIV ELECTRONICS document");
  TestReportAddMiscInfo("Nightly test", "No");
  TestReportAddMiscInfo("Test type", "Requirement-Based test");
  TestReportAddMiscInfo("Regression Test", "No");
  TestReportAddMiscInfo("Fault injection method used", "No");
  TestReportAddMiscInfo("Resource usage evaluation", "No");
  TestReportAddMiscInfo("Priority", "No");
  TestReportAddMiscInfo("Safety relevant", "No");
  
  AddRequirementInfo("Requirement under test", "ARCH_SW_DIA_0510; ARCH_SW_DIA_0511; ARCH_SW_DIA_0543; ARCH_SW_DIA_0544; ARCH_SW_DIA_0545; ARCH_SW_DIA_0546; ARCH_SW_DIA_0547; ARCH_SW_DIA_0548; ARCH_SW_DIA_0549; ARCH_SW_DIA_0550; ARCH_SW_DIA_0551; ARCH_SW_DIA_0512; ARCH_SW_DIA_0513; ARCH_SW_DIA_0514");
  AddRequirementInfo("ARCH_SW_DIA_0510", "Service 0x22 (Read Data By Identifier) will be implemented for DID 0210 (CAN Output)");
  AddRequirementInfo("ARCH_SW_DIA_0511", "Response data shall contain Presafe Display Request, Belt Slack Decreasing Mode.");
  AddRequirementInfo("ARCH_SW_DIA_0543", "The last value of BSR Function Mode  BltSlckDec_Md_FR_Stat_ST3) shall keep over a next power cycle ( any type of reset )");
  AddRequirementInfo("ARCH_SW_DIA_0544", "If a diagnostic service request is received via CAN Frame DIAG_RBTM_FL_03_ExtCAN_RQ_ST3 then RGS shall respond via DIAG_RBTM_FL_03_ExtCAN_RS_ST3 (Id: 0x18E1A481) frame");
  AddRequirementInfo("ARCH_SW_DIA_0545", "DIAG_RBTM_FL_03_ExtCAN_RS_ST3 Frame size: variable max 8 bytes");
  AddRequirementInfo("ARCH_SW_DIA_0546", "If a diagnostic service request is received via CAN Frame DIAG_RBTM_FR_03_ExtCAN_RQ_ST3 then RGS shall respond via DIAG_RBTM_FR_03_ExtCAN_RS_ST3 (Id: 0x18E1A581) frame");
  AddRequirementInfo("ARCH_SW_DIA_0547", "DIAG_RBTM_FR_03_ExtCAN_RS_ST3 Frame size: variable max 8 bytes");
  AddRequirementInfo("ARCH_SW_DIA_0548", "If a diagnostic service request is received via CAN Frame DIAG_RBTM_FL_03_IntEth_RS_ST3 then RGS shall respond via DIAG_RBTM_FL_03_IntEth_RS_ST3 (Id: 0x18E1A485) frame");
  AddRequirementInfo("ARCH_SW_DIA_0549", "DIAG_RBTM_FL_03_IntEth_RS_ST3 Frame size: variable max 8 bytes");
  AddRequirementInfo("ARCH_SW_DIA_0550", "If a diagnostic service request is received via CAN Frame DIAG_RBTM_FR_03_IntEth_RS_ST3 then RGS shall respond via DIAG_RBTM_FR_03_IntEth_RS_ST3 (Id: 0x18E1A585) frame");
  AddRequirementInfo("ARCH_SW_DIA_0551", "DIAG_RBTM_FR_03_IntEth_RS_ST3 Frame size: variable max 8 bytes");
  AddRequirementInfo("ARCH_SW_DIA_0512", "Response data shall contain PS_Curve_xy_Stat_ST3");
  AddRequirementInfo("ARCH_SW_DIA_0512", "Response data shall contain RBTMxy_ACTV_LVL_ST35");
  AddRequirementInfo("ARCH_SW_DIA_0513", "Response data shall contain RBTMxy_SP_ActvClient_ST35");
  AddRequirementInfo("ARCH_SW_DIA_0514", "Response data shall contain RBTMxy_SP_FCTPrecond_Stat_ST35");

  ////***************************************************************************************

  testCaseComment("Preconditions");
  testStep("STEP", "Bench Initialization");
  RunPreTs();
  ////====================================================

  testStep("STEP", "Enter development session.");
  EnterDiagnosticSession("development");
  
  testStep("STEP", "Set BP in function *DIA_runDid0210_CAN_output_Read_CANoutput1_ReadData* --> BP was reached.");
  debugger_setRelativeFunctionBpAtLine("DIA_runDid0210_CAN_output_Read_CANoutput1_ReadData", 15);
  debugger_run();
  
  testCaseComment("Action: ARCH_SW_DIA_0510; ARCH_SW_DIA_0511; ARCH_SW_DIA_0543; ARCH_SW_DIA_0544; ARCH_SW_DIA_0545; ARCH_SW_DIA_0546; ARCH_SW_DIA_0547; ARCH_SW_DIA_0548; ARCH_SW_DIA_0549; ARCH_SW_DIA_0550; ARCH_SW_DIA_0551; ARCH_SW_DIA_0512; ARCH_SW_DIA_0513; ARCH_SW_DIA_0514");
  testStep("STEP", "Send diag request for 22 0210 and wait for timeout error --> Request sent and timeout received.");
  SendDiagnosticRequest(dCANOutputReadRequest, dCANOutputReadResponse, TRUE);
  debugger_waitUntilBPisReached(5000);
  debugger_isCPUStoppedAtFunction("DIA_runDid0210_CAN_output_Read_CANoutput1_ReadData");
  
  testStep("STEP", "Read Data variable --> Variable read.");
  pi64Data = debugger_readLocalVariable("presfDispReq");
  EvalManStepEqual("Data pointer read.", pi64Data);

  ////====================================================
  testCaseComment("Postcondition");
  testStep("STEP", "Return ECU to default values");
  RunPostTs();
}

testcase SW_IT_DIA_runDidFD50_Hardware_Version_Information_Write_HW_year_01()
{
  int64 i64DataBuffer;
  ////***********************************Test report header*********************************
  testReportAddMiscInfoBlock("AUTOLIV ELECTRONICS document");
  TestReportAddMiscInfo("Nightly test", "No");
  TestReportAddMiscInfo("Test type", "Requirement-Based test");
  TestReportAddMiscInfo("Regression Test", "No");
  TestReportAddMiscInfo("Fault injection method used", "No");
  TestReportAddMiscInfo("Resource usage evaluation", "No");
  TestReportAddMiscInfo("Priority", "No");
  TestReportAddMiscInfo("Safety relevant", "No");
  
  AddRequirementInfo("Requirement under test", "ARCH_SW_DIA_0515; ARCH_SW_DIA_0517;");
  AddRequirementInfo("ARCH_SW_DIA_0515", "Service 0x2E (Write Data By Identifier) will be implemented for DID FD50 (HW Version)");
  AddRequirementInfo("ARCH_SW_DIA_0515", "Runnable shall return 2 bytes, representing PATCH of HW version");
  AddRequirementInfo("ARCH_SW_DIA_0517", "Runnable shall return 2 bytes, representing YEAR of HW version");

  ////***************************************************************************************

  testCaseComment("Preconditions");
  testStep("STEP", "Bench Initialization");
  RunPreTs();
  ////====================================================

  testStep("STEP", "Enter development session.");
  EnterDiagnosticSession("development");
  
  testStep("STEP", "Set breakpoint in function *DIA_runDidFD50_Hardware_Version_Information_Write_HW_year*.");
  debugger_setRelativeFunctionBpAtLine("DIA_runDidFD50_Hardware_Version_Information_Write_HW_year", 0);
  debugger_run();
 
  testCaseComment("Action: ARCH_SW_DIA_0515; ARCH_SW_DIA_0517;");
  testStep("STEP", "Send diag request for 2E FD50 and wait for timeout error --> Timeout reached.");
  SendDiagnosticRequest(dHardwareVersionInformationWriteRequest, dHardwareVersionInformationWriteResponse, TRUE);

  testStep("STEP", "Check if breakpoint from function DIA_runDidFD50_Hardware_Version_Information_Write_HW_year was reached. --> BP was reached.");
  debugger_waitUntilBPisReached(5000);
  debugger_isCPUStoppedAtFunction("DIA_runDidFD50_Hardware_Version_Information_Write_HW_year");
  
  testStep("STEP", "Write Data byte --> Variable overwritten with 0x1.");
  debugger_writeLocalVariable("*Data", 0x1);
  debugger_stepOver();
  i64DataBuffer = debugger_readLocalVariable("*Data");
  EvalManStepEqual("Byte was read", i64DataBuffer, 0x1);
  
  testStep("STEP", "Send diag request for 2E FD50 --> Response received.");
  testWaitForTimeout(2000);
  debugger_deleteAllBP();
  debugger_run();
  SendDiagnosticRequest(dHardwareVersionInformationWriteRequest, dHardwareVersionInformationWriteResponse);
  CheckPositiveResponse(dHardwareVersionInformationWriteRequest, dHardwareVersionInformationWriteResponse);

  
    ////====================================================
  testCaseComment("Postcondition");
  testStep("STEP", "Return ECU to default values");
  RunPostTs();
  
}

testcase SW_IT_DIA_runDidFD50_Hardware_Version_Information_Write_HW_week_01()
{
  int64 i64DataBuffer;
  ////***********************************Test report header*********************************
  testReportAddMiscInfoBlock("AUTOLIV ELECTRONICS document");
  TestReportAddMiscInfo("Nightly test", "No");
  TestReportAddMiscInfo("Test type", "Requirement-Based test");
  TestReportAddMiscInfo("Regression Test", "No");
  TestReportAddMiscInfo("Fault injection method used", "No");
  TestReportAddMiscInfo("Resource usage evaluation", "No");
  TestReportAddMiscInfo("Priority", "No");
  TestReportAddMiscInfo("Safety relevant", "No");
  
  AddRequirementInfo("Requirement under test", "ARCH_SW_DIA_0515; ARCH_SW_DIA_0517;");
  AddRequirementInfo("ARCH_SW_DIA_0515", "Service 0x2E (Write Data By Identifier) will be implemented for DID FD50 (HW Version)");
  AddRequirementInfo("ARCH_SW_DIA_0515", "Runnable shall return 2 bytes, representing PATCH of HW version");
  AddRequirementInfo("ARCH_SW_DIA_0516", "Runnable shall return 2 bytes, representing WEEK of HW version");

  ////***************************************************************************************

  testCaseComment("Preconditions");
  testStep("STEP", "Bench Initialization");
  RunPreTs();
  ////====================================================

  testStep("STEP", "Enter development session.");
  EnterDiagnosticSession("development");
  
  testStep("STEP", "Set breakpoint in function *DIA_runDidFD50_Hardware_Version_Information_Write_HW_week*.");
  debugger_setRelativeFunctionBpAtLine("DIA_runDidFD50_Hardware_Version_Information_Write_HW_week", 0);
  debugger_run();
 
  testCaseComment("Action: ARCH_SW_DIA_0515; ARCH_SW_DIA_0517;");
  testStep("STEP", "Send diag request for 2E FD50 and wait for timeout error --> Timeout reached.");
  SendDiagnosticRequest(dHardwareVersionInformationWriteRequest, dHardwareVersionInformationWriteResponse, TRUE);

  testStep("STEP", "Check if breakpoint from function DIA_runDidFD50_Hardware_Version_Information_Write_HW_year was reached. --> BP was reached.");
  debugger_waitUntilBPisReached(5000);
  debugger_isCPUStoppedAtFunction("DIA_runDidFD50_Hardware_Version_Information_Write_HW_week");
 
  testStep("STEP", "Write Data byte --> Variable overwritten with 0x1.");
  debugger_writeLocalVariable("*Data", 0x1);
  i64DataBuffer = debugger_readLocalVariable("*Data");
  EvalManStepEqual("Byte was read", i64DataBuffer, 0x1);
  
  testStep("STEP", "Send diag request for 2E FD50 --> Response received.");
  testWaitForTimeout(2000);
  debugger_deleteAllBP();
  debugger_run();
  SendDiagnosticRequest(dHardwareVersionInformationWriteRequest, dHardwareVersionInformationWriteResponse);
  CheckPositiveResponse(dHardwareVersionInformationWriteRequest, dHardwareVersionInformationWriteResponse);

    ////====================================================
  testCaseComment("Postcondition");
  testStep("STEP", "Return ECU to default values");
  RunPostTs();
  
}

testcase SW_IT_DIA_runDidEF00_Ecu_Extract_Version()
{
  //***********************************Test report header*********************************
  testReportAddMiscInfoBlock("AUTOLIV ELECTRONICS document");
 TestReportAddMiscInfo("Nightly test", "No");
 TestReportAddMiscInfo("Test type", "Requirement-Based test");
 TestReportAddMiscInfo("Regression Test", "No");
 TestReportAddMiscInfo("Fault injection method used", "No");
 TestReportAddMiscInfo("Resource usage evaluation", "No");
 TestReportAddMiscInfo("Priority", "No");
 TestReportAddMiscInfo("Safety relevant", "No");
 TestReportAddMiscInfo("Test type", "automatic");
  
  AddRequirementInfo("Requirement under test", "ARCH_SW_DIA_0655; ARCH_SW_DIA_0656; ARCH_SW_DIA_0657; ARCH_SW_DIA_0658; ARCH_SW_DIA_0659; ARCH_SW_DIA_0660");
  AddRequirementInfo("ARCH_SW_DIA_0655", "Service 0x22 (Read Data By Identifier) will be implemented for DiagCommonData Structure which is composed by the following DIDs: EF00 (ECU Extract Version) EF01 (Diagnostic Extract Version) EF03 (Standard Application SW Package Information) EF05 (Minimum SW Version) F100 (Active Diagnostic Information) F104 (ECU Name) F10D (DDS Package Release) F111 (MBC ECU Identification - Hardware Part Number) F121 (MBC ECU Identification - Software Logical Block Part Number(s)) F154 (Hardware Supplier Identification) F155 (Software Supplier Identification)");
  AddRequirementInfo("ARCH_SW_DIA_0656", "The Read ECU Extract Version service shall be available in the following sessions: ?Default Session (0x01) ?Programming (0x02) ?Extended Session (0x03) ?Supplier Session/Development Session (0x7E) ");
  AddRequirementInfo("ARCH_SW_DIA_0657", "The Read ECU Extract Version service shall be available under the following forms of Authentication: â¦Supplier â¦Development ENHANCED â¦Production â¦After-Sales ENHANCED â¦After-Sales â¦After-Sales BASIC â¦Internal Diagnostic Test Tool â¦ePTI Test Tool");
  AddRequirementInfo("ARCH_SW_DIA_0658", "DataIdentifier of the Read ECU Extract Version shall be: 0xEF00");
  AddRequirementInfo("ARCH_SW_DIA_0659", "Response data length shall be 54 bytes long Note: Full Response length = 3 bytes + Response data length");
  AddRequirementInfo("ARCH_SW_DIA_0660", "Byte #4: ?bits 0-7: ECU Extract Major Version Byte #5: ?bits 0-7: ECU Extract Minor Version Byte #6: ?bits 0-7: ECU Extract Patch Version Bytes #7: ?bits 0-7: Identification Type (Constant = 0x00) Note: This is not returned on response, instead it is just for EF00 Identification between the CDD Routines. Byte #8-#17: ?bits 0-7: XDIS Version Byte #18-#27: ?bits 0-7: Export Date Byte #28-#57: ?bits 0-7: ECU Name ");

  //***************************************************************************************
  
  testCaseComment("Preconditions");
  testStep("STEP", "Bench Initialization");
  RunPreTs();
  //====================================================

  testCaseComment("Action: ARCH_SW_DIA_0655; ARCH_SW_DIA_0656; ARCH_SW_DIA_0657; ARCH_SW_DIA_0658; ARCH_SW_DIA_0659; ARCH_SW_DIA_0660");
  testStep("STEP", "Send diag request for 22 EF00 and check response --> Response received.");
  SendDiagnosticRequest(dECUEextractVersionReadRequest, dECUEextractVersionReadResponse);
  CheckPositiveResponse("", dECUEextractVersionReadRequest, dECUEextractVersionReadResponse);

  //====================================================
  testCaseComment("Postcondition");
  testStep("STEP", "Return ECU to default values");
  RunPostTs();

}

testcase SW_IT_DIA_runDidEF01_Diagnostic_Extract_Version()
{
  //***********************************Test report header*********************************
  testReportAddMiscInfoBlock("AUTOLIV ELECTRONICS document");
 TestReportAddMiscInfo("Nightly test", "No");
 TestReportAddMiscInfo("Test type", "Requirement-Based test");
 TestReportAddMiscInfo("Regression Test", "No");
 TestReportAddMiscInfo("Fault injection method used", "No");
 TestReportAddMiscInfo("Resource usage evaluation", "No");
 TestReportAddMiscInfo("Priority", "No");
 TestReportAddMiscInfo("Safety relevant", "No");
 TestReportAddMiscInfo("Test type", "automatic");
  
  AddRequirementInfo("Requirement under test", "ARCH_SW_DIA_0655, ARCH_SW_DIA_0661; ARCH_SW_DIA_0662; ARCH_SW_DIA_0663; ARCH_SW_DIA_0664; ARCH_SW_DIA_0665");
  AddRequirementInfo("ARCH_SW_DIA_0655", "Service 0x22 (Read Data By Identifier) will be implemented for DiagCommonData Structure which is composed by the following DIDs: EF00 (ECU Extract Version) EF01 (Diagnostic Extract Version) EF03 (Standard Application SW Package Information) EF05 (Minimum SW Version) F100 (Active Diagnostic Information) F104 (ECU Name) F10D (DDS Package Release) F111 (MBC ECU Identification - Hardware Part Number) F121 (MBC ECU Identification - Software Logical Block Part Number(s)) F154 (Hardware Supplier Identification) F155 (Software Supplier Identification)");
  AddRequirementInfo("ARCH_SW_DIA_0661", "The Read Diagnostic Extract Version service shall be available in the following sessions: â¦Default Session (0x01) â¦Extended Session (0x03) â¦Supplier Session/Development Session (0x7E)");
  AddRequirementInfo("ARCH_SW_DIA_0662", "The Read ECU Extract Version service shall be available under the following forms of Authentication: â¦Supplier â¦Development ENHANCED â¦Production â¦After-Sales ENHANCED â¦After-Sales â¦After-Sales BASIC â¦Internal Diagnostic Test Tool â¦ePTI Test Tool");
  AddRequirementInfo("ARCH_SW_DIA_0663", "DataIdentifier of the Read Diagnostic Extract Version shall be: 0xEF01");
  AddRequirementInfo("ARCH_SW_DIA_0664", "Response data length shall be 53 bytes long Note: Full Response length = 3 bytes + Response data length");
  AddRequirementInfo("ARCH_SW_DIA_0665", "Byte #4: â¦bits 0-7: Diagnostic Extract Major Version Byte #5: â¦bits 0-7: Diagnostic Extract Minor Version Byte #6: â¦bits 0-7: Diagnostic Extract Patch Version Bytes #7-#16: â¦bits 0-7: CANDela Version Bytes #17-#26: â¦bits 0-7: DDM Version Bytes #27-#56: â¦bits 0-7: Exported Diagnostic Variant");

  //***************************************************************************************
  
  testCaseComment("Preconditions");
  testStep("STEP", "Bench Initialization");
  RunPreTs();
  //====================================================

  testCaseComment("Action: ARCH_SW_DIA_0655, ARCH_SW_DIA_0661; ARCH_SW_DIA_0662; ARCH_SW_DIA_0663; ARCH_SW_DIA_0664; ARCH_SW_DIA_0665");
  testStep("STEP", "Send diag request for 22 EF01 and check response --> Response received.");
  SendDiagnosticRequest(dDiagnosticExtractVersionReadRequest, dDiagnosticExtractVersionReadResponse);
  CheckPositiveResponse("", dDiagnosticExtractVersionReadRequest, dDiagnosticExtractVersionReadResponse);

  //====================================================
  testCaseComment("Postcondition");
  testStep("STEP", "Return ECU to default values");
  RunPostTs();

}

testcase SW_IT_DIA_runDidEF03_Standard_Application_SW_Package_Information()
{
  //***********************************Test report header*********************************
  testReportAddMiscInfoBlock("AUTOLIV ELECTRONICS document");
 TestReportAddMiscInfo("Nightly test", "No");
 TestReportAddMiscInfo("Test type", "Requirement-Based test");
 TestReportAddMiscInfo("Regression Test", "No");
 TestReportAddMiscInfo("Fault injection method used", "No");
 TestReportAddMiscInfo("Resource usage evaluation", "No");
 TestReportAddMiscInfo("Priority", "No");
 TestReportAddMiscInfo("Safety relevant", "No");
 TestReportAddMiscInfo("Test type", "automatic");
  
  AddRequirementInfo("Requirement under test", "ARCH_SW_DIA_0655, ARCH_SW_DIA_0666; ARCH_SW_DIA_0667; ARCH_SW_DIA_0668; ARCH_SW_DIA_0669; ARCH_SW_DIA_0670");
  AddRequirementInfo("ARCH_SW_DIA_0655", "Service 0x22 (Read Data By Identifier) will be implemented for DiagCommonData Structure which is composed by the following DIDs: EF00 (ECU Extract Version) EF01 (Diagnostic Extract Version) EF03 (Standard Application SW Package Information) EF05 (Minimum SW Version) F100 (Active Diagnostic Information) F104 (ECU Name) F10D (DDS Package Release) F111 (MBC ECU Identification - Hardware Part Number) F121 (MBC ECU Identification - Software Logical Block Part Number(s)) F154 (Hardware Supplier Identification) F155 (Software Supplier Identification)");
  AddRequirementInfo("ARCH_SW_DIA_0666", "The Read Standard Application SW Package Information service shall be available in the following sessions: â¦Default Session (0x01) â¦Extended Session (0x03) â¦Supplier Session/Development Session (0x7E)");
  AddRequirementInfo("ARCH_SW_DIA_0667", "The Read Standard Application SW Package Information service shall be available under the following forms of Authentication: â¦Supplier â¦Development ENHANCED â¦Production â¦Internal Diagnostic Test Tool");
  AddRequirementInfo("ARCH_SW_DIA_0668", "DataIdentifier of the Read Standard Application SW Package Information shall be: 0xEF03");
  AddRequirementInfo("ARCH_SW_DIA_0669", "Response data length shall be 17 bytes long Note: Full Response length = 3 bytes + Response data length");
  AddRequirementInfo("ARCH_SW_DIA_0670", "Byte #4: â¦bits 0-7: Standard Application SW Package Major Version Byte #5: â¦bits 0-7: Standard Application SW Package Minor Version Byte #6: â¦bits 0-7: Standard Application SW Package Patch Version Byte #7: â¦bits 0-7: Standard Application SW Package Build Version Bytes #8-#17: â¦bits 0-7: ÂµC ID Bytes #18-#19: â¦bits 0-7: Supplier Identification Byte #20: â¦bits 0-7: AUTOSAR Platform");

  //***************************************************************************************
  testCaseComment("Preconditions");
  testStep("STEP", "Bench Initialization");
  RunPreTs();
  //====================================================

  testCaseComment("Action: ARCH_SW_DIA_0655, ARCH_SW_DIA_0666; ARCH_SW_DIA_0667; ARCH_SW_DIA_0668; ARCH_SW_DIA_0669; ARCH_SW_DIA_0670");
  testStep("STEP", "Send diag request for 22 EF03 and check response --> Response received.");
  SendDiagnosticRequest(dStandardApplicationSWPackageInformationReadRequest, dStandardApplicationSWPackageInformationReadResponse);
  CheckPositiveResponse("", dStandardApplicationSWPackageInformationReadRequest, dStandardApplicationSWPackageInformationReadResponse);

  //====================================================
  testCaseComment("Postcondition");
  testStep("STEP", "Return ECU to default values");
  RunPostTs();

}

testcase SW_IT_DIA_runDidEF05_Minimum_SW_Version()
{
  //***********************************Test report header*********************************
  testReportAddMiscInfoBlock("AUTOLIV ELECTRONICS document");
 TestReportAddMiscInfo("Nightly test", "No");
 TestReportAddMiscInfo("Test type", "Requirement-Based test");
 TestReportAddMiscInfo("Regression Test", "No");
 TestReportAddMiscInfo("Fault injection method used", "No");
 TestReportAddMiscInfo("Resource usage evaluation", "No");
 TestReportAddMiscInfo("Priority", "No");
 TestReportAddMiscInfo("Safety relevant", "No");
 TestReportAddMiscInfo("Test type", "automatic");
  
  AddRequirementInfo("Requirement under test", "ARCH_SW_DIA_0655, ARCH_SW_DIA_0671; ARCH_SW_DIA_0672; ARCH_SW_DIA_0673; ARCH_SW_DIA_0674; ARCH_SW_DIA_0675");
  AddRequirementInfo("ARCH_SW_DIA_0655", "Service 0x22 (Read Data By Identifier) will be implemented for DiagCommonData Structure which is composed by the following DIDs: EF00 (ECU Extract Version) EF01 (Diagnostic Extract Version) EF03 (Standard Application SW Package Information) EF05 (Minimum SW Version) F100 (Active Diagnostic Information) F104 (ECU Name) F10D (DDS Package Release) F111 (MBC ECU Identification - Hardware Part Number) F121 (MBC ECU Identification - Software Logical Block Part Number(s)) F154 (Hardware Supplier Identification) F155 (Software Supplier Identification)");
  AddRequirementInfo("ARCH_SW_DIA_0671", "The Read Standard Application SW Package Information service shall be available in the following sessions: â¦Default Session (0x01) â¦Extended Session (0x03) â¦Supplier Session/Development Session (0x7E)");
  AddRequirementInfo("ARCH_SW_DIA_0672", "The Read Minimum SW Version service shall be available under the following forms of Authentication: ?Supplier ?Development ENHANCED ?Production ?After-Sales ENHANCED ?Internal Diagnostic Test Tool ");
  AddRequirementInfo("ARCH_SW_DIA_0673", "DataIdentifier of the Read Minimum SW Version shall be: 0xEF05");
  AddRequirementInfo("ARCH_SW_DIA_0674", "Response data length shall be 3 bytes longNote: Full Response length = 3 bytes + Response data length");
  AddRequirementInfo("ARCH_SW_DIA_0675", "Byte #4: ?bits 0-7: SW Year Byte #5: ?bits 0-7: SW Week Byte #6: ?bits 0-7: SW Patch Level ");

  //***************************************************************************************
  testCaseComment("Preconditions");
  testStep("STEP", "Bench Initialization");
  RunPreTs();
  //====================================================

  testCaseComment("Action: ARCH_SW_DIA_0655, ARCH_SW_DIA_0671; ARCH_SW_DIA_0672; ARCH_SW_DIA_0673; ARCH_SW_DIA_0674; ARCH_SW_DIA_0675");
  testStep("STEP", "Send diag request for 22 EF03 and check response --> Response received.");
  SendDiagnosticRequest(dStandardApplicationSWPackageInformationReadRequest, dStandardApplicationSWPackageInformationReadResponse);
  CheckPositiveResponse("", dStandardApplicationSWPackageInformationReadRequest, dStandardApplicationSWPackageInformationReadResponse);

  //====================================================
  testCaseComment("Postcondition");
  testStep("STEP", "Return ECU to default values");
  RunPostTs();


}


testcase SW_IT_DIA_runDidF100_Active_Diagnostic_Information()
{
  //***********************************Test report header*********************************
  testReportAddMiscInfoBlock("AUTOLIV ELECTRONICS document");
 TestReportAddMiscInfo("Nightly test", "No");
 TestReportAddMiscInfo("Test type", "Requirement-Based test");
 TestReportAddMiscInfo("Regression Test", "No");
 TestReportAddMiscInfo("Fault injection method used", "No");
 TestReportAddMiscInfo("Resource usage evaluation", "No");
 TestReportAddMiscInfo("Priority", "No");
 TestReportAddMiscInfo("Safety relevant", "No");
 TestReportAddMiscInfo("Test type", "automatic");
  
  AddRequirementInfo("Requirement under test", "ARCH_SW_DIA_0655, ARCH_SW_DIA_0676; ARCH_SW_DIA_0677; ARCH_SW_DIA_0678; ARCH_SW_DIA_0679; ARCH_SW_DIA_0680; ARCH_SW_DIA_0681");
  AddRequirementInfo("ARCH_SW_DIA_0655", "Service 0x22 (Read Data By Identifier) will be implemented for DiagCommonData Structure which is composed by the following DIDs: EF00 (ECU Extract Version) EF01 (Diagnostic Extract Version) EF03 (Standard Application SW Package Information) EF05 (Minimum SW Version) F100 (Active Diagnostic Information) F104 (ECU Name) F10D (DDS Package Release) F111 (MBC ECU Identification - Hardware Part Number) F121 (MBC ECU Identification - Software Logical Block Part Number(s)) F154 (Hardware Supplier Identification) F155 (Software Supplier Identification)");
  AddRequirementInfo("ARCH_SW_DIA_0676", "The Read Standard Application SW Package Information service shall be available in the following sessions: â¦Default Session (0x01) â¦Extended Session (0x03) â¦Supplier Session/Development Session (0x7E)");
  AddRequirementInfo("ARCH_SW_DIA_0677", "The Read Active Diagnostic Information service shall be available under the following forms of Authentication: ?Supplier ?Development ENHANCED ?Production ?After-Sales ENHANCED ?After-Sales ?After-Sales BASIC ?Internal Diagnostic Test Tool ?ePTI Test Tool ");
  AddRequirementInfo("ARCH_SW_DIA_0678", "DataIdentifier of the Read Active Diagnostic Information shall be: 0xF100");
  AddRequirementInfo("ARCH_SW_DIA_0679", "Response data length shall be 4 bytes long Note: Full Response length = 3 bytes + Response data length ");
  AddRequirementInfo("ARCH_SW_DIA_0680", "Bytes #2-#3: DataIdentifier of the Read Active Diagnostic Information shall be: 0xF100");
  AddRequirementInfo("ARCH_SW_DIA_0681", "Byte #4: â¦bits 0-7: Active Diagnostic Status 0 = Application / 1 = Bootloader Byte #5: â¦bits 0-7: Active Diagnostic Variant Byte #6: â¦bits 0-7: Active Diagnostic Version Byte #7: â¦bits 0-7: Active Diagnostic Sesion -- 0x01: Default -- 0x02: Programming -- 0x04: Extended");

  //***************************************************************************************
  testCaseComment("Preconditions");
  testStep("STEP", "Bench Initialization");
  RunPreTs();
  //====================================================

  testCaseComment("Action: ARCH_SW_DIA_0655, ARCH_SW_DIA_0676; ARCH_SW_DIA_0677; ARCH_SW_DIA_0678; ARCH_SW_DIA_0679; ARCH_SW_DIA_0680; ARCH_SW_DIA_0681");
  testStep("STEP", "Send diag request for 22 F100 and check response --> Response received.");
  SendDiagnosticRequest(dActiveDiagnosticInformationReadRequest, dActiveDiagnosticInformationReadResponse);
  CheckPositiveResponse("", dActiveDiagnosticInformationReadRequest, dActiveDiagnosticInformationReadResponse);

  //====================================================
  testCaseComment("Postcondition");
  testStep("STEP", "Return ECU to default values");
  RunPostTs();
}


testcase SW_IT_DIA_runDidF104_ECU_Name()
{
  //***********************************Test report header*********************************
  testReportAddMiscInfoBlock("AUTOLIV ELECTRONICS document");
 TestReportAddMiscInfo("Nightly test", "No");
 TestReportAddMiscInfo("Test type", "Requirement-Based test");
 TestReportAddMiscInfo("Regression Test", "No");
 TestReportAddMiscInfo("Fault injection method used", "No");
 TestReportAddMiscInfo("Resource usage evaluation", "No");
 TestReportAddMiscInfo("Priority", "No");
 TestReportAddMiscInfo("Safety relevant", "No");
 TestReportAddMiscInfo("Test type", "automatic");
  
  AddRequirementInfo("Requirement under test", "ARCH_SW_DIA_0655, ARCH_SW_DIA_0682; ARCH_SW_DIA_0683; ARCH_SW_DIA_0684; ARCH_SW_DIA_0685; ARCH_SW_DIA_0686");
  AddRequirementInfo("ARCH_SW_DIA_0655", "Service 0x22 (Read Data By Identifier) will be implemented for DiagCommonData Structure which is composed by the following DIDs: EF00 (ECU Extract Version) EF01 (Diagnostic Extract Version) EF03 (Standard Application SW Package Information) EF05 (Minimum SW Version) F100 (Active Diagnostic Information) F104 (ECU Name) F10D (DDS Package Release) F111 (MBC ECU Identification - Hardware Part Number) F121 (MBC ECU Identification - Software Logical Block Part Number(s)) F154 (Hardware Supplier Identification) F155 (Software Supplier Identification)");
  AddRequirementInfo("ARCH_SW_DIA_0682", "The Read Standard Application SW Package Information service shall be available in the following sessions: â¦Default Session (0x01) â¦Extended Session (0x03) â¦Supplier Session/Development Session (0x7E)");
  AddRequirementInfo("ARCH_SW_DIA_0683", "The Read Active Diagnostic Information service shall be available under the following forms of Authentication: ?Supplier ?Development ENHANCED ?Production ?After-Sales ENHANCED ?After-Sales ?After-Sales BASIC ?Internal Diagnostic Test Tool ?ePTI Test Tool ");
  AddRequirementInfo("ARCH_SW_DIA_0684", "DataIdentifier of the Read ECU Name shall be: 0xF104");
  AddRequirementInfo("ARCH_SW_DIA_0685", "Response data length shall be 1 byte long Note: Full Response length = 3 bytes + Response data length");
  AddRequirementInfo("ARCH_SW_DIA_0686", "Byte #4: Diagnostic ECU Name coded in ASCII Left ECU - RBTMFL174 Right ECU - RBTMFR174");

  //***************************************************************************************
  testCaseComment("Preconditions");
  testStep("STEP", "Bench Initialization");
  RunPreTs();
  //====================================================

  testCaseComment("Action: ARCH_SW_DIA_0655, ARCH_SW_DIA_0682; ARCH_SW_DIA_0683; ARCH_SW_DIA_0684; ARCH_SW_DIA_0685; ARCH_SW_DIA_0686");
  testStep("STEP", "Send diag request for 22 F104 and check response --> Response received.");
  SendDiagnosticRequest(dECUNameReadRequest, dECUNameReadResponse);
  CheckPositiveResponse("", dECUNameReadRequest, dECUNameReadResponse);

  //====================================================
  testCaseComment("Postcondition");
  testStep("STEP", "Return ECU to default values");
  RunPostTs();
}


testcase SW_IT_DIA_runDidF10D_DDS_Package_Release()
{
  //***********************************Test report header*********************************
  testReportAddMiscInfoBlock("AUTOLIV ELECTRONICS document");
 TestReportAddMiscInfo("Nightly test", "No");
 TestReportAddMiscInfo("Test type", "Requirement-Based test");
 TestReportAddMiscInfo("Regression Test", "No");
 TestReportAddMiscInfo("Fault injection method used", "No");
 TestReportAddMiscInfo("Resource usage evaluation", "No");
 TestReportAddMiscInfo("Priority", "No");
 TestReportAddMiscInfo("Safety relevant", "No");
 TestReportAddMiscInfo("Test type", "automatic");
  
  AddRequirementInfo("Requirement under test", "ARCH_SW_DIA_0655, ARCH_SW_DIA_0687; ARCH_SW_DIA_0688; ARCH_SW_DIA_0689; ARCH_SW_DIA_0690; ARCH_SW_DIA_0691");
  AddRequirementInfo("ARCH_SW_DIA_0655", "Service 0x22 (Read Data By Identifier) will be implemented for DiagCommonData Structure which is composed by the following DIDs: EF00 (ECU Extract Version) EF01 (Diagnostic Extract Version) EF03 (Standard Application SW Package Information) EF05 (Minimum SW Version) F100 (Active Diagnostic Information) F104 (ECU Name) F10D (DDS Package Release) F111 (MBC ECU Identification - Hardware Part Number) F121 (MBC ECU Identification - Software Logical Block Part Number(s)) F154 (Hardware Supplier Identification) F155 (Software Supplier Identification)");
  AddRequirementInfo("ARCH_SW_DIA_0687", "The Read Standard Application SW Package Information service shall be available in the following sessions: â¦Default Session (0x01) â¦Extended Session (0x03) â¦Supplier Session/Development Session (0x7E)");
  AddRequirementInfo("ARCH_SW_DIA_0688", "The Read Active Diagnostic Information service shall be available under the following forms of Authentication: ?Supplier ?Development ENHANCED ?Production ?After-Sales ENHANCED ?After-Sales ?After-Sales BASIC ?Internal Diagnostic Test Tool ?ePTI Test Tool ");
  AddRequirementInfo("ARCH_SW_DIA_0689", "DataIdentifier of the Read DDS Package Release shall be: 0xF10D");
  AddRequirementInfo("ARCH_SW_DIA_0690", "Response data length shall be 4 bytes long Note: Full Response length = 3 bytes + Response data length ");
  AddRequirementInfo("ARCH_SW_DIA_0691", "Byte #4: ?bits 0-7: Year Application DDS Package Release Byte #5: ?bits 0-7: Month Application DDS Package Release Byte #6: ?bits 0-7: Year Boot DDS Package Release Byte #7: ?bits 0-7: Month Boot DDS Package Release ");

  //***************************************************************************************
  
  testCaseComment("Preconditions");
  testStep("STEP", "Bench Initialization");
  RunPreTs();
  //====================================================

  testCaseComment("Action: ARCH_SW_DIA_0655, ARCH_SW_DIA_0687; ARCH_SW_DIA_0688; ARCH_SW_DIA_0689; ARCH_SW_DIA_0690; ARCH_SW_DIA_0691");
  testStep("STEP", "Send diag request for 22 F10D and check response --> Response received.");
  SendDiagnosticRequest(dDDSPackageReleaseReadRequest, dDDSPackageReleaseReadResponse);
  CheckPositiveResponse("", dDDSPackageReleaseReadRequest, dDDSPackageReleaseReadResponse);

  //====================================================
  testCaseComment("Postcondition");
  testStep("STEP", "Return ECU to default values");
  RunPostTs();
  
}

testcase SW_IT_DIA_runDidF111_MBC_ECU_Identification_HW_Part_Number()
{
  //***********************************Test report header*********************************
  testReportAddMiscInfoBlock("AUTOLIV ELECTRONICS document");
 TestReportAddMiscInfo("Nightly test", "No");
 TestReportAddMiscInfo("Test type", "Requirement-Based test");
 TestReportAddMiscInfo("Regression Test", "No");
 TestReportAddMiscInfo("Fault injection method used", "No");
 TestReportAddMiscInfo("Resource usage evaluation", "No");
 TestReportAddMiscInfo("Priority", "No");
 TestReportAddMiscInfo("Safety relevant", "No");
 TestReportAddMiscInfo("Test type", "automatic");
  
  AddRequirementInfo("Requirement under test", "ARCH_SW_DIA_0655, ARCH_SW_DIA_0692; ARCH_SW_DIA_0693; ARCH_SW_DIA_0694; ARCH_SW_DIA_0695; ARCH_SW_DIA_0696");
  AddRequirementInfo("ARCH_SW_DIA_0655", "Service 0x22 (Read Data By Identifier) will be implemented for DiagCommonData Structure which is composed by the following DIDs: EF00 (ECU Extract Version) EF01 (Diagnostic Extract Version) EF03 (Standard Application SW Package Information) EF05 (Minimum SW Version) F100 (Active Diagnostic Information) F104 (ECU Name) F10D (DDS Package Release) F111 (MBC ECU Identification - Hardware Part Number) F121 (MBC ECU Identification - Software Logical Block Part Number(s)) F154 (Hardware Supplier Identification) F155 (Software Supplier Identification)");
  AddRequirementInfo("ARCH_SW_DIA_0692", "The Read MBC ECU Identification - Hardware Part Number shall be available in the following sessions: â¦Default Session (0x01) â¦Programming Session (0x02) â¦Extended Session (0x03) â¦Supplier Session/Development Session (0x7E)");
  AddRequirementInfo("ARCH_SW_DIA_0693", "The Read MBC ECU Identification - Hardware Part Number service shall be available under the following forms of Authentication: â¦Supplier â¦Development ENHANCED â¦Production â¦After-Sales ENHANCED â¦After-Sales â¦After-Sales BASIC â¦Internal Diagnostic Test Tool â¦ePTI Test Tool");
  AddRequirementInfo("ARCH_SW_DIA_0694", "DataIdentifier of the Read MBC ECU Identification - Hardware Part Number shall be: 0xF111");
  AddRequirementInfo("ARCH_SW_DIA_0695", "Response data length shall be 10 bytes long Note: Full Response length = 3 bytes + Response data length ");
  AddRequirementInfo("ARCH_SW_DIA_0696", "Bytes #2-#3: DataIdentifier of the Read MBC ECU Identification - Hardware Part Number shall be: 0xF111 Bytes #4-#13: Hardware Part Number [ASCII coded]  ");

  //***************************************************************************************
  
  testCaseComment("Preconditions");
  testStep("STEP", "Bench Initialization");
  RunPreTs();
  //====================================================

  testCaseComment("Action: ARCH_SW_DIA_0655, ARCH_SW_DIA_0692; ARCH_SW_DIA_0693; ARCH_SW_DIA_0694; ARCH_SW_DIA_0695; ARCH_SW_DIA_0696");
  testStep("STEP", "Send diag request for 22 F111 and check response --> Response received.");
  testStepFail("CAPL Error: Diag object not found");

  //====================================================
  testCaseComment("Postcondition");
  testStep("STEP", "Return ECU to default values");
  RunPostTs();

}

testcase SW_IT_DIA_runDidF121_MBC_ECU_Identification_HW_Part_Number()
{
  //***********************************Test report header*********************************
  testReportAddMiscInfoBlock("AUTOLIV ELECTRONICS document");
 TestReportAddMiscInfo("Nightly test", "No");
 TestReportAddMiscInfo("Test type", "Requirement-Based test");
 TestReportAddMiscInfo("Regression Test", "No");
 TestReportAddMiscInfo("Fault injection method used", "No");
 TestReportAddMiscInfo("Resource usage evaluation", "No");
 TestReportAddMiscInfo("Priority", "No");
 TestReportAddMiscInfo("Safety relevant", "No");
 TestReportAddMiscInfo("Test type", "automatic");
  
  AddRequirementInfo("Requirement under test", "ARCH_SW_DIA_0655, ARCH_SW_DIA_0697; ARCH_SW_DIA_0698; ARCH_SW_DIA_0699; ARCH_SW_DIA_0700");
  AddRequirementInfo("ARCH_SW_DIA_0655", "Service 0x22 (Read Data By Identifier) will be implemented for DiagCommonData Structure which is composed by the following DIDs: EF00 (ECU Extract Version) EF01 (Diagnostic Extract Version) EF03 (Standard Application SW Package Information) EF05 (Minimum SW Version) F100 (Active Diagnostic Information) F104 (ECU Name) F10D (DDS Package Release) F111 (MBC ECU Identification - Hardware Part Number) F121 (MBC ECU Identification - Software Logical Block Part Number(s)) F154 (Hardware Supplier Identification) F155 (Software Supplier Identification)");
  AddRequirementInfo("ARCH_SW_DIA_0697", "The Read MBC ECU Identification - Software Logical Block Part Number(s) shall be available in the following sessions: ?Default Session (0x01) ?Programming Session (0x02) ?Extended Session (0x03) ?Supplier Session/Development Session (0x7E) ");
  AddRequirementInfo("ARCH_SW_DIA_0698", "The Read MBC ECU Identification - Software Logical Block Part Number(s) service shall be available under the following forms of Authentication: ?Supplier ?Development ENHANCED ?Production ?After-Sales ENHANCED ?After-Sales ?After-Sales BASIC ?Internal Diagnostic Test Tool ?ePTI Test Tool ");
  AddRequirementInfo("ARCH_SW_DIA_0699", "DataIdentifier of the Read MBC ECU Identification - Hardware Part Number shall be: 0xF111");
  AddRequirementInfo("ARCH_SW_DIA_0700", "Response data length shall be 10 bytes long Note: Full Response length = 3 bytes + Response data length ");

  //***************************************************************************************
    testCaseComment("Preconditions");
  testStep("STEP", "Bench Initialization");
  RunPreTs();
  //====================================================
  
  testCaseComment("Action: ARCH_SW_DIA_0655, ARCH_SW_DIA_0697; ARCH_SW_DIA_0698; ARCH_SW_DIA_0699; ARCH_SW_DIA_0700");
  testStep("STEP", "Send diag request for 22 F121 and check response --> Response received.");
  testStepFail("CAPL Error: Diag object not found");

  
    //====================================================
  testCaseComment("Postcondition");
  testStep("STEP", "Return ECU to default values");
  RunPostTs();

}


testcase SW_IT_DIA_runDidF154_Hardware_Supplier_Identification()
{
  //***********************************Test report header*********************************
  testReportAddMiscInfoBlock("AUTOLIV ELECTRONICS document");
 TestReportAddMiscInfo("Nightly test", "No");
 TestReportAddMiscInfo("Test type", "Requirement-Based test");
 TestReportAddMiscInfo("Regression Test", "No");
 TestReportAddMiscInfo("Fault injection method used", "No");
 TestReportAddMiscInfo("Resource usage evaluation", "No");
 TestReportAddMiscInfo("Priority", "No");
 TestReportAddMiscInfo("Safety relevant", "No");
 TestReportAddMiscInfo("Test type", "automatic");
  
  AddRequirementInfo("Requirement under test", "ARCH_SW_DIA_0655, ARCH_SW_DIA_0701; ARCH_SW_DIA_0702; ARCH_SW_DIA_0703; ARCH_SW_DIA_0704; ARCH_SW_DIA_0705");
  AddRequirementInfo("ARCH_SW_DIA_0655", "Service 0x22 (Read Data By Identifier) will be implemented for DiagCommonData Structure which is composed by the following DIDs: EF00 (ECU Extract Version) EF01 (Diagnostic Extract Version) EF03 (Standard Application SW Package Information) EF05 (Minimum SW Version) F100 (Active Diagnostic Information) F104 (ECU Name) F10D (DDS Package Release) F111 (MBC ECU Identification - Hardware Part Number) F121 (MBC ECU Identification - Software Logical Block Part Number(s)) F154 (Hardware Supplier Identification) F155 (Software Supplier Identification)");
  AddRequirementInfo("ARCH_SW_DIA_0701", "The Read Hardware Supplier Identification shall be available in the following sessions: ?Default Session (0x01) ?Programming Session (0x02) ?Extended Session (0x03) ?Supplier Session/Development Session (0x7E ");
  AddRequirementInfo("ARCH_SW_DIA_0702", "The Read Hardware Supplier Identification service shall be available under the following forms of Authentication: ?Supplier ?Development ENHANCED ?Production ?After-Sales ENHANCED ?After-Sales ?After-Sales BASIC ?Internal Diagnostic Test Tool ?ePTI Test Tool ");
  AddRequirementInfo("ARCH_SW_DIA_0703", "DataIdentifier of the Read Hardware Supplier Identification shall be: 0xF154");
  AddRequirementInfo("ARCH_SW_DIA_0704", "Response data length shall be 2 bytes long Note: Full Response length = 3 bytes + Response data length ");
  AddRequirementInfo("ARCH_SW_DIA_0705", "Byte #4:?bits 0-7: Hardware Supplier IdentificationByte #5:?bits 0-7: Hardware Supplier Identification");

  //***************************************************************************************
  
  testCaseComment("Preconditions");
  testStep("STEP", "Bench Initialization");
  RunPreTs();
  //====================================================
  
  testCaseComment("Action: ARCH_SW_DIA_0655, ARCH_SW_DIA_0701; ARCH_SW_DIA_0702; ARCH_SW_DIA_0703; ARCH_SW_DIA_0704; ARCH_SW_DIA_0705");
  testStep("STEP", "Send diag request for 22 F10D and check response --> Response received.");
  SendDiagnosticRequest(dHardwareSupplierReadRequest, dHardwareSupplierReadResponse);
  CheckPositiveResponse("", dHardwareSupplierReadRequest, dHardwareSupplierReadResponse);
  
  //====================================================
  testCaseComment("Postcondition");
  testStep("STEP", "Return ECU to default values");
  RunPostTs();
}

testcase SW_IT_DIA_runDidF155_Software_Supplier_Identification()
{
  //***********************************Test report header*********************************
  testReportAddMiscInfoBlock("AUTOLIV ELECTRONICS document");
 TestReportAddMiscInfo("Nightly test", "No");
 TestReportAddMiscInfo("Test type", "Requirement-Based test");
 TestReportAddMiscInfo("Regression Test", "No");
 TestReportAddMiscInfo("Fault injection method used", "No");
 TestReportAddMiscInfo("Resource usage evaluation", "No");
 TestReportAddMiscInfo("Priority", "No");
 TestReportAddMiscInfo("Safety relevant", "No");
 TestReportAddMiscInfo("Test type", "automatic");
  
  AddRequirementInfo("Requirement under test", "ARCH_SW_DIA_0655, ARCH_SW_DIA_0706; ARCH_SW_DIA_0707; ARCH_SW_DIA_0708; ARCH_SW_DIA_0709; ARCH_SW_DIA_0710, ARCH_SW_DIA_0711");
  AddRequirementInfo("ARCH_SW_DIA_0655", "Service 0x22 (Read Data By Identifier) will be implemented for DiagCommonData Structure which is composed by the following DIDs: EF00 (ECU Extract Version) EF01 (Diagnostic Extract Version) EF03 (Standard Application SW Package Information) EF05 (Minimum SW Version) F100 (Active Diagnostic Information) F104 (ECU Name) F10D (DDS Package Release) F111 (MBC ECU Identification - Hardware Part Number) F121 (MBC ECU Identification - Software Logical Block Part Number(s)) F154 (Hardware Supplier Identification) F155 (Software Supplier Identification)");
  AddRequirementInfo("ARCH_SW_DIA_0706", "DataIdentifier of the Software Supplier Identification shall be: 0xF155");
  AddRequirementInfo("ARCH_SW_DIA_0707", "The Read Software Supplier Identification shall be available in the following sessions: ? Default Session (0x01) ? Programming Session (0x02) ? Extended Session (0x03) ? Supplier Session/Development Session (0x7E) ");
  AddRequirementInfo("ARCH_SW_DIA_0708", "The Read Software Supplier Identification service shall be available under the following forms of Authentication: ?Supplier ?Development ENHANCED ?Production ?After-Sales ENHANCED ?After-Sales ?After-Sales BASIC ?Internal Diagnostic Test Tool ?ePTI Test Tool ");
  AddRequirementInfo("ARCH_SW_DIA_0709", "Response data length shall be 2 bytes long for eack logical block Note: Full Response length = 3 bytes + Response data length ");
  AddRequirementInfo("ARCH_SW_DIA_0710", "Bytes #2-#3: DataIdentifier of the Read Software Supplier Identification shall be: 0xF155");
  AddRequirementInfo("ARCH_SW_DIA_0711", "Byte #4: ?bits 0-7: Software Logical Block Supplier Identification Byte #5: ?bits 0-7: Software Logical Block Supplier Identification ");

  //***************************************************************************************
  
  testCaseComment("Preconditions");
  testStep("STEP", "Bench Initialization");
  RunPreTs();
  //====================================================
  
  testCaseComment("Action: ARCH_SW_DIA_0655, ARCH_SW_DIA_0706; ARCH_SW_DIA_0707; ARCH_SW_DIA_0708; ARCH_SW_DIA_0709; ARCH_SW_DIA_0710, ARCH_SW_DIA_0711");
  testStep("STEP", "Send diag request for 22 F10D and check response --> Response received.");
  SendDiagnosticRequest(dSoftwareSupplierReadRequest, dSoftwareSupplierReadResponse);
  CheckPositiveResponse("", dSoftwareSupplierReadRequest, dSoftwareSupplierReadResponse);
  
  //====================================================
  testCaseComment("Postcondition");
  testStep("STEP", "Return ECU to default values");
  RunPostTs();
}


testcase SW_IT_DIA_runDid0220_HW_input_Read_Voltage_KL30t_ReadData()
{
  //***********************************Test report header*********************************
  testReportAddMiscInfoBlock("AUTOLIV ELECTRONICS document");
 TestReportAddMiscInfo("Nightly test", "No");
 TestReportAddMiscInfo("Test type", "Requirement-Based test");
 TestReportAddMiscInfo("Regression Test", "No");
 TestReportAddMiscInfo("Fault injection method used", "No");
 TestReportAddMiscInfo("Resource usage evaluation", "No");
 TestReportAddMiscInfo("Priority", "No");
 TestReportAddMiscInfo("Safety relevant", "No");
 TestReportAddMiscInfo("Test type", "automatic");
  
  AddRequirementInfo("Requirement under test", "ARCH_SW_DIA_0555; ARCH_SW_DIA_0556; ARCH_SW_DIA_0557; ARCH_SW_DIA_0558; ARCH_SW_DIA_0559; ARCH_SW_DIA_0560; ARCH_SW_DIA_0561; ARCH_SW_DIA_0562");
  AddRequirementInfo("ARCH_SW_DIA_0555", "Service 0x22 (Read Data By Identifier) will be implemented for DID 0220 (HW Input)");
  AddRequirementInfo("ARCH_SW_DIA_0556", "The Read HW Input service shall be available in the following sessions: ?Default Session (0x01) ?Extended Session (0x03) ?Supplier Session/Development Session (0x7E) ?Update Session (0x42)Update Session (0x42) ");
  AddRequirementInfo("ARCH_SW_DIA_0557", "The Read HW Input service shall be available under the following forms of Authentication: ?Supplier ?Development ENHANCED ?Production ?After-Sales ENHANCED ?After-Sales ?After-Sales BASIC ?Internal Diagnostic Test Tool ?ePTI Test Tool ");
  AddRequirementInfo("ARCH_SW_DIA_0558", "DataIdentifier of the Read HW Input shall be: 0x0220");
  AddRequirementInfo("ARCH_SW_DIA_0559", "Response data length shall be 5 bytes long Note: Full Response length = 3 bytes + Response data length");
  AddRequirementInfo("ARCH_SW_DIA_0560", "Bytes #2-#3:  DataIdentifier of the Read HW Input shall be: 0x0220");
  AddRequirementInfo("ARCH_SW_DIA_0561", "Byte #4: ?bits 0-7: Voltage KL30t Any value from 0x00 -> 0xFF Offset is 0 (i.e. 0x00 = 0V) Resolution is 0.1 (e.g. 0x10 = 1.6 V) Range is 0V -> 25.4V ");
  AddRequirementInfo("ARCH_SW_DIA_0562", "Read HW Input service shall return the Voltage measured.");

  //***************************************************************************************
  testCaseComment("Preconditions");
  testStep("STEP", "Bench Initialization");
  RunPreTs();
  //====================================================
  
  testStep("STEP", "Set breakpoint in function *DIA_runDid0220_HW_input_Read_Voltage_KL30t_ReadData*.");
  debugger_setRelativeFunctionBpAtLine("DIA_runDid0220_HW_input_Read_Voltage_KL30t_ReadData", 10);
  debugger_run();
 
  testCaseComment("Action: ARCH_SW_DIA_0555; ARCH_SW_DIA_0556; ARCH_SW_DIA_0557; ARCH_SW_DIA_0558; ARCH_SW_DIA_0559; ARCH_SW_DIA_0560; ARCH_SW_DIA_0561; ARCH_SW_DIA_0562");
  testStep("STEP", "Send diag request for 22 0220 and wait for timeout error --> Timeout received.");
  SendDiagnosticRequest(dHWInputReadRequest, dHWInputReadResponse, TRUE);

  testWaitForTimeout(2000);
  testStep("STEP", "Check if breakpoint from function DIA_runDid0220_HW_input_Read_Voltage_KL30t_ReadData was reached. --> BP was reached.");
  debugger_waitUntilBPisReached(5000);
  debugger_isCPUStoppedAtFunction("DIA_runDid0220_HW_input_Read_Voltage_KL30t_ReadData");
  
  testStep("STEP", "Evaluate *Data pointer --> Byte was read.");
  pi64Data = debugger_readLocalVariable("*Data");
  EvalManStepEqual("Data pointer read", pi64Data);
  
  //====================================================
  testCaseComment("Postcondition");
  testStep("STEP", "Return ECU to default values");
  RunPostTs();
}

testcase SW_IT_DIA_runDid0220_HW_input_Read_Voltage_Motor_ReadData()
{
  //***********************************Test report header*********************************
  testReportAddMiscInfoBlock("AUTOLIV ELECTRONICS document");
 TestReportAddMiscInfo("Nightly test", "No");
 TestReportAddMiscInfo("Test type", "Requirement-Based test");
 TestReportAddMiscInfo("Regression Test", "No");
 TestReportAddMiscInfo("Fault injection method used", "No");
 TestReportAddMiscInfo("Resource usage evaluation", "No");
 TestReportAddMiscInfo("Priority", "No");
 TestReportAddMiscInfo("Safety relevant", "No");
 TestReportAddMiscInfo("Test type", "automatic");
  
  AddRequirementInfo("Requirement under test", "ARCH_SW_DIA_0555; ARCH_SW_DIA_0563;");
  AddRequirementInfo("ARCH_SW_DIA_0555", "Service 0x22 (Read Data By Identifier) will be implemented for DID 0220 (HW Input)");
  AddRequirementInfo("ARCH_SW_DIA_0563", "Byte #5: ?bits 0-7: Voltage Motor Any value from 0x00 -> 0xFF Offset is 0 (i.e. 0x00 = 0V) Resolution is 0.1 (e.g. 0x10 = 1.6 V) Range is 0V -> 25.4V  ");

  //***************************************************************************************
  
  testCaseComment("Preconditions");
  testStep("STEP", "Bench Initialization");
  RunPreTs();
  //====================================================
  
  testStep("STEP", "Set breakpoint in function *DIA_runDid0220_HW_input_Read_Voltage_Motor_ReadData*.");
  debugger_setRelativeFunctionBpAtLine("DIA_runDid0220_HW_input_Read_Voltage_Motor_ReadData", 10);
  debugger_run();
 
  testCaseComment("Action: ARCH_SW_DIA_0555; ARCH_SW_DIA_0563");
  testStep("STEP", "Send diag request for 22 0220 and wait for timeout error --> Timeout received.");
  SendDiagnosticRequest(dHWInputReadRequest, dHWInputReadResponse, TRUE);

  testWaitForTimeout(2000);
  testStep("STEP", "Check if breakpoint from function DIA_runDid0220_HW_input_Read_Voltage_Motor_ReadData was reached. --> BP was reached.");
  debugger_waitUntilBPisReached(5000);
  debugger_isCPUStoppedAtFunction("DIA_runDid0220_HW_input_Read_Voltage_Motor_ReadData");
  
  testStep("STEP", "Evaluate *Data pointer --> Byte was read.");
  pi64Data = debugger_readLocalVariable("*Data");
  EvalManStepEqual("Data pointer read", pi64Data);
  
  //====================================================
  testCaseComment("Postcondition");
  testStep("STEP", "Return ECU to default values");
  RunPostTs();

}

testcase SW_IT_DIA_runDid0240_Internal_ECU_information_Read_Autosar_System_State_EcuM_State_ReadData()
{
  //***********************************Test report header*********************************
  testReportAddMiscInfoBlock("AUTOLIV ELECTRONICS document");
 TestReportAddMiscInfo("Nightly test", "No");
 TestReportAddMiscInfo("Test type", "Requirement-Based test");
 TestReportAddMiscInfo("Regression Test", "No");
 TestReportAddMiscInfo("Fault injection method used", "No");
 TestReportAddMiscInfo("Resource usage evaluation", "No");
 TestReportAddMiscInfo("Priority", "No");
 TestReportAddMiscInfo("Safety relevant", "No");
 TestReportAddMiscInfo("Test type", "automatic");
  
  AddRequirementInfo("Requirement under test", "ARCH_SW_DIA_0565; ARCH_SW_DIA_0566; ARCH_SW_DIA_0567; ARCH_SW_DIA_0568; ARCH_SW_DIA_0569; ARCH_SW_DIA_0570; ARCH_SW_DIA_0571; ARCH_SW_DIA_0572");
  AddRequirementInfo("ARCH_SW_DIA_0565", "Service 0x22 (Read Data By Identifier) will be implemented for DID 0240 (Internal ECU Information)");
  AddRequirementInfo("ARCH_SW_DIA_0566", "The Read Internal ECU Information service shall be available in the following sessions: ?Default Session (0x01) ?Extended Session (0x03) ?Supplier Session/Development Session (0x7E) ?Update Session (0x42)  ");
  AddRequirementInfo("ARCH_SW_DIA_0567", "The Read Internal ECU Information service shall be available under the following forms of Authentication: ?Supplier ?Development ENHANCED ?Production ?After-Sales ENHANCED ?After-Sales ?After-Sales BASIC ?Internal Diagnostic Test Tool ?ePTI Test Tool ");
  AddRequirementInfo("ARCH_SW_DIA_0568", "DataIdentifier of the Read Internal ECU Information shall be: 0x0240");
  AddRequirementInfo("ARCH_SW_DIA_0569", "Response data length shall be 6 bytes long Note: Full Response length = 3 bytes + Response data length ");
  AddRequirementInfo("ARCH_SW_DIA_0570", "Bytes #2-#3:  DataIdentifier of the Read Internal ECU Information shall be: 0x0240");
  AddRequirementInfo("ARCH_SW_DIA_0571", "Byte #4: ?bits 0-7: Autosar System State (EcuM_State) 0x10 - Startup 0x20 - Wakeup 0x30 - Run 0x40 - Shutdown 0x50 - Sleep ");
  AddRequirementInfo("ARCH_SW_DIA_0572", "Read Internal ECU Information service shall return the values measured.");

  //***************************************************************************************
   
  testCaseComment("Preconditions");
  testStep("STEP", "Bench Initialization");
  RunPreTs();
  //====================================================
  
  testStep("STEP", "Set breakpoint in function *DIA_runDid0240_Internal_ECU_information_Read_Autosar_System_State_EcuM_State_ReadData*.");
  debugger_setRelativeFunctionBpAtLine("DIA_runDid0240_Internal_ECU_information_Read_Autosar_System_State_EcuM_State_ReadData", 37);
  debugger_run();
 
  testCaseComment("Action: ARCH_SW_DIA_0565; ARCH_SW_DIA_0566; ARCH_SW_DIA_0567; ARCH_SW_DIA_0568; ARCH_SW_DIA_0569; ARCH_SW_DIA_0570; ARCH_SW_DIA_0571; ARCH_SW_DIA_0572");
  testStep("STEP", "Send diag request for 22 0220 and wait for timeout error --> Timeout received.");
  SendDiagnosticRequest(dInternalECUInformationReadRequest, dInternalECUInformationReadResponse, TRUE);

  testWaitForTimeout(2000);
  testStep("STEP", "Check if breakpoint from function DIA_runDid0240_Internal_ECU_information_Read_Autosar_System_State_EcuM_State_ReadData was reached. --> BP was reached.");
  debugger_waitUntilBPisReached(5000);
  debugger_isCPUStoppedAtFunction("DIA_runDid0240_Internal_ECU_information_Read_Autosar_System_State_EcuM_State_ReadData");
  
  testStep("STEP", "Evaluate *Data pointer --> Byte was read.");
  pi64Data = debugger_readLocalVariable("*Data");
  EvalManStepEqual("Data pointer read", pi64Data);
  
  //====================================================
  testCaseComment("Postcondition");
  testStep("STEP", "Return ECU to default values");
  RunPostTs();

}

testcase SW_IT_DIA_runDid0240_Internal_ECU_information_Read_ECU_Temperature_ReadData()
{
  //***********************************Test report header*********************************
  testReportAddMiscInfoBlock("AUTOLIV ELECTRONICS document");
 TestReportAddMiscInfo("Nightly test", "No");
 TestReportAddMiscInfo("Test type", "Requirement-Based test");
 TestReportAddMiscInfo("Regression Test", "No");
 TestReportAddMiscInfo("Fault injection method used", "No");
 TestReportAddMiscInfo("Resource usage evaluation", "No");
 TestReportAddMiscInfo("Priority", "No");
 TestReportAddMiscInfo("Safety relevant", "No");
 TestReportAddMiscInfo("Test type", "automatic");
  
  AddRequirementInfo("Requirement under test", "ARCH_SW_DIA_0565; ARCH_SW_DIA_0573;");
  AddRequirementInfo("ARCH_SW_DIA_0565", "Service 0x22 (Read Data By Identifier) will be implemented for DID 0240 (Internal ECU Information)");
  AddRequirementInfo("ARCH_SW_DIA_0573", "Bytes #5-#6: ?bits 0-7: ECU Temperature Any value from 0x0A -> 0x043F Offset is -52.7875 (i.e. 0x0A = -50 V) Resolution is 0.2325 (e.g. 0x10 = -49.0675 V) Range is -50 deg C -> 200 deg C Range 0x00 -> 0x09 is Undefined Range 0x0440 -> 0xFFFF is Undefined ");

  //***************************************************************************************
     
  testCaseComment("Preconditions");
  testStep("STEP", "Bench Initialization");
  RunPreTs();
  //====================================================
  
  testStep("STEP", "Set breakpoint in function *DIA_runDid0240_Internal_ECU_information_Read_ECU_Temperature_ReadData*.");
  debugger_setRelativeFunctionBpAtLine("DIA_runDid0240_Internal_ECU_information_Read_ECU_Temperature_ReadData", 14);
  debugger_run();
 
  testCaseComment("Action: ARCH_SW_DIA_0565; ARCH_SW_DIA_0573");
  testStep("STEP", "Send diag request for 22 0220 and wait for timeout error --> Timeout received.");
  SendDiagnosticRequest(dInternalECUInformationReadRequest, dInternalECUInformationReadResponse, TRUE);

  testWaitForTimeout(2000);
  testStep("STEP", "Check if breakpoint from function DIA_runDid0240_Internal_ECU_information_Read_ECU_Temperature_ReadData was reached. --> BP was reached.");
  debugger_waitUntilBPisReached(5000);
  debugger_isCPUStoppedAtFunction("DIA_runDid0240_Internal_ECU_information_Read_ECU_Temperature_ReadData");
  
  testStep("STEP", "Evaluate *Data pointer --> Byte was read.");
  pi64Data = debugger_readLocalVariable("*Data");
  EvalManStepEqual("Data pointer read", pi64Data);
  
  //====================================================
  testCaseComment("Postcondition");
  testStep("STEP", "Return ECU to default values");
  RunPostTs();


}


testcase SW_IT_DIA_runDid0240_Internal_ECU_information_Read_MOTOR_Current_ReadData()
{
  //***********************************Test report header*********************************
  testReportAddMiscInfoBlock("AUTOLIV ELECTRONICS document");
 TestReportAddMiscInfo("Nightly test", "No");
 TestReportAddMiscInfo("Test type", "Requirement-Based test");
 TestReportAddMiscInfo("Regression Test", "No");
 TestReportAddMiscInfo("Fault injection method used", "No");
 TestReportAddMiscInfo("Resource usage evaluation", "No");
 TestReportAddMiscInfo("Priority", "No");
 TestReportAddMiscInfo("Safety relevant", "No");
 TestReportAddMiscInfo("Test type", "automatic");
  
  AddRequirementInfo("Requirement under test", "ARCH_SW_DIA_0565; ARCH_SW_DIA_0574;");
  AddRequirementInfo("ARCH_SW_DIA_0565", "Service 0x22 (Read Data By Identifier) will be implemented for DID 0240 (Internal ECU Information)");
  AddRequirementInfo("ARCH_SW_DIA_0574", "Bytes #7-#8: ?bits 0-7: Motor Current Any value from 0x00 -> 0xFF Offset is 0 (i.e. 0x00 = 0A) Resolution is 0.01 (e.g. 0x100 = 16 A) Range is 0A -> 163.83A ");

  //***************************************************************************************
  
  testCaseComment("Preconditions");
  testStep("STEP", "Bench Initialization");
  RunPreTs();
  //====================================================
  
  testStep("STEP", "Set breakpoint in function *DIA_runDid0240_Internal_ECU_information_Read_MOTOR_Current_ReadData*.");
  debugger_setRelativeFunctionBpAtLine("DIA_runDid0240_Internal_ECU_information_Read_MOTOR_Current_ReadData", 14);
  debugger_run();
 
  testCaseComment("Action: ARCH_SW_DIA_0565; ARCH_SW_DIA_0574");
  testStep("STEP", "Send diag request for 22 0220 and wait for timeout error --> Timeout received.");
  SendDiagnosticRequest(dInternalECUInformationReadRequest, dInternalECUInformationReadResponse, TRUE);

  testWaitForTimeout(2000);
  testStep("STEP", "Check if breakpoint from function DIA_runDid0240_Internal_ECU_information_Read_MOTOR_Current_ReadData was reached. --> BP was reached.");
  debugger_waitUntilBPisReached(5000);
  debugger_isCPUStoppedAtFunction("DIA_runDid0240_Internal_ECU_information_Read_MOTOR_Current_ReadData");
  
  testStep("STEP", "Evaluate *Data pointer --> Byte was read.");
  pi64Data = debugger_readLocalVariable("*Data");
  EvalManStepEqual("Data pointer read", pi64Data);
  
  //====================================================
  testCaseComment("Postcondition");
  testStep("STEP", "Return ECU to default values");
  RunPostTs();


}

testcase SW_IT_DIA_runDidFD03_ECUTraceablityNumberRead()
{
  //***********************************Test report header*********************************
  testReportAddMiscInfoBlock("AUTOLIV ELECTRONICS document");
 TestReportAddMiscInfo("Nightly test", "No");
 TestReportAddMiscInfo("Test type", "Requirement-Based test");
 TestReportAddMiscInfo("Regression Test", "No");
 TestReportAddMiscInfo("Fault injection method used", "No");
 TestReportAddMiscInfo("Resource usage evaluation", "No");
 TestReportAddMiscInfo("Priority", "No");
 TestReportAddMiscInfo("Safety relevant", "No");
 TestReportAddMiscInfo("Test type", "automatic");
  
  AddRequirementInfo("Requirement under test", "ARCH_SW_DIA_0575; ARCH_SW_DIA_0576; ARCH_SW_DIA_0577");
  AddRequirementInfo("ARCH_SW_DIA_0575", "Service 0x22 (Read Data By Identifier) will be implemented for DID FD03 (AEE Traceability Number And PCBA Programmed PN)");
  AddRequirementInfo("ARCH_SW_DIA_0576", "The Read AEE Traceability Number And PCBA programmed PN shall be available in the following sessions: ?Default Session (0x01) ?Extended Session (0x03) ?Supplier Session/Development Session (0x7E) ?Update Session (0x42) ");
  AddRequirementInfo("ARCH_SW_DIA_0577", "The Read AEE Traceability Number And PCBA programmed PN shall be processed without Authentification.");

  //***************************************************************************************
  
    
  testCaseComment("Preconditions");
  testStep("STEP", "Bench Initialization");
  RunPreTs();
  //====================================================
  
  testStep("STEP", "Set breakpoint in function *DIA_runDidFD03_ECUTraceablityNumberRead*.");
  debugger_setRelativeFunctionBpAtLine("DIA_runDidFD03_ECUTraceablityNumberRead", 2);
  debugger_run();
 
  testCaseComment("Action: ARCH_SW_DIA_0575; ARCH_SW_DIA_0576; ARCH_SW_DIA_0577");
  testStep("STEP", "Send diag request for 22 0220 and wait for timeout error --> Timeout received.");
  SendDiagnosticRequest(dECUSerialNumberReadRequest, dECUSerialNumberReadResponse, TRUE);

  testWaitForTimeout(2000);
  testStep("STEP", "Check if breakpoint from function DIA_runDidFD03_ECUTraceablityNumberRead was reached. --> BP was reached.");
  debugger_waitUntilBPisReached(5000);
  debugger_isCPUStoppedAtFunction("DIA_runDidFD03_ECUTraceablityNumberRead");
  
  testStep("STEP", "Evaluate *Data pointer --> Byte was read.");
  pi64Data = debugger_readLocalVariable("*Data");
  EvalManStepEqual("Data pointer read", pi64Data);
  
  //====================================================
  testCaseComment("Postcondition");
  testStep("STEP", "Return ECU to default values");
  RunPostTs();

}

testcase SW_IT_DIA_RUNDIDFD03_PCBAProgrammedPartNumberRead()
{
  //***********************************Test report header*********************************
  testReportAddMiscInfoBlock("AUTOLIV ELECTRONICS document");
 TestReportAddMiscInfo("Nightly test", "No");
 TestReportAddMiscInfo("Test type", "Requirement-Based test");
 TestReportAddMiscInfo("Regression Test", "No");
 TestReportAddMiscInfo("Fault injection method used", "No");
 TestReportAddMiscInfo("Resource usage evaluation", "No");
 TestReportAddMiscInfo("Priority", "No");
 TestReportAddMiscInfo("Safety relevant", "No");
 TestReportAddMiscInfo("Test type", "automatic");
  
  AddRequirementInfo("Requirement under test", "ARCH_SW_DIA_0575; ARCH_SW_DIA_0578; ARCH_SW_DIA_0579; ARCH_SW_DIA_0580; ARCH_SW_DIA_0581; ARCH_SW_DIA_0582");
  AddRequirementInfo("ARCH_SW_DIA_0575", "Service 0x22 (Read Data By Identifier) will be implemented for DID FD03 (AEE Traceability Number And PCBA Programmed PN)");
  AddRequirementInfo("ARCH_SW_DIA_0578", "Data Identifier of the Read AEE Traceability Number And PCBA programmed PN Service shall be: 0xFD03");
  AddRequirementInfo("ARCH_SW_DIA_0579", "Response data length shall be 22 bytes longNote: Full Response length = 3 bytes + Response data length");
  AddRequirementInfo("ARCH_SW_DIA_0580", "Response data length shall be 22 bytes long Note: Full Response length = 3 bytes + Response data length ");
  AddRequirementInfo("ARCH_SW_DIA_0581", "Bytes #4-#15: ?AEE Traceability Number [ASCII Coded ");
  AddRequirementInfo("ARCH_SW_DIA_0582", "Bytes #16-#25: ?PCBA programmed Part Number [ASCII Coded] ");

  //***************************************************************************************
  
      
  testCaseComment("Preconditions");
  testStep("STEP", "Bench Initialization");
  RunPreTs();
  //====================================================
  
  testStep("STEP", "Set breakpoint in function *DIA_runDidFD03_PCBAProgrammedPartNumberRead*.");
  debugger_setRelativeFunctionBpAtLine("DIA_runDidFD03_PCBAProgrammedPartNumberRead", 2);
  debugger_run();
 
  testCaseComment("Action:ARCH_SW_DIA_0575; ARCH_SW_DIA_0578; ARCH_SW_DIA_0579; ARCH_SW_DIA_0580; ARCH_SW_DIA_0581; ARCH_SW_DIA_0582");
  testStep("STEP", "Send diag request for 22 0220 and wait for timeout error --> Timeout received.");
  SendDiagnosticRequest(dECUSerialNumberReadRequest, dECUSerialNumberReadResponse, TRUE);

  testWaitForTimeout(2000);
  testStep("STEP", "Check if breakpoint from function DIA_runDidFD03_PCBAProgrammedPartNumberRead was reached. --> BP was reached.");
  debugger_waitUntilBPisReached(5000);
  debugger_isCPUStoppedAtFunction("DIA_runDidFD03_PCBAProgrammedPartNumberRead");
  
  testStep("STEP", "Evaluate *Data pointer --> Byte was read.");
  pi64Data = debugger_readLocalVariable("*Data");
  EvalManStepEqual("Data pointer read", pi64Data);
  
  //====================================================
  testCaseComment("Postcondition");
  testStep("STEP", "Return ECU to default values");
  RunPostTs();


}

testcase SW_IT_DIA_runDidFD03_ECUTraceablityNumberWrite()
{
  int64 i64NVP_BLOCK_ID_AEE_TRACEABILITY_RamBlockData;
  //***********************************Test report header*********************************
  testReportAddMiscInfoBlock("AUTOLIV ELECTRONICS document");
 TestReportAddMiscInfo("Nightly test", "No");
 TestReportAddMiscInfo("Test type", "Requirement-Based test");
 TestReportAddMiscInfo("Regression Test", "No");
 TestReportAddMiscInfo("Fault injection method used", "No");
 TestReportAddMiscInfo("Resource usage evaluation", "No");
 TestReportAddMiscInfo("Priority", "No");
 TestReportAddMiscInfo("Safety relevant", "No");
 TestReportAddMiscInfo("Test type", "automatic");
  
  AddRequirementInfo("Requirement under test", "ARCH_SW_DIA_0585; ARCH_SW_DIA_0586; ARCH_SW_DIA_0587; ARCH_SW_DIA_0588");
  AddRequirementInfo("ARCH_SW_DIA_0585", "Service 0x2E (Write Data By Identifier) will be implemented for DID FD03 (AEE Traceability Number And PCBA Programmed PN)");
  AddRequirementInfo("ARCH_SW_DIA_0586", "The Write AEE Traceability Number And PCBA programmed PN shall be available in the following sessions: ?Supplier Session/Development Session (0x7E) ");
  AddRequirementInfo("ARCH_SW_DIA_0587", "The Write AEE Traceability Number And PCBA Programmed PN service shall be available under the following forms of Authentication: ?Supplier ?Development ENHANCED ?Production ");
  AddRequirementInfo("ARCH_SW_DIA_0588", "Request data shall be 22 bytes long. Note: Full Request length = 3 bytes + Response data length ");

  //***************************************************************************************
  testCaseComment("Preconditions");
  testStep("STEP", "Bench Initialization");
  RunPreTs();
  //====================================================
    testStep("STEP", "Enter development session.");
  EnterDiagnosticSession("development");
  
  testStep("STEP", "Set breakpoint in function *DIA_runDidFD03_ECUTraceablityNumberWrite*.");
  debugger_setRelativeFunctionBpAtLine("DIA_runDidFD03_ECUTraceablityNumberWrite", 11);
  debugger_run();
 
  testCaseComment("ARCH_SW_DIA_0585; ARCH_SW_DIA_0586; ARCH_SW_DIA_0587; ARCH_SW_DIA_0588");
  testStep("STEP", "Send diag request for 2E FD03 and wait for timeout error --> Timeout reached.");
  SendDiagnosticRequest(dECUSerialNumberWriteRequest, dECUSerialNumberWriteResponse, TRUE);

  testWaitForTimeout(2000);
  testStep("STEP", "Check if breakpoint from function DIA_runDidFD03_ECUTraceablityNumberWrite was reached. --> BP was reached.");
  debugger_waitUntilBPisReached(5000);
  debugger_isCPUStoppedAtFunction("DIA_runDidFD03_ECUTraceablityNumberWrite");
  //====================================================
  testCaseComment("Postcondition");
  testStep("STEP", "Return ECU to default values");
  RunPostTs();
}



testcase SW_IT_DIA_runDidFD03_PCBAProgrammedPartNumberWrite()
{
  //***********************************Test report header*********************************
  testReportAddMiscInfoBlock("AUTOLIV ELECTRONICS document");
 TestReportAddMiscInfo("Nightly test", "No");
 TestReportAddMiscInfo("Test type", "Requirement-Based test");
 TestReportAddMiscInfo("Regression Test", "No");
 TestReportAddMiscInfo("Fault injection method used", "No");
 TestReportAddMiscInfo("Resource usage evaluation", "No");
 TestReportAddMiscInfo("Priority", "No");
 TestReportAddMiscInfo("Safety relevant", "No");
 TestReportAddMiscInfo("Test type", "automatic");
  
  AddRequirementInfo("Requirement under test", "ARCH_SW_DIA_0585; ARCH_SW_DIA_0589; ARCH_SW_DIA_0590; ARCH_SW_DIA_0591; ARCH_SW_DIA_0592; ARCH_SW_DIA_0593");
  AddRequirementInfo("ARCH_SW_DIA_0585", "Service 0x2E (Write Data By Identifier) will be implemented for DID FD03 (AEE Traceability Number And PCBA Programmed PN)");
  AddRequirementInfo("ARCH_SW_DIA_0589", "Bytes #2-#3: DataIdentifier of the Write AEE Traceability Number And PCBA programmed PN shall be: 0xFD03");
  AddRequirementInfo("ARCH_SW_DIA_0590", "Bytes #4-#15: ?AEE Traceability Number [ASCII Coded]");
  AddRequirementInfo("ARCH_SW_DIA_0591", "Bytes #16-#25: ?PCBA programmed Part Number [ASCII Coded] ");
  AddRequirementInfo("ARCH_SW_DIA_0592", "Byte #1: SID-PR of the WriteDataByIdentifier service shall be 0x6E.");
  AddRequirementInfo("ARCH_SW_DIA_0593", "Bytes #2-#3: Data Identifier of the Write AEE Traceability Number And PCBA programmed PN Service shall be: 0xFD03.");

  //***************************************************************************************
  
  testCaseComment("Preconditions");
  testStep("STEP", "Bench Initialization");
  RunPreTs();
  //====================================================
  
  testStep("STEP", "Enter development session.");
  EnterDiagnosticSession("development");
  
  testStep("STEP", "Set breakpoint in function *DIA_runDidFD03_PCBAProgrammedPartNumberWrite*.");
  debugger_setRelativeFunctionBpAtLine("DIA_runDidFD03_PCBAProgrammedPartNumberWrite", 11);
  debugger_run();
 
  testCaseComment("ARCH_SW_DIA_0585; ARCH_SW_DIA_0589; ARCH_SW_DIA_0590; ARCH_SW_DIA_0591; ARCH_SW_DIA_0592; ARCH_SW_DIA_0593");
  testStep("STEP", "Send diag request for 2E FD03 and wait for timeout error --> Timeout reached.");
  SendDiagnosticRequest(dECUSerialNumberWriteRequest, dECUSerialNumberWriteResponse, TRUE);

  testWaitForTimeout(2000);
  testStep("STEP", "Check if breakpoint from function DIA_runDidFD03_PCBAProgrammedPartNumberWrite was reached. --> BP was reached.");
  debugger_waitUntilBPisReached(5000);
  debugger_isCPUStoppedAtFunction("DIA_runDidFD03_PCBAProgrammedPartNumberWrite");
  //====================================================
  testCaseComment("Postcondition");
  testStep("STEP", "Return ECU to default values");
  RunPostTs();

}

testcase SW_IT_DIA_DataServices_Reprogramming_Attempt_Counter_Read_Reprogramming_Attempts_ReadData ()
{
  //***********************************Test report header*********************************
  testReportAddMiscInfoBlock("AUTOLIV ELECTRONICS document");
 TestReportAddMiscInfo("Nightly test", "No");
 TestReportAddMiscInfo("Test type", "Requirement-Based test");
 TestReportAddMiscInfo("Regression Test", "No");
 TestReportAddMiscInfo("Fault injection method used", "No");
 TestReportAddMiscInfo("Resource usage evaluation", "No");
 TestReportAddMiscInfo("Priority", "No");
 TestReportAddMiscInfo("Safety relevant", "No");
 TestReportAddMiscInfo("Test type", "automatic");
  
  AddRequirementInfo("Requirement under test", "ARCH_SW_DIA_0595; ARCH_SW_DIA_0596; ARCH_SW_DIA_0597; ARCH_SW_DIA_0598");
  AddRequirementInfo("ARCH_SW_DIA_0595", "Service 0x22 (Read Data By Identifier) will be implemented for DID 0100 (Reprogramming Attempt Counter)");
  AddRequirementInfo("ARCH_SW_DIA_0596", "The Read Reprogramming Attempt Counter service shall be available in the following sessions: ?Default Session (0x01) ?Programming Session (0x02) ?Extended Session (0x03) ?Supplier Session/Development Session (0x7E) ");
  AddRequirementInfo("ARCH_SW_DIA_0597", "The Read Reprogramming Attempt Counter service shall be available under the following forms of Authentication: ?Supplier ?Development ENHANCED ?Production ?After-Sales ENHANCED ?After-Sales ?After-Sales BASIC ?Internal Diagnostic Test Tool ?ePTI Test Tool ");
  AddRequirementInfo("ARCH_SW_DIA_0598", "DataIdentifier of the Read Reprogramming Attempt Counter shall be: 0x0100");

  //***************************************************************************************
      
  testCaseComment("Preconditions");
  testStep("STEP", "Bench Initialization");
  RunPreTs();
  //====================================================
 
  testStep("STEP", "Set breakpoint in function *DataServices_Reprogramming_Attempt_Counter_Read_Reprogramming_Attempts_ReadData*.");
  debugger_setRelativeFunctionBpAtLine("DataServices_Reprogramming_Attempt_Counter_Read_Reprogramming_Attempts_ReadData", 0);
  debugger_run();
 
  testCaseComment("Action:ARCH_SW_DIA_0595; ARCH_SW_DIA_0596; ARCH_SW_DIA_0597; ARCH_SW_DIA_0598");
  testStep("STEP", "Send diag request for 22 0100 and wait for timeout error --> Timeout received.");
  SendDiagnosticRequest(dReprogrammingAttemptCounterReadRequest, dReprogrammingAttemptCounterReadResponse, TRUE);

  testWaitForTimeout(2000);
  testStep("STEP", "Check if breakpoint from function DataServices_Reprogramming_Attempt_Counter_Read_Reprogramming_Attempts_ReadData was reached. --> BP was reached.");
  debugger_waitUntilBPisReached(5000);
  debugger_isCPUStoppedAtFunction("DataServices_Reprogramming_Attempt_Counter_Read_Reprogramming_Attempts_ReadData");

  //====================================================
  testCaseComment("Postcondition");
  testStep("STEP", "Return ECU to default values");
  RunPostTs();

}

testcase SW_IT_DIA_DataServices_Reprogramming_Attempt_Counter_Read_Reprogramming_Attempts_ReadDataLength()
{
  //***********************************Test report header*********************************
  testReportAddMiscInfoBlock("AUTOLIV ELECTRONICS document");
 TestReportAddMiscInfo("Nightly test", "No");
 TestReportAddMiscInfo("Test type", "Requirement-Based test");
 TestReportAddMiscInfo("Regression Test", "No");
 TestReportAddMiscInfo("Fault injection method used", "No");
 TestReportAddMiscInfo("Resource usage evaluation", "No");
 TestReportAddMiscInfo("Priority", "No");
 TestReportAddMiscInfo("Safety relevant", "No");
 TestReportAddMiscInfo("Test type", "automatic");
  
  AddRequirementInfo("Requirement under test", "ARCH_SW_DIA_0595; ARCH_SW_DIA_0599; ARCH_SW_DIA_0600; ARCH_SW_DIA_0601; ARCH_SW_DIA_0602");
  AddRequirementInfo("ARCH_SW_DIA_0595", "Service 0x22 (Read Data By Identifier) will be implemented for DID 0100 (Reprogramming Attempt Counter)");
  AddRequirementInfo("ARCH_SW_DIA_0599", "Response data length shall be (4 bytes* number of logical blocks) long. Note: Full Response length = 3 bytes + Response data length");
  AddRequirementInfo("ARCH_SW_DIA_0600", "Byte #4 #5: ?Number Of Reprogramming Attempts default value: 0x0000 if ECU erased and Programmed by the ECU supplier.");
  AddRequirementInfo("ARCH_SW_DIA_0601", "Byte #6 #7: ?Max. Number Of Reprogramming Attempts");
  AddRequirementInfo("ARCH_SW_DIA_0602", "The reprogramming attempt counter shall be incremented by each reprogramming attempt.");

  //***************************************************************************************
   
  testCaseComment("Preconditions");
  testStep("STEP", "Bench Initialization");
  RunPreTs();
  //====================================================
 
  testStep("STEP", "Set breakpoint in function *DataServices_Reprogramming_Attempt_Counter_Read_Reprogramming_Attempts_ReadDataLength*.");
  debugger_setRelativeFunctionBpAtLine("DataServices_Reprogramming_Attempt_Counter_Read_Reprogramming_Attempts_ReadDataLength", 0);
  debugger_run();
 
  testCaseComment("Action:ARCH_SW_DIA_0595; ARCH_SW_DIA_0599; ARCH_SW_DIA_0600; ARCH_SW_DIA_0601; ARCH_SW_DIA_0602");
  testStep("STEP", "Send diag request for 22 0100 and wait for timeout error --> Timeout received.");
  SendDiagnosticRequest(dReprogrammingAttemptCounterReadRequest, dReprogrammingAttemptCounterReadResponse, TRUE);

  testWaitForTimeout(2000);
  testStep("STEP", "Check if breakpoint from function DataServices_Reprogramming_Attempt_Counter_Read_Reprogramming_Attempts_ReadDataLength was reached. --> BP was reached.");
  debugger_waitUntilBPisReached(5000);
  debugger_isCPUStoppedAtFunction("DataServices_Reprogramming_Attempt_Counter_Read_Reprogramming_Attempts_ReadDataLength");

  //====================================================
  testCaseComment("Postcondition");
  testStep("STEP", "Return ECU to default values");
  RunPostTs();


}

testcase SW_IT_DIA_DataServices_Vehicle_Odometer_in_Low_Resolution_Read_Vehicle_Odometer_in_Low_Resolution_ReadData()
{
  //***********************************Test report header*********************************
  testReportAddMiscInfoBlock("AUTOLIV ELECTRONICS document");
 TestReportAddMiscInfo("Nightly test", "No");
 TestReportAddMiscInfo("Test type", "Requirement-Based test");
 TestReportAddMiscInfo("Regression Test", "No");
 TestReportAddMiscInfo("Fault injection method used", "No");
 TestReportAddMiscInfo("Resource usage evaluation", "No");
 TestReportAddMiscInfo("Priority", "No");
 TestReportAddMiscInfo("Safety relevant", "No");
 TestReportAddMiscInfo("Test type", "automatic");
  
  AddRequirementInfo("Requirement under test", "ARCH_SW_DIA_0605; ARCH_SW_DIA_0606; ARCH_SW_DIA_0607; ARCH_SW_DIA_0608; ARCH_SW_DIA_0609; ARCH_SW_DIA_0610; ARCH_SW_DIA_0611");
  AddRequirementInfo("ARCH_SW_DIA_0605", "Service 0x22 (Read Data By Identifier) will be implemented for DID 010A (Vehicle Odometer in Low Resolution)");
  AddRequirementInfo("ARCH_SW_DIA_0606", "The Read Vehicle Odometer in Low Resolution service shall be available in the following sessions: ?Default Session (0x01) ?Extended Session (0x03) ?Supplier Session/Development Session (0x7E) ");
  AddRequirementInfo("ARCH_SW_DIA_0607", "The Read Vehicle Odometer in Low Resolution service shall be available under the following forms of Authentication: ?Supplier ?Development ENHANCED ?Production ?After-Sales ENHANCED ?After-Sales ?After-Sales BASIC ?Internal Diagnostic Test Tool ?ePTI Test Tool ");
  AddRequirementInfo("ARCH_SW_DIA_0608", "DataIdentifier of the Read Vehicle Odometer in Low Resolution shall be: 0x010A");
  AddRequirementInfo("ARCH_SW_DIA_0609", "Response data length shall be 2 bytes long. Note: Full Response length = 3 bytes + Response data length ");
  AddRequirementInfo("ARCH_SW_DIA_0610", "Bytes #2-#3:  DataIdentifier of the Read Vehicle Odometer in Low Resolution shall be: 0x010A.");
  AddRequirementInfo("ARCH_SW_DIA_0611", "Byte #4 #5: ?Vehicle Odometer In Low Resolution Offset is 0 (i.e. 0x00 = 0 km) Resolution is 16 (e.g. 0x10 = 16 km) Range is 0 km -> 1048544 km.");

  //***************************************************************************************
  
  testCaseComment("Preconditions");
  testStep("STEP", "Bench Initialization");
  RunPreTs();
  //====================================================
  
  testStep("STEP", "Set breakpoint in function *DataServices_Vehicle_Odometer_in_Low_Resolution_Read_Vehicle_Odometer_in_Low_Resolution_ReadData*.");
  debugger_setRelativeFunctionBpAtLine("DataServices_Vehicle_Odometer_in_Low_Resolution_Read_Vehicle_Odometer_in_Low_Resolution_ReadData", 20);
  debugger_run();
 
  testCaseComment("Action: ARCH_SW_DIA_0605; ARCH_SW_DIA_0606; ARCH_SW_DIA_0607; ARCH_SW_DIA_0608; ARCH_SW_DIA_0609; ARCH_SW_DIA_0610; ARCH_SW_DIA_0611");
  testStep("STEP", "Send diag request for 22 010A and wait for timeout error --> Timeout received.");
  SendDiagnosticRequest(dVehicleOdometerinLowResolutionReadRequest, dVehicleOdometerinLowResolutionReadResponse, TRUE);

  testWaitForTimeout(2000);
  testStep("STEP", "Check if breakpoint from function DataServices_Vehicle_Odometer_in_Low_Resolution_Read_Vehicle_Odometer_in_Low_Resolution_ReadData was reached. --> BP was reached.");
  debugger_waitUntilBPisReached(5000);
  debugger_isCPUStoppedAtFunction("DataServices_Vehicle_Odometer_in_Low_Resolution_Read_Vehicle_Odometer_in_Low_Resolution_ReadData");
  
  testStep("STEP", "Evaluate *Data pointer --> Byte was read.");
  pi64Data = debugger_readLocalVariable("*Data");
  EvalManStepEqual("Data pointer read", pi64Data);
  
  //====================================================
  testCaseComment("Postcondition");
  testStep("STEP", "Return ECU to default values");
  RunPostTs();


}

testcase SW_IT_DIA_DataServices_Adjust_ISO_15765_2_Block_Size_and_STmin_Parameter_Read_Block_Size_Value_ReadData()
{
  //***********************************Test report header*********************************
  testReportAddMiscInfoBlock("AUTOLIV ELECTRONICS document");
 TestReportAddMiscInfo("Nightly test", "No");
 TestReportAddMiscInfo("Test type", "Requirement-Based test");
 TestReportAddMiscInfo("Regression Test", "No");
 TestReportAddMiscInfo("Fault injection method used", "No");
 TestReportAddMiscInfo("Resource usage evaluation", "No");
 TestReportAddMiscInfo("Priority", "No");
 TestReportAddMiscInfo("Safety relevant", "No");
 TestReportAddMiscInfo("Test type", "automatic");
  
  AddRequirementInfo("Requirement under test", "ARCH_SW_DIA_0615; ARCH_SW_DIA_0616; ARCH_SW_DIA_0617; ARCH_SW_DIA_0618; ARCH_SW_DIA_0619");
  AddRequirementInfo("ARCH_SW_DIA_0615", "Service 0x22 (Read Data By Identifier) will be implemented for DID 010B (Adjust ISO 15765-2 Block Size and STmin Parameter)");
  AddRequirementInfo("ARCH_SW_DIA_0616", "Description: Service Read Adjust ISO 15765-2 Block Size and STmin Parameter shall report the ISO 15762-2 Transport Protocol parameters such as BlockSize (BS) and minimum Separation Time which are transmitted within the FlowControl message.");
  AddRequirementInfo("ARCH_SW_DIA_0617", "The Read Adjust ISO 15765-2 Block Size and STmin Parameter service shall be available in the following sessions: ?Default Session (0x01) ?Programming (0x02) ?Extended Session (0x03) ?Supplier Session/Development Session (0x7E) ");
  AddRequirementInfo("ARCH_SW_DIA_0618", "The Read Adjust ISO 15765-2 Block Size and STmin Parameter service shall be available under the following forms of Authentication: ?Supplier ?Development ENHANCED ?Production ?After-Sales ENHANCED ?After-Sales ?After-Sales BASIC ?Internal Diagnostic Test Tool ?ePTI Test Tool ");
  AddRequirementInfo("ARCH_SW_DIA_0619", "DataIdentifier of the Read Adjust ISO 15765-2 Block Size and STmin Parameter shall be: 0x010B.");

  //***************************************************************************************
  testCaseComment("Preconditions");
  testStep("STEP", "Bench Initialization");
  RunPreTs();
  //====================================================
  
  testStep("STEP", "Set breakpoint in function *DataServices_Adjust_ISO_15765_2_Block_Size_and_STmin_Parameter_Read_Block_Size_Value_ReadData*.");
  debugger_setRelativeFunctionBpAtLine("DataServices_Adjust_ISO_15765_2_Block_Size_and_STmin_Parameter_Read_Block_Size_Value_ReadData", 2);
  debugger_run();
 
  testCaseComment("Action: ARCH_SW_DIA_0615; ARCH_SW_DIA_0616; ARCH_SW_DIA_0617; ARCH_SW_DIA_0618; ARCH_SW_DIA_0619");
  testStep("STEP", "Send diag request for 22 010B and wait for timeout error --> Timeout received.");
  SendDiagnosticRequest(dAdjustISO157652BlockSizeandSTminParameterReadRequest, dAdjustISO157652BlockSizeandSTminParameterReadResponse, TRUE);

  testWaitForTimeout(2000);
  testStep("STEP", "Check if breakpoint from function DataServices_Adjust_ISO_15765_2_Block_Size_and_STmin_Parameter_Read_Block_Size_Value_ReadData was reached. --> BP was reached.");
  debugger_waitUntilBPisReached(5000);
  debugger_isCPUStoppedAtFunction("DataServices_Adjust_ISO_15765_2_Block_Size_and_STmin_Parameter_Read_Block_Size_Value_ReadData");
  
  testStep("STEP", "Evaluate *Data pointer --> Byte was read.");
  pi64Data = debugger_readLocalVariable("*Data");
  EvalManStepEqual("Data pointer read", pi64Data);
  
  //====================================================
  testCaseComment("Postcondition");
  testStep("STEP", "Return ECU to default values");
  RunPostTs();


}

testcase SW_IT_DIA_DataServices_Adjust_ISO_15765_2_Block_Size_and_STmin_Parameter_Read_STmin_Value_ReadData()
{
  //***********************************Test report header*********************************
  testReportAddMiscInfoBlock("AUTOLIV ELECTRONICS document");
 TestReportAddMiscInfo("Nightly test", "No");
 TestReportAddMiscInfo("Test type", "Requirement-Based test");
 TestReportAddMiscInfo("Regression Test", "No");
 TestReportAddMiscInfo("Fault injection method used", "No");
 TestReportAddMiscInfo("Resource usage evaluation", "No");
 TestReportAddMiscInfo("Priority", "No");
 TestReportAddMiscInfo("Safety relevant", "No");
 TestReportAddMiscInfo("Test type", "automatic");
  
  AddRequirementInfo("Requirement under test", "ARCH_SW_DIA_0615; ARCH_SW_DIA_0620; ARCH_SW_DIA_0621;");
  AddRequirementInfo("ARCH_SW_DIA_0615", "Service 0x22 (Read Data By Identifier) will be implemented for DID 010B (Adjust ISO 15765-2 Block Size and STmin Parameter)");
  AddRequirementInfo("ARCH_SW_DIA_0620", "Response data length shall be 2 bytes long Note: Full Response length = 3 bytes + Response data length ");
  AddRequirementInfo("ARCH_SW_DIA_0621", "Bytes #4 #5: ?Block Size Value as defined in ISO 15765-2 ?STmin Value as defined in ISO 15765-2 ");

  //***************************************************************************************
  
  testCaseComment("Preconditions");
  testStep("STEP", "Bench Initialization");
  RunPreTs();
  //====================================================
  
  testCaseComment("Action: ARCH_SW_DIA_0615; ARCH_SW_DIA_0620; ARCH_SW_DIA_0621;");
  testStep("STEP", "Send diag request for 22 010B --> Timeout received.");
  SendDiagnosticRequest(dAdjustISO157652BlockSizeandSTminParameterReadRequest, dAdjustISO157652BlockSizeandSTminParameterReadResponse);
  CheckPositiveResponse(dAdjustISO157652BlockSizeandSTminParameterReadRequest, dAdjustISO157652BlockSizeandSTminParameterReadResponse);
  
  //====================================================
  testCaseComment("Postcondition");
  testStep("STEP", "Return ECU to default values");
  RunPostTs();


}


testcase SW_IT_DIA_DataServices_Adjust_ISO_15765_2_Block_Size_and_STmin_Parameter_Read_Block_Size_Value_WriteData()
{
  //***********************************Test report header*********************************
  testReportAddMiscInfoBlock("AUTOLIV ELECTRONICS document");
 TestReportAddMiscInfo("Nightly test", "No");
 TestReportAddMiscInfo("Test type", "Requirement-Based test");
 TestReportAddMiscInfo("Regression Test", "No");
 TestReportAddMiscInfo("Fault injection method used", "No");
 TestReportAddMiscInfo("Resource usage evaluation", "No");
 TestReportAddMiscInfo("Priority", "No");
 TestReportAddMiscInfo("Safety relevant", "No");
 TestReportAddMiscInfo("Test type", "automatic");
  
  AddRequirementInfo("Requirement under test", "ARCH_SW_DIA_0625; ARCH_SW_DIA_0626; ARCH_SW_DIA_0627; ARCH_SW_DIA_0628");
  AddRequirementInfo("ARCH_SW_DIA_0625", "Service 0x2E (Write Data By Identifier) will be implemented for DID 010B (Adjust ISO 15765-2 Block Size and STmin Parameter)");
  AddRequirementInfo("ARCH_SW_DIA_0626", "The Write Adjust ISO 15765-2 Block Size and STmin Parameter service shall be available in the following sessions: ?Extended Session (0x03) ?Supplier Session/Development Session (0x7E) ");
  AddRequirementInfo("ARCH_SW_DIA_0627", "The Write Adjust ISO 15765-2 Block Size and STmin Parameter service shall be available under the following forms of Authentication: ?Supplier ?Development ENHANCED ?Production ?After-Sales ENHANCED ?After-Sales ?After-Sales BASIC ?Internal Diagnostic Test Tool ?ePTI Test Tool ");
  AddRequirementInfo("ARCH_SW_DIA_0628", "Bytes #2-#3: DataIdentifier of the Write Adjust ISO 15765-2 Block Size and STmin Parameter shall be: 0x010B");

  //***************************************************************************************
  testCaseComment("Preconditions");
  testStep("STEP", "Bench Initialization");
  RunPreTs();
  //====================================================
  
  testStep("STEP", "Enter development session.");
  EnterDiagnosticSession("development");
  
  testStep("STEP", "Set breakpoint in function *DataServices_Adjust_ISO_15765_2_Block_Size_and_STmin_Parameter_Read_Block_Size_Value_WriteData*.");
  debugger_setRelativeFunctionBpAtLine("DataServices_Adjust_ISO_15765_2_Block_Size_and_STmin_Parameter_Read_Block_Size_Value_WriteData", 10);
  debugger_run();
 
  testCaseComment("ARCH_SW_DIA_0625; ARCH_SW_DIA_0626; ARCH_SW_DIA_0627; ARCH_SW_DIA_0628");
  testStep("STEP", "Send diag request for 2E 010B and wait for timeout error --> Timeout reached.");
  SendDiagnosticRequest(dAdjustISO157652BlockSizeandSTminParameterWriteRequest, dAdjustISO157652BlockSizeandSTminParameterWriteResponse, TRUE);

  testWaitForTimeout(2000);
  testStep("STEP", "Check if breakpoint from function DataServices_Adjust_ISO_15765_2_Block_Size_and_STmin_Parameter_Read_Block_Size_Value_WriteData was reached. --> BP was reached.");
  debugger_waitUntilBPisReached(5000);
  debugger_isCPUStoppedAtFunction("DataServices_Adjust_ISO_15765_2_Block_Size_and_STmin_Parameter_Read_Block_Size_Value_WriteData");
  //====================================================
  testCaseComment("Postcondition");
  testStep("STEP", "Return ECU to default values");
  RunPostTs();

}

testcase SW_IT_DIA_DataServices_Adjust_ISO_15765_2_Block_Size_and_STmin_Parameter_Read_STmin_Value_WriteData ()
{
  //***********************************Test report header*********************************
  testReportAddMiscInfoBlock("AUTOLIV ELECTRONICS document");
 TestReportAddMiscInfo("Nightly test", "No");
 TestReportAddMiscInfo("Test type", "Requirement-Based test");
 TestReportAddMiscInfo("Regression Test", "No");
 TestReportAddMiscInfo("Fault injection method used", "No");
 TestReportAddMiscInfo("Resource usage evaluation", "No");
 TestReportAddMiscInfo("Priority", "No");
 TestReportAddMiscInfo("Safety relevant", "No");
 TestReportAddMiscInfo("Test type", "automatic");
  
  AddRequirementInfo("Requirement under test", "ARCH_SW_DIA_0625; ARCH_SW_DIA_0629; ARCH_SW_DIA_0630; ARCH_SW_DIA_0631");
  AddRequirementInfo("ARCH_SW_DIA_0625", "Service 0x2E (Write Data By Identifier) will be implemented for DID 010B (Adjust ISO 15765-2 Block Size and STmin Parameter)");
  AddRequirementInfo("ARCH_SW_DIA_0629", "Request data length shall be 2 bytes long Note: Full Request length = 3 bytes + Request data length ");
  AddRequirementInfo("ARCH_SW_DIA_0630", "Byte #4: ?bits 0-7: Block Size Value as defined in ISO 15765-2 ");
  AddRequirementInfo("ARCH_SW_DIA_0631", "Byte #5: ?bits 0-7: STmin Value as defined in ISO 15765-2.");

  //***************************************************************************************
  
  testCaseComment("Preconditions");
  testStep("STEP", "Bench Initialization");
  RunPreTs();
  //====================================================
  
  testStep("STEP", "Enter development session.");
  EnterDiagnosticSession("development");
  
  testStep("STEP", "Set breakpoint in function *DataServices_Adjust_ISO_15765_2_Block_Size_and_STmin_Parameter_Read_Block_Size_Value_WriteData*.");
  debugger_setRelativeFunctionBpAtLine("DataServices_Adjust_ISO_15765_2_Block_Size_and_STmin_Parameter_Read_Block_Size_Value_WriteData", 10);
  debugger_run();
 
  testCaseComment("ARCH_SW_DIA_0625; ARCH_SW_DIA_0629; ARCH_SW_DIA_0630; ARCH_SW_DIA_0631");
  testStep("STEP", "Send diag request for 2E 010B and wait for timeout error --> Timeout reached.");
  SendDiagnosticRequest(dAdjustISO157652BlockSizeandSTminParameterWriteRequest, dAdjustISO157652BlockSizeandSTminParameterWriteResponse, TRUE);

  testWaitForTimeout(2000);
  testStep("STEP", "Check if breakpoint from function DataServices_Adjust_ISO_15765_2_Block_Size_and_STmin_Parameter_Read_Block_Size_Value_WriteData was reached. --> BP was reached.");
  debugger_waitUntilBPisReached(5000);
  debugger_isCPUStoppedAtFunction("DataServices_Adjust_ISO_15765_2_Block_Size_and_STmin_Parameter_Read_Block_Size_Value_WriteData");
  //====================================================
  testCaseComment("Postcondition");
  testStep("STEP", "Return ECU to default values");
  RunPostTs();


}

testcase SW_IT_DIA_DataServices_Task_Response_Time_Read_Task_histograms_ReadData()
{
  //***********************************Test report header*********************************
  testReportAddMiscInfoBlock("AUTOLIV ELECTRONICS document");
 TestReportAddMiscInfo("Nightly test", "No");
 TestReportAddMiscInfo("Test type", "Requirement-Based test");
 TestReportAddMiscInfo("Regression Test", "No");
 TestReportAddMiscInfo("Fault injection method used", "No");
 TestReportAddMiscInfo("Resource usage evaluation", "No");
 TestReportAddMiscInfo("Priority", "No");
 TestReportAddMiscInfo("Safety relevant", "No");
 TestReportAddMiscInfo("Test type", "automatic");
  
  AddRequirementInfo("Requirement under test", "ARCH_SW_DIA_0635; ARCH_SW_DIA_0636; ARCH_SW_DIA_0637; ARCH_SW_DIA_0638");
  AddRequirementInfo("ARCH_SW_DIA_0635", "Service 0x22 (Read Data By Identifier) will be implemented for DID 01E0 (Task Response Time)");
  AddRequirementInfo("ARCH_SW_DIA_0636", "The Read Task Response Time service shall be available in the following sessions: ?Default Session (0x01) ?Extended Session (0x03) ?Supplier Session/Development Session (0x7E) ");
  AddRequirementInfo("ARCH_SW_DIA_0637", "The Read Task Response Time service shall be available under the following forms of Authentication: ?Supplier ?Development ENHANCED ?Internal Diagnostic Test Tool ");
  AddRequirementInfo("ARCH_SW_DIA_0638", "DataIdentifier of the Read Task Response Time shall be: 0x01E0");

  //***************************************************************************************
  
  testCaseComment("Preconditions");
  testStep("STEP", "Bench Initialization");
  RunPreTs();
  //====================================================
  
  testStep("STEP", "Set breakpoint in function *DataServices_Task_Response_Time_Read_Task_histograms_ReadData*.");
  debugger_setRelativeFunctionBpAtLine("DataServices_Task_Response_Time_Read_Task_histograms_ReadData", 20);
  debugger_run();
 
  testCaseComment("Action: ARCH_SW_DIA_0635; ARCH_SW_DIA_0636; ARCH_SW_DIA_0637; ARCH_SW_DIA_0638");
  testStep("STEP", "Send diag request for 22 01E0 and wait for timeout error --> Timeout received.");
  SendDiagnosticRequest(dTaskResponseTimeReadRequest, dTaskResponseTimeReadResponse, TRUE);

  testWaitForTimeout(2000);
  testStep("STEP", "Check if breakpoint from function DataServices_Task_Response_Time_Read_Task_histograms_ReadData was reached. --> BP was reached.");
  debugger_waitUntilBPisReached(5000);
  debugger_isCPUStoppedAtFunction("DataServices_Task_Response_Time_Read_Task_histograms_ReadData");
  
  testStep("STEP", "Evaluate *Data pointer --> Byte was read.");
  pi64Data = debugger_readLocalVariable("*Data");
  EvalManStepEqual("Data pointer read", pi64Data);
  
  //====================================================
  testCaseComment("Postcondition");
  testStep("STEP", "Return ECU to default values");
  RunPostTs();


}


testcase SW_IT_DIA_DataServices_Task_Response_Time_Read_Task_histograms_ReadDataLength()
{
  //***********************************Test report header*********************************
  testReportAddMiscInfoBlock("AUTOLIV ELECTRONICS document");
 TestReportAddMiscInfo("Nightly test", "No");
 TestReportAddMiscInfo("Test type", "Requirement-Based test");
 TestReportAddMiscInfo("Regression Test", "No");
 TestReportAddMiscInfo("Fault injection method used", "No");
 TestReportAddMiscInfo("Resource usage evaluation", "No");
 TestReportAddMiscInfo("Priority", "No");
 TestReportAddMiscInfo("Safety relevant", "No");
 TestReportAddMiscInfo("Test type", "automatic");
  
  AddRequirementInfo("Requirement under test", "ARCH_SW_DIA_0635; ARCH_SW_DIA_0639; ARCH_SW_DIA_0640");
  AddRequirementInfo("ARCH_SW_DIA_0635", "Service 0x22 (Read Data By Identifier) will be implemented for DID 01E0 (Task Response Time)");
  AddRequirementInfo("ARCH_SW_DIA_0639", "Response data length shall be 16 bytes for each task. Note: Full Response length = 3 bytes + Response data length Note: For each task there will be 16 bytes on response meaning that the total length for each task is 16 bytes x 11 tasks = 176 bytes ");
  AddRequirementInfo("ARCH_SW_DIA_0640", "Bytes #4 - #15 = Task Histogram [16 bytes]: ?[Byte0] Task ID ?[Byte1] 0-19%, PercentUpdate ?[Byte2] 20-39%, PercentUpdate ?[Byte3] 40-59%, PercentUpdate ?[Byte4] 60-79%, PercentUpdate ?[Byte5] 80-99%, PercentUpdate ?[Byte6] 100-119%, PercentUpdate ?[Byte7] 120-139%, PercentUpdate ?[Byte8] 140-159%, PercentUpdate ?[Byte9] 160-179%, PercentUpdate ?[Byte10] 180-199%, PercentUpdate ?[Byte11] >=200%, PercentUpdate ?[Byte12-Byte15] Max us, Microseconds ");

  //***************************************************************************************
  testCaseComment("Preconditions");
  testStep("STEP", "Bench Initialization");
  RunPreTs();
  //====================================================
  
  testStep("STEP", "Set breakpoint in function *DataServices_Task_Response_Time_Read_Task_histograms_ReadDataLength*.");
  debugger_setRelativeFunctionBpAtLine("DataServices_Task_Response_Time_Read_Task_histograms_ReadDataLength", 0);
  debugger_run();
 
  testCaseComment("Action: ARCH_SW_DIA_0635; ARCH_SW_DIA_0639; ARCH_SW_DIA_0640");
  testStep("STEP", "Send diag request for 22 01E0 and wait for timeout error --> Timeout received.");
  SendDiagnosticRequest(dTaskResponseTimeReadRequest, dTaskResponseTimeReadResponse, TRUE);

  testWaitForTimeout(2000);
  testStep("STEP", "Check if breakpoint from function DataServices_Task_Response_Time_Read_Task_histograms_ReadDataLength was reached. --> BP was reached.");
  debugger_waitUntilBPisReached(5000);
  debugger_isCPUStoppedAtFunction("DataServices_Task_Response_Time_Read_Task_histograms_ReadDataLength");
  
  //====================================================
  testCaseComment("Postcondition");
  testStep("STEP", "Return ECU to default values");
  RunPostTs();
  
}


testcase SW_IT_DIA_DataServices_System_Time_read_Read_System_time_ReadData()
{
  //***********************************Test report header*********************************
  testReportAddMiscInfoBlock("AUTOLIV ELECTRONICS document");
 TestReportAddMiscInfo("Nightly test", "No");
 TestReportAddMiscInfo("Test type", "Requirement-Based test");
 TestReportAddMiscInfo("Regression Test", "No");
 TestReportAddMiscInfo("Fault injection method used", "No");
 TestReportAddMiscInfo("Resource usage evaluation", "No");
 TestReportAddMiscInfo("Priority", "No");
 TestReportAddMiscInfo("Safety relevant", "No");
 TestReportAddMiscInfo("Test type", "automatic");
  
  AddRequirementInfo("Requirement under test", "ARCH_SW_DIA_0645; ARCH_SW_DIA_0646; ARCH_SW_DIA_0647; ARCH_SW_DIA_0648; ARCH_SW_DIA_0649; ARCH_SW_DIA_0650");
  AddRequirementInfo("ARCH_SW_DIA_0645", "Service 0x22 (Read Data By Identifier) will be implemented for DID 02EA (System Time)");
  AddRequirementInfo("ARCH_SW_DIA_0646", "The Read System Time service shall be available in the following sessions: ?Default Session (0x01) ?Extended Session (0x03) ?Supplier Session/Development Session (0x7E) ");
  AddRequirementInfo("ARCH_SW_DIA_0647", "The Read System Time service shall be available under the following forms of Authentication: ?Supplier ?Development ENHANCED ?Production ?After-Sales ENHANCED ?After-Sales ?After-Sales BASIC ?Internal Diagnostic Test Tool ?ePTI Test Tool ");
  AddRequirementInfo("ARCH_SW_DIA_0648", "DataIdentifier of the Read System Time shall be: 0x02EA");
  AddRequirementInfo("ARCH_SW_DIA_0649", "Response data length shall be 4 bytes long Note: Full Response length = 3 bytes + Response data length)");
  AddRequirementInfo("ARCH_SW_DIA_0650", "Bytes #4 to #7 ? bits 0-7: System Time [BCD coded] ");

  //***************************************************************************************
    
  testCaseComment("Preconditions");
  testStep("STEP", "Bench Initialization");
  RunPreTs();
  //====================================================
  
  testStep("STEP", "Set breakpoint in function *DataServices_System_Time_read_Read_System_time_ReadData*.");
  debugger_setRelativeFunctionBpAtLine("DataServices_System_Time_read_Read_System_time_ReadData", 19);
  debugger_run();
 
  testCaseComment("Action: ARCH_SW_DIA_0645; ARCH_SW_DIA_0646; ARCH_SW_DIA_0647; ARCH_SW_DIA_0648; ARCH_SW_DIA_0649; ARCH_SW_DIA_0650");
  testStep("STEP", "Send diag request for 22 01E0 and wait for timeout error --> Timeout received.");
  SendDiagnosticRequest(dSystemTimeReadRequest, dSystemTimeReadResponse, TRUE);

  testWaitForTimeout(2000);
  testStep("STEP", "Check if breakpoint from function DataServices_System_Time_read_Read_System_time_ReadData was reached. --> BP was reached.");
  debugger_waitUntilBPisReached(5000);
  debugger_isCPUStoppedAtFunction("DataServices_System_Time_read_Read_System_time_ReadData");
  
  testStep("STEP", "Evaluate *Data pointer --> Byte was read.");
  pi64Data = debugger_readLocalVariable("*Data");
  EvalManStepEqual("Data pointer read", pi64Data);
  
  //====================================================
  testCaseComment("Postcondition");
  testStep("STEP", "Return ECU to default values");
  RunPostTs();


}

testcase SW_IT_DIA_DataServices_Reprogramming_capabilities_Read_Reprogramming_Capabilities_ReadData()
{
  //***********************************Test report header*********************************
  testReportAddMiscInfoBlock("AUTOLIV ELECTRONICS document");
 TestReportAddMiscInfo("Nightly test", "No");
 TestReportAddMiscInfo("Test type", "Requirement-Based test");
 TestReportAddMiscInfo("Regression Test", "No");
 TestReportAddMiscInfo("Fault injection method used", "No");
 TestReportAddMiscInfo("Resource usage evaluation", "No");
 TestReportAddMiscInfo("Priority", "No");
 TestReportAddMiscInfo("Safety relevant", "No");
 TestReportAddMiscInfo("Test type", "automatic");
  
  AddRequirementInfo("Requirement under test", "ARCH_SW_DIA_0715; ARCH_SW_DIA_0719; ARCH_SW_DIA_0720");
  AddRequirementInfo("ARCH_SW_DIA_0715", "Service 0x22 (Read Data By Identifier) will be implemented for DID F130 (Reprogramming Capabilities)");
  AddRequirementInfo("ARCH_SW_DIA_0719", "Bytes #2-#3:  DataIdentifier of the Read Reprograming Capabilities shall be: 0xF130");
  AddRequirementInfo("ARCH_SW_DIA_0720", "Byte #4: ?bits 0-7: Security Class Default Value = 0x03 (CCCv2) Byte #5: ?bits 0-7: Delta Update Support Byte #6-#35: ?bits 0-7: Delta Algorithm Byte #36: ?bits 0-7: OFR ");

  //***************************************************************************************
   
  testCaseComment("Preconditions");
  testStep("STEP", "Bench Initialization");
  RunPreTs();
  //====================================================
  
  testCaseComment("Action: ARCH_SW_DIA_0715; ARCH_SW_DIA_0719; ARCH_SW_DIA_0720");
  testStep("STEP", "Send diag request for 22 F130");
  SendDiagnosticRequest(dReprogrammingAttemptCounterReadRequest, dReprogrammingAttemptCounterReadResponse);
  CheckPositiveResponse("", dReprogrammingAttemptCounterReadRequest, dReprogrammingAttemptCounterReadResponse); 

  //====================================================
  testCaseComment("Postcondition");
  testStep("STEP", "Return ECU to default values");
  RunPostTs();

}


testcase SW_IT_DIA_DataServices_Supported_configuration_mechanisms_Read_Config_mechanisms_ReadData()
{
  //***********************************Test report header*********************************
  testReportAddMiscInfoBlock("AUTOLIV ELECTRONICS document");
 TestReportAddMiscInfo("Nightly test", "No");
 TestReportAddMiscInfo("Test type", "Requirement-Based test");
 TestReportAddMiscInfo("Regression Test", "No");
 TestReportAddMiscInfo("Fault injection method used", "No");
 TestReportAddMiscInfo("Resource usage evaluation", "No");
 TestReportAddMiscInfo("Priority", "No");
 TestReportAddMiscInfo("Safety relevant", "No");
 TestReportAddMiscInfo("Test type", "automatic");
  
  AddRequirementInfo("Requirement under test", "ARCH_SW_DIA_0725; ARCH_SW_DIA_0726; ARCH_SW_DIA_0727; ARCH_SW_DIA_0728; ARCH_SW_DIA_0729; ARCH_SW_DIA_0730");
  AddRequirementInfo("ARCH_SW_DIA_0725", "Service 0x22 (Read Data By Identifier) will be implemented for DID F131 (Supported Configuration Mechanisms)");
  AddRequirementInfo("ARCH_SW_DIA_0726", "Bytes #2-#3:  DataIdentifier of the Read Reprograming Capabilities shall be: 0xF130");
  AddRequirementInfo("ARCH_SW_DIA_0727", "The Read Supported Configuration Mechanisms service shall be available under the following forms of Authentication: ?Supplier ?Development ENHANCED ?Production ?After-Sales ENHANCED ?After-Sales ?After-Sales BASIC ?Internal Diagnostic Test Tool ?ePTI Test Tool ");
  AddRequirementInfo("ARCH_SW_DIA_0728", "DataIdentifier of the Read Supported Configuration Mechanisms shall be: 0xF131");
  AddRequirementInfo("ARCH_SW_DIA_0729", "Response data length shall be 1 byte long Note: Full Response length = 3 bytes + Response data length ");
  AddRequirementInfo("ARCH_SW_DIA_0730", "Byte #4: ?bits 0-7: Configuration Mechanisms");
  
  //***************************************************************************************
  testCaseComment("Preconditions");
  testStep("STEP", "Bench Initialization");
  RunPreTs();
  //====================================================
  
  testStep("STEP", "Set breakpoint in function *DataServices_Supported_configuration_mechanisms_Read_Config_mechanisms_ReadData*.");
  debugger_setRelativeFunctionBpAtLine("DataServices_Supported_configuration_mechanisms_Read_Config_mechanisms_ReadData", 4);
  debugger_run();
 
  testCaseComment("Action: ARCH_SW_DIA_0725; ARCH_SW_DIA_0726; ARCH_SW_DIA_0727; ARCH_SW_DIA_0728; ARCH_SW_DIA_0729; ARCH_SW_DIA_0730");
  testStep("STEP", "Send diag request for 22 F131 and wait for timeout error --> Timeout received.");
  SendDiagnosticRequest(dSupportedConfigurationMechanismsReadRequest, dSupportedConfigurationMechanismsReadResponse, TRUE);

  testWaitForTimeout(2000);
  testStep("STEP", "Check if breakpoint from function DataServices_Supported_configuration_mechanisms_Read_Config_mechanisms_ReadData was reached. --> BP was reached.");
  debugger_waitUntilBPisReached(5000);
  debugger_isCPUStoppedAtFunction("DataServices_Supported_configuration_mechanisms_Read_Config_mechanisms_ReadData");
  
  testStep("STEP", "Evaluate *Data pointer --> Byte was read.");
  pi64Data = debugger_readLocalVariable("*Data");
  EvalManStepEqual("Data pointer read", pi64Data);
  
  //====================================================
  testCaseComment("Postcondition");
  testStep("STEP", "Return ECU to default values");
  RunPostTs();

}


testcase SW_IT_DIA_DataServices_ReadFingerprint_Read_Software_Fingerprint_s_ReadData()
{
  //***********************************Test report header*********************************
  testReportAddMiscInfoBlock("AUTOLIV ELECTRONICS document");
 TestReportAddMiscInfo("Nightly test", "No");
 TestReportAddMiscInfo("Test type", "Requirement-Based test");
 TestReportAddMiscInfo("Regression Test", "No");
 TestReportAddMiscInfo("Fault injection method used", "No");
 TestReportAddMiscInfo("Resource usage evaluation", "No");
 TestReportAddMiscInfo("Priority", "No");
 TestReportAddMiscInfo("Safety relevant", "No");
 TestReportAddMiscInfo("Test type", "automatic");
  
  AddRequirementInfo("Requirement under test", "ARCH_SW_DIA_0735; ARCH_SW_DIA_0736; ARCH_SW_DIA_0737; ARCH_SW_DIA_0738");
  AddRequirementInfo("ARCH_SW_DIA_0735", "Service 0x22 (Read Data By Identifier) will be implemented for DID F15B (Software Fingerprint)");
  AddRequirementInfo("ARCH_SW_DIA_0736", "The Read Software Fingerprint shall be available in the following sessions: ?Default Session (0x01) ?Programming Session (0x02) ?Extended Session (0x03) ?Supplier Session/Development Session (0x7E) ");
  AddRequirementInfo("ARCH_SW_DIA_0737", "The Read Software Fingerprint service shall be available under the following forms of Authentication: ?Supplier ?Development ENHANCED ?Production ?After-Sales ENHANCED ?After-Sales ?After-Sales BASIC ?Internal Diagnostic Test Tool ?ePTI Test Tool ");
  AddRequirementInfo("ARCH_SW_DIA_0738", "DataIdentifier of the Read Software Fingerprint shall be: 0xF15B");
  
  //***************************************************************************************
  
    testCaseComment("Preconditions");
  testStep("STEP", "Bench Initialization");
  RunPreTs();
  //====================================================
  
  testStep("STEP", "Set breakpoint in function *DataServices_ReadFingerprint_Read_Software_Fingerprint_s_ReadData*.");
  debugger_setRelativeFunctionBpAtLine("DataServices_ReadFingerprint_Read_Software_Fingerprint_s_ReadData", 56);
  debugger_run();
 
  testCaseComment("Action: ARCH_SW_DIA_0735; ARCH_SW_DIA_0736; ARCH_SW_DIA_0737; ARCH_SW_DIA_0738");
  testStep("STEP", "Send diag request for 22 F15B and wait for timeout error --> Timeout received.");
  SendDiagnosticRequest(dReadFingerprintReadRequest, dReadFingerprintReadResponse, TRUE);

  testWaitForTimeout(2000);
  testStep("STEP", "Check if breakpoint from function DataServices_ReadFingerprint_Read_Software_Fingerprint_s_ReadData was reached. --> BP was reached.");
  debugger_waitUntilBPisReached(5000);
  debugger_isCPUStoppedAtFunction("DataServices_ReadFingerprint_Read_Software_Fingerprint_s_ReadData");
  
  testStep("STEP", "Evaluate *Data pointer --> Byte was read.");
  pi64Data = debugger_readLocalVariable("*Data");
  EvalManStepEqual("Data pointer read", pi64Data);
  
  //====================================================
  testCaseComment("Postcondition");
  testStep("STEP", "Return ECU to default values");
  RunPostTs();

}

testcase SW_IT_DIA_DataServices_ReadFingerprint_Read_Software_Fingerprint_s_ReadDataLength()
{
  //***********************************Test report header*********************************
  testReportAddMiscInfoBlock("AUTOLIV ELECTRONICS document");
 TestReportAddMiscInfo("Nightly test", "No");
 TestReportAddMiscInfo("Test type", "Requirement-Based test");
 TestReportAddMiscInfo("Regression Test", "No");
 TestReportAddMiscInfo("Fault injection method used", "No");
 TestReportAddMiscInfo("Resource usage evaluation", "No");
 TestReportAddMiscInfo("Priority", "No");
 TestReportAddMiscInfo("Safety relevant", "No");
 TestReportAddMiscInfo("Test type", "automatic");
  
  AddRequirementInfo("Requirement under test", "ARCH_SW_DIA_0735; ARCH_SW_DIA_0739; ARCH_SW_DIA_0740");
  AddRequirementInfo("ARCH_SW_DIA_0735", "Service 0x22 (Read Data By Identifier) will be implemented for DID F15B (Software Fingerprint)");
  AddRequirementInfo("ARCH_SW_DIA_0739", "Response data length shall be 20 bytes* nb of logical blocks Note: Full Response length = 3 bytes + Response data length ");
  AddRequirementInfo("ARCH_SW_DIA_0740", "Byte #4: ?Status Information - Logical Block #0 Bytes #5 -#20: ?Diagnostic Authentication Certificate ID Byte #21: ?Programming Date Year Byte #22: ?Programming Date Month Byte #23: ?Programming Date Day ");
  
  //***************************************************************************************
 
  testCaseComment("Preconditions");
  testStep("STEP", "Bench Initialization");
  RunPreTs();
  //====================================================
  
  testStep("STEP", "Set breakpoint in function *DataServices_ReadFingerprint_Read_Software_Fingerprint_s_ReadDataLength*.");
  debugger_setRelativeFunctionBpAtLine("DataServices_ReadFingerprint_Read_Software_Fingerprint_s_ReadDataLength", 3);
  debugger_run();
 
  testCaseComment("Action: ARCH_SW_DIA_0735; ARCH_SW_DIA_0739; ARCH_SW_DIA_0740");
  testStep("STEP", "Send diag request for 22 F15B and wait for timeout error --> Timeout received.");
  SendDiagnosticRequest(dReadFingerprintReadRequest, dReadFingerprintReadResponse, TRUE);

  testWaitForTimeout(2000);
  testStep("STEP", "Check if breakpoint from function DataServices_ReadFingerprint_Read_Software_Fingerprint_s_ReadDataLength was reached. --> BP was reached.");
  debugger_waitUntilBPisReached(5000);
  debugger_isCPUStoppedAtFunction("DataServices_ReadFingerprint_Read_Software_Fingerprint_s_ReadDataLength");
  
  testStep("STEP", "Evaluate *DataLength pointer --> Byte was read.");
  pi64Data = debugger_readLocalVariable("*DataLength");
  EvalManStepEqual("Data pointer read", pi64Data);
  
  //====================================================
  testCaseComment("Postcondition");
  testStep("STEP", "Return ECU to default values");
  RunPostTs();

}

testcase SW_IT_DIA_DataServices_Calibration_Identifications_CAL_ID_Write_CombinedDataElement_WriteData()
{
  //***********************************Test report header*********************************
  testReportAddMiscInfoBlock("AUTOLIV ELECTRONICS document");
 TestReportAddMiscInfo("Nightly test", "No");
 TestReportAddMiscInfo("Test type", "Requirement-Based test");
 TestReportAddMiscInfo("Regression Test", "No");
 TestReportAddMiscInfo("Fault injection method used", "No");
 TestReportAddMiscInfo("Resource usage evaluation", "No");
 TestReportAddMiscInfo("Priority", "No");
 TestReportAddMiscInfo("Safety relevant", "No");
 TestReportAddMiscInfo("Test type", "automatic");
  
  AddRequirementInfo("Requirement under test", "ARCH_SW_DIA_0745; ARCH_SW_DIA_0746; ARCH_SW_DIA_0747; ARCH_SW_DIA_0748");
  AddRequirementInfo("ARCH_SW_DIA_0745", "Service 0x2E (Write Data By Identifier) will be implemented for DID F804 (Calibration Identifications (CAL ID))");
  AddRequirementInfo("ARCH_SW_DIA_0746", "The Write Calibration Identifications (CAL ID) service shall be available in the following sessions: ?Programming (0x02) ?Extended Session (0x03) ?Supplier Session/Development Session (0x7E) ");
  AddRequirementInfo("ARCH_SW_DIA_0747", "The Write Calibration Identifications (CAL ID) service shall be available under the following forms of Authentication: ?Supplier ?Development ENHANCED ?Production ?After-Sales ENHANCED ?After-Sales STANDARD ");
  AddRequirementInfo("ARCH_SW_DIA_0748", "Bytes #2-#3: DataIdentifier of the Write Calibration Identifications (CAL ID) shall be: 0xF804");
  
  //***************************************************************************************
  
    
  testCaseComment("Preconditions");
  testStep("STEP", "Bench Initialization");
  RunPreTs();
  //====================================================
  
  testStep("STEP", "Enter development session.");
  EnterDiagnosticSession("development");
  
  testStep("STEP", "Set breakpoint in function *DataServices_Calibration_Identifications_CAL_ID_Write_CombinedDataElement_WriteData*.");
  debugger_setRelativeFunctionBpAtLine("DataServices_Calibration_Identifications_CAL_ID_Write_CombinedDataElement_WriteData", 0);
  debugger_run();
 
  testCaseComment("ARCH_SW_DIA_0745; ARCH_SW_DIA_0746; ARCH_SW_DIA_0747; ARCH_SW_DIA_0748");
  testStep("STEP", "Send diag request for 2E F804 and wait for timeout error --> Timeout reached.");
  SendDiagnosticRequest(dCalibrationIdentificationCALIDWriteRequest, dCalibrationIdentificationCALIDWriteResponse, TRUE);

  testWaitForTimeout(2000);
  testStep("STEP", "Check if breakpoint from function DataServices_Calibration_Identifications_CAL_ID_Write_CombinedDataElement_WriteData was reached. --> BP was reached.");
  debugger_waitUntilBPisReached(5000);
  debugger_isCPUStoppedAtFunction("DataServices_Calibration_Identifications_CAL_ID_Write_CombinedDataElement_WriteData");
  //====================================================
  testCaseComment("Postcondition");
  testStep("STEP", "Return ECU to default values");
  RunPostTs();

}

testcase SW_IT_DIA_DataServices_Calibration_Identifications_CAL_ID_Write_Number_of_data_items()
{
  //***********************************Test report header*********************************
  testReportAddMiscInfoBlock("AUTOLIV ELECTRONICS document");
 TestReportAddMiscInfo("Nightly test", "No");
 TestReportAddMiscInfo("Test type", "Requirement-Based test");
 TestReportAddMiscInfo("Regression Test", "No");
 TestReportAddMiscInfo("Fault injection method used", "No");
 TestReportAddMiscInfo("Resource usage evaluation", "No");
 TestReportAddMiscInfo("Priority", "No");
 TestReportAddMiscInfo("Safety relevant", "No");
 TestReportAddMiscInfo("Test type", "automatic");
  
  AddRequirementInfo("Requirement under test", "ARCH_SW_DIA_0745; ARCH_SW_DIA_0749; ARCH_SW_DIA_0750");
  AddRequirementInfo("ARCH_SW_DIA_0745", "Service 0x2E (Write Data By Identifier) will be implemented for DID F804 (Calibration Identifications (CAL ID))");
  AddRequirementInfo("ARCH_SW_DIA_0749", "Request data shall be 17 bytes long.Note: Full Request length = 3 bytes + Response data length");
  AddRequirementInfo("ARCH_SW_DIA_0750", "Byte #4: ?bits 0-7: Number of data items Bytes #5-#21: ?bits 0-7: Calibration Identification ");
  
  //***************************************************************************************
  
      
  testCaseComment("Preconditions");
  testStep("STEP", "Bench Initialization");
  RunPreTs();
  //====================================================
  
  testStep("STEP", "Enter development session.");
  EnterDiagnosticSession("development");
  
  testStep("STEP", "Set breakpoint in function *DataServices_Calibration_Identifications_CAL_ID_Write_Number_of_data_items*.");
  debugger_setRelativeFunctionBpAtLine("DataServices_Calibration_Identifications_CAL_ID_Write_Number_of_data_items", 0);
  debugger_run();
 
  testCaseComment("ARCH_SW_DIA_0745; ARCH_SW_DIA_0749; ARCH_SW_DIA_0750");
  testStep("STEP", "Send diag request for 2E F804 and wait for timeout error --> Timeout reached.");
  SendDiagnosticRequest(dCalibrationIdentificationCALIDWriteRequest, dCalibrationIdentificationCALIDWriteResponse, TRUE);

  testWaitForTimeout(2000);
  testStep("STEP", "Check if breakpoint from function DataServices_Calibration_Identifications_CAL_ID_Write_Number_of_data_items was reached. --> BP was reached.");
  debugger_waitUntilBPisReached(5000);
  debugger_isCPUStoppedAtFunction("DataServices_Calibration_Identifications_CAL_ID_Write_Number_of_data_items");
  //====================================================
  testCaseComment("Postcondition");
  testStep("STEP", "Return ECU to default values");
  RunPostTs();

}


testcase SW_IT_DIA_DataServices_Synchronize_to_Non_volatile_Memory_Start()
{
  //***********************************Test report header*********************************
  testReportAddMiscInfoBlock("AUTOLIV ELECTRONICS document");
 TestReportAddMiscInfo("Nightly test", "No");
 TestReportAddMiscInfo("Test type", "Requirement-Based test");
 TestReportAddMiscInfo("Regression Test", "No");
 TestReportAddMiscInfo("Fault injection method used", "No");
 TestReportAddMiscInfo("Resource usage evaluation", "No");
 TestReportAddMiscInfo("Priority", "No");
 TestReportAddMiscInfo("Safety relevant", "No");
 TestReportAddMiscInfo("Test type", "automatic");
  
  AddRequirementInfo("Requirement under test", "ARCH_SW_DIA_0755; ARCH_SW_DIA_0756; ARCH_SW_DIA_0757; ARCH_SW_DIA_0758");
  AddRequirementInfo("ARCH_SW_DIA_0755", "Service 0x31 (Routine Control) 0x31 01 Start 0x31 02 Stop 0x31 03 Request Results for RID 0x0245 (Synchronize to Non-volatile Memory) will be implemented ");
  AddRequirementInfo("ARCH_SW_DIA_0756", "RoutineIdentifier shall be 0x0245.");
  AddRequirementInfo("ARCH_SW_DIA_0757", "Routine Start 0x01 shall be available in the following diagnostic sessions: ?Extended Session (0x03) ?Supplier Session/Development Session (0x7E) Routine Start requires the following forms of Authentication: ?Supplier ?Development ENHANCED ?Production ?After-Sales ENHANCED ?After-Sales STANDARD ");
  AddRequirementInfo("ARCH_SW_DIA_0758", "Routine Start 0x01 shall synchronize all data currently not synchronized from volatile memory to non-volatile memory.");
 
  //***************************************************************************************
  
  testCaseComment("Preconditions");
  testStep("STEP", "Bench Initialization");
  RunPreTs();
  //====================================================

  testStep("STEP", "Enter development session.");
  EnterDiagnosticSession("development");
  
  testStep("STEP", "Set breakpoint in function *DataServices_Synchronize_to_Non_volatile_Memory_Start*.");
  debugger_setRelativeFunctionBpAtLine("DataServices_Synchronize_to_Non_volatile_Memory_Start", 0);
 
  testCaseComment("Action: ARCH_SW_DIA_0755; ARCH_SW_DIA_0756; ARCH_SW_DIA_0757; ARCH_SW_DIA_0758");
  testStep("STEP", "Send diag request for RID 02 45 Start --> Request Sent.");
  SendDiagnosticRequest(dSynchronizeToNonVolatileMemoryStartRequest, dSynchronizeToNonVolatileMemoryStartResponse, TRUE);
  
  testWaitForTimeout(2000);
  testStep("STEP", "Check if breakpoint from function DataServices_Synchronize_to_Non_volatile_Memory_Start was reached. --> BP was reached.");
  debugger_waitUntilBPisReached(5000);
  debugger_isCPUStoppedAtFunction("DataServices_Synchronize_to_Non_volatile_Memory_Start");
  
  
  //====================================================
  testCaseComment("Postcondition");
  testStep("STEP", "Return ECU to default values");
  RunPostTs();

}

testcase SW_IT_DIA_DataServices_Synchronize_to_Non_volatile_Memory_Stop()
{
  //***********************************Test report header*********************************
  testReportAddMiscInfoBlock("AUTOLIV ELECTRONICS document");
 TestReportAddMiscInfo("Nightly test", "No");
 TestReportAddMiscInfo("Test type", "Requirement-Based test");
 TestReportAddMiscInfo("Regression Test", "No");
 TestReportAddMiscInfo("Fault injection method used", "No");
 TestReportAddMiscInfo("Resource usage evaluation", "No");
 TestReportAddMiscInfo("Priority", "No");
 TestReportAddMiscInfo("Safety relevant", "No");
 TestReportAddMiscInfo("Test type", "automatic");
  
  AddRequirementInfo("Requirement under test", "ARCH_SW_DIA_0755; ARCH_SW_DIA_0759; ARCH_SW_DIA_0760");
  AddRequirementInfo("ARCH_SW_DIA_0755", "Service 0x31 (Routine Control) 0x31 01 Start 0x31 02 Stop 0x31 03 Request Results for RID 0x0245 (Synchronize to Non-volatile Memory) will be implemented ");
  AddRequirementInfo("ARCH_SW_DIA_0759", "Routine Stop 0x02 shall be available in the following diagnostic sessions: ?Extended Session (0x03) ?Supplier Session/Development Session (0x7E) Routine Stop requires the following forms of Authentication: ?Supplier ?Development ENHANCED ?Production ?After-Sales ENHANCED ?After-Sales STANDARD ");
  AddRequirementInfo("ARCH_SW_DIA_0760", "Routine Stop 0x02 shall be responsible for deactivating the synchronization of all data");
 
  //***************************************************************************************
  
  testCaseComment("Preconditions");
  testStep("STEP", "Bench Initialization");
  RunPreTs();
  ////====================================================

  testStep("STEP", "Enter development session.");
  EnterDiagnosticSession("development");
  
  testStep("STEP", "Set breakpoint in function *Synchronize_to_Non_volatile_Memory_Stop*.");
  debugger_setRelativeFunctionBpAtLine("Synchronize_to_Non_volatile_Memory_Stop", 0);
  debugger_run();
 
  testStep("STEP", "Send diag request for RID 02 45 Start --> Request Sent.");
  SendDiagnosticRequest(dSynchronizeToNonVolatileMemoryStartRequest, dSynchronizeToNonVolatileMemoryStartResponse);
  
  testStep("STEP", "Send diag request for RID 02 45 Stop --> Timeout error.");
  SendDiagnosticRequest(dSynchronizeToNonVolatileMemoryStopRequest, dSynchronizeToNonVolatileMemoryStopResponse, TRUE);
  
  testCaseComment("Action: ARCH_SW_DIA_0755; ARCH_SW_DIA_0759; ARCH_SW_DIA_0760");
  testStep("STEP", "Check if breakpoint from function Synchronize_to_Non_volatile_Memory_Stop was reached. --> BP was reached.");
  debugger_waitUntilBPisReached(5000);
  debugger_isCPUStoppedAtFunction("Synchronize_to_Non_volatile_Memory_Stop");
  
  
  ////====================================================
  testCaseComment("Postcondition");
  testStep("STEP", "Return ECU to default values");
  RunPostTs();
}

testcase SW_IT_DIA_DataServices_Synchronize_to_Non_volatile_Memory_RequestResults()
{
  //***********************************Test report header*********************************
  testReportAddMiscInfoBlock("AUTOLIV ELECTRONICS document");
 TestReportAddMiscInfo("Nightly test", "No");
 TestReportAddMiscInfo("Test type", "Requirement-Based test");
 TestReportAddMiscInfo("Regression Test", "No");
 TestReportAddMiscInfo("Fault injection method used", "No");
 TestReportAddMiscInfo("Resource usage evaluation", "No");
 TestReportAddMiscInfo("Priority", "No");
 TestReportAddMiscInfo("Safety relevant", "No");
 TestReportAddMiscInfo("Test type", "automatic");
  
  AddRequirementInfo("Requirement under test", "ARCH_SW_DIA_0755; ARCH_SW_DIA_0761; ARCH_SW_DIA_0762");
  AddRequirementInfo("ARCH_SW_DIA_0755", "Service 0x31 (Routine Control) 0x31 01 Start 0x31 02 Stop 0x31 03 Request Results for RID 0x0245 (Synchronize to Non-volatile Memory) will be implemented ");
  AddRequirementInfo("ARCH_SW_DIA_0761", "Routine Request Results 0x03 shall be available in the following diagnostic sessions: ?Extended Session (0x03) ?Supplier Session/Development Session (0x7E) Routine Stop requires the following forms of Authentication: ?Supplier ?Development ENHANCED ?Production ?After-Sales ENHANCED ?After-Sales STANDARD  ");
  AddRequirementInfo("ARCH_SW_DIA_0762", "RID specific Routine Result shall be represented by the following: ?0x00 - Terminated successful. ?0x01 - Routine still running. ?0x02 - Stopped without result ");
 
  //***************************************************************************************
  
  
  testCaseComment("Preconditions");
  testStep("STEP", "Bench Initialization");
  RunPreTs();
  //====================================================

  testStep("STEP", "Enter development session.");
  EnterDiagnosticSession("development");
  
  testStep("STEP", "Set breakpoint in function *Synchronize_to_Non_volatile_Memory_RequestResults*.");
  debugger_setRelativeFunctionBpAtLine("Synchronize_to_Non_volatile_Memory_RequestResults", 0);
 
  testStep("STEP", "Send diag request for RID 02 45 Start --> Request Sent.");
  SendDiagnosticRequest(dSynchronizeToNonVolatileMemoryStartRequest, dSynchronizeToNonVolatileMemoryStartResponse);
  
  testStep("STEP", "Send diag request for RID 02 45 Request Results --> Timeout error.");
  SendDiagnosticRequest(dSynchronizeToNonVolatileMemoryResultsRequest, dSynchronizeToNonVolatileMemoryResultsResponse, TRUE);
  
  testCaseComment("Action: ARCH_SW_DIA_0755; ARCH_SW_DIA_0761; ARCH_SW_DIA_0762");
  testStep("STEP", "Check if breakpoint from function Synchronize_to_Non_volatile_Memory_RequestResults was reached. --> BP was reached.");
  debugger_waitUntilBPisReached(5000);
  debugger_isCPUStoppedAtFunction("Synchronize_to_Non_volatile_Memory_RequestResults");
  
   ////====================================================
  testCaseComment("Postcondition");
  testStep("STEP", "Return ECU to default values");
  RunPostTs();

}


testcase SW_IT_DIA_Ssa_ProcCtrl_RoutineServices_Routine_Replace_Trust_model_Certificates()
{
  //***********************************Test report header*********************************
  testReportAddMiscInfoBlock("AUTOLIV ELECTRONICS document");
 TestReportAddMiscInfo("Nightly test", "No");
 TestReportAddMiscInfo("Test type", "Requirement-Based test");
 TestReportAddMiscInfo("Regression Test", "No");
 TestReportAddMiscInfo("Fault injection method used", "No");
 TestReportAddMiscInfo("Resource usage evaluation", "No");
 TestReportAddMiscInfo("Priority", "No");
 TestReportAddMiscInfo("Safety relevant", "No");
 TestReportAddMiscInfo("Test type", "automatic");
  
  AddRequirementInfo("Requirement under test", "ARCH_SW_DIA_0765; ARCH_SW_DIA_0766; ARCH_SW_DIA_0767; ARCH_SW_DIA_0768; ARCH_SW_DIA_0769; ARCH_SW_DIA_0770");
  AddRequirementInfo("ARCH_SW_DIA_0765", "Service 0x31 (Routine Control) 0x31 01 Start for RID 0x0277 (Replace Trust Model Root Certificate) will be implemented ");
  AddRequirementInfo("ARCH_SW_DIA_0766", "RoutineIdentifier shall be 0x0277.");
  AddRequirementInfo("ARCH_SW_DIA_0767", "The folowing request shall be available for this RID: - Start Routine ");
  AddRequirementInfo("ARCH_SW_DIA_0768", "Routine Start shall replace the currently stored Trust model ECU Root Certificate");
  AddRequirementInfo("ARCH_SW_DIA_0769", "RID specific Control Options Record shall be represented by the following: ?Byte 0: Signature new Root ?Byte 64: Signature ?Byte128: Certificates ");
  AddRequirementInfo("ARCH_SW_DIA_0770", "RID specific Routine Start Result shall be represented by the following: ?Byte 0: Verification Result");

  //***************************************************************************************
  
  testCaseComment("Preconditions");
  testStep("STEP", "Bench Initialization");
  RunPreTs();
  //====================================================

  testStep("STEP", "Authenticate with Production role.");
  AuthenticateECU(3);
  
  testStep("STEP", "Enter development session.");
  EnterDiagnosticSession("development");
  
  testCaseComment("Action: ARCH_SW_DIA_0765; ARCH_SW_DIA_0766; ARCH_SW_DIA_0767; ARCH_SW_DIA_0768; ARCH_SW_DIA_0769; ARCH_SW_DIA_0770");
  testStep("STEP", "Send diag request for RID 02 77 Start --> Request Sent.");
  SendDiagnosticRequest(dReplaceCertificatesStartRequest, dReplaceCertificatesStartResponse);
  CheckPositiveResponse("",dReplaceCertificatesStartRequest, dReplaceCertificatesStartResponse);
  
  
  //====================================================
  testCaseComment("Postcondition");
  testStep("STEP", "Return ECU to default values");
  RunPostTs();
  
}

testcase SW_IT_DIA_DataServices_Check_Reprogramming_Preconditions_Routine_Start()
{
    const byte I_C04_PRESF_LVL_V2_LVL2 = 2;
  byte bNo_of_unfulfilled_precond;
  byte bList_of_unfulfilled_precond;
  //***********************************Test report header*********************************
  testReportAddMiscInfoBlock("AUTOLIV ELECTRONICS document");
 TestReportAddMiscInfo("Nightly test", "No");
 TestReportAddMiscInfo("Test type", "Requirement-Based test");
 TestReportAddMiscInfo("Regression Test", "No");
 TestReportAddMiscInfo("Fault injection method used", "No");
 TestReportAddMiscInfo("Resource usage evaluation", "No");
 TestReportAddMiscInfo("Priority", "No");
 TestReportAddMiscInfo("Safety relevant", "No");
 TestReportAddMiscInfo("Test type", "automatic");
  
  AddRequirementInfo("Requirement under test", "ARCH_SW_DIA_0805; ARCH_SW_DIA_0806; ARCH_SW_DIA_0807; ARCH_SW_DIA_0808; ARCH_SW_DIA_0809; ARCH_SW_DIA_0810; ARCH_SW_DIA_0811; ARCH_SW_DIA_0812; ARCH_SW_DIA_0813; ARCH_SW_DIA_0814");
  AddRequirementInfo("ARCH_SW_DIA_0805", "Service 0x31 (Routine Control) 0x31 01 Start for RID 0x0203 (Check Reprogramming Preconditions) will be implemented ");
  AddRequirementInfo("ARCH_SW_DIA_0806", "RoutineIdentifier shall be 0x0203.");
  AddRequirementInfo("ARCH_SW_DIA_0807", "The folowing request shall be available for this RID: - Start Routine (01) ");
  AddRequirementInfo("ARCH_SW_DIA_0808", "If the ECU does not need any preconditions to be fulfilled for being reprogrammed or all preconditions are fulfilled, it shall return 0x00 as Number of Unfulfilled Preconditions.");
  AddRequirementInfo("ARCH_SW_DIA_0809", "If there are unfulfilled preconditions, the ECU shall include each of them in the List of Unfulfilled Preconditions.");
  AddRequirementInfo("ARCH_SW_DIA_0810", "If there are additional preconditions necessary which are not contained in the List of Unfulfilled Preconditions, these shall be added in consultation with the Diagnostic Development Team.");
  AddRequirementInfo("ARCH_SW_DIA_0811", "Routine Start shall be available in the following diagnostic sessions: ?Programming Session ?Extended Session ?Development Session.");
  AddRequirementInfo("ARCH_SW_DIA_0812", "Routine Start shall be available under the following forms of Authentication: ?Supplier ?Development ENHANCED ?Production ?After-Sales ENHANCED ");
  AddRequirementInfo("ARCH_SW_DIA_0813", "Routine Start shall be responsible to check if any system or ECU conditions to successfully reprogram the ECU are not fulfilled. ");
  AddRequirementInfo("ARCH_SW_DIA_0814", "RID specific Routine Start Result shall be represented by the following: ?Byte 0: Number of Unfulfilled Preconditions. ?Byte 1: List of Unfulfilled Preconditions ");
  AddRequirementInfo("ARCH_SW_DIA_1019", "The programming shall still be possible in the folowing cases ?vehicle_speed information or Impact_x information (CAN signals) not received since last power on/wake-up. ?vehicle_speed information or Impact_x information is SNA ?if vehicle_speed information or Impact_x information is lost during the active diagnostic session, the ECU shall use the last known valid preconditions to determine if a transition from Application Software to Reprogramming Software is allowed. ");

  //***************************************************************************************
   testCaseComment("Preconditions");
  testStep("STEP", "Bench Initialization");
  RunPreTs();
  //==================================================== 

  testCaseComment("Action: ARCH_SW_DIA_0805; ARCH_SW_DIA_0806; ARCH_SW_DIA_0807; ARCH_SW_DIA_0808; ARCH_SW_DIA_0809; ARCH_SW_DIA_0810; ARCH_SW_DIA_0811; ARCH_SW_DIA_0812; ARCH_SW_DIA_0813; ARCH_SW_DIA_0814");
  testStep("STEP", "Enter development session --> Response is received.");
  EnterDiagnosticSession("development");
  
  testStep("STEP", "Set BP in function *DIA_runCheckProgrammingPreconditions* at the start of the validation of preprogramming preconditons. --> BP is set.");
  debugger_setRelativeFunctionBPatLine("DIA_runCheckProgrammingPreconditions", 14);
  debugger_run();
  debugger_WaitUntilBPisReached(2000);
  debugger_isCPUStoppedAtFunction("DIA_runCheckProgrammingPreconditions");
  
  testStep("STEP", "Precondition 1: Crash (Impact x set to True at leat once during the curent wake-up cycle ) --> stImpact3.Impact_X_ST3 set to TRUE");
  debugger_writeLocalVariable("stImpact3.Impact_X_ST3", TRUE);
  
  testStep("STEP", "Precondition 2: Vehicle speed > 0 ( input from VehSpd_Disp_ST3) --> u16NewVehicleSpeed > 0");
  debugger_writeLocalVariable("u16NewVehicleSpeed", 50);
  
  testStep("STEP", "Precondition 3: Low battery voltage (KL30<=9V) --> u16BatteryVoltage <= DIA_PROG_PRECOND_UNDERVOLTAGE");
  debugger_writeLocalVariable("u16BatteryVoltage", 8);
  
  testStep("STEP", "Set BP in function *DIA_runRid0203_CheckProgrammingPreconditionsStart* at line *VStdMemCpy(List_of_Preconditions, DIA_u8ProgrammingPreconditionsList, DIA_u8ActiveProgrammingPreconditions);* --> BP is set.");
  debugger_setRelativeFunctionBPatLine("DIA_runRid0203_CheckProgrammingPreconditionsStart", 5);
  debugger_run();
  
  testStep("STEP", "Use the Start Routine service 0x31 01 for RID 0203, and check that BP was reached. --> BP is reached.");
  SendDiagnosticRequest(dCheckReprogrammingPreconditionsStartRequest, dCheckReprogrammingPreconditionsStartResponse, TRUE);
  debugger_WaitUntilBPisReached(2000);
  debugger_isCPUStoppedAtFunction("DIA_runRid0203_CheckProgrammingPreconditionsStart");
  
  debugger_deleteRelativeFunctionBPatLine("DIA_runRid0203_CheckProgrammingPreconditionsStart", 5);
  debugger_run();
  testStep("STEP", "Use the Start Routine service 0x31 01 for RID 0203 --> BP is reached.");
  SendDiagnosticRequest(dCheckReprogrammingPreconditionsStartRequest, dCheckReprogrammingPreconditionsStartResponse);
  CheckPositiveResponse("", dCheckReprogrammingPreconditionsStartRequest,dCheckReprogrammingPreconditionsStartResponse);

  testStep("STEP", "Evaluate Byte 0 of RID 0x0203 response. --> Byte = 0x2");
  bNo_of_unfulfilled_precond = diagGetParameter(dCheckReprogrammingPreconditionsStartResponse, "Number_of_Unfulfilled_Preconditions");
  EvalManStepEqual("Byte0 is set to 0x02", bNo_of_unfulfilled_precond, 0x2);
  
  testStep("STEP", "Evaluate Byte 1 of RID 0x0203 response. --> Byte = 0x2");
  bList_of_unfulfilled_precond = diagGetParameter(dCheckReprogrammingPreconditionsStartResponse, "List_of_Preconditions/EndOfServiceIteration0/Programming_Condition");
  EvalManStepEqual("Byte1 is set to 0x02", bNo_of_unfulfilled_precond, 0x2);
  
  //====================================================
  testCaseComment("Postcondition");
  testStep("STEP", "Return ECU to default values");
  RunPostTs();

}

testcase SW_IT_DIA_DataServices_PreCheckProgrammingDependencies_Start()
{
  //***********************************Test report header*********************************
  testReportAddMiscInfoBlock("AUTOLIV ELECTRONICS document");
 TestReportAddMiscInfo("Nightly test", "No");
 TestReportAddMiscInfo("Test type", "Requirement-Based test");
 TestReportAddMiscInfo("Regression Test", "No");
 TestReportAddMiscInfo("Fault injection method used", "No");
 TestReportAddMiscInfo("Resource usage evaluation", "No");
 TestReportAddMiscInfo("Priority", "No");
 TestReportAddMiscInfo("Safety relevant", "No");
 TestReportAddMiscInfo("Test type", "automatic");
  
  AddRequirementInfo("Requirement under test", "ARCH_SW_DIA_0815; ARCH_SW_DIA_0816; ARCH_SW_DIA_0817; ARCH_SW_DIA_0818; ARCH_SW_DIA_0819; ARCH_SW_DIA_0820; ARCH_SW_DIA_0821; ARCH_SW_DIA_0822; ARCH_SW_DIA_0823");
  AddRequirementInfo("ARCH_SW_DIA_0805", "Service 0x31 (Routine Control) 0x31 01 Start for RID 0x0203 (Check Reprogramming Preconditions) will be implemented ");
  AddRequirementInfo("ARCH_SW_DIA_0816", "RoutineIdentifier shall be 0x0207.");
  AddRequirementInfo("ARCH_SW_DIA_0817", "The folowing request shall be available for this RID: - Start Routine (01) ");
  AddRequirementInfo("ARCH_SW_DIA_0818", "Regarding the SW/SW and HW/SW compatibility checks the same algorithms shall be used like for RoutineControl checkProgrammingDependencies");
  AddRequirementInfo("ARCH_SW_DIA_0819", "Contrary to RoutineControl checkProgrammingDependencies, this service shall not change any ECU flags");
  AddRequirementInfo("ARCH_SW_DIA_0820", "Routine Start shall be available in the following diagnostic sessions: ?Programming Session ?Extended Session ?Development Session ");
  AddRequirementInfo("ARCH_SW_DIA_0821", "Routine Start shall be available under the following forms of Authentication: ?Supplier ?Development ENHANCED ?Production ?After-Sales ENHANCED ");
  AddRequirementInfo("ARCH_SW_DIA_0822", "Routine Start shall be responsible to check if any system or ECU conditions to successfully reprogram the ECU are not fulfilled. RID specific Control Options Record shall be represented by the following: Byte 0: Precheck Informations ");
  AddRequirementInfo("ARCH_SW_DIA_0823", "RID specific Routine Start Result shall be represented by the following: ?Byte 0: Dependencies Verification Check Result ");

  //***************************************************************************************

    
  testCaseComment("Preconditions");
  testStep("STEP", "Bench Initialization");
  RunPreTs();
  //====================================================
  
  testStep("STEP", "Enter development session.");
  EnterDiagnosticSession("development");
  
  testCaseComment("Action: ARCH_SW_DIA_0815; ARCH_SW_DIA_0816; ARCH_SW_DIA_0817; ARCH_SW_DIA_0818; ARCH_SW_DIA_0819; ARCH_SW_DIA_0820; ARCH_SW_DIA_0821; ARCH_SW_DIA_0822; ARCH_SW_DIA_0823");
  testStep("STEP", "Send diag request for RID 02 03 Start --> Request Sent.");
  SendDiagnosticRequest(dPreCheckProgrammingDependenciesStartRequest, dPreCheckProgrammingDependenciesStartResponse);
  CheckPositiveResponse("",dPreCheckProgrammingDependenciesStartRequest, dPreCheckProgrammingDependenciesStartResponse);

  //====================================================
  testCaseComment("Postcondition");
  testStep("STEP", "Return ECU to default values");
  RunPostTs();
  
}

testcase SW_IT_DIA_runDidFD30_TemperatureSensorCalibrationPointRead()
{
  //***********************************Test report header*********************************
  testReportAddMiscInfoBlock("AUTOLIV ELECTRONICS document");
 TestReportAddMiscInfo("Nightly test", "No");
 TestReportAddMiscInfo("Test type", "Requirement-Based test");
 TestReportAddMiscInfo("Regression Test", "No");
 TestReportAddMiscInfo("Fault injection method used", "No");
 TestReportAddMiscInfo("Resource usage evaluation", "No");
 TestReportAddMiscInfo("Priority", "No");
 TestReportAddMiscInfo("Safety relevant", "No");
 TestReportAddMiscInfo("Test type", "automatic");
  
  AddRequirementInfo("Requirement under test", "ARCH_SW_DIA_0830; ARCH_SW_DIA_0831; ARCH_SW_DIA_0832; ARCH_SW_DIA_0833");
  AddRequirementInfo("ARCH_SW_DIA_0830", "Service 0x22 (Read Data By Identifier) will be implemented for DID FD30 (Temperature Sensor Calibration Point)");
  AddRequirementInfo("ARCH_SW_DIA_0831", "The Read Temperature Sensor Calibration Point shall be available in the following sessions: ?Default Session (0x01) ?Extended Session (0x03) ?Supplier Session/Development Session (0x7E) ");
  AddRequirementInfo("ARCH_SW_DIA_0832", "The Read Temperature Sensor Calibration Point service shall be available under the following forms of Authentication: ?Supplier ?Development ENHANCED ?Production ?After-Sales ENHANCED ?After-Sales STANDARD ?After-Sales BASIC ?Internal Diagnostic Test Tool ?ePTI Test Tool ");
  AddRequirementInfo("ARCH_SW_DIA_0833", "Data Identifier of the Read Temperature Sensor Calibration Point Service shall be: 0xFD30");

  //***************************************************************************************
  testCaseComment("Preconditions");
  testStep("STEP", "Bench Initialization");
  RunPreTs();
  //====================================================
  
  testCaseComment("Action: ARCH_SW_DIA_0830; ARCH_SW_DIA_0831; ARCH_SW_DIA_0832; ARCH_SW_DIA_0833");
  testStep("STEP", "Send diag request for 22 FD30 and check response --> Response received.");
  SendDiagnosticRequest(dTemperature_SensorCalibrationPointReadRequest, dTemperature_SensorCalibrationPointReadResponse);
  CheckPositiveResponse("", dTemperature_SensorCalibrationPointReadRequest, dTemperature_SensorCalibrationPointReadResponse);
  
  //====================================================
  testCaseComment("Postcondition");
  testStep("STEP", "Return ECU to default values");
  RunPostTs();
  
  
}

testcase SW_IT_DIA_runDidFD30_TemperatureSensorCalibrationPointConditionCheckRead()
{
  //***********************************Test report header*********************************
  testReportAddMiscInfoBlock("AUTOLIV ELECTRONICS document");
 TestReportAddMiscInfo("Nightly test", "No");
 TestReportAddMiscInfo("Test type", "Requirement-Based test");
 TestReportAddMiscInfo("Regression Test", "No");
 TestReportAddMiscInfo("Fault injection method used", "No");
 TestReportAddMiscInfo("Resource usage evaluation", "No");
 TestReportAddMiscInfo("Priority", "No");
 TestReportAddMiscInfo("Safety relevant", "No");
 TestReportAddMiscInfo("Test type", "automatic");
  
  AddRequirementInfo("Requirement under test", "ARCH_SW_DIA_0830; ARCH_SW_DIA_0834; ARCH_SW_DIA_0835");
  AddRequirementInfo("ARCH_SW_DIA_0830", "Service 0x22 (Read Data By Identifier) will be implemented for DID FD30 (Temperature Sensor Calibration Point)");
  AddRequirementInfo("ARCH_SW_DIA_0834", "Response data length shall be 1 byte long Note: Full Response length = 3 bytes + Response data length  ");
  AddRequirementInfo("ARCH_SW_DIA_0835", "Byte #4: ? Offset Point (signed value) ");

  //***************************************************************************************
    testCaseComment("Preconditions");
  testStep("STEP", "Bench Initialization");
  RunPreTs();
  //====================================================
  
  testCaseComment("Action: ARCH_SW_DIA_0830; ARCH_SW_DIA_0834; ARCH_SW_DIA_0835");
  testStep("STEP", "Send diag request for 22 FD30 and check response --> Response received.");
  SendDiagnosticRequest(dTemperature_SensorCalibrationPointReadRequest, dTemperature_SensorCalibrationPointReadResponse);
  CheckPositiveResponse("", dTemperature_SensorCalibrationPointReadRequest, dTemperature_SensorCalibrationPointReadResponse);
  
  //====================================================
  testCaseComment("Postcondition");
  testStep("STEP", "Return ECU to default values");
  RunPostTs();
  
}

testcase SW_IT_DIA_runDidFD30_TemperatureSensorCalibrationPointWrite()
{
  //***********************************Test report header*********************************
  testReportAddMiscInfoBlock("AUTOLIV ELECTRONICS document");
 TestReportAddMiscInfo("Nightly test", "No");
 TestReportAddMiscInfo("Test type", "Requirement-Based test");
 TestReportAddMiscInfo("Regression Test", "No");
 TestReportAddMiscInfo("Fault injection method used", "No");
 TestReportAddMiscInfo("Resource usage evaluation", "No");
 TestReportAddMiscInfo("Priority", "No");
 TestReportAddMiscInfo("Safety relevant", "No");
 TestReportAddMiscInfo("Test type", "automatic");
  
  AddRequirementInfo("Requirement under test", "ARCH_SW_DIA_0840; ARCH_SW_DIA_0841; ARCH_SW_DIA_0842; ARCH_SW_DIA_0843; ARCH_SW_DIA_0844");
  AddRequirementInfo("ARCH_SW_DIA_0840", "Service 0x2E (Write Data By Identifier) will be implemented for DID FD30 (Temperature Sensor Calibration Point)");
  AddRequirementInfo("ARCH_SW_DIA_0841", "The Write Temperature Sensor Calibration Point Service shall be available in the following sessions: ?Supplier Session/Development Session (0x7E)");
  AddRequirementInfo("ARCH_SW_DIA_0842", "The Write Temperature Sensor Calibration Point service shall be available under the following forms of Authentication: ?Supplier ?Development ENHANCED ?Production ?After-Sales ENHANCED ?After-Sales STANDARD ");
  AddRequirementInfo("ARCH_SW_DIA_0843", "Request data shall be 1 byte long. Note: Full Request length = 3 bytes + Response data length. ");
  AddRequirementInfo("ARCH_SW_DIA_0844", "Byte #4: ?Offset Point (signed value)");

  //***************************************************************************************
   
      
  testCaseComment("Preconditions");
  testStep("STEP", "Bench Initialization");
  RunPreTs();
  //====================================================
  
   testCaseComment("Action: ARCH_SW_DIA_0840; ARCH_SW_DIA_0841; ARCH_SW_DIA_0842; ARCH_SW_DIA_0843; ARCH_SW_DIA_0844;");
  testStep("STEP", "Send diag request for 22 FD30 --> Timeout received.");
  SendDiagnosticRequest(dTemperatureSensorCalibrationPointWriteRequest, dTemperatureSensorCalibrationPointWriteResponse);
  CheckPositiveResponse(dTemperatureSensorCalibrationPointWriteRequest, dTemperatureSensorCalibrationPointWriteResponse);
  

  //====================================================
  testCaseComment("Postcondition");
  testStep("STEP", "Return ECU to default values");
  RunPostTs();

}

testcase SW_IT_DIA_runDidFDDF_VelocityPiRegulationCoefficientsRead()
{
  //***********************************Test report header*********************************
  testReportAddMiscInfoBlock("AUTOLIV ELECTRONICS document");
 TestReportAddMiscInfo("Nightly test", "No");
 TestReportAddMiscInfo("Test type", "Requirement-Based test");
 TestReportAddMiscInfo("Regression Test", "No");
 TestReportAddMiscInfo("Fault injection method used", "No");
 TestReportAddMiscInfo("Resource usage evaluation", "No");
 TestReportAddMiscInfo("Priority", "No");
 TestReportAddMiscInfo("Safety relevant", "No");
 TestReportAddMiscInfo("Test type", "automatic");
  
  AddRequirementInfo("Requirement under test", "ARCH_SW_DIA_0845; ARCH_SW_DIA_0846; ARCH_SW_DIA_0847; ARCH_SW_DIA_0848");
  AddRequirementInfo("ARCH_SW_DIA_0845", "Service 0x22 (Read Data By Identifier) will be implemented for DID FDDF (Velocity PI Regulation Coefficients)");
  AddRequirementInfo("ARCH_SW_DIA_0846", "The Read Velocity PI Regulation Coefficients Service shall be available in the following sessions: ?Default Session (0x01) ?Extended Session (0x03) ?Supplier Session/Development Session (0x7E)");
  AddRequirementInfo("ARCH_SW_DIA_0847", "The Read Velocity PI Regulation Coefficients service shall be available under the following forms of Authentication: ?Supplier ?Development ENHANCED ?Production ?After-Sales ENHANCED ?After-Sales STANDARD ?After-Sales BASIC ?Internal Diagnostic Test Tool ?ePTI Test Tool ");
  AddRequirementInfo("ARCH_SW_DIA_0848", "Data Identifier of the Read Velocity PI Regulation Coefficients Service shall be: 0xFDDF");

  //***************************************************************************************
  testCaseComment("Preconditions");
  testStep("STEP", "Bench Initialization");
  RunPreTs();
  //==================================================== 
  
    testCaseComment("Action: ARCH_SW_DIA_0845; ARCH_SW_DIA_0846; ARCH_SW_DIA_0847; ARCH_SW_DIA_0848");
  testStep("STEP", "Send diag request for 22 FDDF and check response --> Response received.");
  SendDiagnosticRequest(dVelocityPIRegulationCoefficientReadRequest, dVelocityPIRegulationCoefficientReadResponse);
  CheckPositiveResponse("", dVelocityPIRegulationCoefficientReadRequest, dVelocityPIRegulationCoefficientReadResponse);
  
    //====================================================
  testCaseComment("Postcondition");
  testStep("STEP", "Return ECU to default values");
  RunPostTs();
}

testcase SW_IT_DIA_runDidFDDF_VelocityPiRegulationCoefficientsConditionCheckRead()
{
  //***********************************Test report header*********************************
  testReportAddMiscInfoBlock("AUTOLIV ELECTRONICS document");
 TestReportAddMiscInfo("Nightly test", "No");
 TestReportAddMiscInfo("Test type", "Requirement-Based test");
 TestReportAddMiscInfo("Regression Test", "No");
 TestReportAddMiscInfo("Fault injection method used", "No");
 TestReportAddMiscInfo("Resource usage evaluation", "No");
 TestReportAddMiscInfo("Priority", "No");
 TestReportAddMiscInfo("Safety relevant", "No");
 TestReportAddMiscInfo("Test type", "automatic");
  
  AddRequirementInfo("Requirement under test", "ARCH_SW_DIA_0845; ARCH_SW_DIA_0849; ARCH_SW_DIA_0850");
  AddRequirementInfo("ARCH_SW_DIA_0845", "Service 0x22 (Read Data By Identifier) will be implemented for DID FDDF (Velocity PI Regulation Coefficients)");
  AddRequirementInfo("ARCH_SW_DIA_0849", "Response data length shall be 30 bytes long Note: Full Response length = 3 bytes + Response data length ");
  AddRequirementInfo("ARCH_SW_DIA_0848", "Bytes #4-#33: ?Input Velocity Coefficient ");
  //***************************************************************************************
  
  testCaseComment("Preconditions");
  testStep("STEP", "Bench Initialization");
  RunPreTs();
  //==================================================== 
  
    testCaseComment("Action: ARCH_SW_DIA_0845; ARCH_SW_DIA_0849; ARCH_SW_DIA_0850");
  testStep("STEP", "Send diag request for 22 FDDF and check response --> Response received.");
  SendDiagnosticRequest(dVelocityPIRegulationCoefficientReadRequest, dVelocityPIRegulationCoefficientReadResponse);
  CheckPositiveResponse("", dVelocityPIRegulationCoefficientReadRequest, dVelocityPIRegulationCoefficientReadResponse);
  
    //====================================================
  testCaseComment("Postcondition");
  testStep("STEP", "Return ECU to default values");
  RunPostTs();
  
}


testcase SW_IT_DIA_runDidFDDF_VelocityPiRegulationCoefficientsConditionWrite()
{
  //***********************************Test report header*********************************
  testReportAddMiscInfoBlock("AUTOLIV ELECTRONICS document");
 TestReportAddMiscInfo("Nightly test", "No");
 TestReportAddMiscInfo("Test type", "Requirement-Based test");
 TestReportAddMiscInfo("Regression Test", "No");
 TestReportAddMiscInfo("Fault injection method used", "No");
 TestReportAddMiscInfo("Resource usage evaluation", "No");
 TestReportAddMiscInfo("Priority", "No");
 TestReportAddMiscInfo("Safety relevant", "No");
 TestReportAddMiscInfo("Test type", "automatic");
  
  AddRequirementInfo("Requirement under test", "ARCH_SW_DIA_0855; ARCH_SW_DIA_0856; ARCH_SW_DIA_0857; ARCH_SW_DIA_0858; ARCH_SW_DIA_0859");
  AddRequirementInfo("ARCH_SW_DIA_0855", "Service 0x2E (Write Data By Identifier) will be implemented for DID FDDF (Velocity PI Regulation Coefficients)");
  AddRequirementInfo("ARCH_SW_DIA_0856", "The Write Velocity PI Regulation Coefficients Service shall be available in the following sessions: ?Supplier Session/Development Session (0x7E)");
  AddRequirementInfo("ARCH_SW_DIA_0857", "The Write Velocity PI Regulation Coefficients service shall be available under the following forms of Authentication: ?Supplier ?Development ENHANCED ?Production ?After-Sales ENHANCED ?After-Sales STANDARD ");
  AddRequirementInfo("ARCH_SW_DIA_0858", "Request data shall be 30 bytes long. Note: Full Request length = 3 bytes + Response data length");
  AddRequirementInfo("ARCH_SW_DIA_0859", "Bytes #4-#33: ?Input Velocity Coefficient ");
  
  //***************************************************************************************
  
  testCaseComment("Preconditions");
  testStep("STEP", "Bench Initialization");
  RunPreTs();
  //==================================================== 
  testStep("STEP", "Enter development session.");
  EnterDiagnosticSession("development");
  
  testCaseComment("Action: ARCH_SW_DIA_0855; ARCH_SW_DIA_0856; ARCH_SW_DIA_0857; ARCH_SW_DIA_0858; ARCH_SW_DIA_0859");
  testStep("STEP", "Send diag request for 22 FDDF and check response --> Response received.");
  SendDiagnosticRequest(dVelocityPIRegulationCoefficientWriteRequest, dVelocityPIRegulationCoefficientWriteResponse);
  CheckPositiveResponse("", dVelocityPIRegulationCoefficientWriteRequest, dVelocityPIRegulationCoefficientWriteResponse);
  
    //====================================================
  testCaseComment("Postcondition");
  testStep("STEP", "Return ECU to default values");
  RunPostTs();
  
}


testcase SW_IT_DIA_DataServices_Erase_All_Start()
{
  //***********************************Test report header*********************************
  testReportAddMiscInfoBlock("AUTOLIV ELECTRONICS document");
 TestReportAddMiscInfo("Nightly test", "No");
 TestReportAddMiscInfo("Test type", "Requirement-Based test");
 TestReportAddMiscInfo("Regression Test", "No");
 TestReportAddMiscInfo("Fault injection method used", "No");
 TestReportAddMiscInfo("Resource usage evaluation", "No");
 TestReportAddMiscInfo("Priority", "No");
 TestReportAddMiscInfo("Safety relevant", "No");
 TestReportAddMiscInfo("Test type", "automatic");
  
  AddRequirementInfo("Requirement under test", "ARCH_SW_DIA_0860; ARCH_SW_DIA_0861; ARCH_SW_DIA_0862; ARCH_SW_DIA_0863; ARCH_SW_DIA_0864; ARCH_SW_DIA_0865");
  AddRequirementInfo("ARCH_SW_DIA_0860", "Service 0x31 (Routine Control) 0x31 01 Start for RID 0xF782 (Erase All) will be implemented ");
  AddRequirementInfo("ARCH_SW_DIA_0861", "RoutineIdentifier shall be 0xF782.");
  AddRequirementInfo("ARCH_SW_DIA_0862", "The folowing request shall be available for this RID: - Start Routine ");
  AddRequirementInfo("ARCH_SW_DIA_0863", "Routine Start shall be available in the following diagnostic sessions: ?Supplier Session/Development Session (0x7E) Routine Start requires the following forms of Authentication: ?Supplier ?Development ENHANCED ?Production ?After-Sales ENHANCED ?After-Sales STANDARD ");
  AddRequirementInfo("ARCH_SW_DIA_0864", "Routine Start shall be used to reset/clear the following NVM data: ?All cycle counters (EOL counters, Request Counters) ?System context ?System time ?Deficiency level ?Warm Reset data ?Security event log ");
  AddRequirementInfo("ARCH_SW_DIA_0865", "RID specific Routine Status Record Start shall be represented by the following: ?Byte 6: Erase Block Status ?Bit 0: EOL Counters ?0 = Block is filled with data ?1 = Block has been erased NVP_BLOCK_ID_EXECUTION_COUNTERS ?Bit 1: Request Counters ?0 = Block is filled with data ?1 = Block has been erased NVP_BLOCK_ID_MEASUREMENT_FRAME_12_CONFIG ?Bit 2: System Context ?0 = Block is filled with data ?1 = Block has been erased NVP_BLOCK_ID_SYSTEM_CONTEXT_0 NVP_BLOCK_ID_SYSTEM_CONTEXT_1 NVP_BLOCK_ID_SYSTEM_CONTEXT_2 ?Bit 3: System Time ?0 = Block is filled with data ?1 = Block has been erased NVP_BLOCK_ID_PRE_SAFE_RECORDER_1 NVP_BLOCK_ID_PRE_SAFE_RECORDER_2 ?Bit 4: Deficiency Level ?0 = Block is filled with data ?1 = Block has been erased NVP_BLOCK_ID_TESTS_PARAM ?Bit 5: Warm Reset Data ?0 = Block is filled with data ?1 = Block has been erased NVP_BLOCK_ID_WARM_RESET ?Bit 6: Security Event Log ?0 = Block is filled with data ?1 = Block has been erased Ssa_SecLogNvM_SecLog_LogDataEvnt1_FailedCertVerif Ssa_SecLogNvM_SecLog_LogDataEvnt2_SucCertVerif Ssa_SecLogNvM_SecLog_LogDataEvnt3_SucAuthAndEnhanceRights Ssa_SecLogNvM_SecLog_LogDataEvnt4_AuthBySecAccess Ssa_SecLogNvM_SecLog_LogDataEvnt5_SucDiagServiceExec Ssa_SecLogNvM_SecLog_LogDataEvnt6_RightsMgmt Ssa_SecLogNvM_SecLog_LogDataEvnt7_SigVerif Ssa_SecLogNvM_SecLog_LogDataEvnt8_TickCountDateAndTime Ssa_SecLogNvM_SecLog_LogDataEvnt9_SecOcMisconfig Ssa_SecLogNvM_SecLog_LogDataEvnt10_FailedPduMacVerif Ssa_SecLogNvM_SecLog_LogDataEvnt11_SecOrAuthBoot Ssa_SecLogNvM_SecLog_LogDataEvnt12_ChangeOfVin Ssa_SecLogNvM_SecLog_LogDataEvnt13_AclReplacement ");

  //***************************************************************************************

    
  testCaseComment("Preconditions");
  testStep("STEP", "Bench Initialization");
  RunPreTs();
  //==================================================== 
  testStep("STEP", "Enter development session.");
  EnterDiagnosticSession("development");
  
  testCaseComment("Action: ARCH_SW_DIA_0860; ARCH_SW_DIA_0861; ARCH_SW_DIA_0862; ARCH_SW_DIA_0863; ARCH_SW_DIA_0864; ARCH_SW_DIA_0865");
  testStep("STEP", "Send diag request for 22 F782 and check response --> Response received.");
  SendDiagnosticRequest(dEraseAllStartRequest, dEraseAllStartResponse);
  CheckPositiveResponse("", dEraseAllStartRequest, dEraseAllStartResponse);
  
    //====================================================
  testCaseComment("Postcondition");
  testStep("STEP", "Return ECU to default values");
  RunPostTs();
  
}


testcase SW_IT_DIA_DATASERVICES_EXTERNAL_WATCHDOG_TEST_START()
{
  //***********************************Test report header*********************************
  testReportAddMiscInfoBlock("AUTOLIV ELECTRONICS document");
 TestReportAddMiscInfo("Nightly test", "No");
 TestReportAddMiscInfo("Test type", "Requirement-Based test");
 TestReportAddMiscInfo("Regression Test", "No");
 TestReportAddMiscInfo("Fault injection method used", "No");
 TestReportAddMiscInfo("Resource usage evaluation", "No");
 TestReportAddMiscInfo("Priority", "No");
 TestReportAddMiscInfo("Safety relevant", "No");
 TestReportAddMiscInfo("Test type", "automatic");
  
  AddRequirementInfo("Requirement under test", "ARCH_SW_DIA_0870; ARCH_SW_DIA_0871; ARCH_SW_DIA_0872; ARCH_SW_DIA_0873; ARCH_SW_DIA_0874; ARCH_SW_DIA_0875");
  AddRequirementInfo("ARCH_SW_DIA_0870", "Service 0x31 (Routine Control) 0x31 01 Start for RID 0xF791 (External Watchdog Test) will be implemented ");
  AddRequirementInfo("ARCH_SW_DIA_0871", "RoutineIdentifier shall be 0xF782.");
  AddRequirementInfo("ARCH_SW_DIA_0872", "The folowing request shall be available for this RID: - Start Routine ");
  AddRequirementInfo("ARCH_SW_DIA_0873", "Routine Start shall be available in the following diagnostic sessions: ?Supplier Session/Development Session (0x7E) Routine Start requires the following forms of Authentication: ?Supplier ?Development ENHANCED ?Production ?After-Sales ENHANCED ?After-Sales STANDARD ");
  AddRequirementInfo("ARCH_SW_DIA_0874", "Routine Start shall be used to test the external watchdog by stopping its refresh and causing a reset.");
  AddRequirementInfo("ARCH_SW_DIA_0875", "RID specific Routine Status Record Start shall be represented by the following: ?Byte 6: Watchdog Status ?WDG_RESET_NOT_EXECUTED = 0x00 ?WDG_RESET_BY_DIAG = 0xAA ?WDG_NOT_RESET_BY_DIAG = 0x55 ");
  //***************************************************************************************
  
      
  testCaseComment("Preconditions");
  testStep("STEP", "Bench Initialization");
  RunPreTs();
  //==================================================== 
  testStep("STEP", "Enter development session.");
  EnterDiagnosticSession("development");
  
  testCaseComment("Action: ARCH_SW_DIA_0870; ARCH_SW_DIA_0871; ARCH_SW_DIA_0872; ARCH_SW_DIA_0873; ARCH_SW_DIA_0874; ARCH_SW_DIA_0875");
  testStep("STEP", "Send diag request for Routine Start for RID F791 and check response --> Response received.");
  SendDiagnosticRequest(dForceExternalWDGStartRequest, dForceExternalWDGStartResponse);
  CheckPositiveResponse("", dForceExternalWDGStartRequest, dForceExternalWDGStartResponse);
  
    //====================================================
  testCaseComment("Postcondition");
  testStep("STEP", "Return ECU to default values");
  RunPostTs();
  
}

testcase SW_IT_DIA_DataServices_Customer_Settings_Read_Customer_Settings_ReadData()
{
  //***********************************Test report header*********************************
  testReportAddMiscInfoBlock("AUTOLIV ELECTRONICS document");
 TestReportAddMiscInfo("Nightly test", "No");
 TestReportAddMiscInfo("Test type", "Requirement-Based test");
 TestReportAddMiscInfo("Regression Test", "No");
 TestReportAddMiscInfo("Fault injection method used", "No");
 TestReportAddMiscInfo("Resource usage evaluation", "No");
 TestReportAddMiscInfo("Priority", "No");
 TestReportAddMiscInfo("Safety relevant", "No");
 TestReportAddMiscInfo("Test type", "automatic");
  
  AddRequirementInfo("Requirement under test", "ARCH_SW_DIA_0880; ARCH_SW_DIA_0881; ARCH_SW_DIA_0882; ARCH_SW_DIA_0883");
  AddRequirementInfo("ARCH_SW_DIA_0880", "Service 0x22 (Read Data By Identifier) will be implemented for DID 0138 (Customer Settings)");
  AddRequirementInfo("ARCH_SW_DIA_0881", "The Read Customer Settings service shall be available in the following sessions: ?Default Session (0x01) ?Programming (0x02) ?Extended Session (0x03) ?Supplier Session/Development Session (0x7E) ");
  AddRequirementInfo("ARCH_SW_DIA_0882", "The Read Customer Settings service shall be available under the following forms of Authentication: ?Supplier ?Development ENHANCED ?Production ?After-Sales ENHANCED ?After-Sales ");
  AddRequirementInfo("ARCH_SW_DIA_0883", "DataIdentifier of the Read Customer Settings shall be: 0x0138");
  //***************************************************************************************
  
    testCaseComment("Preconditions");
  testStep("STEP", "Bench Initialization");
  RunPreTs();
  //==================================================== 
  
    testCaseComment("Action: ARCH_SW_DIA_0880; ARCH_SW_DIA_0881; ARCH_SW_DIA_0882; ARCH_SW_DIA_0883");
  testStep("STEP", "Send diag request for 22 0138 and check response --> Response received.");
  SendDiagnosticRequest(dCustomerSettingsReadRequest, dCustomerSettingsReadResponse);
  CheckPositiveResponse("", dCustomerSettingsReadRequest, dCustomerSettingsReadResponse);
  
    //====================================================
  testCaseComment("Postcondition");
  testStep("STEP", "Return ECU to default values");
  RunPostTs();
  
  
}


testcase SW_IT_DIA_DataServices_Customer_Settings_Read_Customer_Settings_ReadDataLength()
{
  //***********************************Test report header*********************************
  testReportAddMiscInfoBlock("AUTOLIV ELECTRONICS document");
 TestReportAddMiscInfo("Nightly test", "No");
 TestReportAddMiscInfo("Test type", "Requirement-Based test");
 TestReportAddMiscInfo("Regression Test", "No");
 TestReportAddMiscInfo("Fault injection method used", "No");
 TestReportAddMiscInfo("Resource usage evaluation", "No");
 TestReportAddMiscInfo("Priority", "No");
 TestReportAddMiscInfo("Safety relevant", "No");
 TestReportAddMiscInfo("Test type", "automatic");
  
  AddRequirementInfo("Requirement under test", "ARCH_SW_DIA_0880; ARCH_SW_DIA_0884; ARCH_SW_DIA_0885; ARCH_SW_DIA_0886");
  AddRequirementInfo("ARCH_SW_DIA_0880", "Service 0x22 (Read Data By Identifier) will be implemented for DID 0138 (Customer Settings)");
  AddRequirementInfo("ARCH_SW_DIA_0884", "Response data length shall be 2 bytes long Note: Full Response length = 3 bytes + Response data length ");
  AddRequirementInfo("ARCH_SW_DIA_0885", "Byte #4: BltSlckDec_Md_xy_Stat_ST3 obs: Service shall not report the current value of signal, but the value of parameter stored in NVM xy = FL or FR ");
  AddRequirementInfo("ARCH_SW_DIA_0886", "Byte #5: PS_Curve_xy_Stat_ST3 obs: Service shall not report the current value of signal, but the value of parameter stored in NVM xy = FL or FR ");
  //***************************************************************************************
  
  
  testCaseComment("Preconditions");
  testStep("STEP", "Bench Initialization");
  RunPreTs();
  //==================================================== 
  
  testCaseComment("Action: ARCH_SW_DIA_0880; ARCH_SW_DIA_0884; ARCH_SW_DIA_0885; ARCH_SW_DIA_0886");
  testStep("STEP", "Send diag request for 22 0138 and check response --> Response received.");
  SendDiagnosticRequest(dCustomerSettingsReadRequest, dCustomerSettingsReadResponse);
  CheckPositiveResponse("", dCustomerSettingsReadRequest, dCustomerSettingsReadResponse);
  
    //====================================================
  testCaseComment("Postcondition");
  testStep("STEP", "Return ECU to default values");
  RunPostTs();
  
  
}

testcase SW_IT_DIA_DataServices_DID_01A2_Trust_model_CSR_Supplier_Signature_ReadData()
{
  //***********************************Test report header*********************************
  testReportAddMiscInfoBlock("AUTOLIV ELECTRONICS document");
 TestReportAddMiscInfo("Nightly test", "No");
 TestReportAddMiscInfo("Test type", "Requirement-Based test");
 TestReportAddMiscInfo("Regression Test", "No");
 TestReportAddMiscInfo("Fault injection method used", "No");
 TestReportAddMiscInfo("Resource usage evaluation", "No");
 TestReportAddMiscInfo("Priority", "No");
 TestReportAddMiscInfo("Safety relevant", "No");
 TestReportAddMiscInfo("Test type", "automatic");
  
  AddRequirementInfo("Requirement under test", "ARCH_SW_DIA_0890; ARCH_SW_DIA_0891; ARCH_SW_DIA_0892; ARCH_SW_DIA_0893");
  AddRequirementInfo("ARCH_SW_DIA_0890", "Service 0x22 (Read Data By Identifier) will be implemented for DID 01A2 (Trust Model CSR Supplier Signature)");
  AddRequirementInfo("ARCH_SW_DIA_0891", "The Read Trust Model CSR Supplier Signature service shall be available in the following sessions: ?Default Session (0x01) ?Extended Session (0x03) ?Supplier Session/Development Session (0x7E) ");
  AddRequirementInfo("ARCH_SW_DIA_0892", "The Read Trust Model CSR Supplier Signature service shall be available under the following forms of Authentication: ?Supplier ?Development ENHANCED ?Production ?After-Sales ENHANCED ");
  AddRequirementInfo("ARCH_SW_DIA_0893", "DataIdentifier of the Read Trust Model CSR Supplier Signature shall be: 0x01A2");
  //***************************************************************************************

  testCaseComment("Preconditions");
  testStep("STEP", "Bench Initialization");
  RunPreTs();
  //==================================================== 
  
  testCaseComment("Action: ARCH_SW_DIA_0890; ARCH_SW_DIA_0891; ARCH_SW_DIA_0892; ARCH_SW_DIA_0893");
  testStep("STEP", "Send diag request for 22 01A2 and check response --> Response received.");
  SendDiagnosticRequest(dTrustModelCSRSupplierSignatureReadRequest, dTrustModelCSRSupplierSignatureReadResponse);
  CheckPositiveResponse("", dTrustModelCSRSupplierSignatureReadRequest, dTrustModelCSRSupplierSignatureReadResponse);
  
    //====================================================
  testCaseComment("Postcondition");
  testStep("STEP", "Return ECU to default values");
  RunPostTs();
  
}

testcase SW_IT_DIA_DataServices_DID_01A2_Trust_model_CSR_Supplier_Signature_ReadDataLength()
{
  //***********************************Test report header*********************************
  testReportAddMiscInfoBlock("AUTOLIV ELECTRONICS document");
 TestReportAddMiscInfo("Nightly test", "No");
 TestReportAddMiscInfo("Test type", "Requirement-Based test");
 TestReportAddMiscInfo("Regression Test", "No");
 TestReportAddMiscInfo("Fault injection method used", "No");
 TestReportAddMiscInfo("Resource usage evaluation", "No");
 TestReportAddMiscInfo("Priority", "No");
 TestReportAddMiscInfo("Safety relevant", "No");
 TestReportAddMiscInfo("Test type", "automatic");
  
  AddRequirementInfo("Requirement under test", "ARCH_SW_DIA_0890; ARCH_SW_DIA_0894; ARCH_SW_DIA_0895; ARCH_SW_DIA_0896");
  AddRequirementInfo("ARCH_SW_DIA_0890", "Service 0x22 (Read Data By Identifier) will be implemented for DID 01A2 (Trust Model CSR Supplier Signature)");
  AddRequirementInfo("ARCH_SW_DIA_0894", "Response data length shall be 258 bytes long Note: Full Response length = 3 bytes + Response data length ");
  AddRequirementInfo("ARCH_SW_DIA_0895", "Bytes #4 - #131: ?Supplier Public Key ");
  AddRequirementInfo("ARCH_SW_DIA_0895", "Bytes #132 - #261: ?Supplier Signature ");

  //***************************************************************************************
  testCaseComment("Preconditions");
  testStep("STEP", "Bench Initialization");
  RunPreTs();
  //==================================================== 
  
  testCaseComment("Action: ARCH_SW_DIA_0890; ARCH_SW_DIA_0894; ARCH_SW_DIA_0895; ARCH_SW_DIA_0896");
  testStep("STEP", "Send diag request for 22 01A2 and check response --> Response received.");
  SendDiagnosticRequest(dTrustModelCSRSupplierSignatureReadRequest, dTrustModelCSRSupplierSignatureReadResponse);
  CheckPositiveResponse("", dTrustModelCSRSupplierSignatureReadRequest, dTrustModelCSRSupplierSignatureReadResponse);
  
    //====================================================
  testCaseComment("Postcondition");
  testStep("STEP", "Return ECU to default values");
  RunPostTs();
  
}

testcase SW_IT_DIA_DataServices_DID_01A2_Trust_model_CSR_Supplier_Signature_WriteData()
{
  //***********************************Test report header*********************************
  testReportAddMiscInfoBlock("AUTOLIV ELECTRONICS document");
 TestReportAddMiscInfo("Nightly test", "No");
 TestReportAddMiscInfo("Test type", "Requirement-Based test");
 TestReportAddMiscInfo("Regression Test", "No");
 TestReportAddMiscInfo("Fault injection method used", "No");
 TestReportAddMiscInfo("Resource usage evaluation", "No");
 TestReportAddMiscInfo("Priority", "No");
 TestReportAddMiscInfo("Safety relevant", "No");
 TestReportAddMiscInfo("Test type", "automatic");
  
  AddRequirementInfo("Requirement under test", "ARCH_SW_DIA_0900; ARCH_SW_DIA_0901; ARCH_SW_DIA_0902; ARCH_SW_DIA_0903; ARCH_SW_DIA_0904; ARCH_SW_DIA_0905; ARCH_SW_DIA_0906");
  AddRequirementInfo("ARCH_SW_DIA_0900", "Service 0x2E (Write Data By Identifier) will be implemented for DID 01A2 (Trust Model CSR Supplier Signature)");
  AddRequirementInfo("ARCH_SW_DIA_0901", "The Write Trust Model CSR Supplier Signature service shall be available in the following sessions:?Default Session (0x01)?Extended Session (0x03)?Supplier Session/Development Session (0x7E)");
  AddRequirementInfo("ARCH_SW_DIA_0902", "The Write Trust Model CSR Supplier Signature service shall be available under the following forms of Authentication:?Supplier");
  AddRequirementInfo("ARCH_SW_DIA_0903", "Bytes #2-#3: DataIdentifier of the Write Trust Model CSR Supplier Signature shall be: 0x01A2");
  AddRequirementInfo("ARCH_SW_DIA_0904", "Bytes #2-#3: DataIdentifier of the Write Trust Model CSR Supplier Signature shall be: 0x01A2");
  AddRequirementInfo("ARCH_SW_DIA_0904", "Bytes #4 - #131: ?Supplier Public KeY");
  AddRequirementInfo("ARCH_SW_DIA_0904", "Bytes #132 - #261:?Supplier Signature");

  //***************************************************************************************
  testCaseComment("Preconditions");
  testStep("STEP", "Bench Initialization");
  RunPreTs();
  //==================================================== 
  
  AuthenticateECU(1);
  
  testCaseComment("Action: ARCH_SW_DIA_0900; ARCH_SW_DIA_0901; ARCH_SW_DIA_0902; ARCH_SW_DIA_0903; ARCH_SW_DIA_0904; ARCH_SW_DIA_0905; ARCH_SW_DIA_0906");
  testStep("STEP", "Send diag request for 2E 01A2 and check response --> Response received.");
  SendDiagnosticRequest(dTrustModelCSRSupplierSignatureWriteRequest, dTrustModelCSRSupplierSignatureWriteResponse);
  CheckPositiveResponse("", dTrustModelCSRSupplierSignatureWriteRequest, dTrustModelCSRSupplierSignatureWriteResponse);
  
  //====================================================
  testCaseComment("Postcondition");
  testStep("STEP", "Return ECU to default values");
  RunPostTs();
}

testcase SW_IT_DIA_DataServices_Calibration_Identifications_CAL_ID_Read_CombinedDataElement_ReadData()
{
  //***********************************Test report header*********************************
  testReportAddMiscInfoBlock("AUTOLIV ELECTRONICS document");
 TestReportAddMiscInfo("Nightly test", "No");
 TestReportAddMiscInfo("Test type", "Requirement-Based test");
 TestReportAddMiscInfo("Regression Test", "No");
 TestReportAddMiscInfo("Fault injection method used", "No");
 TestReportAddMiscInfo("Resource usage evaluation", "No");
 TestReportAddMiscInfo("Priority", "No");
 TestReportAddMiscInfo("Safety relevant", "No");
 TestReportAddMiscInfo("Test type", "automatic");
  
  AddRequirementInfo("Requirement under test", "ARCH_SW_DIA_1000; ARCH_SW_DIA_1001; ARCH_SW_DIA_1002; ARCH_SW_DIA_1003");
  AddRequirementInfo("ARCH_SW_DIA_1000", "Service 0x22 (Read Data By Identifier) will be implemented for DID E104 (Calibration Identifications – CAL ID)");
  AddRequirementInfo("ARCH_SW_DIA_1001", "The Read Calibration Identifications (CAL ID) service shall be available in the following sessions: ?Default Session (0x01) ?Programming (0x02) ?Extended Session (0x03) ?Supplier Session/Development Session (0x7E) ");
  AddRequirementInfo("ARCH_SW_DIA_1002", "The Read Calibration Identifications (CAL ID) service shall be available under the following forms of Authentication: ?Supplier ?Development ENHANCED ?Production ?After-Sales ENHANCED ?After-Sales STANDARD ?After-Sales BASIC ?Internal Diagnostic Test Tool ?ePTI Test Tool ");
  AddRequirementInfo("ARCH_SW_DIA_1003", "DataIdentifier of the Read Calibration Identifications (CAL ID) shall be: 0xE104");
  //***************************************************************************************

  testCaseComment("Preconditions");
  testStep("STEP", "Bench Initialization");
  RunPreTs();
  //==================================================== 
  
  testCaseComment("Action: ARCH_SW_DIA_1000; ARCH_SW_DIA_1001; ARCH_SW_DIA_1002; ARCH_SW_DIA_1003");
  testStep("STEP", "Send diag request for 22 E104 and check response --> Response received.");
  SendDiagnosticRequest(dCalibrationIdentificationsCALIDReadRequest, dCalibrationIdentificationsCALIDReadResponse);
  CheckPositiveResponse("", dCalibrationIdentificationsCALIDReadRequest, dCalibrationIdentificationsCALIDReadResponse);
  
    //====================================================
  testCaseComment("Postcondition");
  testStep("STEP", "Return ECU to default values");
  RunPostTs();
}


testcase SW_IT_DIA_DataServices_Calibration_Identifications_CAL_ID_Read_CombinedDataElement_ReadDataLength()
{
  //***********************************Test report header*********************************
  testReportAddMiscInfoBlock("AUTOLIV ELECTRONICS document");
 TestReportAddMiscInfo("Nightly test", "No");
 TestReportAddMiscInfo("Test type", "Requirement-Based test");
 TestReportAddMiscInfo("Regression Test", "No");
 TestReportAddMiscInfo("Fault injection method used", "No");
 TestReportAddMiscInfo("Resource usage evaluation", "No");
 TestReportAddMiscInfo("Priority", "No");
 TestReportAddMiscInfo("Safety relevant", "No");
 TestReportAddMiscInfo("Test type", "automatic");
  
  AddRequirementInfo("Requirement under test", "ARCH_SW_DIA_1000; ARCH_SW_DIA_1004; ARCH_SW_DIA_1005");
  AddRequirementInfo("ARCH_SW_DIA_1000", "Service 0x22 (Read Data By Identifier) will be implemented for DID E104 (Calibration Identifications – CAL ID)");
  AddRequirementInfo("ARCH_SW_DIA_1004", "Response data length shall be 16 bytes long Note: Full Response length = 3 bytes + Response data length ");
  AddRequirementInfo("ARCH_SW_DIA_1005", "Bytes #4-#19: ?Calibration Identification ");
  //***************************************************************************************

  testCaseComment("Preconditions");
  testStep("STEP", "Bench Initialization");
  RunPreTs();
  //==================================================== 
  
  testCaseComment("Action: ARCH_SW_DIA_1000; ARCH_SW_DIA_1004; ARCH_SW_DIA_1005");
  testStep("STEP", "Send diag request for 22 E104 and check response --> Response received.");
  SendDiagnosticRequest(dCalibrationIdentificationsCALIDReadRequest, dCalibrationIdentificationsCALIDReadResponse);
  CheckPositiveResponse("", dCalibrationIdentificationsCALIDReadRequest, dCalibrationIdentificationsCALIDReadResponse);
  
    //====================================================
  testCaseComment("Postcondition");
  testStep("STEP", "Return ECU to default values");
  RunPostTs();
  
}

testcase SW_IT_DIA_DataServices_Dump_of_Vedoc_Relevant_Information_Read_PatchedObject_ReadData()
{
  //***********************************Test report header*********************************
  testReportAddMiscInfoBlock("AUTOLIV ELECTRONICS document");
 TestReportAddMiscInfo("Nightly test", "No");
 TestReportAddMiscInfo("Test type", "Requirement-Based test");
 TestReportAddMiscInfo("Regression Test", "No");
 TestReportAddMiscInfo("Fault injection method used", "No");
 TestReportAddMiscInfo("Resource usage evaluation", "No");
 TestReportAddMiscInfo("Priority", "No");
 TestReportAddMiscInfo("Safety relevant", "No");
 TestReportAddMiscInfo("Test type", "automatic");
  
  AddRequirementInfo("Requirement under test", "ARCH_SW_DIA_1010; ARCH_SW_DIA_1011; ARCH_SW_DIA_1012; ARCH_SW_DIA_1013");
  AddRequirementInfo("ARCH_SW_DIA_1010", "Service 0x22 (Read Data By Identifier) will be implemented for DID F103 (Vedoc Relevant Information)");
  AddRequirementInfo("ARCH_SW_DIA_1011", "The Read Vedoc Relevant Information shall be available in the following sessions: ?Default Session (0x01) ?Programming Session (0x02) ?Extended Session (0x03) ?Supplier Session/Development Session (0x7E) ");
  AddRequirementInfo("ARCH_SW_DIA_1012", "The Read Vedoc Relevant Information service shall be available under the following forms of Authentication: ?Supplier ?Development ENHANCED ?Production ?After-Sales ENHANCED ?After-Sales ?After-Sales BASIC ?Internal Diagnostic Test Tool ?ePTI Test Tool ");
  AddRequirementInfo("ARCH_SW_DIA_1013", "DataIdentifier of the Read Vedoc Relevant Information shall be: 0xF103");
  //***************************************************************************************
  
    testCaseComment("Preconditions");
  testStep("STEP", "Bench Initialization");
  RunPreTs();
  //==================================================== 
  
  testCaseComment("Action: ARCH_SW_DIA_1010; ARCH_SW_DIA_1011; ARCH_SW_DIA_1012; ARCH_SW_DIA_1013");
  testStep("STEP", "Send diag request for 22 F103 and check response --> Response received.");
  SendDiagnosticRequest(dVedocRelevantInformationReadRequest, dVedocRelevantInformationReadResponse);
  CheckPositiveResponse("", dVedocRelevantInformationReadRequest, dVedocRelevantInformationReadResponse);
  
    //====================================================
  testCaseComment("Postcondition");
  testStep("STEP", "Return ECU to default values");
  RunPostTs();
  

  
}


testcase SW_IT_DIA_DataServices_Dump_of_Vedoc_Relevant_Information_Read_PatchedObject_ReadDataLength()
{
  //***********************************Test report header*********************************
  testReportAddMiscInfoBlock("AUTOLIV ELECTRONICS document");
 TestReportAddMiscInfo("Nightly test", "No");
 TestReportAddMiscInfo("Test type", "Requirement-Based test");
 TestReportAddMiscInfo("Regression Test", "No");
 TestReportAddMiscInfo("Fault injection method used", "No");
 TestReportAddMiscInfo("Resource usage evaluation", "No");
 TestReportAddMiscInfo("Priority", "No");
 TestReportAddMiscInfo("Safety relevant", "No");
 TestReportAddMiscInfo("Test type", "automatic");
  
  AddRequirementInfo("Requirement under test", "ARCH_SW_DIA_1010; ARCH_SW_DIA_1014; ARCH_SW_DIA_1015; ARCH_SW_DIA_1016; ARCH_SW_DIA_1017; ARCH_SW_DIA_1018");
  AddRequirementInfo("ARCH_SW_DIA_1010", "Service 0x22 (Read Data By Identifier) will be implemented for DID F103 (Vedoc Relevant Information)");
  AddRequirementInfo("ARCH_SW_DIA_1014", "Response data length shall be 16 byte long Note: Full Response length = 3 bytes + Response data length ");
  AddRequirementInfo("ARCH_SW_DIA_1015", "Bytes #4-#13: Hardware Part Number [ASCII]");
  AddRequirementInfo("ARCH_SW_DIA_1016", "Byte #14: Constant [ASCII]");
  AddRequirementInfo("ARCH_SW_DIA_1017", "Bytes #15-#18: Hardware Supplier Identification [Hex to ASCII]");

  //***************************************************************************************
  
    testCaseComment("Preconditions");
  testStep("STEP", "Bench Initialization");
  RunPreTs();
  //==================================================== 
  
  testCaseComment("Action: ARCH_SW_DIA_1010; ARCH_SW_DIA_1014; ARCH_SW_DIA_1015; ARCH_SW_DIA_1016; ARCH_SW_DIA_1017; ARCH_SW_DIA_1018");
  testStep("STEP", "Send diag request for 22 F103 and check response --> Response received.");
  SendDiagnosticRequest(dVedocRelevantInformationReadRequest, dVedocRelevantInformationReadResponse);
  CheckPositiveResponse("", dVedocRelevantInformationReadRequest, dVedocRelevantInformationReadResponse);
  
    //====================================================
  testCaseComment("Postcondition");
  testStep("STEP", "Return ECU to default values");
  RunPostTs();
  

}

testcase SW_IT_DIA_runDid0340_UniqueSeatbeltSerialNumberWrite()
{
  //***********************************Test report header*********************************
  testReportAddMiscInfoBlock("AUTOLIV ELECTRONICS document");
 TestReportAddMiscInfo("Nightly test", "No");
 TestReportAddMiscInfo("Test type", "Requirement-Based test");
 TestReportAddMiscInfo("Regression Test", "No");
 TestReportAddMiscInfo("Fault injection method used", "No");
 TestReportAddMiscInfo("Resource usage evaluation", "No");
 TestReportAddMiscInfo("Priority", "No");
 TestReportAddMiscInfo("Safety relevant", "No");
 TestReportAddMiscInfo("Test type", "automatic");
  
  AddRequirementInfo("Requirement under test", "ARCH_SW_DIA_1020; ARCH_SW_DIA_1021; ARCH_SW_DIA_1022; ARCH_SW_DIA_1023; ARCH_SW_DIA_1024; ARCH_SW_DIA_1025");
  AddRequirementInfo("ARCH_SW_DIA_1020", "Service 0x2E (Write Data By Identifier) will be implemented for DID 0340 (Seat Belt Serial Number)");
  AddRequirementInfo("ARCH_SW_DIA_1021", "The Write Seat Belt Serial Number service shall be available in the following sessions: ?Supplier Session/Development Session (0x7E) ");
  AddRequirementInfo("ARCH_SW_DIA_1022", "The Write Seat Belt Serial Number service shall be available under the following forms of Authentication: ?Supplier ?Development ENHANCED ?Production ");
  AddRequirementInfo("ARCH_SW_DIA_1023", "Bytes #2-#3: DataIdentifier of the Write Seat Belt Serial Number shall be: 0x0340");
  AddRequirementInfo("ARCH_SW_DIA_1024", "Request data shall be 28 bytes long.Note: Full Request length = 3 bytes + Response data length");
  AddRequirementInfo("ARCH_SW_DIA_1025", "Bytes #4 - #31: Unique Seatbelt Serial Number [ASCII]");

  //***************************************************************************************
    testCaseComment("Preconditions");
  testStep("STEP", "Bench Initialization");
  RunPreTs();
  //==================================================== 
  
  EnterDiagnosticSession("development");
  
    testCaseComment("Action: ARCH_SW_DIA_1020; ARCH_SW_DIA_1021; ARCH_SW_DIA_1022; ARCH_SW_DIA_1023; ARCH_SW_DIA_1024; ARCH_SW_DIA_1025");
  testStep("STEP", "Send diag request for 2E 01A2 and check response --> Response received.");
  SendDiagnosticRequest(dSeatbeltSerialNumberWriteRequest, dSeatbeltSerialNumberWriteResponse);
  CheckPositiveResponse("", dSeatbeltSerialNumberWriteRequest, dSeatbeltSerialNumberWriteResponse);
     //====================================================
  testCaseComment("Postcondition");
  testStep("STEP", "Return ECU to default values");
  RunPostTs();
  
}


testcase SW_IT_DIA_RoutineServices_Routine_Clear_Resource_Consumption_Data_Start_Start()
{
  //***********************************Test report header*********************************
  testReportAddMiscInfoBlock("AUTOLIV ELECTRONICS document");
 TestReportAddMiscInfo("Nightly test", "No");
 TestReportAddMiscInfo("Test type", "Requirement-Based test");
 TestReportAddMiscInfo("Regression Test", "No");
 TestReportAddMiscInfo("Fault injection method used", "No");
 TestReportAddMiscInfo("Resource usage evaluation", "No");
 TestReportAddMiscInfo("Priority", "No");
 TestReportAddMiscInfo("Safety relevant", "No");
 TestReportAddMiscInfo("Test type", "automatic");
  
  AddRequirementInfo("Requirement under test", "ARCH_SW_DIA_1030; ARCH_SW_DIA_1031; ARCH_SW_DIA_1032; ARCH_SW_DIA_1033; ARCH_SW_DIA_1034; ARCH_SW_DIA_1035; ARCH_SW_DIA_1036");
  AddRequirementInfo("ARCH_SW_DIA_1030", "Service 0x31 (Routine Control) 0x31 01 Start for RID 0x0211 (Clear Resource Consumption Data) will be implemented ");
  AddRequirementInfo("ARCH_SW_DIA_1031", "RoutineIdentifier shall be 0x0211.");
  AddRequirementInfo("ARCH_SW_DIA_1032", "The folowing request shall be available for this RID: - Start Routine (01) ");
  AddRequirementInfo("ARCH_SW_DIA_1033", "Bytes #2-#3: DataIdentifier of the Write Seat Belt Serial Number shall be: 0x0340");
  AddRequirementInfo("ARCH_SW_DIA_1034", "Routine Start shall be available under the following forms of Authentication: ?Supplier ?Development ENHANCED ");
  AddRequirementInfo("ARCH_SW_DIA_1035", "Routine Start shall be responsible to reset all resource data that is provided by the DIDs 0x01E0, 0x01E1, 0x01E2 and 0x01E3.");
  AddRequirementInfo("ARCH_SW_DIA_1036", "RID specific Routine Start Result shall be represented by the following: ?Byte 0: Routine Info ");

  //***************************************************************************************
  
        
  testCaseComment("Preconditions");
  testStep("STEP", "Bench Initialization");
  RunPreTs();
  //==================================================== 
  testStep("STEP", "Enter development session.");
  EnterDiagnosticSession("development");
  
  testCaseComment("Action: ARCH_SW_DIA_1030; ARCH_SW_DIA_1031; ARCH_SW_DIA_1032; ARCH_SW_DIA_1033; ARCH_SW_DIA_1034; ARCH_SW_DIA_1035; ARCH_SW_DIA_1036");
  testStep("STEP", "Send diag request for Routine Start for RID 0211 and check response --> Response received.");
  SendDiagnosticRequest(dClearResourceConsumptionDataStartRequest, dClearResourceConsumptionDataStartResponse);
  CheckPositiveResponse("", dClearResourceConsumptionDataStartRequest, dClearResourceConsumptionDataStartResponse);
  
    //====================================================
  testCaseComment("Postcondition");
  testStep("STEP", "Return ECU to default values");
  RunPostTs();
  
}
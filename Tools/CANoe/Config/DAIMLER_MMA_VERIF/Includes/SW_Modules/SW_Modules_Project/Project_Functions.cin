/*@!Encoding:1252*/

variables
{
  //HESS
  int iHESSport = 6;
  int iBaudrateHESS = 9600;   
  int iParityHESS = 0;	
  int iStopbitHESS = 1;
	int iByteSizeHESS = 8;
  
  enum NM_STATE {
    BUS_SLEEP         = 1,
    PREPARE_BUS_SLEEP = 2,
    READY_SLEEP       = 3,
    NORMAL_OPERATION  = 4,
    REPEAT_MESSAGE    = 5
  };
  
  byte After_Buckle_Delay[1] = 0x14;
  byte After_MD_Delay[1] = 0x02;
  byte After_PowerTrain_Delay[1] = 0x14;
  byte BSR_1_Acceleration_Timeout[1] = 0x1E;
  
  byte bReleaseProfilesConfiguration[147] = {0x2E, 0x03, 0x01, 
    0x29, 0x20, 0x00, 0xFF, 0x74, 0x75, 0x76, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
    0x29, 0x20, 0x00, 0xFF, 0x74, 0x75, 0x76, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
    0x29, 0x20, 0x00, 0xFF, 0x74, 0x75, 0x76, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
    0x29, 0x20, 0x00, 0xFF, 0x77, 0x76, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
    0x00, 0x0A, 0xF5, 0x84, 0x00, 0x10, 0xFF, 0xFF, 0x00, 0x32, 0xF5, 0x24, 
    0x00, 0x10, 0xFF, 0xFF, 0x00, 0x0A, 0x00, 0x80, 0x00, 0x00, 0xFF, 0xFF, 
    0x00, 0x0A, 0xF5, 0x04, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF
  };
  
  byte bRBSRProfilesConfiguration[236] = {0x2E, 0x03, 0x02, 
    0x18, 0x23, 0x00, 0x1D, 0x5C, 0x5D, 0x5E, 0x5F, 0x60, 0x61, 0x62, 0xFF, 
    0x18, 0x23, 0x00, 0x1D, 0x5C, 0x5D, 0x5E, 0x5F, 0x60, 0x61, 0x62, 0xFF, 
    0x18, 0x23, 0x00, 0x1D, 0x5C, 0x5D, 0x5E, 0x5F, 0x60, 0x61, 0x62, 0xFF, 
    0x00, 0x02, 0x03, 0x04, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x46, 0x0C, 0x84, 
    0x38, 0x10, 0xFF, 0xFF, 0x00, 0x82, 0x0C, 0x84, 0x38, 0x10, 0xFF, 0xFF, 
    0x01, 0xF4, 0x08, 0x81, 0x18, 0x10, 0xFF, 0xFF, 0x03, 0xE8, 0x0C, 0x14,
    0x38, 0x00, 0xFF, 0xFF, 0x00, 0x64, 0x0E, 0x84, 0x64, 0x10, 0xFF, 0xFF, 
    0x00, 0x0A, 0x00, 0x84, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
    0x14, 0x02, 0x14, 0x1E, 0x00
  };

  byte bTensioningProfileConfiguration[1076] = {0x2E, 0x03, 0x00, 
    0x18, 0x23, 0x10, 0x1D, 0x00, 0x01, 0x02, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
    0x18, 0x23, 0x10, 0x1D, 0x03, 0x01, 0x02, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0x18, 0x23, 0x10, 0x1D, 0x04, 0x05, 0x01, 0x02, 0xFF, 0xFF, 0xFF, 0xFF,
    0x18, 0x23, 0x10, 0x1D, 0x13, 0x14, 0x01, 0x02, 0xFF, 0xFF, 0xFF, 0xFF,
    0x18, 0x23, 0x10, 0x1D, 0x11, 0x12, 0x01, 0x02, 0xFF, 0xFF, 0xFF, 0xFF,
    0x18, 0x23, 0x10, 0x1D, 0x15, 0x16, 0x01, 0x02, 0xFF, 0xFF, 0xFF, 0xFF,
    0x24, 0x23, 0x10, 0xFF, 0x0E, 0x0F, 0x17, 0x02, 0xFF, 0xFF, 0xFF, 0xFF,
    0x18, 0x23, 0x10, 0x1D, 0x11, 0x12, 0x01, 0x02, 0xFF, 0xFF, 0xFF, 0xFF,
    0x18, 0x23, 0x10, 0x1D, 0x11, 0x12, 0x01, 0x02, 0xFF, 0xFF, 0xFF, 0xFF,
    0x18, 0x23, 0x10, 0x1D, 0x11, 0x12, 0x01, 0x02, 0xFF, 0xFF, 0xFF, 0xFF,
    0x18, 0x23, 0x10, 0x1D, 0x11, 0x12, 0x01, 0x02, 0xFF, 0xFF, 0xFF, 0xFF,
    0x18, 0x23, 0x10, 0x1D, 0x11, 0x12, 0x01, 0x02, 0xFF, 0xFF, 0xFF, 0xFF,
    0x18, 0x23, 0x10, 0x1D, 0x11, 0x12, 0x01, 0x02, 0xFF, 0xFF, 0xFF, 0xFF,
    0x18, 0x23, 0x10, 0x1D, 0x11, 0x12, 0x01, 0x02, 0xFF, 0xFF, 0xFF, 0xFF,
    0x18, 0x23, 0x10, 0x1D, 0x06, 0x07, 0x09, 0x02, 0xFF, 0xFF, 0xFF, 0xFF,
    0x18, 0x23, 0x10, 0x1D, 0x06, 0x07, 0x09, 0x02, 0xFF, 0xFF, 0xFF, 0xFF,
    0x18, 0x23, 0x10, 0x1D, 0x06, 0x07, 0x09, 0x02, 0xFF, 0xFF, 0xFF, 0xFF,
    0x18, 0x23, 0x10, 0x1D, 0x06, 0x07, 0x09, 0x02, 0xFF, 0xFF, 0xFF, 0xFF,
    0x46, 0x23, 0x00, 0x1D, 0x0A, 0x0B, 0x0C, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0x46, 0x23, 0x00, 0x1D, 0x0D, 0x0C, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0x46, 0x23, 0x00, 0x1D, 0x0A, 0x0B, 0x0C, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0x46, 0x23, 0x00, 0x1D, 0x0D, 0x0C, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0x46, 0x23, 0x00, 0x1D, 0x0A, 0x0B, 0x0C, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0x46, 0x23, 0x00, 0x1D, 0x0D, 0x0C, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0x46, 0x23, 0x00, 0x1D, 0x0A, 0x0B, 0x0C, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0x46, 0x23, 0x00, 0x1D, 0x0D, 0x0C, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0x00, 0xC8, 0x38, 0x84, 0xF0, 0x00, 0xFF, 0xFF,
    0x0D, 0xAC, 0x1A, 0x09, 0x00, 0x00, 0xFF, 0xFF,
    0x00, 0x0A, 0x00, 0x84, 0x00, 0x00, 0xFF, 0xFF,
    0x00, 0x28, 0x2C, 0x84, 0xF4, 0x00, 0xFF, 0xFF,
    0x00, 0x0A, 0x2C, 0x84, 0xF0, 0x00, 0xFF, 0xFF,
    0x00, 0x28, 0x20, 0x01, 0x00, 0x10, 0xFF, 0xFF,
    0x00, 0x0A, 0x08, 0x04, 0x00, 0x00, 0xFF, 0xFF,
    0x00, 0x50, 0x12, 0x84, 0xBC, 0x00, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0x0D, 0xAC, 0x0A, 0x09, 0x00, 0x00, 0xFF, 0xFF,
    0x00, 0x1E, 0x16, 0x84, 0xAC, 0x00, 0xFF, 0xFF,
    0x00, 0x64, 0x16, 0x04, 0xAC, 0x00, 0xFF, 0xFF,
    0x00, 0x06, 0x04, 0x04, 0x00, 0x00, 0xFF, 0xFF,
    0x00, 0x03, 0x11, 0x04, 0x00, 0x00, 0xFF, 0xFF,
    0x00, 0x01, 0x2C, 0x01, 0x01, 0x00, 0xFF, 0xFF,
    0x00, 0x23, 0x46, 0x01, 0x01, 0x00, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0x00, 0x02, 0x39, 0x84, 0xFC, 0x00, 0xFF, 0xFF,
    0x00, 0x28, 0x3C, 0x01, 0x00, 0x10, 0xFF, 0xFF,
    0x00, 0x02, 0x39, 0x84, 0xF4, 0x00, 0xFF, 0xFF,
    0x00, 0x28, 0x30, 0x01, 0x00, 0x10, 0xFF, 0xFF,
    0x00, 0x01, 0x2C, 0x01, 0x01, 0x00, 0xFF, 0xFF,
    0x00, 0x13, 0x46, 0x01, 0x01, 0x00, 0xFF, 0xFF,
    0x01, 0xF4, 0x1A, 0x09, 0x00, 0x00, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xF4, 0x01, 0xE8, 0x03, 0xE8, 0x03, 0xE8, 0x03, 0xE8, 0x03, 0x00, 0x1E, 0x1E, 0x1E, 0x01, 0x11, 0x11, 0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
  };
  
  // addresses to be set as start values and changed to their respective HW module folder
    //Multimeter 
  char sMultimeterAddress[100] = "USB0::0x164E::0x0DAD::TW00041293::INSTR"; 
  
  //Signal generator 
  char sSignalGeneratorAddress[100] = "USB::0x0699::0x034A::C020918::INSTR";  
  //---------------------------------------------------------------------------------------------
  byte bStorageConditionsStatus[4] = {0x70, 0x00, 0xBF, 0xC4}; // ERH_u16StorageConditionStatus
  
  byte bCurrentDeficiencylevel[4] = {0x70, 0x00, 0x88, 0x94}; // Rte_Irv_PMP_u32DeficiencyLevel
  byte bCurrentDeficiencylevelSize = 4;
  
  byte _u8BatteryVoltageSurveyState[4] = {0x70, 0x00, 0x82, 0x78}; // app.map_tag[pmp_stBatterySurveyParam,1,+9,FALSE]  
  // Variables used for 'DetectCycleStep' output.
  const CYCLE_DETECT_ERROR               = 0xFF; // Can be incorrect input, MF block not active, etc.
  const CYCLE_NOT_DETECTED               = 0x00;
  const CYCLE_DETECTED_STEP_NOT_DETECTED = 0x1F;
  const CYCLE_DETECTED                   = 0x10;
  const CYCLE_AND_STEP_DETECTED          = 0x11;
  
  // Variables used for create/remove fault functions.
  const ACTIVATION                       = 0x01;
  const RELEASING                        = 0x11;
  const TENSIONING                       = 0x12;
  const STARTUP                          = 0x13;
  const NO_ACTIVATION                    = 0x02;
  const PHISICALLY                       = 0x03;
  const PS                               = 0x04;
  enum IMPLAUSIBLE_DATA {CRC = 1, SQC = 2, SNA = 3, FLT = 4, CRC_NO_WAIT = 10, SQC_NO_WAIT = 20, SNA_NO_WAIT = 30, FLT_NO_WAIT = 40};
  enum TIMEOUT {TIMEOUT_NO_WAIT = 0xAA};
  
  const PRESAFE                          = 0x01;
  const API                              = 0x92;
  const DIAG                             = 0x03;
  const DIAG_INTERNAL                    = 0x04;
  const ORC                              = 0x05;
  const ALGO                             = 0x06;
  const FUNCTION                         = 0x59;
  
  const Disable                          = 0x81;
  const Enable                           = 0x82;
  const Disable_ORC                      = 0x83;
  const Enable_ORC                       = 0x84;
  const Left                             = 0x85;
  const Right                            = 0x86;
  const BSR                              = 0x87;
  const Belt_handover                    = 0x88;
  const HapticWarning_Left               = 0x89;
  const HapticWarning_Right              = 0x8A;
  
  const Undervoltage_Thrs                = 0x8B;
  const Undervoltage_Abort_Thrs          = 0x8C;
  const Overvoltage_Thrs                 = 0x8D;
  const Overvoltage_Abort_Thrs           = 0x8E;
  
  const Display       = 0x8F;
  const Counter       = 0x90;
  const CRC_VEH       = 0x91;
  const Steering_Side = 0x93;
  
  const PRE_SAFE_5_Duration = 0x94;
  const HAPTIC_WARNING1_P1_DURATION = 0x95;
  const HAPTIC_WARNING2_P1_DURATION = 0x96;
  const HAPTIC_WARNING3_P1_DURATION = 0x97;
  const HAPTIC_WARNING4_P1_DURATION = 0x98;
  const PRESAFE_acceleration_timeout = 0x99;
  const HWA1_acceleration_timeout = 0x9A;
  const API_acceleration_timeout = 0x9B;
  const Associatedcounter = 0x9C;
  
  const PRESAFE_memory_location = 0x9D;
  const BSR_memory_location = 0x9E;
  const Release_memory_location = 0x9F;
  const EEPROM = 0xA0;
  const ROM = 0xA1;
  
  const BSR_buckle_delay = 0xA2;
  const BSR_MD_delay = 0xA3;
  const BSR_Powertrain_delay = 0xA4;
  const BSR_acceleration_timeout = 0xA5;
  
  const Haptic_type = 0xA6;
  const Fixed = 1234;
  const Not_fixed_HWA_1 = 2345;
  const Not_fixed_HWA_2 = 3456;
  const Not_fixed_HWA_3 = 4567;
  const Not_fixed_HWA_4 = 5678;
  
//  byte bVehicleEquipmentData[19] = {0x2E, 0x03, 0x10, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0xFB, 0x07, 0x2D, 0x0E, 0x5A, 0x0C, 0xC2}; // R5.0 OV and OV threhsolds are inversed
//  byte bVehicleEquipmentData[19] = {0x2E, 0x03, 0x10, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x2D, 0x05, 0xFB, 0x0C, 0xC2, 0x0E, 0x5A}; // R5.1 UV and UV threhsolds are inversed now, OV thresh no longer inversed
//  byte bVehicleEquipmentData[19] = {0x2E, 0x03, 0x10, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0xFB, 0x07, 0x2D, 0x0C, 0xC2, 0x0E, 0x5A}; // R6.0 EEROM
  byte bVehicleEquipmentData[19] = {0x2E, 0x03, 0x10, 0x01, 0x00, 0x00, 0x00, 0x00, 0xE0, 0x00, 0x00, 0x05, 0xFB, 0x07, 0x2D, 0x0C, 0xC2, 0x0E, 0x5A}; // R6.0 ROM
  
  byte bClearVehicleEquipmentData[19] = {0x2E, 0x03, 0x10, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF}; // empty
  
  byte bClearHBCalibration[43]   = {0x2E, 0xFD, 0x31, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF};
  byte bDefaultHBCalibration[43] = {0x2E, 0xFD, 0x31, 0x32, 0x00, 0x89, 0x00, 0x36, 0x01, 0xFF, 0x03, 0xFF, 0x03, 0x33, 0x00, 0x7B, 0x00, 0x08, 0x01, 0x8A, 0x02, 0xFF, 0x03, 0x00, 0x00, 0x56, 0x04, 0x18, 0x08, 0x01, 0x1C, 0x01, 0x1C, 0x00, 0x00, 0x47, 0x03, 0xAC, 0x07, 0x4E, 0x14, 0x98, 0x20};
  
  const byte bVEH_RHD = 0;
  const byte bVEH_LHD = 1;
  
  enum Undervoltage {
    Voltage_7_5 = 90, 
    Voltage_7_6,
    Voltage_7_7,
    Voltage_7_8,
    Voltage_7_9,
    Voltage_8_0,
    Voltage_8_1,
    Voltage_8_2,
    Voltage_8_3,
    Voltage_8_4,
    Voltage_8_5,
    Voltage_8_6,
    Voltage_8_7,
    Voltage_8_8,
    Voltage_8_9,
    Voltage_9_0,
    Voltage_9_1,
    Voltage_9_2,
    Voltage_9_3,
    Voltage_9_4,
    Voltage_9_5,
    Voltage_9_6,
    Voltage_9_7,
    Voltage_9_8,
    Voltage_9_9,
    Voltage_10_0
  };
  enum Overvoltage {
    Voltage_16_0 = 120,
    Voltage_16_1,
    Voltage_16_2,
    Voltage_16_3,
    Voltage_16_4,
    Voltage_16_5,
    Voltage_16_6,
    Voltage_16_7,
    Voltage_16_8,
    Voltage_16_9,
    Voltage_17_0,
    Voltage_17_1,
    Voltage_17_2,
    Voltage_17_3,
    Voltage_17_4,
    Voltage_17_5,
    Voltage_17_6,
    Voltage_17_7,
    Voltage_17_8,
    Voltage_17_9,
    Voltage_18_0
  };
  
  message Meas8_RBTM_FL_ST3 MeasurementFrameFL;
  message Meas8_RBTM_FR_ST3 MeasurementFrameFR;
  
  diagRequest * dRequest;
  diagResponse * dResponse;
  
  //Dignostic session control
//  diagRequest Default_Start dDefaultSessionRequest;
//  diagResponse Default_Start dDefaultSessionResponse;
//    
//  diagRequest Extended_Start dExtendedSessionRequest;
//  diagResponse Extended_Start dExtendedSessionResponse;
//  
//  diagRequest ProgrammingStart dProgrammingSessionRequest;
//  diagResponse ProgrammingStart dProgrammingSessionResponse;
//  
//  diagRequest Update_Start dUpdateSessionRequest;
//  diagResponse Update_Start dUpdateSessionResponse;  
  
//  diagRequest Development_Start dDevelopmentSessionRequest;
//  diagResponse Development_Start dDevelopmentSessionResponse;
  
  //Control DTC Setting  
  diagRequest DTC_Setting_Mode_On_Control dDTCEnableRequest;
  diagResponse DTC_Setting_Mode_On_Control dDTCEnableResponse;  
  
  diagRequest DTC_Setting_Mode_Off_Control dDTCDisableRequest;
  diagResponse DTC_Setting_Mode_Off_Control dDTCDisableResponse;  
  
  //Read DTC Snapshot
  diagRequest FaultMem_ReportDTCSnapshotRecordByDTCNbr  dFaultMem_ReportDTCSnapshotRecordByDTCNbrRequest;
  diagResponse FaultMem_ReportDTCSnapshotRecordByDTCNbr  dFaultMem_ReportDTCSnapshotRecordByDTCNbrResponse;
  
  //Read DTC Extended
  diagRequest FaultMem_ReportDTCExtendedDataByDTCNbr  dFaultMem_ReportDTCExtendedDataByDTCNbrRequest;
  diagResponse FaultMem_ReportDTCExtendedDataByDTCNbr  dFaultMem_ReportDTCExtendedDataByDTCNbrResponse;  
  
  // ECU reset.
//  diagRequest HardReset dHardResetRequest;
//  diagResponse HardReset dHardResetResponse;
//  
//  diagRequest SoftReset dSoftResetRequest;
//  diagResponse SoftReset dSoftResetResponse;
  
  //Clear Diagnostic Information
  diagRequest FaultMem_ClearGroup dFaultMemClearGroupRequest;
  diagResponse FaultMem_ClearGroup dFaultMemClearGroupResponse;
  
  //RDBLI
//  // Software version
//  diagRequest SoftwareVersion_Read dReadSWVersionRequest;
//  diagResponse SoftwareVersion_Read dReadSWVersionResponse;
  
  //HSM Identification Read
  diagRequest HSM_Identification_Read dHSMIdentificationReadRequest;
  diagResponse  HSM_Identification_Read dHSMIdentificationReadResponse;
  
  //Reprogramming Attempt Counter
  diagRequest Reprogramming_Attempt_Counter_Read  dReprogrammingAttemptCounterReadRequest;  
  diagResponse  Reprogramming_Attempt_Counter_Read  dReprogrammingAttemptCounterReadResponse;
  
  //Read Adjust ISO 15765-2 Block Size and STmin Parameter
  diagRequest Adjust_ISO_15765_2_Block_Size_and_STmin_Parameter_Read  dAdjustISO15765_2BlockSizeAndSTminParameterReadRequest;
  diagResponse  Adjust_ISO_15765_2_Block_Size_and_STmin_Parameter_Read  dAdjustISO15765_2BlockSizeAndSTminParameterReadResponse;
  
  //Vehicle Odometer in Low resolution
  diagRequest Vehicle_Odometer_in_Low_Resolution_Read dVehicleOdometerInLowResolutionReadRequest;
  diagResponse  Vehicle_Odometer_in_Low_Resolution_Read dVehicleOdometerInLowResolutionReadResponse;
  
  //Hardware Version Information
  diagRequest HardwareVersion_Read dHardwareVersionInformationRequest;
  diagResponse HardwareVersion_Read dHardwareVersionInformationResponse;  
  
  diagRequest Hardware_Version_Information_Write  dHardwareVersionInformationWriteRequest;
  diagResponse Hardware_Version_Information_Write dHardwareVersionInformationWriteResponse;
  
  //Sofware Version Information
  diagRequest SoftwareVersion_Read dSofwareVersionInformationRequest;
  diagResponse SoftwareVersion_Read dSofwareVersionInformationResponse;  
  
  //Boot Software Version Information
  diagRequest BootSoftwareVersion_Read dBootSoftwareVersionInformationRequest;
  diagResponse BootSoftwareVersion_Read dBootSoftwareVersionInformationResponse;    
  
  //Security access
//  diagRequest Request_Seed_Reprogramming dRequestSeedReprogrammingRequest;
//  diagResponse Request_Seed_Reprogramming dRequestSeedReprogrammingResponse;
    
//  diagRequest Send_Key_Reprogramming dSendKeyReprogrammingRequest;
//  diagResponse Send_Key_Reprogramming dSendKeyReprogrammingResponse;    
  
  // ECU Location 
  diagRequest ECU_Location_Read dReadECULocationRequest;
  diagResponse ECU_Location_Read dReadECULocationResponse;
  
  diagRequest ECU_Location_Write dECULocationWriteRequest;
  diagResponse ECU_Location_Write dECULocationWriteResponse;    
  
  // Last SW reset Cause
  diagRequest Reset_Cause_Management_Read dReadLastSWResetCausesRequest;
  diagResponse Reset_Cause_Management_Read dReadLastSWResetCausesResponse;
  
  // Last Warm reset parameters
  diagRequest Last_Warm_Reset_Parameters_Read dReadLastWarmResetParametersRequest;
  diagResponse Last_Warm_Reset_Parameters_Read dReadLastWarmResetParametersResponse;
    
  // Seatbelt serial number.
  diagRequest Seatbelt_Serial_Number_Read dSeatbeltSerialNumberRequest;
  diagResponse Seatbelt_Serial_Number_Read dSeatbeltSerialNumberResponse;
     
  // ECU serial number Read
  diagRequest ECUSerialNumberDataIdentifier_Read dECUSerialNumberRequest;
  diagResponse ECUSerialNumberDataIdentifier_Read dECUSerialNumberResponse;
  
  // ECU serial number Write
  diagRequest ECUSerialNumberDataIdentifier_Write dECUSerialNumberWriteRequest;
  diagResponse ECUSerialNumberDataIdentifier_Write dECUSerialNumberWriteResponse;  
  
  //Global time sync measured values read
  diagRequest Global_Time_Sync_Measured_Values_Read dGlobalTimeSyncValuesRequest;
  diagResponse Global_Time_Sync_Measured_Values_Read dGlobalTimeSyncValuesResponse;
  
  //Current Operation Time Read
  diagRequest Current_Operating_Time_Read dCurrentOperationTimeReadRequest;
  diagResponse Current_Operating_Time_Read dCurrentOperationTimeReadResponse;
  
  //Obsolescence Data
  diagRequest Obsolescence_Data_Read  dObsolescenceDataReadRequest;
  diagResponse Obsolescence_Data_Read dObsolescenceDataReadResponse;  
  
  //Availability Data
  diagRequest Availability_Data_Read dAvailabilityDataRequest;
  diagResponse Availability_Data_Read dAvailabilityDataResponse;
  
  //Read Task Response Time
  diagRequest Task_Response_Time_Read dTaskResponseTimeReadRequest;
  diagResponse  Task_Response_Time_Read dTaskResponseTimeReadResponse;
  
  //System Time Read
  diagRequest System_Time_read_Read dSystemTimeReadRequest;
  diagResponse  System_Time_read_Read dSystemTimeReadResponse;
  
  //ECU Extract Version
  diagRequest ECU_Extract_Version_Read  dECUExtractVersionReadRequest;
  diagResponse  ECU_Extract_Version_Read  dECUExtractVersionReadResponse;
  
  //Read Diagnostic Extract Version
  diagRequest Diagnostic_Extract_Version_Read dDiagnosticExtractVersionReadRequest;
  diagResponse  Diagnostic_Extract_Version_Read ddDiagnosticExtractVersionReadResponse;
  
  //Read Standard Application SW Package Information
  diagRequest Standard_Application_SW_Package_Information_Read  dStandardApplicationSWPackageInformationReadRequest;
  diagResponse Standard_Application_SW_Package_Information_Read  dStandardApplicationSWPackageInformationReadResponse;
  
  //Read Minimum SW Version
  diagRequest Minimum_Software_Version_Read dMinimumSoftwareVersionReadRequest;
  diagResponse  Minimum_Software_Version_Read dMinimumSoftwareVersionReadResponse;
  
  //Read Active Diagnostic Information
  diagRequest ActiveDiagnosticInformation_Read  dActiveDiagnosticInformationReadRequest;
  diagResponse  ActiveDiagnosticInformation_Read  dActiveDiagnosticInformationReadResponse;
  
  //Read ECU Name
  diagRequest ECU_Name_Read dECUNameReadRequest;
  diagResponse  ECU_Name_Read dECUNameReadResponse;
  
  //Read DDS Package Release
  diagRequest DDS_Package_Release_Read  dDDSPackageReleaseReadRequest;
  diagResponse  DDS_Package_Release_Read  dDDSPackageReleaseReadResponse;
  
  //Read MBC ECU Identification Hardware Part Number
  diagRequest MercedesCarGroupHardware_Read dMercedesCarGroupHardwareReadRequest;
  diagResponse  MercedesCarGroupHardware_Read dMercedesCarGroupHardwareReadResponse;
  
  //Read MBC ECU Identification Software Logical Block Part Number
  diagRequest MercedesCarGroupSoftware_Read dMercedesCarGroupSoftwareReadRequest;
  diagResponse  MercedesCarGroupSoftware_Read dMercedesCarGroupSoftwareReadResponse;
  
  //Read Reprogramming Capabilities
  diagRequest Reprogramming_capabilities_Read dReprogrammingCapabilitiesReadRequest;
  diagResponse  Reprogramming_capabilities_Read dReprogrammingCapabilitiesReadResponse;
  
  //Read Supported Configuration Mechanisms
  diagRequest Supported_configuration_mechanisms_Read dSupportedConfigurationMechanismsReadRequest;
  diagResponse  Supported_configuration_mechanisms_Read dSupportedConfigurationMechanismsReadResponse;
  
  //Read Hardware Supplier Identification
  diagRequest HardwareSupplier_Read dHardwareSupplierReadRequest;
  diagResponse  HardwareSupplier_Read dHardwareSupplierReadResponse;  
  
  //Read Software Supplier Identification
  diagRequest SoftwareSupplier_Read dSoftwareSupplierReadRequest;
  diagResponse  SoftwareSupplier_Read dSoftwareSupplierReadResponse;
  
  //Read Software Fingerprint
  diagRequest ReadFingerprint_Read  dReadFingerprintReadRequest;
  diagResponse  ReadFingerprint_Read  dReadFingerprintReadResponse;
  
  
  //Read CPU Load
  diagRequest CPU_Load_Read dCPULoadReadRequest;
  diagResponse CPU_Load_Read dCPULoadReadResponse;
  
  //Read E2E Timing
  diagRequest E2E_Timing_Read dE2ETimingReadRequest;
  diagResponse E2E_Timing_Read dE2ETimingReadResponse;  
  
  //Read Stack Load  
  diagRequest Stack_Load_Read dStackLoadReadRequest;
  diagResponse Stack_Load_Read dStackLoadReadResponse;
  
  //Read Memory usage Cycles
  diagRequest Memory_Usage_Cycles_Read dMemoryUsageCyclesReadRequest;
  diagResponse Memory_Usage_Cycles_Read dMemoryUsageCyclesReadResponse;  
  
  //Read CAN Input
  diagRequest CAN_input_Read  dCANinputReadRequest;
  diagResponse CAN_input_Read dCANinputReadResponse;    
  
  //Read CAN Output
  diagRequest CAN_output_Read  dCANOutputReadRequest;
  diagResponse CAN_output_Read dCANOutputReadResponse;   
  
  //Read HW Input
  diagRequest HW_input_Read dHWInputReadRequest;
  diagResponse HW_input_Read  dHWInputReadResponse;
    
  //Read Internal ECU Information
  diagRequest Internal_ECU_information_Read dInternalECUInformationReadRequest;
  diagResponse Internal_ECU_information_Read  dInternalECUInformationReadResponse;  
    
  //Certificate Identification
  diagRequest Certificate_Identification dCertificateIdentificationRequest;
  diagResponse Certificate_Identification dCertificateIdentificationResponse;
  
  //Verification Certificate
  diagRequest Verification_Certificate dVerificationCertificateRequest;
  diagResponse Verification_Certificate dVerificationCertificateResponse;
  
  //Verification Signature
  diagRequest Verification_Signature dVerificationSignatureRequest;
  diagResponse Verification_Signature dVerificationSignatureResponse;  
  
  //Last Requested Pre-Safe Cycle Record1 
  diagRequest PRE_SAFE_Recorder_1_read_Read dPRE_SAFERecorder1ReadRequest;
  diagResponse PRE_SAFE_Recorder_1_read_Read dPRE_SAFERecorder1ReadResponse;  
  
  //Last Requested Pre-Safe Cycle Record2
  diagRequest PRE_SAFE_Recorder_2_read_Read dPRE_SAFERecorder2ReadRequest;
  diagResponse PRE_SAFE_Recorder_2_read_Read dPRE_SAFERecorder2ReadResponse;   
  
  //Pre-Safe Cycle buffer clear (0x2E 0x02 0x41)
  diagRequest PRE_SAFE_Recorder_1_reset_Write dPRE_SAFERecorder1resetWriteRequest;
  diagResponse PRE_SAFE_Recorder_1_reset_Write dPRE_SAFERecorder1resetWriteResponse;
  
  //Pre-Safe Cycle buffer clear (0x2E 0x02 0x42)
  diagRequest PRE_SAFE_Recorder_2_reset_Write dPRE_SAFERecorder2resetWriteRequest;
  diagResponse PRE_SAFE_Recorder_2_reset_Write dPRE_SAFERecorder2resetWriteResponse;
  
  //Pre-Safe Counter
  diagRequest Pre_Safe_Counter dPreSafeCounterRequest;
  diagResponse Pre_Safe_Counter dPreSafeCounterResponse; 
  
  //Pre-Safe Counter Reset 
  diagRequest PRE_SAFE_Request_Counter_reset_Write  PRE_SAFERequestCounterresetWriteRequest;
  diagResponse  PRE_SAFE_Request_Counter_reset_Write  PRE_SAFERequestCounterresetWriteResponse;
  
  //Trigger Pre-Safe display
  diagRequest  Trigger_Presafe_Display_Request_Start  TriggerPresafeDisplayRequestStartRequest;
  diagResponse  Trigger_Presafe_Display_Request_Start TriggerPresafeDisplayRequestStartResponse;
    
  diagRequest  Trigger_Presafe_Display_Request_Stop TriggerPresafeDisplayRequestStopRequest;
  diagResponse  Trigger_Presafe_Display_Request_Stop  TriggerPresafeDisplayRequestStopResponse;
    
  diagRequest  Trigger_Presafe_Display_Request_RequestResults  TriggerPresafeDisplayRequestRequestResultsRequest;
  diagResponse  Trigger_Presafe_Display_Request_RequestResults  TriggerPresafeDisplayRequestRequestResultsResponse;
  
  //SW Version read
  diagRequest SW_Version_Read dSWVersionReadRequest;
  diagResponse SW_Version_Read dSWVersionReadResponse;
  
  //read AEE Traceability Number And PCBA programmed PN
  diagRequest ECU_serial_number_Read  dECUSerialNumberReadAEEPCBARequest;
  diagResponse  ECU_serial_number_Read  dECUSerialNumberReadAEEPCBAResponse;
    
  //VIN data
  diagRequest VIN_Data_Read dVINDataReadRequest;
  diagResponse VIN_Data_Read dVINDataReadResponse;   
  
  diagRequest VIN_Data_Write dVINDataWriteRequest;
  diagResponse VIN_Data_Write dVINDataWriteResponse; 
  
  //Authenticate diagnostic user or tester
  diagRequest Authenticate_Diagnostic_User_Or_Tester dAuthenticateDiagnosticUserOrTesterRequest;
  diagResponse Authenticate_Diagnostic_User_Or_Tester dAuthenticateDiagnosticUserOrTesterResponse; 
  
  //Read Tensioning Profile Configuration
  diagRequest PreSafe_Cycles_Level_1_8_Read dReadTensioningProfileConfigurationRequest;
  diagResponse PreSafe_Cycles_Level_1_8_Read dReadTensioningProfileConfigurationResponse; 
  
  //Read Release Profile Configuration
  diagRequest Release_Cycles_BSR_and_PreSafe_Read dReadReleaseProfileConfigurationRequest;
  diagResponse Release_Cycles_BSR_and_PreSafe_Read dReadReleaseProfileConfigurationResponse;  
  
  //Read BSR Profile Configuration
  diagRequest Tensioning_Cycle_BSR_Read dReadBSRProfileConfigurationRequest;
  diagResponse Tensioning_Cycle_BSR_Read dReadBSRProfileConfigurationResponse;  
  
  //Read Vehicle Equipment Configuration Data
  diagRequest Vehicle_Equipment_Read dReadVehicleEquipmentConfigurationDataRequest;
  diagResponse Vehicle_Equipment_Read dReadVehicleEquipmentConfigurationDataResponse;  
  
  //Read Vehicle Equipment Development Data
  diagRequest  ZZZ_Vehicle_Equipment_Development_Read dReadVehicleEquipmentDevelopmentDataRequest;
  diagResponse  ZZZ_Vehicle_Equipment_Development_Read dReadVehicleEquipmentDevelopmentDataResponse;    
     
//  //RMBA
//  diagRequest * dReadMemoryByAddressRequest;
//  diagResponse * dReadMemoryByAddressResponse;
  
//  //WMBA
//  diagRequest * dWriteMemoryByAddressRequest;
//  diagResponse * dWriteMemoryByAddressResponse;
  
  //RC
  diagRequest * dStartALVCyclesRequest;
  diagResponse * dStartALVCyclesResponse;
  
  diagRequest * dStopALVCyclesRequest;
  diagResponse * dStopALVCyclesResponse;
  
  
  diagRequest Cycle_Execution_RequestResults  dResultALVCyclesRequest;
  diagResponse Cycle_Execution_RequestResults  dResultALVCyclesResponse; 

  //Check Reprogramming Preconditions
  diagRequest  Check_Reprogramming_Preconditions_Start  dCheckReprogrammingPreconditionsStartRequest;
  diagResponse  Check_Reprogramming_Preconditions_Start  dCheckReprogrammingPreconditionsStartResponse;
  
  //PreCheckProgrammingDependencies
  diagRequest PreCheckProgrammingDependencies_Start dPreCheckProgrammingDependenciesStartRequest;
  diagResponse  PreCheckProgrammingDependencies_Start dPreCheckProgrammingDependenciesStartResponse;
  
  //Replace Trust Model Root Certificate
  diagRequest Replace_Trust_model_Root_Certificate_Start  dReplaceTrustModelRootCertificateStartRequest;
  diagResponse Replace_Trust_model_Root_Certificate_Start  dReplaceTrustModelRootCertificateStartResponse;
  
  //Activate Debugging Interfaces Start/Stop/Result  
  diagRequest Activate_Debugging_Interfaces_Start dActivateDebuggingInterfacesStartRequest;
  diagResponse Activate_Debugging_Interfaces_Start dActivateDebuggingInterfacesStartResponse;
    
  diagRequest Activate_Debugging_Interfaces_Stop dActivateDebuggingInterfacesStopRequest;
  diagResponse Activate_Debugging_Interfaces_Stop dActivateDebuggingInterfacesStopResponse;
  
  diagRequest Activate_Debugging_Interfaces_RequestResults dActivateDebuggingInterfacesRequestResultsRequest;
  diagResponse Activate_Debugging_Interfaces_RequestResults dActivateDebuggingInterfacesRequestResultsResponse;  
  
  //VIN Data Identifier Read  
  diagRequest   VINDataIdentifier_Read  dVINDataIdentifierReadRequest;
  diagResponse  VINDataIdentifier_Read  dVINDataIdentifierReadResponse;  
  
//  //read/write AEE Traceability Number And PCBA programmed PN
//  diagRequest ECU_serial_number_Read  dECUSerialNumberReadAEEPCBARequest;
//  diagResponse  ECU_serial_number_Read  dECUSerialNumberReadAEEPCBAResponse;
  
  diagRequest ECU_serial_number_Write dECUSerialNumberAEEPCBAWriteRequest;
  diagResponse  ECU_serial_number_Write dECUSerialNumberAEEPCBAWriteResponse;  
  
  //Synchronize to Non-volatile Memory Start/Stop/Result   
  diagRequest Synchronize_to_Non_volatile_Memory_Start  dSynchronizeToNonVolatileMemoryStartRequest;
  diagResponse  Synchronize_to_Non_volatile_Memory_Start  dSynchronizeToNonVolatileMemoryStartResponse;
    
  diagRequest Synchronize_to_Non_volatile_Memory_Stop   dSynchronizeToNonVolatileMemoryStopRequest;
  diagResponse  Synchronize_to_Non_volatile_Memory_Stop   dSynchronizeToNonVolatileMemoryStopResponse;
    
  diagRequest Synchronize_to_Non_volatile_Memory_Results  dSynchronizeToNonVolatileMemoryResultsRequest;
  diagResponse  Synchronize_to_Non_volatile_Memory_Results  dSynchronizeToNonVolatileMemoryResultsResponse;  
  
  //Trigger Trigger Tensioning Cycle Start/Stop/Result
  diagRequest Trigger_Tensioning_Cycle_Start dTriggerTensioningCycleStartRequest;
  diagResponse Trigger_Tensioning_Cycle_Start dTriggerTensioningCycleStartResponse;
   
  diagRequest Trigger_Tensioning_Cycle_Stop dTriggerTensioningCycleStopRequest;
  diagResponse Trigger_Tensioning_Cycle_Stop dTriggerTensioningCycleStopResponse;
    
  diagRequest Trigger_Tensioning_Cycle_RequestResults dTriggerTensioningCycleRequestResultsRequest; 
  diagResponse Trigger_Tensioning_Cycle_RequestResults dTriggerTensioningCycleRequestResultsResponse;
    
  //Trigger BSR Start/Stop/Result
  diagRequest Trigger_BSR_Start dTriggerBSRStartRequest;
  diagResponse Trigger_BSR_Start dTriggerBSRStartResponse;
  
  diagRequest Trigger_BSR_Stop  dTriggerBSRStopRequest;
  diagResponse Trigger_BSR_Stop  dTriggerBSRStopResponse;  
  
  diagRequest Trigger_BSR_RequestResults dTriggerBSRRequestResultsRequest;
  diagResponse Trigger_BSR_RequestResults dTriggerBSRRequestResultsResponse; 
  
  //WDBLI
  diagRequest * dWriteMeasurementFrameBlock12Request;
  diagResponse * dWriteMeasurementFrameBlock12Response;
  
  byte bLock[4] = {0x31, 0x02 ,0xf7, 0x81};
  byte bUnlock[4] = {0x31, 0x01, 0xf7, 0x81};
  
  byte bLeft[4] = {0x2E, 0xFD, 0x2F, 0x9C};
  byte bRight[4] = {0x2E, 0xFD, 0x2F, 0x99};
  
  //Communication Control
  diagRequest EnableRxAndEnableTx_Control dEnableRxAndEnableTxControlRequest;
  diagResponse EnableRxAndEnableTx_Control dEnableRxAndEnableTxControlResponse;
  
  diagRequest EnableRxAndDisableTx_Control  dEnableRxAndDisableTxControlRequest;
  diagResponse EnableRxAndDisableTx_Control dEnableRxAndDisableTxControlResponse; 
  
  //ECU Location Write
//  diagRequest  ECU_Location_Write dECULocationWriteRequest;
//  diagResponse ECU_Location_Write dECULocationWriteResponse;
  
  diagRequest  ECU_Location_Read dECULocationReadRequest;
  diagResponse ECU_Location_Read dECULocationReadResponse;
  
  //Write Adjust ISO 15765-2 Block Size and STmin Parameter
  diagRequest Adjust_ISO_15765_2_Block_Size_and_STmin_Parameter_Write dAdjustISO15765_2BlockSizeAndSTminParameterWriteRequest;
  diagResponse  Adjust_ISO_15765_2_Block_Size_and_STmin_Parameter_Write dAdjustISO15765_2BlockSizeAndSTminParameterWriteResponse;
  
  //Write and Read Calibration Identifications (CAL ID)
  diagRequest Calibration_Identifications_CAL_ID_Write  dCalibrationIdentificationsCALIDWriteRequest;
  diagResponse  Calibration_Identifications_CAL_ID_Write  dCalibrationIdentificationsCALIDWriteResponse;
  
  diagRequest Calibration_Identifications_CAL_ID_Read dCalibrationIdentificationsCALIDReadRequest;
  diagResponse  Calibration_Identifications_CAL_ID_Read dCalibrationIdentificationsCALIDReadResponse;
  
  //Write Release Profile Configuration
  diagRequest  Release_Cycles_BSR_and_PreSafe_Write dReleaseProfileConfigurationWriteRequest;
  diagResponse Release_Cycles_BSR_and_PreSafe_Write dReleaseProfileConfigurationWriteResponse; 
  
  //Write BSR Profile Configuration
  diagRequest Tensioning_Cycle_BSR_Write dWriteBSRProfileConfigurationRequest;
  diagResponse Tensioning_Cycle_BSR_Write dWriteBSRProfileConfigurationResponse; 
  
  //Write Tensioning Profile Configuration
  diagRequest PreSafe_Cycles_Level_1_8_Write dWriteTensioningProfileConfigurationRequest;
  diagResponse PreSafe_Cycles_Level_1_8_Write dWriteTensioningProfileConfigurationResponse;  
  
  //Write Vehicle Equipment Configuration Data
  diagRequest Vehicle_Equipment_Write dWriteVehicleEquipmentConfigurationDataRequest;
  diagResponse Vehicle_Equipment_Write dWriteVehicleEquipmentConfigurationDataResponse;  
  
  //Write Vehicle Equipment Development Data
  diagRequest ZZZ_Vehicle_Equipment_Development_Write dWriteVehicleEquipmentDevelopmentDataRequest;
  diagResponse ZZZ_Vehicle_Equipment_Development_Write dWriteVehicleEquipmentDevelopmentDataResponse;
  
  //CAN Input Read
  diagRequest  CAN_input_Read dCanInputReadRequest;
  diagResponse CAN_input_Read dCanInputReadResponse;
  
//  
//  diagRequest  FaultMem_ReportDTCByStatusMask dReportDTCByStatusMaskRequest;
//  diagResponse FaultMem_ReportDTCByStatusMask dReportDTCByStatusMaskResponse;
//  
//  diagRequest  FaultMem_ReportDTCExtendedDataByDTCNbr dReportDTCExtendedDataByDTCNbrRequest;
//  diagResponse FaultMem_ReportDTCExtendedDataByDTCNbr dReportDTCExtendedDataByDTCNbrResponse;
//  
//  diagRequest  FaultMem_ReportNbrOfDTCStatusMask dReportNbrOfDTCByStatusMaskRequest;
//  diagResponse FaultMem_ReportNbrOfDTCStatusMask dReportNbrOfDTCByStatusMaskResponse;
//  
//  diagRequest  FaultMem_ReportSupportedDTCs dReportSupportedDTCsRequest;
//  diagResponse FaultMem_ReportSupportedDTCs dReportSupportedDTCsResponse;
//  
  //ClearAllAec
//  diagRequest FaultMem_ClearGroup dClearAllDTCsRequest;
//  diagResponse FaultMem_ClearGroup dClearAllDTCsResponse;
  
  char sDefault[8] = "default";
  char sExtended[9] = "extended";
  char sProgramming[12] = "programming";
  char sDevelopment[12] = "development";
  char sUpdate[7] ="update";
  
  char sUnlock[10] = "unlock";
  char sLock[10] = "lock";
   
  char sTargetECUFrontLeftName[10] = "RBTMFL174";
  char sTargetECUFrontRightName[10] = "RBTMFR174";
  
  int iSideFlag;
  
//  const DIAG_SEND_OR_RECEIVE_ERROR = -1;
//  byte bEmptyBuffer[1000];
  
  // Read PRE-SAFE counters. 
  diagRequest  PRE_SAFE_Counter_read_Read dReadPreSafeCountersRequest;
  diagResponse PRE_SAFE_Counter_read_Read dReadPreSafeCountersResponse;
  
  // Read BSR counters.
  diagRequest  BSR_Counter_read_Read dReadBSRCounterRequest;
  diagResponse BSR_Counter_read_Read dReadBSRCounterResponse;
  
  // Read Cycles configuration. 
  diagRequest  Cycle_configuration_Read dReadCycleConfigRequest;
  diagResponse Cycle_configuration_Read dReadCycleConfigResponse;
  
  // Write Cycles configuration. 
  diagRequest  Cycle_configuration_Write dWriteCycleConfigRequest;
  diagResponse Cycle_configuration_Write dWriteCycleConfigResponse;
  
  // Read Steps configuration.
  diagRequest  Steps_library_Read dReadStepsConfigRequest;
  diagResponse Steps_library_Read dReadStepsConfigResponse;
  
  // Write Steps configuration.
  diagRequest  Steps_library_Write dWriteStepsConfigRequest;
  diagResponse Steps_library_Write dWriteStepsConfigResponse;
  
  diagRequest ReadCycleCounters dReadCountersRequest; // To be deleted
  diagResponse ReadCycleCounters dReadCountersResponse; // To be deleted
  
  // Read MF configuration.
//  diagRequest  Measurement_Frames_Configuration_Read dActivateMFRequest;
//  diagResponse Measurement_Frames_Configuration_Read dActivateMFResponse;
  
  diagRequest  Measurement_Frames_Configuration_Read dReadMFRequest;
  diagResponse Measurement_Frames_Configuration_Read dReadMFResponse;
  
  // Write MF configuration.
  diagRequest  Measurement_Frames_Configuration_Write dWriteMFRequest;
  diagResponse Measurement_Frames_Configuration_Write dWriteMFResponse;
  
  //Read ECU Calibration Parameters
  diagRequest  HB_Calibration_Read dReadECUCalibParamRequest;
  diagResponse HB_Calibration_Read dReadECUCalibParamResponse;
  
  //Write ECU Calibration Parameters
  diagRequest  HB_Calibration_Write dWriteECUCalibParamRequest;
  diagResponse HB_Calibration_Write dWriteECUCalibParamResponse;  
  
  //Read ALL AEC
  diagRequest  AEC_Status_Read dReadAllAECStatusRequest;
  diagResponse AEC_Status_Read dReadAllAECStatusResponse;
 
  //Read Measurement Frame Block 12 Config
  diagRequest  Measurement_Frame_Block_12_Config_Read dReadMFBlock12ConfigRequest;
  diagResponse Measurement_Frame_Block_12_Config_Read dReadMFBlock12ConfigResponse;
  
  //Write Measurement Frame Block 12 Config
  diagRequest  Measurement_Frame_Block_12_Config_Write dWriteMFBlock12ConfigRequest;
  diagResponse Measurement_Frame_Block_12_Config_Write dWriteMFBlock12ConfigResponse;
  
  diagRequest  HB_Calibration_Read dReadHBCalibrationRequest;
  diagResponse HB_Calibration_Read dReadHBCalibrationResponse;
  
  diagRequest  HB_Calibration_Write dWriteHBCalibrationgRequest;
  diagResponse HB_Calibration_Write dWriteHBCalibrationResponse;
  
  //Temperature Sensor Calibration Point 
  diagRequest Temperature_Sensor_Calibration_Point_Read dTemperatureSensorCalibrationPointReadRequest;
  diagResponse Temperature_Sensor_Calibration_Point_Read dTemperatureSensorCalibrationPointReadResponse;
  
  diagRequest Temperature_Sensor_Calibration_Point_Write  dTemperatureSensorCalibrationPointWriteRequest;
  diagResponse Temperature_Sensor_Calibration_Point_Write dTemperatureSensorCalibrationPointWriteResponse;
  
  //Velocity PI Regulation Coefficient
  diagRequest Velocity_PI_Regulation_Coefficient_Read dVelocityPIRegulationCoefficientReadRequest;
  diagResponse Velocity_PI_Regulation_Coefficient_Read  dVelocityPIRegulationCoefficientReadResponse;
  
  diagRequest Velocity_PI_Regulation_Coefficient_Write  dVelocityPIRegulationCoefficientWriteRequest;
  diagResponse  Velocity_PI_Regulation_Coefficient_Write  dVelocityPIRegulationCoefficientWriteResponse;
    
  //Erase All Start  
  diagRequest Erase_All_Start dEraseAllStartRequest;
  diagResponse Erase_All_Start dEraseAllStartResponse;
    
  //Customer Settings Read
  diagRequest Customer_Settings_Read dCustomerSettingsReadRequest;
  diagResponse Customer_Settings_Read dCustomerSettingsReadResponse;
    
  //Trust Model CSR Supplier Signature Read
  diagRequest Trust_Model_CSR_Supplier_Signature_Read dTrustModelCSRSupplierSignatureReadRequest;
  diagResponse  Trust_Model_CSR_Supplier_Signature_Read dTrustModelCSRSupplierSignatureReadResponse;
  
  diagRequest Trust_Model_CSR_Supplier_Signature_Write  dTrustModelCSRSupplierSignatureWriteRequest;
  diagResponse  Trust_Model_CSR_Supplier_Signature_Write  dTrustModelCSRSupplierSignatureWriteResponse;
  
  //Vedoc Relevant Information Read
  diagRequest Vedoc_Relevant_Information_Read dVedocRelevantInformationReadRequest;
  diagResponse Vedoc_Relevant_Information_Read dVedocRelevantInformationReadResponse;
  
  //Seatbelt Serial Number Write
  diagRequest Seatbelt_Serial_Number_Write  dSeatbeltSerialNumberWriteRequest;
  diagResponse  Seatbelt_Serial_Number_Write  dSeatbeltSerialNumberWriteResponse;
  
  //Clear Resource Consumption Data Start
  diagRequest Clear_Resource_Consumption_Data_Start dClearResourceConsumptionDataStartRequest;
  diagResponse  Clear_Resource_Consumption_Data_Start dClearResourceConsumptionDataStartResponse;
    
  byte bDefaultCycleRequest[423];
  byte bDefaultCycleLibraryRequest[3] = {0x2E, 0xFD, 0x10};
  
  byte bDefaultStepsRequest[1163];
  byte bDefaultStepsLibraryRequest[3] = {0x2E, 0xFD, 0x2A};
  
  // NRCs.
  byte bNRC_GeneralReject                          = 0x10;
  byte bNRC_IncorrectMessangeLengthOrInvalidFormat = 0x13;
  byte bNRC_ConditionsNotCorrect                   = 0x22;
  byte bNRC_RequestOutOfRange                      = 0x31;
  byte bNRC_SecurityAccessDenied                   = 0x33;
  byte bNRC_AuthenticationRequired                 = 0x34;
  
  int64 iVehStartup_SNA;
  int64 iVehStartup_NotFulfilled;
  int64 iVehStartup_NoStartup;
  int64 iTransportMode_Active;
  int64 iTransportMode_Inactive;
  int64 iProductionMode_Active;
  int64 iProductionMode_NotActive;
  
  float fSCDebounceTimer_NetworkCom = 5000;
  float fSCDebounceTimer_PowerDist  = 5000;
  
  enum SCID             {SC1 = 0         ,  SC2 = 1            ,  SC3 = 2          ,  SC4 = 3           ,  SC5 = 4                ,  SC8 = 5                 ,  SC10_PD = 6           ,  SC10_NC = 7           ,  SC10_NC15 = 8           ,  SC11 = 9             , SC12 = 10           };
  char SCName[11][30] = {"SC1_ControlDTC", "SC2_IgnitionStatus", "SC3_LocalVoltage", "SC4_SystemVoltage", "SC5_TransportationMode", "SC8_CommunicationStatus", "SC10_PD_debounceTimer", "SC10_NC_debounceTimer", "SC10_NC15_debounceTimer", "SC11_VehicleStartup", "SC12_ProductionMode"};
}

/// <CAN_Communication>
//Activate measurement frame with one block active.
// iBlock - block number to be activated on MF in decimal (1/2/3 .. 24 )
// Example:      ActivateMeasurementFrame(12)
 void ActivateMeasurementFrame(int iBlock)
{
  stack byte bMfDefaultConfigBlock[7] = {0x2E, 0xFE, 0xFF, 0x01, 0x00, 0x00, 0x00};
  
  switch(iBlock)
  {
    case 0:
      bMfDefaultConfigBlock[6] = bMfDefaultConfigBlock[6] + 0x00;
      break;
    case 1:
      bMfDefaultConfigBlock[6] = bMfDefaultConfigBlock[6] + 0x01;
      break;
    case 2:
      bMfDefaultConfigBlock[6] = bMfDefaultConfigBlock[6] + 0x02;
      break;
    case 3:
      bMfDefaultConfigBlock[6] = bMfDefaultConfigBlock[6] + 0x04;
      break;
    case 4:
      bMfDefaultConfigBlock[6] = bMfDefaultConfigBlock[6] + 0x08;
      break;
    case 5:
      bMfDefaultConfigBlock[6] = bMfDefaultConfigBlock[6] + 0x10;
      break;
    case 6:
      bMfDefaultConfigBlock[6] = bMfDefaultConfigBlock[6] + 0x20;
      break;
    case 7:
      bMfDefaultConfigBlock[6] = bMfDefaultConfigBlock[6] + 0x40;
      break;
    case 8:
      bMfDefaultConfigBlock[6] = bMfDefaultConfigBlock[6] + 0x80;
      break;
    case 9:
      bMfDefaultConfigBlock[5] = bMfDefaultConfigBlock[5] + 0x01;
      break;
    case 10:
      bMfDefaultConfigBlock[5] = bMfDefaultConfigBlock[5] + 0x02;
      break;
    case 11:
      bMfDefaultConfigBlock[5] = bMfDefaultConfigBlock[5] + 0x04;
      break;
    case 12:
      bMfDefaultConfigBlock[5] = bMfDefaultConfigBlock[5] + 0x08;
      break;
    case 13:
      bMfDefaultConfigBlock[5] = bMfDefaultConfigBlock[5] + 0x10;
      break;
    case 14:
      bMfDefaultConfigBlock[5] = bMfDefaultConfigBlock[5] + 0x20;
      break;
    case 15:
      bMfDefaultConfigBlock[5] = bMfDefaultConfigBlock[5] + 0x40;
      break;
    case 16:
      bMfDefaultConfigBlock[5] = bMfDefaultConfigBlock[5] + 0x80;
      break;
    case 17:
      bMfDefaultConfigBlock[4] = bMfDefaultConfigBlock[4] + 0x01;
      break;
    case 18:
      bMfDefaultConfigBlock[4] = bMfDefaultConfigBlock[4] + 0x02;
      break;
    case 19:
      bMfDefaultConfigBlock[4] = bMfDefaultConfigBlock[4] + 0x04;
      break;
    case 20:
      bMfDefaultConfigBlock[4] = bMfDefaultConfigBlock[4] + 0x08;
      break;
    case 21:
      bMfDefaultConfigBlock[4] = bMfDefaultConfigBlock[4] + 0x10;
      break;
    case 22:
      bMfDefaultConfigBlock[4] = bMfDefaultConfigBlock[4] + 0x20;
      break;
    case 23:
      bMfDefaultConfigBlock[4] = bMfDefaultConfigBlock[4] + 0x40;
      break;
    case 24:
      bMfDefaultConfigBlock[4] = bMfDefaultConfigBlock[4] + 0x80;
      break;
    default:
      testStepFail(@sysvar::CORE::sysLevelOfDetailFail, "Error", "Invalid block number for measurement frame configuration");
      break;
  }
  diagResize(dWriteMFRequest, 7);
  
  SendDiagnosticRequest(dWriteMFRequest, dWriteMFResponse, bMfDefaultConfigBlock);
  CheckPositiveResponse("Check positive response for activation of Measurement frame.", dWriteMFRequest, dWriteMFResponse);
  
}

/// <CAN_Communication>
//Activate measurement frame with two blocks active
// iBlock - first block number to be activated on MF in decimal (1/2/3 .. 24 )
// iBlock2 - second block number to be activated on MF in decimal (1/2/3 .. 24 )
// Example:      ActivateMeasurementFrame(1, 2)
void ActivateMeasurementFrame(int iBlock, int iBlock2)
{
  byte bMfDefaultConfigBlock[7];
  
  bMfDefaultConfigBlock[0] = 0x2E;
  bMfDefaultConfigBlock[1] = 0xFE;
  bMfDefaultConfigBlock[2] = 0xFF;
  bMfDefaultConfigBlock[3] = 0x01;
  bMfDefaultConfigBlock[4] = 0x00;
  bMfDefaultConfigBlock[5] = 0x00;
  bMfDefaultConfigBlock[6] = 0x00;
  
  switch(iBlock)
  {
    case 1:
      bMfDefaultConfigBlock[6] = bMfDefaultConfigBlock[6] + 0x01;
      break;
    case 2:
      bMfDefaultConfigBlock[6] = bMfDefaultConfigBlock[6] + 0x02;
      break;
    case 3:
      bMfDefaultConfigBlock[6] = bMfDefaultConfigBlock[6] + 0x04;
      break;
    case 4:
      bMfDefaultConfigBlock[6] = bMfDefaultConfigBlock[6] + 0x08;
      break;
    case 5:
      bMfDefaultConfigBlock[6] = bMfDefaultConfigBlock[6] + 0x10;
      break;
    case 6:
      bMfDefaultConfigBlock[6] = bMfDefaultConfigBlock[6] + 0x20;
      break;
    case 7:
      bMfDefaultConfigBlock[6] = bMfDefaultConfigBlock[6] + 0x40;
      break;
    case 8:
      bMfDefaultConfigBlock[6] = bMfDefaultConfigBlock[6] + 0x80;
      break;
    case 9:
      bMfDefaultConfigBlock[5] = bMfDefaultConfigBlock[5] + 0x01;
      break;
    case 10:
      bMfDefaultConfigBlock[5] = bMfDefaultConfigBlock[5] + 0x02;
      break;
    case 11:
      bMfDefaultConfigBlock[5] = bMfDefaultConfigBlock[5] + 0x04;
      break;
    case 12:
      bMfDefaultConfigBlock[5] = bMfDefaultConfigBlock[5] + 0x08;
      break;
    case 13:
      bMfDefaultConfigBlock[5] = bMfDefaultConfigBlock[5] + 0x10;
      break;
    case 14:
      bMfDefaultConfigBlock[5] = bMfDefaultConfigBlock[5] + 0x20;
      break;
    case 15:
      bMfDefaultConfigBlock[5] = bMfDefaultConfigBlock[5] + 0x40;
      break;
    case 16:
      bMfDefaultConfigBlock[5] = bMfDefaultConfigBlock[5] + 0x80;
      break;
    case 17:
      bMfDefaultConfigBlock[4] = bMfDefaultConfigBlock[4] + 0x01;
      break;
    case 18:
      bMfDefaultConfigBlock[4] = bMfDefaultConfigBlock[4] + 0x02;
      break;
    case 19:
      bMfDefaultConfigBlock[4] = bMfDefaultConfigBlock[4] + 0x04;
      break;
    case 20:
      bMfDefaultConfigBlock[4] = bMfDefaultConfigBlock[4] + 0x08;
      break;
    case 21:
      bMfDefaultConfigBlock[4] = bMfDefaultConfigBlock[4] + 0x10;
      break;
    case 22:
      bMfDefaultConfigBlock[4] = bMfDefaultConfigBlock[4] + 0x20;
      break;
    case 23:
      bMfDefaultConfigBlock[4] = bMfDefaultConfigBlock[4] + 0x40;
      break;
    case 24:
      bMfDefaultConfigBlock[4] = bMfDefaultConfigBlock[4] + 0x80;
      break;
    default:
      testStepFail(@sysvar::CORE::sysLevelOfDetailFail, "Error", "Invalid block number for measurement frame configuration");
      break;
  }
  
  switch(iBlock2)
  {
    case 1:
      bMfDefaultConfigBlock[6] = bMfDefaultConfigBlock[6] + 0x01;
      break;
    case 2:
      bMfDefaultConfigBlock[6] = bMfDefaultConfigBlock[6] + 0x02;
      break;
    case 3:
      bMfDefaultConfigBlock[6] = bMfDefaultConfigBlock[6] + 0x04;
      break;
    case 4:
      bMfDefaultConfigBlock[6] = bMfDefaultConfigBlock[6] + 0x08;
      break;
    case 5:
      bMfDefaultConfigBlock[6] = bMfDefaultConfigBlock[6] + 0x10;
      break;
    case 6:
      bMfDefaultConfigBlock[6] = bMfDefaultConfigBlock[6] + 0x20;
      break;
    case 7:
      bMfDefaultConfigBlock[6] = bMfDefaultConfigBlock[6] + 0x40;
      break;
    case 8:
      bMfDefaultConfigBlock[6] = bMfDefaultConfigBlock[6] + 0x80;
      break;
    case 9:
      bMfDefaultConfigBlock[5] = bMfDefaultConfigBlock[5] + 0x01;
      break;
    case 10:
      bMfDefaultConfigBlock[5] = bMfDefaultConfigBlock[5] + 0x02;
      break;
    case 11:
      bMfDefaultConfigBlock[5] = bMfDefaultConfigBlock[5] + 0x04;
      break;
    case 12:
      bMfDefaultConfigBlock[5] = bMfDefaultConfigBlock[5] + 0x08;
      break;
    case 13:
      bMfDefaultConfigBlock[5] = bMfDefaultConfigBlock[5] + 0x10;
      break;
    case 14:
      bMfDefaultConfigBlock[5] = bMfDefaultConfigBlock[5] + 0x20;
      break;
    case 15:
      bMfDefaultConfigBlock[5] = bMfDefaultConfigBlock[5] + 0x40;
      break;
    case 16:
      bMfDefaultConfigBlock[5] = bMfDefaultConfigBlock[5] + 0x80;
      break;
    case 17:
      bMfDefaultConfigBlock[4] = bMfDefaultConfigBlock[4] + 0x01;
      break;
    case 18:
      bMfDefaultConfigBlock[4] = bMfDefaultConfigBlock[4] + 0x02;
      break;
    case 19:
      bMfDefaultConfigBlock[4] = bMfDefaultConfigBlock[4] + 0x04;
      break;
    case 20:
      bMfDefaultConfigBlock[4] = bMfDefaultConfigBlock[4] + 0x08;
      break;
    case 21:
      bMfDefaultConfigBlock[4] = bMfDefaultConfigBlock[4] + 0x10;
      break;
    case 22:
      bMfDefaultConfigBlock[4] = bMfDefaultConfigBlock[4] + 0x20;
      break;
    case 23:
      bMfDefaultConfigBlock[4] = bMfDefaultConfigBlock[4] + 0x40;
      break;
    case 24:
      bMfDefaultConfigBlock[4] = bMfDefaultConfigBlock[4] + 0x80;
      break;
    default:
      testStepFail(@sysvar::CORE::sysLevelOfDetailFail, "Error", "Invalid block number for measurement frame configuration");
      break;
  }
//  SetECUMode("unlock");
  diagResize(dRequest, 7);
  diagSetPrimitiveData(dRequest, bMfDefaultConfigBlock, elCount(bMfDefaultConfigBlock));
  SendDiagnosticRequest(dRequest, dResponse);
  CheckPositiveResponse("Measurement frame blocks are activated with 10ms periodicity", dRequest, dResponse);
//  SetECUMode("lock");
}

/// <CAN_Communication>
//Activate measurement frame with two blocks active
// iBlock - first block number to be activated on MF in decimal (1/2/3 .. 24 )
// iBlock2 - second block number to be activated on MF in decimal (1/2/3 .. 24 )
// iBlock3 - third block number to be activated on MF in decimal (1/2/3 .. 24 )
// Example:      ActivateMeasurementFrame(1, 2, 6)
void ActivateMeasurementFrame(int iBlock, int iBlock2, int iBlock3)
{
  byte bMfDefaultConfigBlock[7];
  
  bMfDefaultConfigBlock[0] = 0x2E;
  bMfDefaultConfigBlock[1] = 0xFE;
  bMfDefaultConfigBlock[2] = 0xFF;
  bMfDefaultConfigBlock[3] = 0x01;
  bMfDefaultConfigBlock[4] = 0x00;
  bMfDefaultConfigBlock[5] = 0x00;
  bMfDefaultConfigBlock[6] = 0x00;
  
  switch(iBlock)
  {
    case 1:
      bMfDefaultConfigBlock[6] = bMfDefaultConfigBlock[6] + 0x01;
      break;
    case 2:
      bMfDefaultConfigBlock[6] = bMfDefaultConfigBlock[6] + 0x02;
      break;
    case 3:
      bMfDefaultConfigBlock[6] = bMfDefaultConfigBlock[6] + 0x04;
      break;
    case 4:
      bMfDefaultConfigBlock[6] = bMfDefaultConfigBlock[6] + 0x08;
      break;
    case 5:
      bMfDefaultConfigBlock[6] = bMfDefaultConfigBlock[6] + 0x10;
      break;
    case 6:
      bMfDefaultConfigBlock[6] = bMfDefaultConfigBlock[6] + 0x20;
      break;
    case 7:
      bMfDefaultConfigBlock[6] = bMfDefaultConfigBlock[6] + 0x40;
      break;
    case 8:
      bMfDefaultConfigBlock[6] = bMfDefaultConfigBlock[6] + 0x80;
      break;
    case 9:
      bMfDefaultConfigBlock[5] = bMfDefaultConfigBlock[5] + 0x01;
      break;
    case 10:
      bMfDefaultConfigBlock[5] = bMfDefaultConfigBlock[5] + 0x02;
      break;
    case 11:
      bMfDefaultConfigBlock[5] = bMfDefaultConfigBlock[5] + 0x04;
      break;
    case 12:
      bMfDefaultConfigBlock[5] = bMfDefaultConfigBlock[5] + 0x08;
      break;
    case 13:
      bMfDefaultConfigBlock[5] = bMfDefaultConfigBlock[5] + 0x10;
      break;
    case 14:
      bMfDefaultConfigBlock[5] = bMfDefaultConfigBlock[5] + 0x20;
      break;
    case 15:
      bMfDefaultConfigBlock[5] = bMfDefaultConfigBlock[5] + 0x40;
      break;
    case 16:
      bMfDefaultConfigBlock[5] = bMfDefaultConfigBlock[5] + 0x80;
      break;
    case 17:
      bMfDefaultConfigBlock[4] = bMfDefaultConfigBlock[4] + 0x01;
      break;
    case 18:
      bMfDefaultConfigBlock[4] = bMfDefaultConfigBlock[4] + 0x02;
      break;
    case 19:
      bMfDefaultConfigBlock[4] = bMfDefaultConfigBlock[4] + 0x04;
      break;
    case 20:
      bMfDefaultConfigBlock[4] = bMfDefaultConfigBlock[4] + 0x08;
      break;
    case 21:
      bMfDefaultConfigBlock[4] = bMfDefaultConfigBlock[4] + 0x10;
      break;
    case 22:
      bMfDefaultConfigBlock[4] = bMfDefaultConfigBlock[4] + 0x20;
      break;
    case 23:
      bMfDefaultConfigBlock[4] = bMfDefaultConfigBlock[4] + 0x40;
      break;
    case 24:
      bMfDefaultConfigBlock[4] = bMfDefaultConfigBlock[4] + 0x80;
      break;
    default:
      testStepFail(@sysvar::CORE::sysLevelOfDetailFail, "Error", "Invalid block number for measurement frame configuration");
      break;
  }
  
  switch(iBlock2)
  {
    case 1:
      bMfDefaultConfigBlock[6] = bMfDefaultConfigBlock[6] + 0x01;
      break;
    case 2:
      bMfDefaultConfigBlock[6] = bMfDefaultConfigBlock[6] + 0x02;
      break;
    case 3:
      bMfDefaultConfigBlock[6] = bMfDefaultConfigBlock[6] + 0x04;
      break;
    case 4:
      bMfDefaultConfigBlock[6] = bMfDefaultConfigBlock[6] + 0x08;
      break;
    case 5:
      bMfDefaultConfigBlock[6] = bMfDefaultConfigBlock[6] + 0x10;
      break;
    case 6:
      bMfDefaultConfigBlock[6] = bMfDefaultConfigBlock[6] + 0x20;
      break;
    case 7:
      bMfDefaultConfigBlock[6] = bMfDefaultConfigBlock[6] + 0x40;
      break;
    case 8:
      bMfDefaultConfigBlock[6] = bMfDefaultConfigBlock[6] + 0x80;
      break;
    case 9:
      bMfDefaultConfigBlock[5] = bMfDefaultConfigBlock[5] + 0x01;
      break;
    case 10:
      bMfDefaultConfigBlock[5] = bMfDefaultConfigBlock[5] + 0x02;
      break;
    case 11:
      bMfDefaultConfigBlock[5] = bMfDefaultConfigBlock[5] + 0x04;
      break;
    case 12:
      bMfDefaultConfigBlock[5] = bMfDefaultConfigBlock[5] + 0x08;
      break;
    case 13:
      bMfDefaultConfigBlock[5] = bMfDefaultConfigBlock[5] + 0x10;
      break;
    case 14:
      bMfDefaultConfigBlock[5] = bMfDefaultConfigBlock[5] + 0x20;
      break;
    case 15:
      bMfDefaultConfigBlock[5] = bMfDefaultConfigBlock[5] + 0x40;
      break;
    case 16:
      bMfDefaultConfigBlock[5] = bMfDefaultConfigBlock[5] + 0x80;
      break;
    case 17:
      bMfDefaultConfigBlock[4] = bMfDefaultConfigBlock[4] + 0x01;
      break;
    case 18:
      bMfDefaultConfigBlock[4] = bMfDefaultConfigBlock[4] + 0x02;
      break;
    case 19:
      bMfDefaultConfigBlock[4] = bMfDefaultConfigBlock[4] + 0x04;
      break;
    case 20:
      bMfDefaultConfigBlock[4] = bMfDefaultConfigBlock[4] + 0x08;
      break;
    case 21:
      bMfDefaultConfigBlock[4] = bMfDefaultConfigBlock[4] + 0x10;
      break;
    case 22:
      bMfDefaultConfigBlock[4] = bMfDefaultConfigBlock[4] + 0x20;
      break;
    case 23:
      bMfDefaultConfigBlock[4] = bMfDefaultConfigBlock[4] + 0x40;
      break;
    case 24:
      bMfDefaultConfigBlock[4] = bMfDefaultConfigBlock[4] + 0x80;
      break;
    default:
      testStepFail(@sysvar::CORE::sysLevelOfDetailFail, "Error", "Invalid block number for measurement frame configuration");
      break;
  }
  
    switch(iBlock3)
  {
    case 1:
      bMfDefaultConfigBlock[6] = bMfDefaultConfigBlock[6] + 0x01;
      break;
    case 2:
      bMfDefaultConfigBlock[6] = bMfDefaultConfigBlock[6] + 0x02;
      break;
    case 3:
      bMfDefaultConfigBlock[6] = bMfDefaultConfigBlock[6] + 0x04;
      break;
    case 4:
      bMfDefaultConfigBlock[6] = bMfDefaultConfigBlock[6] + 0x08;
      break;
    case 5:
      bMfDefaultConfigBlock[6] = bMfDefaultConfigBlock[6] + 0x10;
      break;
    case 6:
      bMfDefaultConfigBlock[6] = bMfDefaultConfigBlock[6] + 0x20;
      break;
    case 7:
      bMfDefaultConfigBlock[6] = bMfDefaultConfigBlock[6] + 0x40;
      break;
    case 8:
      bMfDefaultConfigBlock[6] = bMfDefaultConfigBlock[6] + 0x80;
      break;
    case 9:
      bMfDefaultConfigBlock[5] = bMfDefaultConfigBlock[5] + 0x01;
      break;
    case 10:
      bMfDefaultConfigBlock[5] = bMfDefaultConfigBlock[5] + 0x02;
      break;
    case 11:
      bMfDefaultConfigBlock[5] = bMfDefaultConfigBlock[5] + 0x04;
      break;
    case 12:
      bMfDefaultConfigBlock[5] = bMfDefaultConfigBlock[5] + 0x08;
      break;
    case 13:
      bMfDefaultConfigBlock[5] = bMfDefaultConfigBlock[5] + 0x10;
      break;
    case 14:
      bMfDefaultConfigBlock[5] = bMfDefaultConfigBlock[5] + 0x20;
      break;
    case 15:
      bMfDefaultConfigBlock[5] = bMfDefaultConfigBlock[5] + 0x40;
      break;
    case 16:
      bMfDefaultConfigBlock[5] = bMfDefaultConfigBlock[5] + 0x80;
      break;
    case 17:
      bMfDefaultConfigBlock[4] = bMfDefaultConfigBlock[4] + 0x01;
      break;
    case 18:
      bMfDefaultConfigBlock[4] = bMfDefaultConfigBlock[4] + 0x02;
      break;
    case 19:
      bMfDefaultConfigBlock[4] = bMfDefaultConfigBlock[4] + 0x04;
      break;
    case 20:
      bMfDefaultConfigBlock[4] = bMfDefaultConfigBlock[4] + 0x08;
      break;
    case 21:
      bMfDefaultConfigBlock[4] = bMfDefaultConfigBlock[4] + 0x10;
      break;
    case 22:
      bMfDefaultConfigBlock[4] = bMfDefaultConfigBlock[4] + 0x20;
      break;
    case 23:
      bMfDefaultConfigBlock[4] = bMfDefaultConfigBlock[4] + 0x40;
      break;
    case 24:
      bMfDefaultConfigBlock[4] = bMfDefaultConfigBlock[4] + 0x80;
      break;
    default:
      testStepFail(@sysvar::CORE::sysLevelOfDetailFail, "Error", "Invalid block number for measurement frame configuration");
      break;
  }
//  SetECUMode("unlock");
  diagResize(dRequest, 7);
  diagSetPrimitiveData(dRequest, bMfDefaultConfigBlock, elCount(bMfDefaultConfigBlock));
  SendDiagnosticRequest(dRequest, dResponse);
  CheckPositiveResponse("Measurement frame blocks are activated with 10ms periodicity", dRequest, dResponse);
//  SetECUMode("lock");
}


/// <CAN_Communication>
//Wait until first measurement frame appears on CAN bus
void WaitECUInitialization()
{
  stack int iResult;
  stack float fStartTime = timeNow() / 100; // simulation time in ms.
  stack float fCurrentTime;
  stack  char targetName[100];
  
  testwaitfortimeout(30);
  
  diagGetCurrentEcu(targetName, elcount(targetName));
  
  if (strncmp(targetName, sTargetECUFrontLeftName, elcount(targetName)) == 0)
  {
    iResult = testWaitForMessage(0x18E1A490x, 2000); // Measurement frame FL
    
    fCurrentTime = (timeNow() / 100) - fStartTime;
    
    if (iResult == 1)
    {
      testStep(@sysvar::CORE::sysLevelOfDetailStep, "", "ECU initialized in %.f ms", fCurrentTime);
    }
    else
    {
      testStepFail(@sysvar::CORE::sysLevelOfDetailFail, "", "Frame Not found in %.f ms", fCurrentTime);
    }
  }
  else
  {
    iResult = testWaitForMessage(0x18E1A590x, 2000); // Measurement frame FR
    
    fCurrentTime = (timeNow() / 100) - fStartTime;
    
    if (iResult == 1)
    {
      testStep(@sysvar::CORE::sysLevelOfDetailStep, "", "ECU initialized in %.f ms", fCurrentTime);
    }
    else
    {
      testStepFail(@sysvar::CORE::sysLevelOfDetailFail, "", "Frame Not found in %.f ms", fCurrentTime);
    }
  }     
}


/// <CAN_Communication>
// Set Buckle State buckled or unbuckeld state. To be updated according DAG spec.!!!!!!!!!
//void SetBuckleState(char sSide[], char sState[])
//{
//  toUpper(sSide, sSide, elcount(sSide));
//  toUpper(sState, sState, elcount(sState));
//    
//  if (strncmp(sSide,"FRONT_LEFT", elcount(sSide)) == 0)
//    {
//     write("left");
//     // $RGS_VL_Anforderung_XIX_RGS_Anf_01_XIX_Airbag_SUBCANFD01 = sState;
//     // testWaitForSignalChange(RGS_VL_Anforderung_XIX_RGS_Anf_01_XIX_Airbag_SUBCANFD01, 100);      
//    }
//  
//  if (strncmp(sSide,"FRONT_RIGHT", elcount(sSide)) == 0)
//    {
//      write("right");
//     // $RGS_VR_Anforderung_XIX_RGS_Anf_01_XIX_Airbag_SUBCANFD01 = sState;
//     // testWaitForSignalChange(RGS_VR_Anforderung_XIX_RGS_Anf_01_XIX_Airbag_SUBCANFD01, 100);     
//    }
//}

/// <CAN_Communication>
//Function that retunrs information from measurement frame
//Examples: // If Measurement Frame Block 1 is with these dates: 0x01 0x12 0x11 0x00 0x00 0x00 0x00 0x00
            // GetMeasurementFrameInfo(1,1,2) [Block 1, Start Byte 1, Stop Byte 2 => selected data from above: '0x12 0x11'] => returns value in Int: 4625
int64 GetMeasurementFrameInfo(int iBlock, int iStartPos, int iStopPos)
{
  int   res;
  int   iFlag;
  int   iCount;
  int   iIndex;
  int   iBlockID;
  int   iMaxValue;
  int64 iReturnValue = 0;
  char  temp[20];
  char  temp1[20];
  char  buffer[20];
  char  targetName[100];
  char  _cBytesValues[7][3];
  char  _sMeasurementFrameSignals[7][25]   = {"Meas_RBTM_FL_02_ST3","Meas_RBTM_FL_03_ST3","Meas_RBTM_FL_04_ST3","Meas_RBTM_FL_05_ST3","Meas_RBTM_FL_06_ST3","Meas_RBTM_FL_07_ST3","Meas_RBTM_FL_08_ST3"};
  char  _sMeasurementFrameSignalsFR[7][25] = {"Meas_RBTM_FR_02_ST3","Meas_RBTM_FR_03_ST3","Meas_RBTM_FR_04_ST3","Meas_RBTM_FR_05_ST3","Meas_RBTM_FR_06_ST3","Meas_RBTM_FR_07_ST3","Meas_RBTM_FR_08_ST3"};
  
  iIndex = 0;
  iCount = 0;
  iMaxValue = 1000;
  testWaitForTimeout(20);
  snprintf(temp, 1, "%c", '\0');
  snprintf(temp1, 1, "%c", '\0');
  snprintf(buffer, 3, "%c%c", '0','x');
  
  diagGetCurrentEcu(targetName, elcount(targetName));
  
  if (strncmp(targetName, sTargetECUFrontLeftName, elcount(targetName)) == 0)
  {
    iFlag = testWaitForMessage(@sysvar::ProjectConfiguration::sysMeasurementFrameID, 10);
    
    while ((iCount < 200) && (iFlag != 1))
    {
      iFlag = testWaitForMessage(@sysvar::ProjectConfiguration::sysMeasurementFrameID, 10);
      iCount += 1;
    }
    
    if (iFlag == 1)
    {
      iBlockID = getSignal(Meas_RBTM_FL_01_ST3);
      while((iBlock != iBlockID) && (iCount < iMaxValue))
      {
        testWaitForTimeout(5);
        iCount += 1;
        iBlockID = getSignal(Meas_RBTM_FL_01_ST3);
      }
      if(iCount<iMaxValue)
      {
        if((iStartPos > 0 && iStartPos < 8) && (iStopPos > 0 && iStopPos < 8))
        {
          for(iIndex=0;iIndex<elCount(_cBytesValues);iIndex++)
          {
            if(getRawSignal(_sMeasurementFrameSignals[iIndex])< 16)
            {
              snprintf(_cBytesValues[iIndex], 3, "%X%X", 0, getRawSignal(_sMeasurementFrameSignals[iIndex]));
            }
            
            else 
            {
              snprintf(_cBytesValues[iIndex], 3, "%X%X", getRawSignal(_sMeasurementFrameSignals[iIndex]));
            }
            
            strncat(temp,_cBytesValues[iIndex],2*iIndex+3);
          }
          
          substr_cpy(temp1, temp,2*iStartPos-2, 2*(iStopPos-iStartPos)+2, elCount(buffer));
          strncat(buffer,temp1,elCount(buffer));
          res = strtoll(buffer,iReturnValue);
          return iReturnValue;
        }
        else
        {
          testStepFail(@sysvar::CORE::sysLevelOfDetailFail, "", "Start/Stop position out of range. Wrong StartPos: %d [OR] StopPos: %d", iStartPos, iStopPos);
          return -1;
        }
      }
      else
      {
        testStepFail(@sysvar::CORE::sysLevelOfDetailFail, "", "Measurement Frame Block: %d is NOT active.", iBlock);
        return -1;
      }
    }
    else
    {
      testStepFail(@sysvar::CORE::sysLevelOfDetailFail, "", "Measurement Frame Not found in %d ms", iCount*10);
      return -1;
    }
  }
  else
  {
    @sysvar::ProjectConfiguration::sysMeasurementFrameID = MeasurementFrameFR.id;
    
    iFlag = testWaitForMessage(@sysvar::ProjectConfiguration::sysMeasurementFrameID, 10);
    
    while ((iCount < 200) && (iFlag != 1))
    {
      iFlag = testWaitForMessage(@sysvar::ProjectConfiguration::sysMeasurementFrameID, 10);
      iCount += 1;
    }
    
    if (iFlag == 1)
    {
      iBlockID = getSignal(Meas_RBTM_FR_01_ST3);
      while((iBlock != iBlockID) && (iCount < iMaxValue))
      {
        testWaitForTimeout(5);
        iCount += 1;
        iBlockID = getSignal(Meas_RBTM_FR_01_ST3);
      }
      if(iCount<iMaxValue)
      {
        if((iStartPos > 0 && iStartPos < 8) && (iStopPos > 0 && iStopPos < 8))
        {
          for(iIndex=0;iIndex<elCount(_cBytesValues);iIndex++)
          {
            if(getRawSignal(_sMeasurementFrameSignalsFR[iIndex])< 16)
            {
              snprintf(_cBytesValues[iIndex], 3, "%X%X", 0, getRawSignal(_sMeasurementFrameSignalsFR[iIndex]));
            }
            
            else 
            {
              snprintf(_cBytesValues[iIndex], 3, "%X%X", getRawSignal(_sMeasurementFrameSignalsFR[iIndex]));
            }
            
            strncat(temp,_cBytesValues[iIndex],2*iIndex+3);
          }
          
          substr_cpy(temp1, temp,2*iStartPos-2, 2*(iStopPos-iStartPos)+2, elCount(buffer));
          strncat(buffer,temp1,elCount(buffer));
          res = strtoll(buffer,iReturnValue);
          return iReturnValue;
        }
        else
        {
          testStepFail(@sysvar::CORE::sysLevelOfDetailFail, "", "Start/Stop position out of range. Wrong StartPos: %d [OR] StopPos: %d", iStartPos, iStopPos);
          return -1;
        }
      }
      else
      {
        testStepFail(@sysvar::CORE::sysLevelOfDetailFail, "", "Measurement Frame Block: %d is NOT active.", iBlock);
        return -1;
      }
    }
    else
    {
      testStepFail(@sysvar::CORE::sysLevelOfDetailFail, "", "Measurement Frame Not found in %d ms", iCount*10);
      return -1;
    }
  }
  }

/// <CAN_Communication>
// Performs 'iNumberOfIgnCycles' ignition cycles by setting ignition status to LOCK then ON.
// 11 seconds debounce time is set after IGN is set to ON.
void PerformIgnitionCycles(dword iNumberOfIgnCycles)
{
  int64 iIGN_OFF;
  int64 iIGN_ON;
  int64 iIGN_START;
  int i;
  int iStatusFrameID;
  
  stack long EvalManStepTable   = 0;
  stack int iTableResult        = 1;
  dword dIgnitionDebouncingTime = 10000;
  stack char cTmp[100];
  stack float fStartTime = timeNow()/100;
  
  getSignalValueForDescription(Ign_Stat_ST3::ISw_Stat_ST3, "I_C03_ISW_STAT_IGN_OFF", iIGN_OFF);
  getSignalValueForDescription(Ign_Stat_ST3::ISw_Stat_ST3, "I_C03_ISW_STAT_IGN_ON", iIGN_ON);
  getSignalValueForDescription(Ign_Stat_ST3::ISw_Stat_ST3, "I_C03_ISW_STAT_IGN_START", iIGN_START);
  
  if(@sysvar::ProjectConfiguration::sysMeasurementFrameID == getMessageID("Meas8_RBTM_FR_ST3"))
  {
    iStatusFrameID = 0x699; // RH
    SetDiagTarget("RBTMFL174");
    diagStopTesterPresent();
    SetDiagTarget("RBTMFR174");
  }
  else
  {
    iStatusFrameID = 0x698; // LH
    SetDiagTarget("RBTMFR174");
    diagStopTesterPresent();
    SetDiagTarget("RBTMFL174");
  }
  
  testWaitForTimeoutSilent(4000); // ECU does not go to sleep if diag request is sent right before this function is called (??).
  
  if(iNumberOfIgnCycles < 1)
  {
    testStepFail(@sysvar::CORE::sysLevelOfDetailFail, "", "Please input an Ignition cycles number larger than 0.");
    return;
  }
  if(iNumberOfIgnCycles > 256)
  {
    testStepFail(@sysvar::CORE::sysLevelOfDetailFail, "", "Please input an Ignition cycles number smaller than 257.");
    return;
  }
  
  // begin table
  snprintf(cTmp, elcount(cTmp), "Perform [%i] ignition cyles: Sleep -> Wake-Up -> Wait 11s (debouncing time = 10s) -> Sleep -> ...", iNumberOfIgnCycles);
  EvalManStepTable = TestInfoTable(cTmp);
  
  // header
  TestInfoHeadingBegin(EvalManStepTable, 0);
  TestInfoCell(EvalManStepTable, "Ignition cycle number.");
  TestInfoCell(EvalManStepTable, "Result");
  TestInfoHeadingEnd(EvalManStepTable);
  
  diagStopTesterPresent();
  for(i = 1; i <= iNumberOfIgnCycles; i++)
  {
    TestInfoRow(EvalManStepTable, 0);
    snprintf(cTmp, elcount(cTmp), "Ignition cycle: %i", i);
    TestInfoCell(EvalManStepTable, cTmp);
    
    // Set ECU to sleep.
    $ISw_Stat_ST3 = iIGN_OFF;
    
    testWaitForSysVar(sysvar::_NMControl::BODY3::Nodes::VectorSimulationNode::State, 10000); // Ready sleep
    testWaitForSysVar(sysvar::_NMControl::BODY3::Nodes::VectorSimulationNode::State, 30000); // Prepare BUS sleep
    testWaitForSysVar(sysvar::_NMControl::BODY3::Nodes::VectorSimulationNode::State, 10000); // BUS sleep
    
    if((@sysvar::_NMControl::BODY3::Nodes::VectorSimulationNode::State != BUS_SLEEP) || (TestWaitForMessage(iStatusFrameID, 1000) != 0))
    {
      TestInfoCell(EvalManStepTable, "fail");
      testStepFail(@sysvar::CORE::sysLevelOfDetailFail, "", "ECU did not go to sleep mode during Ignition cycle [%i]. Stopping sequence...", i);
      iTableResult = 0;
      $ISw_Stat_ST3 = iIGN_ON;
      break;
    }
    
    // Wake-Up ECU.
    $ISw_Stat_ST3 = iIGN_ON;
    testWaitForTimeoutSilent(dIgnitionDebouncingTime + 1000);
//    testWaitForTimeoutSilent(dIgnitionDebouncingTime / 2.5); // 10 / 2.5 = 4s
//    $ISw_Stat_ST3 = iIGN_START;
//    testWaitForTimeoutSilent(dIgnitionDebouncingTime / 5); // 10 / 5 = 2s
//    $ISw_Stat_ST3 = iIGN_ON;
//    testWaitForTimeoutSilent(dIgnitionDebouncingTime / 2.5 + 1000); // 10 / 2.5 + 1 = 5
    
    if((@sysvar::_NMControl::BODY3::Nodes::VectorSimulationNode::State == NORMAL_OPERATION) && (TestWaitForMessage(iStatusFrameID, 1000) == 1))
    {
      TestInfoCell(EvalManStepTable, "pass");
    }
    else
    {
      TestInfoCell(EvalManStepTable, "fail");
      testStepFail(@sysvar::CORE::sysLevelOfDetailFail, "", "ECU did not Wake-Up during Ignition cycle [%i]. Stopping sequence...", i);
      iTableResult = 0;
      break;
    }
  }
  diagStartTesterPresent();
  
  snprintf(cTmp, elcount(cTmp), "Total duration: [%.0f] s.", ((timeNow() / 100) - fStartTime) / 1000);
  TestInfoHeadingBegin(EvalManStepTable, 0);
  TestInfoCell(EvalManStepTable, cTmp, 2);
  TestInfoHeadingEnd(EvalManStepTable);
  
  if(iTableResult == 0)
  {
    testStepFail(@sysvar::CORE::sysLevelOfDetailFail, "", EvalManStepTable);
  }
  else
  {
    testStepPass(@sysvar::CORE::sysLevelOfDetailPass, "", EvalManStepTable);
  }
}

/// <CAN_Communication>
// Performs 'iNumberOfIgnCycles' ignition cycles by setting ignition status to LOCK then ON.
// 11 seconds debounce time is set after IGN is set to ON.
void PerformIgnitionCyclesTens(dword iNumberOfIgnCycles)
{
  int64 iIGN_LOCK;
  int64 iIGN_OFF;
  int64 iIGN_ON;
  int64 iIGN_START;
  int i;
  int iStatusFrameID;
  
  stack long EvalManStepTable   = 0;
  stack int iTableResult        = 1;
  dword dIgnitionDebouncingTime = 10000;
  stack char cTmp[100];
  stack float fStartTime = timeNow()/100;
  
  getSignalValueForDescription(Ign_Stat_ST3::ISw_Stat_ST3, "I_C03_ISW_STAT_IGN_LOCK", iIGN_LOCK);
  getSignalValueForDescription(Ign_Stat_ST3::ISw_Stat_ST3, "I_C03_ISW_STAT_IGN_OFF", iIGN_OFF);
  getSignalValueForDescription(Ign_Stat_ST3::ISw_Stat_ST3, "I_C03_ISW_STAT_IGN_ON", iIGN_ON);
  getSignalValueForDescription(Ign_Stat_ST3::ISw_Stat_ST3, "I_C03_ISW_STAT_IGN_START", iIGN_START);
  
  if(@sysvar::ProjectConfiguration::sysMeasurementFrameID == getMessageID("Meas8_RBTM_FR_ST3"))
  {
    iStatusFrameID = 0x699; // RH
    SetDiagTarget("RBTMFL174");
    diagStopTesterPresent();
    SetDiagTarget("RBTMFR174");
  }
  else
  {
    iStatusFrameID = 0x698; // LH
    SetDiagTarget("RBTMFR174");
    diagStopTesterPresent();
    SetDiagTarget("RBTMFL174");
  }

  testWaitForTimeoutSilent(4000); // ECU does not go to sleep if diag request is sent right before this function is called (??).
  
  if(iNumberOfIgnCycles < 1)
  {
    testStepFail(@sysvar::CORE::sysLevelOfDetailFail, "", "Please input an Ignition cycles number larger than 0.");
    return;
  }
  if(iNumberOfIgnCycles > 256)
  {
    testStepFail(@sysvar::CORE::sysLevelOfDetailFail, "", "Please input an Ignition cycles number smaller than 257.");
    return;
  }
  
  // begin table
  snprintf(cTmp, elcount(cTmp), "Perform [%i] ignition cyles: Sleep -> Wake-Up -> Wait 11s (debouncing time = 10s) -> Sleep -> ...", iNumberOfIgnCycles);
  EvalManStepTable = TestInfoTable(cTmp);
  
  // header
  TestInfoHeadingBegin(EvalManStepTable, 0);
  TestInfoCell(EvalManStepTable, "Ignition cycle number.");
  TestInfoCell(EvalManStepTable, "Result");
  TestInfoHeadingEnd(EvalManStepTable);
  
  diagStopTesterPresent();
  for(i = 1; i <= iNumberOfIgnCycles; i++)
  {
    TestInfoRow(EvalManStepTable, 0);
    snprintf(cTmp, elcount(cTmp), "Ignition cycle: %i", i);
    TestInfoCell(EvalManStepTable, cTmp);
    
    // Set ECU to sleep.
    $ISw_Stat_ST3 = iIGN_LOCK;
    
    testWaitForSysVar(sysvar::_NMControl::BODY3::Nodes::VectorSimulationNode::State, 10000); // Ready sleep
    testWaitForSysVar(sysvar::_NMControl::BODY3::Nodes::VectorSimulationNode::State, 30000); // Prepare BUS sleep
    testWaitForSysVar(sysvar::_NMControl::BODY3::Nodes::VectorSimulationNode::State, 10000); // BUS sleep
    
    if((@sysvar::_NMControl::BODY3::Nodes::VectorSimulationNode::State != BUS_SLEEP) || (TestWaitForMessage(iStatusFrameID, 1000) != 0))
    {
      TestInfoCell(EvalManStepTable, "fail");
      testStepFail(@sysvar::CORE::sysLevelOfDetailFail, "", "ECU did not go to sleep mode during Ignition cycle [%i]. Stopping sequence...", i);
      iTableResult = 0;
      $ISw_Stat_ST3 = iIGN_ON;
      break;
    }
    
    // Wake-Up ECU.
    $ISw_Stat_ST3 = iIGN_ON;
    testWaitForTimeoutSilent(dIgnitionDebouncingTime + 1000);
//    testWaitForTimeoutSilent(dIgnitionDebouncingTime / 2.5); // 10 / 2.5 = 4s
//    $ISw_Stat_ST3 = iIGN_START;
//    testWaitForTimeoutSilent(dIgnitionDebouncingTime / 5); // 10 / 5 = 2s
//    $ISw_Stat_ST3 = iIGN_ON;
//    testWaitForTimeoutSilent(dIgnitionDebouncingTime / 2.5 + 1000); // 10 / 2.5 + 1 = 5
    
    if((@sysvar::_NMControl::BODY3::Nodes::VectorSimulationNode::State == NORMAL_OPERATION) && (TestWaitForMessage(iStatusFrameID, 1000) == 1))
    {
      TestInfoCell(EvalManStepTable, "pass");
    }
    else
    {
      TestInfoCell(EvalManStepTable, "fail");
      testStepFail(@sysvar::CORE::sysLevelOfDetailFail, "", "ECU did not Wake-Up during Ignition cycle [%i]. Stopping sequence...", i);
      iTableResult = 0;
      break;
    }
  }
  diagStartTesterPresent();
  
  snprintf(cTmp, elcount(cTmp), "Total duration: [%.0f] s.", ((timeNow() / 100) - fStartTime) / 1000);
  TestInfoHeadingBegin(EvalManStepTable, 0);
  TestInfoCell(EvalManStepTable, cTmp, 2);
  TestInfoHeadingEnd(EvalManStepTable);
  
  if(iTableResult == 0)
  {
    testStepFail(@sysvar::CORE::sysLevelOfDetailFail, "", EvalManStepTable);
  }
  else
  {
    testStepPass(@sysvar::CORE::sysLevelOfDetailPass, "", EvalManStepTable);
  }
}

/// <CyberSecurity>
void SetSecTickCount()
{
 
  stack int i;
  diagRequest SecOC_Local_TickCount_Read Req_ReadSecTickCount;
  diagResponse SecOC_Local_TickCount_Read Resp_ReadSecTickCount;
  stack byte secTickCount[6];
  stack qword secTickCountValue;
  stack qword maxSecTickCountValue = 0;
  stack long currP2Timeout;
  stack long ret;
  stack char ecuQual[100]; 

//  TestStep(@sysvar::CORE::sysLevelOfDetailStep, "1","Authentication for all targets");
     
  currP2Timeout = diagGetP2Timeout();

  //testStep(@sysvar::CORE::sysLevelOfDetailStep, "","Authenticate");
  
  //AuthenticateECU(1);
  
  //if( @sysvar::LocalAuthentication::AuthResult == 1 )
  if(1)
  {
    testStep(@sysvar::CORE::sysLevelOfDetailStep, "","ReadSecTickCount");
   
    diagSendRequest(Req_ReadSecTickCount);
    testWaitForDiagRequestSent(Req_ReadSecTickCount,1000);
    ret = testWaitForDiagResponse(Req_ReadSecTickCount,currP2Timeout);
    if( ret == 1) // response received
    {
      diagGetLastResponse(Req_ReadSecTickCount,Resp_ReadSecTickCount);
      diagGetParameterRaw(Resp_ReadSecTickCount,"TickCount",secTickCount,elCount(secTickCount));
      ConvertFreshnessArrayToQword(secTickCount,secTickCountValue);

      sysGetVariableString("LocalAuthentication", "DiagTarget", ecuQual, elCount(ecuQual));
      testStep(@sysvar::CORE::sysLevelOfDetailStep, "","Target:%s LocalSecTickCount:0x%I64x",ecuQual,secTickCountValue);
      
      testStep(@sysvar::CORE::sysLevelOfDetailStep, "","Calculate max TickCount");
      if( secTickCountValue > maxSecTickCountValue )
        maxSecTickCountValue = secTickCountValue;
      testStep(@sysvar::CORE::sysLevelOfDetailStep,"","MaxSecTickCount:0x%I64x LocalSecTickCount:0x%I64x",maxSecTickCountValue,secTickCountValue);
      
      if( maxSecTickCountValue > 0 )
      {     
        @sysvar::SeckTickSynchronization::SyncedMaxSecTickCount = maxSecTickCountValue;
      }
   
    }
    else if( ret == 0) // p2 timeout occured
    {
      teststep(@sysvar::CORE::sysLevelOfDetailStep,"", "No response within P2 timeout.");
    }
    else
    {
      teststepFail(@sysvar::CORE::sysLevelOfDetailFail,"Error ocurred returncode=%i",ret);
    }
  }
  else
  {
    testStepFail();
  }
  
  if( @sysvar::SeckTickSynchronization::SignTickCountOffset == 1 )
    @sysvar::SeckTickSynchronization::CalculatedSecTickCountWithOffset = maxSecTickCountValue + @sysvar::SeckTickSynchronization::TickCountOffset;
  else
    @sysvar::SeckTickSynchronization::CalculatedSecTickCountWithOffset = maxSecTickCountValue - @sysvar::SeckTickSynchronization::TickCountOffset;
}


/// <CyberSecurity>
int ConvertFreshnessArrayToQword(byte array[], qword& freshness)
{
  stack int offset = 1;
  if( elCount(array) < 5 + offset )
    return -1;
  
  freshness = array[4 + offset] + 
              ((qword)array[3+ offset] << 8) + 
              ((qword)array[2+ offset] << 16) + 
              ((qword)array[1+ offset] << 24) + 
              ((qword)array[0+ offset] << 32);
  
  return 0;
}
/// <CyberSecurity>
int AuthenticateECU(int iAuthLevel)
{
  stack char targetName[400];
  stack char jobQualifier[40];
  stack int authResult;

//  sysGetVariableString("LocalAuthentication", "DiagTarget", targetName, elCount(targetName));
  diagGetCurrentEcu(targetName, 9);
  
  switch(iAuthLevel)
  {
    case 0:
      snprintf(jobQualifier,elCount(jobQualifier),"Job_Anybody");
      break;
    case 1:
      snprintf(jobQualifier,elCount(jobQualifier),"Job_Supplier");
      break;
    case 2:
      snprintf(jobQualifier,elCount(jobQualifier),"Job_Development_Enhanced");
      break;
    case 3:
      snprintf(jobQualifier,elCount(jobQualifier),"Job_Production");
      break;
    case 4:
      snprintf(jobQualifier,elCount(jobQualifier),"Job_After_Sales_Enhanced");
      break;
    case 5:
      snprintf(jobQualifier,elCount(jobQualifier),"Job_After_Sales_Standard");
      break;
    case 6:
      snprintf(jobQualifier,elCount(jobQualifier),"Job_After_Sales_Basic");
      break;
    case 7:
      snprintf(jobQualifier,elCount(jobQualifier),"Job_Internal_Diagnostic_Test_Tool");
      break;
    case 8:
      snprintf(jobQualifier,elCount(jobQualifier),"Job_ePTI_Test_Tool");
      break;
    default:
      break;
  }

  authResult = testWaitForDiagAuthCompleted(targetName, jobQualifier);
  if (authResult == 0)
  {
     testStep(@sysvar::CORE::sysLevelOfDetailStep, "", "ECU Authentication has succeeded");
  }
  else
  {
    testStepFail(@sysvar::CORE::sysLevelOfDetailFail, "", "ECU Authentication has failed with error code:%i", authResult);
  }
  
  return authResult;
}

/// <CyberSecurity>
SecVarCoding_Start()
{
  @sysvar::SecVarCodingPanel::Button_CodingStart = 1;
  testWaitForTimeout(50);
  @sysvar::SecVarCodingPanel::Button_CodingStart = 0;
  
  if(testWaitForSysVar(sysvar::SecVarCodingControl::SecVarCodingSequence, 5000) == 1)
  {
    if(@sysvar::SecVarCodingControl::SecVarCodingSequence == sysvar::SecVarCodingControl::SecVarCodingSequence::WriteData)
    {
      testStepPass("", "SecVarCoding_Start: 'Write data' state is active.");
    }
    else
    {
      testStepFail("","SecVarCoding_Start: 'Write Data' state expected.");
    }
  }
  else
  {
   testStepFail("","SecVarCoding_Start: Timeout"); 
  }
}

/// <CyberSecurity>
SecVarCoding_Finish()
{
  testWaitForTimeout(2000);
  @sysvar::SecVarCodingPanel::Button_CodingFinished = 1;
  testWaitForTimeout(50);
  @sysvar::SecVarCodingPanel::Button_CodingFinished = 0;
  
  if(testWaitForSysVar(sysvar::SecVarCodingPanel::LED_CodingFinished, 5000) == 1)
  {
    if(@sysvar::SecVarCodingPanel::LED_CodingFinished == 1)
    {
      testStepPass("", "SecVarCoding_Finish: Signature verification successfull");
    }
    else
    {
      testStepFail("","SecVarCoding_Finish: Signature verification failed.");
    }
  }
  else
  {
   testStepFail("","SecVarCoding_Finish: Timeout"); 
  }
}


//Run pre ts.
testfunction RunPreTs()
{
  byte bSW_Version_Read[3] = {0x22, 0xFD, 0x01};
  stack byte bSWV_Read_FD01[50];
  stack char cSoftwareVersion[500];
  
  @sysvar::ProjectConfiguration::EnableVINBroadcast = 1;
  @sysvar::CORE::sysLevelOfDetailPass = 3; // Set to < 3 to display passed test steps.
  @sysvar::CORE::sysLevelOfDetailStep = 3; // Set to < 3 to display test steps.
  
  DisplayRequirementsInfo();
  AddTestSetupInformation();
  
  // Start .blf and .asc logging of whole test case.
  testStep(@sysvar::CORE::sysLevelOfDetailStep, "", "Start .ASC and .BLF test case logging.");
  PreTS_StartLogging();
  
  // Configure power suppply.
  testStep(@sysvar::CORE::sysLevelOfDetailStep, "", "Configure power supply Voltage to %.2f V / Current limit to %.2f A then set the output on.", 12.5, 40.0);
  SetVoltage(12.5);
  SetCurrent(40);
  PowerOn();
  
//  testStep(@sysvar::CORE::sysLevelOfDetailStep, "STEP", "Set system voltage to nominal value.");
//  setSignal(PN14_Master_Stat1_ST3::PN14_SupBat_Volt_ST3, _fBAT_NOMINAL_VALUE);
//  testWaitForMessage(PN14_Master_Stat1_ST3_ID, PN14_Master_Stat1_ST3_Peridicity * 2);
  
  // Wait for ECU initialization in case PSU was set to off before RunPreTS().
  WaitECUInitialization();
     
  // Change ECU to left system side.
  if(testWaitForMessage(getMessageID("RBTM_FL_Stat_ST3"), 1100) == 1)
  {
   testStep(@sysvar::CORE::sysLevelOfDetailStep, "", "ECU is already set to left system side.");
   
   SetDiagTarget("RBTMFL174"); // Set diag target to left side.
   @sysvar::ProjectConfiguration::sysMeasurementFrameID = MeasurementFrameFL.id;
  }
  else
  {
   SetDiagTarget("RBTMFR174"); // Set diag target to right side.
   
   // Change ECU side.
   ChangeECUSide("left");
  }

  //Activate measurement frame. --> MF is active by default for R1.1
//  testStep(@sysvar::CORE::sysLevelOfDetailStep, "", "Activate measurement frame block 0x01");
//  ActivateMeasurementFrame(1);
  
  //Unlock ECU
//  SetECUMode("Unlock");

  //Write default calibration for HB.
//  iRequestSize = ConcatenateTwoByteArrays(bCalibrationRequest, bDefaultCalibration, bRequest);
//  diagResize(dRequest, iRequestSize);
//  diagSetPrimitiveData(dRequest, bRequest, elCount(bRequest));

//  SendDiagnosticRequest(dRequest, dResponse);
//  CheckPositiveResponse("Write default calibration", dRequest, dResponse);
  
  // Security authentification.
  AuthenticateECU(2); // Development_Enhanced
  
  // Enter development session.
  EnterDiagnosticSession("development");
  
  // Activate MF block 1
  ActivateMeasurementFrame(1);
  
  // Write default steps - Valid for R3.0
//  WriteCycleParameters();
//  Wait(1000);
  WriteStepParameters();

  // Wait due to issue: 813584 - [DAI_MMA][R02.0][TST][SW] Immediate diagnostic requests after write steps library modify Steps.
//  Wait(1000);
  
  // Enter default session.
  EnterDiagnosticSession("default");
  
  // Clear DTC memory.
  ClearAll();
  Wait(2000);
  
  // Soft reset ECU.
  ResetECU("soft");
  WaitECUInitialization();
  
  // Check that Start-up cycle is active.
  EvalManStepEqual("Check that Start-up cycle is active.", DetectCycleStep(START_UP, 1000), CYCLE_DETECTED);
  WaitCycleToFinish();
  
  // Security authentification.
  AuthenticateECU(2); // Development_Enhanced
  
  testStep(@sysvar::CORE::sysLevelOfDetailStep, "", "Wait for all storage conditions to be 'TRUE'");
  WaitDebounceTimer();
  testStep(@sysvar::CORE::sysLevelOfDetailStep, "", "Wait for all autotests to be executed."); // Longest autotest monitoring rate: Timeout ODOSPEEDOMETER = 1000ms
  ReturnAECStatusChangeTime(bERR_TIMEOUT_ODOSPEEDOMETER, bAEC_TestedNotPresent, 10, (_iMONITORING_RATE_TIMEOUT_ODOSPEEDOMETER + 100));
  
  // Check for DTC presence .
  CheckDTCPresenceInBenchInit();
  CheckAECPresenceInBenchInit();
  
  // Check SW version.---------------------------------------------
  @sysvar::CORE::sysLevelOfDetailPass = 0; // Set to < 3 to display passed test steps. 
  CheckSWVersion();
  
  // Diag Error Handling.
  if(SendDiagnosticRequest(dRequest, dResponse, bSW_Version_Read) == DIAG_SEND_OR_RECEIVE_ERROR) 
  {
    testStepFail(@sysvar::CORE::sysLevelOfDetailFail, "", "CheckSWVersion: Diagnostic request send or receive error.");
  }
  
  // Diag Error Handling.
  if(CheckPositiveResponse(dRequest, dResponse) == 0)
  {
    testStepFail(@sysvar::CORE::sysLevelOfDetailFail, "", "CheckSWVersion: Negative response received when reading software version: [0x%X].", dReadSWVersionResponse.GetResponseCode());
  }
  
  dResponse.GetPrimitiveData(bSWV_Read_FD01, elcount(bSWV_Read_FD01));
  ConvertByteArrInCharArr(bSWV_Read_FD01, cSoftwareVersion, dRequest.GetPrimitiveSize(), dResponse.GetPrimitiveSize() - 1, "false");
  EvalManStepEqual("Check Software Version (0x22 0xFD 0x01).", cSoftwareVersion, cSWV_Read_FD01);
  
  @sysvar::CORE::sysLevelOfDetailPass = 3;
  //--------------------------------------------------------------
  
  $Bckl_Sw_D_Stat_ST3  = 0; // Buckle switch driver state: 0    = "STAT_OK".
  $Bckl_Sw_FP_Stat_ST3 = 0; // Buckle switch passenger state: 0 = "STAT_OK".
  testWaitForSignalUpdate(Bckl_Sw_D_Stat_ST3, 42);
  
  SetSecTickCount();
  Wait(500); // Activation won't work if triggered imediately after tickcount.
  
  // Enter default session.
  testStep(@sysvar::CORE::sysLevelOfDetailStep, "", "Enter default session");
  EnterDiagnosticSession("default");
  
  @sysvar::CORE::sysLevelOfDetailPass = 0; // Set to < 3 to display passed test steps.
  @sysvar::CORE::sysLevelOfDetailStep = 0; // Set to < 3 to display test steps.
}

//Run post ts.
testfunction RunPostTs()
{
//  byte bRequest[100]; 
//  int index;
//  byte bAllAec[168];
//  int iThermalProtectionTimeout = 0;
  
  @sysvar::CORE::sysLevelOfDetailPass = 3; // Set to < 3 to display passed test steps.
  @sysvar::CORE::sysLevelOfDetailStep = 3; // Set to < 3 to display test steps.
    
  //////////////////////////////
  //FIB reset to be made
  //////////////////////////////

  //Set power supply
  testStep(@sysvar::CORE::sysLevelOfDetailStep, "", "Configure power supply Voltage to %.2f V / Current limit to %.2f A then set the output on.", 12.5, 40.0);
  SetVoltage(12.5);
  SetCurrent(40);
  PowerOn();
  
  // Wait for ECU initialization in case PSU was set to off before RunPreTS().
//  WaitECUInitialization();
  
  // Security authentification.
  AuthenticateECU(2); // Development_Enhanced
  
  EnterDiagnosticSession("Development");
  
  ActivateMeasurementFrame(1);
  
  //Check if SW_Self_Protection is qualified and wait do deskill
//  teststep(@sysvar::CORE::sysLevelOfDetailStep, "", "Check if SW_Self_Protection is qualified and wait to deskill");
//  EnterDiagnosticSession("supplier");
//  
//  SendDiagnosticRequest(dReadAllAECStatusRequest, dReadAllAECStatusResponse);
//
//  if (diagIsPositiveResponse(dReadAllAECStatusResponse) != 0 )
//  {
//    diagGetPrimitiveData(dReadAllAECStatusResponse, bAllAec, 168);
//  
//    for(index = 1; index <= (elcount(bAllAec)-3)/3; index+=1)
//    {
//      if (strncmp(_sAEC_NameConfig[index-1],"ERR_SW_SELF_PROTECTION", elCount(_sAEC_NameConfig[index-1]))==0 )
//      {
//        while (((bAllAec[index*3+2] == 0x2F) || (bAllAec[index*3+2] == 0x27)) && (iThermalProtectionTimeout < 60))
//        {
//          testWaitForTimeout(10000);
//          EnterDiagnosticSession("supplier");
//          SendDiagnosticRequest(dReadAllAECStatusRequest, dReadAllAECStatusResponse);
//            if (diagIsPositiveResponse(dReadAllAECStatusResponse) != 0 )
//            {
//              diagGetPrimitiveData(dReadAllAECStatusResponse, bAllAec, 168);
//            }
//            else
//            {
////              continue;
//            }
//        }
//        if ( iThermalProtectionTimeout != 0 ) 
//        {
//          if ( iThermalProtectionTimeout < 60 )
//          {
//            testStepPass(@sysvar::CORE::sysLevelOfDetailPass, "", "ERR_SW_SELF_PROTECTION is deskilled in %d ms", iThermalProtectionTimeout*10000);
//          }
//          else
//          {
//            testStepFail(@sysvar::CORE::sysLevelOfDetailFail, "AEC", "Autotest failed - Autoliv ERROR Code: %02x - %s - status: %02x",  bAllAec[index*3+1], _sAEC_NameConfig[index-1], bAllAec[index*3+2]);
//          }
//        }
//        else
//        {
//           testStepPass(@sysvar::CORE::sysLevelOfDetailPass, "", "ERR_SW_SELF_PROTECTION is not qualified");         
//        }
//      }
//    }
//  }
    // Check if SW_Self_Protection fault is active and wait for it's deskill time if it is.
   if((GetDTCStatusByExtendedData(bERR_SW_SELF_PROTECTION) & 0x01) == 0x01)
   {
     ReturnDTCStatusChangeTime(bERR_SW_SELF_PROTECTION, bDTC_DeskilledFailed, 2500, 300000);
   }
  
  
  //Activate measurement frame
//  testStep(@sysvar::CORE::sysLevelOfDetailStep, "", "Activate measurement frame block 0x01");
//  ActivateMeasurementFrame(1);
  
  //Security authentification.
//  testStep(@sysvar::CORE::sysLevelOfDetailStep, "", "Obtain security authentification");
//  AuthenticateECU(2); // Development_Enhanced
//  
//  // Enter development session.
//  EnterDiagnosticSession("development");
//  
//  //Write default steps - Valid for R1.1
//  testStep("STEP", "Write tensioning cycles with default steps");
//  dWriteStepsConfigRequest.SetPrimitiveData(bWriteDefaultStepsLibraryA, elcount(bWriteDefaultStepsLibraryA));
//  
//  SendDiagnosticRequest(dWriteStepsConfigRequest, dWriteStepsConfigResponse);
//  CheckPositiveResponse("Check positive response for writing steps 0 to 19", dWriteStepsConfigRequest, dWriteStepsConfigResponse);
//  
//  // Enter  default session.
//  EnterDiagnosticSession("default");
//  
  //Clear DTC memory.
  ClearAll();
  Wait(2000);
   
  //Soft reset ECU.
  ResetECU("soft");
  WaitECUInitialization();

  // Check that Start-up cycle is active.
  EvalManStepEqual("Check that Start-up cycle is active", DetectCycleStep(START_UP, 1000), CYCLE_DETECTED);
  WaitCycleToFinish();
  
  // Security authentification.
  AuthenticateECU(2); // Development_Enhanced
  
  testStep(@sysvar::CORE::sysLevelOfDetailStep, "", "Wait for all storage conditions to be 'TRUE'");
  WaitDebounceTimer();
  testStep(@sysvar::CORE::sysLevelOfDetailStep, "", "Wait for all autotests to be executed."); // Longest autotest monitoring rate: Timeout ODOSPEEDOMETER = 1000ms
  ReturnAECStatusChangeTime(bERR_TIMEOUT_ODOSPEEDOMETER, bAEC_TestedNotPresent, 10, (_iMONITORING_RATE_TIMEOUT_ODOSPEEDOMETER + 100));
  
  // Check DTC/AEC presence after clear.
  CheckDTCPresenceAfterClear();
  CheckAECPresenceAfterClear();
  
  //////////////////////////////
  //Warm reset detection to be made
  //////////////////////////////
  
  testStep(@sysvar::CORE::sysLevelOfDetailStep, "", "Enter default session");
  EnterDiagnosticSession("default");
  
  testStep(@sysvar::CORE::sysLevelOfDetailStep, "", "Stop .ASC and .BLF test case logging.");
  PostTS_StopLogging();
    
  @sysvar::CORE::sysLevelOfDetailPass = 0; // Set to < 3 to display passed test steps.
  @sysvar::CORE::sysLevelOfDetailStep = 0; // Set to < 3 to display test steps.
  iOriginalTestCaseTitleLength = 0; // Useful to set logs name. Please do not remove.
}

///// <DTC_management>
////Creates fault to the ECU based on the autotest ID
//// bFault - ID of the fault to be created ( bERR_MOSFET_LOW_SC or 0x05 )
//// Example:      CreateFault(bERR_HIGH_SIDE_SWITCH) or CreateFault(0x02)
void CreateFault(byte bFault)
{
  CreateFault(bFault, 0xFF);
}
//

///// <DTC_management>
////Creates fault to the ECU based on the autotest ID
//// bFault - ID of the fault to be created ( bERR_MOSFET_LOW_SC or 0x05 )
//// bInfo - aditional information to be added for particular autotests
//// Example:      CreateFault(bERR_ENABLE_OUT_OF_ORDER, NO_ACTIVATION) or CreateFault(0x03, NO_ACTIVATION)
void CreateFault(byte bFault, byte bInfo)
{
  stack char cFIBResponse[1000];
  stack char cExpectedFIBResponse[1000];
  stack int64 iSNA_FLT_Value;
  
  // Steering
  stack byte bDriver_Side_Diag   = 0x99;
  stack byte bDriver_Side_Signal = 0x99;
  stack char cDriver_Side_Signal[100];
  stack char cDriver_Side_Diag[100];
  stack int64 iSteering_RHD;
  stack int64 iSteering_LHD;
  
  switch(bFault)
  {
    case bERR_EXT_WDG_OUT_OF_ORDER:
      SendDiagnosticRequest(dForceExternalWDGStartRequest, dForceExternalWDGStartResponse);
      if(CheckPositiveResponse(dForceExternalWDGStartRequest, dForceExternalWDGStartResponse) == 1)
      {
        testStepPass(@sysvar::CORE::sysLevelOfDetailPass, "CreateFault", "ERR_EXT_WDG_OUT_OF_ORDER fault created using internal routine 0xF791.");
      }
      else
      {
        testStepFail(@sysvar::CORE::sysLevelOfDetailFail, "CreateFault", "ERR_EXT_WDG_OUT_OF_ORDER fault was not created: Negative response received for Force External WDG request: [0x%X].", dForceExternalWDGStartResponse.GetResponseCode());    
      }
      break;
    case bERR_NVM_NOT_PROG:
      SendDiagnosticRequest(dWriteHBCalibrationgRequest, dWriteHBCalibrationResponse, bClearHBCalibration);
      if(CheckPositiveResponse(dWriteHBCalibrationgRequest, dWriteHBCalibrationResponse) == 1)
      {
        testStepPass(@sysvar::CORE::sysLevelOfDetailPass, "CreateFault", "ERR_NVM_NOT_PROG fault created using HB calibration write service.");
      }
      else
      {
        testStepFail(@sysvar::CORE::sysLevelOfDetailFail, "CreateFault", "ERR_NVM_NOT_PROG fault was not created: Negative response received for Write HB calibration request: [0x%X].", dWriteHBCalibrationResponse.GetResponseCode());
      }
      break;
    case bERR_SPI_E_HW_ERROR:
      Open_Circuit(_iMISO, cFIBResponse);
      snprintf(cExpectedFIBResponse, elcount(cExpectedFIBResponse), "Open Circuit performed OK on channel %i", _iMISO);
      EvalManStepEqual("Make FIB fault.",  cFIBResponse, cExpectedFIBResponse);
      
      testStepPass("", "ERR_SPI_E_HW_ERROR fault created.");
      break;
    case bERR_CANSM_E_BUS_OFF:
      {
        Perform_Channel_Short(_iCAN_LOW, _iCAN_HIGH, cFIBResponse);
        snprintf(cExpectedFIBResponse, elcount(cExpectedFIBResponse), "Short between channels %i and %i performed OK.", _iCAN_LOW, _iCAN_HIGH);
        EvalManStepEqual("Make FIB fault.", cFIBResponse, cExpectedFIBResponse);
        testStepPass(@sysvar::CORE::sysLevelOfDetailPass, "CreateFault", "CANSM_E_BUS_OFF fault created.");
      }
      break;
    case FREE_MOTOR:
      Perform_Leakage(_iMOTOR_FREE, "false", "VCC", cFIBResponse);
      snprintf(cExpectedFIBResponse, elcount(cExpectedFIBResponse), "Short to VCC performed OK on channel %i", _iMOTOR_FREE);
      EvalManStepEqual("Connect free motor.",  cFIBResponse, cExpectedFIBResponse);
      break;
    case bERR_MOSFET_HIGH_SC:
      Set_DAC_Voltage(_iV_MOTOR_PLUS, (_iMOSFET_SC_HIGH_uC_THRESHOLD + 70),  cFIBResponse);
      snprintf(cExpectedFIBResponse, elcount(cExpectedFIBResponse), "Set DAC voltage to %i mV performed OK on channel %i",  (_iMOSFET_SC_HIGH_uC_THRESHOLD + 70), _iV_MOTOR_PLUS);
      EvalManStepEqual("Make FIB fault.",  cFIBResponse, cExpectedFIBResponse);
      
      Set_DAC_Voltage(_iV_MOTOR_MINUS,  (_iMOSFET_SC_HIGH_uC_THRESHOLD + 70),  cFIBResponse);
      snprintf(cExpectedFIBResponse, elcount(cExpectedFIBResponse), "Set DAC voltage to %i mV performed OK on channel %i",  (_iMOSFET_SC_HIGH_uC_THRESHOLD + 70), _iV_MOTOR_MINUS);
      EvalManStepEqual("Make FIB fault.",  cFIBResponse, cExpectedFIBResponse);

      Perform_Leakage(_iV_MOTOR_PLUS, "false", "DAC", cFIBResponse);
      strncpy(cExpectedFIBResponse, "", elcount(cExpectedFIBResponse));
      snprintf(cExpectedFIBResponse, elcount(cExpectedFIBResponse), "Short to DAC performed OK on channel %i", _iV_MOTOR_PLUS);
      EvalManStepEqual("Make FIB fault.",  cFIBResponse, cExpectedFIBResponse);
      
      Perform_Leakage(_iV_MOTOR_MINUS, "false", "DAC", cFIBResponse);
      strncpy(cExpectedFIBResponse, "", elcount(cExpectedFIBResponse));
      snprintf(cExpectedFIBResponse, elcount(cExpectedFIBResponse), "Short to DAC performed OK on channel %i", _iV_MOTOR_MINUS);
      EvalManStepEqual("Make FIB fault.",  cFIBResponse, cExpectedFIBResponse);
      
      testStepPass("", "MOSFET_HIGH_SC fault created");
      break;
      
    case bERR_MOSFET_LOW_SC:
      Set_DAC_Voltage(_iV_MOTOR_PLUS, (_iMOSFET_SC_LOW_uC_THRESHOLD - 20),  cFIBResponse);
      snprintf(cExpectedFIBResponse, elcount(cExpectedFIBResponse), "Set DAC voltage to %i mV performed OK on channel %i", (_iMOSFET_SC_LOW_uC_THRESHOLD - 20), _iV_MOTOR_PLUS);
      EvalManStepEqual("Make FIB fault.",  cFIBResponse, cExpectedFIBResponse);
      
      Set_DAC_Voltage(_iV_MOTOR_MINUS, (_iMOSFET_SC_LOW_uC_THRESHOLD - 20),  cFIBResponse);
      snprintf(cExpectedFIBResponse, elcount(cExpectedFIBResponse), "Set DAC voltage to %i mV performed OK on channel %i", (_iMOSFET_SC_LOW_uC_THRESHOLD - 20), _iV_MOTOR_MINUS);
      EvalManStepEqual("Make FIB fault.",  cFIBResponse, cExpectedFIBResponse);

      Perform_Leakage(_iV_MOTOR_PLUS, "false", "DAC", cFIBResponse);
      strncpy(cExpectedFIBResponse, "", elcount(cExpectedFIBResponse));
      snprintf(cExpectedFIBResponse, elcount(cExpectedFIBResponse), "Short to DAC performed OK on channel %i", _iV_MOTOR_PLUS);
      EvalManStepEqual("Make FIB fault.",  cFIBResponse, cExpectedFIBResponse);
      
      Perform_Leakage(_iV_MOTOR_MINUS, "false", "DAC", cFIBResponse);
      strncpy(cExpectedFIBResponse, "", elcount(cExpectedFIBResponse));
      snprintf(cExpectedFIBResponse, elcount(cExpectedFIBResponse), "Short to DAC performed OK on channel %i", _iV_MOTOR_MINUS);
      EvalManStepEqual("Make FIB fault.",  cFIBResponse, cExpectedFIBResponse);
      
      testStepPass("", "MOSFET_LOW_SC fault created");
      break;
      
    case bERR_MOSFET_OC:
      Set_DAC_Voltage(_iV_MOTOR_PLUS, (_iMOSFET_OC_HIGH_uC_THRESHOLD - 50),  cFIBResponse);
      snprintf(cExpectedFIBResponse, elcount(cExpectedFIBResponse), "Set DAC voltage to %i mV performed OK on channel %i", (_iMOSFET_OC_HIGH_uC_THRESHOLD - 50), _iV_MOTOR_PLUS);
      EvalManStepEqual("Make FIB fault.",  cFIBResponse, cExpectedFIBResponse);
      
      Set_DAC_Voltage(_iV_MOTOR_MINUS, (_iMOSFET_OC_HIGH_uC_THRESHOLD - 50),  cFIBResponse);
      snprintf(cExpectedFIBResponse, elcount(cExpectedFIBResponse), "Set DAC voltage to %i mV performed OK on channel %i", (_iMOSFET_OC_HIGH_uC_THRESHOLD - 50), _iV_MOTOR_MINUS);
      EvalManStepEqual("Make FIB fault.",  cFIBResponse, cExpectedFIBResponse);

      Perform_Leakage(_iV_MOTOR_PLUS, "false", "DAC", cFIBResponse);
      strncpy(cExpectedFIBResponse, "", elcount(cExpectedFIBResponse));
      snprintf(cExpectedFIBResponse, elcount(cExpectedFIBResponse), "Short to DAC performed OK on channel %i", _iV_MOTOR_PLUS);
      EvalManStepEqual("Make FIB fault.",  cFIBResponse, cExpectedFIBResponse);
      
      Perform_Leakage(_iV_MOTOR_MINUS, "false", "DAC", cFIBResponse);
      strncpy(cExpectedFIBResponse, "", elcount(cExpectedFIBResponse));
      snprintf(cExpectedFIBResponse, elcount(cExpectedFIBResponse), "Short to DAC performed OK on channel %i", _iV_MOTOR_MINUS);
      EvalManStepEqual("Make FIB fault.",  cFIBResponse, cExpectedFIBResponse);
      
      testStepPass("", "MOSFET_OC fault created");
      break;
      
    case bERR_HALL_SENSOR:
//      Set_DAC_Voltage(_iHALL_A, (_iHES_HIGH_THRESHOLD + 50),  cFIBResponse);
//      snprintf(cExpectedFIBResponse, elcount(cExpectedFIBResponse), "Set DAC voltage to %i mV performed OK on channel %i", (_iHES_HIGH_THRESHOLD + 50), _iHALL_A);
//      EvalManStepEqual("Make FIB fault.",  cFIBResponse, cExpectedFIBResponse);
//
//      Perform_Leakage(_iHALL_A, "false", "DAC", cFIBResponse);
//      strncpy(cExpectedFIBResponse, "", elcount(cExpectedFIBResponse));
//      snprintf(cExpectedFIBResponse, elcount(cExpectedFIBResponse), "Short to DAC performed OK on channel %i", _iHALL_A);
//      EvalManStepEqual("Make FIB fault.",  cFIBResponse, cExpectedFIBResponse);
      Open_Circuit(_iHALL_A, cFIBResponse);
      strncpy(cExpectedFIBResponse, "", elcount(cExpectedFIBResponse));
      snprintf(cExpectedFIBResponse, elcount(cExpectedFIBResponse), "Open Circuit performed OK on channel %i", _iHALL_A);
      EvalManStepEqual("Make FIB fault.",  cFIBResponse, cExpectedFIBResponse);
      
      testStepPass("", "HALL_SENSOR fault created");
      break;
      
    case bERR_ENABLE_OUT_OF_ORDER:
      if (bInfo == NO_ACTIVATION)
      {
        Perform_Leakage(_iRD_EN_HB_P, "false", "VCC", cFIBResponse);
        strncpy(cExpectedFIBResponse, "", elcount(cExpectedFIBResponse));
        snprintf(cExpectedFIBResponse, elcount(cExpectedFIBResponse), "Short to VCC performed OK on channel %i", _iRD_EN_HB_P);
        EvalManStepEqual("Make FIB fault.",  cFIBResponse, cExpectedFIBResponse);

        Perform_Leakage(_iRD_EN_HB_N, "false", "VCC", cFIBResponse);
        strncpy(cExpectedFIBResponse, "", elcount(cExpectedFIBResponse));
        snprintf(cExpectedFIBResponse, elcount(cExpectedFIBResponse), "Short to VCC performed OK on channel %i", _iRD_EN_HB_N);
        EvalManStepEqual("Make FIB fault.",  cFIBResponse, cExpectedFIBResponse);
        
        testStepPass("", "ENABLE_OUT_OF_ORDER fault created");
      }
      else
        if (bInfo == ACTIVATION)
        {
          Perform_Leakage(_iRD_EN_HB_P, "false", "GND", cFIBResponse);
          strncpy(cExpectedFIBResponse, "", elcount(cExpectedFIBResponse));
          snprintf(cExpectedFIBResponse, elcount(cExpectedFIBResponse), "Short to GND performed OK on channel %i", _iRD_EN_HB_P);
          EvalManStepEqual("Make FIB fault.",  cFIBResponse, cExpectedFIBResponse);

          Perform_Leakage(_iRD_EN_HB_N, "false", "GND", cFIBResponse);
          strncpy(cExpectedFIBResponse, "", elcount(cExpectedFIBResponse));
          snprintf(cExpectedFIBResponse, elcount(cExpectedFIBResponse), "Short to GND performed OK on channel %i", _iRD_EN_HB_N);
          EvalManStepEqual("Make FIB fault.",  cFIBResponse, cExpectedFIBResponse);
          
          testStepPass("", "ENABLE_OUT_OF_ORDER fault created");
        }
        else
        {
          testStepFail("", "Parameter value for CreateFault function is invalid");
        }
        
      break;
      
    case bERR_HW_SELF_PROTECTION:
      Set_DAC_Voltage(_iVIS_TENSION, (NVP_u16HWSelfProtecCurrentThrs + 100),  cFIBResponse);
      snprintf(cExpectedFIBResponse, elcount(cExpectedFIBResponse), "Set DAC voltage to %i mV performed OK on channel %i", (NVP_u16HWSelfProtecCurrentThrs + 100), _iVIS_TENSION);
      EvalManStepEqual("Make FIB fault.",  cFIBResponse, cExpectedFIBResponse);

      Perform_Leakage(_iVIS_TENSION, "false", "DAC", cFIBResponse);
      strncpy(cExpectedFIBResponse, "", elcount(cExpectedFIBResponse));
      snprintf(cExpectedFIBResponse, elcount(cExpectedFIBResponse), "Short to DAC performed OK on channel %i", _iVIS_TENSION);
      EvalManStepEqual("Make FIB fault.",  cFIBResponse, cExpectedFIBResponse);
      testStepPass("", "HW_SELF_PROTECTION fault created");
      break;
      
    case bERR_HIGH_SIDE_SWITCH:
      Set_DAC_Voltage(_iHS1_LVL, NVP_u16HSSWRegTestLowThreshold - 30,  cFIBResponse);
      snprintf(cExpectedFIBResponse, elcount(cExpectedFIBResponse), "Set DAC voltage to %i mV performed OK on channel %i", NVP_u16HSSWRegTestLowThreshold - 30, _iHS1_LVL);
      EvalManStepEqual("Make FIB fault.",  cFIBResponse, cExpectedFIBResponse);

      Perform_Leakage(_iHS1_LVL, "false", "DAC", cFIBResponse);
      strncpy(cExpectedFIBResponse, "", elcount(cExpectedFIBResponse));
      snprintf(cExpectedFIBResponse, elcount(cExpectedFIBResponse), "Short to DAC performed OK on channel %i", _iHS1_LVL);
      EvalManStepEqual("Make FIB fault.",  cFIBResponse, cExpectedFIBResponse);
      testStepPass("", "HIGH_SIDE_SWITCH fault created");
      break;
      
    case bERR_WARM_RESET:
      Perform_Leakage(_iWARM_RST, "false", "GND", 500, cFIBResponse);
      strncpy(cExpectedFIBResponse, "", elcount(cExpectedFIBResponse));
      snprintf(cExpectedFIBResponse, elcount(cExpectedFIBResponse), "Short to GND performed OK on channel %i for %i ms", _iWARM_RST, 500);
      EvalManStepEqual("Make FIB fault.",  cFIBResponse, cExpectedFIBResponse);
      Wait(500);
      Open_Circuit(_iWARM_RST, cFIBResponse);
      strncpy(cExpectedFIBResponse, "", elcount(cExpectedFIBResponse));
      snprintf(cExpectedFIBResponse, elcount(cExpectedFIBResponse), "Open Circuit performed OK on channel %i", _iWARM_RST);
      EvalManStepEqual("Make FIB fault.",  cFIBResponse, cExpectedFIBResponse);
      testStepPass("", "WARM_RESET fault created");
      break;
      
    case bERR_TEMPERATURE_SENSOR_FAILURE:
      //TBD
      break;
      
    case bERR_MOTOR_BLOCKED:
      if (bInfo == NO_ACTIVATION)
      {
        Set_DAC_Voltage(_iVIS_RELEASE, 1700,  cFIBResponse);
        snprintf(cExpectedFIBResponse, elcount(cExpectedFIBResponse), "Set DAC voltage to %i mV performed OK on channel %i", 1700, _iVIS_RELEASE);
        EvalManStepEqual("Make FIB fault.",  cFIBResponse, cExpectedFIBResponse);

        Perform_Leakage(_iVIS_RELEASE, "false", "DAC", cFIBResponse);
        strncpy(cExpectedFIBResponse, "", elcount(cExpectedFIBResponse));
        snprintf(cExpectedFIBResponse, elcount(cExpectedFIBResponse), "Short to DAC performed OK on channel %i", _iVIS_RELEASE);
        EvalManStepEqual("Make FIB fault.",  cFIBResponse, cExpectedFIBResponse);
        
        testStepPass("", "MOTOR_BLOCKED fault created");
      }
      else 
        if (bInfo == STARTUP)  
        {
          Set_DAC_Voltage(_iVIS_RELEASE, 1000,  cFIBResponse);
          snprintf(cExpectedFIBResponse, elcount(cExpectedFIBResponse), "Set DAC voltage to %i mV performed OK on channel %i", 1000, _iVIS_RELEASE);
          EvalManStepEqual("Make FIB fault.",  cFIBResponse, cExpectedFIBResponse);

          Perform_Leakage(_iVIS_RELEASE, "false", "DAC", cFIBResponse);
          strncpy(cExpectedFIBResponse, "", elcount(cExpectedFIBResponse));
          snprintf(cExpectedFIBResponse, elcount(cExpectedFIBResponse), "Short to DAC performed OK on channel %i", _iVIS_RELEASE);
          EvalManStepEqual("Make FIB fault.",  cFIBResponse, cExpectedFIBResponse);
          
          testStepPass("", "MOTOR_BLOCKED fault created");
        }
        else
          if (bInfo == RELEASING)
          {
            Set_DAC_Voltage(_iVIS_RELEASE, 1800,  cFIBResponse);
            snprintf(cExpectedFIBResponse, elcount(cExpectedFIBResponse), "Set DAC voltage to %i mV performed OK on channel %i", 1800, _iVIS_RELEASE);
            EvalManStepEqual("Make FIB fault.",  cFIBResponse, cExpectedFIBResponse);

            Perform_Leakage(_iVIS_RELEASE, "false", "DAC", cFIBResponse);
            strncpy(cExpectedFIBResponse, "", elcount(cExpectedFIBResponse));
            snprintf(cExpectedFIBResponse, elcount(cExpectedFIBResponse), "Short to DAC performed OK on channel %i", _iVIS_RELEASE);
            EvalManStepEqual("Make FIB fault.",  cFIBResponse, cExpectedFIBResponse);
            
            testStepPass("", "MOTOR_BLOCKED fault created");
          }
          else
          {
            testStepFail("", "Parameter value for CreateFault function is invalid");
          }
      break;
      
    case bERR_MOTOR_IN_SC:
      Set_DAC_Voltage(_iVIS_RELEASE, 1900,  cFIBResponse);
      snprintf(cExpectedFIBResponse, elcount(cExpectedFIBResponse), "Set DAC voltage to %i mV performed OK on channel %i", 1900, _iVIS_RELEASE);
      EvalManStepEqual("Make FIB fault.",  cFIBResponse, cExpectedFIBResponse);

      Perform_Leakage(_iVIS_RELEASE, "false", "DAC", cFIBResponse);
      strncpy(cExpectedFIBResponse, "", elcount(cExpectedFIBResponse));
      snprintf(cExpectedFIBResponse, elcount(cExpectedFIBResponse), "Short to DAC performed OK on channel %i", _iVIS_RELEASE);
      EvalManStepEqual("Make FIB fault.",  cFIBResponse, cExpectedFIBResponse);
      
      testStepPass("", "MOTOR_IN_SC fault created");
      break;
      
    case bERR_MOTOR_CURRENT:
      //TBD
      break;
      
    case bERR_MOTOR_DISCONNECTED:
      if (bInfo == PHISICALLY) 
      {
        Perform_Leakage(_iMOTOR_DISCONNECTED, "false", "VCC", cFIBResponse);
        strncpy(cExpectedFIBResponse, "", elcount(cExpectedFIBResponse));
        snprintf(cExpectedFIBResponse, elcount(cExpectedFIBResponse), "Short to DAC performed OK on channel %i", _iMOTOR_DISCONNECTED);
        EvalManStepEqual("Make FIB fault.",  cFIBResponse, cExpectedFIBResponse);
        testStepPass("", "MOTOR_DISCONNECTED fault created");
        
      }
      else
      {
        Set_DAC_Voltage(_iV_MOTOR_PLUS, 700,  cFIBResponse);
        snprintf(cExpectedFIBResponse, elcount(cExpectedFIBResponse), "Set DAC voltage to %i mV performed OK on channel %i", 700, _iV_MOTOR_PLUS);
        EvalManStepEqual("Make FIB fault.",  cFIBResponse, cExpectedFIBResponse);
        
        Set_DAC_Voltage(_iV_MOTOR_MINUS, 350,  cFIBResponse);
        snprintf(cExpectedFIBResponse, elcount(cExpectedFIBResponse), "Set DAC voltage to %i mV performed OK on channel %i", 350, _iV_MOTOR_MINUS);
        EvalManStepEqual("Make FIB fault.",  cFIBResponse, cExpectedFIBResponse);

        Perform_Leakage(_iV_MOTOR_PLUS, "false", "DAC", cFIBResponse);
        strncpy(cExpectedFIBResponse, "", elcount(cExpectedFIBResponse));
        snprintf(cExpectedFIBResponse, elcount(cExpectedFIBResponse), "Short to DAC performed OK on channel %i", _iV_MOTOR_PLUS);
        EvalManStepEqual("Make FIB fault.",  cFIBResponse, cExpectedFIBResponse);
        
        Perform_Leakage(_iV_MOTOR_MINUS, "false", "DAC", cFIBResponse);
        strncpy(cExpectedFIBResponse, "", elcount(cExpectedFIBResponse));
        snprintf(cExpectedFIBResponse, elcount(cExpectedFIBResponse), "Short to DAC performed OK on channel %i", _iV_MOTOR_MINUS);
        EvalManStepEqual("Make FIB fault.",  cFIBResponse, cExpectedFIBResponse);
        
        testStepPass("", "MOTOR_DISCONNECTED fault created");
      }
      break;
      
    case bERR_MOTOR_ORDER:
      //TBD
      break;
      
    case bERR_SW_SELF_PROTECTION:
      Set_DAC_Voltage(_iVIS_TENSION, 1500,  cFIBResponse);
      snprintf(cExpectedFIBResponse, elcount(cExpectedFIBResponse), "Set DAC voltage to %i mV performed OK on channel %i", 1500, _iVIS_TENSION);
      EvalManStepEqual("Make FIB fault.",  cFIBResponse, cExpectedFIBResponse);

      Perform_Leakage(_iVIS_TENSION, "false", "DAC", cFIBResponse);
      strncpy(cExpectedFIBResponse, "", elcount(cExpectedFIBResponse));
      snprintf(cExpectedFIBResponse, elcount(cExpectedFIBResponse), "Short to DAC performed OK on channel %i", _iVIS_TENSION);
      EvalManStepEqual("Make FIB fault.",  cFIBResponse, cExpectedFIBResponse);
      
      testStepPass("", "SW_SELF_PROTECTION fault created");
      break;
      
    case bERR_BAT_PWR_OVER_VOLTAGE:
      if ( bInfo == PS )
      {
        SetVoltage(NVP_u16OverKL30QualificationThrs + 0.4);
        testStepPass("", "BAT_PWR_OVER_VOLTAGE fault created");
      }
      else
      {
        Set_DAC_Voltage(_iKL30_LVL, (NVP_u16OverKL30QualificationThrs_uC + 100), cFIBResponse);
        snprintf(cExpectedFIBResponse, elcount(cExpectedFIBResponse), "Set DAC voltage to %i mV performed OK on channel %i", (NVP_u16OverKL30QualificationThrs_uC + 100), _iKL30_LVL);
        EvalManStepEqual("Make FIB fault.",  cFIBResponse, cExpectedFIBResponse);

        Perform_Leakage(_iKL30_LVL, "false", "DAC", cFIBResponse);
        strncpy(cExpectedFIBResponse, "", elcount(cExpectedFIBResponse));
        snprintf(cExpectedFIBResponse, elcount(cExpectedFIBResponse), "Short to DAC performed OK on channel %i", _iKL30_LVL);
        EvalManStepEqual("Make FIB fault.",  cFIBResponse, cExpectedFIBResponse);
        
        testStepPass("", "BAT_PWR_OVER_VOLTAGE fault created");
      }
      break;
      
    case bERR_BAT_PWR_UNDER_VOLTAGE:
      if ( bInfo == PS )
      {
        SetVoltage(NVP_u16UnderKL30QualificationThrs - 0.3);
        testStepPass("", "BAT_PWR_UNDER_VOLTAGE fault created");
      }
      else
      {
        Set_DAC_Voltage(_iKL30_LVL, (NVP_u16UnderKL30QualificationThrs_uC - 100), cFIBResponse);
        snprintf(cExpectedFIBResponse, elcount(cExpectedFIBResponse), "Set DAC voltage to %i mV performed OK on channel %i", (NVP_u16UnderKL30QualificationThrs_uC - 100), _iKL30_LVL);
        EvalManStepEqual("Make FIB fault.",  cFIBResponse, cExpectedFIBResponse);

        Perform_Leakage(_iKL30_LVL, "false", "DAC", cFIBResponse);
        strncpy(cExpectedFIBResponse, "", elcount(cExpectedFIBResponse));
        snprintf(cExpectedFIBResponse, elcount(cExpectedFIBResponse), "Short to DAC performed OK on channel %i", _iKL30_LVL);
        EvalManStepEqual("Make FIB fault.",  cFIBResponse, cExpectedFIBResponse);
        
        testStepPass("", "BAT_PWR_UNDER_VOLTAGE fault created");
      }
      break;
      
    case bERR_BAT_PWR_UNDER_VOLTAGE_SYSTEM:
    {
      setSignal(PN14_Master_Stat1_ST3::PN14_SupBat_Volt_ST3, (_iBAT_PWR_UNDER_VOLTAGE_SYSTEM_Qualification_Thrs - 0.025));
      if(testWaitForMessage(PN14_Master_Stat1_ST3_ID, PN14_Master_Stat1_ST3_Peridicity * 2) == 1)
      {
        testStepPass(@sysvar::CORE::sysLevelOfDetailPass, "CreateFault", "BAT_PWR_UNDER_VOLTAGE_SYSTEM fault created: 'PN14_SupBat_Volt_ST3' set to %0.3fV", (_iBAT_PWR_UNDER_VOLTAGE_SYSTEM_Qualification_Thrs - 0.025));
      }
      else
      {
        testStepFail(@sysvar::CORE::sysLevelOfDetailFail, "CreateFault", "BAT_PWR_UNDER_VOLTAGE_SYSTEM fault was created but there was an error when waiting for transmission of message: 'PN14_Master_Stat1_ST3'.");
      }
    break;
    }
    
    case bERR_BAT_PWR_OVER_VOLTAGE_SYSTEM:
    {
      setSignal(PN14_Master_Stat1_ST3::PN14_SupBat_Volt_ST3, (_iBAT_PWR_OVER_VOLTAGE_SYSTEM_Qualification_Thrs + 0.025));
      if(testWaitForMessage(PN14_Master_Stat1_ST3_ID, PN14_Master_Stat1_ST3_Peridicity * 2) == 1)
      {
        testStepPass(@sysvar::CORE::sysLevelOfDetailPass, "CreateFault", "BAT_PWR_OVER_VOLTAGE_SYSTEM fault created: 'PN14_SupBat_Volt_ST3' set to %0.3fV", (_iBAT_PWR_OVER_VOLTAGE_SYSTEM_Qualification_Thrs + 0.025));
      }
      else
      {
        testStepFail(@sysvar::CORE::sysLevelOfDetailFail, "CreateFault", "BAT_PWR_OVER_VOLTAGE_SYSTEM fault was created but there was an error when waiting for transmission of message: 'PN14_Master_Stat1_ST3'.");
      }
    break;
    }
    
    case bERR_BAT_PWR_UNDER_VOLTAGE_DURING_TENS:
      if (bInfo == NO_ACTIVATION)
      {
        EnableTriggeringPreconditions();
        LaunchMasterBeltProfile(PRE_SAFE_1, PRESAFE);
        testWaitForTimeout(200);
        CheckStartedProfile(PRE_SAFE_1);
        SetVoltage(NVP_u16UnderKL30DuringTensQualificationThrs - 0.4);
        ReturnAECStatusChangeTime(bERR_BAT_PWR_UNDER_VOLTAGE_DURING_TENS, bAEC_Qualified, 10, _iQualif_BAT_PWR_UNDER_VOLTAGE_TENSIONING * 1.1);
        LaunchMasterBeltProfile(NOLVL, PRESAFE);
        WaitCycleToFinish();
        testStepPass("", "BAT_PWR_UNDER_VOLTAGE_TENSIONING fault created");
      }
      else
      {
        SetVoltage(NVP_u16UnderKL30DuringTensQualificationThrs - 0.4);
        testStepPass("", "BAT_PWR_UNDER_VOLTAGE_TENSIONING fault created");
      }
      break;
      
    case bERR_BAT_PWR_OVER_VOLTAGE_DURING_TENS:
      if (bInfo == NO_ACTIVATION)
      {
        EnableTriggeringPreconditions();
        LaunchMasterBeltProfile(PRE_SAFE_1, PRESAFE);
        testWaitForTimeout(200);
        CheckStartedProfile(PRE_SAFE_1);
        SetVoltage(NVP_u16OverKL30DuringTensQualificationThrs + 0.4);
        ReturnAECStatusChangeTime(bERR_BAT_PWR_OVER_VOLTAGE_DURING_TENS, bAEC_Qualified, 10, _iQualif_BAT_PWR_OVER_VOLTAGE_TENSIONING * 1.1);
        LaunchMasterBeltProfile(NOLVL, PRESAFE);
        WaitCycleToFinish();
        testStepPass("", "BAT_PWR_OVER_VOLTAGE_TENSIONING fault created");
      }
      else
      {
        SetVoltage(NVP_u16OverKL30DuringTensQualificationThrs + 0.8);
        testStepPass("", "BAT_PWR_OVER_VOLTAGE_TENSIONING fault created");
      }
      break;
      
    case bERR_LOW_FORCE_END_OF_LIFE:
      break;
      
    case bERR_COMFORT_END_OF_LIFE:
      break;
      
    case bERR_IMPLAUSIBLE_DATA_PRESAFE:
    {
      if(bInfo > 9)
      {
        bInfo = bInfo / 10;
      }
      else
      {
        if(testWaitForMessage(PresfAct_Adj_ST3_ID, PresfAct_Adj_ST3_Periodicity * 2) != 1)
        {
         testStepFail(@sysvar::CORE::sysLevelOfDetailFail, "CreateFault", "ERR_IMPLAUSIBLE_DATA_PRESAFE fault was not created: error when waiting for message: 'PresfAct_Adj_ST3'.");
         return;
        }
      }
      
      switch(bInfo)
      {
        case CRC:
          if(testDisableCRCCalculation(PresfAct_Adj_ST3) == 0)
          {
            testStepPass(@sysvar::CORE::sysLevelOfDetailPass, "CreateFault", "ERR_IMPLAUSIBLE_DATA_PRESAFE fault created (CRC).");
          }
          break;
        case SQC:
          if(TestDisableMsgSequenceCounter(PresfAct_Adj_ST3) == 0)
          {
            testStepPass(@sysvar::CORE::sysLevelOfDetailPass, "CreateFault", "ERR_IMPLAUSIBLE_DATA_PRESAFE fault created (SQC).");
          }
          break;
        case SNA:
          if(getSignalValueForDescription(PresfAct_Adj_ST3::Presf_Lvl_ST3, "I_C04_PRESF_LVL_V2_SNA", iSNA_FLT_Value) == 0)
          {
            setsignal(Presf_Lvl_ST3, iSNA_FLT_Value);
            testStepPass(@sysvar::CORE::sysLevelOfDetailPass, "CreateFault", "ERR_IMPLAUSIBLE_DATA_PRESAFE fault created (SNA).");
          }
          else
          {
            testStepFail(@sysvar::CORE::sysLevelOfDetailFail, "CreateFault", "Error getting value for description for 'Presf_Lvl_ST3'.");
          }
          break;
        default: testStepFail(@sysvar::CORE::sysLevelOfDetailFail, "CreateFault", "Parameter value for CreateFault function is invalid");
          break;
      }
    break;
   }
    
    case bERR_IMPLAUSIBLE_DATA_ORC:
    {
      if(bInfo > 9)
      {
        bInfo = bInfo / 10;
      }
      else
      {
        if(testWaitForMessage(Impact3_ST3_ID, Impact3_ST3_Periodicity * 2) != 1)
        {
          testStepFail(@sysvar::CORE::sysLevelOfDetailFail, "CreateFault", "ERR_IMPLAUSIBLE_DATA_ORC fault was not created: error when waiting for message: 'Impact3_ST3'.");
          return;
        }
      }
      
      switch(bInfo)
      {
        case CRC:
          if(testDisableCRCCalculation(Impact3_ST3) == 0)
          {
            testStepPass(@sysvar::CORE::sysLevelOfDetailPass, "CreateFault", "ERR_IMPLAUSIBLE_DATA_ORC fault created (CRC).");
          }
          break;
        case SQC:
          if(TestDisableMsgSequenceCounter(Impact3_ST3) == 0)
          {
            testStepPass(@sysvar::CORE::sysLevelOfDetailPass, "CreateFault", "ERR_IMPLAUSIBLE_DATA_ORC fault created (SQC).");
          }
          break;
        default: testStepFail(@sysvar::CORE::sysLevelOfDetailFail, "CreateFault", "Parameter value for CreateFault function is invalid: CRC or SQC must be specified");
          break;
      }
      
      break;
    }
    
    case bERR_IMPLAUSIBLE_DATA_BUCKLE:
    {
      if(bInfo > 9) // no wait time for next frame scenario.
      {
        bInfo = bInfo / 10;
      }
      else
      {
        if(testWaitForMessage(Bckl_Sw_Fx_Stat_ST3_ID, Bckl_Sw_Fx_Stat_ST3_Periodicity * 2) != 1)
        {
          testStepFail(@sysvar::CORE::sysLevelOfDetailFail, "CreateFault", "ERR_IMPLAUSIBLE_DATA_BUCKLE fault was not created: error when waiting for message: 'Bckl_Sw_Fx_Stat_ST3'.");
          return;
        }
      }
      
      switch(bInfo)
      {
        case CRC:
          if(testDisableCRCCalculation(Bckl_Sw_Fx_Stat_ST3) == 0)
          {
            testStepPass(@sysvar::CORE::sysLevelOfDetailPass, "CreateFault", "ERR_IMPLAUSIBLE_DATA_BUCKLE fault created (CRC).");
          }
          break;
        case SQC:
          if(TestDisableMsgSequenceCounter(Bckl_Sw_Fx_Stat_ST3) == 0)
          {
            testStepPass(@sysvar::CORE::sysLevelOfDetailPass, "CreateFault", "ERR_IMPLAUSIBLE_DATA_BUCKLE fault created (SQC).");
          }
          break;
        case SNA:
          if(@sysvar::ProjectConfiguration::sysMeasurementFrameID == MeasurementFrameFL.id)
          {
            if(getSignalValueForDescription(Bckl_Sw_Fx_Stat_ST3::Bckl_Sw_D_Stat_ST3, "I_C02_BCKL_SW_STAT_SNA", iSNA_FLT_Value) == 0)
            {
              SetSignal(Bckl_Sw_D_Stat_ST3, iSNA_FLT_Value);
              testStepPass(@sysvar::CORE::sysLevelOfDetailPass, "CreateFault", "ERR_IMPLAUSIBLE_DATA_BUCKLE fault created (Bckl_Sw_D_Stat_ST3 = SNA).");
            }
            else
            {
              testStepFail(@sysvar::CORE::sysLevelOfDetailFail, "CreateFault", "Error getting value for description for 'I_C02_BCKL_SW_STAT_SNA'.");
            }
          }
          else
          {
            if(getSignalValueForDescription(Bckl_Sw_Fx_Stat_ST3::Bckl_Sw_FP_Stat_ST3, "I_C02_BCKL_SW_STAT_SNA", iSNA_FLT_Value) == 0)
            {
              SetSignal(Bckl_Sw_FP_Stat_ST3, iSNA_FLT_Value);
              testStepPass(@sysvar::CORE::sysLevelOfDetailPass, "CreateFault", "ERR_IMPLAUSIBLE_DATA_BUCKLE fault created (Bckl_Sw_FP_Stat_ST3 = SNA).");
            }
            else
            {
              testStepFail(@sysvar::CORE::sysLevelOfDetailFail, "CreateFault", "Error getting value for description for 'I_C02_BCKL_SW_STAT_SNA'.");
            }
          }
          break;
        case FLT:
          if(@sysvar::ProjectConfiguration::sysMeasurementFrameID == MeasurementFrameFL.id)
          {
            if(getSignalValueForDescription(Bckl_Sw_Fx_Stat_ST3::Bckl_Sw_D_Stat_ST3, "I_C02_BCKL_SW_STAT_FLT", iSNA_FLT_Value) == 0)
            {
              SetSignal(Bckl_Sw_D_Stat_ST3, iSNA_FLT_Value);
              testStepPass(@sysvar::CORE::sysLevelOfDetailPass, "CreateFault", "ERR_IMPLAUSIBLE_DATA_BUCKLE fault created (Bckl_Sw_D_Stat_ST3 = FLT).");
            }
            else
            {
              testStepFail(@sysvar::CORE::sysLevelOfDetailFail, "CreateFault", "Error getting value for description for 'I_C02_BCKL_SW_STAT_FLT'.");
            }
          }
          else
          {
            if(getSignalValueForDescription(Bckl_Sw_Fx_Stat_ST3::Bckl_Sw_FP_Stat_ST3, "I_C02_BCKL_SW_STAT_FLT", iSNA_FLT_Value) == 0)
            {
              SetSignal(Bckl_Sw_FP_Stat_ST3, iSNA_FLT_Value);
              testStepPass(@sysvar::CORE::sysLevelOfDetailPass, "CreateFault", "ERR_IMPLAUSIBLE_DATA_BUCKLE fault created (Bckl_Sw_FP_Stat_ST3 = FLT).");
            }
            else
            {
              testStepFail(@sysvar::CORE::sysLevelOfDetailFail, "CreateFault", "Error getting value for description for 'I_C02_BCKL_SW_STAT_FLT'.");
            }
          }
          break;
          default: testStepFail(@sysvar::CORE::sysLevelOfDetailFail, "CreateFault", "Parameter value for CreateFault function is invalid: CRC, SNA, FLT or SQC must be specified");
            break;
      }
      break;
    }
    
    case bERR_IMPLAUSIBLE_DATA_POWERTRAIN_RDY:
    {
      if(bInfo > 9) // no wait time for next frame scenario.
      {
        bInfo = bInfo / 10;
      }
      else
      {
        if(testWaitForMessage(PT4_PTCoor4_ST3_ID, PT4_PTCoor4_ST3_Periodicity * 2) != 1)
        {
          testStepFail(@sysvar::CORE::sysLevelOfDetailFail, "CreateFault", "ERR_IMPLAUSIBLE_DATA_POWERTRAIN_RDY fault was not created: error when waiting for message: 'PT4_PTCoor4_ST3'.");
          return;
        }
      }
      
      switch(bInfo)
      {
       case SNA:
        {
          if(getSignalValueForDescription(PT4_PTCoor4_ST3::PT4_PTCoor_PT_Rdy_ST3, "I_C02_PT_RDY_V2_SNA", iSNA_FLT_Value) == 0)
          {
            setSignal(PT4_PTCoor_PT_Rdy_ST3, iSNA_FLT_Value);
            testStepPass(@sysvar::CORE::sysLevelOfDetailPass, "CreateFault", "ERR_IMPLAUSIBLE_DATA_POWERTRAINRDY fault created for frame 0x35F: PT4_PTCoor_PT_Rdy_ST3 = SNA.");
          }
          else
          {
            testStepFail(@sysvar::CORE::sysLevelOfDetailFail, "CreateFault", "Error getting value for description for 'I_C02_PT_RDY_V2_SNA'.");
          }
          break;
        }
        default: testStepFail(@sysvar::CORE::sysLevelOfDetailFail, "CreateFault", "Parameter value for ERR_IMPLAUSIBLE_DATA_POWERTRAIN_RDY scenario is invalid: SNA or SNA_NO_WAIT must be specified.");
          break;
      }
      break;
    }
    
    case bERR_IMPLAUSIBLE_DATA_POWERTRAIN_DRV:
    {
      if(bInfo > 9) // no wait time for next frame scenario.
      {
        bInfo = bInfo / 10;
      }
      else
      {
        if(testWaitForMessage(PT4_PTCoor_DrvPosn_Gear_ST3_ID, PT4_PTCoor_DrvPosn_Gear_ST3_Periodicity * 2) != 1)
        {
          testStepFail(@sysvar::CORE::sysLevelOfDetailFail, "CreateFault", "ERR_IMPLAUSIBLE_DATA_POWERTRAIN fault was not created: error when waiting for message: 'PT4_PTCoor_DrvPosn_Gear_ST3'.");
          return;
        }
      }
      
      switch(bInfo)
      {
        case SNA:
        {
          if(getSignalValueForDescription(PT4_PTCoor_DrvPosn_Gear_ST3::PT4_PTCoor_DrvPosn_Stat_ST3, "I_C04_DRVPOSN_ST3_SNA", iSNA_FLT_Value) == 0)
          {
            setSignal(PT4_PTCoor_DrvPosn_Stat_ST3, iSNA_FLT_Value);
            testStepPass(@sysvar::CORE::sysLevelOfDetailPass, "CreateFault", "ERR_IMPLAUSIBLE_DATA_POWERTRAIN_DRV fault created for frame 0x582: PT4_PTCoor_DrvPosn_Stat_ST3 = SNA.");
          }
          else
          {
            testStepFail(@sysvar::CORE::sysLevelOfDetailFail, "CreateFault", "Error getting value for description for 'I_C04_DRVPOSN_ST3_SNA'.");
          }
          break;
        }
        default: testStepFail(@sysvar::CORE::sysLevelOfDetailFail, "CreateFault", "Parameter value for ERR_IMPLAUSIBLE_DATA_POWERTRAIN_DRV scenario is invalid: SNA or SNA_NO_WAIT must be specified.");
          break;
      }
      break;
    }
    
    case bERR_IMPLAUSIBLE_DATA_IGNITION:
    {
      if(bInfo > 9) // no wait time for next frame scenario.
      {
        bInfo = bInfo / 10;
      }
      else
      {
        if(testWaitForMessage(Ign_Stat_ST3_ID, Ign_Stat_ST3_Periodicity * 2) != 1)
        {
          testStepFail(@sysvar::CORE::sysLevelOfDetailFail, "CreateFault", "ERR_IMPLAUSIBLE_DATA_IGNITION fault was not created: error when waiting for message: 'Ign_Stat_ST3'.");
          return;
        }
      }
      
      switch(bInfo)
      {
        case CRC:
          if(testDisableCRCCalculation(Ign_Stat_ST3) == 0)
          {
            testStepPass(@sysvar::CORE::sysLevelOfDetailPass, "CreateFault", "ERR_IMPLAUSIBLE_DATA_IGNITION fault created (CRC).");
          }
          break;
        case SQC:
          if(TestDisableMsgSequenceCounter(Ign_Stat_ST3) == 0)
          {
            testStepPass(@sysvar::CORE::sysLevelOfDetailPass, "CreateFault", "ERR_IMPLAUSIBLE_DATA_IGNITION fault created (SQC).");
          }
          break;
        case SNA:
          if(getSignalValueForDescription(Ign_Stat_ST3::ISw_Stat_ST3, "I_C03_ISW_STAT_SNA", iSNA_FLT_Value) == 0)
          {
            setSignal(Ign_Stat_ST3::ISw_Stat_ST3, iSNA_FLT_Value);
            testStepPass(@sysvar::CORE::sysLevelOfDetailPass, "CreateFault", "ERR_IMPLAUSIBLE_DATA_IGNITION fault created (SNA).");
          }
          else
          {
            testStepFail(@sysvar::CORE::sysLevelOfDetailFail, "CreateFault", "Error getting value for description for 'I_C03_ISW_STAT_SNA'.");
          }
          break;
        default: testStepFail(@sysvar::CORE::sysLevelOfDetailPass, "CreateFault", "Parameter value for ERR_IMPLAUSIBLE_DATA_IGNITION function is invalid: SNA, SQC or CRC must be specified.");
          break;
      }
    break;
    }
    
    case bERR_TIMEOUT_BUCKLE:
    {
      if(bInfo != TIMEOUT_NO_WAIT)
      {
        if(testWaitForMessage(Bckl_Sw_Fx_Stat_ST3_ID, Bckl_Sw_Fx_Stat_ST3_Periodicity * 2) != 1)
        {
          testStepFail(@sysvar::CORE::sysLevelOfDetailFail, "CreateFault", "ERR_TIMEOUT_BUCKLE fault was not created: error when waiting for message: 'Bckl_Sw_Fx_Stat_ST3'.");
          return;
        }
      }
      
      if(testDisableMsg(Bckl_Sw_Fx_Stat_ST3) == 0)
      {
        testStepPass(@sysvar::CORE::sysLevelOfDetailPass, "CreateFault", "ERR_TIMEOUT_BUCKLE fault created.");
      }
      else
      {
        testStepFail(@sysvar::CORE::sysLevelOfDetailFail, "CreateFault", "'testDisableMsg' general error for message: 'Bckl_Sw_Fx_Stat_ST3'.");
      }
      break;
    }
    
    case bERR_TIMEOUT_PRESAFE:
    {
      if(bInfo != TIMEOUT_NO_WAIT)
      {
        if(testWaitForMessage(PresfAct_Adj_ST3_ID, PresfAct_Adj_ST3_Periodicity * 2) != 1)
        {
          testStepFail(@sysvar::CORE::sysLevelOfDetailFail, "CreateFault", "ERR_TIMEOUT_PRESAFE fault was not created: error when waiting for message: 'PresfAct_Adj_ST3'.");
          return;
        }
      }
      
      if(testDisableMsg(PresfAct_Adj_ST3) == 0)
      {
        testStepPass(@sysvar::CORE::sysLevelOfDetailPass, "CreateFault", "ERR_TIMEOUT_PRESAFE fault created.");
      }
      else
      {
        testStepFail(@sysvar::CORE::sysLevelOfDetailFail, "CreateFault", "'testDisableMsg' general error for message: 'PresfAct_Adj_ST3'.");
      }
      break;
    }
    
    case bERR_TIMEOUT_IGNITION:
    {
      if(bInfo != TIMEOUT_NO_WAIT)
      {
        if(testWaitForMessage(Ign_Stat_ST3_ID, Ign_Stat_ST3_Periodicity * 2) != 1)
        {
          testStepFail(@sysvar::CORE::sysLevelOfDetailFail, "CreateFault", "ERR_TIMEOUT_IGNITION fault was not created: error when waiting for message: 'Ign_Stat_ST3'.");
          return;
        }
      }
      
      if(testDisableMsg(Ign_Stat_ST3) == 0)
      {
        testStepPass(@sysvar::CORE::sysLevelOfDetailPass, "CreateFault", "ERR_TIMEOUT_IGNITION fault created.");
      }
      else
      {
        testStepFail(@sysvar::CORE::sysLevelOfDetailFail, "CreateFault", "'testDisableMsg' general error for message: 'Ign_Stat_ST3'.");
      }
      break;
    }
    
    case bERR_TIMEOUT_POWERTRAIN:
    {
      if(bInfo != TIMEOUT_NO_WAIT)
      {
        if(testWaitForMessage(PT4_PTCoor4_ST3_ID, PT4_PTCoor4_ST3_Periodicity * 2) != 1)
        {
          testStepFail(@sysvar::CORE::sysLevelOfDetailFail, "CreateFault", "ERR_TIMEOUT_POWERTRAIN fault was not created: error when waiting for message: 'PT4_PTCoor4_ST3'.");
          return;
        }
      }
      
      if(testDisableMsg(PT4_PTCoor4_ST3) == 0)
      {
        testStepPass(@sysvar::CORE::sysLevelOfDetailPass, "CreateFault", "ERR_TIMEOUT_POWERTRAIN fault created.");
      }
      else
      {
        testStepFail(@sysvar::CORE::sysLevelOfDetailFail, "CreateFault", "'testDisableMsg' general error for message: 'PT4_PTCoor4_ST3'.");
      }
      break;
    }
    
    case bERR_TIMEOUT_BELT_HANDOVER_LEFT:
    {
      if(bInfo != TIMEOUT_NO_WAIT)
      {
        if(testWaitForMessage(BeltHdOvr_FL_State_ST3_ID, BeltHdOvr_FL_State_ST3_Periodicity * 2) != 1)
        {
          testStepFail(@sysvar::CORE::sysLevelOfDetailFail, "CreateFault", "ERR_TIMEOUT_BELT_HANDOVER_LEFT fault was not created: error when waiting for message: 'BeltHdOvr_FL_State_ST3'.");
          return;
        }
      }
      
      if(testDisableMsg(BeltHdOvr_FL_State_ST3) == 0)
      {
        testStepPass(@sysvar::CORE::sysLevelOfDetailPass, "CreateFault", "ERR_TIMEOUT_BELT_HANDOVER_LEFT fault created.");
      }
      else
      {
        testStepFail(@sysvar::CORE::sysLevelOfDetailFail, "CreateFault", "'testDisableMsg' general error for message: 'BeltHdOvr_FL_State_ST3'.");
      }
      break;
    }
    
    case bERR_TIMEOUT_BELT_HANDOVER_RIGHT:
    {
      if(bInfo != TIMEOUT_NO_WAIT)
      {
        if(testWaitForMessage(BeltHdOvr_FR_State_ST3_ID, BeltHdOvr_FR_State_ST3_Periodicity * 2) != 1)
        {
          testStepFail(@sysvar::CORE::sysLevelOfDetailFail, "CreateFault", "ERR_TIMEOUT_BELT_HANDOVER_RIGHT fault was not created: error when waiting for message: 'BeltHdOvr_FR_State_ST3'.");
          return;
        }
      }
      
      if(testDisableMsg(BeltHdOvr_FR_State_ST3) == 0)
      {
        testStepPass(@sysvar::CORE::sysLevelOfDetailPass, "CreateFault", "ERR_TIMEOUT_BELT_HANDOVER_RIGHT fault created.");
      }
      else
      {
        testStepFail(@sysvar::CORE::sysLevelOfDetailFail, "CreateFault", "'testDisableMsg' general error for message: 'BeltHdOvr_FR_State_ST3'.");
      }
      break;
    }
    
    case bERR_TIMEOUT_API_INTERFACE:
    {
      if(bInfo != TIMEOUT_NO_WAIT)
      {
        if(testWaitForMessage(SBeltTens_SP_Lvl_ST3_ID, SBeltTens_SP_Lvl_ST3_Periodicity * 2) != 1)
        {
          testStepFail(@sysvar::CORE::sysLevelOfDetailFail, "CreateFault", "ERR_TIMEOUT_API_INTERFACE fault was not created: error when waiting for message: 'SBeltTens_SP_Lvl_ST3'.");
          return;
        }
      }
      
      if(testDisableMsg(SBeltTens_SP_Lvl_ST3) == 0)
      {
        testStepPass(@sysvar::CORE::sysLevelOfDetailPass, "CreateFault", "ERR_TIMEOUT_API_INTERFACE fault created.");
      }
      else
      {
        testStepFail(@sysvar::CORE::sysLevelOfDetailFail, "CreateFault", "'testDisableMsg' general error for message: 'SBeltTens_SP_Lvl_ST3'.");
      }
      break;
    }
    
    case bERR_TIMEOUT_BELT_ADJ:
    {
      if(bInfo != TIMEOUT_NO_WAIT)
      {
        if(testWaitForMessage(BeltAdj_UI_Set_Rq_ST3_ID, BeltAdj_UI_Set_Rq_ST3_Periodicity * 2) != 1)
        {
          testStepFail(@sysvar::CORE::sysLevelOfDetailFail, "CreateFault", "ERR_TIMEOUT_BELT_ADJ fault was not created: error when waiting for message: 'BeltAdj_UI_Set_Rq_ST3'.");
          return;
        }
      }
      
      if(testDisableMsg(BeltAdj_UI_Set_Rq_ST3) == 0)
      {
        testStepPass(@sysvar::CORE::sysLevelOfDetailPass, "CreateFault", "ERR_TIMEOUT_BELT_ADJ fault created.");
      }
      else
      {
        testStepFail(@sysvar::CORE::sysLevelOfDetailFail, "CreateFault", "'testDisableMsg' general error for message: 'BeltAdj_UI_Set_Rq_ST3'.");
      }
      break;
    }
    
    case bERR_STEERING_CONFIGURATION:
    {
      if(bInfo == SNA)
      {
        getSignalValueForDescription(EVC_CfgList_01_08_Pr5_ST3::EVC_List03_StStyle_ST3, "I_C02_STSTYLE_SNA", iSNA_FLT_Value);
        setSignal(EVC_List03_StStyle_ST3, iSNA_FLT_Value);
        testWaitForMessage(0x6E0, 1200);
        testStepPass(@sysvar::CORE::sysLevelOfDetailPass, "CreateFault" ,"ERR_STEERING_CONFIGURATION fault created; EVC_List03_StStyle_ST3 was set to: 0x%02X (%s)", iSNA_FLT_Value, "I_C02_STSTYLE_SNA");
//        testStepFAIL(@sysvar::CORE::sysLevelOfDetailFail, "", "As of R6.1, ERR_STEERING_CONFIGURATION does not take SNA value into account");
      }
      else if(SendDiagnosticRequest(dReadVehicleEquipmentConfigurationDataRequest, dReadVehicleEquipmentConfigurationDataResponse) == DIAG_SEND_OR_RECEIVE_ERROR)
      {
        testStepFail(@sysvar::CORE::sysLevelOfDetailFail, "CreateFault" ,"Diagnostic request send or receive error for 'ReadVehicleEquipmentConfigurationDataRequest'.");
        return;
      }
      else
      {
        bDriver_Side_Diag = diagGetParameter(dReadVehicleEquipmentConfigurationDataResponse, "Equipment_1.Links_Rechtslenker");
        diagGetParameter(dReadVehicleEquipmentConfigurationDataResponse, "Equipment_1.Links_Rechtslenker", cDriver_Side_Diag, elcount(cDriver_Side_Diag));
        testStep(@sysvar::CORE::sysLevelOfDetailStep, "", "ECU Driver side according to 'Vehicle_Equipment_Read' is: 0x%02X  (%s).", bDriver_Side_Diag, cDriver_Side_Diag);
        
        bDriver_Side_Signal = getSignal(EVC_List03_StStyle_ST3);
        getSignalDescriptionForValue(EVC_List03_StStyle_ST3, bDriver_Side_Signal, cDriver_Side_Signal, elcount(cDriver_Side_Signal));
        
        getSignalValueForDescription(EVC_CfgList_01_08_Pr5_ST3::EVC_List03_StStyle_ST3, "I_C02_STSTYLE_LHD", iSteering_LHD);
        getSignalValueForDescription(EVC_CfgList_01_08_Pr5_ST3::EVC_List03_StStyle_ST3, "I_C02_STSTYLE_RHD", iSteering_RHD);
        
        switch(bDriver_Side_Diag)
        {
          case bVEH_LHD:
              if(bDriver_Side_Signal != iSteering_LHD)
              {
                 testStepFail(@sysvar::CORE::sysLevelOfDetailFail, "CreateFault" ,"SteeringStyle configuration (%s) is already different from 'EVC_List03_StStyle_ST3' signal (%s).", cDriver_Side_Diag, cDriver_Side_Signal);
              }
              else
              {
                getSignalDescriptionForValue(EVC_List03_StStyle_ST3, iSteering_RHD, cDriver_Side_Signal, elcount(cDriver_Side_Signal));
                setSignal(EVC_List03_StStyle_ST3, iSteering_RHD);
                testWaitForMessage(0x6E0, 1200);
                testStepPass(@sysvar::CORE::sysLevelOfDetailPass, "CreateFault" ,"ERR_STEERING_CONFIGURATION fault created; EVC_List03_StStyle_ST3 was set to: 0x%02X (%s)", iSteering_RHD, cDriver_Side_Signal);
              }
            break;
          case bVEH_RHD:
              if(bDriver_Side_Signal != iSteering_RHD)
              {
                 testStepFail(@sysvar::CORE::sysLevelOfDetailFail, "CreateFault", "SteeringStyle configuration (%s) is already different from 'EVC_List03_StStyle_ST3' signal (%s).", cDriver_Side_Diag, cDriver_Side_Signal);
              }
              else
              {
                getSignalDescriptionForValue(EVC_List03_StStyle_ST3, iSteering_LHD, cDriver_Side_Signal, elcount(cDriver_Side_Signal));
                setSignal(EVC_List03_StStyle_ST3, iSteering_LHD);
                testWaitForMessage(0x6E0, 1200);
                testStepPass(@sysvar::CORE::sysLevelOfDetailPass, "CreateFault", "ERR_STEERING_CONFIGURATION fault created; EVC_List03_StStyle_ST3 was set to: 0x%02X (%s)", iSteering_LHD, cDriver_Side_Signal);
              }
            break;
        }
      }
      break;
    }
    
    case bERR_TIMEOUT_ODOSPEEDOMETER:
    {
      if(bInfo != TIMEOUT_NO_WAIT)
      {
        if(testWaitForMessage(DI_OdoSpeedometer_ST3_ID, DI_OdoSpeedometer_ST3_Periodicity * 2) != 1)
        {
          testStepFail(@sysvar::CORE::sysLevelOfDetailFail, "CreateFault", "ERR_TIMEOUT_ODOSPEEDOMETER fault was not created: error when waiting for message: 'DI_OdoSpeedometer_ST3'.");
          return;
        }
      }
      
      if(testDisableMsg(DI_OdoSpeedometer_ST3) == 0)
      {
        testStepPass(@sysvar::CORE::sysLevelOfDetailPass, "CreateFault", "ERR_TIMEOUT_ODOSPEEDOMETER fault created.");
      }
      else
      {
        testStepFail(@sysvar::CORE::sysLevelOfDetailFail, "CreateFault", "'testDisableMsg' general error for message: 'DI_OdoSpeedometer_ST3'.");
      }
      break;
    }
    
    case bERR_TIMEOUT_VSS_SECTICKCOUNT:
    {
      if(bInfo != TIMEOUT_NO_WAIT)
      {
        if(testWaitForMessage(VSS_TP_SecTickCount_Lvl2_ST3_ID, VSS_TP_VIN_ST3_Periodicity * 2) != 1)
        {
          testStepFail(@sysvar::CORE::sysLevelOfDetailFail, "CreateFault", "ERR_TIMEOUT_VSS_SECTICKCOUNT fault was not created: error when waiting for message: 'VSS_TP_SecTickCount_Lvl2_ST3'.");
          return;
        }
      }
      @sysvar::RBTM_Simulation::Secured_Tickcount_Timeout = 1;
      break;
    }
    
    case bERR_INCOMPATIBLE_CONFIGURATION_VIN:
    {
      if(bInfo != TIMEOUT_NO_WAIT)
      {
        testWaitForSysVar(sysvar::SecuredVINBroadcast::TriggerSecuredVINBroadcast, 1500);
        if(@sysvar::SecuredVINBroadcast::TriggerSecuredVINBroadcast == 0)
        {
          testWaitForSysVar(sysvar::SecuredVINBroadcast::TriggerSecuredVINBroadcast, 1500);
        }
        
        // VIN is sent in bursts of 4 frames every 1000 ms.
        testWaitForMessage(VSS_TP_VIN_ST3_ID, VSS_TP_VIN_ST3_Periodicity * 2);
        testWaitForMessage(VSS_TP_VIN_ST3_ID, VSS_TP_VIN_ST3_Periodicity * 2);
        testWaitForMessage(VSS_TP_VIN_ST3_ID, VSS_TP_VIN_ST3_Periodicity * 2);
        testWaitForMessage(VSS_TP_VIN_ST3_ID, VSS_TP_VIN_ST3_Periodicity * 2);
      }
      
      @ProjectConfiguration::EnableVINBroadcast = 0;
      break;
    }
    case bERR_IMPLAUSIBLE_DATA_API:
    {
      if(bInfo > 9) // no wait time for next frame scenario.
      {
        bInfo = bInfo / 10;
      }
      else
      {
        if(testWaitForMessage(SBeltTens_SP_Lvl_ST3_ID, SBeltTens_SP_Lvl_ST3_Periodicity * 2) != 1)
        {
          testStepFail(@sysvar::CORE::sysLevelOfDetailFail, "CreateFault", "ERR_IMPLAUSIBLE_DATA_API fault was not created: error when waiting for message: 'SBeltTens_SP_Lvl_ST3'.");
          return;
        }
      }
      
      switch(bInfo)
      {
        case CRC:
          if(testDisableCRCCalculation(SBeltTens_SP_Lvl_ST3) == 0)
          {
            testStepPass(@sysvar::CORE::sysLevelOfDetailPass, "CreateFault", "ERR_IMPLAUSIBLE_DATA_API fault created (CRC).");
          }
          break;
        case SQC:
          if(TestDisableMsgSequenceCounter(SBeltTens_SP_Lvl_ST3) == 0)
          {
            testStepPass(@sysvar::CORE::sysLevelOfDetailPass, "CreateFault", "ERR_IMPLAUSIBLE_DATA_API fault created (SQC).");
          }
          break;
        case SNA:
          if(@sysvar::ProjectConfiguration::sysMeasurementFrameID == MeasurementFrameFL.id)
          {
            if(getSignalValueForDescription(SBeltTens_SP_Lvl_ST3::RBTMFL_SP_Lvl_Rq_ST35 , "I_C06_RBTM_LVL_RQ_SNA", iSNA_FLT_Value) == 0)
            {
              SetSignal(RBTMFL_SP_Lvl_Rq_ST35, iSNA_FLT_Value);
              testStepPass(@sysvar::CORE::sysLevelOfDetailPass, "CreateFault", "ERR_IMPLAUSIBLE_DATA_API fault created (RBTMFL_SP_Lvl_Rq_ST35  = SNA).");
            }
            else
            {
              testStepFail(@sysvar::CORE::sysLevelOfDetailFail, "CreateFault", "Error getting value for description for 'I_C06_RBTM_LVL_RQ_SNA'.");
            }
          }
          else
          {
            if(getSignalValueForDescription(SBeltTens_SP_Lvl_ST3::RBTMFR_SP_Lvl_Rq_ST35, "I_C06_RBTM_LVL_RQ_SNA", iSNA_FLT_Value) == 0)
            {
              SetSignal(RBTMFR_SP_Lvl_Rq_ST35, iSNA_FLT_Value);
              testStepPass(@sysvar::CORE::sysLevelOfDetailPass, "CreateFault", "ERR_IMPLAUSIBLE_DATA_API fault created (RBTMFR_SP_Lvl_Rq_ST35 = SNA).");
            }
            else
            {
              testStepFail(@sysvar::CORE::sysLevelOfDetailFail, "CreateFault", "Error getting value for description for 'I_C06_RBTM_LVL_RQ_SNA'.");
            }
          }
          break;
        default: testStepFail(@sysvar::CORE::sysLevelOfDetailFail, "CreateFault", "Parameter value for CreateFault function is invalid: CRC, SNA or SQC must be specified");
          break;
      }
      break;
    }
    default:
      testStepFail(@sysvar::CORE::sysLevelOfDetailFail, "CreateFault" , "Incorrect input.");
      break;

  }
}

///// <DTC_management>
////Removes a fault based on the autotest ID
//// bFault - ID of the fault to be created ( bERR_MOSFET_LOW_SC or 0x05 )
//// Example:      CreateFault(bERR_HIGH_SIDE_SWITCH) or CreateFault(0x02)
void RemoveFault(byte bFault)
{
  RemoveFault(bFault, 0xFF);
}
//  
///// <DTC_management>
////Removes a fault based on the autotest ID
//// bFault - TBD
void RemoveFault(byte bFault, byte bInfo)
{
  stack char cFIBResponse[1000];
  stack char cExpectedFIBResponse[1000];
  stack int64 iDefaultValue;
  
  // Steering
  stack byte bDriver_Side_Diag   = 0x99;
  stack byte bDriver_Side_Signal = 0x99;
  stack char cDriver_Side_Signal[100];
  stack char cDriver_Side_Diag[100];
  const byte bVEH_RHD = 0;
  const byte bVEH_LHD = 1;
  stack int64 iSteering_RHD;
  stack int64 iSteering_LHD;
  
  switch(bFault)
  {
    case bERR_NVM_NOT_PROG:
      SendDiagnosticRequest(dWriteHBCalibrationgRequest, dWriteHBCalibrationResponse, bDefaultHBCalibration);
      if(CheckPositiveResponse(dWriteHBCalibrationgRequest, dWriteHBCalibrationResponse) == 1)
      {
        testStepPass(@sysvar::CORE::sysLevelOfDetailPass, "RemoveFault", "ERR_NVM_NOT_PROG fault was removed using HB calibration write service.");
      }
      else
      {
        testStepFail(@sysvar::CORE::sysLevelOfDetailFail, "RemoveFault", "ERR_NVM_NOT_PROG fault was not removed: Negative response received for Write HB calibration request: [0x%X].", dWriteHBCalibrationResponse.GetResponseCode());
      }
      break;
    case bERR_SPI_E_HW_ERROR:
      Remove_Fault(_iMISO, cFIBResponse);
      snprintf(cExpectedFIBResponse, elcount(cExpectedFIBResponse), "Remove fault performed OK on channel %i", _iMISO);
      EvalManStepEqual("Make FIB fault.",  cFIBResponse, cExpectedFIBResponse);
      
      testStepPass(@sysvar::CORE::sysLevelOfDetailPass, "RemoveFault", "ERR_SPI_E_HW_ERROR fault removed.");
      break;
    
    case bERR_CANSM_E_BUS_OFF:
    {
      Remove_Channel_Short(_iCAN_LOW, _iCAN_HIGH, cFIBResponse);
      snprintf(cExpectedFIBResponse, elcount(cExpectedFIBResponse), "Removing short between channels %i and %i performed OK.", _iCAN_LOW, _iCAN_HIGH);
      EvalManStepEqual("Make FIB fault.", cFIBResponse, cExpectedFIBResponse);
      testStepPass(@sysvar::CORE::sysLevelOfDetailPass, "RemoveFault", "CANSM_E_BUS_OFF fault removed.");
    }
    break;
    case FREE_MOTOR:
      Remove_Fault(_iMOTOR_FREE, cFIBResponse);
      strncpy(cExpectedFIBResponse, "", elcount(cExpectedFIBResponse));
      snprintf(cExpectedFIBResponse, elcount(cExpectedFIBResponse), "Remove fault performed OK on channel %i", _iMOTOR_FREE);
      EvalManStepEqual("Connect retractor.",  cFIBResponse, cExpectedFIBResponse);
      break;
    case bERR_MOSFET_HIGH_SC:
      Remove_Fault(_iV_MOTOR_PLUS, cFIBResponse);
      strncpy(cExpectedFIBResponse, "", elcount(cExpectedFIBResponse));
      snprintf(cExpectedFIBResponse, elcount(cExpectedFIBResponse), "Remove fault performed OK on channel %i", _iV_MOTOR_PLUS);
      EvalManStepEqual("Remove FIB fault.",  cFIBResponse, cExpectedFIBResponse);

      Remove_Fault(_iV_MOTOR_MINUS, cFIBResponse);
      strncpy(cExpectedFIBResponse, "", elcount(cExpectedFIBResponse));
      snprintf(cExpectedFIBResponse, elcount(cExpectedFIBResponse), "Remove fault performed OK on channel %i", _iV_MOTOR_MINUS);
      EvalManStepEqual("Remove FIB fault.",  cFIBResponse, cExpectedFIBResponse);
      testStepPass("", "MOSFET_HIGH_SC fault is removed");
      break;
      
    case bERR_MOSFET_LOW_SC:
      Remove_Fault(_iV_MOTOR_PLUS, cFIBResponse);
      strncpy(cExpectedFIBResponse, "", elcount(cExpectedFIBResponse));
      snprintf(cExpectedFIBResponse, elcount(cExpectedFIBResponse), "Remove fault performed OK on channel %i", _iV_MOTOR_PLUS);
      EvalManStepEqual("Remove FIB fault.",  cFIBResponse, cExpectedFIBResponse);

      Remove_Fault(_iV_MOTOR_MINUS, cFIBResponse);
      strncpy(cExpectedFIBResponse, "", elcount(cExpectedFIBResponse));
      snprintf(cExpectedFIBResponse, elcount(cExpectedFIBResponse), "Remove fault performed OK on channel %i", _iV_MOTOR_MINUS);
      EvalManStepEqual("Remove FIB fault.",  cFIBResponse, cExpectedFIBResponse);
      testStepPass("", "MOSFET_LOW_SC fault is removed");      
      break;
      
    case bERR_MOSFET_OC:
      Remove_Fault(_iV_MOTOR_PLUS, cFIBResponse);
      strncpy(cExpectedFIBResponse, "", elcount(cExpectedFIBResponse));
      snprintf(cExpectedFIBResponse, elcount(cExpectedFIBResponse), "Remove fault performed OK on channel %i", _iV_MOTOR_PLUS);
      EvalManStepEqual("Remove FIB fault.",  cFIBResponse, cExpectedFIBResponse);

      Remove_Fault(_iV_MOTOR_MINUS, cFIBResponse);
      strncpy(cExpectedFIBResponse, "", elcount(cExpectedFIBResponse));
      snprintf(cExpectedFIBResponse, elcount(cExpectedFIBResponse), "Remove fault performed OK on channel %i", _iV_MOTOR_MINUS);
      EvalManStepEqual("Remove FIB fault.",  cFIBResponse, cExpectedFIBResponse);
      testStepPass("", "MOSFET_OC fault is removed");      
      break;
      
    case bERR_HALL_SENSOR:
      Remove_Fault(_iHALL_A, cFIBResponse);
      strncpy(cExpectedFIBResponse, "", elcount(cExpectedFIBResponse));
      snprintf(cExpectedFIBResponse, elcount(cExpectedFIBResponse), "Remove fault performed OK on channel %i", _iHALL_A);
      EvalManStepEqual("Remove FIB fault.",  cFIBResponse, cExpectedFIBResponse);
      
      testStepPass("", "HALL_SENSOR fault is removed"); 
      break;
      
    case bERR_ENABLE_OUT_OF_ORDER:
      Remove_Fault(_iRD_EN_HB_P, cFIBResponse);
      strncpy(cExpectedFIBResponse, "", elcount(cExpectedFIBResponse));
      snprintf(cExpectedFIBResponse, elcount(cExpectedFIBResponse), "Remove fault performed OK on channel %i", _iRD_EN_HB_P);
      EvalManStepEqual("Remove FIB fault.",  cFIBResponse, cExpectedFIBResponse);
      
      Remove_Fault(_iRD_EN_HB_N, cFIBResponse);
      strncpy(cExpectedFIBResponse, "", elcount(cExpectedFIBResponse));
      snprintf(cExpectedFIBResponse, elcount(cExpectedFIBResponse), "Remove fault performed OK on channel %i", _iRD_EN_HB_N);
      EvalManStepEqual("Remove FIB fault.",  cFIBResponse, cExpectedFIBResponse);
      testStepPass("", "ENABLE_OUT_OF_ORDER fault is removed"); 
      break;
      
    case bERR_HW_SELF_PROTECTION:
      Remove_Fault(_iVIS_TENSION, cFIBResponse);
      strncpy(cExpectedFIBResponse, "", elcount(cExpectedFIBResponse));
      snprintf(cExpectedFIBResponse, elcount(cExpectedFIBResponse), "Remove fault performed OK on channel %i", _iVIS_TENSION);
      EvalManStepEqual("Remove FIB fault.",  cFIBResponse, cExpectedFIBResponse);
      
      Remove_Fault(_iVIS_RELEASE, cFIBResponse);
      strncpy(cExpectedFIBResponse, "", elcount(cExpectedFIBResponse));
      snprintf(cExpectedFIBResponse, elcount(cExpectedFIBResponse), "Remove fault performed OK on channel %i", _iVIS_RELEASE);
      EvalManStepEqual("Remove FIB fault.",  cFIBResponse, cExpectedFIBResponse);
      testStepPass("", "HW_SELF_PROTECTION fault is removed");
      break;
      
    case bERR_HIGH_SIDE_SWITCH:
      Remove_Fault(_iHS1_LVL, cFIBResponse);
      strncpy(cExpectedFIBResponse, "", elcount(cExpectedFIBResponse));
      snprintf(cExpectedFIBResponse, elcount(cExpectedFIBResponse), "Remove fault performed OK on channel %i", _iHS1_LVL);
      EvalManStepEqual("Remove FIB fault.",  cFIBResponse, cExpectedFIBResponse);
      testStepPass("", "HIGH_SIDE_SWITCH fault is removed");
      break;
      
    case bERR_WARM_RESET:
      Remove_Fault(_iWARM_RST, cFIBResponse);
      strncpy(cExpectedFIBResponse, "", elcount(cExpectedFIBResponse));
      snprintf(cExpectedFIBResponse, elcount(cExpectedFIBResponse), "Remove fault performed OK on channel %i", _iWARM_RST);
      EvalManStepEqual("Remove FIB fault.",  cFIBResponse, cExpectedFIBResponse);
      testStepPass("", "WARM_RESET fault is removed");      
      break;
      
    case bERR_TEMPERATURE_SENSOR_FAILURE:
      //TBD
      break;
      
    case bERR_MOTOR_BLOCKED:
      Remove_Fault(_iVIS_RELEASE, cFIBResponse);
      strncpy(cExpectedFIBResponse, "", elcount(cExpectedFIBResponse));
      snprintf(cExpectedFIBResponse, elcount(cExpectedFIBResponse), "Remove fault performed OK on channel %i", _iVIS_RELEASE);
      EvalManStepEqual("Remove FIB fault.",  cFIBResponse, cExpectedFIBResponse);
      testStepPass("", "MOTOR_BLOCKED fault is removed");   
      break;
      
    case bERR_MOTOR_IN_SC:
      Remove_Fault(_iVIS_RELEASE, cFIBResponse);
      strncpy(cExpectedFIBResponse, "", elcount(cExpectedFIBResponse));
      snprintf(cExpectedFIBResponse, elcount(cExpectedFIBResponse), "Remove fault performed OK on channel %i", _iVIS_RELEASE);
      EvalManStepEqual("Remove FIB fault.",  cFIBResponse, cExpectedFIBResponse);
      testStepPass("", "MOTOR_IN_SC fault is removed");   
      break;
      
    case bERR_MOTOR_CURRENT:
      //TBD
      break;
      
    case bERR_MOTOR_DISCONNECTED:
      Remove_Fault(_iMOTOR_DISCONNECTED, cFIBResponse);
      strncpy(cExpectedFIBResponse, "", elcount(cExpectedFIBResponse));
      snprintf(cExpectedFIBResponse, elcount(cExpectedFIBResponse), "Remove fault performed OK on channel %i", _iMOTOR_DISCONNECTED);
      EvalManStepEqual("Remove FIB fault.",  cFIBResponse, cExpectedFIBResponse);
      
      
      Remove_Fault(_iV_MOTOR_PLUS, cFIBResponse);
      strncpy(cExpectedFIBResponse, "", elcount(cExpectedFIBResponse));
      snprintf(cExpectedFIBResponse, elcount(cExpectedFIBResponse), "Remove fault performed OK on channel %i", _iV_MOTOR_PLUS);
      EvalManStepEqual("Remove FIB fault.",  cFIBResponse, cExpectedFIBResponse);
      
      Remove_Fault(_iV_MOTOR_MINUS, cFIBResponse);
      strncpy(cExpectedFIBResponse, "", elcount(cExpectedFIBResponse));
      snprintf(cExpectedFIBResponse, elcount(cExpectedFIBResponse), "Remove fault performed OK on channel %i", _iV_MOTOR_MINUS);
      EvalManStepEqual("Remove FIB fault.",  cFIBResponse, cExpectedFIBResponse);
            
      testStepPass("", "MOTOR_DISCONNECTED fault is removed");   
      break;
      
    case bERR_MOTOR_ORDER:
      break;
    case bERR_SW_SELF_PROTECTION:
      Remove_Fault(_iVIS_TENSION, cFIBResponse);
      strncpy(cExpectedFIBResponse, "", elcount(cExpectedFIBResponse));
      snprintf(cExpectedFIBResponse, elcount(cExpectedFIBResponse), "Remove fault performed OK on channel %i", _iVIS_TENSION);
      EvalManStepEqual("Remove FIB fault.",  cFIBResponse, cExpectedFIBResponse);
      testStepPass("", "SW_SELF_PROTECTION fault is removed");
      break;
      
    case bERR_BAT_PWR_OVER_VOLTAGE:
      if (bInfo == PS)
        {
          SetVoltage(_fBAT_NOMINAL_VALUE);
          testStep("RemoveFault", "BAT_PWR_OVER_VOLTAGE fault is removed");
        }
        else
        {
            Remove_Fault(_iKL30_LVL, cFIBResponse);
            snprintf(cExpectedFIBResponse, elcount(cExpectedFIBResponse), "Remove fault performed OK on channel %i", _iKL30_LVL);
            EvalManStepEqual("Remove FIB fault.",  cFIBResponse, cExpectedFIBResponse);
            testStep("RemoveFault", "BAT_PWR_OVER_VOLTAGE fault is removed");
        }
      break;
    //modified  
    case bERR_BAT_PWR_UNDER_VOLTAGE:
      if (bInfo == PS)
        {
          SetVoltage(_fBAT_NOMINAL_VALUE);
          testStep("RemoveFault", "BAT_PWR_UNDER_VOLTAGE fault is removed");
        }
      else
        {  
          Remove_Fault(_iKL30_LVL, cFIBResponse);
          snprintf(cExpectedFIBResponse, elcount(cExpectedFIBResponse), "Remove fault performed OK on channel %i", _iKL30_LVL);
          EvalManStepEqual("Remove FIB fault.",  cFIBResponse, cExpectedFIBResponse);
          testStep("RemoveFault", "BAT_PWR_UNDER_VOLTAGE fault is removed");
        }
     break;
    
    case bERR_BAT_PWR_UNDER_VOLTAGE_SYSTEM:
    {
      setSignal(PN14_Master_Stat1_ST3::PN14_SupBat_Volt_ST3, _fBAT_NOMINAL_VALUE);
      if(testWaitForMessage(PN14_Master_Stat1_ST3_ID, PN14_Master_Stat1_ST3_Peridicity * 2) == 1)
      {
        testStepPass(@sysvar::CORE::sysLevelOfDetailPass, "RemoveFault", "BAT_PWR_UNDER_VOLTAGE_SYSTEM fault removed.");
      }
      else
      {
        testStepFail(@sysvar::CORE::sysLevelOfDetailFail, "RemoveFault", "BAT_PWR_UNDER_VOLTAGE_SYSTEM fault was removed but there was an error when waiting for transmission of message: 'PN14_Master_Stat1_ST3'.");
      }
    break;
    }
    
    case bERR_BAT_PWR_OVER_VOLTAGE_SYSTEM:
    {
      setSignal(PN14_Master_Stat1_ST3::PN14_SupBat_Volt_ST3, _fBAT_NOMINAL_VALUE);
      if(testWaitForMessage(PN14_Master_Stat1_ST3_ID, PN14_Master_Stat1_ST3_Peridicity * 2) == 1)
      {
        testStepPass(@sysvar::CORE::sysLevelOfDetailPass, "RemoveFault", "BAT_PWR_OVER_VOLTAGE_SYSTEM fault removed.");
      }
      else
      {
        testStepFail(@sysvar::CORE::sysLevelOfDetailFail, "RemoveFault", "BAT_PWR_OVER_VOLTAGE_SYSTEM fault was removed but there was an error when waiting for transmission of message: 'PN14_Master_Stat1_ST3'.");
      }
    break;
    }
    
    case bERR_BAT_PWR_UNDER_VOLTAGE_DURING_TENS:
      SetVoltage(_fBAT_NOMINAL_VALUE);
      testStep("", "BAT_PWR_UNDER_VOLTAGE_TENSIONING fault is removed");
      break;
      
    case bERR_BAT_PWR_OVER_VOLTAGE_DURING_TENS:
      SetVoltage(_fBAT_NOMINAL_VALUE);
      testStep("", "BAT_PWR_OVER_VOLTAGE_TENSIONING fault is removed");
      break;
      
    case bERR_LOW_FORCE_END_OF_LIFE:
      break;
    case bERR_COMFORT_END_OF_LIFE:
      break;
      
    case bERR_IMPLAUSIBLE_DATA_PRESAFE:
    {
      switch(bInfo)
      {
        case CRC:
          if(testEnableCRCCalculation(PresfAct_Adj_ST3) == 0)
          {
            testStepPass(@sysvar::CORE::sysLevelOfDetailPass, "RemoveFault", "ERR_IMPLAUSIBLE_DATA_PRESAFE fault removed (CRC).");
          }
          break;
        case SQC:
          if(TestEnableMsgSequenceCounter(PresfAct_Adj_ST3) == 0)
          {
            testStepPass(@sysvar::CORE::sysLevelOfDetailPass, "RemoveFault", "ERR_IMPLAUSIBLE_DATA_PRESAFE fault removed (SQC).");
          }
          break;
        case SNA:
          if(getSignalValueForDescription(PresfAct_Adj_ST3::Presf_Lvl_ST3, "I_C04_PRESF_LVL_V2_NOLVL", iDefaultValue) == 0)
          {
            SetSignal(Presf_Lvl_ST3, iDefaultValue);
            testStepPass(@sysvar::CORE::sysLevelOfDetailPass, "RemoveFault", "ERR_IMPLAUSIBLE_DATA_PRESAFE fault removed (SNA).");
          }
          else
          {
            testStepFail(@sysvar::CORE::sysLevelOfDetailFail, "RemoveFault", "Error getting value for description 'Presf_Lvl_ST3'.");
          }
          break;
        default: testStepFail(@sysvar::CORE::sysLevelOfDetailFail, "RemoveFault", "Parameter value for RemoveFault function is invalid.");
          break;
      }
      break;
    }
    
    case bERR_IMPLAUSIBLE_DATA_ORC:
    {
      switch(bInfo)
      {
        case CRC:
          if(testEnableCRCCalculation(Impact3_ST3) == 0)
          {
            testStepPass(@sysvar::CORE::sysLevelOfDetailPass, "RemoveFault", "ERR_IMPLAUSIBLE_DATA_ORC fault removed (CRC).");
          }
          break;
        case SQC:
          if(TestEnableMsgSequenceCounter(Impact3_ST3) == 0)
          {
            testStepPass(@sysvar::CORE::sysLevelOfDetailPass, "RemoveFault", "ERR_IMPLAUSIBLE_DATA_ORC fault removed (SQC).");
          }
          break;
        default: testStepFail(@sysvar::CORE::sysLevelOfDetailFail, "RemoveFault", "Parameter value for RemoveFault function is invalid: SQC or CRC must be used. ");
          break;
      }
      break;
    }
    
    case bERR_IMPLAUSIBLE_DATA_BUCKLE:
    {
      switch(bInfo)
      {
        case CRC:
          if(testEnableCRCCalculation(Bckl_Sw_Fx_Stat_ST3) == 0)
          {
            testStepPass(@sysvar::CORE::sysLevelOfDetailPass, "RemoveFault", "ERR_IMPLAUSIBLE_DATA_BUCKLE fault removed (CRC).");
          }
          break;
        case SQC:
          if(TestEnableMsgSequenceCounter(Bckl_Sw_Fx_Stat_ST3) == 0)
          {
            testStepPass(@sysvar::CORE::sysLevelOfDetailPass, "RemoveFault", "ERR_IMPLAUSIBLE_DATA_BUCKLE fault removed (SQC).");
          }
          break;
        case SNA:
          if(getSignalValueForDescription(Bckl_Sw_Fx_Stat_ST3::Bckl_Sw_D_Stat_ST3, "I_C02_BCKL_SW_STAT_NOT", iDefaultValue) == 0)
          {
            SetSignal(Bckl_Sw_D_Stat_ST3, iDefaultValue);
            SetSignal(Bckl_Sw_FP_Stat_ST3, iDefaultValue);
            testStepPass(@sysvar::CORE::sysLevelOfDetailPass, "RemoveFault", "ERR_IMPLAUSIBLE_DATA_BUCKLE fault removed (SNA).");
          }
          else
          {
            testStepFail(@sysvar::CORE::sysLevelOfDetailFail, "RemoveFault", "Error getting value for description 'I_C02_BCKL_SW_STAT_NOT'.");
          }
          break;
         case FLT:
          if(getSignalValueForDescription(Bckl_Sw_Fx_Stat_ST3::Bckl_Sw_D_Stat_ST3, "I_C02_BCKL_SW_STAT_NOT", iDefaultValue) == 0)
          {
            SetSignal(Bckl_Sw_D_Stat_ST3, iDefaultValue);
            SetSignal(Bckl_Sw_FP_Stat_ST3, iDefaultValue);
            testStepPass(@sysvar::CORE::sysLevelOfDetailPass, "RemoveFault", "ERR_IMPLAUSIBLE_DATA_BUCKLE fault removed (FLT).");
          }
          else
          {
            testStepFail(@sysvar::CORE::sysLevelOfDetailFail, "RemoveFault", "Error getting value for description 'I_C02_BCKL_SW_STAT_NOT'.");
          }
          break;
        default: testStepFail(@sysvar::CORE::sysLevelOfDetailFail, "RemoveFault", "Parameter value for RemoveFault function is invalid");
          break;
      }
      break;
    }
    
    case bERR_IMPLAUSIBLE_DATA_IGNITION:
    {
      switch(bInfo)
      {
        case CRC:
          if(testEnableCRCCalculation(Ign_Stat_ST3) == 0)
          {
            testStepPass(@sysvar::CORE::sysLevelOfDetailPass, "RemoveFault", "ERR_IMPLAUSIBLE_DATA_IGNITION fault removed (CRC).");
          }
          break;
        case SQC:
          if(TestEnableMsgSequenceCounter(Ign_Stat_ST3) == 0)
          {
            testStepPass(@sysvar::CORE::sysLevelOfDetailPass, "RemoveFault", "ERR_IMPLAUSIBLE_DATA_IGNITION fault removed (SQC).");
          }
          break;
        case SNA:
          if(getSignalValueForDescription(Ign_Stat_ST3::ISw_Stat_ST3, "I_C03_ISW_STAT_IGN_ON", iDefaultValue) == 0)
          {
            setSignal(Ign_Stat_ST3::ISw_Stat_ST3, iDefaultValue);
            testStepPass(@sysvar::CORE::sysLevelOfDetailPass, "RemoveFault", "ERR_IMPLAUSIBLE_DATA_IGNTION fault removed (SNA).");
          }
          else
          {
            testStepFail(@sysvar::CORE::sysLevelOfDetailFail, "RemoveFault", "Error getting value for description 'I_C03_ISW_STAT_IGN_ON'.");
          }
          break;
        default: testStepFail(@sysvar::CORE::sysLevelOfDetailFail, "RemoveFault", "Parameter value for RemoveFault function is invalid");
          break;
      }
      break;
    }
    
    case bERR_IMPLAUSIBLE_DATA_POWERTRAIN_RDY:
    {
      if(getSignalValueForDescription(PT4_PTCoor4_ST3::PT4_PTCoor_PT_Rdy_ST3, "I_C02_PT_RDY_V2_PT_NOT_RDY", iDefaultValue) == 0)
      {
        setSignal(PT4_PTCoor_PT_Rdy_ST3, iDefaultValue);
        testStepPass(@sysvar::CORE::sysLevelOfDetailPass, "RemoveFault", "ERR_IMPLAUSIBLE_DATA_POWERTRAIN_RDY fault removed for frame 0x35F: PT4_PTCoor_PT_Rdy_ST3 = I_C02_PT_RDY_V2_PT_NOT_RDY.");
      }
      else
      {
        testStepFail(@sysvar::CORE::sysLevelOfDetailFail, "RemoveFault", "Error getting value for description for 'I_C02_PT_RDY_V2_PT_NOT_RDY'.");
      }
      break;
    }
    
    case bERR_IMPLAUSIBLE_DATA_POWERTRAIN_DRV:
    {
      if(getSignalValueForDescription(PT4_PTCoor_DrvPosn_Gear_ST3::PT4_PTCoor_DrvPosn_Stat_ST3, "I_C04_DRVPOSN_ST3_N", iDefaultValue) == 0)
      {
        setSignal(PT4_PTCoor_DrvPosn_Stat_ST3, iDefaultValue);
        testStepPass(@sysvar::CORE::sysLevelOfDetailPass, "RemoveFault", "ERR_IMPLAUSIBLE_DATA_POWERTRAIN_DRV fault removed for frame 0x582: PT4_PTCoor_DrvPosn_Stat_ST3 = I_C04_DRVPOSN_ST3_N.");
      }
      else
      {
        testStepFail(@sysvar::CORE::sysLevelOfDetailFail, "RemoveFault", "Error getting value for description for 'I_C04_DRVPOSN_ST3_N'.");
      }
      break;
    }
    
    case bERR_TIMEOUT_BUCKLE:
    {
      if(testEnableMsg(Bckl_Sw_Fx_Stat_ST3) == 0)
      {
        testStepPass(@sysvar::CORE::sysLevelOfDetailPass, "RemoveFault", "ERR_TIMEOUT_BUCKLE fault removed.");
      }
      else
      {
        testStepFail(@sysvar::CORE::sysLevelOfDetailFail, "RemoveFault", "'testEnableMsg' general error for message: 'Bckl_Sw_Fx_Stat_ST3'.");
      }
      break;
    }
    case bERR_TIMEOUT_PRESAFE:
    {
      if(testEnableMsg(PresfAct_Adj_ST3) == 0)
      {
        testStepPass(@sysvar::CORE::sysLevelOfDetailPass, "RemoveFault", "ERR_TIMEOUT_PRESAFE fault removed.");
      }
      else
      {
        testStepFail(@sysvar::CORE::sysLevelOfDetailFail, "RemoveFault", "'testEnableMsg' general error for message: 'PresfAct_Adj_ST3'.");
      }
      break;
    }
    
    case bERR_TIMEOUT_IGNITION:
    {
      if(testEnableMsg(Ign_Stat_ST3) == 0)
      {
        testStepPass(@sysvar::CORE::sysLevelOfDetailPass, "RemoveFault", "ERR_TIMEOUT_IGNITION fault removed.");
      }
      else
      {
        testStepFail(@sysvar::CORE::sysLevelOfDetailFail, "RemoveFault", "'testEnableMsg' general error for message: 'Ign_Stat_ST3'.");
      }
      break;
    }
    
    case bERR_TIMEOUT_POWERTRAIN:
    {
      if(testEnableMsg(PT4_PTCoor4_ST3) == 0)
      {
        testStepPass(@sysvar::CORE::sysLevelOfDetailPass, "RemoveFault", "ERR_TIMEOUT_POWERTRAIN fault removed.");
      }
      else
      {
        testStepFail(@sysvar::CORE::sysLevelOfDetailFail, "RemoveFault", "'testEnableMsg' general error for message: 'PT4_PTCoor4_ST3'.");
      }
      break;
    }
    
    case bERR_TIMEOUT_BELT_HANDOVER_LEFT:
    {
      if(testEnableMsg(BeltHdOvr_FL_State_ST3) == 0)
      {
        testStepPass(@sysvar::CORE::sysLevelOfDetailPass, "RemoveFault", "ERR_TIMEOUT_BELT_HANDOVER_LEFT fault removed.");
      }
      else
      {
        testStepFail(@sysvar::CORE::sysLevelOfDetailFail, "RemoveFault", "'testEnableMsg' general error for message: 'BeltHdOvr_FL_State_ST3'.");
      }
      break;
    }
    
    case bERR_TIMEOUT_BELT_HANDOVER_RIGHT:
    {
      if(testEnableMsg(BeltHdOvr_FR_State_ST3) == 0)
      {
        testStepPass(@sysvar::CORE::sysLevelOfDetailPass, "RemoveFault", "ERR_TIMEOUT_BELT_HANDOVER_RIGHT fault removed.");
      }
      else
      {
        testStepFail(@sysvar::CORE::sysLevelOfDetailFail, "RemoveFault", "'testEnableMsg' general error for message: 'BeltHdOvr_FR_State_ST3'.");
      }
      break;
    }
    
    case bERR_TIMEOUT_API_INTERFACE:
    {
      if(testEnableMsg(SBeltTens_SP_Lvl_ST3) == 0)
      {
        testStepPass(@sysvar::CORE::sysLevelOfDetailPass, "RemoveFault", "ERR_TIMEOUT_API_INTERFACE fault removed.");
      }
      else
      {
        testStepFail(@sysvar::CORE::sysLevelOfDetailFail, "RemoveFault", "'testEnableMsg' general error for message: 'SBeltTens_SP_Lvl_ST3'.");
      }
      break;
    }
    
    case bERR_TIMEOUT_BELT_ADJ:
    {
      if(testEnableMsg(BeltAdj_UI_Set_Rq_ST3) == 0)
      {
        testStepPass(@sysvar::CORE::sysLevelOfDetailPass, "RemoveFault", "ERR_TIMEOUT_BELT_ADJ fault removed.");
      }
      else
      {
        testStepFail(@sysvar::CORE::sysLevelOfDetailFail, "RemoveFault", "'testEnableMsg' general error for message: 'BeltAdj_UI_Set_Rq_ST3'.");
      }
      break;
    }
    
    case bERR_STEERING_CONFIGURATION:
    {
      if(SendDiagnosticRequest(dReadVehicleEquipmentConfigurationDataRequest, dReadVehicleEquipmentConfigurationDataResponse) == DIAG_SEND_OR_RECEIVE_ERROR)
      {
        testStepFail(@sysvar::CORE::sysLevelOfDetailFail, "RemoveFault" , "Diagnostic request send or receive error for 'ReadVehicleEquipmentConfigurationDataRequest'.");
        break;
      }
      else
      {
        bDriver_Side_Diag = diagGetParameter(dReadVehicleEquipmentConfigurationDataResponse, "Equipment_1.Links_Rechtslenker");
        diagGetParameter(dReadVehicleEquipmentConfigurationDataResponse, "Equipment_1.Links_Rechtslenker", cDriver_Side_Diag, elcount(cDriver_Side_Diag));
        testStep(@sysvar::CORE::sysLevelOfDetailStep, "", "ECU Driver side according to 'Vehicle_Equipment_Read' is: 0x%02X  (%s).", bDriver_Side_Diag, cDriver_Side_Diag);
        
        bDriver_Side_Signal = getSignal(EVC_List03_StStyle_ST3);
        getSignalDescriptionForValue(EVC_List03_StStyle_ST3, bDriver_Side_Signal, cDriver_Side_Signal, elcount(cDriver_Side_Signal));
        
        getSignalValueForDescription(EVC_CfgList_01_08_Pr5_ST3::EVC_List03_StStyle_ST3, "I_C02_STSTYLE_LHD", iSteering_LHD);
        getSignalValueForDescription(EVC_CfgList_01_08_Pr5_ST3::EVC_List03_StStyle_ST3, "I_C02_STSTYLE_RHD", iSteering_RHD);
        
        switch(bDriver_Side_Diag)
        {
          case bVEH_LHD:
              getSignalDescriptionForValue(EVC_List03_StStyle_ST3, iSteering_LHD, cDriver_Side_Signal, elcount(cDriver_Side_Signal));
              setSignal(EVC_List03_StStyle_ST3, iSteering_LHD);
              testWaitForMessage(0x6E0, 1200);
              testStepPass(@sysvar::CORE::sysLevelOfDetailPass, "RemoveFault" ,"ERR_STEERING_CONFIGURATION fault removed; EVC_List03_StStyle_ST3 was set to: 0x%02X (%s)", iSteering_LHD, cDriver_Side_Signal);
            break;
          case bVEH_RHD:
              getSignalDescriptionForValue(EVC_List03_StStyle_ST3, iSteering_RHD, cDriver_Side_Signal, elcount(cDriver_Side_Signal));
              setSignal(EVC_List03_StStyle_ST3, iSteering_RHD);
              testWaitForMessage(0x6E0, 1200);
              testStepPass(@sysvar::CORE::sysLevelOfDetailPass, "RemoveFault", "ERR_STEERING_CONFIGURATION fault removed; EVC_List03_StStyle_ST3 was set to: 0x%02X (%s)", iSteering_RHD, cDriver_Side_Signal);
            break;
        }
      }
    break;
    }
    
    case bERR_TIMEOUT_ODOSPEEDOMETER:
    {
      if(testEnableMsg(DI_OdoSpeedometer_ST3) == 0)
      {
        testStepPass(@sysvar::CORE::sysLevelOfDetailPass, "RemoveFault", "ERR_TIMEOUT_ODOSPEEDOMETER fault removed.");
      }
      else
      {
        testStepFail(@sysvar::CORE::sysLevelOfDetailFail, "RemoveFault", "'testEnableMsg' general error for message: 'DI_OdoSpeedometer_ST3'.");
      }
      break;
    }
    
    case bERR_TIMEOUT_VSS_SECTICKCOUNT:
    {
      @sysvar::RBTM_Simulation::Secured_Tickcount_Timeout = 0;
      break;
    }
    
    case bERR_INCOMPATIBLE_CONFIGURATION_VIN:
    {
      @ProjectConfiguration::EnableVINBroadcast = 1;
      break;
    }
    
    case bERR_IMPLAUSIBLE_DATA_API:
    {
      switch(bInfo)
      {
        case CRC:
          if(testEnableCRCCalculation(SBeltTens_SP_Lvl_ST3) == 0)
          {
            testStepPass(@sysvar::CORE::sysLevelOfDetailPass, "RemoveFault", "ERR_IMPLAUSIBLE_DATA_API fault removed (CRC).");
          }
          break;
        case SQC:
          if(TestEnableMsgSequenceCounter(SBeltTens_SP_Lvl_ST3) == 0)
          {
            testStepPass(@sysvar::CORE::sysLevelOfDetailPass, "RemoveFault", "ERR_IMPLAUSIBLE_DATA_API fault removed (SQC).");
          }
          break;
        case SNA:
          if(getSignalValueForDescription(SBeltTens_SP_Lvl_ST3::RBTMFL_SP_Lvl_Rq_ST35, "I_C06_RBTM_LVL_RQ_NONE", iDefaultValue) == 0)
          {
            SetSignal(RBTMFL_SP_Lvl_Rq_ST35, iDefaultValue);
            SetSignal(RBTMFR_SP_Lvl_Rq_ST35, iDefaultValue);
            testStepPass(@sysvar::CORE::sysLevelOfDetailPass, "RemoveFault", "ERR_IMPLAUSIBLE_DATA_API fault removed (SNA).");
          }
          else
          {
            testStepFail(@sysvar::CORE::sysLevelOfDetailFail, "RemoveFault", "Error getting value for description 'I_C06_RBTM_LVL_RQ_NONE'.");
          }
          break;
        default: testStepFail(@sysvar::CORE::sysLevelOfDetailFail, "RemoveFault", "Parameter value for RemoveFault function is invalid");
          break;
      }
      break;
    }
    
    default:
      testStepFail(@sysvar::CORE::sysLevelOfDetailFail, "RemoveFault" , "Incorrect input.");
      break;
  }
}

/// <DTC_management>
//Configure block 12 to return the status of the input AEC (on the first byte).
void ConfigureBlock12ForAECReading(byte bAutotest)
{
  int iIndex;
  stack long lBuffer;
  stack byte bAEC_RAM_Address[4];
  
  // Enter development session.
  EnterDiagnosticSession("development");
  
  ActivateMeasurementFrame(12);
  
 // Set RAM address.
  memcpy(bAEC_RAM_Address, _erh_au8AecStatus, elcount(_erh_au8AecStatus));
  lBuffer = bAutotest - 1 + _erh_au8AecStatus[3] + (_erh_au8AecStatus[2] << 8);
  bAEC_RAM_Address[2] = ((lBuffer & 0xFF00) >> 8);
  bAEC_RAM_Address[3] = lBuffer & 0xFF;
  
  ConfigureMeasurement_Block12(bAEC_RAM_Address, 7);
}


/// <Helpers>
void ByteToBitArray(byte bInput, byte bOutput[])
{
  byte bBuffer;
  bBuffer = bInput;
  
  if(elcount(bOutput) == 8)
  {
    bOutput[0] = bBuffer & 0x01;
    bBuffer = bBuffer >> 1;
    
    bOutput[1] = bBuffer & 0x01;
    bBuffer = bBuffer >> 1;
    
    bOutput[2] = bBuffer & 0x01;
    bBuffer = bBuffer >> 1;
    
    bOutput[3] = bBuffer & 0x01;
    bBuffer = bBuffer >> 1;
   
    bOutput[4] = bBuffer & 0x01;
    bBuffer = bBuffer >> 1;
    
    bOutput[5] = bBuffer & 0x01;
    bBuffer = bBuffer >> 1;
    
    bOutput[6] = bBuffer & 0x01;
    bBuffer = bBuffer >> 1;
    
    bOutput[7] = bBuffer & 0x01;
  }
  else
  {
    testStepFail(@sysvar::CORE::sysLevelOfDetailFail, "", "Output array is too small/large ( != 8 bits) for ByteToBitArray function.");
  }
}


/// <Profile_management>
int DetectCycleStep(byte bCycle, float fMaxTime, byte bIgnoredCycles)
{
  return DetectCycleStep(bCycle, 0xFF, fMaxTime, bIgnoredCycles);
}

/// <Profile_management>
int DetectCycleStep(byte bCycle, float fMaxTime)
{
  return DetectCycleStep(bCycle, 0xFF, fMaxTime, 0xFF);
}

/// <Profile_management>
int DetectCycleStep(byte bCycle, byte bStep, float fMaxTime, byte bIgnoredCycle)
{
  stack int index;
  stack int iIgnoredCycleIndex;
  stack int iCount = 0;
  stack int iUnexpectedCycleIndex;
  stack char cInputCycle_UpperCase[20];
  stack char cIgnoredCyclesArray[3][20]; 
  stack byte bCurrentCycle;
  stack byte bUnexpectedCycles[3];
  stack float fIgnoredCycleTime[3] = {0x00, 0x00, 0x00};
  stack float fStartTime = timeNow() / 100; // simulation time in ms.
  stack float fCycleDetectionTime;
  stack float fCurrentTime = 0; 
  message * MeasurementFrame;
  
  stack int iActiveProfile = 1;

  // Process input variables >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
  
  if (TestWaitForMessage(@sysvar::ProjectConfiguration::sysMeasurementFrameID, 30) == 1) // Check if MF is active.
  {
    if(TestGetWaitEventMsgData(MeasurementFrame) == 0)
    {   
      iCount = 0;
      while((MeasurementFrame.byte(0) != 0x01) && (MeasurementFrame.byte(0) != 0x0F) && (MeasurementFrame.byte(0) != 0x18) && (iCount < 20)) // Check if proper MF blocks are active.
      {
        TestWaitForMessage(MeasurementFrame.id, 5);
        TestGetWaitEventMsgData(MeasurementFrame);
        iCount++;
      }
    }
    else
    {
      testStepFail(@sysvar::CORE::sysLevelOfDetailFail, "-", "Measurement Frame: Data access could not be executed, the last event was not a message event.");
      return CYCLE_DETECT_ERROR;
    }
  }
  else 
  {
    testStepFail(@sysvar::CORE::sysLevelOfDetailFail, "-", "Measurement Frame not detected in 30 ms.");
    return CYCLE_DETECT_ERROR;
  }

  if(iCount >= 20)
  {
    testStepFail(@sysvar::CORE::sysLevelOfDetailFail, "-", "Incorrect MF active block(s); Measurement Frame block (1 or 15 or 24) not detected in %f ms", (timeNow() / 100) - fStartTime);
    return CYCLE_DETECT_ERROR;
  }
  else
  {
  // Check for "cInputCycle" <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
    
    if (iActiveProfile == 0)
    {
      bCurrentCycle = MeasurementFrame.byte(1);
    }
    else
    {
      bCurrentCycle = bCycle;
    }
 
    iUnexpectedCycleIndex = 0;
    while((MeasurementFrame.byte(1) != CYCLE[bCycle].MF_ID) && (fCurrentTime < fMaxTime)) // Search for "cInputCycle" for "fMaxTime" or until found.
    {
      if((MeasurementFrame.byte(1) != bCurrentCycle) && (MeasurementFrame.byte(1) != 0xFF)) // Unexpected cycle case.
      {         
        if(iUnexpectedCycleIndex == 0)
        {
          bUnexpectedCycles[0] = (MeasurementFrame.byte(1));
          fIgnoredCycleTime[0] = (timeNow() / 100) - fStartTime;
          iUnexpectedCycleIndex++;
        }
        else if (MeasurementFrame.byte(1) != bUnexpectedCycles[iUnexpectedCycleIndex - 1])
              {
                bUnexpectedCycles[iUnexpectedCycleIndex] = MeasurementFrame.byte(1);
                fIgnoredCycleTime[iUnexpectedCycleIndex] = (timeNow() / 100) - fStartTime;
                iUnexpectedCycleIndex++;
              }
      }
      
      testWaitForTimeout(5);
      if (TestWaitForMessage(MeasurementFrame.id, 30) != 1)
      {
        testStepFail(@sysvar::CORE::sysLevelOfDetailFail, "-", "Measurement Frame not detected in 30 ms.");
        return CYCLE_DETECT_ERROR;
      }
      TestGetWaitEventMsgData(MeasurementFrame);
      
      iCount = 0;
      while((MeasurementFrame.byte(0) != 0x01) && (MeasurementFrame.byte(0) != 0x0F) && (MeasurementFrame.byte(0) != 0x18) && (iCount < 20))
      {
        TestWaitForMessage(MeasurementFrame.id, 5);
        TestGetWaitEventMsgData(MeasurementFrame);
        iCount++;
      }
      
      if(iCount >= 20)
      {
        testStepFail(@sysvar::CORE::sysLevelOfDetailFail, "-", "Incorrect MF active block(s); Measurement Frame block (1 or 15 or 24) no longer detected.");
        return CYCLE_DETECT_ERROR;
      }
      
      fCurrentTime = (timeNow() / 100) - fStartTime;
    }
  // Check for "cInputCycle" >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
   
  // Check for unexpected cycles <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
   
    if(iUnexpectedCycleIndex > 0)
    {
      for(index = 0; index < iUnexpectedCycleIndex; index++)
      {
        if (bIgnoredCycle != 0xFF )
        {
          if(bUnexpectedCycles[index] == CYCLE[bIgnoredCycle].MF_ID)
          {                     

             testStep(@sysvar::CORE::sysLevelOfDetailStep, "", "Unexpected cycle %x was detected in %.f ms, but you chose to ignore it.", bUnexpectedCycles[index], fIgnoredCycleTime[index]);
          }
          else
          {             
             testStepFail(@sysvar::CORE::sysLevelOfDetailFail, "-", "Unexpected cycle %x was detected in %.f ms.", bUnexpectedCycles[index], fIgnoredCycleTime[index]);
          }
        }
        else
        {
          testStepFail(@sysvar::CORE::sysLevelOfDetailFail, "-", "Unexpected cycle %x was detected in %.f ms.", bUnexpectedCycles[index], fIgnoredCycleTime[index]);
        }
      }
    }
  // Check for unexpected cycles >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
    
  // Check for "cInputStep" <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
    if(fCurrentTime >= fMaxTime) // Only check for "cInputStep" if "cInputCycle" was detected in "fMaxTime".
    {
     testStep(@sysvar::CORE::sysLevelOfDetailStep, "", "0x%02X - %s cycle was not detected in %.f ms (simulation time).", CYCLE[bCycle].MF_ID, CYCLE[bCycle].MF_Name, fCurrentTime);
     return CYCLE_NOT_DETECTED;
    }
    else
    {
      testStep(@sysvar::CORE::sysLevelOfDetailStep, "", "0x%02X - %s  cycle detected in %.f ms (simulation time).", CYCLE[bCycle].MF_ID, CYCLE[bCycle].MF_Name, fCurrentTime);
      fCycleDetectionTime = fCurrentTime;
      
      if(bStep != 0xFF)
      {
        while(bStep != MeasurementFrame.byte(2) && (fCurrentTime < fMaxTime))
        {
          if (CYCLE[bCycle].MF_ID != MeasurementFrame.byte(1)) // Stop waiting for "cInputStep" if cycle ends before "fMaxTime".
          {
            testStep(@sysvar::CORE::sysLevelOfDetailStep, "", "Step 0x%02X was not detected. %s cycle ended in %.f ms (simulation time). ", bStep, CYCLE[bCycle].MF_Name, fCurrentTime);
            return CYCLE_DETECTED_STEP_NOT_DETECTED;
          }
          else
          {
            testWaitForTimeout(5);
            if (TestWaitForMessage(MeasurementFrame.id, 30) != 1)
            {
              testStepFail(@sysvar::CORE::sysLevelOfDetailFail, "-", "Measurement Frame not detected in 30 ms.");
              return CYCLE_DETECT_ERROR;
            }
            TestGetWaitEventMsgData(MeasurementFrame);
            
            iCount = 0;
            while((MeasurementFrame.byte(0) != 0x01) && (MeasurementFrame.byte(0) != 0x0F) && (MeasurementFrame.byte(0) != 0x18) && (iCount < 20))
            {
              TestWaitForMessage(MeasurementFrame.id, 5);
              TestGetWaitEventMsgData(MeasurementFrame);
              iCount++;
            }
            
            if(iCount >= 20)
            {
              testStepFail(@sysvar::CORE::sysLevelOfDetailFail, "-", "Incorrect MF active block(s); Measurement Frame block (1 or 15 or 24) no longer detected.");
              return CYCLE_DETECT_ERROR;
            }

            fCurrentTime = (timeNow() / 100) - fStartTime;
            } 
        }
        
        if (fCurrentTime < fMaxTime)
        {
          testStep(@sysvar::CORE::sysLevelOfDetailStep, "", "Step 0x%02X was detected in %.f ms (simulation time) and %.f ms since %s cycle was detected.", bStep, fCurrentTime, (fCurrentTime - fCycleDetectionTime), CYCLE[bCycle].MF_Name);
          return CYCLE_AND_STEP_DETECTED;
        }
        else
        {
          testStep(@sysvar::CORE::sysLevelOfDetailStep, "", "Step 0x%02X  was not detected in %.f ms (simulation time).", bStep, fCurrentTime);
          return CYCLE_DETECTED_STEP_NOT_DETECTED;
        }
      }
      else return CYCLE_DETECTED;
    }
  }
  // Check for "cInputStep" >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
}

/// <Profile_management>
int DetectCycleStep(byte bCycle, byte bStep, float fMaxTime, byte bIgnoredCycle, byte bIgnoredCycle2)
{
  stack int index;
  stack int iIgnoredCycleIndex;
  stack int iCount = 0;
  stack int iUnexpectedCycleIndex;
  stack char cInputCycle_UpperCase[20];
  stack char cIgnoredCyclesArray[3][20];
  stack byte bCurrentCycle;
  stack byte bUnexpectedCycles[3];
  stack float fIgnoredCycleTime[3] = {0x00, 0x00, 0x00};
  stack float fStartTime = timeNow() / 100; // simulation time in ms.
  stack float fCycleDetectionTime;
  stack float fCurrentTime = 0; 
  message * MeasurementFrame;
  
  stack int iActiveProfile = 1;

  // Process input variables >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
  
  if (TestWaitForMessage(@sysvar::ProjectConfiguration::sysMeasurementFrameID, 30) == 1) // Check if MF is active.
  {
    if(TestGetWaitEventMsgData(MeasurementFrame) == 0)
    {   
      iCount = 0;
      while((MeasurementFrame.byte(0) != 0x01) && (MeasurementFrame.byte(0) != 0x0F) && (MeasurementFrame.byte(0) != 0x18) && (iCount < 20)) // Check if proper MF blocks are active.
      {
        TestWaitForMessage(MeasurementFrame.id, 5);
        TestGetWaitEventMsgData(MeasurementFrame);
        iCount++;
      }
    }
    else
    {
      testStepFail(@sysvar::CORE::sysLevelOfDetailFail, "-", "Measurement Frame: Data access could not be executed, the last event was not a message event.");
      return CYCLE_DETECT_ERROR;
    }
  }
  else 
  {
    testStepFail(@sysvar::CORE::sysLevelOfDetailFail, "-", "Measurement Frame not detected in 30 ms.");
    return CYCLE_DETECT_ERROR;
  }

  if(iCount >= 20)
  {
    testStepFail(@sysvar::CORE::sysLevelOfDetailFail, "-", "Incorrect MF active block(s); Measurement Frame block (1 or 15 or 24) not detected in %f ms", (timeNow() / 100) - fStartTime);
    return CYCLE_DETECT_ERROR;
  }
  else
  {
  // Check for "cInputCycle" <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
    
    if (iActiveProfile == 0)
    {
      bCurrentCycle = MeasurementFrame.byte(1);
    }
    else
    {
      bCurrentCycle = bCycle;
    }
 
    iUnexpectedCycleIndex = 0;
    while((MeasurementFrame.byte(1) != CYCLE[bCycle].MF_ID) && (fCurrentTime < fMaxTime)) // Search for "cInputCycle" for "fMaxTime" or until found.
    {
      if((MeasurementFrame.byte(1) != bCurrentCycle) && (MeasurementFrame.byte(1) != 0xFF)) // Unexpected cycle case.
      {         
        if(iUnexpectedCycleIndex == 0)
        {
          bUnexpectedCycles[0] = (MeasurementFrame.byte(1));
          fIgnoredCycleTime[0] = (timeNow() / 100) - fStartTime;
          iUnexpectedCycleIndex++;
        }
        else if (MeasurementFrame.byte(1) != bUnexpectedCycles[iUnexpectedCycleIndex - 1])
              {
                bUnexpectedCycles[iUnexpectedCycleIndex] = MeasurementFrame.byte(1);
                fIgnoredCycleTime[iUnexpectedCycleIndex] = (timeNow() / 100) - fStartTime;
                iUnexpectedCycleIndex++;
              }
      }
      
      testWaitForTimeout(5);
      if (TestWaitForMessage(MeasurementFrame.id, 30) != 1)
      {
        testStepFail(@sysvar::CORE::sysLevelOfDetailFail, "-", "Measurement Frame not detected in 30 ms.");
        return CYCLE_DETECT_ERROR;
      }
      TestGetWaitEventMsgData(MeasurementFrame);
      
      iCount = 0;
      while((MeasurementFrame.byte(0) != 0x01) && (MeasurementFrame.byte(0) != 0x0F) && (MeasurementFrame.byte(0) != 0x18) && (iCount < 20))
      {
        TestWaitForMessage(MeasurementFrame.id, 5);
        TestGetWaitEventMsgData(MeasurementFrame);
        iCount++;
      }
      
      if(iCount >= 20)
      {
        testStepFail(@sysvar::CORE::sysLevelOfDetailFail, "-", "Incorrect MF active block(s); Measurement Frame block (1 or 15 or 24) no longer detected.");
        return CYCLE_DETECT_ERROR;
      }
      
      fCurrentTime = (timeNow() / 100) - fStartTime;
    }
  // Check for "cInputCycle" >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
   
  // Check for unexpected cycles <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
   
    if(iUnexpectedCycleIndex > 0)
    {
      for(index = 0; index < iUnexpectedCycleIndex; index++)
      {
        if (bIgnoredCycle != 0xFF )
        {
          if(bUnexpectedCycles[index] == CYCLE[bIgnoredCycle].MF_ID)
          {                     

             testStep(@sysvar::CORE::sysLevelOfDetailStep, "", "Unexpected cycle %x was detected in %.f ms, but you chose to ignore it.", bUnexpectedCycles[index], fIgnoredCycleTime[index]);
          }
          else
          {             
             testStepFail(@sysvar::CORE::sysLevelOfDetailFail, "-", "Unexpected cycle %x was detected in %.f ms.", bUnexpectedCycles[index], fIgnoredCycleTime[index]);
          }   
          
          if(bUnexpectedCycles[index] == CYCLE[bIgnoredCycle2].MF_ID)
          {                     

             testStep(@sysvar::CORE::sysLevelOfDetailStep, "", "Unexpected cycle %x was detected in %.f ms, but you chose to ignore it.", bUnexpectedCycles[index], fIgnoredCycleTime[index]);
          }
          else
          {             
             testStepFail(@sysvar::CORE::sysLevelOfDetailFail, "-", "Unexpected cycle %x was detected in %.f ms.", bUnexpectedCycles[index], fIgnoredCycleTime[index]);
          }   
        }
        else
        {
          testStepFail(@sysvar::CORE::sysLevelOfDetailFail, "-", "Unexpected cycle %x was detected in %.f ms.", bUnexpectedCycles[index], fIgnoredCycleTime[index]);
        }
      }
    }
  // Check for unexpected cycles >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
    
  // Check for "cInputStep" <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
    if(fCurrentTime >= fMaxTime) // Only check for "cInputStep" if "cInputCycle" was detected in "fMaxTime".
    {
     testStep(@sysvar::CORE::sysLevelOfDetailStep, "", "0x%02X - %s cycle was not detected in %.f ms (simulation time).", CYCLE[bCycle].MF_ID, CYCLE[bCycle].MF_Name, fCurrentTime);
     return CYCLE_NOT_DETECTED;
    }
    else
    {
      testStep(@sysvar::CORE::sysLevelOfDetailStep, "", "0x%02X - %s  cycle detected in %.f ms (simulation time).", CYCLE[bCycle].MF_ID, CYCLE[bCycle].MF_Name, fCurrentTime);
      fCycleDetectionTime = fCurrentTime;
      
      if(bStep != 0xFF)
      {
        while(bStep != MeasurementFrame.byte(2) && (fCurrentTime < fMaxTime))
        {
          if (CYCLE[bCycle].MF_ID != MeasurementFrame.byte(1)) // Stop waiting for "cInputStep" if cycle ends before "fMaxTime".
          {
            testStep(@sysvar::CORE::sysLevelOfDetailStep, "", "Step 0x%02X was not detected. %s cycle ended in %.f ms (simulation time). ", bStep, CYCLE[bCycle].MF_Name, fCurrentTime);
            return CYCLE_DETECTED_STEP_NOT_DETECTED;
          }
          else
          {
            testWaitForTimeout(5);
            if (TestWaitForMessage(MeasurementFrame.id, 30) != 1)
            {
              testStepFail(@sysvar::CORE::sysLevelOfDetailFail, "-", "Measurement Frame not detected in 30 ms.");
              return CYCLE_DETECT_ERROR;
            }
            TestGetWaitEventMsgData(MeasurementFrame);
            
            iCount = 0;
            while((MeasurementFrame.byte(0) != 0x01) && (MeasurementFrame.byte(0) != 0x0F) && (MeasurementFrame.byte(0) != 0x18) && (iCount < 20))
            {
              TestWaitForMessage(MeasurementFrame.id, 5);
              TestGetWaitEventMsgData(MeasurementFrame);
              iCount++;
            }
            
            if(iCount >= 20)
            {
              testStepFail(@sysvar::CORE::sysLevelOfDetailFail, "-", "Incorrect MF active block(s); Measurement Frame block (1 or 15 or 24) no longer detected.");
              return CYCLE_DETECT_ERROR;
            }

            fCurrentTime = (timeNow() / 100) - fStartTime;
            } 
        }
        
        if (fCurrentTime < fMaxTime)
        {
          testStep(@sysvar::CORE::sysLevelOfDetailStep, "", "Step 0x%02X was detected in %.f ms (simulation time) and %.f ms since %s cycle was detected.", bStep, fCurrentTime, (fCurrentTime - fCycleDetectionTime), CYCLE[bCycle].MF_Name);
          return CYCLE_AND_STEP_DETECTED;
        }
        else
        {
          testStep(@sysvar::CORE::sysLevelOfDetailStep, "", "Step 0x%02X  was not detected in %.f ms (simulation time).", bStep, fCurrentTime);
          return CYCLE_DETECTED_STEP_NOT_DETECTED;
        }
      }
      else return CYCLE_DETECTED;
    }
  }
  // Check for "cInputStep" >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
}

/// <Profile_management>
// Sets the signals values needed in order to have the tensioning functions operational.
void EnableTriggeringPreconditions()
{ 
  stack char cECU[100];

  // Frame: Ign_Stat_ST3
  testStep("", "ISw_Stat_ST3 is set to 0x04 ( IGN_ON )");
  $ISw_Stat_ST3 = 4; // Ignition switch state: 4 = "IGN_ON".
  testWaitForSignalUpdate(ISw_Stat_ST3, 100);
  
  diagGetCurrentEcu(cECU, elcount(cECU));
  if (strncmp(cECU, sTargetECUFrontLeftName, elcount(cECU)) == 0)
  {
    // Frame: Bckl_Sw_Fx_Stat_ST3
    testStep("", "Bckl_Sw_D_Stat_ST3 is set to 0x00 ( STAT_OK )");
    $Bckl_Sw_D_Stat_ST3  = 0; // Buckle switch driver state: 0     = "STAT_OK".
    testWaitForSignalUpdate(Bckl_Sw_D_Stat_ST3, 100);
  }
  else if(strncmp(cECU, sTargetECUFrontRightName, elcount(cECU)) == 0)
  {
    testStep("", "Bckl_Sw_FP_Stat_ST3 is set to 0x00 ( STAT_OK )");
    $Bckl_Sw_FP_Stat_ST3 = 0; // Buckle switch passenger state: 0 = "STAT_OK".
    testWaitForSignalUpdate(Bckl_Sw_FP_Stat_ST3, 100);
  }

  //Frame: PresfAct_Adj_ST3
  testStep("", "PresfAct_TensSupp_Rq_ST3 is set to 0x00 ( NO )");
  $PresfAct_TensSupp_Rq_ST3 = 0; // Presafe actuator tensioning suppress request: 0 = "NO".
  testWaitForSignalUpdate(PresfAct_TensSupp_Rq_ST3, 100);
  testStep("", "Presf_Enbl_ST3 is set to 0x01 ( TRUE )");
  $Presf_Enbl_ST3 = 1;           // Presafe enabled: 1 = "TRUE".
  testWaitForSignalUpdate(Presf_Enbl_ST3, 100);
  
  // Frame: Impact3_ST3
  testStep("", "Impact_RO_type1_ST3 is set to 0x00");
  $Impact_RO_type1_ST3 = 0; // Rollover mittels Drehratensensorik (Rollover by means of rotation rate sensor technology).
  testWaitForSignalUpdate(Impact_RO_type1_ST3, 100);
  
  testStep("", "Impact_RO_type2_ST3 is set to 0x00");
  $Impact_RO_type2_ST3 = 0; // Rollover mittels Beschleunigungssensorik (Rollover by means of acceleration sensor technology).
  testWaitForSignalUpdate(Impact_RO_type2_ST3, 100);
  
  testStep("", "PT4_PTCoor_PT_Rdy_ST3 is set to 0x01");
  $PT4_PTCoor_PT_Rdy_ST3 = 1;
  testWaitForSignalUpdate(PT4_PTCoor_PT_Rdy_ST3, 100);
  
  Wait(1500);
  WaitCycleToFinish();
}
/// <Profile_management>
//Function used to launch a profile 
// bProfile - Profile request ID 
// bInfo - type of request to be sent ( eg: PRESAFE, API, DIAG, CRASH)
// Example: LaunchMasterBeltProfile(PRE_SAFE_1, DIAG) 
//          LaunchMasterBeltProfile(PRE_SAFE_1, PRESAFE)
//          LaunchMasterBeltProfile(PRE_SAFE_1, API)
//          LaunchMasterBeltProfile(PRE_SAFE_1, CRASH)
void LaunchMasterBeltProfile(byte bProfile, byte bInfo)
{ 
  stack int index = 0;
  stack int foundflag = 0;
  char targetName[100];
    
  byte bLMBP_TriggerTensioningrequest[6] = {0x31, 0x01, 0x03, 0x30, 0x01, 0x05};
  byte bLMBP_TriggerBSRrequest[4] = {0x31, 0x01, 0x03, 0x29};
  
  diagRequest * dLMBP_TriggerTensioningRequest;
  diagResponse * dLMBP_TriggerTensioningResponse;
  
  diagRequest * bLMBP_TriggerBSRRequest;
  diagResponse * bLMBP_TriggerBSRResponse;
  
  diagRequest * dStart_ALV_Cycle_Request;
  diagResponse * dStart_ALV_Cycle_Response;
  byte bStart_ALV_Cycle_Request[5] = {0x31, 0x01, 0xF7, 0x03, 0x15};
  
  diagRequest * dStop_ALV_Cycle_Request;
  diagResponse * dStop_ALV_Cycle_Response; 
  byte bStop_ALV_Cycle_Request[4] = {0x31, 0x02, 0xF7, 0x03};
  
  
  diagGetCurrentEcu(targetName, elcount(targetName));
  
  switch (bInfo)
  {
    case PRESAFE:
      if (bProfile == 0x00 )
      {
        if ((@sysvar::ProjectConfiguration::sysTensioningRequestSource == 0) | (@sysvar::ProjectConfiguration::sysTensioningRequestSource == 5))
        {
          $PresfAct_Adj_ST3::PresfAccelReset_NotExcd_ST3 = 2;
          testWaitForSignalChange(PresfAct_Adj_ST3::PresfAccelReset_NotExcd_ST3, 100);
          
          testStep("", "Presf_Lvl_ST3 is set to 0x%X in order to launch %s profile", CYCLE[bProfile].Launch_ID, CYCLE[bProfile].Launch_Name);
          $PresfAct_Adj_ST3::Presf_Lvl_ST3 = CYCLE[bProfile].Launch_ID;
          testWaitForSignalChange(PresfAct_Adj_ST3::Presf_Lvl_ST3, 100);
          
          @sysvar::ProjectConfiguration::sysTensioningRequestSource = 5;
        }
        else
        {
          testStepFail("", "Wrong parameter PRESAFE for LaunchMasterBeltProfile since request has been made on another source");
          
          @sysvar::ProjectConfiguration::sysTensioningRequestSource = 5;
          LaunchMasterBeltProfile(NOLVL, API);
          LaunchMasterBeltProfile(NOLVL, PRESAFE);
          LaunchMasterBeltProfile(NOLVL, ORC);
        }
      }
      else
      {
          @sysvar::ProjectConfiguration::sysTensioningRequestSource = 0;
        
          testStep("", "PresfAccelReset_NotExcd_ST3 is set to 0x02");
          $PresfAct_Adj_ST3::PresfAccelReset_NotExcd_ST3 = 2;
          
          if ( bProfile > PRE_SAFE_8 )
          {
            testStepFail("", "Wrong profile for LaunchMasterBeltProfile with PRESAFE source: %s", CYCLE[bProfile].Launch_Name);
          }
          else
          {
            testStep("", "Presf_Lvl_ST3 is set to 0x%X in order to launch %s profile", CYCLE[bProfile].Launch_ID, CYCLE[bProfile].Launch_Name);
            $PresfAct_Adj_ST3::Presf_Lvl_ST3 = CYCLE[bProfile].Launch_ID;
            testWaitForSignalChange(PresfAct_Adj_ST3::Presf_Lvl_ST3, 100);
          }
      }
      break;
    
    case API:
      diagGetCurrentEcu(targetName, elcount(targetName));
      if (strncmp(targetName, sTargetECUFrontLeftName, elcount(targetName)) == 0)
        {
          if ( bProfile == 0x00 )
          {
            if ((@sysvar::ProjectConfiguration::sysTensioningRequestSource == 1) | (@sysvar::ProjectConfiguration::sysTensioningRequestSource == 5))
            {
              testStep("", "PresfAccelReset_NotExcd_ST3 is set to 0x02");
              $PresfAct_Adj_ST3::PresfAccelReset_NotExcd_ST3 = 2;
              testWaitForSignalChange(PresfAct_Adj_ST3::PresfAccelReset_NotExcd_ST3, 100);
              
              testStep("", "RBTMFL_SP_Lvl_Rq_ST35 is set to 0x00 in order to remove tensioning request");
              $RBTMFL_SP_Lvl_Rq_ST35 = CYCLE[bProfile].Launch_ID;
              testWaitForSignalChange(SBeltTens_SP_Lvl_ST3::RBTMFL_SP_Lvl_Rq_ST35, 100);
              
              @sysvar::ProjectConfiguration::sysTensioningRequestSource = 5;
            }
            else
            {
              testStepFail("", "Wrong parameter for LaunchMasterBeltProfile since request has been made on another source");
              
              @sysvar::ProjectConfiguration::sysTensioningRequestSource = 5;
              LaunchMasterBeltProfile(NOLVL, PRESAFE);
            }
          }
          else
          {
            @sysvar::ProjectConfiguration::sysTensioningRequestSource = 1;
            
            testStep("", "RBTMFL_SP_Lvl_Rq_ST35 is set to 0x%X in order to launch %s profile", CYCLE[bProfile].Launch_ID, CYCLE[bProfile].Launch_Name);
            $RBTMFL_SP_Lvl_Rq_ST35 = CYCLE[bProfile].Launch_ID;
            testWaitForSignalChange(SBeltTens_SP_Lvl_ST3::RBTMFL_SP_Lvl_Rq_ST35, 100);
          }
        }
        else
        {
          if ( bProfile == 0x00 )
          {
            if ( @sysvar::ProjectConfiguration::sysTensioningRequestSource == 1 ) 
            {
              testStep("", "PresfAccelReset_NotExcd_ST3 is set to 0x02");
              $PresfAct_Adj_ST3::PresfAccelReset_NotExcd_ST3 = 2;
              testWaitForSignalChange(PresfAct_Adj_ST3::PresfAccelReset_NotExcd_ST3, 100);
              
              testStep("", "RBTMFR_SP_Lvl_Rq_ST35 is set to 0x00 in order to remove tensioning request");
              $RBTMFR_SP_Lvl_Rq_ST35 = CYCLE[bProfile].Launch_ID;
              testWaitForSignalChange(SBeltTens_SP_Lvl_ST3::RBTMFR_SP_Lvl_Rq_ST35, 100);
            }
            else
            {
              testStepFail("", "Wrong parameter for LaunchMasterBeltProfile since request has been made on another source");
              
              @sysvar::ProjectConfiguration::sysTensioningRequestSource = 5;
              LaunchMasterBeltProfile(NOLVL, API);
              LaunchMasterBeltProfile(NOLVL, PRESAFE);
              LaunchMasterBeltProfile(NOLVL, ORC);
            }
          }
          else
          {
            @sysvar::ProjectConfiguration::sysTensioningRequestSource = 1;
            
            testStep("", "RBTMFR_SP_Lvl_Rq_ST35 is set to 0x%X in order to launch %s profile", CYCLE[bProfile].Launch_ID, CYCLE[bProfile].Launch_Name);
            $RBTMFR_SP_Lvl_Rq_ST35 = CYCLE[bProfile].Launch_ID;
            testWaitForSignalChange(SBeltTens_SP_Lvl_ST3::RBTMFR_SP_Lvl_Rq_ST35, 100);
          }
        }
      break;
        
    case DIAG:
      if ( bProfile == BSR_1 )
      {
        diagResize(bLMBP_TriggerBSRRequest, 4);
        diagSetPrimitiveData(bLMBP_TriggerBSRRequest, bLMBP_TriggerBSRrequest, 4);
        
        SendDiagnosticRequest(bLMBP_TriggerBSRRequest, bLMBP_TriggerBSRResponse);
        CheckPositiveResponse("BSR_1 profile is requested via diagnostic service", bLMBP_TriggerBSRRequest, bLMBP_TriggerBSRResponse); 
      }
      else
      {
        diagResize(dLMBP_TriggerTensioningRequest, 6);
        diagSetPrimitiveData(dLMBP_TriggerTensioningRequest, bLMBP_TriggerTensioningrequest, 6);
        DiagSetPrimitiveByte(dLMBP_TriggerTensioningRequest, 4, CYCLE[bProfile].Launch_ID);
        DiagSetPrimitiveByte(dLMBP_TriggerTensioningRequest, 5, 0x05); //TBD what is this parameter
        
        SendDiagnosticRequest(dLMBP_TriggerTensioningRequest, dLMBP_TriggerTensioningResponse);
        CheckPositiveResponse("Tensioning profile is requested via diagnostic service", dLMBP_TriggerTensioningRequest, dLMBP_TriggerTensioningResponse); 
      }
      
      break;
      
    case DIAG_INTERNAL:
      
      if(CYCLE[bProfile].DiagLaunch_ID == CYCLE[NOLVL].DiagLaunch_ID) // Stop activation
      {
        diagResize(dStop_ALV_Cycle_Request, 4);
        diagSetPrimitiveData(dStop_ALV_Cycle_Request, bStop_ALV_Cycle_Request, 4);
        SendDiagnosticRequest(dStop_ALV_Cycle_Request, dStop_ALV_Cycle_Response);
        CheckPositiveResponse("Tensioning stop request is sent via internal diagnostic service", dStop_ALV_Cycle_Request, dStop_ALV_Cycle_Response);
      }
      else // Start activation
      {
        diagResize(dStart_ALV_Cycle_Request, 5);
        diagSetPrimitiveData(dStart_ALV_Cycle_Request, bStart_ALV_Cycle_Request, 5);
        DiagSetPrimitiveByte(dStart_ALV_Cycle_Request, 4, CYCLE[bProfile].DiagLaunch_ID);
        SendDiagnosticRequest(dStart_ALV_Cycle_Request, dStart_ALV_Cycle_Response);
        CheckPositiveResponse("Tensioning profile is requested via internal diagnostic service.", dStart_ALV_Cycle_Request, dStart_ALV_Cycle_Response); 
      }
      break;
      
    case  ORC:
      if ( bProfile == 0x00 )
      {
        if ((@sysvar::ProjectConfiguration::sysTensioningRequestSource == 2) | (@sysvar::ProjectConfiguration::sysTensioningRequestSource == 5))
        {
          
          testStep("", "Impact_RO_type1_ST3 is set to 0x00");
          $Impact_RO_type1_ST3 = 0;
          testWaitForSignalChange(Impact_RO_type1_ST3, 100);
          
          @sysvar::ProjectConfiguration::sysTensioningRequestSource = 5;
        }
        else
        {
          testStepFail("", "Wrong parameter PRESAFE for LaunchMasterBeltProfile since request has been made on another source");
          
          @sysvar::ProjectConfiguration::sysTensioningRequestSource = 5;
          LaunchMasterBeltProfile(NOLVL, API);
          LaunchMasterBeltProfile(NOLVL, PRESAFE);
          LaunchMasterBeltProfile(NOLVL, ORC);
        }
      }
      else
      {
        @sysvar::ProjectConfiguration::sysTensioningRequestSource = 2;
        if ( bProfile == PRE_SAFE_8 )
        {
          testStep("", "Impact_RO_type1_ST3 is set to 0x01 in order to launch %s profile", CYCLE[bProfile].Launch_Name);//CYCLE[bProfile].Launch_ID
          $Impact_RO_type1_ST3 = 1;
          testWaitForSignalChange(Impact_RO_type1_ST3, 100);
        }
        else
        {
          testStepFail("", "Wrong profile for LaunchMasterBeltProfile with ORC source: %s", CYCLE[bProfile].Launch_Name);
        }
      }
      break;
      
     case ALGO:
        @sysvar::ProjectConfiguration::sysTensioningRequestSource = 0;
        
        if (bProfile == BSR_1)
        {
          if (strncmp(targetName, sTargetECUFrontLeftName, elcount(targetName)) == 0)
          {
            testStep("", "Bckl_Sw_D_Stat_ST3 is set to 0x01");
            $Bckl_Sw_D_Stat_ST3  = 1; // Buckle switch driver state: 1     = "STAT_NOK".
            testWaitForSignalUpdate(Bckl_Sw_D_Stat_ST3, 100);
            
            Wait(1000);
            
            testStep("", "Bckl_Sw_D_Stat_ST3 is set to 0x00");
            $Bckl_Sw_D_Stat_ST3  = 0; // Buckle switch driver state: 0     = "STAT_OK".
            testWaitForSignalUpdate(Bckl_Sw_D_Stat_ST3, 100);
          }
          else
          {
            testStep("", "Bckl_Sw_FP_Stat_ST3 is set to 0x01");
            $Bckl_Sw_FP_Stat_ST3  = 1; // Buckle switch driver state: 1     = "STAT_NOK".
            testWaitForSignalUpdate(Bckl_Sw_FP_Stat_ST3, 100);
            
            Wait(1000);
            
            testStep("", "Bckl_Sw_FP_Stat_ST3 is set to 0x00");
            $Bckl_Sw_FP_Stat_ST3  = 0; // Buckle switch driver state: 0     = "STAT_OK".
            testWaitForSignalUpdate(Bckl_Sw_FP_Stat_ST3, 100);
          }
        }
        else
        {
          testStepFail("", "Wrong profile for LaunchMasterBeltProfile with ALGO source: %s", CYCLE[bProfile].Launch_Name);
        }
      break;
    case FUNCTION:
        @sysvar::ProjectConfiguration::sysTensioningRequestSource = 0;
        
        if (bProfile == BSR_1)
        {
          if (strncmp(targetName, sTargetECUFrontLeftName, elcount(targetName)) == 0)
          {
            testStep("", "BltSlckDec_Md_Rq_HU_ST3 is set to 0x00");
            $BltSlckDec_Md_Rq_HU_ST3 = 0; // 0x00= OFF (disabled)
            testWaitForSignalUpdate(BltSlckDec_Md_Rq_HU_ST3, 1000);
            
            testStep("", "BltSlckDec_Md_FL_Stat_ST3 is set to 0x00");
            testWaitForSignalUpdate(BltSlckDec_Md_FL_Stat_ST3, 1000);
            
            Wait(1000);
            
            testStep("", "BltSlckDec_Md_Rq_HU_ST3 is set to 0x01");
            $BltSlckDec_Md_Rq_HU_ST3  = 1; // 0x01= ON (enable)
            testWaitForSignalUpdate(BltSlckDec_Md_Rq_HU_ST3, 1000);
            
            testStep("", "BltSlckDec_Md_FL_Stat_ST3 is set to 0x01");
            testWaitForSignalUpdate(BltSlckDec_Md_FL_Stat_ST3, 1000);
            
          }
          else
          {
            testStep("", "BltSlckDec_Md_Rq_HU_ST3 is set to 0x00");
            $BltSlckDec_Md_Rq_HU_ST3 = 0; // 0x00= OFF (disabled)
            testWaitForSignalUpdate(BltSlckDec_Md_Rq_HU_ST3, 1000);
            
            testStep("", "BltSlckDec_Md_FR_Stat_ST3 is set to 0x00");
            testWaitForSignalUpdate(BltSlckDec_Md_FR_Stat_ST3, 1000);
            
            Wait(1000);
            
            testStep("", "BltSlckDec_Md_Rq_HU_ST3 is set to 0x01");
            $BltSlckDec_Md_Rq_HU_ST3  = 1; // 0x01= ON (enable)
            testWaitForSignalUpdate(BltSlckDec_Md_Rq_HU_ST3, 1000);
            
            testStep("", "BltSlckDec_Md_FR_Stat_ST3 is set to 0x01");
            testWaitForSignalUpdate(BltSlckDec_Md_FR_Stat_ST3, 1000);
          }
        }
        else
        {
          testStepFail("", "Wrong profile for LaunchMasterBeltProfile with FUNCTION source: %s", CYCLE[bProfile].Launch_Name);
        }
      break;
  }
}

/// <Vehicle_configuration>
//// Write default vehicle equipment configuration data with service 0x2E 0x03 0x10  
//// Example:      WriteVehicleEquipmentConfiguration()
void WriteVehicleEquipmentConfiguration()
{
  WriteVehicleEquipmentConfiguration(0xFF, 0xFF);
}

/// <Vehicle_configuration>
//// Write ECU side with vehicle equipment configuration data with service 0x2E 0x03 0x10  
//// Example:      WriteVehicleEquipmentConfiguration(Left)
////               WriteVehicleEquipmentConfiguration(Right)
void WriteVehicleEquipmentConfiguration(byte bAttibute)
{
  byte bResponse[19];
  
  testStep("", "Authenticate ECU");
  AuthenticateECU(2);
  EnterDiagnosticSession("development");
  
  testStep("", "Read Vehicle Equipment Configuration Data");
  SendDiagnosticRequest(dReadVehicleEquipmentConfigurationDataRequest, dReadVehicleEquipmentConfigurationDataResponse);
  CheckPositiveResponse("Check positive response of the Read Vehicle Equipment Configuration Data", dReadVehicleEquipmentConfigurationDataRequest, dReadVehicleEquipmentConfigurationDataResponse);
  testReportWriteDiagResponse(dReadVehicleEquipmentConfigurationDataRequest);
  
  diagGetPrimitiveData(dReadVehicleEquipmentConfigurationDataResponse, bResponse, elcount(bResponse));
  
  diagResize(dWriteVehicleEquipmentConfigurationDataRequest, 19);
  diagSetPrimitiveData(dWriteVehicleEquipmentConfigurationDataRequest, bResponse, elcount(bResponse));
  DiagSetPrimitiveByte(dWriteVehicleEquipmentConfigurationDataRequest, 0, 0x2E);
  DiagSetPrimitiveByte(dWriteVehicleEquipmentConfigurationDataRequest, 1, 0x03);
  DiagSetPrimitiveByte(dWriteVehicleEquipmentConfigurationDataRequest, 2, 0x10);
  
   switch(bAttibute)
  {
    case Left: //////////////////////// Change ECU side to left  ////////////////////////
        DiagSetPrimitiveByte(dWriteVehicleEquipmentConfigurationDataRequest, 3, DiagGetPrimitiveByte(dReadVehicleEquipmentConfigurationDataResponse, 3) | 0x01);
        testStep("", "Change ECU side to left via Vehicle Equipment configuration service");
      break;
      
    case Right: //////////////////////// Change ECU side to right  ////////////////////////
        DiagSetPrimitiveByte(dWriteVehicleEquipmentConfigurationDataRequest, 3, DiagGetPrimitiveByte(dReadVehicleEquipmentConfigurationDataResponse, 3) & 0xFE);
        testStep("", "Change ECU side to right via Vehicle Equipment configuration service");
      break;
      
    default:
      testStepFail("", "Wrong parameter value for WritevehicleEquipment function");
      break;
        
  }
  
  testStep("", "Start variant coding sequence");  
  SecVarCoding_Start();
  Wait(2000);
    
  testStep("", "Send Write Vehicle Equipment Configuration Data diagnostic service request with new values");
  SendDiagnosticRequest(dWriteVehicleEquipmentConfigurationDataRequest, dWriteVehicleEquipmentConfigurationDataResponse);
  CheckPositiveResponse("Check positive response of Write Vehicle Equipment Configuration Data diagnostic service.", dWriteVehicleEquipmentConfigurationDataRequest, dWriteVehicleEquipmentConfigurationDataResponse);
  Wait(1000);
  
  testStep("", "Stop variant coding sequence");  
  SecVarCoding_Finish();
  
  wait(1500);
  ResetECU("soft");
  WaitECUInitialization();
  
   testStep("", "Authenticate ECU");
  AuthenticateECU(2);
  EnterDiagnosticSession("development");
  
  testStep("", "Read Vehicle Equipment Configuration Data");
  SendDiagnosticRequest(dReadVehicleEquipmentConfigurationDataRequest, dReadVehicleEquipmentConfigurationDataResponse);
  CheckPositiveResponse("Check positive response of the Read Vehicle Equipment Configuration Data", dReadVehicleEquipmentConfigurationDataRequest, dReadVehicleEquipmentConfigurationDataResponse);
  testReportWriteDiagResponse(dReadVehicleEquipmentConfigurationDataRequest);

}

/// <Vehicle_configuration>
//// Used for configuring the vehicle equipment configuration data with service 0x2E 0x03 0x10  
//// bAttibute - PRE_SAFE_1 - PRE_SAFE_15, HAPTIC_WARNING1 - HAPTIC_WARNING4, BSR_1 - BSR_3, PRE_SAFE_CURVE_1 - PRE_SAFE_CURVE_4
//// bInfo - Enable/Disable/Enable_ORC(PRE_SAFE_8 only)/Disable_ORC(PRE_SAFE_8 only)
//// Example:      WriteVehicleEquipmentConfiguration(Steering_Side, bVEH_LHD/bVEH_RHD) 
////               WriteVehicleEquipmentConfiguration(BSR, Disable/Enable) 
////               WriteVehicleEquipmentConfiguration(Belt_handover, Disable/Enable) 
////               WriteVehicleEquipmentConfiguration(HapticWarning_Left, Disable/Enable) 
////               WriteVehicleEquipmentConfiguration(HapticWarning_Right, Disable/Enable) 
////               WriteVehicleEquipmentConfiguration(API, Disable/Enable) 
////               WriteVehicleEquipmentConfiguration(PRE_SAFE_1, Disable/Enable) 
////               WriteVehicleEquipmentConfiguration(HAPTIC_WARNING1, Disable/Enable) 
////               WriteVehicleEquipmentConfiguration(PRE_SAFE_3, Disable/Enable) 
////               WriteVehicleEquipmentConfiguration(PRE_SAFE_4, Disable/Enable) 
////               WriteVehicleEquipmentConfiguration(PRE_SAFE_5, Disable/Enable)  
////               WriteVehicleEquipmentConfiguration(PRE_SAFE_6, Disable/Enable) 
////               WriteVehicleEquipmentConfiguration(PRE_SAFE_7, Disable/Enable) 
////               WriteVehicleEquipmentConfiguration(PRE_SAFE_8, Disable/Enable)  
////               WriteVehicleEquipmentConfiguration(PRE_SAFE_9, Disable/Enable) 
////               WriteVehicleEquipmentConfiguration(PRE_SAFE_10, Disable/Enable) 
////               WriteVehicleEquipmentConfiguration(PRE_SAFE_11, Disable/Enable)  
////               WriteVehicleEquipmentConfiguration(PRE_SAFE_12, Disable/Enable) 
////               WriteVehicleEquipmentConfiguration(PRE_SAFE_13, Disable/Enable) 
////               WriteVehicleEquipmentConfiguration(PRE_SAFE_14, Disable/Enable)  
////               WriteVehicleEquipmentConfiguration(PRE_SAFE_15, Disable/Enable) 
////               WriteVehicleEquipmentConfiguration(HAPTIC_WARNING2, Disable/Enable)  
////               WriteVehicleEquipmentConfiguration(HAPTIC_WARNING3, Disable/Enable) 
////               WriteVehicleEquipmentConfiguration(HAPTIC_WARNING4, Disable/Enable)  
////               WriteVehicleEquipmentConfiguration(BSR_1, Disable/Enable) 
////               WriteVehicleEquipmentConfiguration(BSR_2, Disable/Enable)  
////               WriteVehicleEquipmentConfiguration(BSR_3, Disable/Enable)  
////               WriteVehicleEquipmentConfiguration(PRE_SAFE_CURVE_1, Disable/Enable)  
////               WriteVehicleEquipmentConfiguration(PRE_SAFE_CURVE_2, Disable/Enable)  
////               WriteVehicleEquipmentConfiguration(PRE_SAFE_CURVE_3, Disable/Enable)  
////               WriteVehicleEquipmentConfiguration(PRE_SAFE_CURVE_4, Disable/Enable)  
////               WriteVehicleEquipmentConfiguration(START_UP, Disable/Enable)  
////               WriteVehicleEquipmentConfiguration(Release_memory_location, EEPROM/ROM)  
////               WriteVehicleEquipmentConfiguration(BSR_memory_location, EEPROM/ROM) 
////               WriteVehicleEquipmentConfiguration(PRESAFE_memory_location, EEPROM/ROM) 
////               WriteVehicleEquipmentConfiguration(Undervoltage_Abort_Thrs, Voltage_7_5/Voltage_7_6/.../Voltage_10_0)  
////               WriteVehicleEquipmentConfiguration(Undervoltage_Thrs, Voltage_7_5/Voltage_7_6/.../Voltage_10_0)  
////               WriteVehicleEquipmentConfiguration(Overvoltage_Abort_Thrs, Voltage_16_0/Voltage_16_1/.../Voltage_18_0)  
////               WriteVehicleEquipmentConfiguration(Overvoltage_Thrs, Voltage_16_0/Voltage_16_1/.../Voltage_18_0)  
void WriteVehicleEquipmentConfiguration(byte bAttibute, byte bInfo)
{
  stack byte bResponse[19];
  
  testStep("", "Authenticate ECU");
  AuthenticateECU(2);
  EnterDiagnosticSession("development");
  
  testStep("", "Read Vehicle Equipment Configuration Data");
  SendDiagnosticRequest(dReadVehicleEquipmentConfigurationDataRequest, dReadVehicleEquipmentConfigurationDataResponse);
  CheckPositiveResponse("Check positive response of the Read Vehicle Equipment Configuration Data", dReadVehicleEquipmentConfigurationDataRequest, dReadVehicleEquipmentConfigurationDataResponse);
  testReportWriteDiagResponse(dReadVehicleEquipmentConfigurationDataRequest);
  
  diagGetPrimitiveData(dReadVehicleEquipmentConfigurationDataResponse, bResponse, elcount(bResponse));
  
  diagResize(dWriteVehicleEquipmentConfigurationDataRequest, 19);
  diagSetPrimitiveData(dWriteVehicleEquipmentConfigurationDataRequest, bResponse, elcount(bResponse));
  DiagSetPrimitiveByte(dWriteVehicleEquipmentConfigurationDataRequest, 0, 0x2E);
  DiagSetPrimitiveByte(dWriteVehicleEquipmentConfigurationDataRequest, 1, 0x03);
  DiagSetPrimitiveByte(dWriteVehicleEquipmentConfigurationDataRequest, 2, 0x10);
  
  switch(bAttibute)
  {
    case Steering_Side:
      if (bInfo == bVEH_LHD)
      {
        DiagSetPrimitiveByte(dWriteVehicleEquipmentConfigurationDataRequest, 3, DiagGetPrimitiveByte(dReadVehicleEquipmentConfigurationDataResponse, 3) | 0x01);
        testStep(@sysvar::CORE::sysLevelOfDetailStep, "VEH" ,"EVC_List03_StStyle_ST3 was set to LHD (0x01) via Vehicle Equipment configuration service.");
      }
      else
        if (bInfo == bVEH_RHD)
        {
          DiagSetPrimitiveByte(dWriteVehicleEquipmentConfigurationDataRequest, 3, DiagGetPrimitiveByte(dReadVehicleEquipmentConfigurationDataResponse, 3) & 0xFE);
          testStep(@sysvar::CORE::sysLevelOfDetailStep, "VEH" ,"EVC_List03_StStyle_ST3 was set to RHD (0x00) via Vehicle Equipment configuration service.");
        }
        else
        {
          testStepFail("", "Wrong parameter value for WritevehicleEquipment function");
        }
      break;
      
    case BSR: //////////////////////// BSR - Enable/Disable ////////////////////////
      if (bInfo == Disable)
      {
        DiagSetPrimitiveByte(dWriteVehicleEquipmentConfigurationDataRequest, 3, DiagGetPrimitiveByte(dReadVehicleEquipmentConfigurationDataResponse, 3) | 0x02);
        testStep("", "BSR is disabled via Vehicle Equipment configuration service");
      }
      else
        if (bInfo == Enable)
        {
          DiagSetPrimitiveByte(dWriteVehicleEquipmentConfigurationDataRequest, 3, DiagGetPrimitiveByte(dReadVehicleEquipmentConfigurationDataResponse, 3) & 0xFD);
          testStep("", "BSR is enabled via Vehicle Equipment configuration service");
        }
        else
        {
          testStepFail("", "Wrong parameter value for WritevehicleEquipment function");
        }
      break;
      
    case Belt_handover: //////////////////////// Belt handover - Enable/Disable ////////////////////////
      if (bInfo == Disable)
      {
        DiagSetPrimitiveByte(dWriteVehicleEquipmentConfigurationDataRequest, 3, DiagGetPrimitiveByte(dReadVehicleEquipmentConfigurationDataResponse, 3) | 0x04);
        testStep("", "Belt_handover is disabled via Vehicle Equipment configuration service");
      }
      else
        if (bInfo == Enable)
        {
          DiagSetPrimitiveByte(dWriteVehicleEquipmentConfigurationDataRequest, 3, DiagGetPrimitiveByte(dReadVehicleEquipmentConfigurationDataResponse, 3) & 0xFB);
          testStep("", "Belt_handover is enabled via Vehicle Equipment configuration service");
        }
        else
        {
          testStepFail("", "Wrong parameter value for WritevehicleEquipment function");
        }
      break;
    
    
    case HapticWarning_Left: //////////////////////// Haptic warning Left  - Enable/Disable ////////////////////////
      if (bInfo == Disable)
      {
        DiagSetPrimitiveByte(dWriteVehicleEquipmentConfigurationDataRequest, 3, DiagGetPrimitiveByte(dReadVehicleEquipmentConfigurationDataResponse, 3) | 0x10);
        testStep("", "Haptic warning Left is disabled via Vehicle Equipment configuration service", CYCLE[bAttibute].Launch_Name);
      }
      else
        if (bInfo == Enable)
        {
          DiagSetPrimitiveByte(dWriteVehicleEquipmentConfigurationDataRequest, 3, DiagGetPrimitiveByte(dReadVehicleEquipmentConfigurationDataResponse, 3) & 0xEF);
          testStep("", "Haptic warning Left is enabled via Vehicle Equipment configuration service");
        }
        else
        {
          testStepFail("", "Wrong parameter value for WritevehicleEquipment function");
        }
      break;
        
    case HapticWarning_Right: //////////////////////// Haptic warning Right - Enable/Disable ////////////////////////
      if (bInfo == Disable)
      {
        DiagSetPrimitiveByte(dWriteVehicleEquipmentConfigurationDataRequest, 3, DiagGetPrimitiveByte(dReadVehicleEquipmentConfigurationDataResponse, 3) | 0x20);
        testStep("", "Haptic warning Right is disabled via Vehicle Equipment configuration service");
      }
      else
        if (bInfo == Enable)
        {
          DiagSetPrimitiveByte(dWriteVehicleEquipmentConfigurationDataRequest, 3, DiagGetPrimitiveByte(dReadVehicleEquipmentConfigurationDataResponse, 3) & 0xDF);
          testStep("", " Haptic warning Right is enabled via Vehicle Equipment configuration service");
        }
        else
        {
          testStepFail("", "Wrong parameter value for WritevehicleEquipment function");
        }
      break;
    
    case API: //////////////////////// API - Enable/Disable ////////////////////////
      if (bInfo == Disable)
      {
        DiagSetPrimitiveByte(dWriteVehicleEquipmentConfigurationDataRequest, 3, DiagGetPrimitiveByte(dReadVehicleEquipmentConfigurationDataResponse, 3) | 0x40);
        testStep("", "API is disabled via Vehicle Equipment configuration service");
      }
      else
        if (bInfo == Enable)
        {
          DiagSetPrimitiveByte(dWriteVehicleEquipmentConfigurationDataRequest, 3, DiagGetPrimitiveByte(dReadVehicleEquipmentConfigurationDataResponse, 3) & 0xBF);
          testStep("", "API is enabled via Vehicle Equipment configuration service");
        }
        else
        {
          testStepFail("", "Wrong parameter value for WritevehicleEquipment function");
        }
      break;
    
    case PRE_SAFE_1: //////////////////////// PRE_SAFE_1 - Enable/Disable ////////////////////////
      if (bInfo == Disable)
      {
        DiagSetPrimitiveByte(dWriteVehicleEquipmentConfigurationDataRequest, 4, DiagGetPrimitiveByte(dReadVehicleEquipmentConfigurationDataResponse, 4) | 0x01);
        testStep("", " %s is disabled via Vehicle Equipment configuration service", CYCLE[bAttibute].Launch_Name);
      }
      else
        if (bInfo == Enable)
        {
          DiagSetPrimitiveByte(dWriteVehicleEquipmentConfigurationDataRequest, 4, DiagGetPrimitiveByte(dReadVehicleEquipmentConfigurationDataResponse, 4) & 0xFE);
          testStep("", " %s is enabled via Vehicle Equipment configuration service", CYCLE[bAttibute].Launch_Name);
        }
        else
        {
          testStepFail("", "Wrong parameter value for WritevehicleEquipment function");
        }
      break;
        
    case HAPTIC_WARNING1: //////////////////////// HAPTIC_WARNING1 - Enable/Disable ////////////////////////
      if (bInfo == Disable)
      {
        DiagSetPrimitiveByte(dWriteVehicleEquipmentConfigurationDataRequest, 4, DiagGetPrimitiveByte(dReadVehicleEquipmentConfigurationDataResponse, 4) | 0x02);
        testStep("", " %s is disabled via Vehicle Equipment configuration service", CYCLE[bAttibute].Launch_Name);
      }
      else
        if (bInfo == Enable)
        {
          DiagSetPrimitiveByte(dWriteVehicleEquipmentConfigurationDataRequest, 4, DiagGetPrimitiveByte(dReadVehicleEquipmentConfigurationDataResponse, 4) & 0xFD);
          testStep("", " %s is enabled via Vehicle Equipment configuration service", CYCLE[bAttibute].Launch_Name);
        }
        else
        {
          testStepFail("", "Wrong parameter value for WritevehicleEquipment function");
        }
      break;
        
    case PRE_SAFE_3: //////////////////////// PRE_SAFE_3 - Enable/Disable ////////////////////////
      if (bInfo == Disable)
      {
        DiagSetPrimitiveByte(dWriteVehicleEquipmentConfigurationDataRequest, 4, DiagGetPrimitiveByte(dReadVehicleEquipmentConfigurationDataResponse, 4) | 0x04);
        testStep("", " %s is disabled via Vehicle Equipment configuration service", CYCLE[bAttibute].Launch_Name);
      }
      else
        if (bInfo == Enable)
        {
          DiagSetPrimitiveByte(dWriteVehicleEquipmentConfigurationDataRequest, 4, DiagGetPrimitiveByte(dReadVehicleEquipmentConfigurationDataResponse, 4) & 0xFB);
          testStep("", " %s is enabled via Vehicle Equipment configuration service", CYCLE[bAttibute].Launch_Name);
        }
        else
        {
          testStepFail("", "Wrong parameter value for WritevehicleEquipment function");
        }
      break;
        
    case PRE_SAFE_4: //////////////////////// PRE_SAFE_4 - Enable/Disable ////////////////////////
      if (bInfo == Disable)
      {
        DiagSetPrimitiveByte(dWriteVehicleEquipmentConfigurationDataRequest, 4, DiagGetPrimitiveByte(dReadVehicleEquipmentConfigurationDataResponse, 4) | 0x08);
        testStep("", " %s is disabled via Vehicle Equipment configuration service", CYCLE[bAttibute].Launch_Name);
      }
      else
        if (bInfo == Enable)
        {
          DiagSetPrimitiveByte(dWriteVehicleEquipmentConfigurationDataRequest, 4, DiagGetPrimitiveByte(dReadVehicleEquipmentConfigurationDataResponse, 4) & 0xF7);
          testStep("", " %s is enabled via Vehicle Equipment configuration service", CYCLE[bAttibute].Launch_Name);
        }
        else
        {
          testStepFail("", "Wrong parameter value for WritevehicleEquipment function");
        }
      break;
        
    case PRE_SAFE_5: //////////////////////// PRE_SAFE_5 - Enable/Disable ////////////////////////
      if (bInfo == Disable)
      {
        DiagSetPrimitiveByte(dWriteVehicleEquipmentConfigurationDataRequest, 4, DiagGetPrimitiveByte(dReadVehicleEquipmentConfigurationDataResponse, 4) | 0x10);
        testStep("", " %s is disabled via Vehicle Equipment configuration service", CYCLE[bAttibute].Launch_Name);
      }
      else
        if (bInfo == Enable)
        {
          DiagSetPrimitiveByte(dWriteVehicleEquipmentConfigurationDataRequest, 4, DiagGetPrimitiveByte(dReadVehicleEquipmentConfigurationDataResponse, 4) & 0xEF);
          testStep("", " %s is enabled via Vehicle Equipment configuration service", CYCLE[bAttibute].Launch_Name);
        }
        else
        {
          testStepFail("", "Wrong parameter value for WritevehicleEquipment function");
        }
      break;
        
    case PRE_SAFE_6: //////////////////////// PRE_SAFE_6 - Enable/Disable ////////////////////////
      if (bInfo == Disable)
      {
        DiagSetPrimitiveByte(dWriteVehicleEquipmentConfigurationDataRequest, 4, DiagGetPrimitiveByte(dReadVehicleEquipmentConfigurationDataResponse, 4) | 0x20);
        testStep("", " %s is disabled via Vehicle Equipment configuration service", CYCLE[bAttibute].Launch_Name);
      }
      else
        if (bInfo == Enable)
        {
          DiagSetPrimitiveByte(dWriteVehicleEquipmentConfigurationDataRequest, 4, DiagGetPrimitiveByte(dReadVehicleEquipmentConfigurationDataResponse, 4) & 0xDF);
          testStep("", " %s is enabled via Vehicle Equipment configuration service", CYCLE[bAttibute].Launch_Name);
        }
        else
        {
          testStepFail("", "Wrong parameter value for WritevehicleEquipment function");
        }
      break;
        
    case PRE_SAFE_7: //////////////////////// PRE_SAFE_7 - Enable/Disable ////////////////////////
      if (bInfo == Disable)
      {
        DiagSetPrimitiveByte(dWriteVehicleEquipmentConfigurationDataRequest, 4, DiagGetPrimitiveByte(dReadVehicleEquipmentConfigurationDataResponse, 4) | 0x40);
        testStep("", " %s is disabled via Vehicle Equipment configuration service", CYCLE[bAttibute].Launch_Name);
      }
      else
        if (bInfo == Enable)
        {
          DiagSetPrimitiveByte(dWriteVehicleEquipmentConfigurationDataRequest, 4, DiagGetPrimitiveByte(dReadVehicleEquipmentConfigurationDataResponse, 4) & 0xBF);
          testStep("", " %s is enabled via Vehicle Equipment configuration service", CYCLE[bAttibute].Launch_Name);
        }
        else
        {
          testStepFail("", "Wrong parameter value for WritevehicleEquipment function");
        }
      break;
        
    case PRE_SAFE_8: //////////////////////// PRE_SAFE_8 - Enable/Disable ////////////////////////
      if (bInfo == Disable)
      {
        DiagSetPrimitiveByte(dWriteVehicleEquipmentConfigurationDataRequest, 4, DiagGetPrimitiveByte(dReadVehicleEquipmentConfigurationDataResponse, 4) | 0x80);
        testStep("", " %s is disabled via Vehicle Equipment configuration service", CYCLE[bAttibute].Launch_Name);
      }
      else
        if (bInfo == Enable)
        {
          DiagSetPrimitiveByte(dWriteVehicleEquipmentConfigurationDataRequest, 4, DiagGetPrimitiveByte(dReadVehicleEquipmentConfigurationDataResponse, 4) & 0x7F);
          testStep("", " %s is enabled via Vehicle Equipment configuration service", CYCLE[bAttibute].Launch_Name);
        }
        else
          if (bInfo == Disable_ORC)
          {
            DiagSetPrimitiveByte(dWriteVehicleEquipmentConfigurationDataRequest, 8, DiagGetPrimitiveByte(dReadVehicleEquipmentConfigurationDataResponse, 8) | 0x01);
            testStep("", " %s is disabled for ORC request via Vehicle Equipment configuration service", CYCLE[bAttibute].Launch_Name);
          }
          else
            if (bInfo == Enable_ORC)
            {
              DiagSetPrimitiveByte(dWriteVehicleEquipmentConfigurationDataRequest, 8, DiagGetPrimitiveByte(dReadVehicleEquipmentConfigurationDataResponse, 8) & 0xFE);
              testStep("", " %s is enabled for ORC request via Vehicle Equipment configuration service", CYCLE[bAttibute].Launch_Name);
            }       
            else
            {
              testStepFail("", "Wrong parameter value for WritevehicleEquipment function");
            }
      break;
        
    case PRE_SAFE_9: //////////////////////// PRE_SAFE_9 - Enable/Disable ////////////////////////
      if (bInfo == Disable)
      {
        DiagSetPrimitiveByte(dWriteVehicleEquipmentConfigurationDataRequest, 5, DiagGetPrimitiveByte(dReadVehicleEquipmentConfigurationDataResponse, 5) | 0x01);
        testStep("", " %s is disabled via Vehicle Equipment configuration service", CYCLE[bAttibute].Launch_Name);
      }
      else
        if (bInfo == Enable)
        {
          DiagSetPrimitiveByte(dWriteVehicleEquipmentConfigurationDataRequest, 5, DiagGetPrimitiveByte(dReadVehicleEquipmentConfigurationDataResponse, 5) & 0xFE);
          testStep("", " %s is enabled via Vehicle Equipment configuration service", CYCLE[bAttibute].Launch_Name);
        }
        else
        {
          testStepFail("", "Wrong parameter value for WritevehicleEquipment function");
        }
      break;
        
    case PRE_SAFE_10: //////////////////////// PRE_SAFE_10 - Enable/Disable ////////////////////////
      if (bInfo == Disable)
      {
        DiagSetPrimitiveByte(dWriteVehicleEquipmentConfigurationDataRequest, 5, DiagGetPrimitiveByte(dReadVehicleEquipmentConfigurationDataResponse, 5) | 0x02);
        testStep("", " %s is disabled via Vehicle Equipment configuration service", CYCLE[bAttibute].Launch_Name);
      }
      else
        if (bInfo == Enable)
        {
          DiagSetPrimitiveByte(dWriteVehicleEquipmentConfigurationDataRequest, 5, DiagGetPrimitiveByte(dReadVehicleEquipmentConfigurationDataResponse, 5) & 0xFD);
          testStep("", " %s is enabled via Vehicle Equipment configuration service", CYCLE[bAttibute].Launch_Name);
        }
        else
        {
          testStepFail("", "Wrong parameter value for WritevehicleEquipment function");
        }
      break;
        
    case PRE_SAFE_11: //////////////////////// PRE_SAFE_11 - Enable/Disable ////////////////////////
      if (bInfo == Disable)
      {
        DiagSetPrimitiveByte(dWriteVehicleEquipmentConfigurationDataRequest, 5, DiagGetPrimitiveByte(dReadVehicleEquipmentConfigurationDataResponse, 5) | 0x04);
        testStep("", " %s is disabled via Vehicle Equipment configuration service", CYCLE[bAttibute].Launch_Name);
      }
      else
        if (bInfo == Enable)
        {
          DiagSetPrimitiveByte(dWriteVehicleEquipmentConfigurationDataRequest, 5, DiagGetPrimitiveByte(dReadVehicleEquipmentConfigurationDataResponse, 5) & 0xFB);
          testStep("", " %s is enabled via Vehicle Equipment configuration service", CYCLE[bAttibute].Launch_Name);
        }
        else
        {
          testStepFail("", "Wrong parameter value for WritevehicleEquipment function");
        }
      break;
        
    case PRE_SAFE_12: //////////////////////// PRE_SAFE_12 - Enable/Disable ////////////////////////
      if (bInfo == Disable)
      {
        DiagSetPrimitiveByte(dWriteVehicleEquipmentConfigurationDataRequest, 5, DiagGetPrimitiveByte(dReadVehicleEquipmentConfigurationDataResponse, 5) | 0x08);
        testStep("", " %s is disabled via Vehicle Equipment configuration service", CYCLE[bAttibute].Launch_Name);
      }
      else
        if (bInfo == Enable)
        {
          DiagSetPrimitiveByte(dWriteVehicleEquipmentConfigurationDataRequest, 5, DiagGetPrimitiveByte(dReadVehicleEquipmentConfigurationDataResponse, 5) & 0xF7);
          testStep("", " %s is enabled via Vehicle Equipment configuration service", CYCLE[bAttibute].Launch_Name);
        }
        else
        {
          testStepFail("", "Wrong parameter value for WritevehicleEquipment function");
        }
      break;
        
    case PRE_SAFE_13: //////////////////////// PRE_SAFE_13 - Enable/Disable ////////////////////////
      if (bInfo == Disable)
      {
        DiagSetPrimitiveByte(dWriteVehicleEquipmentConfigurationDataRequest, 5, DiagGetPrimitiveByte(dReadVehicleEquipmentConfigurationDataResponse, 5) | 0x10);
        testStep("", " %s is disabled via Vehicle Equipment configuration service", CYCLE[bAttibute].Launch_Name);
      }
      else
        if (bInfo == Enable)
        {
          DiagSetPrimitiveByte(dWriteVehicleEquipmentConfigurationDataRequest, 5, DiagGetPrimitiveByte(dReadVehicleEquipmentConfigurationDataResponse, 5) & 0xEF);
          testStep("", " %s is enabled via Vehicle Equipment configuration service", CYCLE[bAttibute].Launch_Name);
        }
        else
        {
          testStepFail("", "Wrong parameter value for WritevehicleEquipment function");
        }
      break;
        
    case PRE_SAFE_14: //////////////////////// PRE_SAFE_14 - Enable/Disable ////////////////////////
      if (bInfo == Disable)
      {
        DiagSetPrimitiveByte(dWriteVehicleEquipmentConfigurationDataRequest, 5, DiagGetPrimitiveByte(dReadVehicleEquipmentConfigurationDataResponse, 5) | 0x20);
        testStep("", " %s is disabled via Vehicle Equipment configuration service", CYCLE[bAttibute].Launch_Name);
      }
      else
        if (bInfo == Enable)
        {
          DiagSetPrimitiveByte(dWriteVehicleEquipmentConfigurationDataRequest, 5, DiagGetPrimitiveByte(dReadVehicleEquipmentConfigurationDataResponse, 5) & 0xDF);
          testStep("", " %s is enabled via Vehicle Equipment configuration service", CYCLE[bAttibute].Launch_Name);
        }
        else
        {
          testStepFail("", "Wrong parameter value for WritevehicleEquipment function");
        }
      break;
        
    case PRE_SAFE_15: //////////////////////// PRE_SAFE_15 - Enable/Disable ////////////////////////
      if (bInfo == Disable)
      {
        DiagSetPrimitiveByte(dWriteVehicleEquipmentConfigurationDataRequest, 5, DiagGetPrimitiveByte(dReadVehicleEquipmentConfigurationDataResponse, 5) | 0x40);
        testStep("", " %s is disabled via Vehicle Equipment configuration service", CYCLE[bAttibute].Launch_Name);
      }
      else
        if (bInfo == Enable)
        {
          DiagSetPrimitiveByte(dWriteVehicleEquipmentConfigurationDataRequest, 5, DiagGetPrimitiveByte(dReadVehicleEquipmentConfigurationDataResponse, 5) & 0xBF);
          testStep("", " %s is enabled via Vehicle Equipment configuration service", CYCLE[bAttibute].Launch_Name);
        }
        else
        {
          testStepFail("", "Wrong parameter value for WritevehicleEquipment function");
        }
      break;
        
    case HAPTIC_WARNING2: //////////////////////// HAPTIC_WARNING2 - Enable/Disable ////////////////////////
      if (bInfo == Disable)
      {
        DiagSetPrimitiveByte(dWriteVehicleEquipmentConfigurationDataRequest, 5, DiagGetPrimitiveByte(dReadVehicleEquipmentConfigurationDataResponse, 5) | 0x80);
        testStep("", " %s is disabled via Vehicle Equipment configuration service", CYCLE[bAttibute].Launch_Name);
      }
      else
        if (bInfo == Enable)
        {
          DiagSetPrimitiveByte(dWriteVehicleEquipmentConfigurationDataRequest, 5, DiagGetPrimitiveByte(dReadVehicleEquipmentConfigurationDataResponse, 5) & 0x7F);
          testStep("", " %s is enabled via Vehicle Equipment configuration service", CYCLE[bAttibute].Launch_Name);
        }
        else
        {
          testStepFail("", "Wrong parameter value for WritevehicleEquipment function");
        }
      break;
        
    case HAPTIC_WARNING3: //////////////////////// HAPTIC_WARNING3 - Enable/Disable ////////////////////////
      if (bInfo == Disable)
      {
        DiagSetPrimitiveByte(dWriteVehicleEquipmentConfigurationDataRequest, 6, DiagGetPrimitiveByte(dReadVehicleEquipmentConfigurationDataResponse, 6) | 0x01);
        testStep("", " %s is disabled via Vehicle Equipment configuration service", CYCLE[bAttibute].Launch_Name);
      }
      else
        if (bInfo == Enable)
        {
          DiagSetPrimitiveByte(dWriteVehicleEquipmentConfigurationDataRequest, 6, DiagGetPrimitiveByte(dReadVehicleEquipmentConfigurationDataResponse, 6) & 0xFE);
          testStep("", " %s is enabled via Vehicle Equipment configuration service", CYCLE[bAttibute].Launch_Name);
        }
        else
        {
          testStepFail("", "Wrong parameter value for WritevehicleEquipment function");
        }
      break;
        
    case HAPTIC_WARNING4: //////////////////////// HAPTIC_WARNING4 - Enable/Disable ////////////////////////
      if (bInfo == Disable)
      {
        DiagSetPrimitiveByte(dWriteVehicleEquipmentConfigurationDataRequest, 6, DiagGetPrimitiveByte(dReadVehicleEquipmentConfigurationDataResponse, 6) | 0x02);
        testStep("", " %s is disabled via Vehicle Equipment configuration service", CYCLE[bAttibute].Launch_Name);
      }
      else
        if (bInfo == Enable)
        {
          DiagSetPrimitiveByte(dWriteVehicleEquipmentConfigurationDataRequest, 6, DiagGetPrimitiveByte(dReadVehicleEquipmentConfigurationDataResponse, 6) & 0xFD);
          testStep("", " %s is enabled via Vehicle Equipment configuration service", CYCLE[bAttibute].Launch_Name);
        }
        else
        {
          testStepFail("", "Wrong parameter value for WritevehicleEquipment function");
        }
      break;
        
    case BSR_1: //////////////////////// BSR_1 - Enable/Disable ////////////////////////
      if (bInfo == Disable)
      {
        DiagSetPrimitiveByte(dWriteVehicleEquipmentConfigurationDataRequest, 6, DiagGetPrimitiveByte(dReadVehicleEquipmentConfigurationDataResponse, 6) | 0x04);
        testStep("", " %s is disabled via Vehicle Equipment configuration service", CYCLE[bAttibute].Launch_Name);
      }
      else
        if (bInfo == Enable)
        {
          DiagSetPrimitiveByte(dWriteVehicleEquipmentConfigurationDataRequest, 6, DiagGetPrimitiveByte(dReadVehicleEquipmentConfigurationDataResponse, 6) & 0xFB);
          testStep("", " %s is enabled via Vehicle Equipment configuration service", CYCLE[bAttibute].Launch_Name);
        }
        else
        {
          testStepFail("", "Wrong parameter value for WritevehicleEquipment function");
        }
      break;
        
    case BSR_2: //////////////////////// BSR_2 - Enable/Disable ////////////////////////
      if (bInfo == Disable)
      {
        DiagSetPrimitiveByte(dWriteVehicleEquipmentConfigurationDataRequest, 6, DiagGetPrimitiveByte(dReadVehicleEquipmentConfigurationDataResponse, 6) | 0x08);
        testStep("", " %s is disabled via Vehicle Equipment configuration service", CYCLE[bAttibute].Launch_Name);
      }
      else
        if (bInfo == Enable)
        {
          DiagSetPrimitiveByte(dWriteVehicleEquipmentConfigurationDataRequest, 6, DiagGetPrimitiveByte(dReadVehicleEquipmentConfigurationDataResponse, 6) & 0xF7);
          testStep("", " %s is enabled via Vehicle Equipment configuration service", CYCLE[bAttibute].Launch_Name);
        }
        else
        {
          testStepFail("", "Wrong parameter value for WritevehicleEquipment function");
        }
      break;
        
    case BSR_3: //////////////////////// BSR_3 - Enable/Disable ////////////////////////
      if (bInfo == Disable)
      {
        DiagSetPrimitiveByte(dWriteVehicleEquipmentConfigurationDataRequest, 6, DiagGetPrimitiveByte(dReadVehicleEquipmentConfigurationDataResponse, 6) | 0x10);
        testStep("", " %s is disabled via Vehicle Equipment configuration service", CYCLE[bAttibute].Launch_Name);
      }
      else
        if (bInfo == Enable)
        {
          DiagSetPrimitiveByte(dWriteVehicleEquipmentConfigurationDataRequest, 6, DiagGetPrimitiveByte(dReadVehicleEquipmentConfigurationDataResponse, 6) & 0xEF);
          testStep("", " %s is enabled via Vehicle Equipment configuration service", CYCLE[bAttibute].Launch_Name);
        }
        else
        {
          testStepFail("", "Wrong parameter value for WritevehicleEquipment function");
        }
      break;
        
    case PRE_SAFE_CURVE_1: //////////////////////// PRE_SAFE_CURVE_1 - Enable/Disable ////////////////////////
      if (bInfo == Disable)
      {
        DiagSetPrimitiveByte(dWriteVehicleEquipmentConfigurationDataRequest, 6, DiagGetPrimitiveByte(dReadVehicleEquipmentConfigurationDataResponse, 6) | 0x20);
        testStep("", " %s is disabled via Vehicle Equipment configuration service", CYCLE[bAttibute].Launch_Name);
      }
      else
        if (bInfo == Enable)
        {
          DiagSetPrimitiveByte(dWriteVehicleEquipmentConfigurationDataRequest, 6, DiagGetPrimitiveByte(dReadVehicleEquipmentConfigurationDataResponse, 6) & 0xDF);
          testStep("", " %s is enabled via Vehicle Equipment configuration service", CYCLE[bAttibute].Launch_Name);
        }
        else
        {
          testStepFail("", "Wrong parameter value for WritevehicleEquipment function");
        }
      break;
        
    case PRE_SAFE_CURVE_2: //////////////////////// PRE_SAFE_CURVE_2 - Enable/Disable ////////////////////////
      if (bInfo == Disable)
      {
        DiagSetPrimitiveByte(dWriteVehicleEquipmentConfigurationDataRequest, 6, DiagGetPrimitiveByte(dReadVehicleEquipmentConfigurationDataResponse, 6) | 0x40);
        testStep("", " %s is disabled via Vehicle Equipment configuration service", CYCLE[bAttibute].Launch_Name);
      }
      else
        if (bInfo == Enable)
        {
          DiagSetPrimitiveByte(dWriteVehicleEquipmentConfigurationDataRequest, 6, DiagGetPrimitiveByte(dReadVehicleEquipmentConfigurationDataResponse, 6) & 0xBF);
          testStep("", " %s is enabled via Vehicle Equipment configuration service", CYCLE[bAttibute].Launch_Name);
        }
        else
        {
          testStepFail("", "Wrong parameter value for WritevehicleEquipment function");
        }
      break;
        
    case PRE_SAFE_CURVE_3: //////////////////////// PRE_SAFE_CURVE_3 - Enable/Disable ////////////////////////
      if (bInfo == Disable)
      {
        DiagSetPrimitiveByte(dWriteVehicleEquipmentConfigurationDataRequest, 6, DiagGetPrimitiveByte(dReadVehicleEquipmentConfigurationDataResponse, 6) | 0x80);
        testStep("", " %s is disabled via Vehicle Equipment configuration service", CYCLE[bAttibute].Launch_Name);
      }
      else
        if (bInfo == Enable)
        {
          DiagSetPrimitiveByte(dWriteVehicleEquipmentConfigurationDataRequest, 6, DiagGetPrimitiveByte(dReadVehicleEquipmentConfigurationDataResponse, 6) & 0x7F);
          testStep("", " %s is enabled via Vehicle Equipment configuration service", CYCLE[bAttibute].Launch_Name);
        }
        else
        {
          testStepFail("", "Wrong parameter value for WritevehicleEquipment function");
        }
      break;
        
    case PRE_SAFE_CURVE_4: //////////////////////// PRE_SAFE_CURVE_4 - Enable/Disable ////////////////////////
      if (bInfo == Disable)
      {
        DiagSetPrimitiveByte(dWriteVehicleEquipmentConfigurationDataRequest, 7, DiagGetPrimitiveByte(dReadVehicleEquipmentConfigurationDataResponse, 7) | 0x01);
        testStep("", " %s is disabled via Vehicle Equipment configuration service", CYCLE[bAttibute].Launch_Name);
      }
      else
        if (bInfo == Enable)
        {
          DiagSetPrimitiveByte(dWriteVehicleEquipmentConfigurationDataRequest, 7, DiagGetPrimitiveByte(dReadVehicleEquipmentConfigurationDataResponse, 7) & 0xFE);
          testStep("", " %s is enabled via Vehicle Equipment configuration service", CYCLE[bAttibute].Launch_Name);
        }
        else
        {
          testStepFail("", "Wrong parameter value for WritevehicleEquipment function");
        }
      break;
        
    case START_UP: //////////////////////// START_UP - Enable/Disable ////////////////////////
      if (bInfo == Disable)
      {
        DiagSetPrimitiveByte(dWriteVehicleEquipmentConfigurationDataRequest, 8, DiagGetPrimitiveByte(dReadVehicleEquipmentConfigurationDataResponse, 8) | 0x02);
        testStep("", " %s is disabled via Vehicle Equipment configuration service", CYCLE[bAttibute].Launch_Name);
      }
      else
        if (bInfo == Enable)
        {
          DiagSetPrimitiveByte(dWriteVehicleEquipmentConfigurationDataRequest, 8, DiagGetPrimitiveByte(dReadVehicleEquipmentConfigurationDataResponse, 8) & 0xFD);
          testStep("", " %s is enabled via Vehicle Equipment configuration service", CYCLE[bAttibute].Launch_Name);
        }
        else
        {
          testStepFail("", "Wrong parameter value for WritevehicleEquipment function");
        }
      break;
    case Release_memory_location:
      if (bInfo == ROM)
      {
        DiagSetPrimitiveByte(dWriteVehicleEquipmentConfigurationDataRequest, 8, DiagGetPrimitiveByte(dReadVehicleEquipmentConfigurationDataResponse, 8) | 0x20);
        testStep("", "Release memory location is set to ROM");
      }
      else
        if (bInfo == EEPROM)
        {
          DiagSetPrimitiveByte(dWriteVehicleEquipmentConfigurationDataRequest, 8, DiagGetPrimitiveByte(dReadVehicleEquipmentConfigurationDataResponse, 8) & 0xDF);
          testStep("", "Release memory location is set to EEPROM");
        }
        else
        {
          testStepFail("", "Wrong parameter value for WritevehicleEquipment function");
        }
      break;
    case BSR_memory_location:
      if (bInfo == ROM)
      {
        DiagSetPrimitiveByte(dWriteVehicleEquipmentConfigurationDataRequest, 8, DiagGetPrimitiveByte(dReadVehicleEquipmentConfigurationDataResponse, 8) | 0x40);
        testStep("", "BSR memory location is set to ROM");
      }
      else
        if (bInfo == EEPROM)
        {
          DiagSetPrimitiveByte(dWriteVehicleEquipmentConfigurationDataRequest, 8, DiagGetPrimitiveByte(dReadVehicleEquipmentConfigurationDataResponse, 8) & 0xBF);
          testStep("", "BSR memory location is set to EEPROM");
        }
        else
        {
          testStepFail("", "Wrong parameter value for WritevehicleEquipment function");
        }
      break;
    case PRESAFE_memory_location:
      if (bInfo == ROM)
      {
        DiagSetPrimitiveByte(dWriteVehicleEquipmentConfigurationDataRequest, 8, DiagGetPrimitiveByte(dReadVehicleEquipmentConfigurationDataResponse, 8) | 0x80);
        testStep("", "PRESAFE memory location is set to ROM");
      }
      else
        if (bInfo == EEPROM)
        {
          DiagSetPrimitiveByte(dWriteVehicleEquipmentConfigurationDataRequest, 8, DiagGetPrimitiveByte(dReadVehicleEquipmentConfigurationDataResponse, 8) & 0x7F);
          testStep("", "PRESAFE memory location is set to EEPROM");
        }
        else
        {
          testStepFail("", "Wrong parameter value for WritevehicleEquipment function");
        }
      break;
    case Undervoltage_Abort_Thrs:
      switch (bInfo)
      {
        case Voltage_7_5:
          DiagSetPrimitiveByte(dWriteVehicleEquipmentConfigurationDataRequest, 11, 0x05);
          DiagSetPrimitiveByte(dWriteVehicleEquipmentConfigurationDataRequest, 12, 0xFB);
          break;
        case Voltage_7_6:
          DiagSetPrimitiveByte(dWriteVehicleEquipmentConfigurationDataRequest, 11, 0x06);
          DiagSetPrimitiveByte(dWriteVehicleEquipmentConfigurationDataRequest, 12, 0x0F);
          break;
        case Voltage_7_7:
          DiagSetPrimitiveByte(dWriteVehicleEquipmentConfigurationDataRequest, 11, 0x06);
          DiagSetPrimitiveByte(dWriteVehicleEquipmentConfigurationDataRequest, 12, 0x23);
          break;
        case Voltage_7_8:
          DiagSetPrimitiveByte(dWriteVehicleEquipmentConfigurationDataRequest, 11, 0x06);
          DiagSetPrimitiveByte(dWriteVehicleEquipmentConfigurationDataRequest, 12, 0x38);
          break;
        case Voltage_7_9:
          DiagSetPrimitiveByte(dWriteVehicleEquipmentConfigurationDataRequest, 11, 0x06);
          DiagSetPrimitiveByte(dWriteVehicleEquipmentConfigurationDataRequest, 12, 0x4C);
          break;
        case Voltage_8_0:
          DiagSetPrimitiveByte(dWriteVehicleEquipmentConfigurationDataRequest, 11, 0x06);
          DiagSetPrimitiveByte(dWriteVehicleEquipmentConfigurationDataRequest, 12, 0x61);
          break;
        case Voltage_8_1:
          DiagSetPrimitiveByte(dWriteVehicleEquipmentConfigurationDataRequest, 11, 0x06);
          DiagSetPrimitiveByte(dWriteVehicleEquipmentConfigurationDataRequest, 12, 0x75);
          break;
        case Voltage_8_2:
          DiagSetPrimitiveByte(dWriteVehicleEquipmentConfigurationDataRequest, 11, 0x06);
          DiagSetPrimitiveByte(dWriteVehicleEquipmentConfigurationDataRequest, 12, 0x89);
          break;
        case Voltage_8_3:
          DiagSetPrimitiveByte(dWriteVehicleEquipmentConfigurationDataRequest, 11, 0x06);
          DiagSetPrimitiveByte(dWriteVehicleEquipmentConfigurationDataRequest, 12, 0x9E);
          break;
        case Voltage_8_4:
          DiagSetPrimitiveByte(dWriteVehicleEquipmentConfigurationDataRequest, 11, 0x06);
          DiagSetPrimitiveByte(dWriteVehicleEquipmentConfigurationDataRequest, 12, 0xB2);
          break;
        case Voltage_8_5:
          DiagSetPrimitiveByte(dWriteVehicleEquipmentConfigurationDataRequest, 11, 0x06);
          DiagSetPrimitiveByte(dWriteVehicleEquipmentConfigurationDataRequest, 12, 0xC7);
          break;
        case Voltage_8_6:
          DiagSetPrimitiveByte(dWriteVehicleEquipmentConfigurationDataRequest, 11, 0x06);
          DiagSetPrimitiveByte(dWriteVehicleEquipmentConfigurationDataRequest, 12, 0xDB);
          break;
        case Voltage_8_7:
          DiagSetPrimitiveByte(dWriteVehicleEquipmentConfigurationDataRequest, 11, 0x06);
          DiagSetPrimitiveByte(dWriteVehicleEquipmentConfigurationDataRequest, 12, 0xEF);
          break;
        case Voltage_8_8:
          DiagSetPrimitiveByte(dWriteVehicleEquipmentConfigurationDataRequest, 11, 0x07);
          DiagSetPrimitiveByte(dWriteVehicleEquipmentConfigurationDataRequest, 12, 0x04);
          break;
        case Voltage_8_9:
          DiagSetPrimitiveByte(dWriteVehicleEquipmentConfigurationDataRequest, 11, 0x07);
          DiagSetPrimitiveByte(dWriteVehicleEquipmentConfigurationDataRequest, 12, 0x18);
          break;
        case Voltage_9_0:
          DiagSetPrimitiveByte(dWriteVehicleEquipmentConfigurationDataRequest, 11, 0x07);
          DiagSetPrimitiveByte(dWriteVehicleEquipmentConfigurationDataRequest, 12, 0x2D);
          break;
        case Voltage_9_1:
          DiagSetPrimitiveByte(dWriteVehicleEquipmentConfigurationDataRequest, 11, 0x07);
          DiagSetPrimitiveByte(dWriteVehicleEquipmentConfigurationDataRequest, 12, 0x41);
          break;
        case Voltage_9_2:
          DiagSetPrimitiveByte(dWriteVehicleEquipmentConfigurationDataRequest, 11, 0x07);
          DiagSetPrimitiveByte(dWriteVehicleEquipmentConfigurationDataRequest, 12, 0x56);
          break;
        case Voltage_9_3:
          DiagSetPrimitiveByte(dWriteVehicleEquipmentConfigurationDataRequest, 11, 0x07);
          DiagSetPrimitiveByte(dWriteVehicleEquipmentConfigurationDataRequest, 12, 0x6A);
          break;
        case Voltage_9_4:
          DiagSetPrimitiveByte(dWriteVehicleEquipmentConfigurationDataRequest, 11, 0x07);
          DiagSetPrimitiveByte(dWriteVehicleEquipmentConfigurationDataRequest, 12, 0x7E);
          break;
        case Voltage_9_5:
          DiagSetPrimitiveByte(dWriteVehicleEquipmentConfigurationDataRequest, 11, 0x07);
          DiagSetPrimitiveByte(dWriteVehicleEquipmentConfigurationDataRequest, 12, 0x93);
          break;
        case Voltage_9_6:
          DiagSetPrimitiveByte(dWriteVehicleEquipmentConfigurationDataRequest, 11, 0x07);
          DiagSetPrimitiveByte(dWriteVehicleEquipmentConfigurationDataRequest, 12, 0xA7);
          break;
        case Voltage_9_7:
          DiagSetPrimitiveByte(dWriteVehicleEquipmentConfigurationDataRequest, 11, 0x07);
          DiagSetPrimitiveByte(dWriteVehicleEquipmentConfigurationDataRequest, 12, 0xBC);
          break;
        case Voltage_9_8:
          DiagSetPrimitiveByte(dWriteVehicleEquipmentConfigurationDataRequest, 11, 0x07);
          DiagSetPrimitiveByte(dWriteVehicleEquipmentConfigurationDataRequest, 12, 0xD0);
          break;
        case Voltage_9_9:
          DiagSetPrimitiveByte(dWriteVehicleEquipmentConfigurationDataRequest, 11, 0x07);
          DiagSetPrimitiveByte(dWriteVehicleEquipmentConfigurationDataRequest, 12, 0xE4);
          break;
        case Voltage_10_0:
          DiagSetPrimitiveByte(dWriteVehicleEquipmentConfigurationDataRequest, 11, 0x07);
          DiagSetPrimitiveByte(dWriteVehicleEquipmentConfigurationDataRequest, 12, 0xF9);
          break;
      }
      break;  
    case Undervoltage_Thrs:
      switch (bInfo)
      {
        case Voltage_7_5:
          DiagSetPrimitiveByte(dWriteVehicleEquipmentConfigurationDataRequest, 13, 0x05);
          DiagSetPrimitiveByte(dWriteVehicleEquipmentConfigurationDataRequest, 14, 0xFB);
          break;
        case Voltage_7_6:
          DiagSetPrimitiveByte(dWriteVehicleEquipmentConfigurationDataRequest, 13, 0x06);
          DiagSetPrimitiveByte(dWriteVehicleEquipmentConfigurationDataRequest, 14, 0x0F);
          break;
        case Voltage_7_7:
          DiagSetPrimitiveByte(dWriteVehicleEquipmentConfigurationDataRequest, 13, 0x06);
          DiagSetPrimitiveByte(dWriteVehicleEquipmentConfigurationDataRequest, 14, 0x23);
          break;
        case Voltage_7_8:
          DiagSetPrimitiveByte(dWriteVehicleEquipmentConfigurationDataRequest, 13, 0x06);
          DiagSetPrimitiveByte(dWriteVehicleEquipmentConfigurationDataRequest, 14, 0x38);
          break;
        case Voltage_7_9:
          DiagSetPrimitiveByte(dWriteVehicleEquipmentConfigurationDataRequest, 13, 0x06);
          DiagSetPrimitiveByte(dWriteVehicleEquipmentConfigurationDataRequest, 14, 0x4C);
          break;
        case Voltage_8_0:
          DiagSetPrimitiveByte(dWriteVehicleEquipmentConfigurationDataRequest, 13, 0x06);
          DiagSetPrimitiveByte(dWriteVehicleEquipmentConfigurationDataRequest, 14, 0x61);
          break;
        case Voltage_8_1:
          DiagSetPrimitiveByte(dWriteVehicleEquipmentConfigurationDataRequest, 13, 0x06);
          DiagSetPrimitiveByte(dWriteVehicleEquipmentConfigurationDataRequest, 14, 0x75);
          break;
        case Voltage_8_2:
          DiagSetPrimitiveByte(dWriteVehicleEquipmentConfigurationDataRequest, 13, 0x06);
          DiagSetPrimitiveByte(dWriteVehicleEquipmentConfigurationDataRequest, 14, 0x89);
          break;
        case Voltage_8_3:
          DiagSetPrimitiveByte(dWriteVehicleEquipmentConfigurationDataRequest, 13, 0x06);
          DiagSetPrimitiveByte(dWriteVehicleEquipmentConfigurationDataRequest, 14, 0x9E);
          break;
        case Voltage_8_4:
          DiagSetPrimitiveByte(dWriteVehicleEquipmentConfigurationDataRequest, 13, 0x06);
          DiagSetPrimitiveByte(dWriteVehicleEquipmentConfigurationDataRequest, 14, 0xB2);
          break;
        case Voltage_8_5:
          DiagSetPrimitiveByte(dWriteVehicleEquipmentConfigurationDataRequest, 13, 0x06);
          DiagSetPrimitiveByte(dWriteVehicleEquipmentConfigurationDataRequest, 14, 0xC7);
          break;
        case Voltage_8_6:
          DiagSetPrimitiveByte(dWriteVehicleEquipmentConfigurationDataRequest, 13, 0x06);
          DiagSetPrimitiveByte(dWriteVehicleEquipmentConfigurationDataRequest, 14, 0xDB);
          break;
        case Voltage_8_7:
          DiagSetPrimitiveByte(dWriteVehicleEquipmentConfigurationDataRequest, 13, 0x06);
          DiagSetPrimitiveByte(dWriteVehicleEquipmentConfigurationDataRequest, 14, 0xEF);
          break;
        case Voltage_8_8:
          DiagSetPrimitiveByte(dWriteVehicleEquipmentConfigurationDataRequest, 13, 0x07);
          DiagSetPrimitiveByte(dWriteVehicleEquipmentConfigurationDataRequest, 14, 0x04);
          break;
        case Voltage_8_9:
          DiagSetPrimitiveByte(dWriteVehicleEquipmentConfigurationDataRequest, 13, 0x07);
          DiagSetPrimitiveByte(dWriteVehicleEquipmentConfigurationDataRequest, 14, 0x18);
          break;
        case Voltage_9_0:
          DiagSetPrimitiveByte(dWriteVehicleEquipmentConfigurationDataRequest, 13, 0x07);
          DiagSetPrimitiveByte(dWriteVehicleEquipmentConfigurationDataRequest, 14, 0x2D);
          break;
        case Voltage_9_1:
          DiagSetPrimitiveByte(dWriteVehicleEquipmentConfigurationDataRequest, 13, 0x07);
          DiagSetPrimitiveByte(dWriteVehicleEquipmentConfigurationDataRequest, 14, 0x41);
          break;
        case Voltage_9_2:
          DiagSetPrimitiveByte(dWriteVehicleEquipmentConfigurationDataRequest, 13, 0x07);
          DiagSetPrimitiveByte(dWriteVehicleEquipmentConfigurationDataRequest, 14, 0x56);
          break;
        case Voltage_9_3:
          DiagSetPrimitiveByte(dWriteVehicleEquipmentConfigurationDataRequest, 13, 0x07);
          DiagSetPrimitiveByte(dWriteVehicleEquipmentConfigurationDataRequest, 14, 0x6A);
          break;
        case Voltage_9_4:
          DiagSetPrimitiveByte(dWriteVehicleEquipmentConfigurationDataRequest, 13, 0x07);
          DiagSetPrimitiveByte(dWriteVehicleEquipmentConfigurationDataRequest, 14, 0x7E);
          break;
        case Voltage_9_5:
          DiagSetPrimitiveByte(dWriteVehicleEquipmentConfigurationDataRequest, 13, 0x07);
          DiagSetPrimitiveByte(dWriteVehicleEquipmentConfigurationDataRequest, 14, 0x93);
          break;
        case Voltage_9_6:
          DiagSetPrimitiveByte(dWriteVehicleEquipmentConfigurationDataRequest, 13, 0x07);
          DiagSetPrimitiveByte(dWriteVehicleEquipmentConfigurationDataRequest, 14, 0xA7);
          break;
        case Voltage_9_7:
          DiagSetPrimitiveByte(dWriteVehicleEquipmentConfigurationDataRequest, 13, 0x07);
          DiagSetPrimitiveByte(dWriteVehicleEquipmentConfigurationDataRequest, 14, 0xBC);
          break;
        case Voltage_9_8:
          DiagSetPrimitiveByte(dWriteVehicleEquipmentConfigurationDataRequest, 13, 0x07);
          DiagSetPrimitiveByte(dWriteVehicleEquipmentConfigurationDataRequest, 14, 0xD0);
          break;
        case Voltage_9_9:
          DiagSetPrimitiveByte(dWriteVehicleEquipmentConfigurationDataRequest, 13, 0x07);
          DiagSetPrimitiveByte(dWriteVehicleEquipmentConfigurationDataRequest, 14, 0xE4);
          break;
        case Voltage_10_0:
          DiagSetPrimitiveByte(dWriteVehicleEquipmentConfigurationDataRequest, 13, 0x07);
          DiagSetPrimitiveByte(dWriteVehicleEquipmentConfigurationDataRequest, 14, 0xF9);
          break;
      }
      break;  
    case Overvoltage_Thrs:
      switch (bInfo)
      {
        case Voltage_16_0:
          DiagSetPrimitiveByte(dWriteVehicleEquipmentConfigurationDataRequest, 15, 0x0C);
          DiagSetPrimitiveByte(dWriteVehicleEquipmentConfigurationDataRequest, 16, 0xC2);
          break;
        case Voltage_16_1:
          DiagSetPrimitiveByte(dWriteVehicleEquipmentConfigurationDataRequest, 15, 0x0C);
          DiagSetPrimitiveByte(dWriteVehicleEquipmentConfigurationDataRequest, 16, 0xD6);
          break;
        case Voltage_16_2:
          DiagSetPrimitiveByte(dWriteVehicleEquipmentConfigurationDataRequest, 15, 0x0C);
          DiagSetPrimitiveByte(dWriteVehicleEquipmentConfigurationDataRequest, 16, 0xEB);
          break;
        case Voltage_16_3:
          DiagSetPrimitiveByte(dWriteVehicleEquipmentConfigurationDataRequest, 15, 0x0C);
          DiagSetPrimitiveByte(dWriteVehicleEquipmentConfigurationDataRequest, 16, 0xFF);
          break;
        case Voltage_16_4:
          DiagSetPrimitiveByte(dWriteVehicleEquipmentConfigurationDataRequest, 15, 0x0D);
          DiagSetPrimitiveByte(dWriteVehicleEquipmentConfigurationDataRequest, 16, 0x13);
          break;
        case Voltage_16_5:
          DiagSetPrimitiveByte(dWriteVehicleEquipmentConfigurationDataRequest, 15, 0x0D);
          DiagSetPrimitiveByte(dWriteVehicleEquipmentConfigurationDataRequest, 16, 0x28);
          break;
        case Voltage_16_6:
          DiagSetPrimitiveByte(dWriteVehicleEquipmentConfigurationDataRequest, 15, 0x0D);
          DiagSetPrimitiveByte(dWriteVehicleEquipmentConfigurationDataRequest, 16, 0x3C);
          break;
        case Voltage_16_7:
          DiagSetPrimitiveByte(dWriteVehicleEquipmentConfigurationDataRequest, 15, 0x0D);
          DiagSetPrimitiveByte(dWriteVehicleEquipmentConfigurationDataRequest, 16, 0x51);
          break;
        case Voltage_16_8:
          DiagSetPrimitiveByte(dWriteVehicleEquipmentConfigurationDataRequest, 15, 0x0D);
          DiagSetPrimitiveByte(dWriteVehicleEquipmentConfigurationDataRequest, 16, 0x65);
          break;
        case Voltage_16_9:
          DiagSetPrimitiveByte(dWriteVehicleEquipmentConfigurationDataRequest, 15, 0x0D);
          DiagSetPrimitiveByte(dWriteVehicleEquipmentConfigurationDataRequest, 16, 0x79);
          break;
        case Voltage_17_0:
          DiagSetPrimitiveByte(dWriteVehicleEquipmentConfigurationDataRequest, 15, 0x0D);
          DiagSetPrimitiveByte(dWriteVehicleEquipmentConfigurationDataRequest, 16, 0x8E);
          break;
        case Voltage_17_1:
          DiagSetPrimitiveByte(dWriteVehicleEquipmentConfigurationDataRequest, 15, 0x0D);
          DiagSetPrimitiveByte(dWriteVehicleEquipmentConfigurationDataRequest, 16, 0xA2);
          break;
        case Voltage_17_2:
          DiagSetPrimitiveByte(dWriteVehicleEquipmentConfigurationDataRequest, 15, 0x0D);
          DiagSetPrimitiveByte(dWriteVehicleEquipmentConfigurationDataRequest, 16, 0xB7);
          break;
        case Voltage_17_3:
          DiagSetPrimitiveByte(dWriteVehicleEquipmentConfigurationDataRequest, 15, 0x0D);
          DiagSetPrimitiveByte(dWriteVehicleEquipmentConfigurationDataRequest, 16, 0xCB);
          break;
        case Voltage_17_4:
          DiagSetPrimitiveByte(dWriteVehicleEquipmentConfigurationDataRequest, 15, 0x0D);
          DiagSetPrimitiveByte(dWriteVehicleEquipmentConfigurationDataRequest, 16, 0xDF);
          break;
        case Voltage_17_5:
          DiagSetPrimitiveByte(dWriteVehicleEquipmentConfigurationDataRequest, 15, 0x0D);
          DiagSetPrimitiveByte(dWriteVehicleEquipmentConfigurationDataRequest, 16, 0xF4);
          break;
        case Voltage_17_6:
          DiagSetPrimitiveByte(dWriteVehicleEquipmentConfigurationDataRequest, 15, 0x0E);
          DiagSetPrimitiveByte(dWriteVehicleEquipmentConfigurationDataRequest, 16, 0x08);
          break;
        case Voltage_17_7:
          DiagSetPrimitiveByte(dWriteVehicleEquipmentConfigurationDataRequest, 15, 0x0E);
          DiagSetPrimitiveByte(dWriteVehicleEquipmentConfigurationDataRequest, 16, 0x1D);
          break;
        case Voltage_17_8:
          DiagSetPrimitiveByte(dWriteVehicleEquipmentConfigurationDataRequest, 15, 0x0E);
          DiagSetPrimitiveByte(dWriteVehicleEquipmentConfigurationDataRequest, 16, 0x31);
          break;
        case Voltage_17_9:
          DiagSetPrimitiveByte(dWriteVehicleEquipmentConfigurationDataRequest, 15, 0x0E);
          DiagSetPrimitiveByte(dWriteVehicleEquipmentConfigurationDataRequest, 16, 0x46);
          break;
        case Voltage_18_0:
          DiagSetPrimitiveByte(dWriteVehicleEquipmentConfigurationDataRequest, 15, 0x0E);
          DiagSetPrimitiveByte(dWriteVehicleEquipmentConfigurationDataRequest, 16, 0x5A);
          break;
      }
      break;
    case Overvoltage_Abort_Thrs:
      switch (bInfo)
      {
        case Voltage_16_0:
          DiagSetPrimitiveByte(dWriteVehicleEquipmentConfigurationDataRequest, 17, 0x0C);
          DiagSetPrimitiveByte(dWriteVehicleEquipmentConfigurationDataRequest, 18, 0xC2);
          break;
        case Voltage_16_1:
          DiagSetPrimitiveByte(dWriteVehicleEquipmentConfigurationDataRequest, 17, 0x0C);
          DiagSetPrimitiveByte(dWriteVehicleEquipmentConfigurationDataRequest, 18, 0xD6);
          break;
        case Voltage_16_2:
          DiagSetPrimitiveByte(dWriteVehicleEquipmentConfigurationDataRequest, 17, 0x0C);
          DiagSetPrimitiveByte(dWriteVehicleEquipmentConfigurationDataRequest, 18, 0xEB);
          break;
        case Voltage_16_3:
          DiagSetPrimitiveByte(dWriteVehicleEquipmentConfigurationDataRequest, 17, 0x0C);
          DiagSetPrimitiveByte(dWriteVehicleEquipmentConfigurationDataRequest, 18, 0xFF);
          break;
        case Voltage_16_4:
          DiagSetPrimitiveByte(dWriteVehicleEquipmentConfigurationDataRequest, 17, 0x0D);
          DiagSetPrimitiveByte(dWriteVehicleEquipmentConfigurationDataRequest, 18, 0x13);
          break;
        case Voltage_16_5:
          DiagSetPrimitiveByte(dWriteVehicleEquipmentConfigurationDataRequest, 17, 0x0D);
          DiagSetPrimitiveByte(dWriteVehicleEquipmentConfigurationDataRequest, 18, 0x28);
          break;
        case Voltage_16_6:
          DiagSetPrimitiveByte(dWriteVehicleEquipmentConfigurationDataRequest, 17, 0x0D);
          DiagSetPrimitiveByte(dWriteVehicleEquipmentConfigurationDataRequest, 18, 0x3C);
          break;
        case Voltage_16_7:
          DiagSetPrimitiveByte(dWriteVehicleEquipmentConfigurationDataRequest, 17, 0x0D);
          DiagSetPrimitiveByte(dWriteVehicleEquipmentConfigurationDataRequest, 18, 0x51);
          break;
        case Voltage_16_8:
          DiagSetPrimitiveByte(dWriteVehicleEquipmentConfigurationDataRequest, 17, 0x0D);
          DiagSetPrimitiveByte(dWriteVehicleEquipmentConfigurationDataRequest, 18, 0x65);
          break;
        case Voltage_16_9:
          DiagSetPrimitiveByte(dWriteVehicleEquipmentConfigurationDataRequest, 17, 0x0D);
          DiagSetPrimitiveByte(dWriteVehicleEquipmentConfigurationDataRequest, 18, 0x79);
          break;
        case Voltage_17_0:
          DiagSetPrimitiveByte(dWriteVehicleEquipmentConfigurationDataRequest, 17, 0x0D);
          DiagSetPrimitiveByte(dWriteVehicleEquipmentConfigurationDataRequest, 18, 0x8E);
          break;
        case Voltage_17_1:
          DiagSetPrimitiveByte(dWriteVehicleEquipmentConfigurationDataRequest, 17, 0x0D);
          DiagSetPrimitiveByte(dWriteVehicleEquipmentConfigurationDataRequest, 18, 0xA2);
          break;
        case Voltage_17_2:
          DiagSetPrimitiveByte(dWriteVehicleEquipmentConfigurationDataRequest, 17, 0x0D);
          DiagSetPrimitiveByte(dWriteVehicleEquipmentConfigurationDataRequest, 18, 0xB7);
          break;
        case Voltage_17_3:
          DiagSetPrimitiveByte(dWriteVehicleEquipmentConfigurationDataRequest, 17, 0x0D);
          DiagSetPrimitiveByte(dWriteVehicleEquipmentConfigurationDataRequest, 18, 0xCB);
          break;
        case Voltage_17_4:
          DiagSetPrimitiveByte(dWriteVehicleEquipmentConfigurationDataRequest, 17, 0x0D);
          DiagSetPrimitiveByte(dWriteVehicleEquipmentConfigurationDataRequest, 18, 0xDF);
          break;
        case Voltage_17_5:
          DiagSetPrimitiveByte(dWriteVehicleEquipmentConfigurationDataRequest, 17, 0x0D);
          DiagSetPrimitiveByte(dWriteVehicleEquipmentConfigurationDataRequest, 18, 0xF4);
          break;
        case Voltage_17_6:
          DiagSetPrimitiveByte(dWriteVehicleEquipmentConfigurationDataRequest, 17, 0x0E);
          DiagSetPrimitiveByte(dWriteVehicleEquipmentConfigurationDataRequest, 18, 0x08);
          break;
        case Voltage_17_7:
          DiagSetPrimitiveByte(dWriteVehicleEquipmentConfigurationDataRequest, 17, 0x0E);
          DiagSetPrimitiveByte(dWriteVehicleEquipmentConfigurationDataRequest, 18, 0x1D);
          break;
        case Voltage_17_8:
          DiagSetPrimitiveByte(dWriteVehicleEquipmentConfigurationDataRequest, 17, 0x0E);
          DiagSetPrimitiveByte(dWriteVehicleEquipmentConfigurationDataRequest, 18, 0x31);
          break;
        case Voltage_17_9:
          DiagSetPrimitiveByte(dWriteVehicleEquipmentConfigurationDataRequest, 17, 0x0E);
          DiagSetPrimitiveByte(dWriteVehicleEquipmentConfigurationDataRequest, 18, 0x46);
          break;
        case Voltage_18_0:
          DiagSetPrimitiveByte(dWriteVehicleEquipmentConfigurationDataRequest, 17, 0x0E);
          DiagSetPrimitiveByte(dWriteVehicleEquipmentConfigurationDataRequest, 18, 0x5A);
          break;

      }
      break;      

    default:
      diagSetPrimitiveData(dWriteVehicleEquipmentConfigurationDataRequest, bVehicleEquipmentData, elcount(bVehicleEquipmentData));
      testStep("", "Set Equipment Configuration Data to default");
      break;
          
  }   
  
  testStep("", "Start variant coding sequence");  
  SecVarCoding_Start();
  Wait(2000);
    
  testStep("", "Send Write Vehicle Equipment Configuration Data diagnostic service request with new values");
  SendDiagnosticRequest(dWriteVehicleEquipmentConfigurationDataRequest, dWriteVehicleEquipmentConfigurationDataResponse);
  CheckPositiveResponse("Check positive response of Write Vehicle Equipment Configuration Data diagnostic service.", dWriteVehicleEquipmentConfigurationDataRequest, dWriteVehicleEquipmentConfigurationDataResponse);
  Wait(1000);
  
  testStep("", "Stop variant coding sequence");  
  SecVarCoding_Finish();
  
  testStep("", "Stop variant coding sequence"); 
  wait(2000);
  ResetECU("soft");
  WaitECUInitialization();
  
  testStep("", "Authenticate ECU");
  AuthenticateECU(2);
  EnterDiagnosticSession("development");
  
  testStep("", "Read Vehicle Equipment Configuration Data");
  SendDiagnosticRequest(dReadVehicleEquipmentConfigurationDataRequest, dReadVehicleEquipmentConfigurationDataResponse);
  CheckPositiveResponse("Check positive response of the Read Vehicle Equipment Configuration Data", dReadVehicleEquipmentConfigurationDataRequest, dReadVehicleEquipmentConfigurationDataResponse);
  testReportWriteDiagResponse(dReadVehicleEquipmentConfigurationDataRequest);
  
}

/// <Vehicle_configuration>
//// Write default vehicle equipment development data with service 0x2E 0x03 0x11  
//// Example:      WriteVehicleEquipmentDevelopment()
void WriteVehicleEquipmentDevelopment()
{
  WriteVehicleEquipmentDevelopment(0xFF, 0xFF);
}

/// <Vehicle_configuration>
//// Used for configuring the vehicle equipment development data with service 0x2E 0x03 0x11  
//// bAttibute - PRE_SAFE_1 - PRE_SAFE_15, HAPTIC_WARNING1 - HAPTIC_WARNING4, BSR_1 - BSR_3, PRE_SAFE_CURVE_1 - PRE_SAFE_CURVE_4
//// bInfo - Enable/Disable/Enable_ORC(PRE_SAFE_8 only)/Disable_ORC(PRE_SAFE_8 only)
//// Example:      WriteVehicleEquipmentDevelopment(PRESAFE, Disable/Enable) 
////               WriteVehicleEquipmentDevelopment(Display, Disable/Enable) 
////               WriteVehicleEquipmentDevelopment(Counter, Disable/Enable) 
////               WriteVehicleEquipmentDevelopment(CRC_VEH, Disable/Enable) 
void WriteVehicleEquipmentDevelopment(byte bAttibute, byte bInfo)
{
  byte bVehicleEquipmentDevelopmentData[6] = {0x2E, 0x03, 0x11, 0xFF, 0x00, 0x0A};
  byte bResponse[6];
  
  testStep("", "Authenticate ECU");
  AuthenticateECU(2);
  EnterDiagnosticSession("development");
  
  testStep("", "Read Vehicle Equipment Development Data");
  SendDiagnosticRequest(dReadVehicleEquipmentDevelopmentDataRequest, dReadVehicleEquipmentDevelopmentDataResponse);
  CheckPositiveResponse("Check positive response of the Read Vehicle Equipment Development Data", dReadVehicleEquipmentDevelopmentDataRequest, dReadVehicleEquipmentDevelopmentDataResponse);
  testReportWriteDiagResponse(dReadVehicleEquipmentDevelopmentDataRequest);
  
  diagGetPrimitiveData(dReadVehicleEquipmentDevelopmentDataResponse, bResponse, elcount(bResponse));
  
  diagResize(dWriteVehicleEquipmentDevelopmentDataRequest, 6);
  diagSetPrimitiveData(dWriteVehicleEquipmentDevelopmentDataRequest, bResponse, elcount(bResponse));
  DiagSetPrimitiveByte(dWriteVehicleEquipmentDevelopmentDataRequest, 0, 0x2E);
  DiagSetPrimitiveByte(dWriteVehicleEquipmentDevelopmentDataRequest, 1, 0x03);
  DiagSetPrimitiveByte(dWriteVehicleEquipmentDevelopmentDataRequest, 2, 0x11);
  DiagSetPrimitiveByte(dWriteVehicleEquipmentDevelopmentDataRequest, 3, 0xFF);
  DiagSetPrimitiveByte(dWriteVehicleEquipmentDevelopmentDataRequest, 4, 0x00);
  DiagSetPrimitiveByte(dWriteVehicleEquipmentDevelopmentDataRequest, 5, 0x0A);
  switch (bAttibute)
  {
    case PRESAFE: //////////////////////// PRE_SAFE_1 - Enable/Disable ////////////////////////
      if (bInfo == Disable)
      {
        DiagSetPrimitiveByte(dWriteVehicleEquipmentDevelopmentDataRequest, 4, DiagGetPrimitiveByte(dReadVehicleEquipmentDevelopmentDataResponse, 4) | 0x01);
        testStep("", "PRESAFE is disabled via Vehicle Equipment Development service");
      }
      else
        if (bInfo == Enable)
        {
          DiagSetPrimitiveByte(dWriteVehicleEquipmentDevelopmentDataRequest, 4, DiagGetPrimitiveByte(dReadVehicleEquipmentDevelopmentDataResponse, 4) & 0xFE);
          testStep("", "PRESAFE is Enabled via Vehicle Equipment Development service");
        }
        else
        {
          testStepFail("", "Wrong parameter value for Write Vehicle Equipment Development function");
        }
      break;
        
    case Display: //////////////////////// Disaplay message - Enable/Disable ////////////////////////
      if (bInfo == Disable)
      {
        DiagSetPrimitiveByte(dWriteVehicleEquipmentDevelopmentDataRequest, 4, DiagGetPrimitiveByte(dReadVehicleEquipmentDevelopmentDataResponse, 4) | 0x02);
        testStep("", "Disaplay message is disabled via Vehicle Equipment Development service");
      }
      else
        if (bInfo == Enable)
        {
          DiagSetPrimitiveByte(dWriteVehicleEquipmentDevelopmentDataRequest, 4, DiagGetPrimitiveByte(dReadVehicleEquipmentDevelopmentDataResponse, 4) & 0xFD);
          testStep("", "Disaplay message is Enabled via Vehicle Equipment Development service");
        }
        else
        {
          testStepFail("", "Wrong parameter value for Write Vehicle Equipment Development function");
        }
      break;
        
    case Counter: //////////////////////// Counter limitation - Enable/Disable ////////////////////////
      if (bInfo == Disable)
      {
        DiagSetPrimitiveByte(dWriteVehicleEquipmentDevelopmentDataRequest, 4, DiagGetPrimitiveByte(dReadVehicleEquipmentDevelopmentDataResponse, 4) | 0x04);
        testStep("", "Counter limitation is disabled via Vehicle Equipment Development service");
      }
      else
        if (bInfo == Enable)
        {
          DiagSetPrimitiveByte(dWriteVehicleEquipmentDevelopmentDataRequest, 4, DiagGetPrimitiveByte(dReadVehicleEquipmentDevelopmentDataResponse, 4) & 0xFB);
          testStep("", "Counter limitation is Enabled via Vehicle Equipment Development service");
        }
        else
        {
          testStepFail("", "Wrong parameter value for Write Vehicle Equipment Development function");
        }
      break;
        
    case CRC_VEH: //////////////////////// CRC fault - Enable/Disable ////////////////////////
      if (bInfo == Disable)
      {
        DiagSetPrimitiveByte(dWriteVehicleEquipmentDevelopmentDataRequest, 4, DiagGetPrimitiveByte(dReadVehicleEquipmentDevelopmentDataResponse, 4) | 0x08);
        testStep("", "CRC fault monitoring is disabled via Vehicle Equipment Development service");
      }
      else
        if (bInfo == Enable)
        {
          DiagSetPrimitiveByte(dWriteVehicleEquipmentDevelopmentDataRequest, 4, DiagGetPrimitiveByte(dReadVehicleEquipmentDevelopmentDataResponse, 4) & 0xF7);
          testStep("", "CRC fault monitoring is Enabled via Vehicle Equipment Development service");
        }
        else
        {
          testStepFail("", "Wrong parameter value for Write Vehicle Equipment Development function");
        }
      break;
        
    default:
          diagSetPrimitiveData( dWriteVehicleEquipmentDevelopmentDataRequest, bVehicleEquipmentDevelopmentData, elcount(bVehicleEquipmentDevelopmentData));
        break;
        
  }

  testStep("", "Start variant coding sequence");  
  SecVarCoding_Start();
  Wait(2000);
    
  testStep("", "Send Write Vehicle Equipment Configuration Data diagnostic service request with new values");
  SendDiagnosticRequest(dWriteVehicleEquipmentDevelopmentDataRequest, dWriteVehicleEquipmentDevelopmentDataResponse);
  CheckPositiveResponse("Check positive response of Write Vehicle Equipment Configuration Data diagnostic service.", dWriteVehicleEquipmentDevelopmentDataRequest, dWriteVehicleEquipmentDevelopmentDataResponse);
  Wait(2000);
  
  testStep("", "Stop variant coding sequence");  
  SecVarCoding_Finish();
  wait(2000);  
  
  testStep("", "Stop variant coding sequence"); 
  ResetECU("soft");
  WaitECUInitialization();
  
  testStep("", "Authenticate ECU");
  AuthenticateECU(2);
  EnterDiagnosticSession("development");
  
  testStep("", "Read Vehicle Equipment Development Data");
  SendDiagnosticRequest(dReadVehicleEquipmentDevelopmentDataRequest, dReadVehicleEquipmentDevelopmentDataResponse);
  CheckPositiveResponse("Check positive response of the Read Vehicle Equipment Development Data", dReadVehicleEquipmentDevelopmentDataRequest, dReadVehicleEquipmentDevelopmentDataResponse);
  testReportWriteDiagResponse(dReadVehicleEquipmentDevelopmentDataRequest);
  

}

/// <Vehicle_configuration/_0x0301>
void WriteReleaseProfileConfiguration()
{
  testStep(@sysvar::CORE::sysLevelOfDetailStep, "", "Authenticate ECU");
  AuthenticateECU(2);
  EnterDiagnosticSession("development");
  
  testStep(@sysvar::CORE::sysLevelOfDetailStep, "", "Read Release profiles configuration diagnostic service (0x0301).");
  SendDiagnosticRequest(dReadReleaseProfileConfigurationRequest, dReadReleaseProfileConfigurationResponse);
  CheckPositiveResponse("Check positive response of the Read Release profiles configuration diagnostic request.", dReadReleaseProfileConfigurationRequest, dReadReleaseProfileConfigurationResponse);
  testReportWriteDiagResponse(dReadReleaseProfileConfigurationRequest);
  
//  memcpy_off(bReleaseProfilesConfiguration, 3, bDefaultCycleValues, (12 * 29), (12 * 4));
//  memcpy_off(bReleaseProfilesConfiguration, (3 + 12 * 4), bDefaultStepsLibrary, (8 * 116), 96);
  
//  // Configure diagnostic object.
//  if(diagResize(dReleaseProfileConfigurationWriteRequest, elcount(bReleaseProfilesConfiguration)) < 0)
//  {
//    testStepFail(@sysvar::CORE::sysLevelOfDetailFail, "" ,"WriteReleaseProfileConfiguration: Error when creating diagnostic object.");
//    return;
//  }
//  
//  if(diagSetPrimitiveData(dReleaseProfileConfigurationWriteRequest, bReleaseProfilesConfiguration, elcount(bReleaseProfilesConfiguration)) < 0)
//  {
//    testStepFail(@sysvar::CORE::sysLevelOfDetailFail, "" ,"WriteReleaseProfileConfiguration: Error when creating diagnostic object.");
//    return;
//  }
  
  testStep(@sysvar::CORE::sysLevelOfDetailStep, "", "Start variant coding sequence");
  SecVarCoding_Start();
  Wait(1000);
  
  // Diag Error Handling.
  if(SendDiagnosticRequest(dReleaseProfileConfigurationWriteRequest, dReleaseProfileConfigurationWriteResponse, bReleaseProfilesConfiguration) == DIAG_SEND_OR_RECEIVE_ERROR) 
  {
    testStepFail(@sysvar::CORE::sysLevelOfDetailFail, "" ,"WriteReleaseProfileConfiguration: Diagnostic request send or receive error.");
  }
  
  // Diag Error Handling.
  if (diagIsPositiveResponse(dReleaseProfileConfigurationWriteResponse) == 0)
  {
    testStepFail(@sysvar::CORE::sysLevelOfDetailFail, "", "WriteReleaseProfileConfiguration: Negative response received for WriteReleaseProfileConfiguration: [0x%X].", dReleaseProfileConfigurationWriteResponse.GetResponseCode());
    testReportWriteDiagResponse(dReleaseProfileConfigurationWriteRequest);
  }
  
  testStep(@sysvar::CORE::sysLevelOfDetailStep, "", "Stop variant coding sequence");
  SecVarCoding_Finish();
  Wait(2000);
  
  testStep(@sysvar::CORE::sysLevelOfDetailStep, "", "Soft reset ECU");
  ResetECU("soft");
  WaitECUInitialization();
  
  testStep(@sysvar::CORE::sysLevelOfDetailStep, "", "Authenticate ECU");
  AuthenticateECU(2);
  EnterDiagnosticSession("development");
  
  testStep(@sysvar::CORE::sysLevelOfDetailStep, "", "Read Release profiles configuration diagnostic service (0x0301).");
  SendDiagnosticRequest(dReadReleaseProfileConfigurationRequest, dReadReleaseProfileConfigurationResponse);
  CheckPositiveResponse("Check positive response of the Read Release profiles configuration diagnostic request.", dReadReleaseProfileConfigurationRequest, dReadReleaseProfileConfigurationResponse);
  testReportWriteDiagResponse(dReadReleaseProfileConfigurationRequest);
}

//// Write BSR cycles configuration with default values  
//// bAttibute - 
//// bInfo - see below
//// Example:      WriteBSRProfileConfiguration();
/// <Vehicle_configuration/_0x0302>
void WriteBSRProfileConfiguration()
{
  testStep(@sysvar::CORE::sysLevelOfDetailStep, "", "Authenticate ECU");
  AuthenticateECU(2);
  EnterDiagnosticSession("development");
  
  testStep(@sysvar::CORE::sysLevelOfDetailStep, "", "Read BSR profiles configuration diagnostic service (0x0302).");
  SendDiagnosticRequest(dReadBSRProfileConfigurationRequest, dReadBSRProfileConfigurationResponse);
  CheckPositiveResponse("Check positive response of the Read BSR profiles configuration diagnostic request.", dReadBSRProfileConfigurationRequest, dReadBSRProfileConfigurationResponse);
  testReportWriteDiagResponse(dReadBSRProfileConfigurationRequest);
  
//  memcpy_off(bRBSRProfilesConfiguration, 3, bDefaultCycleValues, (12 * 26), (12 * 3));
//  memcpy_off(bRBSRProfilesConfiguration, (3 + 12 * 3), bDefaultStepsLibrary, (8 * 92), 192);
//  memcpy_off(bRBSRProfilesConfiguration, (3 + 12 * 3 + 192), After_Buckle_Delay, 0, 1); // After Buckle - NVP_BLOCK_ID_CYCLE_DELAYS_MB
//  memcpy_off(bRBSRProfilesConfiguration, (3 + 12 * 3 + 192 + 1), After_MD_Delay, 0, 1); // AFter Md - NVP_BLOCK_ID_CYCLE_DELAYS_MB
//  memcpy_off(bRBSRProfilesConfiguration, (3 + 12 * 3 + 192 + 2), After_PowerTrain_Delay, 0, 1); // Pwt Delay - NVP_BLOCK_ID_CYCLE_DELAYS_MB
//  memcpy_off(bRBSRProfilesConfiguration, (3 + 12 * 3 + 192 + 3), BSR_1_Acceleration_Timeout, 0, 1); // BSR1 Acceleration Timeout - NVP_BLOCK_ID_CYCLE_DELAYS_MB
  // byte 232 is unused
  
  // Configure diagnostic object.
//  if(diagResize(dWriteBSRProfileConfigurationRequest, elcount(bRBSRProfilesConfiguration)) < 0)
//  {
//    testStepFail(@sysvar::CORE::sysLevelOfDetailFail, "" ,"WriteBSRProfileConfiguration: Error when creating diagnostic object.");
//    return;
//  }
//  
//  if(diagSetPrimitiveData(dWriteBSRProfileConfigurationRequest, bRBSRProfilesConfiguration, elcount(bRBSRProfilesConfiguration)) < 0)
//  {
//    testStepFail(@sysvar::CORE::sysLevelOfDetailFail, "" ,"WriteBSRProfileConfiguration: Error when creating diagnostic object.");
//    return;
//  }
//  
  testStep(@sysvar::CORE::sysLevelOfDetailStep, "", "Start variant coding sequence");
  SecVarCoding_Start();
  Wait(1000);
  
  // Diag Error Handling.
  if(SendDiagnosticRequest(dWriteBSRProfileConfigurationRequest, dWriteBSRProfileConfigurationResponse, bRBSRProfilesConfiguration) == DIAG_SEND_OR_RECEIVE_ERROR) 
  {
    testStepFail(@sysvar::CORE::sysLevelOfDetailFail, "" ,"WriteBSRProfileConfiguration: Diagnostic request send or receive error.");
  }
  
  // Diag Error Handling.
  if (diagIsPositiveResponse(dWriteBSRProfileConfigurationResponse) == 0)
  {
    testStepFail(@sysvar::CORE::sysLevelOfDetailFail, "", "WriteBSRProfileConfiguration: Negative response received for WriteBSRProfileConfiguration: [0x%X].", dWriteBSRProfileConfigurationResponse.GetResponseCode());
    testReportWriteDiagResponse(dWriteBSRProfileConfigurationRequest);
  }
  
  testReportWriteDiagResponse(dWriteBSRProfileConfigurationRequest);
  
  testStep(@sysvar::CORE::sysLevelOfDetailStep, "", "Stop variant coding sequence");
  SecVarCoding_Finish();
  Wait(2000);
  
  testStep(@sysvar::CORE::sysLevelOfDetailStep, "", "Soft reset ECU");
  ResetECU("soft");
  WaitECUInitialization();
  
  testStep(@sysvar::CORE::sysLevelOfDetailStep, "", "Authenticate ECU");
  AuthenticateECU(2);
  EnterDiagnosticSession("development");
  
  testStep(@sysvar::CORE::sysLevelOfDetailStep, "", "Read BSR profiles configuration diagnostic service (0x0302).");
  SendDiagnosticRequest(dReadBSRProfileConfigurationRequest, dReadBSRProfileConfigurationResponse);
  CheckPositiveResponse("Check positive response of the Read BSR profiles configuration diagnostic request.", dReadBSRProfileConfigurationRequest, dReadBSRProfileConfigurationResponse);
  testReportWriteDiagResponse(dReadBSRProfileConfigurationRequest);
}

//// Write BSR cycles configuration service  
//// bAttibute - 
//// bInfo - see below
//// Example:      WriteBSRProfileConfiguration(BSR_buckle_delay, 5000);
////               WriteBSRProfileConfiguration(BSR_powertrain_delay, 5000);
////               WriteBSRProfileConfiguration(BSR_MD_delay, 5000);
/// <Vehicle_configuration/_0x0302>
void WriteBSRProfileConfiguration(byte bAttribute, long lInfo)
{
  byte timer_delay[1];
  
  testStep(@sysvar::CORE::sysLevelOfDetailStep, "", "Authenticate ECU");
  AuthenticateECU(2);
  EnterDiagnosticSession("development");
  
  testStep(@sysvar::CORE::sysLevelOfDetailStep, "", "Read BSR profiles configuration diagnostic service (0x0302).");
  SendDiagnosticRequest(dReadBSRProfileConfigurationRequest, dReadBSRProfileConfigurationResponse);
  CheckPositiveResponse("Check positive response of the Read BSR profiles configuration diagnostic request.", dReadBSRProfileConfigurationRequest, dReadBSRProfileConfigurationResponse);
  testReportWriteDiagResponse(dReadBSRProfileConfigurationRequest);
  
  diagResize(dWriteBSRProfileConfigurationRequest, 236);
  diagSetPrimitiveData(dWriteBSRProfileConfigurationRequest, bRBSRProfilesConfiguration, elcount(bRBSRProfilesConfiguration));
  
  switch(bAttribute)
  {
    case BSR_buckle_delay:
      lInfo = lInfo / 50;
      timer_delay[0] = lInfo;
      DiagSetPrimitiveByte(dWriteBSRProfileConfigurationRequest, 231, timer_delay[0]);
      break;
    case BSR_MD_delay:
      lInfo = lInfo / 50;
      timer_delay[0] = lInfo >> 8;
      DiagSetPrimitiveByte(dWriteBSRProfileConfigurationRequest, 232, timer_delay[0]);
      break;
    case BSR_Powertrain_delay:
      lInfo = lInfo / 50;
      timer_delay[0] = lInfo >> 8;
      DiagSetPrimitiveByte(dWriteBSRProfileConfigurationRequest, 233, timer_delay[0]);
      break;
  }
  
  testStep(@sysvar::CORE::sysLevelOfDetailStep, "", "Start variant coding sequence");
  SecVarCoding_Start();
  Wait(1000);
  
  // Diag Error Handling.
  if(SendDiagnosticRequest(dWriteBSRProfileConfigurationRequest, dWriteBSRProfileConfigurationResponse) == DIAG_SEND_OR_RECEIVE_ERROR) 
  {
    testStepFail(@sysvar::CORE::sysLevelOfDetailFail, "" ,"WriteBSRProfileConfiguration: Diagnostic request send or receive error.");
  }
  
  // Diag Error Handling.
  if (diagIsPositiveResponse(dWriteBSRProfileConfigurationResponse) == 0)
  {
    testStepFail(@sysvar::CORE::sysLevelOfDetailFail, "", "WriteBSRProfileConfiguration: Negative response received for WriteBSRProfileConfiguration: [0x%X].", dWriteBSRProfileConfigurationResponse.GetResponseCode());
    testReportWriteDiagResponse(dWriteBSRProfileConfigurationRequest);
  }
  
  testReportWriteDiagResponse(dWriteBSRProfileConfigurationRequest);
  
  testStep(@sysvar::CORE::sysLevelOfDetailStep, "", "Stop variant coding sequence");
  SecVarCoding_Finish();
  Wait(2000);
  
  testStep(@sysvar::CORE::sysLevelOfDetailStep, "", "Soft reset ECU");
  ResetECU("soft");
  WaitECUInitialization();
  
  testStep(@sysvar::CORE::sysLevelOfDetailStep, "", "Authenticate ECU");
  AuthenticateECU(2);
  EnterDiagnosticSession("development");
  
  testStep(@sysvar::CORE::sysLevelOfDetailStep, "", "Read BSR profiles configuration diagnostic service (0x0302).");
  SendDiagnosticRequest(dReadBSRProfileConfigurationRequest, dReadBSRProfileConfigurationResponse);
  CheckPositiveResponse("Check positive response of the Read BSR profiles configuration diagnostic request.", dReadBSRProfileConfigurationRequest, dReadBSRProfileConfigurationResponse);
  testReportWriteDiagResponse(dReadBSRProfileConfigurationRequest);
}



/// <Vehicle_configuration/_x0300>
//// Write tensioning cycles configuration with default values  
//// bAttibute - PRE_SAFE_1 - PRE_SAFE_15, HAPTIC_WARNING1 - HAPTIC_WARNING4, ....
//// bInfo - see below
//// Example:      WriteTensioningProfileConfiguration();
void WriteTensioningProfileConfiguration()
{
  byte bResponse[1076];
  
//  byte bDelay[2] = {0xF4, 0x01};
//  byte bDuration[2] = {0xB8, 0x03}; // intel format
//  byte bHaptictype[1] = {0x00};
//  byte bPRE_SAFE_5_Timeout[2]; //10 ms resolution
//  byte bVibrationPhaseDuration[2]; //1 ms resolution
//  byte bAccelerationTimeout[1] = {0x1E}; //10 ms resolution
//  byte bLowForceAssociatedCounter_firstByte[1] = 0x01;
//  byte bLowForceAssociatedCounter[1] = 0x11;
//  byte bLowForceAssociatedCounter_Empty[1] = 0x00;
//  
//  byte bFirstLow[1] = {0x10};
//  byte bSecondLow[1] = {0x01};
//  
//  byte bFirstHigh[1] = {0x20};
//  byte bSecondHigh[1] = {0x02};
//  
//  byte bFirstMax[1] = {0x40};
//  byte bSecondMax[1] = {0x04};
//  
//  byte bFirstComfort[1] = {0x80};
//  byte bSecondComfort[1] = {0x08};
  
  testStep(@sysvar::CORE::sysLevelOfDetailStep, "", "Authenticate ECU");
  AuthenticateECU(2);
  EnterDiagnosticSession("development");
  
  testStep(@sysvar::CORE::sysLevelOfDetailStep, "", "Read Tensioning profile configuration diagnostic service");
  SendDiagnosticRequest(dReadTensioningProfileConfigurationRequest, dReadTensioningProfileConfigurationResponse);
  CheckPositiveResponse("Check positive response of the Read Tensioning profile configuration diagnostic request", dReadTensioningProfileConfigurationRequest, dReadTensioningProfileConfigurationResponse);
  testReportWriteDiagResponse(dReadTensioningProfileConfigurationRequest);
  
  diagGetPrimitiveData(dReadTensioningProfileConfigurationResponse, bResponse, elcount(bResponse));
  
//  diagResize(dWriteTensioningProfileConfigurationRequest, 1072);
//  diagSetPrimitiveData(dWriteTensioningProfileConfigurationRequest, bTensioningProfileConfiguration, elcount(bTensioningProfileConfiguration));
//  
//  //PRE_SAFE_N
//  memcpy_off(bTensioningProfileConfiguration, 3 + (12 * 0), bDefaultCycleValues, (12 * 0), 12);
//  memcpy_off(bTensioningProfileConfiguration, 3 + (12 * 1), bDefaultCycleValues, (12 * 1), 12);
//  memcpy_off(bTensioningProfileConfiguration, 3 + (12 * 2), bDefaultCycleValues, (12 * 2), 12);
//  memcpy_off(bTensioningProfileConfiguration, 3 + (12 * 3), bDefaultCycleValues, (12 * 3), 12);
//  memcpy_off(bTensioningProfileConfiguration, 3 + (12 * 4), bDefaultCycleValues, (12 * 4), 12);
//  memcpy_off(bTensioningProfileConfiguration, 3 + (12 * 5), bDefaultCycleValues, (12 * 5), 12);
//  memcpy_off(bTensioningProfileConfiguration, 3 + (12 * 6), bDefaultCycleValues, (12 * 6), 12);
//  memcpy_off(bTensioningProfileConfiguration, 3 + (12 * 7), bDefaultCycleValues, (12 * 7), 12);
//  memcpy_off(bTensioningProfileConfiguration, 3 + (12 * 8), bDefaultCycleValues, (12 * 8), 12);
//  memcpy_off(bTensioningProfileConfiguration, 3 + (12 * 9), bDefaultCycleValues, (12 * 9), 12);
//  memcpy_off(bTensioningProfileConfiguration, 3 + (12 * 10), bDefaultCycleValues, (12 * 10), 12);
//  memcpy_off(bTensioningProfileConfiguration, 3 + (12 * 11), bDefaultCycleValues, (12 * 11), 12);
//  memcpy_off(bTensioningProfileConfiguration, 3 + (12 * 12), bDefaultCycleValues, (12 * 12), 12);
//  memcpy_off(bTensioningProfileConfiguration, 3 + (12 * 13), bDefaultCycleValues, (12 * 13), 12);
//  
//  //PRE_SAFE_CURVE_N
//  memcpy_off(bTensioningProfileConfiguration, 3 + (12 * 14), bDefaultCycleValues, (12 * 14), 12);
//  memcpy_off(bTensioningProfileConfiguration, 3 + (12 * 15), bDefaultCycleValues, (12 * 15), 12);
//  memcpy_off(bTensioningProfileConfiguration, 3 + (12 * 16), bDefaultCycleValues, (12 * 16), 12);
//  memcpy_off(bTensioningProfileConfiguration, 3 + (12 * 17), bDefaultCycleValues, (12 * 17), 12);
//  //HWA_N
//  memcpy_off(bTensioningProfileConfiguration, 3 + (12 * 18), bDefaultCycleValues, (12 * 18), 12);
//  memcpy_off(bTensioningProfileConfiguration, 3 + (12 * 19), bDefaultCycleValues, (12 * 19), 12);
//  memcpy_off(bTensioningProfileConfiguration, 3 + (12 * 20), bDefaultCycleValues, (12 * 20), 12);
//  memcpy_off(bTensioningProfileConfiguration, 3 + (12 * 21), bDefaultCycleValues, (12 * 21), 12);
//  memcpy_off(bTensioningProfileConfiguration, 3 + (12 * 22), bDefaultCycleValues, (12 * 22), 12);
//  memcpy_off(bTensioningProfileConfiguration, 3 + (12 * 23), bDefaultCycleValues, (12 * 23), 12);
//  memcpy_off(bTensioningProfileConfiguration, 3 + (12 * 24), bDefaultCycleValues, (12 * 24), 12);
//  memcpy_off(bTensioningProfileConfiguration, 3 + (12 * 25), bDefaultCycleValues, (12 * 25), 12);
//  //Steps configuration
//  memcpy_off(bTensioningProfileConfiguration, 3 + (12 * 26), bDefaultStepsLibrary, 0, (92*8));
//  //Time
//  memcpy_off(bTensioningProfileConfiguration, 3 + (12 * 26) + (92 * 8) + 0, bDelay, 0, 2); //PRE_SAFE_5 duration
//  memcpy_off(bTensioningProfileConfiguration, 3 + (12 * 26) + (92 * 8) + 2, bDuration, 0, 2); //HWA_1 vibration phase duration
//  memcpy_off(bTensioningProfileConfiguration, 3 + (12 * 26) + (92 * 8) + 4, bDuration, 0, 2); //HWA_2 vibration phase duration
//  memcpy_off(bTensioningProfileConfiguration, 3 + (12 * 26) + (92 * 8) + 6, bDuration, 0, 2); //HWA_3 vibration phase duration
//  memcpy_off(bTensioningProfileConfiguration, 3 + (12 * 26) + (92 * 8) + 8, bDuration, 0, 2); //HWA_4 vibration phase duration
//  memcpy_off(bTensioningProfileConfiguration, 3 + (12 * 26) + (92 * 8) + 10, bHaptictype, 0, 1);
//  memcpy_off(bTensioningProfileConfiguration, 3 + (12 * 26) + (92 * 8) + 11, bAccelerationTimeout, 0, 1); //PRE_SAFE acceleration timeout
//  memcpy_off(bTensioningProfileConfiguration, 3 + (12 * 26) + (92 * 8) + 12, bAccelerationTimeout, 0, 1); //HWA acceleration timeout
//  memcpy_off(bTensioningProfileConfiguration, 3 + (12 * 26) + (92 * 8) + 13, bAccelerationTimeout, 0, 1); //API acceleration timeout
//  //EOL parameters
//  memcpy_off(bTensioningProfileConfiguration, 3 + (12 * 26) + (92 * 8) + 14, bLowForceAssociatedCounter_firstByte, 0, 1); //PRE_SAFE_15 Low force counter
//  memcpy_off(bTensioningProfileConfiguration, 3 + (12 * 26) + (92 * 8) + 15, bLowForceAssociatedCounter, 0, 1); //PRE_SAFE_14, PRE_SAFE_13  Low force counter
//  memcpy_off(bTensioningProfileConfiguration, 3 + (12 * 26) + (92 * 8) + 16, bLowForceAssociatedCounter, 0, 1); //PRE_SAFE_12, PRE_SAFE_11 Low force counter
//  memcpy_off(bTensioningProfileConfiguration, 3 + (12 * 26) + (92 * 8) + 17, bLowForceAssociatedCounter, 0, 1); //PRE_SAFE_10, PRE_SAFE_9 Low force counter
//  memcpy_off(bTensioningProfileConfiguration, 3 + (12 * 26) + (92 * 8) + 18, bLowForceAssociatedCounter_Empty, 0, 1); //HAPTIC_WARNING_4, HAPTIC_WARNING_3  Low force counter
//  memcpy_off(bTensioningProfileConfiguration, 3 + (12 * 26) + (92 * 8) + 19, bLowForceAssociatedCounter_Empty, 0, 1); //HAPTIC_WARNING_2, HAPTIC_WARNING_1 Low force counter
//  memcpy_off(bTensioningProfileConfiguration, 3 + (12 * 26) + (92 * 8) + 20, bLowForceAssociatedCounter_Empty, 0, 1); //PRE_SAFE_7, PRE_SAFE_6 Low force counter
//  memcpy_off(bTensioningProfileConfiguration, 3 + (12 * 26) + (92 * 8) + 21, bLowForceAssociatedCounter_Empty, 0, 1); //PRE_SAFE_5, PRE_SAFE_4 Low force counter
//  memcpy_off(bTensioningProfileConfiguration, 3 + (12 * 26) + (92 * 8) + 22, bLowForceAssociatedCounter_Empty, 0, 1); //PRE_SAFE_3, PRE_SAFE_1 Low force counter
//  memcpy_off(bTensioningProfileConfiguration, 3 + (12 * 26) + (92 * 8) + 23, bLowForceAssociatedCounter_Empty, 0, 1); //PRE_SAFE_CURVE_4, PRE_SAFE_CURVE_3 Low force counter
//  memcpy_off(bTensioningProfileConfiguration, 3 + (12 * 26) + (92 * 8) + 24, bLowForceAssociatedCounter_Empty, 0, 1); //PRE_SAFE_CURVE_2, PRE_SAFE_CURVE_1 Low force counter
//  
//  diagResize(dWriteTensioningProfileConfigurationRequest, 1076);
//  diagSetPrimitiveData(dWriteTensioningProfileConfigurationRequest, bTensioningProfileConfiguration, elcount(bTensioningProfileConfiguration));
  
  testStep(@sysvar::CORE::sysLevelOfDetailStep, "", "Start variant coding sequence");
  SecVarCoding_Start();
  Wait(1000);
  
  testStep(@sysvar::CORE::sysLevelOfDetailStep, "", "Send Write tensioning profile configuration diagnostic service request with new values");
  SendDiagnosticRequest(dWriteTensioningProfileConfigurationRequest, dWriteTensioningProfileConfigurationResponse, bTensioningProfileConfiguration);
  CheckPositiveResponse("Check positive response of Write tensioning profile configuration diagnostic service.", dWriteTensioningProfileConfigurationRequest, dWriteTensioningProfileConfigurationResponse);
  Wait(2000);
  
  testStep(@sysvar::CORE::sysLevelOfDetailStep, "", "Stop variant coding sequence");  
  SecVarCoding_Finish();
  wait(2000);  
  
  testStep(@sysvar::CORE::sysLevelOfDetailStep, "", "Stop variant coding sequence"); 
  ResetECU("soft");
  WaitECUInitialization();
  
  testStep(@sysvar::CORE::sysLevelOfDetailStep, "", "Authenticate ECU");
  AuthenticateECU(2);
  EnterDiagnosticSession("development");
  
  testStep(@sysvar::CORE::sysLevelOfDetailStep, "", "Read Tensioning profile configuration diagnostic service");
  SendDiagnosticRequest(dReadTensioningProfileConfigurationRequest, dReadTensioningProfileConfigurationResponse);
  CheckPositiveResponse("Check positive response of the Read Tensioning profile configuration diagnostic request", dReadTensioningProfileConfigurationRequest, dReadTensioningProfileConfigurationResponse);
  testReportWriteDiagResponse(dReadTensioningProfileConfigurationRequest);
  
}

/// <Vehicle_configuration/_x0300>
//// Write tensioning cycles configuration service  
//// bAttibute - PRE_SAFE_1 - PRE_SAFE_15, HAPTIC_WARNING1 - HAPTIC_WARNING4, ....
//// bInfo - see below
//// Example:      WriteTensioningProfileConfiguration(PRE_SAFE_1, <12 byte array with profile configuration>);
////               WriteTensioningProfileConfiguration(PRE_SAFE_3, <12 byte array with profile configuration>);
////               WriteTensioningProfileConfiguration(PRE_SAFE_4, <12 byte array with profile configuration>);
////               WriteTensioningProfileConfiguration(PRE_SAFE_5, <12 byte array with profile configuration>);
////               WriteTensioningProfileConfiguration(PRE_SAFE_6, <12 byte array with profile configuration>);
////               WriteTensioningProfileConfiguration(PRE_SAFE_7, <12 byte array with profile configuration>);
////               WriteTensioningProfileConfiguration(PRE_SAFE_8, <12 byte array with profile configuration>);
////               WriteTensioningProfileConfiguration(PRE_SAFE_9, <12 byte array with profile configuration>);
////               WriteTensioningProfileConfiguration(PRE_SAFE_10, <12 byte array with profile configuration>);
////               WriteTensioningProfileConfiguration(PRE_SAFE_11, <12 byte array with profile configuration>);
////               WriteTensioningProfileConfiguration(PRE_SAFE_12, <12 byte array with profile configuration>);
////               WriteTensioningProfileConfiguration(PRE_SAFE_13, <12 byte array with profile configuration>);
////               WriteTensioningProfileConfiguration(PRE_SAFE_14, <12 byte array with profile configuration>);
////               WriteTensioningProfileConfiguration(PRE_SAFE_15, <12 byte array with profile configuration>);
////               WriteTensioningProfileConfiguration(PRE_SAFE_CURVE_1, <12 byte array with profile configuration>);
////               WriteTensioningProfileConfiguration(PRE_SAFE_CURVE_2, <12 byte array with profile configuration>);
////               WriteTensioningProfileConfiguration(PRE_SAFE_CURVE_3, <12 byte array with profile configuration>);
////               WriteTensioningProfileConfiguration(PRE_SAFE_CURVE_4, <12 byte array with profile configuration>);
////               WriteTensioningProfileConfiguration(HAPTIC_WARNING_1, <12 byte array with profile configuration>);
////               WriteTensioningProfileConfiguration(HAPTIC_WARNING_1_P1, <12 byte array with profile configuration>);
////               WriteTensioningProfileConfiguration(HAPTIC_WARNING_2, <12 byte array with profile configuration>);
////               WriteTensioningProfileConfiguration(HAPTIC_WARNING_2_P1, <12 byte array with profile configuration>);
////               WriteTensioningProfileConfiguration(HAPTIC_WARNING_3, <12 byte array with profile configuration>);
////               WriteTensioningProfileConfiguration(HAPTIC_WARNING_3_P1, <12 byte array with profile configuration>);
////               WriteTensioningProfileConfiguration(HAPTIC_WARNING_4, <12 byte array with profile configuration>);
////               WriteTensioningProfileConfiguration(HAPTIC_WARNING_4_P1, <12 byte array with profile configuration>);
void WriteTensioningProfileConfiguration(byte bAttribute, byte bInfo[])
{
  byte bReadTensioningProfileConfigurationResponse[1076];
  
  byte bDelay[2] = {0x01, 0xF4};
  byte bDuration[2] = {0x03, 0xB8};
  byte bHaptictype[1] = {0x00};
  byte bPRE_SAFE_5_Timeout[2]; //10 ms resolution
  byte bVibrationPhaseDuration[2]; //1 ms resolution
  byte bAccelerationTimeout[1] = {0x1E}; //10 ms resolution
  byte bLowForceAssociatedCounter[1] = 0x11;
  byte bTempRequest[1076];
  
  memcpy(bTempRequest, bTensioningProfileConfiguration, elcount(bTensioningProfileConfiguration));
  
  testStep(@sysvar::CORE::sysLevelOfDetailStep, "", "Authenticate ECU");
  AuthenticateECU(2);
  EnterDiagnosticSession("development");
  
  testStep(@sysvar::CORE::sysLevelOfDetailStep, "", "Read Tensioning profile configuration diagnostic service");
  SendDiagnosticRequest(dReadTensioningProfileConfigurationRequest, dReadTensioningProfileConfigurationResponse);
  CheckPositiveResponse("Check positive response of the Read Tensioning profile configuration diagnostic request", dReadTensioningProfileConfigurationRequest, dReadTensioningProfileConfigurationResponse);
  testReportWriteDiagResponse(dReadTensioningProfileConfigurationRequest);
  
  diagGetPrimitiveData(dReadTensioningProfileConfigurationResponse, bReadTensioningProfileConfigurationResponse, elcount(bReadTensioningProfileConfigurationResponse));
  memcpy_off(bTensioningProfileConfiguration, 3, bReadTensioningProfileConfigurationResponse, 3, elcount(bReadTensioningProfileConfigurationResponse)-3);

  switch(bAttribute)
  {
    case PRE_SAFE_1:
      if (elcount(bInfo) == 12)
      {
        memcpy_off(bTensioningProfileConfiguration, 3 + (12 * 0), bInfo, 0, 12);
      }
      else
      {
        testStepFail("Write tensioning configuration", "Wrong parameter length for profile configuration.");
      }
      break;
    case PRE_SAFE_3:
      if (elcount(bInfo) == 12)
      {
        memcpy_off(bTensioningProfileConfiguration, 3 + (12 * 1), bInfo, 0, 12);
      }
      else
      {
        testStepFail("Write tensioning configuration", "Wrong parameter length for profile configuration.");
      }
      break;
    case PRE_SAFE_4:
      if (elcount(bInfo) == 12)
      {
        memcpy_off(bTensioningProfileConfiguration, 3 + (12 * 2), bInfo, 0, 12);
      }
      else
      {
        testStepFail("Write tensioning configuration", "Wrong parameter length for profile configuration.");
      }
      break;
    case PRE_SAFE_5:
      if (elcount(bInfo) == 12)
      {
        memcpy_off(bTensioningProfileConfiguration, 3 + (12 * 3), bInfo, 0, 12);
      }
      else
      {
        testStepFail("Write tensioning configuration", "Wrong parameter length for profile configuration.");
      }
      break;
    case PRE_SAFE_6:
      if (elcount(bInfo) == 12)
      {
        memcpy_off(bTensioningProfileConfiguration, 3 + (12 * 4), bInfo, 0, 12);
      }
      else
      {
        testStepFail("Write tensioning configuration", "Wrong parameter length for profile configuration.");
      }
      break;
    case PRE_SAFE_7:
      if (elcount(bInfo) == 12)
      {
        memcpy_off(bTensioningProfileConfiguration, 3 + (12 * 5), bInfo, 0, 12);
      }
      else
      {
        testStepFail("Write tensioning configuration", "Wrong parameter length for profile configuration.");
      }
      break;
    case PRE_SAFE_8:
      if (elcount(bInfo) == 12)
      {
        memcpy_off(bTensioningProfileConfiguration, 3 + (12 * 6), bInfo, 0, 12);
      }
      else
      {
        testStepFail("Write tensioning configuration", "Wrong parameter length for profile configuration.");
      }
      break;
    case PRE_SAFE_9:
      if (elcount(bInfo) == 12)
      {
        memcpy_off(bTensioningProfileConfiguration, 3 + (12 * 7), bInfo, 0, 12);
      }
      else
      {
        testStepFail("Write tensioning configuration", "Wrong parameter length for profile configuration.");
      }
      break;
    case PRE_SAFE_10:
      if (elcount(bInfo) == 12)
      {
        memcpy_off(bTensioningProfileConfiguration, 3 + (12 * 8), bInfo, 0, 12);
      }
      else
      {
        testStepFail("Write tensioning configuration", "Wrong parameter length for profile configuration.");
      }
      break;
    case PRE_SAFE_11:
      if (elcount(bInfo) == 12)
      {
        memcpy_off(bTensioningProfileConfiguration, 3 + (12 * 9), bInfo, 0, 12);
      }
      else
      {
        testStepFail("Write tensioning configuration", "Wrong parameter length for profile configuration.");
      }
      break;
    case PRE_SAFE_12:
      if (elcount(bInfo) == 12)
      {
        memcpy_off(bTensioningProfileConfiguration, 3 + (12 * 10), bInfo, 0, 12);
      }
      else
      {
        testStepFail("Write tensioning configuration", "Wrong parameter length for profile configuration.");
      }
      break;
    case PRE_SAFE_13:
      if (elcount(bInfo) == 12)
      {
        memcpy_off(bTensioningProfileConfiguration, 3 + (12 * 11), bInfo, 0, 12);
      }
      else
      {
        testStepFail("Write tensioning configuration", "Wrong parameter length for profile configuration.");
      }
      break;
    case PRE_SAFE_14:
      if (elcount(bInfo) == 12)
      {
        memcpy_off(bTensioningProfileConfiguration, 3 + (12 * 12), bInfo, 0, 12);
      }
      else
      {
        testStepFail("Write tensioning configuration", "Wrong parameter length for profile configuration.");
      }
      break;
    case PRE_SAFE_15:
      if (elcount(bInfo) == 12)
      {
        memcpy_off(bTensioningProfileConfiguration, 3 + (12 * 13), bInfo, 0, 12);
      }
      else
      {
        testStepFail("Write tensioning configuration", "Wrong parameter length for profile configuration.");
      }
      break;
    case PRE_SAFE_CURVE_1:
      if (elcount(bInfo) == 12)
      { 
        memcpy_off(bTensioningProfileConfiguration, 3 + (12 * 14), bInfo, 0, 12);
      }
      else
      {
        testStepFail("Write tensioning configuration", "Wrong parameter length for profile configuration.");
      }
      break;
    case PRE_SAFE_CURVE_2:
      if (elcount(bInfo) == 12)
      {
        memcpy_off(bTensioningProfileConfiguration, 3 + (12 * 15), bInfo, 0, 12);
      }
      else
      {
        testStepFail("Write tensioning configuration", "Wrong parameter length for profile configuration.");
      }
      break;
    case PRE_SAFE_CURVE_3:
      if (elcount(bInfo) == 12)
      {
        memcpy_off(bTensioningProfileConfiguration, 3 + (12 * 16), bInfo, 0, 12);
      }
      else
      {
        testStepFail("Write tensioning configuration", "Wrong parameter length for profile configuration.");
      }
      break;
    case PRE_SAFE_CURVE_4:
      if (elcount(bInfo) == 12)
      {
        memcpy_off(bTensioningProfileConfiguration, 3 + (12 * 17), bInfo, 0, 12);
      }
      else
      {
        testStepFail("Write tensioning configuration", "Wrong parameter length for profile configuration.");
      }
      break;
    case HAPTIC_WARNING1:
      if (elcount(bInfo) == 12)
      {
        memcpy_off(bTensioningProfileConfiguration, 3 + (12 * 18), bInfo, 0, 12);
      }
      else
      {
        testStepFail("Write tensioning configuration", "Wrong parameter length for profile configuration.");
      }
      break;
    case HAPTIC_WARNING1_P1:
      if (elcount(bInfo) == 12)
      {
        memcpy_off(bTensioningProfileConfiguration, 3 + (12 * 19), bInfo, 0, 12);
      }
      else
      {
        testStepFail("Write tensioning configuration", "Wrong parameter length for profile configuration.");
      }
      break;
          case HAPTIC_WARNING2:
      if (elcount(bInfo) == 12)
      {
        memcpy_off(bTensioningProfileConfiguration, 3 + (12 * 20), bInfo, 0, 12);
      }
      else
      {
        testStepFail("Write tensioning configuration", "Wrong parameter length for profile configuration.");
      }
      break;
    case HAPTIC_WARNING2_P1:
      if (elcount(bInfo) == 12)
      {
        memcpy_off(bTensioningProfileConfiguration, 3 + (12 * 21), bInfo, 0, 12);
      }
      else
      {
        testStepFail("Write tensioning configuration", "Wrong parameter length for profile configuration.");
      }
      break;
          case HAPTIC_WARNING3:
      if (elcount(bInfo) == 12)
      {
        memcpy_off(bTensioningProfileConfiguration, 3 + (12 * 22), bInfo, 0, 12);
      }
      else
      {
        testStepFail("Write tensioning configuration", "Wrong parameter length for profile configuration.");
      }
      break;
    case HAPTIC_WARNING3_P1:
      if (elcount(bInfo) == 12)
      {
        memcpy_off(bTensioningProfileConfiguration, 3 + (12 * 23), bInfo, 0, 12);
      }
      else
      {
        testStepFail("Write tensioning configuration", "Wrong parameter length for profile configuration.");
      }
      break;
          case HAPTIC_WARNING4:
      if (elcount(bInfo) == 12)
      {
        memcpy_off(bTensioningProfileConfiguration, 3 + (12 * 24), bInfo, 0, 12);
      }
      else
      {
        testStepFail("Write tensioning configuration", "Wrong parameter length for profile configuration.");
      }
      break;
    case HAPTIC_WARNING4_P1:
      if (elcount(bInfo) == 12)
      {
        memcpy_off(bTensioningProfileConfiguration, 3 + (12 * 25), bInfo, 0, 12);
      }
      else
      {
        testStepFail("Write tensioning configuration", "Wrong parameter length for profile configuration.");
      }
      break;
    ////new case for steps library to be determined 
  }
  
  diagResize(dWriteTensioningProfileConfigurationRequest, 1076);
  diagSetPrimitiveData(dWriteTensioningProfileConfigurationRequest, bTensioningProfileConfiguration, elcount(bTensioningProfileConfiguration));
  
  testStep(@sysvar::CORE::sysLevelOfDetailStep, "", "Start variant coding sequence");
  SecVarCoding_Start();
  Wait(1000);
  
  testStep(@sysvar::CORE::sysLevelOfDetailStep, "", "Send Write tensioning profile configuration diagnostic service request with new values");
  SendDiagnosticRequest(dWriteTensioningProfileConfigurationRequest, dWriteTensioningProfileConfigurationResponse);
  CheckPositiveResponse("Check positive response of Write tensioning profile configuration diagnostic service.", dWriteTensioningProfileConfigurationRequest, dWriteTensioningProfileConfigurationResponse);
  Wait(2000);
  
  testStep(@sysvar::CORE::sysLevelOfDetailStep, "", "Stop variant coding sequence");
  SecVarCoding_Finish();
  wait(2000);  
  
  testStep(@sysvar::CORE::sysLevelOfDetailStep, "", "Soft reset ECU.");
  ResetECU("soft");
  WaitECUInitialization();
  
  testStep(@sysvar::CORE::sysLevelOfDetailStep, "", "Authenticate ECU");
  AuthenticateECU(2);
  EnterDiagnosticSession("development");
  
  testStep(@sysvar::CORE::sysLevelOfDetailStep, "", "Read Tensioning profile configuration diagnostic service");
  SendDiagnosticRequest(dReadTensioningProfileConfigurationRequest, dReadTensioningProfileConfigurationResponse);
  CheckPositiveResponse("Check positive response of the Read Tensioning profile configuration diagnostic request", dReadTensioningProfileConfigurationRequest, dReadTensioningProfileConfigurationResponse);
  testReportWriteDiagResponse(dReadTensioningProfileConfigurationRequest);
  
  memcpy(bTensioningProfileConfiguration, bTempRequest, elcount(bTempRequest));
  
}

/// <Vehicle_configuration/_x0300>
//// Write tensioning cycles configuration service  
//// bAttibute - PRE_SAFE_1 - PRE_SAFE_15, HAPTIC_WARNING1 - HAPTIC_WARNING4, ....
//// bInfo - see below
//// Example:      WriteTensioningProfileConfiguration(PRE_SAFE_5_Duration, 6000);
////               WriteTensioningProfileConfiguration(HAPTIC_WARNING1_P1_DURATION, 6000);
////               WriteTensioningProfileConfiguration(HAPTIC_WARNING2_P1_DURATION, 1500);
////               WriteTensioningProfileConfiguration(HAPTIC_WARNING3_P1_DURATION, 1500);
////               WriteTensioningProfileConfiguration(HAPTIC_WARNING4_P1_DURATION, 1500);
////               WriteTensioningProfileConfiguration(PRESAFE_acceleration_timeout, 300);
////               WriteTensioningProfileConfiguration(HWA1_acceleration_timeout, 300);
////               WriteTensioningProfileConfiguration(API_acceleration_timeout, 300);
void WriteTensioningProfileConfiguration(byte bAttribute, long lInfo)
{
  byte bReadTensioningProfileConfigurationResponse[1076];
  
  byte bDelay[2] = {0x01, 0xF4};
  byte bDuration[2] = {0x03, 0xB8};
  byte bHaptictype[1] = {0x00};
  byte bPRE_SAFE_5_Timeout[2]; //10 ms resolution
  byte bVibrationPhaseDuration[2]; //1 ms resolution
  byte bAccelerationTimeout[1] = {0x1E}; //10 ms resolution
  byte bLowForceAssociatedCounter[1] = 0x11;
  
  testStep(@sysvar::CORE::sysLevelOfDetailStep, "", "Authenticate ECU");
  AuthenticateECU(2);
  EnterDiagnosticSession("development");
  
  testStep(@sysvar::CORE::sysLevelOfDetailStep, "", "Read Tensioning profile configuration diagnostic service");
  SendDiagnosticRequest(dReadTensioningProfileConfigurationRequest, dReadTensioningProfileConfigurationResponse);
  CheckPositiveResponse("Check positive response of the Read Tensioning profile configuration diagnostic request", dReadTensioningProfileConfigurationRequest, dReadTensioningProfileConfigurationResponse);
  testReportWriteDiagResponse(dReadTensioningProfileConfigurationRequest);
  
  diagGetPrimitiveData(dReadTensioningProfileConfigurationResponse, bReadTensioningProfileConfigurationResponse, elcount(bReadTensioningProfileConfigurationResponse));
  memcpy_off(bTensioningProfileConfiguration, 3, bReadTensioningProfileConfigurationResponse, 3, elcount(bReadTensioningProfileConfigurationResponse)-3);
  
  
  diagResize(dWriteTensioningProfileConfigurationRequest, 1076);
  diagSetPrimitiveData(dWriteTensioningProfileConfigurationRequest, bTensioningProfileConfiguration, elcount(bTensioningProfileConfiguration));
  
  switch(bAttribute)
  {
    case PRE_SAFE_5_Duration:
      lInfo = lInfo / 10;
      bPRE_SAFE_5_Timeout[0] = lInfo >> 8;
      bPRE_SAFE_5_Timeout[1] = lInfo;
      if (elcount(bPRE_SAFE_5_Timeout) == 2)
      {
//        memcpy_off(bTensioningProfileConfiguration, 3 + (12 * 25) + (92 * 8) + 0, bPRE_SAFE_5_Timeout, 0, 2);
        DiagSetPrimitiveByte(dWriteTensioningProfileConfigurationRequest, 1052, bPRE_SAFE_5_Timeout[0]);
        DiagSetPrimitiveByte(dWriteTensioningProfileConfigurationRequest, 1051, bPRE_SAFE_5_Timeout[1]);
        
      }
      else
      {
        testStepFail("Write tensioning configuration", "Wrong parameter length for PRE_SAFE_5 duration in case of MAX force counter is reached");
      }
      break;
    case HAPTIC_WARNING1_P1_DURATION:
      bVibrationPhaseDuration[0] = lInfo >> 8;
      bVibrationPhaseDuration[1] = lInfo;
      if (elcount(bVibrationPhaseDuration) == 2)
      {
//        memcpy_off(bTensioningProfileConfiguration, 3 + (12 * 25) + (92 * 8) + 2, bVibrationPhaseDuration, 0, 2);
        DiagSetPrimitiveByte(dWriteTensioningProfileConfigurationRequest, 1054, bVibrationPhaseDuration[0]);
        DiagSetPrimitiveByte(dWriteTensioningProfileConfigurationRequest, 1053, bVibrationPhaseDuration[1]);
      }
      else
      {
        testStepFail("Write tensioning configuration", "Wrong parameter length for Haptic warning duration");
      }
      break;
    case HAPTIC_WARNING2_P1_DURATION:
      bVibrationPhaseDuration[0] = lInfo >> 8;
      bVibrationPhaseDuration[1] = lInfo;
      if (elcount(bVibrationPhaseDuration) == 2)
      {
//        memcpy_off(bTensioningProfileConfiguration, 3 + (12 * 25) + (92 * 8) + 4, bVibrationPhaseDuration, 0, 2);
        DiagSetPrimitiveByte(dWriteTensioningProfileConfigurationRequest, 1056, bVibrationPhaseDuration[0]);
        DiagSetPrimitiveByte(dWriteTensioningProfileConfigurationRequest, 1055, bVibrationPhaseDuration[1]);
      }
      else
      {
        testStepFail("Write tensioning configuration", "Wrong parameter length for Haptic warning duration");
      }
      break;
    case HAPTIC_WARNING3_P1_DURATION:
      bVibrationPhaseDuration[0] = lInfo >> 8;
      bVibrationPhaseDuration[1] = lInfo;
      if (elcount(bVibrationPhaseDuration) == 2)
      {
//        memcpy_off(bTensioningProfileConfiguration, 3 + (12 * 25) + (92 * 8) + 6, bVibrationPhaseDuration, 0, 2);
        DiagSetPrimitiveByte(dWriteTensioningProfileConfigurationRequest, 1058, bVibrationPhaseDuration[0]);
        DiagSetPrimitiveByte(dWriteTensioningProfileConfigurationRequest, 1057, bVibrationPhaseDuration[1]);
      }
      else
      {
        testStepFail("Write tensioning configuration", "Wrong parameter length for Haptic warning duration");
      }
      break;
    case HAPTIC_WARNING4_P1_DURATION:
      bVibrationPhaseDuration[0] = lInfo >> 8;
      bVibrationPhaseDuration[1] = lInfo;
      if (elcount(bVibrationPhaseDuration) == 2)
      {
//        memcpy_off(bTensioningProfileConfiguration, 3 + (12 * 25) + (92 * 8) + 8, bVibrationPhaseDuration, 0, 2);
        DiagSetPrimitiveByte(dWriteTensioningProfileConfigurationRequest, 1060, bVibrationPhaseDuration[0]);
        DiagSetPrimitiveByte(dWriteTensioningProfileConfigurationRequest, 1059, bVibrationPhaseDuration[1]);
      }
      else
      {
        testStepFail("Write tensioning configuration", "Wrong parameter length for Haptic warning duration");
      }
      break;
    case Haptic_type:
      if (lInfo == Fixed)
      {
        DiagSetPrimitiveByte(dWriteTensioningProfileConfigurationRequest, 1061, 0x00);
      }
      else
      {
        if (lInfo == Not_fixed_HWA_1)
        {
          DiagSetPrimitiveByte(dWriteTensioningProfileConfigurationRequest, 1061, 0x01);
        }
        else
        {
          if (lInfo == Not_fixed_HWA_2)
          {
            DiagSetPrimitiveByte(dWriteTensioningProfileConfigurationRequest, 1061, 0x02);
          }
          else
          {
            if (lInfo == Not_fixed_HWA_3)
            {
              DiagSetPrimitiveByte(dWriteTensioningProfileConfigurationRequest, 1061, 0x04);
            }
            else
            {
              if (lInfo == Not_fixed_HWA_4)
              {
                DiagSetPrimitiveByte(dWriteTensioningProfileConfigurationRequest, 1061, 0x08);
              }
              else
              {
                testStepFail("Write tensioning configuration", "Wrong parameter value for Haptic type");
              }
      }}}}
      break;
    case PRESAFE_acceleration_timeout:
      lInfo = lInfo / 10;
      bAccelerationTimeout[0] = lInfo;
      if (elcount(bAccelerationTimeout) == 1)
      {
//        memcpy_off(bTensioningProfileConfiguration, 3 + (12 * 25) + (92 * 8) + 11, bAccelerationTimeout, 0, 1);
        DiagSetPrimitiveByte(dWriteTensioningProfileConfigurationRequest, 1062, bAccelerationTimeout[0]);
      }
      else
      {
        testStepFail("Write tensioning configuration", "Wrong parameter length for Haptic warning duration");
      }
      break;
    case HWA1_acceleration_timeout:
      lInfo = lInfo / 10;
      bAccelerationTimeout[0] = lInfo;
      if (elcount(bAccelerationTimeout) == 1)
      {
//        memcpy_off(bTensioningProfileConfiguration, 3 + (12 * 25) + (92 * 8) + 12, bAccelerationTimeout, 0, 1);
        DiagSetPrimitiveByte(dWriteTensioningProfileConfigurationRequest, 1063, bAccelerationTimeout[0]);
      }
      else
      {
        testStepFail("Write tensioning configuration", "Wrong parameter length for Haptic warning duration");
      }
      break;
    case API_acceleration_timeout:
      lInfo = lInfo / 10;
      bAccelerationTimeout[0] = lInfo;
      if (elcount(bAccelerationTimeout) == 1)
      {
//        memcpy_off(bTensioningProfileConfiguration, 3 + (12 * 25) + (92 * 8) + 13, bAccelerationTimeout, 0, 1);
        DiagSetPrimitiveByte(dWriteTensioningProfileConfigurationRequest, 1064, bAccelerationTimeout[0]);
      }
      else
      {
        testStepFail("Write tensioning configuration", "Wrong parameter length for Haptic warning duration");
      }
      break;
}
  
//  diagResize(dWriteTensioningProfileConfigurationRequest, 1076);
//  diagSetPrimitiveData(dWriteTensioningProfileConfigurationRequest, bTensioningProfileConfiguration, elcount(bTensioningProfileConfiguration));
//  testReportWriteDiagObject(dWriteTensioningProfileConfigurationRequest);
//  
  testStep(@sysvar::CORE::sysLevelOfDetailStep, "", "Start variant coding sequence");
  SecVarCoding_Start();
  Wait(1000);
  
  testStep(@sysvar::CORE::sysLevelOfDetailStep, "", "Send Write tensioning profile configuration diagnostic service request with new values");
  SendDiagnosticRequest(dWriteTensioningProfileConfigurationRequest, dWriteTensioningProfileConfigurationResponse);
  CheckPositiveResponse("Check positive response of Write tensioning profile configuration diagnostic service.", dWriteTensioningProfileConfigurationRequest, dWriteTensioningProfileConfigurationResponse);
  Wait(2000);
  
  testStep(@sysvar::CORE::sysLevelOfDetailStep, "", "Stop variant coding sequence");  
  SecVarCoding_Finish();
  wait(2000);  
  
  testStep(@sysvar::CORE::sysLevelOfDetailStep, "", "Soft reset ECU.");
  ResetECU("soft");
  WaitECUInitialization();
  
  testStep(@sysvar::CORE::sysLevelOfDetailStep, "", "Authenticate ECU");
  AuthenticateECU(2);
  EnterDiagnosticSession("development");
  
  testStep(@sysvar::CORE::sysLevelOfDetailStep, "", "Read Tensioning profile configuration diagnostic service");
  SendDiagnosticRequest(dReadTensioningProfileConfigurationRequest, dReadTensioningProfileConfigurationResponse);
  CheckPositiveResponse("Check positive response of the Read Tensioning profile configuration diagnostic request", dReadTensioningProfileConfigurationRequest, dReadTensioningProfileConfigurationResponse);
  testReportWriteDiagResponse(dReadTensioningProfileConfigurationRequest);
  
}

/// <Vehicle_configuration/_x0300>
//// Write tensioning cycles configuration service  
//// bAttibute - PRE_SAFE_1 - PRE_SAFE_15, HAPTIC_WARNING1 - HAPTIC_WARNING4, ....
//// bInfo - see below
//// Example:      WriteTensioningProfileConfiguration(PRE_SAFE_5_Duration, 6000);
////               WriteTensioningProfileConfiguration(HAPTIC_WARNING1_P1_DURATION, 6000);
////               WriteTensioningProfileConfiguration(HAPTIC_WARNING2_P1_DURATION, 1500);
////               WriteTensioningProfileConfiguration(HAPTIC_WARNING3_P1_DURATION, 1500);
////               WriteTensioningProfileConfiguration(HAPTIC_WARNING4_P1_DURATION, 1500);
////               WriteTensioningProfileConfiguration(PRESAFE_acceleration_timeout, 300);
////               WriteTensioningProfileConfiguration(HWA1_acceleration_timeout, 300);
////               WriteTensioningProfileConfiguration(API_acceleration_timeout, 300);
void WriteTensioningProfileConfiguration(byte bAttribute, byte bProfile, byte bInfo)
{
  byte bReadTensioningProfileConfigurationResponse[1076];
  
  byte bDelay[2] = {0x01, 0xF4};
  byte bDuration[2] = {0x03, 0xB8};
  byte bHaptictype[1] = {0x00};
  byte bPRE_SAFE_5_Timeout[2]; //10 ms resolution
  byte bVibrationPhaseDuration[2]; //1 ms resolution
  byte bAccelerationTimeout[1] = {0x1E}; //10 ms resolution
  byte bLowForceAssociatedCounter[1] = 0x11;
  
  byte bFirstLow = 0x10;
  byte bSecondLow = 0x01;
  
  byte bFirstHigh = 0x20;
  byte bSecondHigh = 0x02;
  
  byte bFirstMax = 0x40;
  byte bSecondMax = 0x04;
  
  byte bFirstComfort = 0x80;
  byte bSecondComfort = 0x08;
  
  testStep(@sysvar::CORE::sysLevelOfDetailStep, "", "Authenticate ECU");
  AuthenticateECU(2);
  EnterDiagnosticSession("development");
  
  testStep(@sysvar::CORE::sysLevelOfDetailStep, "", "Read Tensioning profile configuration diagnostic service");
  SendDiagnosticRequest(dReadTensioningProfileConfigurationRequest, dReadTensioningProfileConfigurationResponse);
  CheckPositiveResponse("Check positive response of the Read Tensioning profile configuration diagnostic request", dReadTensioningProfileConfigurationRequest, dReadTensioningProfileConfigurationResponse);
  testReportWriteDiagResponse(dReadTensioningProfileConfigurationRequest);
  
  diagGetPrimitiveData(dReadTensioningProfileConfigurationResponse, bReadTensioningProfileConfigurationResponse, elcount(bReadTensioningProfileConfigurationResponse));
  
  diagResize(dWriteTensioningProfileConfigurationRequest, 1076);
  diagSetPrimitiveData(dWriteTensioningProfileConfigurationRequest, bReadTensioningProfileConfigurationResponse, elcount(bReadTensioningProfileConfigurationResponse));
  DiagSetPrimitiveByte(dWriteTensioningProfileConfigurationRequest, 0, 0x2E);
  DiagSetPrimitiveByte(dWriteTensioningProfileConfigurationRequest, 1, 0x03);
  DiagSetPrimitiveByte(dWriteTensioningProfileConfigurationRequest, 2, 0x00);
  
  switch(bProfile)
  {
    case PRE_SAFE_15:
      if (bInfo == Low) 
        DiagSetPrimitiveByte(dWriteTensioningProfileConfigurationRequest, 1062 + 3, bSecondLow); //Low force counter
      else 
        if (bInfo == High) 
          DiagSetPrimitiveByte(dWriteTensioningProfileConfigurationRequest, 1062 + 3, bSecondHigh); //High force counter
        else 
          if (bInfo == Max) 
            DiagSetPrimitiveByte(dWriteTensioningProfileConfigurationRequest, 1062 + 3, bSecondMax); //Max force counter
          else
            if (bInfo == Comfort)
              DiagSetPrimitiveByte(dWriteTensioningProfileConfigurationRequest, 1062 + 3, bSecondComfort); //Max force counter
            else
            testStepFail("Write tensioning configuration", "Wrong value for associated counter");
      break;
    case PRE_SAFE_14:
      if (bInfo == Low) 
        DiagSetPrimitiveByte(dWriteTensioningProfileConfigurationRequest, 1063 + 3, bReadTensioningProfileConfigurationResponse[1063 + 3] & 0x0F | bFirstLow ); //Low force counter
      else 
        if (bInfo == High) 
          DiagSetPrimitiveByte(dWriteTensioningProfileConfigurationRequest, 1063 + 3, bReadTensioningProfileConfigurationResponse[1063 + 3] & 0x0F | bFirstHigh); //High force counter
        else 
          if (bInfo == Max) 
            DiagSetPrimitiveByte(dWriteTensioningProfileConfigurationRequest, 1063 + 3, bReadTensioningProfileConfigurationResponse[1063 + 3] & 0x0F | bFirstMax); //Max force counter
          else
            if (bInfo == Comfort)
              DiagSetPrimitiveByte(dWriteTensioningProfileConfigurationRequest, 1063 + 3, bReadTensioningProfileConfigurationResponse[1063 + 3] & 0x0F | bFirstComfort); //Max force counter
            else
            testStepFail("Write tensioning configuration", "Wrong value for associated counter");
      break;
    case PRE_SAFE_13:
      if (bInfo == Low) 
        DiagSetPrimitiveByte(dWriteTensioningProfileConfigurationRequest, 1063 + 3, bReadTensioningProfileConfigurationResponse[1063 + 3] & 0xF0 | bSecondLow ); //Low force counter
      else 
        if (bInfo == High) 
          DiagSetPrimitiveByte(dWriteTensioningProfileConfigurationRequest, 1063 + 3, bReadTensioningProfileConfigurationResponse[1063 + 3] & 0xF0 | bSecondHigh); //High force counter
        else 
          if (bInfo == Max) 
            DiagSetPrimitiveByte(dWriteTensioningProfileConfigurationRequest, 1063 + 3, bReadTensioningProfileConfigurationResponse[1063 + 3] & 0xF0 | bSecondMax); //Max force counter
          else
            if (bInfo == Comfort)
              DiagSetPrimitiveByte(dWriteTensioningProfileConfigurationRequest, 1063 + 3, bReadTensioningProfileConfigurationResponse[1063 + 3] & 0xF0 | bSecondComfort); //Max force counter
            else
            testStepFail("Write tensioning configuration", "Wrong value for associated counter");
      break;
    case PRE_SAFE_12:
      if (bInfo == Low) 
        DiagSetPrimitiveByte(dWriteTensioningProfileConfigurationRequest, 1064 + 3, bReadTensioningProfileConfigurationResponse[1064 + 3] & 0x0F | bFirstLow ); //Low force counter
      else 
        if (bInfo == High) 
          DiagSetPrimitiveByte(dWriteTensioningProfileConfigurationRequest, 1064 + 3, bReadTensioningProfileConfigurationResponse[1064 + 3] & 0x0F | bFirstHigh); //High force counter
        else 
          if (bInfo == Max) 
            DiagSetPrimitiveByte(dWriteTensioningProfileConfigurationRequest, 1064 + 3, bReadTensioningProfileConfigurationResponse[1064 + 3] & 0x0F | bFirstMax); //Max force counter
          else
            if (bInfo == Comfort)
              DiagSetPrimitiveByte(dWriteTensioningProfileConfigurationRequest, 1064 + 3, bReadTensioningProfileConfigurationResponse[1064 + 3] & 0x0F | bFirstComfort); //Max force counter
            else
            testStepFail("Write tensioning configuration", "Wrong value for associated counter");
      break;
    case PRE_SAFE_11:
      if (bInfo == Low) 
        DiagSetPrimitiveByte(dWriteTensioningProfileConfigurationRequest, 1064 + 3, bReadTensioningProfileConfigurationResponse[1064 + 3] & 0xF0 | bSecondLow ); //Low force counter
      else 
        if (bInfo == High) 
          DiagSetPrimitiveByte(dWriteTensioningProfileConfigurationRequest, 1064 + 3, bReadTensioningProfileConfigurationResponse[1064 + 3] & 0xF0 | bSecondHigh); //High force counter
        else 
          if (bInfo == Max) 
            DiagSetPrimitiveByte(dWriteTensioningProfileConfigurationRequest, 1064 + 3, bReadTensioningProfileConfigurationResponse[1064 + 3] & 0xF0 | bSecondMax); //Max force counter
          else
            if (bInfo == Comfort)
              DiagSetPrimitiveByte(dWriteTensioningProfileConfigurationRequest, 1064 + 3, bReadTensioningProfileConfigurationResponse[1064 + 3] & 0xF0 | bSecondComfort); //Max force counter
            else
            testStepFail("Write tensioning configuration", "Wrong value for associated counter");
      break;
    case PRE_SAFE_10:
      if (bInfo == Low) 
        DiagSetPrimitiveByte(dWriteTensioningProfileConfigurationRequest, 1065 + 3, bReadTensioningProfileConfigurationResponse[1065 + 3] & 0x0F | bFirstLow ); //Low force counter
      else 
        if (bInfo == High) 
          DiagSetPrimitiveByte(dWriteTensioningProfileConfigurationRequest, 1065 + 3, bReadTensioningProfileConfigurationResponse[1065 + 3] & 0x0F | bFirstHigh); //High force counter
        else 
          if (bInfo == Max) 
            DiagSetPrimitiveByte(dWriteTensioningProfileConfigurationRequest, 1065 + 3, bReadTensioningProfileConfigurationResponse[1065 + 3] & 0x0F | bFirstMax); //Max force counter
          else
            if (bInfo == Comfort)
              DiagSetPrimitiveByte(dWriteTensioningProfileConfigurationRequest, 1065 + 3, bReadTensioningProfileConfigurationResponse[1065 + 3] & 0x0F | bFirstComfort); //Max force counter
            else
            testStepFail("Write tensioning configuration", "Wrong value for associated counter");
      break;
    case PRE_SAFE_9:
      if (bInfo == Low) 
        DiagSetPrimitiveByte(dWriteTensioningProfileConfigurationRequest, 1065 + 3, bReadTensioningProfileConfigurationResponse[1065 + 3] & 0xF0 | bSecondLow ); //Low force counter
      else 
        if (bInfo == High) 
          DiagSetPrimitiveByte(dWriteTensioningProfileConfigurationRequest, 1065 + 3, bReadTensioningProfileConfigurationResponse[1065 + 3] & 0xF0 | bSecondHigh); //High force counter
        else 
          if (bInfo == Max) 
            DiagSetPrimitiveByte(dWriteTensioningProfileConfigurationRequest, 1065 + 3, bReadTensioningProfileConfigurationResponse[1065 + 3] & 0xF0 | bSecondMax); //Max force counter
          else
            if (bInfo == Comfort)
              DiagSetPrimitiveByte(dWriteTensioningProfileConfigurationRequest, 1065 + 3, bReadTensioningProfileConfigurationResponse[1065 + 3] & 0xF0 | bSecondComfort); //Max force counter
            else
            testStepFail("Write tensioning configuration", "Wrong value for associated counter");
      break;
    case HAPTIC_WARNING4:
      if (bInfo == Low) 
        DiagSetPrimitiveByte(dWriteTensioningProfileConfigurationRequest, 1066 + 3, bReadTensioningProfileConfigurationResponse[1066 + 3] & 0x0F | bFirstLow ); //Low force counter
      else 
        if (bInfo == High) 
          DiagSetPrimitiveByte(dWriteTensioningProfileConfigurationRequest, 1066 + 3, bReadTensioningProfileConfigurationResponse[1066 + 3] & 0x0F | bFirstHigh); //High force counter
        else 
          if (bInfo == Max) 
            DiagSetPrimitiveByte(dWriteTensioningProfileConfigurationRequest, 1066 + 3, bReadTensioningProfileConfigurationResponse[1066 + 3] & 0x0F | bFirstMax); //Max force counter
          else
            if (bInfo == Comfort)
              DiagSetPrimitiveByte(dWriteTensioningProfileConfigurationRequest, 1066 + 3, bReadTensioningProfileConfigurationResponse[1066 + 3] & 0x0F | bFirstComfort); //Max force counter
            else
            testStepFail("Write tensioning configuration", "Wrong value for associated counter");
      break;
    case HAPTIC_WARNING3:
      if (bInfo == Low) 
        DiagSetPrimitiveByte(dWriteTensioningProfileConfigurationRequest, 1066 + 3, bReadTensioningProfileConfigurationResponse[1066 + 3] & 0xF0 | bSecondLow ); //Low force counter
      else 
        if (bInfo == High) 
          DiagSetPrimitiveByte(dWriteTensioningProfileConfigurationRequest, 1066 + 3, bReadTensioningProfileConfigurationResponse[1066 + 3] & 0xF0 | bSecondHigh); //High force counter
        else 
          if (bInfo == Max) 
            DiagSetPrimitiveByte(dWriteTensioningProfileConfigurationRequest, 1066 + 3, bReadTensioningProfileConfigurationResponse[1066 + 3] & 0xF0 | bSecondMax); //Max force counter
          else
            if (bInfo == Comfort)
              DiagSetPrimitiveByte(dWriteTensioningProfileConfigurationRequest, 1066 + 3, bReadTensioningProfileConfigurationResponse[1066 + 3] & 0xF0 | bSecondComfort); //Max force counter
            else
            testStepFail("Write tensioning configuration", "Wrong value for associated counter");
      break;
    case HAPTIC_WARNING2:
      if (bInfo == Low) 
        DiagSetPrimitiveByte(dWriteTensioningProfileConfigurationRequest, 1067 + 3, bReadTensioningProfileConfigurationResponse[1067 + 3] & 0x0F | bFirstLow ); //Low force counter
      else 
        if (bInfo == High) 
          DiagSetPrimitiveByte(dWriteTensioningProfileConfigurationRequest, 1067 + 3, bReadTensioningProfileConfigurationResponse[1067 + 3] & 0x0F | bFirstHigh); //High force counter
        else 
          if (bInfo == Max) 
            DiagSetPrimitiveByte(dWriteTensioningProfileConfigurationRequest, 1067 + 3, bReadTensioningProfileConfigurationResponse[1067 + 3] & 0x0F | bFirstMax); //Max force counter
          else
            if (bInfo == Comfort)
              DiagSetPrimitiveByte(dWriteTensioningProfileConfigurationRequest, 1067 + 3, bReadTensioningProfileConfigurationResponse[1067 + 3] & 0x0F | bFirstComfort); //Max force counter
            else
            testStepFail("Write tensioning configuration", "Wrong value for associated counter");
      break;
    case HAPTIC_WARNING1:
      if (bInfo == Low) 
        DiagSetPrimitiveByte(dWriteTensioningProfileConfigurationRequest, 1067 + 3, bReadTensioningProfileConfigurationResponse[1067 + 3] & 0xF0 | bSecondLow ); //Low force counter
      else 
        if (bInfo == High) 
          DiagSetPrimitiveByte(dWriteTensioningProfileConfigurationRequest, 1067 + 3, bReadTensioningProfileConfigurationResponse[1067 + 3] & 0xF0 | bSecondHigh); //High force counter
        else 
          if (bInfo == Max) 
            DiagSetPrimitiveByte(dWriteTensioningProfileConfigurationRequest, 1067 + 3, bReadTensioningProfileConfigurationResponse[1067 + 3] & 0xF0 | bSecondMax); //Max force counter
          else
            if (bInfo == Comfort)
              DiagSetPrimitiveByte(dWriteTensioningProfileConfigurationRequest, 1067 + 3, bReadTensioningProfileConfigurationResponse[1067 + 3] & 0xF0 | bSecondComfort); //Max force counter
            else
            testStepFail("Write tensioning configuration", "Wrong value for associated counter");
      break;
    case PRE_SAFE_7:
      if (bInfo == Low) 
        DiagSetPrimitiveByte(dWriteTensioningProfileConfigurationRequest, 1068 + 3, bReadTensioningProfileConfigurationResponse[1068 + 3] & 0x0F | bFirstLow ); //Low force counter
      else 
        if (bInfo == High) 
          DiagSetPrimitiveByte(dWriteTensioningProfileConfigurationRequest, 1068 + 3, bReadTensioningProfileConfigurationResponse[1068 + 3] & 0x0F | bFirstHigh); //High force counter
        else 
          if (bInfo == Max) 
            DiagSetPrimitiveByte(dWriteTensioningProfileConfigurationRequest, 1068 + 3, bReadTensioningProfileConfigurationResponse[1068 + 3] & 0x0F | bFirstMax); //Max force counter
          else
            if (bInfo == Comfort)
              DiagSetPrimitiveByte(dWriteTensioningProfileConfigurationRequest, 1068 + 3, bReadTensioningProfileConfigurationResponse[1068 + 3] & 0x0F | bFirstComfort); //Max force counter
            else
            testStepFail("Write tensioning configuration", "Wrong value for associated counter");
      break;
    case PRE_SAFE_6:
      if (bInfo == Low) 
        DiagSetPrimitiveByte(dWriteTensioningProfileConfigurationRequest, 1068 + 3, bReadTensioningProfileConfigurationResponse[1068 + 3] & 0xF0 | bSecondLow ); //Low force counter
      else 
        if (bInfo == High) 
          DiagSetPrimitiveByte(dWriteTensioningProfileConfigurationRequest, 1068 + 3, bReadTensioningProfileConfigurationResponse[1068 + 3] & 0xF0 | bSecondHigh); //High force counter
        else 
          if (bInfo == Max) 
            DiagSetPrimitiveByte(dWriteTensioningProfileConfigurationRequest, 1068 + 3, bReadTensioningProfileConfigurationResponse[1068 + 3] & 0xF0 | bSecondMax); //Max force counter
          else
            if (bInfo == Comfort)
              DiagSetPrimitiveByte(dWriteTensioningProfileConfigurationRequest, 1068 + 3, bReadTensioningProfileConfigurationResponse[1068 + 3] & 0xF0 | bSecondComfort); //Max force counter
            else
            testStepFail("Write tensioning configuration", "Wrong value for associated counter");
      break;
    case PRE_SAFE_5:
      if (bInfo == Low) 
        DiagSetPrimitiveByte(dWriteTensioningProfileConfigurationRequest, 1069 + 3, bReadTensioningProfileConfigurationResponse[1069 + 3] & 0x0F | bFirstLow ); //Low force counter
      else 
        if (bInfo == High) 
          DiagSetPrimitiveByte(dWriteTensioningProfileConfigurationRequest, 1069 + 3, bReadTensioningProfileConfigurationResponse[1069 + 3] & 0x0F | bFirstHigh); //High force counter
        else 
          if (bInfo == Max) 
            DiagSetPrimitiveByte(dWriteTensioningProfileConfigurationRequest, 1069 + 3, bReadTensioningProfileConfigurationResponse[1069 + 3] & 0x0F | bFirstMax); //Max force counter
          else
            if (bInfo == Comfort)
              DiagSetPrimitiveByte(dWriteTensioningProfileConfigurationRequest, 1069 + 3, bReadTensioningProfileConfigurationResponse[1069 + 3] & 0x0F | bFirstComfort); //Max force counter
            else
            testStepFail("Write tensioning configuration", "Wrong value for associated counter");
      break;
    case PRE_SAFE_4:
      if (bInfo == Low) 
        DiagSetPrimitiveByte(dWriteTensioningProfileConfigurationRequest, 1069 + 3, bReadTensioningProfileConfigurationResponse[1069 + 3] & 0xF0 | bSecondLow ); //Low force counter
      else 
        if (bInfo == High) 
          DiagSetPrimitiveByte(dWriteTensioningProfileConfigurationRequest, 1069 + 3, bReadTensioningProfileConfigurationResponse[1069 + 3] & 0xF0 | bSecondHigh); //High force counter
        else 
          if (bInfo == Max) 
            DiagSetPrimitiveByte(dWriteTensioningProfileConfigurationRequest, 1069 + 3, bReadTensioningProfileConfigurationResponse[1069 + 3] & 0xF0 | bSecondMax); //Max force counter
          else
            if (bInfo == Comfort)
              DiagSetPrimitiveByte(dWriteTensioningProfileConfigurationRequest, 1069 + 3, bReadTensioningProfileConfigurationResponse[1069 + 3] & 0xF0 | bSecondComfort); //Max force counter
            else
            testStepFail("Write tensioning configuration", "Wrong value for associated counter");
      break;
    case PRE_SAFE_3:
      if (bInfo == Low) 
        DiagSetPrimitiveByte(dWriteTensioningProfileConfigurationRequest, 1070 + 3, bReadTensioningProfileConfigurationResponse[1070 + 3] & 0x0F | bFirstLow ); //Low force counter
      else 
        if (bInfo == High) 
          DiagSetPrimitiveByte(dWriteTensioningProfileConfigurationRequest, 1070 + 3, bReadTensioningProfileConfigurationResponse[1070 + 3] & 0x0F | bFirstHigh); //High force counter
        else 
          if (bInfo == Max) 
            DiagSetPrimitiveByte(dWriteTensioningProfileConfigurationRequest, 1070 + 3, bReadTensioningProfileConfigurationResponse[1070 + 3] & 0x0F | bFirstMax); //Max force counter
          else
            if (bInfo == Comfort)
              DiagSetPrimitiveByte(dWriteTensioningProfileConfigurationRequest, 1070 + 3, bReadTensioningProfileConfigurationResponse[1070 + 3] & 0x0F | bFirstComfort); //Max force counter
            else
            testStepFail("Write tensioning configuration", "Wrong value for associated counter");
      break;
    case PRE_SAFE_1:
      if (bInfo == Low) 
        DiagSetPrimitiveByte(dWriteTensioningProfileConfigurationRequest, 1070 + 3, bReadTensioningProfileConfigurationResponse[1070 + 3] & 0xF0 | bSecondLow ); //Low force counter
      else 
        if (bInfo == High) 
          DiagSetPrimitiveByte(dWriteTensioningProfileConfigurationRequest, 1070 + 3, bReadTensioningProfileConfigurationResponse[1070 + 3] & 0xF0 | bSecondHigh); //High force counter
        else 
          if (bInfo == Max) 
            DiagSetPrimitiveByte(dWriteTensioningProfileConfigurationRequest, 1070 + 3, bReadTensioningProfileConfigurationResponse[1070 + 3] & 0xF0 | bSecondMax); //Max force counter
          else
            if (bInfo == Comfort)
              DiagSetPrimitiveByte(dWriteTensioningProfileConfigurationRequest, 1070 + 3, bReadTensioningProfileConfigurationResponse[1070 + 3] & 0xF0 | bSecondComfort); //Max force counter
            else
            testStepFail("Write tensioning configuration", "Wrong value for associated counter");
      break;
    case PRE_SAFE_CURVE_4:
      if (bInfo == Low) 
        DiagSetPrimitiveByte(dWriteTensioningProfileConfigurationRequest, 1071 + 3, bReadTensioningProfileConfigurationResponse[1071 + 3] & 0x0F | bFirstLow ); //Low force counter
      else 
        if (bInfo == High) 
          DiagSetPrimitiveByte(dWriteTensioningProfileConfigurationRequest, 1071 + 3, bReadTensioningProfileConfigurationResponse[1071 + 3] & 0x0F | bFirstHigh); //High force counter
        else 
          if (bInfo == Max) 
            DiagSetPrimitiveByte(dWriteTensioningProfileConfigurationRequest, 1071 + 3, bReadTensioningProfileConfigurationResponse[1071 + 3] & 0x0F | bFirstMax); //Max force counter
          else
            if (bInfo == Comfort)
              DiagSetPrimitiveByte(dWriteTensioningProfileConfigurationRequest, 1071 + 3, bReadTensioningProfileConfigurationResponse[1071 + 3] & 0x0F | bFirstComfort); //Max force counter
            else
            testStepFail("Write tensioning configuration", "Wrong value for associated counter");
      break;
    case PRE_SAFE_CURVE_3:
      if (bInfo == Low) 
        DiagSetPrimitiveByte(dWriteTensioningProfileConfigurationRequest, 1071 + 3, bReadTensioningProfileConfigurationResponse[1071 + 3] & 0xF0 | bSecondLow ); //Low force counter
      else 
        if (bInfo == High) 
          DiagSetPrimitiveByte(dWriteTensioningProfileConfigurationRequest, 1071 + 3, bReadTensioningProfileConfigurationResponse[1071 + 3] & 0xF0 | bSecondHigh); //High force counter
        else 
          if (bInfo == Max) 
            DiagSetPrimitiveByte(dWriteTensioningProfileConfigurationRequest, 1071 + 3, bReadTensioningProfileConfigurationResponse[1071 + 3] & 0xF0 | bSecondMax); //Max force counter
          else
            if (bInfo == Comfort)
              DiagSetPrimitiveByte(dWriteTensioningProfileConfigurationRequest, 1071 + 3, bReadTensioningProfileConfigurationResponse[1071 + 3] & 0xF0 | bSecondComfort); //Max force counter
            else
            testStepFail("Write tensioning configuration", "Wrong value for associated counter");
      break;
    case PRE_SAFE_CURVE_2:
      if (bInfo == Low) 
        DiagSetPrimitiveByte(dWriteTensioningProfileConfigurationRequest, 1072 + 3, bReadTensioningProfileConfigurationResponse[1072 + 3] & 0x0F | bFirstLow ); //Low force counter
      else 
        if (bInfo == High) 
          DiagSetPrimitiveByte(dWriteTensioningProfileConfigurationRequest, 1072 + 3, bReadTensioningProfileConfigurationResponse[1072 + 3] & 0x0F | bFirstHigh); //High force counter
        else 
          if (bInfo == Max) 
            DiagSetPrimitiveByte(dWriteTensioningProfileConfigurationRequest, 1072 + 3, bReadTensioningProfileConfigurationResponse[1072 + 3] & 0x0F | bFirstMax); //Max force counter
          else
            if (bInfo == Comfort)
              DiagSetPrimitiveByte(dWriteTensioningProfileConfigurationRequest, 1072 + 3, bReadTensioningProfileConfigurationResponse[1072 + 3] & 0x0F | bFirstComfort); //Max force counter
            else
            testStepFail("Write tensioning configuration", "Wrong value for associated counter");
      break;
    case PRE_SAFE_CURVE_1:
      if (bInfo == Low) 
        DiagSetPrimitiveByte(dWriteTensioningProfileConfigurationRequest, 1072 + 3, bReadTensioningProfileConfigurationResponse[1072 + 3] & 0xF0 | bSecondLow ); //Low force counter
      else 
        if (bInfo == High) 
          DiagSetPrimitiveByte(dWriteTensioningProfileConfigurationRequest, 1072 + 3, bReadTensioningProfileConfigurationResponse[1072 + 3] & 0xF0 | bSecondHigh); //High force counter
        else 
          if (bInfo == Max) 
            DiagSetPrimitiveByte(dWriteTensioningProfileConfigurationRequest, 1072 + 3, bReadTensioningProfileConfigurationResponse[1072 + 3] & 0xF0 | bSecondMax); //Max force counter
          else
            if (bInfo == Comfort)
              DiagSetPrimitiveByte(dWriteTensioningProfileConfigurationRequest, 1072 + 3, bReadTensioningProfileConfigurationResponse[1072 + 3] & 0xF0 | bSecondComfort); //Max force counter
            else
            testStepFail("Write tensioning configuration", "Wrong value for associated counter");
      break;
    default:
      testStepFail("Write tensioning configuration", "Wrong parameter value");
    break;
  }
  
  testStep(@sysvar::CORE::sysLevelOfDetailStep, "", "Start variant coding sequence");
  SecVarCoding_Start();
  Wait(1000);
  
  testStep(@sysvar::CORE::sysLevelOfDetailStep, "", "Send Write tensioning profile configuration diagnostic service request with new values");
  SendDiagnosticRequest(dWriteTensioningProfileConfigurationRequest, dWriteTensioningProfileConfigurationResponse);
  CheckPositiveResponse("Check positive response of Write tensioning profile configuration diagnostic service.", dWriteTensioningProfileConfigurationRequest, dWriteTensioningProfileConfigurationResponse);
  Wait(2000);
  
  testStep(@sysvar::CORE::sysLevelOfDetailStep, "", "Stop variant coding sequence");
  SecVarCoding_Finish();
  wait(2000);  
  
  testStep(@sysvar::CORE::sysLevelOfDetailStep, "", "Soft reset ECU.");
  ResetECU("soft");
  WaitECUInitialization();
  
  testStep(@sysvar::CORE::sysLevelOfDetailStep, "", "Authenticate ECU");
  AuthenticateECU(2);
  EnterDiagnosticSession("development");
  
  testStep(@sysvar::CORE::sysLevelOfDetailStep, "", "Read Tensioning profile configuration diagnostic service");
  SendDiagnosticRequest(dReadTensioningProfileConfigurationRequest, dReadTensioningProfileConfigurationResponse);
  CheckPositiveResponse("Check positive response of the Read Tensioning profile configuration diagnostic request", dReadTensioningProfileConfigurationRequest, dReadTensioningProfileConfigurationResponse);
  testReportWriteDiagResponse(dReadTensioningProfileConfigurationRequest);
  
}



/// <Profile_management>
// Check if input profile is present on RBTM_XY_Stat_ST3 status frame.
// bProfile - Profile request ID 
// Example: ReadBeltProfile(PRE_SAFE_1)
void ReadBeltProfile(byte bProfile)
{
  char targetName[100];
  
  testWaitForTimeout(15);
  diagGetCurrentEcu(targetName, elcount(targetName));
  if (strncmp(targetName, sTargetECUFrontLeftName, elcount(targetName)) == 0)
  {
    if($RBTM_FL_Tens_ST3::RBTMFL_Actv_Lvl_ST35.raw == 0x3F )
    {         
      testStepFail(@sysvar::CORE::sysLevelOfDetailFail, "", "RBTMFL_Actv_Lvl_ST35 value is 0x3F ( Signal not available )");
    }
    else 
    {
      testStep(@sysvar::CORE::sysLevelOfDetailStep, "", "Check started profile on RBTMFL_Actv_Lvl_ST35");
      if ($RBTM_FL_Tens_ST3::RBTMFL_Actv_Lvl_ST35.raw == CYCLE[bProfile].SF_ID)
      {
        testStepPass(@sysvar::CORE::sysLevelOfDetailPass, "","Cycle 0x%02X - %s is detected on status frame left side", CYCLE[bProfile].SF_ID, CYCLE[bProfile].SF_Name);
      }
      else
      {
        if ( $RBTM_FL_Tens_ST3::RBTMFL_Actv_Lvl_ST35.raw == CYCLE[BSR_1].SF_ID )
        {
          testStepPass(@sysvar::CORE::sysLevelOfDetailPass, "","Cycle 0x%02X - %s is detected on status frame left side", CYCLE[bProfile].SF_ID, CYCLE[bProfile].SF_Name);
        }
        else
        {
          testStepFail(@sysvar::CORE::sysLevelOfDetailFail, "", "Cycle 0x%X - %s is NOT detected on status frame left side. Current profile 0x%02X - %s", CYCLE[bProfile].SF_ID, CYCLE[bProfile].SF_Name, getSignal(RBTMFL_Actv_Lvl_ST35), CYCLE[getSignal(RBTMFL_Actv_Lvl_ST35)].SF_Name);
        }
      }
    }
  }
  else
  {
    if($RBTM_FR_Tens_ST3::RBTMFR_Actv_Lvl_ST35.raw == 0x3F)
    {
      testStepFail(@sysvar::CORE::sysLevelOfDetailFail, "", "RBTMFR_Actv_Lvl_ST35 value is 0x3F ( Signal not available )");
    }
    else
    {
      testStep(@sysvar::CORE::sysLevelOfDetailStep, "", "Check started profile on RBTMFR_Actv_Lvl_ST35");
      if ($RBTM_FR_Tens_ST3::RBTMFR_Actv_Lvl_ST35.raw == CYCLE[bProfile].SF_ID)
      {
        testStepPass(@sysvar::CORE::sysLevelOfDetailPass, "","Cycle 0x%02X - %s is detected on status frame right side", CYCLE[bProfile].SF_ID, CYCLE[bProfile].SF_Name);
      }
      else
      {
        if ( $RBTM_FR_Tens_ST3::RBTMFR_Actv_Lvl_ST35.raw == CYCLE[BSR_1].SF_ID )
        {
          testStepPass(@sysvar::CORE::sysLevelOfDetailPass, "","Cycle 0x%02X - %s is detected on status frame right side", CYCLE[bProfile].SF_ID, CYCLE[bProfile].SF_Name);
        }
        else
        {
          testStepFail(@sysvar::CORE::sysLevelOfDetailFail, "", "Cycle 0x%X - %s is NOT detected on status frame right side. Current profile 0x%02X - %s", CYCLE[bProfile].SF_ID, CYCLE[bProfile].SF_Name, getSignal(RBTMFR_Actv_Lvl_ST35), CYCLE[getSignal(RBTMFR_Actv_Lvl_ST35)].SF_Name);
        }
      }
    }   
  }
}


/// <Profile_management>
void WaitCycleToFinish()
{
  stack int iCount;
  stack int iFlag;
  stack int fMaxTime = 26000;
  stack int iTotalFlag = 0;
  stack int iTotalFlagTime = 1050;
  stack int index;
  stack byte bAllCyclesFinished = 0;
  stack byte bLastCycle = 0xFF;
  stack char cCurrentCycle[100];
  message * MeasurementFrame;
  stack float fStartTime;
  stack float fCycleStartTime;
  stack float fCurrentTime;
  
  fStartTime = timeNow() / 100; // simulation time in ms.

  if (TestWaitForMessage(@sysvar::ProjectConfiguration::sysMeasurementFrameID, 30) != 1) // Check if MF is active.
  {
    testStepFail(@sysvar::CORE::sysLevelOfDetailFail, "-", "Measurement Frame not detected in 30 ms.");
    return;
  }
  TestGetWaitEventMsgData(MeasurementFrame);
  if(TestGetWaitEventMsgData(MeasurementFrame) != 0)
  {   
     testStepFail(@sysvar::CORE::sysLevelOfDetailFail, "-", "Measurement Frame: Data access could not be executed, the last event was not a message event.");
     return;
  }

  if (MeasurementFrame.byte(0) == 14)
  {
    testStepFail(@sysvar::CORE::sysLevelOfDetailFail, "-", "Detect_Cycle_Step for block 13 / 14 not implemented");
    return;
  }
  else if (MeasurementFrame.byte(0) == 13)
  {
    testStepFail(@sysvar::CORE::sysLevelOfDetailFail, "-", "Detect_Cycle_Step for block 13 / 14 not implemented");
    return;
  }
  else
  {
    iCount = 0;
    while((MeasurementFrame.byte(0) != 0x01) && (MeasurementFrame.byte(0) != 0x0F) && (MeasurementFrame.byte(0) != 0x18) && (iCount < 20)) // Check if proper MF blocks are active.
    {
      TestWaitForMessage(MeasurementFrame.id, 5);
      TestGetWaitEventMsgData(MeasurementFrame);
      iCount++;
    }
     
    if(iCount >= 20)
    {
      testStepFail(@sysvar::CORE::sysLevelOfDetailFail, "-", "Incorrect MF active block(s); Measurement Frame block (1 or 15 or 24) not detected in 100 ms");
      return;
    }
    else
    {
      while(bAllCyclesFinished != 1)
      {
        fCycleStartTime = timeNow() / 100; // simulation time in ms.
        iFlag = 0;
        testStep(@sysvar::CORE::sysLevelOfDetailStep, "", "Waiting for current cycle to finish...");
        
        while((MeasurementFrame.byte(1) != 0xFF) && (iFlag < fMaxTime))
        {          
          if(MeasurementFrame.byte(1) != bLastCycle)
          {
            bLastCycle = MeasurementFrame.byte(1);
            testStep(@sysvar::CORE::sysLevelOfDetailStep, "", "Current cycle detected is 0x%02x", bLastCycle); 
          }
          
          testWaitForTimeout(5);
          iFlag++;
          
          if (TestWaitForMessage(MeasurementFrame.id, 30) != 1)
          {
            testStepFail(@sysvar::CORE::sysLevelOfDetailFail, "-", "Measurement Frame not detected in 30 ms.");
            return;
          }
          TestGetWaitEventMsgData(MeasurementFrame);
          
          iCount = 0;
          while((MeasurementFrame.byte(0) != 0x01) && (MeasurementFrame.byte(0) != 0x0F) && (MeasurementFrame.byte(0) != 0x18) && (iCount < 20))
          {
            TestWaitForMessage(MeasurementFrame.id, 5);
            TestGetWaitEventMsgData(MeasurementFrame);
            iCount++;
          }
          
          if(iCount >= 20)
          {
            testStepFail(@sysvar::CORE::sysLevelOfDetailFail, "-", "Incorrect MF active block(s); Measurement Frame block (1 or 15 or 24) no longer detected.");
            return;
          }  
        }
        
        fCurrentTime = (timeNow() / 100) - fCycleStartTime;
      
        if(iFlag >= fMaxTime) 
        {
         testStepFail(@sysvar::CORE::sysLevelOfDetailFail, "-", "Cycle 0xFF was not detected in %.f ms (simulation time).", fCurrentTime);
         bAllCyclesFinished = 1;
         return;
        }
        else
        {
          testWaitForTimeout(70);
          if (TestWaitForMessage(MeasurementFrame.id, 30) != 1)
          {
            testStepFail(@sysvar::CORE::sysLevelOfDetailFail, "-", "Measurement Frame not detected in 30 ms.");
            return;
          }
          TestGetWaitEventMsgData(MeasurementFrame);
          
          iCount = 0;
          while((MeasurementFrame.byte(0) != 0x01) && (MeasurementFrame.byte(0) != 0x0F) && (MeasurementFrame.byte(0) != 0x18) && (iCount < 20))
          {
            TestWaitForMessage(MeasurementFrame.id, 5);
            TestGetWaitEventMsgData(MeasurementFrame);
            iCount++;
          }
          
          if(iCount >= 20)
          {
            testStepFail(@sysvar::CORE::sysLevelOfDetailFail, "-", "Incorrect MF active block(s); Measurement Frame block (1 or 15 or 24) no longer detected.");
            return;
          }

          if(MeasurementFrame.byte(1) != 0xFF)
          {
            bAllCyclesFinished = 0;
            testStep(@sysvar::CORE::sysLevelOfDetailStep, "", "Cycle %x started within 100 ms after cycle %x ended.", MeasurementFrame.byte(1), bLastCycle);
          }
          else
          {
            fCurrentTime = (timeNow() / 100) - fStartTime;
            testStep(@sysvar::CORE::sysLevelOfDetailStep, "", "All cycles finished in %.f ms (simulation time)", fCurrentTime - 70);
            bAllCyclesFinished = 1;
          }

          iTotalFlag++;
          if(iTotalFlag >= iTotalFlagTime)
          {
            fCurrentTime = (timeNow() / 100) - fStartTime;
            testStepFail(@sysvar::CORE::sysLevelOfDetailFail, "-", "Cycle 0xFF was not detected in %.f ms", fCurrentTime);
            return;
          }
        }
      }
    }
  }
}

/// <Profile_management>
// Check the current started profile on Measurement Frame.
// "cInputCycle" = cycle that is checked.
//               Input option 1: "Precrash_2".
//               Input option 2: "0x02".
// Example:      CheckStartedProfile("BSR").
// Output:       Test Step Fail/Pass if cycle is not active/active on MF.
/// <Profile_management>
void CheckStartedProfile(byte bProfile)
{
  char cInputCycle_UpperCase[20];
  char EvalManStepString[100];
  int index;
  int iCount;
  byte bCycle;
  float fStartTime;
  message * MeasurementFrame;
  
  bCycle = 0xAA;
  fStartTime = timeNow() / 100;

   if (TestWaitForMessage(@sysvar::ProjectConfiguration::sysMeasurementFrameID, 30) == 1) // Check if MF is active.
  {
    if(TestGetWaitEventMsgData(MeasurementFrame) == 0)
    {   
      iCount = 0;
      while((MeasurementFrame.byte(0) != 0x01) && (MeasurementFrame.byte(0) != 0x0F) && (MeasurementFrame.byte(0) != 0x18) && (iCount < 20)) // Check if proper MF blocks are active.
      {
        TestWaitForMessage(MeasurementFrame.id, 5);
        TestGetWaitEventMsgData(MeasurementFrame);
        iCount++;
      }
    }
    else
    {
      testStepFail(@sysvar::CORE::sysLevelOfDetailFail, "-", "Measurement Frame: Data access could not be executed, the last event was not a message event.");
      return;
    }
  }
  else 
  {
    testStepFail(@sysvar::CORE::sysLevelOfDetailFail, "-", "Measurement Frame not detected in 30 ms.");
    return;
  }

  if(iCount >= 20)
  {
    testStepFail(@sysvar::CORE::sysLevelOfDetailFail, "-", "Incorrect MF active block(s); Measurement Frame block (1 or 15 or 24) not detected in %f ms", (timeNow() / 100) - fStartTime);
    return;
  }
  else
  {
    snprintf(EvalManStepString, elCount(EvalManStepString), "Verify that Belt Profile %s is active on measurement frame", CYCLE[bProfile].Launch_Name);
    EvalManStepEqual(EvalManStepString, MeasurementFrame.byte(1), CYCLE[bProfile].MF_ID);
  }  
}

/// <Profile_management>
// Writes the default cycle parameters.
void WriteCycleParameters()
{ 
  memcpy(bDefaultCycleRequest, bDefaultCycleLibraryRequest, elcount(bDefaultCycleLibraryRequest));
  memcpy_off(bDefaultCycleRequest, 3, bDefaultCycleValues, 0, elcount(bDefaultCycleValues));
  SendDiagnosticRequest(dWriteCycleConfigRequest, dWriteCycleConfigResponse, bDefaultCycleRequest);
  CheckPositiveResponse("Check positive response for writing cycles 0 to 34.", dWriteCycleConfigRequest, dWriteCycleConfigResponse);  
}

/// <Profile_management>
// Writes the default step parameters.
void WriteStepParameters()
{ 
  memcpy(bDefaultStepsRequest, bDefaultStepsLibraryRequest, elcount(bDefaultStepsLibraryRequest));
  memcpy_off(bDefaultStepsRequest, 3, bDefaultStepsLibrary, 0, elcount(bDefaultStepsLibrary));
  SendDiagnosticRequest(dWriteStepsConfigRequest, dWriteStepsConfigResponse, bDefaultStepsRequest);
  CheckPositiveResponse("Check positive response for writing steps 0 to 145.", dWriteStepsConfigRequest, dWriteStepsConfigResponse);
}

/// <Profile_management>
// Function that reads the Cycle Counters.
// bCounter = the cycle that you want to read.
// Usage Example:
// ReadCycleCounter(Low);
// ReadCycleCounter(High);
// ReadCycleCounter(Max);
// ReadCycleCounter(Comfort);
double ReadCycleCounter(byte bCounter)
{
  byte bReadCounterPosResp[23];
  char cAllCycleCounters[120];
  dword lCounter;
  
  lCounter = -1;
  
  EnterDiagnosticSession("development");
  
  if(bCounter == Max)
  {
    SendDiagnosticRequest(dReadPreSafeCountersRequest, dReadPreSafeCountersResponse);
    CheckPositiveResponse("Check positive response of read PRE-SAFE counters diagnostic service.", dReadPreSafeCountersRequest, dReadPreSafeCountersResponse);
    testReportWriteDiagObject(dReadPreSafeCountersResponse);  
    lCounter = (dReadPreSafeCountersResponse.GetPrimitiveByte(10) << 8) +  dReadPreSafeCountersResponse.GetPrimitiveByte(9);
    testStep(@sysvar::CORE::sysLevelOfDetailStep, "", "Max activation Counter=  %ld", lCounter);
  }
  else 
    if(bCounter == High)
    {
      SendDiagnosticRequest(dReadPreSafeCountersRequest, dReadPreSafeCountersResponse);
      CheckPositiveResponse("Check positive response of read PRE-SAFE counters diagnostic service.", dReadPreSafeCountersRequest, dReadPreSafeCountersResponse);
      testReportWriteDiagObject(dReadPreSafeCountersResponse);  
      lCounter = (dReadPreSafeCountersResponse.GetPrimitiveByte(8) << 8) +  dReadPreSafeCountersResponse.GetPrimitiveByte(7);
      testStep(@sysvar::CORE::sysLevelOfDetailStep, "", "High activation Counter=  %ld", lCounter);
  }
  else 
    if(bCounter == Low)
    {
      SendDiagnosticRequest(dReadPreSafeCountersRequest, dReadPreSafeCountersResponse);
      CheckPositiveResponse("Check positive response of read PRE-SAFE counters diagnostic service.", dReadPreSafeCountersRequest, dReadPreSafeCountersResponse);
      testReportWriteDiagObject(dReadPreSafeCountersResponse);
      
      lCounter = (dReadPreSafeCountersResponse.GetPrimitiveByte(6) << 8) +  dReadPreSafeCountersResponse.GetPrimitiveByte(5);
      testStep(@sysvar::CORE::sysLevelOfDetailStep, "", "Low activation Counter=  %ld", lCounter);
    }
    else 
      if(bCounter == Comfort)
      {
        SendDiagnosticRequest(dReadBSRCounterRequest, dReadBSRCounterResponse);
        CheckPositiveResponse("Check positive response of Read BSR counter diagnostic service.", dReadBSRCounterRequest, dReadBSRCounterResponse);
        
        lCounter = (dReadBSRCounterResponse.GetPrimitiveByte(5) << 16) + (dReadBSRCounterResponse.GetPrimitiveByte(4) << 8) + dReadBSRCounterResponse.GetPrimitiveByte(3);
        testStep(@sysvar::CORE::sysLevelOfDetailStep, "", "COMFORT activation Counter=  %ld", lCounter);
      }
      else
        if(bCounter == RequestCounter)
        {
          SendDiagnosticRequest(dReadPreSafeCountersRequest, dReadPreSafeCountersResponse);
          CheckPositiveResponse("Check positive response of read PRE-SAFE counters diagnostic service.", dReadPreSafeCountersRequest, dReadPreSafeCountersResponse);
          testReportWriteDiagObject(dReadPreSafeCountersResponse);
          
          lCounter = (dReadPreSafeCountersResponse.GetPrimitiveByte(4) << 8) +  dReadPreSafeCountersResponse.GetPrimitiveByte(3);
          testStep(@sysvar::CORE::sysLevelOfDetailStep, "", "Request counter=  %ld", lCounter);
        }
        else
        {
          testStepFail(@sysvar::CORE::sysLevelOfDetailFail, "", "Incorrect parameter (ReadCycleCounter function).");
          return -1;
        }
//  ConvertByteArrInCharArr(bReadCounterPosResp, cAllCycleCounters, 0, elcount(bReadCounterPosResp) - 1, "true");
//  testStep(@sysvar::CORE::sysLevelOfDetailStep, "", "Response to Read Belt Activation Counters: %s", cAllCycleCounters);

  return lCounter;
}


/// <Profile_management>
void WriteCycleCounter(byte bCounter, long iValue)
{
  byte bCounterValue[4];
  long iSwappedInput;
  byte bWMBA[2] = {0x3d, 0x24}; 
  byte bCounterRequest[12];
  stack byte bComfortCounterAddress[6] = {0x70, 0x01, 0x75, 0x54, 0x00, 0x04};
  stack byte bLoWCounterAddress[6] = {0x70, 0x01, 0x75, 0x58, 0x00, 0x04};
  stack byte bHighCounterAddress[6] = {0x70, 0x01, 0x75, 0x5C, 0x00, 0x04};
  stack byte bMaxCounterAddress[6] = {0x70, 0x01, 0x75, 0x60, 0x00, 0x04};
  stack byte bRequestCounterAddress[6] = {0x70, 0x01, 0x75, 0x64, 0x00, 0x04};
  
  iSwappedInput = swapLong(iValue); // Swap to little-endian.
  bCounterValue[0] = iSwappedInput >> 24;
  bCounterValue[1] = iSwappedInput >> 16;
  bCounterValue[2] = iSwappedInput >> 8;
  bCounterValue[3] = iSwappedInput;
  
  if(bCounter == Max)
  {
    memcpy_off(bCounterRequest, 0, bWMBA, 0, elcount(bWMBA));
    memcpy_off(bCounterRequest, 2, bMaxCounterAddress, 0, elcount(bMaxCounterAddress));
    memcpy_off(bCounterRequest, 8, bCounterValue, 0, elcount(bCounterValue));
    SendDiagnosticRequest(dWriteMemoryByAddressRequest, dWriteMemoryByAddressResponse, bCounterRequest);
    CheckPositiveResponse(dWriteMemoryByAddressRequest, dWriteMemoryByAddressResponse);
    testStep(@sysvar::CORE::sysLevelOfDetailStep, "", "Max force counter value is set to %ld", iValue);
  }
  else
    if(bCounter == High)
    {
      memcpy_off(bCounterRequest, 0, bWMBA, 0, elcount(bWMBA));
      memcpy_off(bCounterRequest, 2, bHighCounterAddress, 0, elcount(bHighCounterAddress));
      memcpy_off(bCounterRequest, 8, bCounterValue, 0, elcount(bCounterValue));
      SendDiagnosticRequest(dWriteMemoryByAddressRequest, dWriteMemoryByAddressResponse, bCounterRequest);
      CheckPositiveResponse(dWriteMemoryByAddressRequest, dWriteMemoryByAddressResponse);
      testStep(@sysvar::CORE::sysLevelOfDetailStep, "", "High force counter value is set to %ld", iValue);
  }
  else 
    if(bCounter == Low)
    {
      memcpy_off(bCounterRequest, 0, bWMBA, 0, elcount(bWMBA));
      memcpy_off(bCounterRequest, 2, bLoWCounterAddress, 0, elcount(bLoWCounterAddress));
      memcpy_off(bCounterRequest, 8, bCounterValue, 0, elcount(bCounterValue));
      SendDiagnosticRequest(dWriteMemoryByAddressRequest, dWriteMemoryByAddressResponse, bCounterRequest);
      CheckPositiveResponse(dWriteMemoryByAddressRequest, dWriteMemoryByAddressResponse);
      testStep(@sysvar::CORE::sysLevelOfDetailStep, "", "LOW force counter value is set to %ld", iValue);
    }
    else 
      if(bCounter == Comfort)
      {
          memcpy_off(bCounterRequest, 0, bWMBA, 0, elcount(bWMBA));
          memcpy_off(bCounterRequest, 2, bComfortCounterAddress, 0, elcount(bComfortCounterAddress));
          memcpy_off(bCounterRequest, 8, bCounterValue, 0, elcount(bCounterValue));
          SendDiagnosticRequest(dWriteMemoryByAddressRequest, dWriteMemoryByAddressResponse, bCounterRequest);
          CheckPositiveResponse(dWriteMemoryByAddressRequest, dWriteMemoryByAddressResponse);
          testStep(@sysvar::CORE::sysLevelOfDetailStep, "", "Comfort force counter value is set to %ld", iValue);
      }
      else
        if(bCounter == RequestCounter)
        {
            memcpy_off(bCounterRequest, 0, bWMBA, 0, elcount(bWMBA));
            memcpy_off(bCounterRequest, 2, bRequestCounterAddress, 0, elcount(bRequestCounterAddress));
            memcpy_off(bCounterRequest, 8, bCounterValue, 0, elcount(bCounterValue));
            SendDiagnosticRequest(dWriteMemoryByAddressRequest, dWriteMemoryByAddressResponse, bCounterRequest);
            CheckPositiveResponse(dWriteMemoryByAddressRequest, dWriteMemoryByAddressResponse);
            testStep(@sysvar::CORE::sysLevelOfDetailStep, "", "Request counter value is set to %ld", iValue);
        }
        else
        {
          testStepFail(@sysvar::CORE::sysLevelOfDetailFail, "", "Incorrect parameter (WriteCycleCounter function).");
        }
}

/// <Profile_management>
//Read deficiency level from RAM 
long GetDeficiencyLevel()
{
  diagRequest * dReadMemoryByAddressRequest;
  stack diagResponse * dReadMemoryByAddressResponse;
  
  stack dword iDeficiencylevel;
  
  dReadMemoryByAddressRequest.Resize(elcount(bRMBARequest));
  diagSetPrimitiveData(dReadMemoryByAddressRequest, bRMBARequest, elcount(bRMBARequest));
  
  DiagSetPrimitiveByte(dReadMemoryByAddressRequest, 1, 0x24);
  DiagSetPrimitiveByte(dReadMemoryByAddressRequest, 2, bCurrentDeficiencylevel[0]);
  DiagSetPrimitiveByte(dReadMemoryByAddressRequest, 3, bCurrentDeficiencylevel[1]);
  DiagSetPrimitiveByte(dReadMemoryByAddressRequest, 4, bCurrentDeficiencylevel[2]);
  DiagSetPrimitiveByte(dReadMemoryByAddressRequest, 5, bCurrentDeficiencylevel[3]);
  DiagSetPrimitiveByte(dReadMemoryByAddressRequest, 6, 0x00);
  DiagSetPrimitiveByte(dReadMemoryByAddressRequest, 7, bCurrentDeficiencylevelSize);
  
  // Diag Error Handling.
  if(SendDiagnosticRequest(dReadMemoryByAddressRequest, dReadMemoryByAddressResponse) == DIAG_SEND_OR_RECEIVE_ERROR) 
  {
    testStepFail(@sysvar::CORE::sysLevelOfDetailFail, "" ,"GetDeficiencyLevel: Diagnostic request send or receive error.");
    return -1;
  }
  
  // Diag Error Handling.
  if (diagIsPositiveResponse(dReadMemoryByAddressResponse) == 0)
  {
    testStepFail(@sysvar::CORE::sysLevelOfDetailFail, "", "GetDeficiencyLevel: Negative response received for RMBA: 0x%X", dReadMemoryByAddressResponse.GetResponseCode());
    testReportWriteDiagResponse(dReadMemoryByAddressRequest);
    return -1;
  }
  
  return swapDWord(dReadMemoryByAddressResponse.GetParameter(0, "DataRecord"));
}

/// <Profile_management>
// Waits until defficiency level reaches 0. 
void WaitForDefficiencyLevel()
{
  stack long iMaxWaitTime = 330000;
  stack long iElapsedTime = 0;
  stack long iDefficiencyLevel = 0;
  
  while(iElapsedTime < iMaxWaitTime)
  {
    iDefficiencyLevel = GetDeficiencyLevel();
    if(GetDeficiencyLevel() == -1)
    {
      return;
    }
      
    if(GetDeficiencyLevel() == 0)
    {
      testStepPass(@sysvar::CORE::sysLevelOfDetailPass, "" ,"Defficiency level reached 0 in %lu ms", iElapsedTime);
      return;
    }
    else
    {
      testWaitForTimeout(1000);
      iElapsedTime += 1000;
    }
  }
  
  testStepFail(@sysvar::CORE::sysLevelOfDetailPass, "" ,"Defficiency level did not reach 0 in %lu ms. Current defficiency level = %lu", iElapsedTime, iDefficiencyLevel);
}


//Function that configure MF Block12
void ConfigureMeasurement_Block12(byte bAddress[], int iSize) 
{
  
	if(iSize >= 8) 
	{
	  testStepFail(@sysvar::CORE::sysLevelOfDetailFail, "", "ConfigureMeasurement_Block12: Size must be less than 8 bytes. Actual size is set to: %d", iSize);
	}
  else
  {
    diagSetParameterCoded(dWriteMFBlock12ConfigRequest, "Address", bAddress, elcount(bAddress));
    diagSetParameter(dWriteMFBlock12ConfigRequest, "Block_Size", iSize);
    
    // Diag Error Handling.
    if(SendDiagnosticRequest(dWriteMFBlock12ConfigRequest, dWriteMFBlock12ConfigResponse) == DIAG_SEND_OR_RECEIVE_ERROR) 
    {
      testStepFail(@sysvar::CORE::sysLevelOfDetailFail, "" ,"ConfigureMeasurement_Block12: Diagnostic request send or receive error.");
      return;
    }
    
    // Diag Error Handling.    
    CheckPositiveResponse("Check positive response for Configure MF Block12 service.", dWriteMFBlock12ConfigRequest, dWriteMFBlock12ConfigResponse);
  }

}

// Change ECU side .
// Option 1: ChangeECUSide("left")
// Option 2: ChangeECUSide("right")
void ChangeECUSide(char side[])
{
  message Meas8_RBTM_FL_ST3 MeasurementFrameFL;
  message Meas8_RBTM_FR_ST3 MeasurementFrameFR;
  
  toLower(side, side, elcount(side));
  if(strncmp(side, "left", strlen(side)) == 0)
  {
    AuthenticateECU(2);
    EnterDiagnosticSession("development"); 

    dECULocationWriteRequest.SetPrimitiveByte(3, 0x9C);
    SendDiagnosticRequest(dECULocationWriteRequest, dECULocationWriteResponse);
    CheckPositiveResponse("ECU side is changed to left", dECULocationWriteRequest, dECULocationWriteResponse);

    testWaitForTimeout(1000);
    ResetECU("soft");
    @sysvar::ProjectConfiguration::sysMeasurementFrameID = MeasurementFrameFL.id;
    iSideFlag = 0;
    SetDiagTarget("RBTMFL174");
    sysSetVariableString("LocalAuthentication", "DiagTarget", "RBTMFL174");
    WaitECUInitialization();
    
    testStep("", "Obtain ECU security authentification."); 
    AuthenticateECU(2); // Development_Enhanced
    
    testStep("", "Enter development session.");
    EnterDiagnosticSession("development");
    
    testStep("", "Set set tick count.");  // R30 com issue
    SetSecTickCount();
  }
  else
  {
    if(strncmp(side, "right", strlen(side)) == 0)
    {
      AuthenticateECU(2);
      EnterDiagnosticSession("development");
      
      dECULocationWriteRequest.SetPrimitiveByte(3, 0x99);
      SendDiagnosticRequest(dECULocationWriteRequest, dECULocationWriteResponse);
      CheckPositiveResponse("ECU side is changed to right",dECULocationWriteRequest, dECULocationWriteResponse);
      
      testWaitForTimeout(1000);
      ResetECU("soft");
      @sysvar::ProjectConfiguration::sysMeasurementFrameID = MeasurementFrameFR.id;
      iSideFlag = 1;
      SetDiagTarget("RBTMFR174");
      syssetVariableString("LocalAuthentication", "DiagTarget", "RBTMFR174");
      WaitECUInitialization();  
      
      testStep("", "Obtain ECU security authentification."); 
      AuthenticateECU(2); // Development_Enhanced
      
      testStep("", "Enter development session.");
      EnterDiagnosticSession("development");
      
      testStep("", "Set set tick count.");  // R30 com issue
      SetSecTickCount();
    }
    else
    {
      testStepFail(@sysvar::CORE::sysLevelOfDetailFail, "Error", "Invalid parameter for ChangeECUSide function: %s", side);
    }
  }
  WaitDebounceTimer();
}



// Function that evaluates if 'RBTM_FX_Disp_Rq_ST3' Warning Indicator signal is set to 'SRV_DISP_RQ'.
// Return: Warning Indicator value.
int CheckWarningIndicator_ON()
{
  return CheckWarningIndicator(1);
}

// Function that evaluates if 'RBTM_FX_Disp_Rq_ST3' Warning Indicator signal is NOT set to 'SRV_DISP_RQ'.
// Return: Warning Indicator value.
int CheckWarningIndicator_OFF()
{
  return CheckWarningIndicator(0);
}

// Helper function for CheckWarningIndicator_ON/OFF.
int CheckWarningIndicator(int iExpectedStatus)
{
  stack int64 iValueTableValue;
  stack int64 iWarningIndicatorValue = -1;
  stack char cExpected[200];
  stack char cActual[200];
  stack int iReturnValue;
  stack char cBuffer[300];
  
  if(@sysvar::ProjectConfiguration::sysMeasurementFrameID == MeasurementFrameFL.id)
  {
    if(getSignalValueForDescription(RBTM_FL_Stat_ST3::RBTM_FL_Disp_Rq_ST3, "I_C02_PRESF_DISP_RQ_SRV_DISP_RQ", iValueTableValue) == 0)
    {
      iReturnValue = testWaitForMessage(getMessageID("RBTM_FL_Stat_ST3"), 1500);
      if(iReturnValue == 1)
      {
        iWarningIndicatorValue = getSignal(RBTM_FL_Disp_Rq_ST3);
        getSignalDescriptionForValue(RBTM_FL_Disp_Rq_ST3, iWarningIndicatorValue, cBuffer, elcount(cBuffer));
        snprintf(cActual, elcount(cActual), "%i [%s]", iWarningIndicatorValue, cBuffer);

        snprintf(cExpected, elcount(cExpected), "%i [I_C02_PRESF_DISP_RQ_SRV_DISP_RQ]", iValueTableValue);
        
        if(iExpectedStatus == 1)
        {
          EvalManStepEqual("Check that Warning Indicator 'RBTM_FL_Disp_Rq_ST3' is ON:", cActual, cExpected);
        }
        else
        {
          EvalManStepUnEqual("Check that Warning Indicator 'RBTM_FL_Disp_Rq_ST3' is NOT ON:", cActual, cExpected);
        }
      }
      else
      {
       testStepFail(@sysvar::CORE::sysLevelOfDetailFail, "CheckWarningIndicator_ON", "Error code [%i] while waiting for 'RBTM_FL_Stat_ST3' message.", iReturnValue);
      }
    }
    else
    {
      testStepFail(@sysvar::CORE::sysLevelOfDetailFail, "", "Error getting value for description for 'I_C02_PRESF_DISP_RQ_SRV_DISP_RQ'.");
    }
  }
  else
  {
    if(getSignalValueForDescription(RBTM_FR_Stat_ST3::RBTM_FR_Disp_Rq_ST3, "I_C02_PRESF_DISP_RQ_SRV_DISP_RQ", iValueTableValue) == 0)
    {
      iReturnValue = testWaitForMessage(getMessageID("RBTM_FR_Stat_ST3"), 1500);
      if(iReturnValue == 1)
      {
        iWarningIndicatorValue = getSignal(RBTM_FR_Disp_Rq_ST3);
        getSignalDescriptionForValue(RBTM_FR_Disp_Rq_ST3, iWarningIndicatorValue, cBuffer, elcount(cBuffer));
        snprintf(cActual, elcount(cActual), "%i [%s]", iWarningIndicatorValue, cBuffer);
        
        snprintf(cExpected, elcount(cExpected), "%i [I_C02_PRESF_DISP_RQ_SRV_DISP_RQ]", iValueTableValue);
        
        if(iExpectedStatus == 1)
        {
          EvalManStepEqual("Check that Warning Indicator 'RBTM_FR_Disp_Rq_ST3' is ON:", cActual, cExpected);
        }
        else
        {
          EvalManStepUnEqual("Check that Warning Indicator 'RBTM_FR_Disp_Rq_ST3' is NOT ON:", cActual, cExpected);
        }
      }
      else
      {
       testStepFail(@sysvar::CORE::sysLevelOfDetailFail, "CheckWarningIndicator_ON", "Error code [%i] while waiting for 'RBTM_FR_Stat_ST3' message.", iReturnValue);
      }
    }
    else
    {
      testStepFail(@sysvar::CORE::sysLevelOfDetailFail, "", "Error getting value for description for 'I_C02_PRESF_DISP_RQ_SRV_DISP_RQ'.");
    }
  }
  return iWarningIndicatorValue;
}

void ControllDTCSetting_On()
{
  ControllDTCSetting_On(FALSE);
}

// iWaitDebounce = TRUE -> function waits for the debounce timer.
void ControllDTCSetting_On(int iWaitDebounce)
{
  iSessionControlVerbosity = 0;
  EnterDiagnosticSession("development");
  iSessionControlVerbosity = 2;
  
  // Diag Error Handling.
  if(SendDiagnosticRequest(dDTCEnableRequest, dDTCEnableResponse) == DIAG_SEND_OR_RECEIVE_ERROR) 
  {
    testStepFail(@sysvar::CORE::sysLevelOfDetailFail, "" ,"ControllDTCSetting_On: Diagnostic request send or receive error.");
    return;
  }
  
  // Diag Error Handling.
  if (diagIsPositiveResponse(dDTCEnableResponse) == 0)
  {
    testStepFail(@sysvar::CORE::sysLevelOfDetailFail, "", "ControllDTCSetting_On: Negative response received for ControllDTCSetting_On request: [0x%X].", dDTCEnableResponse.GetResponseCode());
    testReportWriteDiagResponse(dDTCEnableRequest);
    return;
  }
  else
  {
     testStepPass(@sysvar::CORE::sysLevelOfDetailPass, "", "ControllDTCSetting: DTC setting enabled.");
  }
  
  if(iWaitDebounce == TRUE)
  {
    Wait(6000);
  }
}

void ControllDTCSetting_Off()
{
  ControllDTCSetting_Off(FALSE);
}

// iWaitDebounce = TRUE -> function waits for the debounce timer.
void ControllDTCSetting_Off(int iWaitDebounce)
{
  iSessionControlVerbosity = 0;
  EnterDiagnosticSession("development");
  iSessionControlVerbosity = 2;
  
  // Diag Error Handling.
  if(SendDiagnosticRequest(dDTCDisableRequest, dDTCDisableResponse) == DIAG_SEND_OR_RECEIVE_ERROR) 
  {
    testStepFail(@sysvar::CORE::sysLevelOfDetailFail, "" ,"ControllDTCSetting_Off: Diagnostic request send or receive error.");
    return;
  }
  
  // Diag Error Handling.
  if (diagIsPositiveResponse(dDTCDisableResponse) == 0)
  {
    testStepFail(@sysvar::CORE::sysLevelOfDetailFail, "", "ControllDTCSetting_Off: Negative response received for ControllDTCSetting_Off request: [0x%X].", dDTCDisableResponse.GetResponseCode());
    testReportWriteDiagResponse(dDTCDisableRequest);
    return;
  }
  else
  {
     testStepPass(@sysvar::CORE::sysLevelOfDetailPass, "", "ControllDTCSetting: DTC setting disabled.");
  }
  
  if(iWaitDebounce == TRUE)
  {
    Wait(6000);
  }
}

/// <ROE>
//// Check ROE Type 1
//// expectedDTC        -> ex: bERR_BAT_PWR_UNDER_VOLTAGE_SYSTEM
//// expectedDTCStatus  -> ex: bDTC_Qualified
//// dtcObservationTime -> ex: _iQualif_BAT_PWR_UNDER_VOLTAGE_SYSTEM
void CheckROEandDTCInfo(byte expectedDTC, byte expectedDTCStatus, float dtcObservationTime)
{
  stack byte  bAvailabilityMask;
  stack byte  bDTC_1;
  stack byte  bDTC_2;
  stack byte  bDTC_3;
  stack dword bDTC;  

  stack byte  bReservedValue_1;
  stack byte  bReservedValue_2;
  stack dword bReservedValue;

  byte  expectedType                = 0x01;
  byte  expectedAvailabilityMask    = 0x09;
  dword expectedReservedValue       = 0x0000;
  
  stack float result;
  stack long  result1;
  
  char  targetName[100];
  dword frameID = 0;
  int   iCount;
  int   iFlag;
      
  diagGetCurrentEcu(targetName, elcount(targetName));
  
  if (strncmp(targetName, sTargetECUFrontLeftName, elcount(targetName)) == 0)
  {
    frameID = 0x18E1A400x;
    
    switch(bDTCID[expectedDTC])
    {
      case 0x164456:
      case 0x1CA000:
      case 0xA10A00:
      case 0xA10B00:
      case 0xA10D00:
      case 0xA10E00:
      case 0xA20400:
      case 0xA28B16:
      case 0xA28B17:
      case 0xA28B45:
      case 0xA28B47:
      case 0xA28B49:
      case 0xA28B4B:
      case 0xA28B71:
      case 0xA28B96:
      case 0xA28B97:
      case 0xA28BFA:
      case 0xAA6857:
      case 0xC11587:
      case 0xC12287:
      case 0xC15187:
      case 0xC15587:
      case 0xC16887:
      case 0xC20187:
      case 0xC20287:
      case 0xC41608:
      case 0xC42708:
      case 0xC44286:
      case 0xC45208:
      case 0xD12087:
      case 0xD22488:
      case 0xD88987:
      case 0xD88A08:
      {       
        writeToLog("$1. Check if frame is available [START]");
        result  = TestWaitForMessage(frameID, dtcObservationTime * 3);
        result1 = TestWaitForSignalMatch(ROE_0_RBTM_FL_ST3, expectedType, dtcObservationTime + 1000);
                
        while ((iCount < 100) && (bDTC != bDTCID[expectedDTC]))
        {
          iFlag = TestWaitForSignalMatch(ROE_0_RBTM_FL_ST3, expectedType, 10);
          
          bDTC_1  = getSignal(ROE_2_RBTM_FL_ST3);
          bDTC_2  = getSignal(ROE_3_RBTM_FL_ST3);
          bDTC_3  = getSignal(ROE_4_RBTM_FL_ST3);
          bDTC    = ((bDTC_1 << 16) | (bDTC_2 << 8) | (bDTC_3));
          
          iCount += 1;
        }
        writeToLog("$2. Check if frame is available [END]");
               
        if(iFlag == 1)
        {
                   
          bReservedValue_1  = getSignal(ROE_6_RBTM_FL_ST3);
          bReservedValue_2  = getSignal(ROE_7_RBTM_FL_ST3);
          bReservedValue    = ((bReservedValue_1 << 8) | (bReservedValue_2));
              
          EvalManStepEqual("Check if received type is: Type1", getSignal(ROE_0_RBTM_FL_ST3), expectedType);
          
          testStep("STEP", "Check if received status availability mask is: 0x09.");
          EvalManStepEqual("Check if received status availability mask is as expected.", getSignal(ROE_1_RBTM_FL_ST3), expectedAvailabilityMask);
          
          testStep("STEP", "Check DTC presence --> Expected DTC received.");
          if(bDTC == bDTCID[expectedDTC])
          {
            testStepPass(@sysvar::CORE::sysLevelOfDetailPass, "DTC", "Expected DTC was received: 0x%X.", bDTC);
          }
          else 
          {
            testStepFail(@sysvar::CORE::sysLevelOfDetailFail, "DTC", "Expected DTC was NOT received. DTC ID received: 0x%X.",bDTC);
          }
          
          testStep("STEP", "Check if received DTC status byte value is: 0x%x.", expectedDTCStatus);
          EvalManStepEqual("Check if received DTC status byte is as expected.", getSignal(ROE_5_RBTM_FL_ST3), expectedDTCStatus);
          
          testStep("STEP", "Check 'Reserved' values --> Expected 'Reserved' values received.");
          if(bReservedValue == expectedReservedValue)
          {
            testStepPass(@sysvar::CORE::sysLevelOfDetailPass, "RESERVED", "Expected 'Reserved' values received: 0x0%X.", bReservedValue);
          }
          else 
          {
            testStepFail(@sysvar::CORE::sysLevelOfDetailFail, "RESERVED", "Expected 'Reserved' values received NOK: 0x0%X.", bReservedValue);
          }
          
        }
        else
        {
            testStepFail(@sysvar::CORE::sysLevelOfDetailFail, "", "Frame was NOT available.");
        }
        break;
      }
      default:
        testStepFail(@sysvar::CORE::sysLevelOfDetailFail, "Error", "Invalid DTC ID.");
        break;
    }
  }
  else
  {
    frameID = 0x18E1A500x;
    
    switch(bDTCID[expectedDTC])
    {
      case 0x164456:
      case 0x1CA000:
      case 0xA10A00:
      case 0xA10B00:
      case 0xA10D00:
      case 0xA10E00:
      case 0xA20400:
      case 0xA28B16:
      case 0xA28B17:
      case 0xA28B45:
      case 0xA28B47:
      case 0xA28B49:
      case 0xA28B4B:
      case 0xA28B71:
      case 0xA28B96:
      case 0xA28B97:
      case 0xA28BFA:
      case 0xAA6857:
      case 0xC11587:
      case 0xC12287:
      case 0xC15187:
      case 0xC15587:
      case 0xC16887:
      case 0xC20187:
      case 0xC20287:
      case 0xC41608:
      case 0xC42708:
      case 0xC44286:
      case 0xC45208:
      case 0xD12087:
      case 0xD22488:
      case 0xD88987:
      case 0xD88A08:
      {
        writeToLog("$1. Check if frame is available [START]");
        result  = TestWaitForMessage(frameID, dtcObservationTime * 3);
        result1 = TestWaitForSignalMatch(ROE_0_RBTM_FR_ST3, expectedType, dtcObservationTime + 1000);
        
        while ((iCount < 100) && (bDTC != bDTCID[expectedDTC]))
        {
          iFlag = TestWaitForSignalMatch(ROE_0_RBTM_FR_ST3, expectedType, 10);
          
          bDTC_1  = getSignal(ROE_2_RBTM_FR_ST3);
          bDTC_2  = getSignal(ROE_3_RBTM_FR_ST3);
          bDTC_3  = getSignal(ROE_4_RBTM_FR_ST3);
          bDTC    = ((bDTC_1 << 16) | (bDTC_2 << 8) | (bDTC_3));
          
          iCount += 1;
        }
        writeToLog("$2. Check if frame is available [END]");
        
        if(iFlag == 1)
        {
                    
          bReservedValue_1  = getSignal(ROE_6_RBTM_FR_ST3);
          bReservedValue_2  = getSignal(ROE_7_RBTM_FR_ST3);
          bReservedValue    = ((bReservedValue_1 << 8) | (bReservedValue_2));
              
          EvalManStepEqual("Check if received type is: Type1", getSignal(ROE_0_RBTM_FR_ST3), 0x01);
          
          testStep("STEP", "Check if received status availability mask is: 0x09.");
          EvalManStepEqual("Check if received status availability mask is as expected.", getSignal(ROE_1_RBTM_FR_ST3), expectedAvailabilityMask);
          
          testStep("STEP", "Check DTC presence --> Expected DTC received.");
          if(bDTC == bDTCID[expectedDTC])
          {
            testStepPass(@sysvar::CORE::sysLevelOfDetailPass, "DTC", "Expected DTC was received: 0x%X.", bDTC);
          }
          else 
          {
            testStepFail(@sysvar::CORE::sysLevelOfDetailFail, "DTC", "Expected DTC was NOT received. DTC ID received: 0x%X.",bDTC);
          }
          
          testStep("STEP", "Check if received DTC status byte value is: 0x%x.", expectedDTCStatus);
          EvalManStepEqual("Check if received DTC status byte is as expected.", getSignal(ROE_5_RBTM_FR_ST3), expectedDTCStatus);
          
          testStep("STEP", "Check 'Reserved' values --> Expected 'Reserved' values received.");
          if(bReservedValue == expectedReservedValue)
          {
            testStepPass(@sysvar::CORE::sysLevelOfDetailPass, "RESERVED", "Expected 'Reserved' values received: 0x0%X.", bReservedValue);
          }
          else 
          {
            testStepFail(@sysvar::CORE::sysLevelOfDetailFail, "RESERVED", "Expected 'Reserved' values received NOK: 0x0%X.", bReservedValue);
          }
          
        }
        else
        {
            testStepFail(@sysvar::CORE::sysLevelOfDetailFail, "", "Frame was NOT available.");
        }
        break;
      }
      default:
        testStepFail(@sysvar::CORE::sysLevelOfDetailFail, "Error", "Invalid DTC ID.");
        break;
    }    
  } 
}

/// <ROE>
//// Check ROE Type 2
//// expectedBlockNr    -> ex: 0x01, 0x02, 0x03
//// roeObservationTime -> ex: 200ms
void CheckROEType2Info(byte expectedBlockNr, float roeObservationTime)
{

  stack byte  bType;
  byte  expectedType              = 0x02;
  
  stack byte  bBlockNr;

  stack byte  bCurrentValue_1;
  stack byte  bCurrentValue_2;
  stack dword bCurrentValue;
  dword expectedCurrrentValue     = 0x00;
  
  stack byte  bThGY_1;
  stack byte  bThGY_2;
  stack dword bThGY;
  dword expectedThGYValue         = 0x0000;
  
  stack byte  bThYR_1;
  stack byte  bThYR_2;
  stack dword bThYR;
  dword expectedThYRValue         = 0x0000;

  float result                    = 0;
  long  result1                   = 0;
  
  char  targetName[100];
  dword frameID = 0;
  int   iCount;
  int   iFlag;
      
  diagGetCurrentEcu(targetName, elcount(targetName));
  
  if (strncmp(targetName, sTargetECUFrontLeftName, elcount(targetName)) == 0)
  {
    frameID = 0x18E1A400x;
    
    switch(expectedBlockNr)
    {
      case 0x00:
      case 0x01:
      case 0x02:
      case 0x03:
      {
        
        writeToLog("$1. Check if frame is available [START]");
        result  = TestWaitForMessage(frameID, roeObservationTime * 3);
        result1 = TestWaitForSignalMatch(ROE_0_RBTM_FL_ST3, expectedType, roeObservationTime + 1000);
                
        while ((iCount < 100) && (iFlag != 1))
        {
          iFlag = TestWaitForSignalMatch(ROE_0_RBTM_FL_ST3, expectedType, 10);          
          iCount += 1;
        }
        writeToLog("$2. Check if frame is available [END]");
        
        if(iFlag == 1)
        {
          
          bType             = getSignal(ROE_0_RBTM_FL_ST3);
          
          bBlockNr          = getSignal(ROE_1_RBTM_FL_ST3);
          
          bCurrentValue_1   = getSignal(ROE_2_RBTM_FL_ST3);
          bCurrentValue_2   = getSignal(ROE_3_RBTM_FL_ST3);
          bCurrentValue     = ((bCurrentValue_1 << 8) | (bCurrentValue_2));
          
          bThGY_1           = getSignal(ROE_4_RBTM_FL_ST3);
          bThGY_2           = getSignal(ROE_5_RBTM_FL_ST3);
          bThGY             = ((bThGY_1 << 8) | (bThGY_2));
          
          bThYR_1           = getSignal(ROE_6_RBTM_FL_ST3);
          bThYR_2           = getSignal(ROE_7_RBTM_FL_ST3);
          bThYR             = ((bThYR_1 << 8) | (bThYR_2));
              
          EvalManStepEqual("Check if received type is: Type2", bType, expectedType);

          testStep("STEP", "Check if received status block number is: 0x0%X.", expectedBlockNr);
          EvalManStepEqual("Check if received status block number is as expected.", bBlockNr, expectedBlockNr);
          
          testStep("STEP", "Check current value --> Expected current value received: 0x0%X.", bCurrentValue);
          if(bCurrentValue == expectedCurrrentValue)
          {
            testStepPass(@sysvar::CORE::sysLevelOfDetailPass, "CurrentValue", "Expected current value was received.");
          }
          else 
          {
            testStepFail(@sysvar::CORE::sysLevelOfDetailFail, "CurrentValue", "Expected current value was NOT received: 0x0%X.", bCurrentValue);
          }
          
          testStep("STEP", "Check threshold values --> Expected threshold values received: 0x0%X.", bThGY);
          if(bThGY == expectedThGYValue)
          {
            testStepPass(@sysvar::CORE::sysLevelOfDetailPass, "Th:GY", "Expected threshold values received.");
          }
          else 
          {
            testStepFail(@sysvar::CORE::sysLevelOfDetailFail, "Th:GY", "Expected threshold values received NOK: 0x0%X.", bThGY);
          }
          
          testStep("STEP", "Check threshold values --> Expected threshold values received: 0x0%X.", bThYR);
          if(bThYR == expectedThYRValue)
          {
            testStepPass(@sysvar::CORE::sysLevelOfDetailPass, "Th:YR", "Expected threshold values received.");
          }
          else 
          {
            testStepFail(@sysvar::CORE::sysLevelOfDetailFail, "Th:YR", "Expected threshold values received NOK: 0x0%X.", bThYR);
          }
          
        }
        
        else
        {
          testStepFail(@sysvar::CORE::sysLevelOfDetailFail, "", "Frame was NOT available.");
        }
        break;
      }
      default:
        testStepFail(@sysvar::CORE::sysLevelOfDetailFail, "Error", "Invalid expected block ID.");
        break;
    }
  }
  
  else
  {
    frameID = 0x18E1A500x;
    
    switch(expectedBlockNr)
    {
      case 0x00:
      case 0x01:
      case 0x02:
      case 0x03:
      {
        
        writeToLog("$1. Check if frame is available [START]");
        result  = TestWaitForMessage(frameID, roeObservationTime * 3);
        result1 = TestWaitForSignalMatch(ROE_0_RBTM_FR_ST3, expectedType, roeObservationTime + 1000);
                
        while ((iCount < 100) && (iFlag != 1))
        {
          iFlag = TestWaitForSignalMatch(ROE_0_RBTM_FR_ST3, expectedType, 10);          
          iCount += 1;
        }
        writeToLog("$2. Check if frame is available [END]");
        
        if(iFlag == 1)
        {
          
          bType             = getSignal(ROE_0_RBTM_FR_ST3);
          
          bBlockNr          = getSignal(ROE_1_RBTM_FR_ST3);
          
          bCurrentValue_1   = getSignal(ROE_2_RBTM_FR_ST3);
          bCurrentValue_2   = getSignal(ROE_3_RBTM_FR_ST3);
          bCurrentValue     = ((bCurrentValue_1 << 8) | (bCurrentValue_2));
          
          bThGY_1           = getSignal(ROE_4_RBTM_FR_ST3);
          bThGY_2           = getSignal(ROE_5_RBTM_FR_ST3);
          bThGY             = ((bThGY_1 << 8) | (bThGY_2));
          
          bThYR_1           = getSignal(ROE_6_RBTM_FR_ST3);
          bThYR_2           = getSignal(ROE_7_RBTM_FR_ST3);
          bThYR             = ((bThYR_1 << 8) | (bThYR_2));
              
          EvalManStepEqual("Check if received type is: Type2", bType, expectedType);

          testStep("STEP", "Check if received status block number is: 0x0%X.", expectedBlockNr);
          EvalManStepEqual("Check if received status block number is as expected.", bBlockNr, expectedBlockNr);
          
          testStep("STEP", "Check current value --> Expected current value received.", bCurrentValue);
          if(bCurrentValue == expectedCurrrentValue)
          {
            testStepPass(@sysvar::CORE::sysLevelOfDetailPass, "CurrentValue", "Expected current value was received: 0x0%X.", bCurrentValue);
          }
          else 
          {
            testStepFail(@sysvar::CORE::sysLevelOfDetailFail, "CurrentValue", "Expected current value was NOT received: 0x0%X.", bCurrentValue);
          }
          
          testStep("STEP", "Check threshold values --> Expected threshold values received.");
          if(bThGY == expectedThGYValue)
          {
            testStepPass(@sysvar::CORE::sysLevelOfDetailPass, "Th:GY", "Expected threshold values received: 0x0%X.", bThGY);
          }
          else 
          {
            testStepFail(@sysvar::CORE::sysLevelOfDetailFail, "Th:GY", "Expected threshold values received NOK: 0x0%X.", bThGY);
          }
          
          testStep("STEP", "Check threshold values --> Expected threshold values received: 0x0%X.", bThYR);
          if(bThYR == expectedThYRValue)
          {
            testStepPass(@sysvar::CORE::sysLevelOfDetailPass, "Th:YR", "Expected threshold values received.");
          }
          else 
          {
            testStepFail(@sysvar::CORE::sysLevelOfDetailFail, "Th:YR", "Expected threshold values received NOK: 0x0%X.", bThYR);
          }
          
        }
        
        else
        {
          testStepFail(@sysvar::CORE::sysLevelOfDetailFail, "", "Frame was NOT available.");
        }
        break;
      }
      default:
        testStepFail(@sysvar::CORE::sysLevelOfDetailFail, "Error", "Invalid expected block ID.");
        break;
    }
  }
}

/// <ROE>
//// Check ROE Type 4
//// roeObservationTime -> ex: 200ms
void CheckROEType4Info(float roeObservationTime)
{

  byte  bType;
  byte  expectedType              = 0x04;
  
  byte  bFunctionNr;
  byte  expectedFunctionNr        = 0x00;
  
  byte  bCategory;
  byte  expectedCategory          = 0x02;
  
  byte  bReservedValue_1;
  byte  bReservedValue_2;
  byte  bReservedValue_3;
  byte  bReservedValue_4;
  byte  bReservedValue_5;
  dword bReservedValue;
  dword expectedReservedValue     = 0x0000000000;

  float result                    = 0;
  long  result1                   = 0;
  
  char  targetName[100];
  dword frameID = 0;
  int   iCount;
  int   iFlag;
      
  diagGetCurrentEcu(targetName, elcount(targetName));
  
  if (strncmp(targetName, sTargetECUFrontLeftName, elcount(targetName)) == 0)
  {
    frameID = 0x18E1A400x;
            
    writeToLog("$1. Check if frame is available [START]");
    result  = TestWaitForMessage(frameID, roeObservationTime * 3);
    result1 = TestWaitForSignalMatch(ROE_0_RBTM_FL_ST3, expectedType, roeObservationTime + 1000);
            
    while ((iCount < 100) && (iFlag != 1))
    {
      iFlag = TestWaitForSignalMatch(ROE_0_RBTM_FL_ST3, expectedType, 10);          
      iCount += 1;
    }
    writeToLog("$2. Check if frame is available [END]");
          
    if(iFlag == 1)
    {
      
      bType             = getSignal(ROE_0_RBTM_FL_ST3);
      
      bFunctionNr       = getSignal(ROE_1_RBTM_FL_ST3);
      
      bCategory         = getSignal(ROE_2_RBTM_FL_ST3);
      
      bReservedValue_1  = getSignal(ROE_3_RBTM_FL_ST3);
      bReservedValue_2  = getSignal(ROE_4_RBTM_FL_ST3);
      bReservedValue_3  = getSignal(ROE_5_RBTM_FL_ST3);  
      bReservedValue_4  = getSignal(ROE_6_RBTM_FL_ST3);  
      bReservedValue_5  = getSignal(ROE_7_RBTM_FL_ST3);                  
      bReservedValue    = ((bReservedValue_1 << 31) | (bReservedValue_2 << 24) | (bReservedValue_3 << 16) | (bReservedValue_4 << 8) | (bReservedValue_5));

      EvalManStepEqual("Check if received type is: Type4", bType, expectedType);
      
      testStep("STEP", "Check if received function number is: 0x0%X.", expectedFunctionNr);
      EvalManStepEqual("Check if received function number is as expected.", bFunctionNr, expectedFunctionNr);
      
      testStep("STEP", "Check if category is: 0x0%X.", expectedCategory);
      EvalManStepEqual("Check if category is as expected.", bCategory, expectedCategory);
      
      testStep("STEP", "Check current value --> Expected current value received.");
      if(bReservedValue == expectedReservedValue)
      {
        testStepPass(@sysvar::CORE::sysLevelOfDetailPass, "CurrentValue", "Expected current value was received: 0x0%X.", bReservedValue);
      }
      else 
      {
        testStepFail(@sysvar::CORE::sysLevelOfDetailFail, "CurrentValue", "Expected current value was NOT received: 0x0%X.", bReservedValue);
      }
      
    }
    
    else
    {
      testStepFail(@sysvar::CORE::sysLevelOfDetailFail, "", "Frame was NOT available.");
    }
  }
  
  else
  {
    frameID = 0x18E1A500x;
    
    writeToLog("$1. Check if frame is available [START]");
    result  = TestWaitForMessage(frameID, roeObservationTime * 3);
    result1 = TestWaitForSignalMatch(ROE_0_RBTM_FR_ST3, expectedType, roeObservationTime + 1000);
            
    while ((iCount < 100) && (iFlag != 1))
    {
      iFlag = TestWaitForSignalMatch(ROE_0_RBTM_FR_ST3, expectedType, 10);          
      iCount += 1;
    }
    writeToLog("$2. Check if frame is available [END]");
          
    if(iFlag == 1)
    {
      
      bType             = getSignal(ROE_0_RBTM_FR_ST3);
      
      bFunctionNr       = getSignal(ROE_1_RBTM_FR_ST3);
      
      bCategory         = getSignal(ROE_2_RBTM_FR_ST3);
      
      bReservedValue_1  = getSignal(ROE_3_RBTM_FR_ST3);
      bReservedValue_2  = getSignal(ROE_4_RBTM_FR_ST3);
      bReservedValue_3  = getSignal(ROE_5_RBTM_FR_ST3);  
      bReservedValue_4  = getSignal(ROE_6_RBTM_FR_ST3);  
      bReservedValue_5  = getSignal(ROE_7_RBTM_FR_ST3);                  
      bReservedValue    = ((bReservedValue_1 << 31) | (bReservedValue_2 << 24) | (bReservedValue_3 << 16) | (bReservedValue_4 << 8) | (bReservedValue_5));

      EvalManStepEqual("Check if received type is: Type4", bType, expectedType);
      
      testStep("STEP", "Check if received function number is: 0x0%X.", expectedFunctionNr);
      EvalManStepEqual("Check if received function number is as expected.", bFunctionNr, expectedFunctionNr);
      
      testStep("STEP", "Check if category is: 0x0%X.", expectedCategory);
      EvalManStepEqual("Check if category is as expected.", bCategory, expectedCategory);
      
      testStep("STEP", "Check current value --> Expected current value received.");
      if(bReservedValue == expectedReservedValue)
      {
        testStepPass(@sysvar::CORE::sysLevelOfDetailPass, "CurrentValue", "Expected current value was received: 0x0%X.", bReservedValue);
      }
      else 
      {
        testStepFail(@sysvar::CORE::sysLevelOfDetailFail, "CurrentValue", "Expected current value was NOT received: 0x0%X.", bReservedValue);
      }
      
    }
    
    else
    {
      testStepFail(@sysvar::CORE::sysLevelOfDetailFail, "", "Frame was NOT available.");
    }
  }
}

// Minimal .CDD DTC check:
// - Checks that all DTCs returned with service 0x19 0x0A have a .CDD description.
// - Checks the expected DTC count.
// iExpectedDTCCount = expected number of returned DTCs
void CDD_Check(int iExpectedDTCCount)
{
  byte bCheckDTCPresenceRequest[2] = {0x19, 0x0A};
  dword DTC;
  stack int iLength;
  stack int i;
  char cDTCErrorText[5000];
  diagRequest        * dFaultMemoryReportSupportedDTCsReq;
  stack diagResponse * dFaultMemoryReportSupportedDTCsResp;
  
  AuthenticateECU(2);
  SendDiagnosticRequest( dFaultMemoryReportSupportedDTCsReq, dFaultMemoryReportSupportedDTCsResp, bCheckDTCPresenceRequest);
  
  iLength = diagGetIterationCount(dFaultMemoryReportSupportedDTCsResp, PR_DTCAndStatusRecord);
 
  EvalManStepEqual("Check number of DTCs:", iLength, iExpectedDTCCount);
  
  for(i = 0; i < iLength; i++)
  { 
    strncpy(cDTCErrorText, "", elcount(cDTCErrorText));
    diagGetComplexParameter(dFaultMemoryReportSupportedDTCsResp, PR_DTCAndStatusRecord, i, PR_DTCRecord, cDTCErrorText, elcount(cDTCErrorText));
    DTC = diagGetComplexParameter(dFaultMemoryReportSupportedDTCsResp, PR_DTCAndStatusRecord, i, PR_DTCRecord);
    if(strlen(cDTCErrorText) == 0)
    {
       testStepFail(@sysvar::CORE::sysLevelOfDetailFail, "CDD_Check", "DTC 0x%lX is not described in the .CDD file.", DTC);
    }
  }
}

/// <Storage_Conditions>
void SetStorageConditions(int iVLocal, int iVSystem)
{
  int64 iIgnitionON;
  
  getSignalValueForDescription(Ign_Stat_ST3::ISw_Stat_ST3, "I_C03_ISW_STAT_IGN_ON", iIgnitionON);
  getSignalValueForDescription(PT4_PTCoor4_ST3::PT4_PTCoor_EngStartPN14_Stat_ST3, "I_C03_ENGSTARTPN14_STAT_SNA", iVehStartup_SNA);
  getSignalValueForDescription(PT4_PTCoor4_ST3::PT4_PTCoor_EngStartPN14_Stat_ST3, "I_C03_ENGSTARTPN14_STAT_NO_COMBUSTIONSTART_RQ", iVehStartup_NoStartup);
  getSignalValueForDescription(PT4_PTCoor4_ST3::PT4_PTCoor_EngStartPN14_Stat_ST3, "I_C03_ENGSTARTPN14_STAT_CUSTOMER_START_RQ", iVehStartup_NotFulfilled);
  
  
  getSignalValueForDescription(PN14_Master_Stat1_ST3::PN14_TransMd_Stat_ST3, "I_C02_TRANSMD_STAT_ACTV", iTransportMode_Active);
  getSignalValueForDescription(PN14_Master_Stat1_ST3::PN14_TransMd_Stat_ST3, "I_C02_TRANSMD_STAT_OFF", iTransportMode_Inactive);
  
  getSignalValueForDescription(PN14_Master_Stat1_ST3::PN14_ProdMd_Stat_ST3, "I_C03_PN14_PRODMD_STAT_ST3_OFF", iProductionMode_NotActive);
  getSignalValueForDescription(PN14_Master_Stat1_ST3::PN14_ProdMd_Stat_ST3, "I_C03_PN14_PRODMD_STAT_ST3_ON", iProductionMode_Active);
  
  AuthenticateECU(2);
  
  // All DTC-specific storage conditions fulfilled
  testStep("STEP", "Set SC 1: Control DTC Setting to ON.");
  ControllDTCSetting_On();
  
  testStep("STEP", "SC 2: Set Ignition switch status to: I_C03_ISW_STAT_IGN_ON (SC 2 is fulfilled).");
  setSignal(ISw_Stat_ST3, iIgnitionON);
  WaitforMessage(Ign_Stat_ST3_ID, (Ign_Stat_ST3_Periodicity * 1.1), 1);
  
  testStep("STEP", "SC 3: Set Local voltage.");
  SetVoltage(iVLocal);
  
  testStep("STEP", "SC 4: Set System Voltage.");
  setSignal(PN14_Master_Stat1_ST3::PN14_SupBat_Volt_ST3, iVSystem);
  
  testStep("STEP", "SC 5: Set 'PN14_TransMd_Stat_ST3' signal to Inactive.");
  setSignal(PN14_Master_Stat1_ST3::PN14_TransMd_Stat_ST3, iTransportMode_Inactive);
  
  // SC 8 - ECU is fully communicating
  
  testStep("STEP", "SC 11: Set 'PT4_PTCoor_EngStartPN14_Stat_ST3' signal to not active.");
  setSignal(PT4_PTCoor4_ST3::PT4_PTCoor_EngStartPN14_Stat_ST3, iVehStartup_NoStartup);
  WaitforMessage(PT4_PTCoor4_ST3_ID, (PT4_PTCoor4_ST3_Periodicity * 1.1), 1);
  
  testStep("STEP", "SC 12: Set 'PN14_ProdMd_Stat_ST3' signal to Active.");
  setSignal(PN14_Master_Stat1_ST3::PN14_ProdMd_Stat_ST3, iProductionMode_NotActive);
  WaitforMessage(0x464, 300, 1);
  
  testStep("STEP", "SC 10: Wait more than System Level - Network Communication / Power Distribution SC debounce timer.");
  Wait(fSCDebounceTimer_NetworkCom + 1000);
}

/// <Storage_Conditions>
int CheckSCStatus(int iSC, int iExpectedSCstatus)
{
  return CheckSCStatus(iSC, iExpectedSCstatus, -1, -1, -1, -1, -1, -1);
}

/// <Storage_Conditions>
int CheckSCStatus(int iSC1, int iExpectedSCstatus1, int iSC2, int iExpectedSCstatus2)
{
  return CheckSCStatus(iSC1, iExpectedSCstatus1, iSC2, iExpectedSCstatus2, -1, -1, -1, -1);
}

/// <Storage_Conditions>
int CheckSCStatus(int iSC1, int iExpectedSCstatus1, int iSC2, int iExpectedSCstatus2, int iSC3, int iExpectedSCstatus3)
{
  return CheckSCStatus(iSC1, iExpectedSCstatus1, iSC2, iExpectedSCstatus2, iSC3, iExpectedSCstatus3, -1, -1);
}

/// <Storage_Conditions>
// Evaluates the status of the selected SC(s). All other SCs are evaluated to be true.
// "iSC":               SC ID (enum): use SC1, SC2, etc.
// "iExpectedSCstatus": 0 = not fullfilled
//                      1 = fulfilled
// Returns: 1 if the status is as expected, 0 otherwise.
// Example: CheckSCStatus(SC1, 1, SC10, 0);
// bStorageConditionsStatus: contains RAM address of SC status; needs to be updated every release.
// SC10_1 = PD, SC10_2 = NC, SC10_3 = NC15
int CheckSCStatus(int iSC1, int iExpectedSCstatus1, int iSC2, int iExpectedSCstatus2, int iSC3, int iExpectedSCstatus3, int iSC4, int iExpectedSCstatus4)
{
  diagRequest        * dReadMemoryByAddressReq;
  stack diagResponse * dReadMemoryByAddressResp;
  
  stack int iInputSCs[4][2] = {{iSC1, iExpectedSCstatus1}, {iSC2, iExpectedSCstatus2}, {iSC3, iExpectedSCstatus3}, {iSC4, iExpectedSCstatus4}};
  
  stack byte SCStatus[2];
  stack char cTmpObtained[100];
  stack char cTmpExpected[100];
  stack long EvalManStepTable;
  stack int iTableResult = 0;
  stack int i, x;
  stack int iFoundSC;
  
  dReadMemoryByAddressReq.Resize(elcount(bRMBARequest));
  diagSetPrimitiveData(dReadMemoryByAddressReq, bRMBARequest, elcount(bRMBARequest));
  
  DiagSetPrimitiveByte(dReadMemoryByAddressReq, 2, bStorageConditionsStatus[0]);
  DiagSetPrimitiveByte(dReadMemoryByAddressReq, 3, bStorageConditionsStatus[1]);
  DiagSetPrimitiveByte(dReadMemoryByAddressReq, 4, bStorageConditionsStatus[2]);
  DiagSetPrimitiveByte(dReadMemoryByAddressReq, 5, bStorageConditionsStatus[3]);
  DiagSetPrimitiveByte(dReadMemoryByAddressReq, 6, 0x00);
  DiagSetPrimitiveByte(dReadMemoryByAddressReq, 7, 0x02);
  
  EnterDiagnosticSession("development");
  
  // Diag Error Handling.
  if(SendDiagnosticRequest(dReadMemoryByAddressReq, dReadMemoryByAddressResp) == DIAG_SEND_OR_RECEIVE_ERROR) 
  {
    testStepFail(@sysvar::CORE::sysLevelOfDetailFail, "" ,"GetSCStatus: Diagnostic request send or receive error.");
    return -1;
  }

  // Diag Error Handling.
  if (diagIsPositiveResponse(dReadMemoryByAddressResp) == 0)
  {
    testStepFail(@sysvar::CORE::sysLevelOfDetailFail, "", "GetSCStatus: Negative response received for Read Memory By Address request: [0x%X].", dReadMemoryByAddressResp.GetResponseCode());
    testReportWriteDiagResponse(dReadMemoryByAddressReq);
    return -1;
  }
  
  SCStatus[0] = DiagGetPrimitiveByte(dReadMemoryByAddressResp, 1);
  SCStatus[1] = DiagGetPrimitiveByte(dReadMemoryByAddressResp, 2);
  
  EvalManStepTable = TestInfoTable("Check Storage Conditions.");
  
  // header
  TestInfoHeadingBegin(EvalManStepTable, 0);
  TestInfoCell(EvalManStepTable, "Storage Condition");
  TestInfoCell(EvalManStepTable, "Obtained");
  TestInfoCell(EvalManStepTable, "Expected");
  TestInfoCell(EvalManStepTable, "Result");
  TestInfoHeadingEnd(EvalManStepTable);
  
  for(i = 0; i <= 10; i++)
  {
    TestInfoRow(EvalManStepTable, 0);
    TestInfoCell(EvalManStepTable, SCName[i]);
    if(i < 8)
    {
      snprintf(cTmpObtained, elcount(cTmpObtained), "%i", ((SCStatus[0] & (1 << i)) >> i));
    }
    else
    {
      snprintf(cTmpObtained, elcount(cTmpObtained), "%i", ((SCStatus[1] & (1 << (i - 8))) >> (i - 8)));
    }
    
    TestInfoCell(EvalManStepTable, cTmpObtained);
    for(x = 0; x < elcount(iInputSCs); x++)
    {
      if(i == iInputSCs[x][0])
      {
        snprintf(cTmpExpected, elcount(cTmpExpected), "%i", iInputSCs[x][1]);
        TestInfoCell(EvalManStepTable, cTmpExpected);
        iFoundSC = 1;
        break;
      }
    }

    if(iFoundSC == 0)
    {
      strncpy(cTmpExpected, "1", elcount(cTmpExpected));
      TestInfoCell(EvalManStepTable, "1");
    }
    iFoundSC = 0;
    
    if(strncmp(cTmpObtained, cTmpExpected, elcount(cTmpObtained)) == 0)
    {
      TestInfoCell(EvalManStepTable, "pass");
    }
    else
    {
      TestInfoCell(EvalManStepTable, "fail");
      iTableResult -= 1;
    }
  }
  
  if(iTableResult < 0)
  {
    testStepFail(@sysvar::CORE::sysLevelOfDetailFail, "", EvalManStepTable);
    return 0;
  }
  else
  {
    testStepPass(@sysvar::CORE::sysLevelOfDetailPass, "", EvalManStepTable);
    return 1;
  }
  
  EnterDiagnosticSession("default");
}
/// <Storage_Conditions>
//#define KU16_ERH_SC1_ControlDTC            (1u)
//#define KU16_ERH_SC2_IgnitonStatus         (2u)
//#define KU16_ERH_SC3_LocalVoltage          (4u)
//#define KU16_ERH_SC4_SystemVoltage         (8u)
//#define KU16_ERH_SC5_TransportationMode    (16u)
//#define KU16_ERH_SC8_CommunicationStatus   (32u)
//#define KU16_ERH_SC10_0_debounceTimer        (64u)
//#define KU16_ERH_SC10_1_debounceTimer        (128u)
//#define KU16_ERH_SC10_2_debounceTimer        (256u)
//#define KU16_ERH_SC11_VehicleStartup       (512u)
//#define KU16_ERH_SC12_ProductionMode          (1024u)
//#define KU16_ERH_MASK_DEBOUNCE_TIMER_NC      ((uint16) 0x63B)
//#define KU16_ERH_MASK_DEBOUNCE_TIMER_NC15      ((uint16) 0x639)
//#define KU16_ERH_MASK_DEBOUNCE_TIMER_PD      ((uint16) 0x633)
//#define KU16_ERH_MASK_ECU_LEVEL              (405u)
//#define KU16_ERH_MASK_POWER_DISTRIBUTION     ((uint16)0x673)
//#define KU16_ERH_MASK_NETWORK_COM           ((uint16)0x6BB)
//#define KU16_ERH_MASK_NETWORK_COM15         ((uint16)0x739)
// Waits for all storage conditions to be set to 'TRUE' (10000ms max. wait time).
void WaitDebounceTimer()
{
  diagRequest Diagnostic_User_Role_Read dRreadAuthRoleRequest;
  stack diagResponse Diagnostic_User_Role_Read dRreadAuthRoleResponse;
  diagRequest        * dReadMemoryByAddressReq;
  stack diagResponse * dReadMemoryByAddressResp;
  
  stack float fStartTime = timeNow()/100;
  stack float fTimeSinceStart;
  
  byte resp[100];
  char response[5000];
  
  dReadMemoryByAddressReq.Resize(elcount(bRMBARequest));
  diagSetPrimitiveData(dReadMemoryByAddressReq, bRMBARequest, elcount(bRMBARequest));
  
  DiagSetPrimitiveByte(dReadMemoryByAddressReq, 2, bStorageConditionsStatus[0]);
  DiagSetPrimitiveByte(dReadMemoryByAddressReq, 3, bStorageConditionsStatus[1]);
  DiagSetPrimitiveByte(dReadMemoryByAddressReq, 4, bStorageConditionsStatus[2]);
  DiagSetPrimitiveByte(dReadMemoryByAddressReq, 5, bStorageConditionsStatus[3]);
  DiagSetPrimitiveByte(dReadMemoryByAddressReq, 6, 0x00);
  DiagSetPrimitiveByte(dReadMemoryByAddressReq, 7, 0x02);
  
  if(SendDiagnosticRequest(dRreadAuthRoleRequest, dRreadAuthRoleResponse) == DIAG_SEND_OR_RECEIVE_ERROR)
  {
    testStepFail(@sysvar::CORE::sysLevelOfDetailFail, "" ,"Diagnostic_User_Role_Read: Diagnostic request send or receive error.");
    return;
  }
  
  if(DiagGetPrimitiveByte(dRreadAuthRoleResponse, 3) != 0x02)
  {
    AuthenticateECU(2);
  }
  
  EnterDiagnosticSession("supplier");
  
  while (fTimeSinceStart < 10000)
  {
    // Diag Error Handling.
    if(SendDiagnosticRequest(dReadMemoryByAddressReq, dReadMemoryByAddressResp) == DIAG_SEND_OR_RECEIVE_ERROR) 
    {
      testStepFail(@sysvar::CORE::sysLevelOfDetailFail, "" ,"WaitDebounceTimer: Diagnostic request send or receive error.");
      return;
    }

    // Diag Error Handling.
    if (diagIsPositiveResponse(dReadMemoryByAddressResp) == 0)
    {
      testStepFail(@sysvar::CORE::sysLevelOfDetailFail, "", "WaitDebounceTimer: Negative response received for Read Memory By Address request: [0x%X].", dReadMemoryByAddressResp.GetResponseCode());
      testReportWriteDiagResponse(dReadMemoryByAddressReq);
      return;
    }
    
    fTimeSinceStart = (timeNow() / 100) - fStartTime;
    if ((DiagGetPrimitiveByte(dReadMemoryByAddressResp, 1) == 0xFF) && (DiagGetPrimitiveByte(dReadMemoryByAddressResp, 2) == 0x07))
    {
      testStepPass(@sysvar::CORE::sysLevelOfDetailPass, "", "All storage conditions were set to 'TRUE' in [%.0f] ms.", ((timeNow() / 100) - fStartTime));
      return;
    }
    testWaitForTimeoutSilent(10);
  }
  
  dReadMemoryByAddressResp.GetPrimitiveData(resp, elcount(resp));
  ConvertByteArrInCharArr(resp, response, 0, dReadMemoryByAddressResp.GetPrimitiveSize() - 1, cKeepHexFormat);
  testStepFail(@sysvar::CORE::sysLevelOfDetailFail, "", "Storage conditions were not set to true in [%.0f] ms: %s.", fTimeSinceStart, response);
  return;
}


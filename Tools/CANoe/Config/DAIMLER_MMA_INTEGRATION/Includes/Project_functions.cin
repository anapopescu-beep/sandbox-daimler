/*@!Encoding:1252*/
includes
{  
  #include "Project_configuration.cin"
}

variables
{ 
  // Variable used for test report formatting.
  dword iLevelOfDetailPass = 0;
  dword iLevelOfDetailFail = 0;
  dword iLevelOfDetailStep = 0; 
  
  // Variables used for requirements table.
  char cAllRequirements[50][400];
  char cAllRequirementsDescription[50][5000];
  int iRequirementsIndex = 0;
  int iOriginalTestCaseTitleLength = 0;
  
  char cSide[7] = "RBTMFL";
  char ObtainedSWVersion[15];
  
  // Variables used for 'DetectCycleStep' output.
  const CYCLE_DETECT_ERROR               = 0xFF; // Can be incorrect input, MF block not active, etc.
  const CYCLE_NOT_DETECTED               = 0x00;
  const CYCLE_DETECTED_STEP_NOT_DETECTED = 0x1F;
  const CYCLE_DETECTED                   = 0x10;
  const CYCLE_AND_STEP_DETECTED          = 0x11;
  
}

//Run pre ts.
testfunction RunPreTs()
{
  iLevelOfDetailPass = 3; // Set to < 3 to display passed test steps.
  iLevelOfDetailStep = 3; // Set to < 3 to display test steps.
  
  DisplayRequirementsInfo();
  AddTestSetupInformation();
  
  // Start .blf and .asc logging of whole test case.
  testStep(iLevelOfDetailStep, "", "Start .ASC and .BLF test case logging.");
  PreTS_StartLogging();
  
  // Configure power suppply.
  testStep(iLevelOfDetailStep, "", "Configure power supply Voltage to %.2f V / Current limit to %.2f A then set the output on.", 12.5, 40.0);
  SetVoltage(12.5);
  SetCurrent(40);
  PowerOn();
  
  // Wait for ECU initialization in case PSU was set to off before RunPreTS().
  WaitECUInitialization();
     
  // Change ECU to left system side.
  if(testWaitForMessage(getMessageID("RBTM_FL_Stat_ST3"), 1100) == 1)
  {
   testStep(iLevelOfDetailStep, "", "ECU is already set to left system side.");
   
   SetDiagTarget("RBTMFL174"); // Set diag target to left side.
  }
  else
  {
   SetDiagTarget("RBTMFR174"); // Set diag target to right side.
   
   // Change ECU side.
//   ChangeECUSide("left");
  }

  //Activate measurement frame. --> MF is active by default for R1.1
//  testStep(iLevelOfDetailStep, "", "Activate measurement frame block 0x01");
//  ActivateMeasurementFrame(1);
  
  //Unlock ECU
//  SetECUMode("Unlock");

  //Write default calibration for HB.
//  iRequestSize = ConcatenateTwoByteArrays(bCalibrationRequest, bDefaultCalibration, bRequest);
//  diagResize(dRequest, iRequestSize);
//  diagSetPrimitiveData(dRequest, bRequest, elCount(bRequest));

//  SendDiagnosticRequest(dRequest, dResponse);
//  CheckPositiveResponse("Write default calibration", dRequest, dResponse);
  
  // Security authentification.
  AuthenticateECU(2); // Development_Enhanced
  
  // Enter development session.
  EnterDiagnosticSession("development");
  
  // Activate MF block 1 (Valid for R2.0).
  ActivateMeasurementFrame();
  
  // Write default steps - Valid for R2.0.
  memcpy(bDefaultStepsRequest, bDefaultStepsLibraryRequest, elcount(bDefaultStepsLibraryRequest));
  memcpy_off(bDefaultStepsRequest, 3, bDefaultStepsLibrary, 0, elcount(bDefaultStepsLibrary));
  SendDiagnosticRequest(dWriteStepsConfigRequest, dWriteStepsConfigResponse, bDefaultStepsRequest);
  CheckPositiveResponse("Check positive response for writing steps 0 to 119.", dWriteStepsConfigRequest, dWriteStepsConfigResponse);
  
  // Wait due to issue: 813584 - [DAI_MMA][R02.0][TST][SW] Immediate diagnostic requests after write steps library modify Steps.
  Wait(100);
  
  // Enter default session.
  EnterDiagnosticSession("default");
  
  // Clear DTC memory.
  ClearAll();
  Wait(2000);
  
  // Soft reset ECU.
  ResetECU("soft");
  WaitECUInitialization();
  
  // Check that Start-up cycle is active.
  EvalManStepEqual("Check that Start-up cycle is active.", DetectCycleStep(START_UP, 1000), CYCLE_DETECTED);
  WaitCycleToFinish();
  
  // Check for DTC presence .
  CheckDTCPresenceInBenchInit();
  
  // Check SW version.
  iLevelOfDetailPass = 0; // Set to < 3 to display passed test steps. 
  CheckSWVersion(ObtainedSWVersion);
  EvalManStepEqual("Check Software Version", ObtainedSWVersion, _sSwVersion); 
  iLevelOfDetailPass = 3;
  
  $Bckl_Sw_D_Stat_ST3  = 0; // Buckle switch driver state: 0    = "STAT_OK".
  $Bckl_Sw_FP_Stat_ST3 = 0; // Buckle switch passenger state: 0 = "STAT_OK".
  testWaitForSignalUpdate(Bckl_Sw_D_Stat_ST3, 42);
  
  SetSecTickCount();
  
  // Authenticate with "Job_anybobdy".
  AuthenticateECU(0);
  
  // Enter default session.
  testStep(iLevelOfDetailStep, "", "Enter default session");
  EnterDiagnosticSession("default");
  
  iLevelOfDetailPass = 0; // Set to < 3 to display passed test steps.
  iLevelOfDetailStep = 0; // Set to < 3 to display test steps.
}

//Run post ts.
testfunction RunPostTs()
{
//  byte bRequest[100]; 
//  int index;
//  byte bAllAec[168];
//  int iThermalProtectionTimeout = 0;
  
  iLevelOfDetailPass = 3; // Set to < 3 to display passed test steps.
  iLevelOfDetailStep = 3; // Set to < 3 to display test steps.
    
  //////////////////////////////
  //FIB reset to be made
  //////////////////////////////

  //Set power supply
  testStep(iLevelOfDetailStep, "", "Configure power supply Voltage to %.2f V / Current limit to %.2f A then set the output on.", 12.5, 40.0);
  SetVoltage(12.5);
  SetCurrent(40);
  PowerOn();
  
  // Wait for ECU initialization in case PSU was set to off before RunPreTS().
  WaitECUInitialization();
  
  //Check if SW_Self_Protection is qualified and wait do deskill
//  teststep(iLevelOfDetailStep, "", "Check if SW_Self_Protection is qualified and wait to deskill");
//  EnterDiagnosticSession("supplier");
//  
//  SendDiagnosticRequest(dReadAllAECStatusRequest, dReadAllAECStatusResponse);
//
//  if (diagIsPositiveResponse(dReadAllAECStatusResponse) != 0 )
//  {
//    diagGetPrimitiveData(dReadAllAECStatusResponse, bAllAec, 168);
//  
//    for(index = 1; index <= (elcount(bAllAec)-3)/3; index+=1)
//    {
//      if (strncmp(_sAEC_NameConfig[index-1],"ERR_SW_SELF_PROTECTION", elCount(_sAEC_NameConfig[index-1]))==0 )
//      {
//        while (((bAllAec[index*3+2] == 0x2F) || (bAllAec[index*3+2] == 0x27)) && (iThermalProtectionTimeout < 60))
//        {
//          testWaitForTimeout(10000);
//          EnterDiagnosticSession("supplier");
//          SendDiagnosticRequest(dReadAllAECStatusRequest, dReadAllAECStatusResponse);
//            if (diagIsPositiveResponse(dReadAllAECStatusResponse) != 0 )
//            {
//              diagGetPrimitiveData(dReadAllAECStatusResponse, bAllAec, 168);
//            }
//            else
//            {
////              continue;
//            }
//        }
//        if ( iThermalProtectionTimeout != 0 ) 
//        {
//          if ( iThermalProtectionTimeout < 60 )
//          {
//            testStepPass(iLevelOfDetailPass, "", "ERR_SW_SELF_PROTECTION is deskilled in %d ms", iThermalProtectionTimeout*10000);
//          }
//          else
//          {
//            testStepFail(iLevelOfDetailFail, "AEC", "Autotest failed - Autoliv ERROR Code: %02x - %s - status: %02x",  bAllAec[index*3+1], _sAEC_NameConfig[index-1], bAllAec[index*3+2]);
//          }
//        }
//        else
//        {
//           testStepPass(iLevelOfDetailPass, "", "ERR_SW_SELF_PROTECTION is not qualified");         
//        }
//      }
//    }
//  }
    // Check if SW_Self_Protection fault is active and wait for it's deskill time if it is.
   if((GetDTCStatusByExtendedData(_dDTC_GENERAL_FAILURE) & 0x01) == 0x01)
   {
     ReturnDTCStatusChangeTime(_dDTC_GENERAL_FAILURE, _bDeskilledFailed, 2500, 300000);   
   }
  
  
  //Activate measurement frame
//  testStep(iLevelOfDetailStep, "", "Activate measurement frame block 0x01");
//  ActivateMeasurementFrame(1);
  
  //Security authentification.
//  testStep(iLevelOfDetailStep, "", "Obtain security authentification");
//  AuthenticateECU(2); // Development_Enhanced
//  
//  // Enter development session.
//  EnterDiagnosticSession("development");
//  
//  //Write default steps - Valid for R1.1
//  testStep("STEP", "Write tensioning cycles with default steps");
//  dWriteStepsConfigRequest.SetPrimitiveData(bWriteDefaultStepsLibraryA, elcount(bWriteDefaultStepsLibraryA));
//  
//  SendDiagnosticRequest(dWriteStepsConfigRequest, dWriteStepsConfigResponse);
//  CheckPositiveResponse("Check positive response for writing steps 0 to 19", dWriteStepsConfigRequest, dWriteStepsConfigResponse);
//  
//  // Enter  default session.
//  EnterDiagnosticSession("default");
//  
  //Clear DTC memory.
  ClearAll();
  Wait(2000);
    
  // Security authentification.
  AuthenticateECU(2); // Development_Enhanced
  
  //Soft reset ECU.
  ResetECU("soft");
  WaitECUInitialization();

  // Check that Start-up cycle is active.
  EvalManStepEqual("Check that Start-up cycle is active", DetectCycleStep(START_UP, 1000), CYCLE_DETECTED);
  WaitCycleToFinish();
  
  // Check DTC presence.
  CheckDTCPresenceAfterClear();
  
  //////////////////////////////
  //Warm reset detection to be made
  //////////////////////////////
  
  testStep(iLevelOfDetailStep, "", "Enter default session");
  EnterDiagnosticSession("default");
  
  testStep(iLevelOfDetailStep, "", "Stop .ASC and .BLF test case logging.");
  PostTS_StopLogging();
    
  iLevelOfDetailPass = 0; // Set to < 3 to display passed test steps.
  iLevelOfDetailStep = 0; // Set to < 3 to display test steps.
  iOriginalTestCaseTitleLength = 0; // Useful to set logs name. Please do not remove.
}

/// <DTC_management>
//Configure first byte of block 12 to read the status of the AEC
//void ConfigureBlock12ForDTCReading(char sAutotestName[])
//{
//  int iIndex;
//  
//  iLevelOfDetailPass = 3;
//  
//  toUpper(sAutotestName, sAutotestName, elcount(sAutotestName));
//  
//  ActivateMeasurementFrame(12);
//  
//  DiagSetPrimitiveByte(dWriteMeasurementFrameBlock12Request, 3, _erh_au8AecStatus[0]);
//  DiagSetPrimitiveByte(dWriteMeasurementFrameBlock12Request, 4, _erh_au8AecStatus[1]);
//  DiagSetPrimitiveByte(dWriteMeasurementFrameBlock12Request, 5, _erh_au8AecStatus[2]);
//  DiagSetPrimitiveByte(dWriteMeasurementFrameBlock12Request, 6, _erh_au8AecStatus[3]);
//  DiagSetPrimitiveByte(dWriteMeasurementFrameBlock12Request, 7, 0x01);
//  
//  for(iIndex = 0; iIndex < elcount(_sAEC_NameConfig); iIndex++)
//  {
//    if (strncmp(sAutotestName, _sAEC_NameConfig[iIndex], elcount(_sAEC_NameConfig[iIndex])) == 0)
//    {
//      DiagSetPrimitiveByte(dWriteMeasurementFrameBlock12Request, 6, _bAEC_CodeConfig[iIndex]+_erh_au8AecStatus[3]);
//      
//      SetECUMode("unlock");
//      
//      SendDiagnosticRequest(dWriteMeasurementFrameBlock12Request, dWriteMeasurementFrameBlock12Response);
//      if(CheckPositiveResponse(dWriteMeasurementFrameBlock12Request, dWriteMeasurementFrameBlock12Response) ==1)
//      {
//        testStep("", "%s AEC is configured on block 12", _sAEC_NameConfig[iIndex]);
//        SetECUMode("lock");
//        break;
//      }
//      else
//      {
//        SendDiagnosticRequest(dWriteMeasurementFrameBlock12Request, dWriteMeasurementFrameBlock12Response);
//        if(CheckPositiveResponse(dWriteMeasurementFrameBlock12Request, dWriteMeasurementFrameBlock12Response) == 1)
//        {
//          testStep("", "%s AEC is configured on block 12", _sAEC_NameConfig[iIndex]);
//          SetECUMode("lock");
//          break;
//        }
//      }
//      SetECUMode("lock");
//    }
//  }
//  
//  if ( iIndex >= elcount(_sAEC_NameConfig))
//  {
//    testStepFail("", "AEC name is not valid -> %s", sAutotestName);
//  }
//  
//  iLevelOfDetailPass = 0;
//}

/// <DTC_management>
//Check the duration in which the AEC status is changed
//float ReturnAECStatusChangeTime(char sAutotestName[], byte bExpectedStatus, int iAutotestPeriod, float fMaxAECStatusChangeTime)
//{
//  int iIndex;
//  float fStartTime, fCurrentTime;
//  
//  toUpper(sAutotestName, sAutotestName, elcount(sAutotestName));
//  fStartTime = timeNow()/100;
//  fCurrentTime = 0;
//  
//  DiagSetPrimitiveByte(dReadMemoryByAddressRequest, 1, 0x24);
//  DiagSetPrimitiveByte(dReadMemoryByAddressRequest, 2, _erh_au8AecStatus[0]);
//  DiagSetPrimitiveByte(dReadMemoryByAddressRequest, 3, _erh_au8AecStatus[1]);
//  DiagSetPrimitiveByte(dReadMemoryByAddressRequest, 4, _erh_au8AecStatus[2]);
//  DiagSetPrimitiveByte(dReadMemoryByAddressRequest, 5, _erh_au8AecStatus[3]);
//  DiagSetPrimitiveByte(dReadMemoryByAddressRequest, 6, 0x00);
//  DiagSetPrimitiveByte(dReadMemoryByAddressRequest, 7, 0x01);
//  
//  for(iIndex = 0; iIndex < elcount(_sAEC_NameConfig); iIndex++)
//  {
//    if (strncmp(sAutotestName, _sAEC_NameConfig[iIndex], elcount(_sAEC_NameConfig[iIndex])) == 0)
//    {
//      DiagSetPrimitiveByte(dReadMemoryByAddressRequest, 5, _bAEC_CodeConfig[iIndex]+_erh_au8AecStatus[3]);
//
//      fCurrentTime = timeNow()/100;
//      while ((fCurrentTime - fStartTime) <= fMaxAECStatusChangeTime)
//      {
//        GetSecurityAccess("supplier");
//        
//        SendDiagnosticRequest(dReadMemoryByAddressRequest, dReadMemoryByAddressResponse);
//        
//        if (CheckPositiveResponse(dReadMemoryByAddressRequest, dReadMemoryByAddressResponse) == 1)
//        {
//          if (DiagGetPrimitiveByte(dReadMemoryByAddressResponse, 1) == bExpectedStatus)
//          {
//            testStep("", "%s AEC status 0x%02x is changed in %.f ms ", _sAEC_NameConfig[iIndex], DiagGetPrimitiveByte(dReadMemoryByAddressResponse, 1), fCurrentTime - fStartTime);
//            return fCurrentTime - fStartTime;
//            break;
//          }
//          else
//          {
//            fCurrentTime = timeNow()/100;
//          }
//        }
//        else
//        {
//          testStepWarning("", "Negative response received in CheckAECStatus");
//        }
//        fCurrentTime = timeNow()/100;
//      }
//      if ((fCurrentTime - fStartTime) > fMaxAECStatusChangeTime)
//      {
//        testStepFail("", "%s AEC status 0x%02x is NOT changed after %.f ms ", _sAEC_NameConfig[iIndex], DiagGetPrimitiveByte(dReadMemoryByAddressResponse, 1), (fCurrentTime - fStartTime));
//        return fCurrentTime - fStartTime;
//        break;
//      }
//    }
//  }
//  if ( iIndex >= elcount(_sAEC_NameConfig))
//  {
//    testStepFail("", "AEC name is not valid -> %s", sAutotestName);
//  }
//  return fCurrentTime - fStartTime;
//}


/// <CAN_Communication>
//Activate measurement frame block 1.
void ActivateMeasurementFrame()
{
  byte bActivateMF[7] = {0x2E, 0xFE, 0xFF, 0x01, 0x00, 0x00, 0x00};
  
  diagResize(dActivateMFRequest, 7);
  
  SendDiagnosticRequest(dActivateMFRequest, dActivateMFResponse, bActivateMF);
  CheckPositiveResponse("Check positive response for activation of Measurement frame block 1.", dActivateMFRequest, dActivateMFResponse);
}

/// <CAN_Communication>
//Activate measurement frame with two blocks
//void ActivateMeasurementFrame(int iBlock, int iBlock2)
//{
//  byte bMfDefaultConfigBlock[7];
//  
//  bMfDefaultConfigBlock[0] = 0x2E;
//  bMfDefaultConfigBlock[1] = 0xFE;
//  bMfDefaultConfigBlock[2] = 0xFF;
//  bMfDefaultConfigBlock[3] = 0x02;
//  bMfDefaultConfigBlock[4] = 0x00;
//  bMfDefaultConfigBlock[5] = 0x00;
//  bMfDefaultConfigBlock[6] = 0x00;
//  
//  switch(iBlock)
//  {
//    case 1:
//      bMfDefaultConfigBlock[6] = bMfDefaultConfigBlock[6] + 0x01;
//      break;
//    case 2:
//      bMfDefaultConfigBlock[6] = bMfDefaultConfigBlock[6] + 0x02;
//      break;
//    case 3:
//      bMfDefaultConfigBlock[6] = bMfDefaultConfigBlock[6] + 0x04;
//      break;
//    case 4:
//      bMfDefaultConfigBlock[6] = bMfDefaultConfigBlock[6] + 0x08;
//      break;
//    case 5:
//      bMfDefaultConfigBlock[6] = bMfDefaultConfigBlock[6] + 0x10;
//      break;
//    case 6:
//      bMfDefaultConfigBlock[6] = bMfDefaultConfigBlock[6] + 0x20;
//      break;
//    case 7:
//      bMfDefaultConfigBlock[6] = bMfDefaultConfigBlock[6] + 0x40;
//      break;
//    case 8:
//      bMfDefaultConfigBlock[6] = bMfDefaultConfigBlock[6] + 0x80;
//      break;
//    case 9:
//      bMfDefaultConfigBlock[5] = bMfDefaultConfigBlock[5] + 0x01;
//      break;
//    case 10:
//      bMfDefaultConfigBlock[5] = bMfDefaultConfigBlock[5] + 0x02;
//      break;
//    case 11:
//      bMfDefaultConfigBlock[5] = bMfDefaultConfigBlock[5] + 0x04;
//      break;
//    case 12:
//      bMfDefaultConfigBlock[5] = bMfDefaultConfigBlock[5] + 0x08;
//      break;
//    case 13:
//      bMfDefaultConfigBlock[5] = bMfDefaultConfigBlock[5] + 0x10;
//      break;
//    case 14:
//      bMfDefaultConfigBlock[5] = bMfDefaultConfigBlock[5] + 0x20;
//      break;
//    case 15:
//      bMfDefaultConfigBlock[5] = bMfDefaultConfigBlock[5] + 0x40;
//      break;
//    case 16:
//      bMfDefaultConfigBlock[5] = bMfDefaultConfigBlock[5] + 0x80;
//      break;
//    case 17:
//      bMfDefaultConfigBlock[4] = bMfDefaultConfigBlock[4] + 0x01;
//      break;
//    case 18:
//      bMfDefaultConfigBlock[4] = bMfDefaultConfigBlock[4] + 0x02;
//      break;
//    case 19:
//      bMfDefaultConfigBlock[4] = bMfDefaultConfigBlock[4] + 0x04;
//      break;
//    case 20:
//      bMfDefaultConfigBlock[4] = bMfDefaultConfigBlock[4] + 0x08;
//      break;
//    case 21:
//      bMfDefaultConfigBlock[4] = bMfDefaultConfigBlock[4] + 0x10;
//      break;
//    case 22:
//      bMfDefaultConfigBlock[4] = bMfDefaultConfigBlock[4] + 0x20;
//      break;
//    case 23:
//      bMfDefaultConfigBlock[4] = bMfDefaultConfigBlock[4] + 0x40;
//      break;
//    case 24:
//      bMfDefaultConfigBlock[4] = bMfDefaultConfigBlock[4] + 0x80;
//      break;
//    default:
//      testStepFail(iLevelOfDetailFail, "Error", "Invalid block number for measurement frame configuration");
//      break;
//  }
//  
//  switch(iBlock2)
//  {
//    case 1:
//      bMfDefaultConfigBlock[6] = bMfDefaultConfigBlock[6] + 0x01;
//      break;
//    case 2:
//      bMfDefaultConfigBlock[6] = bMfDefaultConfigBlock[6] + 0x02;
//      break;
//    case 3:
//      bMfDefaultConfigBlock[6] = bMfDefaultConfigBlock[6] + 0x04;
//      break;
//    case 4:
//      bMfDefaultConfigBlock[6] = bMfDefaultConfigBlock[6] + 0x08;
//      break;
//    case 5:
//      bMfDefaultConfigBlock[6] = bMfDefaultConfigBlock[6] + 0x10;
//      break;
//    case 6:
//      bMfDefaultConfigBlock[6] = bMfDefaultConfigBlock[6] + 0x20;
//      break;
//    case 7:
//      bMfDefaultConfigBlock[6] = bMfDefaultConfigBlock[6] + 0x40;
//      break;
//    case 8:
//      bMfDefaultConfigBlock[6] = bMfDefaultConfigBlock[6] + 0x80;
//      break;
//    case 9:
//      bMfDefaultConfigBlock[5] = bMfDefaultConfigBlock[5] + 0x01;
//      break;
//    case 10:
//      bMfDefaultConfigBlock[5] = bMfDefaultConfigBlock[5] + 0x02;
//      break;
//    case 11:
//      bMfDefaultConfigBlock[5] = bMfDefaultConfigBlock[5] + 0x04;
//      break;
//    case 12:
//      bMfDefaultConfigBlock[5] = bMfDefaultConfigBlock[5] + 0x08;
//      break;
//    case 13:
//      bMfDefaultConfigBlock[5] = bMfDefaultConfigBlock[5] + 0x10;
//      break;
//    case 14:
//      bMfDefaultConfigBlock[5] = bMfDefaultConfigBlock[5] + 0x20;
//      break;
//    case 15:
//      bMfDefaultConfigBlock[5] = bMfDefaultConfigBlock[5] + 0x40;
//      break;
//    case 16:
//      bMfDefaultConfigBlock[5] = bMfDefaultConfigBlock[5] + 0x80;
//      break;
//    case 17:
//      bMfDefaultConfigBlock[4] = bMfDefaultConfigBlock[4] + 0x01;
//      break;
//    case 18:
//      bMfDefaultConfigBlock[4] = bMfDefaultConfigBlock[4] + 0x02;
//      break;
//    case 19:
//      bMfDefaultConfigBlock[4] = bMfDefaultConfigBlock[4] + 0x04;
//      break;
//    case 20:
//      bMfDefaultConfigBlock[4] = bMfDefaultConfigBlock[4] + 0x08;
//      break;
//    case 21:
//      bMfDefaultConfigBlock[4] = bMfDefaultConfigBlock[4] + 0x10;
//      break;
//    case 22:
//      bMfDefaultConfigBlock[4] = bMfDefaultConfigBlock[4] + 0x20;
//      break;
//    case 23:
//      bMfDefaultConfigBlock[4] = bMfDefaultConfigBlock[4] + 0x40;
//      break;
//    case 24:
//      bMfDefaultConfigBlock[4] = bMfDefaultConfigBlock[4] + 0x80;
//      break;
//    default:
//      testStepFail(iLevelOfDetailFail, "Error", "Invalid block number for measurement frame configuration");
//      break;
//  }
//  SetECUMode("unlock");
//  diagResize(dRequest, 7);
//  diagSetPrimitiveData(dRequest, bMfDefaultConfigBlock, elCount(bMfDefaultConfigBlock));
//  SendDiagnosticRequest(dRequest, dResponse);
//  CheckPositiveResponse("Measurement frame blocks are activated with 10ms periodicity", dRequest, dResponse);
//  SetECUMode("lock");
//}

/// <CAN_Communication>
//Activate measurement frame with three blocks
//void ActivateMeasurementFrame(int iBlock, int iBlock2, int iBlock3)
//{
//  byte bMfDefaultConfigBlock[7];
//    
//  bMfDefaultConfigBlock[0] = 0x2E;
//  bMfDefaultConfigBlock[1] = 0xFE;
//  bMfDefaultConfigBlock[2] = 0xFF;
//  bMfDefaultConfigBlock[3] = 0x02;
//  bMfDefaultConfigBlock[4] = 0x00;
//  bMfDefaultConfigBlock[5] = 0x00;
//  bMfDefaultConfigBlock[6] = 0x00;
//  
//  switch(iBlock)
//  {
//    case 1:
//      bMfDefaultConfigBlock[6] = bMfDefaultConfigBlock[6] + 0x01;
//      break;
//    case 2:
//      bMfDefaultConfigBlock[6] = bMfDefaultConfigBlock[6] + 0x02;
//      break;
//    case 3:
//      bMfDefaultConfigBlock[6] = bMfDefaultConfigBlock[6] + 0x04;
//      break;
//    case 4:
//      bMfDefaultConfigBlock[6] = bMfDefaultConfigBlock[6] + 0x08;
//      break;
//    case 5:
//      bMfDefaultConfigBlock[6] = bMfDefaultConfigBlock[6] + 0x10;
//      break;
//    case 6:
//      bMfDefaultConfigBlock[6] = bMfDefaultConfigBlock[6] + 0x20;
//      break;
//    case 7:
//      bMfDefaultConfigBlock[6] = bMfDefaultConfigBlock[6] + 0x40;
//      break;
//    case 8:
//      bMfDefaultConfigBlock[6] = bMfDefaultConfigBlock[6] + 0x80;
//      break;
//    case 9:
//      bMfDefaultConfigBlock[5] = bMfDefaultConfigBlock[5] + 0x01;
//      break;
//    case 10:
//      bMfDefaultConfigBlock[5] = bMfDefaultConfigBlock[5] + 0x02;
//      break;
//    case 11:
//      bMfDefaultConfigBlock[5] = bMfDefaultConfigBlock[5] + 0x04;
//      break;
//    case 12:
//      bMfDefaultConfigBlock[5] = bMfDefaultConfigBlock[5] + 0x08;
//      break;
//    case 13:
//      bMfDefaultConfigBlock[5] = bMfDefaultConfigBlock[5] + 0x10;
//      break;
//    case 14:
//      bMfDefaultConfigBlock[5] = bMfDefaultConfigBlock[5] + 0x20;
//      break;
//    case 15:
//      bMfDefaultConfigBlock[5] = bMfDefaultConfigBlock[5] + 0x40;
//      break;
//    case 16:
//      bMfDefaultConfigBlock[5] = bMfDefaultConfigBlock[5] + 0x80;
//      break;
//    case 17:
//      bMfDefaultConfigBlock[4] = bMfDefaultConfigBlock[4] + 0x01;
//      break;
//    case 18:
//      bMfDefaultConfigBlock[4] = bMfDefaultConfigBlock[4] + 0x02;
//      break;
//    case 19:
//      bMfDefaultConfigBlock[4] = bMfDefaultConfigBlock[4] + 0x04;
//      break;
//    case 20:
//      bMfDefaultConfigBlock[4] = bMfDefaultConfigBlock[4] + 0x08;
//      break;
//    case 21:
//      bMfDefaultConfigBlock[4] = bMfDefaultConfigBlock[4] + 0x10;
//      break;
//    case 22:
//      bMfDefaultConfigBlock[4] = bMfDefaultConfigBlock[4] + 0x20;
//      break;
//    case 23:
//      bMfDefaultConfigBlock[4] = bMfDefaultConfigBlock[4] + 0x40;
//      break;
//    case 24:
//      bMfDefaultConfigBlock[4] = bMfDefaultConfigBlock[4] + 0x80;
//      break;
//    default:
//      testStepFail(iLevelOfDetailFail, "Error", "Invalid block number for measurement frame configuration");
//      break;
//  }
//    switch(iBlock2)
//  {
//    case 1:
//      bMfDefaultConfigBlock[6] = bMfDefaultConfigBlock[6] + 0x01;
//      break;
//    case 2:
//      bMfDefaultConfigBlock[6] = bMfDefaultConfigBlock[6] + 0x02;
//      break;
//    case 3:
//      bMfDefaultConfigBlock[6] = bMfDefaultConfigBlock[6] + 0x04;
//      break;
//    case 4:
//      bMfDefaultConfigBlock[6] = bMfDefaultConfigBlock[6] + 0x08;
//      break;
//    case 5:
//      bMfDefaultConfigBlock[6] = bMfDefaultConfigBlock[6] + 0x10;
//      break;
//    case 6:
//      bMfDefaultConfigBlock[6] = bMfDefaultConfigBlock[6] + 0x20;
//      break;
//    case 7:
//      bMfDefaultConfigBlock[6] = bMfDefaultConfigBlock[6] + 0x40;
//      break;
//    case 8:
//      bMfDefaultConfigBlock[6] = bMfDefaultConfigBlock[6] + 0x80;
//      break;
//    case 9:
//      bMfDefaultConfigBlock[5] = bMfDefaultConfigBlock[5] + 0x01;
//      break;
//    case 10:
//      bMfDefaultConfigBlock[5] = bMfDefaultConfigBlock[5] + 0x02;
//      break;
//    case 11:
//      bMfDefaultConfigBlock[5] = bMfDefaultConfigBlock[5] + 0x04;
//      break;
//    case 12:
//      bMfDefaultConfigBlock[5] = bMfDefaultConfigBlock[5] + 0x08;
//      break;
//    case 13:
//      bMfDefaultConfigBlock[5] = bMfDefaultConfigBlock[5] + 0x10;
//      break;
//    case 14:
//      bMfDefaultConfigBlock[5] = bMfDefaultConfigBlock[5] + 0x20;
//      break;
//    case 15:
//      bMfDefaultConfigBlock[5] = bMfDefaultConfigBlock[5] + 0x40;
//      break;
//    case 16:
//      bMfDefaultConfigBlock[5] = bMfDefaultConfigBlock[5] + 0x80;
//      break;
//    case 17:
//      bMfDefaultConfigBlock[4] = bMfDefaultConfigBlock[4] + 0x01;
//      break;
//    case 18:
//      bMfDefaultConfigBlock[4] = bMfDefaultConfigBlock[4] + 0x02;
//      break;
//    case 19:
//      bMfDefaultConfigBlock[4] = bMfDefaultConfigBlock[4] + 0x04;
//      break;
//    case 20:
//      bMfDefaultConfigBlock[4] = bMfDefaultConfigBlock[4] + 0x08;
//      break;
//    case 21:
//      bMfDefaultConfigBlock[4] = bMfDefaultConfigBlock[4] + 0x10;
//      break;
//    case 22:
//      bMfDefaultConfigBlock[4] = bMfDefaultConfigBlock[4] + 0x20;
//      break;
//    case 23:
//      bMfDefaultConfigBlock[4] = bMfDefaultConfigBlock[4] + 0x40;
//      break;
//    case 24:
//      bMfDefaultConfigBlock[4] = bMfDefaultConfigBlock[4] + 0x80;
//      break;
//    default:
//      testStepFail(iLevelOfDetailFail, "Error", "Invalid block number for measurement frame configuration");
//      break;
//  }
//  switch(iBlock3)
//  {
//    case 1:
//      bMfDefaultConfigBlock[6] = bMfDefaultConfigBlock[6] + 0x01;
//      break;
//    case 2:
//      bMfDefaultConfigBlock[6] = bMfDefaultConfigBlock[6] + 0x02;
//      break;
//    case 3:
//      bMfDefaultConfigBlock[6] = bMfDefaultConfigBlock[6] + 0x04;
//      break;
//    case 4:
//      bMfDefaultConfigBlock[6] = bMfDefaultConfigBlock[6] + 0x08;
//      break;
//    case 5:
//      bMfDefaultConfigBlock[6] = bMfDefaultConfigBlock[6] + 0x10;
//      break;
//    case 6:
//      bMfDefaultConfigBlock[6] = bMfDefaultConfigBlock[6] + 0x20;
//      break;
//    case 7:
//      bMfDefaultConfigBlock[6] = bMfDefaultConfigBlock[6] + 0x40;
//      break;
//    case 8:
//      bMfDefaultConfigBlock[6] = bMfDefaultConfigBlock[6] + 0x80;
//      break;
//    case 9:
//      bMfDefaultConfigBlock[5] = bMfDefaultConfigBlock[5] + 0x01;
//      break;
//    case 10:
//      bMfDefaultConfigBlock[5] = bMfDefaultConfigBlock[5] + 0x02;
//      break;
//    case 11:
//      bMfDefaultConfigBlock[5] = bMfDefaultConfigBlock[5] + 0x04;
//      break;
//    case 12:
//      bMfDefaultConfigBlock[5] = bMfDefaultConfigBlock[5] + 0x08;
//      break;
//    case 13:
//      bMfDefaultConfigBlock[5] = bMfDefaultConfigBlock[5] + 0x10;
//      break;
//    case 14:
//      bMfDefaultConfigBlock[5] = bMfDefaultConfigBlock[5] + 0x20;
//      break;
//    case 15:
//      bMfDefaultConfigBlock[5] = bMfDefaultConfigBlock[5] + 0x40;
//      break;
//    case 16:
//      bMfDefaultConfigBlock[5] = bMfDefaultConfigBlock[5] + 0x80;
//      break;
//    case 17:
//      bMfDefaultConfigBlock[4] = bMfDefaultConfigBlock[4] + 0x01;
//      break;
//    case 18:
//      bMfDefaultConfigBlock[4] = bMfDefaultConfigBlock[4] + 0x02;
//      break;
//    case 19:
//      bMfDefaultConfigBlock[4] = bMfDefaultConfigBlock[4] + 0x04;
//      break;
//    case 20:
//      bMfDefaultConfigBlock[4] = bMfDefaultConfigBlock[4] + 0x08;
//      break;
//    case 21:
//      bMfDefaultConfigBlock[4] = bMfDefaultConfigBlock[4] + 0x10;
//      break;
//    case 22:
//      bMfDefaultConfigBlock[4] = bMfDefaultConfigBlock[4] + 0x20;
//      break;
//    case 23:
//      bMfDefaultConfigBlock[4] = bMfDefaultConfigBlock[4] + 0x40;
//      break;
//    case 24:
//      bMfDefaultConfigBlock[4] = bMfDefaultConfigBlock[4] + 0x80;
//      break;
//    default:
//      testStepFail(iLevelOfDetailFail, "Error", "Invalid block number for measurement frame configuration");
//      break;
//  }
//  SetECUMode("unlock");
//  diagResize(dRequest, 7);
//  diagSetPrimitiveData(dRequest, bMfDefaultConfigBlock, elCount(bMfDefaultConfigBlock));
//  SendDiagnosticRequest(dRequest, dResponse);
//  CheckPositiveResponse("Measurement frame blocks are activated with 10ms periodicity", dRequest, dResponse);
//  SetECUMode("lock");
//}

/// <CAN_Communication>
//Wait until first measurement frame appears on CAN bus
//void WaitECUInitialization()
//{
//  int iResult;
//  int iCount;
//
//  testWaitForTimeout(20);
//  iResult = testWaitForMessage(@sysvar::ProjectConfiguration::sysMeasurementFrameID, 10);
//  iCount = 0;
//  while ((iCount <= 200) && (iResult != 1))
//  {
//    iResult = testWaitForMessage(@sysvar::ProjectConfiguration::sysMeasurementFrameID, 10);
//    iCount += 1;
//  }
//  if (iResult == 1)
//  {
//    testStep(iLevelOfDetailStep, "", "ECU initialized in %d ms", (iCount*10)+30);
//  }
//  else
//  {
//    testStepFail(iLevelOfDetailFail, "", "Frame Not found in %d ms", iCount*10);
//  }
//}

/// <CAN_Communication>
//Wait until first MF appears on CAN bus.
void WaitECUInitialization()
{
  stack int iResult;
  stack int iCount = 0;
  char targetName[100];
  
  // R2.0: Sometimes (1/20 tests) reset lasts longer which causes SF (0x698) to be received before MF.
  // Awaited frame to be revised in later releases.
  
  testWaitForTimeout(50);
  
  diagGetCurrentEcu(targetName, elcount(targetName));
  if (strncmp(targetName, sTargetECUFrontLeftName, elcount(cSide)) == 0)
  {
    iResult = testWaitForMessage(0x18E1A490x, 10); // Measurement frame FL
  
    while ((iCount <= 200) && (iResult != 1))
    {
      iResult = testWaitForMessage(0x18E1A490x, 10);
      iCount += 1;
    }
    if (iResult == 1)
    {
      testStep(iLevelOfDetailStep, "", "ECU initialized in %d ms", (iCount*10)+30);
    }
    else
    {
      testStepFail(iLevelOfDetailFail, "", "Frame Not found in %d ms", iCount*10);
    }
  }
  else
  {
    iResult = testWaitForMessage(0x18E1A590x, 10); // Measurement frame FR
  
    while ((iCount <= 200) && (iResult != 1))
    {
      iResult = testWaitForMessage(0x18E1A590x, 10);
      iCount += 1;
    }
    if (iResult == 1)
    {
      testStep(iLevelOfDetailStep, "", "ECU initialized in %d ms", (iCount*10)+30);
    }
    else
    {
      testStepFail(iLevelOfDetailFail, "", "Frame Not found in %d ms", iCount*10);
    }
  }     
}

/// <CAN_Communication>
// Set Buckle State buckled or unbuckeld state. To be updated according DAG spec.!!!!!!!!!
//void SetBuckleState(char sSide[], char sState[])
//{
//  toUpper(sSide, sSide, elcount(sSide));
//  toUpper(sState, sState, elcount(sState));
//    
//  if (strncmp(sSide,"FRONT_LEFT", elcount(sSide)) == 0)
//    {
//     write("left");
//     // $RGS_VL_Anforderung_XIX_RGS_Anf_01_XIX_Airbag_SUBCANFD01 = sState;
//     // testWaitForSignalChange(RGS_VL_Anforderung_XIX_RGS_Anf_01_XIX_Airbag_SUBCANFD01, 100);      
//    }
//  
//  if (strncmp(sSide,"FRONT_RIGHT", elcount(sSide)) == 0)
//    {
//      write("right");
//     // $RGS_VR_Anforderung_XIX_RGS_Anf_01_XIX_Airbag_SUBCANFD01 = sState;
//     // testWaitForSignalChange(RGS_VR_Anforderung_XIX_RGS_Anf_01_XIX_Airbag_SUBCANFD01, 100);     
//    }
//}

/// <CAN_Communication>
//Check the time in which a signal value is changed from one value to another
//long CheckSignalChangeTime(signal * aSignal, float fInitValue, float fEndValue)
//{
//  dword FirstValueTimestamp, LastValueTimestamp;
//  long errHandle;
//  
//  FirstValueTimestamp = 0x00;
//  LastValueTimestamp = 0x00;
//  
//  errHandle = testWaitForSignalMatch(aSignal, fInitValue, 1000);
//  switch(errHandle)
//  {
//    case 2: 
//      testStepFail(iLevelOfDetailFail,"", "Signal value %x not found in %d ms ", fInitValue, 1000);
//      return -1;
//      break;
//    case -2:
//      testStepFail(iLevelOfDetailFail,"", "Signal not found");
//      return -1;
//      break;
//  }
//  
//  FirstValueTimestamp = getSignalTime(aSignal);  
//  
//  testWaitForSignalMatch(aSignal, fEndValue, 2000);
//    switch(errHandle)
//  {
//    case 2: 
//      testStepFail(iLevelOfDetailFail,"", "Signal value %x not found in %d ms ", fInitValue, 1000);
//      return -1;
//      break;
//    case -2:
//      testStepFail(iLevelOfDetailFail,"", "Signal not found");
//      return -1;
//      break;
//  }
//  
//  LastValueTimestamp = getSignalTime(aSignal);
//  
//  return (LastValueTimestamp-FirstValueTimestamp)/100;
//  
//}

/// <CAN_Communication>
//Function that retunrs information from measurement frame
//Examples: // If Measurement Frame Block 1 is with these dates: 0x01 0x12 0x11 0x00 0x00 0x00 0x00 0x00
            // GetMeasurementFrameInfo(1,1,2) [Block 1, Start Byte 1, Stop Byte 2 => selected data from above: '0x12 0x11'] => returns value in Int: 4625
//int64 GetMeasurementFrameInfo(int iBlock, int iStartPos, int iStopPos)
//{
//  int   res;
//  int   iFlag;
//  int   iCount;
//  int   iIndex;
//  int   iBlockID;
//  int   iMaxValue;
//  int64 iReturnValue;
//  char  temp[20];
//  char  temp1[20];
//  char  buffer[20];
//  char  _cBytesValues[7][3];
//  char  _sMeasurementFrameSignals[7][25] = {"Measurement_VL_Byte1","Measurement_VL_Byte2","Measurement_VL_Byte3","Measurement_VL_Byte4","Measurement_VL_Byte5","Measurement_VL_Byte6","Measurement_VL_Byte7"};
//  
//  iIndex = 0;
//  iCount = 0;
//  iMaxValue = 1000;
//  testWaitForTimeout(20);
//  snprintf(buffer, 3, "%c%c", '0','x');
//  iFlag = testWaitForMessage(@sysvar::ProjectConfiguration::sysMeasurementFrameID, 10);
//  
//  while ((iCount < 200) && (iFlag != 1))
//  {
//    iFlag = testWaitForMessage(@sysvar::ProjectConfiguration::sysMeasurementFrameID, 10);
//    iCount += 1;
//  }
//  
//  if (iFlag == 1)
//  {
//    iBlockID = getSignal(Measurement_VL_BlockId);
//    while((iBlock != iBlockID) && (iCount < iMaxValue))
//    {
//      testWaitForTimeout(5);
//      iCount += 1;
//      iBlockID = getSignal(Measurement_VL_BlockId);
//    }
//    if(iCount<iMaxValue)
//    {
//      if((iStartPos > 0 && iStartPos < 8) && (iStopPos > 0 && iStopPos < 8))
//      {
//        for(iIndex=0;iIndex<elCount(_cBytesValues);iIndex++)
//        {
//          if(getRawSignal(_sMeasurementFrameSignals[iIndex])< 16)
//          {
//            snprintf(_cBytesValues[iIndex], 3, "%X%X", 0, getRawSignal(_sMeasurementFrameSignals[iIndex]));
//          }
//          
//          else 
//          {
//            snprintf(_cBytesValues[iIndex], 3, "%X%X", getRawSignal(_sMeasurementFrameSignals[iIndex]));
//          }
//          
//          strncat(temp,_cBytesValues[iIndex],2*iIndex+3);
//        }
//        
//        substr_cpy(temp1, temp,2*iStartPos-2, 2*(iStopPos-iStartPos)+2, elCount(buffer));
//        strncat(buffer,temp1,elCount(buffer));
//        res = strtoll(buffer,iReturnValue);
//        return iReturnValue;
//      }
//      else
//      {
//        testStepFail(iLevelOfDetailFail, "", "Start/Stop position out of range. Wrong StartPos: %d [OR] StopPos: %d", iStartPos, iStopPos);
//        return -1;
//      }
//    }
//    else
//    {
//      testStepFail(iLevelOfDetailFail, "", "Measurement Frame Block: %d is NOT active.", iBlock);
//      return -1;
//    }
//  }
//  else
//  {
//    testStepFail(iLevelOfDetailFail, "", "Measurement Frame Not found in %d ms", iCount*10);
//    return -1;
//  }
//}
/// <DTC_management>
//Chek that one AEC has an expected status. Ignored autotests will not be considered in this evaluation
//void CheckAECStatus(char sAutotestName[], byte bExpectedStatus, char sAutotestNameIgnored[])
//{
//  int iIndex, iIndex1;
//  byte bAllAec[168];
//  int iErrorFlag;
//  int flag;
//  
//  iErrorFlag = 0;
//  
//  toUpper(sAutotestName, sAutotestName, elcount(sAutotestName));
//  toUpper(sAutotestNameIgnored, sAutotestNameIgnored, elcount(sAutotestNameIgnored));
//  iIndex = 0;
//  iIndex1 = 0;
//  flag = 0;
//  EnterDiagnosticSession("supplier");
//  
//  SendDiagnosticRequest(dReadAllAECStatusRequest, dReadAllAECStatusResponse);
//  if (diagIsPositiveResponse(dReadAllAECStatusResponse) == 0)
//  {
//    testStepFail(iLevelOfDetailFail, "", "No response for Read All AEC Status request");
//    testReportWriteDiagResponse(dReadAllAECStatusRequest);
//  }
//  diagGetPrimitiveData(dReadAllAECStatusResponse, bAllAec, 168);
//
//  for(iIndex = 1; iIndex <= (elcount(bAllAec)-3)/3; iIndex++)
//  {
//    if (strncmp(sAutotestName, _sAEC_NameConfig[iIndex-1], elcount(_sAEC_NameConfig[iIndex-1])) == 0)
//    {
//      if (bAllAec[iIndex*3+2] == bExpectedStatus)
//      {
//        testStepPass(iLevelOfDetailPass, "", "AEC -> %s found with status 0x%02X",  _sAEC_NameConfig[iIndex-1], bAllAec[iIndex*3+2]);
//      }
//      else
//      {
//        testStepFail(iLevelOfDetailFail, "", "AEC -> %s found with status 0x%02X and NOT with 0x%02x ",  _sAEC_NameConfig[iIndex-1], bAllAec[iIndex*3+2], bExpectedStatus);
//      }
//      
//      for(iIndex1 = 1; iIndex1 <= (elcount(bAllAec)-3)/3; iIndex1+=1)
//      {
//        if ((bAllAec[iIndex1*3+2] != 0x00) && (bAllAec[iIndex1*3+2] != 0x40))
//        {
//          if (strncmp(sAutotestNameIgnored, _sAEC_NameConfig[iIndex1-1], elcount(_sAEC_NameConfig[iIndex1-1])) == 0)  
//          {
//            if (strncmp(sAutotestName, _sAEC_NameConfig[iIndex1-1], elcount(_sAEC_NameConfig[iIndex1-1])) != 0)
//            testStep(iLevelOfDetailStep, "", "AEC -> %s found with status 0x%02X and ignored",  _sAEC_NameConfig[iIndex1-1], bAllAec[iIndex1*3+2]);
//          }
//          else
//          {
//            if (strncmp(sAutotestName, _sAEC_NameConfig[iIndex1-1], elcount(_sAEC_NameConfig[iIndex1-1])) != 0)
//            testStepFail(iLevelOfDetailFail, "", "AEC -> %s found with status 0x%02X and NOT ignored",  _sAEC_NameConfig[iIndex1-1], bAllAec[iIndex1*3+2]);
//          }
//        }
//      }
//      break;
//    }
//  }
//  
//  if ( flag == 0 )
//  {
//     testStepWarning("", "%s not valid for CheckAECStatusFromRam function", sAutotestName);
//  }
//}

/// <DTC_management>
//Check on RAM that one AEC has an expected status
//void CheckAECStatusFromRam(char sAutotestName[],byte bExpectedStatus)
//{
//  int iIndex, iIndex1;
//  int flag;
//  
//  toUpper(sAutotestName, sAutotestName, elcount(sAutotestName));
//  
//  iIndex = 0;
//  iIndex1 = 0;
//  flag = 0;
//  
//  DiagSetPrimitiveByte(dReadMemoryByAddressRequest, 1, 0x24);
//  DiagSetPrimitiveByte(dReadMemoryByAddressRequest, 2, _erh_au8AecStatus[0]);
//  DiagSetPrimitiveByte(dReadMemoryByAddressRequest, 3, _erh_au8AecStatus[1]);
//  DiagSetPrimitiveByte(dReadMemoryByAddressRequest, 4, _erh_au8AecStatus[2]);
//  DiagSetPrimitiveByte(dReadMemoryByAddressRequest, 5, _erh_au8AecStatus[3]);
//  DiagSetPrimitiveByte(dReadMemoryByAddressRequest, 6, 0x00);
//  DiagSetPrimitiveByte(dReadMemoryByAddressRequest, 7, 0x01);
//  
//  for(iIndex = 0; iIndex < elcount(_sAEC_NameConfig); iIndex++)
//  {
//    if (strncmp(sAutotestName, _sAEC_NameConfig[iIndex], elcount(_sAEC_NameConfig[iIndex])) == 0)
//    {
//      flag = 1;
//      
//      DiagSetPrimitiveByte(dReadMemoryByAddressRequest, 5, _bAEC_CodeConfig[iIndex]+_erh_au8AecStatus[3]);
//      
//      GetSecurityAccess("supplier");
//      SendDiagnosticRequest(dReadMemoryByAddressRequest, dReadMemoryByAddressResponse);
//      
//      if (CheckPositiveResponse(dReadMemoryByAddressRequest, dReadMemoryByAddressResponse) == 1)
//      {
//        if (DiagGetPrimitiveByte(dReadMemoryByAddressResponse, 1) == bExpectedStatus)
//        {
//          testStepPass(iLevelOfDetailPass, "", "AEC -> %s found with status 0x%02X",  _sAEC_NameConfig[iIndex], DiagGetPrimitiveByte(dReadMemoryByAddressResponse, 1));
//        }
//        else
//        {
//          testStepFail(iLevelOfDetailFail, "", "AEC -> %s found with status 0x%02X and NOT with 0x%02x ",  _sAEC_NameConfig[iIndex], DiagGetPrimitiveByte(dReadMemoryByAddressResponse, 1), bExpectedStatus);
//        }
//      }
//      else
//      {
//        testStepWarning("", "Negative response received in CheckAECStatusFromRam");
//      }
//      break;
//    }
//  }
//  
//  if ( flag == 0 )
//  {
//     testStepWarning("", "%s not valid for CheckAECStatusFromRam function", sAutotestName);
//  }
//}

/// <DTC_management>
//Check that all critical autotests are executed
//void CheckCriticalStatus(char sCriticalAutotestStatus[])
//{
//  toLower(sCriticalAutotestStatus, sCriticalAutotestStatus, elcount(sCriticalAutotestStatus));
//  
//  DiagSetPrimitiveByte(dReadMemoryByAddressRequest, 1, 0x24);
//  DiagSetPrimitiveByte(dReadMemoryByAddressRequest, 2, M_u32_ModesStatus[0]);
//  DiagSetPrimitiveByte(dReadMemoryByAddressRequest, 3, M_u32_ModesStatus[1]);
//  DiagSetPrimitiveByte(dReadMemoryByAddressRequest, 4, M_u32_ModesStatus[2]);
//  DiagSetPrimitiveByte(dReadMemoryByAddressRequest, 5, M_u32_ModesStatus[3]);
//  DiagSetPrimitiveByte(dReadMemoryByAddressRequest, 6, 0x00);
//  DiagSetPrimitiveByte(dReadMemoryByAddressRequest, 7, 0x01);
//  
//  if ( strncmp(sCriticalAutotestStatus, "true", elcount(sCriticalAutotestStatus)) == 0)
//  {
//    GetSecurityAccess("supplier");
//    
//    SendDiagnosticRequest(dReadMemoryByAddressRequest, dReadMemoryByAddressResponse);
//    
//    if ( CheckPositiveResponse(dReadMemoryByAddressRequest, dReadMemoryByAddressResponse) == 1 )
//    {
//      if ( DiagGetPrimitiveByte(dReadMemoryByAddressResponse, 1) == 0 )
//      {
//        testStepPass(iLevelOfDetailPass, "", "All critical autotests are executed");
//      }
//      else
//      {
//        testStepFail(iLevelOfDetailFail, "", "Not All critical autotests are executed");
//      }
//
//    }
//    else
//    {
//      testStepFail(iLevelOfDetailFail, "", "Reading Critical autotests status from RAM failed");
//    }
//  }
//  else
//  {
//    if ( strncmp(sCriticalAutotestStatus, "false", elcount(sCriticalAutotestStatus)) == 0)
//    {
//      GetSecurityAccess("supplier");
//      
//      SendDiagnosticRequest(dReadMemoryByAddressRequest, dReadMemoryByAddressResponse);
//      
//      if ( CheckPositiveResponse(dReadMemoryByAddressRequest, dReadMemoryByAddressResponse) == 1 )
//      {
//        if ( DiagGetPrimitiveByte(dReadMemoryByAddressResponse, 1) == 1 )
//        {
//          testStepPass(iLevelOfDetailPass, "", "Not All critical autotests are executed");
//        }
//        else
//        {
//          testStepFail(iLevelOfDetailFail, "", "All critical autotests are executed");
//        }
//
//      }
//      else
//      {
//        testStepFail(iLevelOfDetailFail, "", "Reading Critical autotests status from RAM failed");
//      }
//    }
//    else
//    {
//      testStepWarning("", "Invalid parameter for CheckCriticalStatus function");
//    }
//  }
//}

/// <DTC_management>
//Creates fault to the ECU based on the autotest name
void CreateFault(char sAutotestName[])
{
  char cFIBResponse[1000];
  char cExpectedFIBResponse[1000];
  toUpper(sAutotestName, sAutotestName, elCount(sAutotestName));

  if (strncmp(sAutotestName, "BAT_PWR_OVER_VOLTAGE", elcount(sAutotestName)) == 0)
  {
    SetVoltage(NVP_u16OverKL30QualificationThrs + 0.8);
    testStepPass("", "BAT_PWR_OVER_VOLTAGE fault created");
  }
  else
  {
    if (strncmp(sAutotestName, "BAT_PWR_UNDER_VOLTAGE", elcount(sAutotestName)) == 0)
    {
      SetVoltage(NVP_u16UnderKL30QualificationThrs - 0.2);
      testStepPass("", "BAT_PWR_UNDER_VOLTAGE fault created");
    }
    else
    {
      if (strncmp(sAutotestName, "BAT_PWR_UNDER_VOLTAGE_TENSIONING", elcount(sAutotestName)) == 0)
      {
        SetVoltage(NVP_u16UnderKL30DuringTensQualificationThrs - 0.2);
        testStepPass("", "BAT_PWR_UNDER_VOLTAGE_TENSIONING fault created");
      }
      else
      {
        if (strncmp(sAutotestName, "BAT_PWR_OVER_VOLTAGE_TENSIONING", elcount(sAutotestName)) == 0)
        {
          SetVoltage(NVP_u16OverKL30DuringTensQualificationThrs + 0.6);
          testStepPass("", "BAT_PWR_UNDER_VOLTAGE_TENSIONING fault created");
        }
        else  
          if (strncmp(sAutotestName, "HW_SELF_PROTECTION", elcount(sAutotestName)) == 0)
          {
            Set_DAC_Voltage(_iVIS_RELEASE, NVP_u16HWSelfProtecCurrentThrs + 100,  cFIBResponse);
            snprintf(cExpectedFIBResponse, elcount(cExpectedFIBResponse), "Set DAC voltage to %i mV performed OK on channel %i", NVP_u16HWSelfProtecCurrentThrs + 100, _iVIS_RELEASE);
            EvalManStepEqual("Make FIB fault.",  cFIBResponse, cExpectedFIBResponse);

            Perform_Leakage(_iVIS_RELEASE, "false", "DAC", cFIBResponse);
            strncpy(cExpectedFIBResponse, "", elcount(cExpectedFIBResponse));
            snprintf(cExpectedFIBResponse, elcount(cExpectedFIBResponse), "Short to DAC performed OK on channel %i", _iVIS_RELEASE);
            EvalManStepEqual("Make FIB fault.",  cFIBResponse, cExpectedFIBResponse);
            testStepPass("", "HW_SELF_PROTECTION fault created");
          }
          else
          {
            testStepFail("", "Parameter value: %s for CreateFault function is invalid", sAutotestName);
          }
      }
    }
  }
}

/// <DTC_management>
//Removes a fault
void RemoveFault(char sAutotestName[])
{
  char cFIBResponse[1000];
  char cExpectedFIBResponse[1000];
  toUpper(sAutotestName, sAutotestName, elCount(sAutotestName));
  
  if (strncmp(sAutotestName, "BAT_PWR_OVER_VOLTAGE", elcount(sAutotestName)) == 0)
  {
    SetVoltage(_fBAT_NOMINAL_VALUE);
    testStep("", "BAT_PWR_OVER_VOLTAGE fault is removed");
  }
  else
  {
    if (strncmp(sAutotestName, "BAT_PWR_UNDER_VOLTAGE", elcount(sAutotestName)) == 0)
    {
      SetVoltage(_fBAT_NOMINAL_VALUE);
      testStep("", "BAT_PWR_UNDER_VOLTAGE fault is removed");
    }
    else
    {
      if (strncmp(sAutotestName, "BAT_PWR_UNDER_VOLTAGE_TENSIONING", elcount(sAutotestName)) == 0)
      {
        SetVoltage(_fBAT_NOMINAL_VALUE);
        testStep("", "BAT_PWR_UNDER_VOLTAGE_TENSIONING fault is removed");
      }
      else
      {
        if (strncmp(sAutotestName, "BAT_PWR_OVER_VOLTAGE_TENSIONING", elcount(sAutotestName)) == 0)
        {
          SetVoltage(_fBAT_NOMINAL_VALUE);
          testStep("", "BAT_PWR_OVER_VOLTAGE_TENSIONING fault is removed");
        }
        else  
          if (strncmp(sAutotestName, "HW_SELF_PROTECTION", elcount(sAutotestName)) == 0)
          {
            Set_DAC_Voltage(_iVIS_RELEASE, NVP_u16HWSelfProtecCurrentThrs - 150,  cFIBResponse);
            snprintf(cExpectedFIBResponse, elcount(cExpectedFIBResponse), "Set DAC voltage to %i mV performed OK on channel %i", NVP_u16HWSelfProtecCurrentThrs - 150, _iVIS_RELEASE);
            EvalManStepEqual("Make FIB fault.",  cFIBResponse, cExpectedFIBResponse);

            Perform_Leakage(_iVIS_RELEASE, "false", "DAC", cFIBResponse);
            strncpy(cExpectedFIBResponse, "", elcount(cExpectedFIBResponse));
            snprintf(cExpectedFIBResponse, elcount(cExpectedFIBResponse), "Short to DAC performed OK on channel %i", _iVIS_RELEASE);
            EvalManStepEqual("Make FIB fault.",  cFIBResponse, cExpectedFIBResponse);
            
            Remove_Fault(_iVIS_RELEASE, cFIBResponse);
            strncpy(cExpectedFIBResponse, "", elcount(cExpectedFIBResponse));
            snprintf(cExpectedFIBResponse, elcount(cExpectedFIBResponse), "Remove fault performed OK on channel %i", _iVIS_RELEASE);
            EvalManStepEqual("Remove FIB fault.",  cFIBResponse, cExpectedFIBResponse);
            testStepPass("", "HW_SELF_PROTECTION fault is removed");
          }
          else
          {
            testStepFail("", "Parameter value: %s for RemoveFault function is invalid", sAutotestName);
          }
      }
    }
  }
}
  
/// <Helpers>
// Reads the Software version.
// "cSoftwareVersion" = Char array where SW version will be saved.
// Example:           CheckSwVersion() => "ER01473H.P30" char array assigned to "cSoftwareVersion".
void CheckSWVersion(char cSoftwareVersion[])
{
  byte bSWVPositiveResponse[6];
  
  SendDiagnosticRequest(dReadSWVersionRequest, dReadSWVersionResponse);
  
  //CheckPositiveResponse("ReadSWVersion check positive response",dReadSWVersionRequest,dReadSWVersionResponse); 
  
  dReadSWVersionResponse.GetPrimitiveData(bSWVPositiveResponse, elcount(bSWVPositiveResponse));
  ConvertByteArrInCharArr(bSWVPositiveResponse, cSoftwareVersion, dReadSWVersionRequest.GetPrimitiveSize(), elcount(bSWVPositiveResponse) - 1, "true");
}

/// <Helpers>
// Sets the data for a requirements table row.
// "cRequirement" = requrement under test.
// "cRequirementDescription" = requirement description.
void AddRequirementInfo(char cRequirement[], char cRequirementDescription[])
{
  strncpy(cAllRequirements[iRequirementsIndex], cRequirement, elcount(cAllRequirements[iRequirementsIndex]));
  strncpy(cAllRequirementsDescription[iRequirementsIndex], cRequirementDescription, elcount(cAllRequirementsDescription[iRequirementsIndex]));
  iRequirementsIndex++;
}

/// <Helpers>
void AddTestSetupInformation()
{
  TestReportAddMiscInfoBlock("Test equipment");
  TestReportAddMiscInfo("Tester Name",  cTesterName);
  TestReportAddMiscInfo("CAN case ID", cCAN_CaseId);
  TestReportAddMiscInfo("SBC Board", cSBC_BOARD);
  TestReportAddMiscInfo("Power supply ID", cPowerSupply1Id);
  TestReportAddMiscInfo("Motherboard", cMOTHER_BOARD);
  TestReportAddMiscInfo("MCU", cMCU);
  TestReportAddMiscInfo("DUT", cDUT);
  TestReportAddMiscInfo("HW Info", cHWVersion); 
}

/// <Helpers>
// Displays the test header based on data added with "AddRequirementInfo" function.
void DisplayRequirementsInfo()
{
  int i;
  char cTimeBuffer[64];
  char cTestCaseTitle[1024];  
  
  TestReportAddExtendedInfo("html", "<table>"
                                        "<tr>"
                                          "<th style='color:rgb(255, 255, 255);font-style:italic;font-weight:bold;text-transform:uppercase;' bgcolor='#2e90e5'>%s</th>"
                                          "<th style='color:rgb(4, 45, 229);font-style:italic;font-weight:bold' bgcolor='#d3e9f6'>%s</th>"
                                        "</tr>"
                                    "</table>"
                                    , cAllRequirements[0], cAllRequirementsDescription[0]);
  
  TestReportAddExtendedInfo("html", "<table> <tr>"
                                         "<th style='color:rgb(255, 255, 255);font-style:italic;font-weight:bold;text-transform:uppercase;' bgcolor='#2e90e5'>Requirement</th>"
                                         "<th style='text-transform:uppercase;color:rgb(255, 255, 255);' bgcolor='2e90e5'>Description of the requirement</th>"
                                    "</tr>");
  
  for(i = 1; i < iRequirementsIndex; i++)
  {
    TestReportAddExtendedInfo("html", "<tr>"
                                          "<td style='color:rgb(4, 45, 229);font-style:italic;font-weight:bold' bgcolor='#d3e9f6'>%s</td>"
                                          "<td style='color:rgb(4, 45, 229);font-style:italic;' bgcolor='#d3e9f6'>%s</td>" 
                                      "</tr>"
                                      , cAllRequirements[i], cAllRequirementsDescription[i]);
  }
  TestReportAddExtendedInfo("html", "</table>");
  
  iRequirementsIndex = 0;
  // Add timestamp to test case name.
  strncpy(cTestCaseTitle, "", 1); 
  
  getLocalTimeString(cTimeBuffer);
  str_replace(cTimeBuffer, " ", "_");
  str_replace(cTimeBuffer, ":", "_");
  str_replace(cTimeBuffer, "__", "_");
  
  if (strstr_regex(cTimeBuffer, "[a-z]_[0-9]_") != -1)
  {
    str_replace(cTimeBuffer, (strstr_regex(cTimeBuffer, "[a-z]_[0-9]_") + 1), "_0", 1); // Sets day number on two characters.
  }
   
  testGetCurrentTestCaseTitle(cTestCaseTitle, elcount(cTestCaseTitle));
  iOriginalTestCaseTitleLength = strlen(cTestCaseTitle);

  strncat(cTestCaseTitle, "_", elcount(cTestCaseTitle));
  strncat(cTestCaseTitle, cTimeBuffer, elcount(cTestCaseTitle));
  
  TestCaseTitle("", cTestCaseTitle);
}

/// <Helpers>
void ConfigureTestModuleInformation()
{
  InitCycleParameters();
  
  TestReportAddEngineerInfo("Tester Name", cTesterName);
  TestReportAddSetupInfo("CAN case ID", cCAN_CaseId);
  TestReportAddSetupInfo("Power supply ID", cPowerSupply1Id);
  TestReportAddSetupInfo("Motherboard", cMOTHER_BOARD);
  TestReportAddSetupInfo("SBC Board", cSBC_BOARD);
  TestReportAddSetupInfo("MCU", cMCU);
  TestReportAddSUTInfo("DUT", cDUT);
  TestReportAddSUTInfo("HW Info", cHWVersion); 
  InitParameters();
  diagSetTarget("RBTMFL174");
}

/// <Helpers>
//Concatenate two byte arrays and returns the length of the output array
long ConcatenateTwoByteArrays(byte bByteArray1[], byte bByteArray2[], byte bByteArrayOut[])
{
  stack int i;
  stack int j;
  stack long iSize = 0;
  
  for (i = 0; i < elcount(bByteArray1); i++)
  {
    bByteArrayOut[i] = bByteArray1[i];
    iSize += 1;
  }
  for (j = 0; j < elcount(bByteArray2)-1; j++)
  {
    bByteArrayOut[iSize] = bByteArray2[j];
    iSize += 1;
  }
  
  return iSize+1;
}

/// <Helpers>
// Converts a byte array to a char array.
// "inputArr[]"   = Input byte array.
// "cOutputArray" = Char array where output will be saved.
// "StartIndex"   = Conversion start index. Starts from 0.
// "StopIndex"    = Conversion stop index.
// "cFormat"      Option 1: "true"  = keep hex format.
//                Option 2: "false" = convert to char.
// Example:       Software Version diag response = {62, fd, 01, 45, 52, 30, 31, 34, 37, 33, 48, 2e, 50, 33, 30}.
//                ConvertArrByteInArrChar(bSoftwareVersion, cSoftwareVersion, ReadSWVersionReq.GetPrimitiveSize(), elcount(bSoftwareVersion) - 1, true)
// Result:        Option 1: bSoftwareVersion converted to char array "0x45 0x52 0x30 0x31 0x34 0x37 0x33 0x48 0x2E 0x50 0x33 0x30" and assigned to cOutputArray.
//                Option 2: bSoftwareVersion converted to char array "ER01473H.P30" and assigned to cOutputArray.
void ConvertByteArrInCharArr(byte bInputArr[], char cOutputArray[], int iStartIndex, int iStopIndex, char cFormat[])
{
  stack char tmp[6];
  stack int iOptionOneIndex;
  
  strncpy(cOutputArray, "", elcount(cOutputArray));
  
  toLower(cFormat, cFormat, elcount(cFormat));
  
  if(iStartIndex > (elcount(bInputArr) - 1) || iStartIndex < 0 || iStopIndex >= elcount(bInputArr) || iStartIndex > iStopIndex) 
  {
    testStepFail(iLevelOfDetailFail, "-", "Incorrect index or array size; Please check parameters for ConvertByteArrInCharArr function.");
  }
  else
  {
    if(strncmp(cFormat, "true", elcount(cFormat)) == 0)
    {
      iOptionOneIndex = (iStopIndex - iStartIndex + 1) * 5;
      for(iStartIndex; iStartIndex <= iStopIndex; iStartIndex++)
          {
            snprintf(tmp, elcount(tmp), "0x%02X ", bInputArr[iStartIndex]);
            strncat(cOutputArray, tmp, elcount(cOutputArray)); 
          }
      snprintf(cOutputArray, iOptionOneIndex, "%s", cOutputArray); // removes last empty character.
    }
    // Make sure "cOutputArray" is large enough.
    else if ((strncmp(cFormat, "false", elcount(cFormat)) == 0) && (elcount(cOutputArray) >= iStopIndex - iStartIndex + 2)) 
         {
          for(iStartIndex; iStartIndex <= iStopIndex; iStartIndex++)
          {
            snprintf(tmp,elcount(tmp), "%c", bInputArr[iStartIndex]);  
            strncat(cOutputArray, tmp, elcount(cOutputArray)); 
          }
         }
    else testStepFail(iLevelOfDetailFail, "-", "Incorrect format sellection or output array size; Please check parameters for ConvertByteArrInCharArr function.");
  }
}

/// <Helpers>
// Output will be saved in "bInput".
void SwapBytes(byte bInput[])
{
  stack int i;
  stack int64 iSwappedValue = 0;
  
  if(elcount(bInput) < 9)
  {
    for(i = 0; i < elcount(bInput); i++)
    {
      iSwappedValue += bInput[i] << ((7 - i) * 8);
    }
    
    iSwappedValue = swapInt64(iSwappedValue);
    
    for(i = 0; i < elcount(bInput); i++)
    {
      bInput[i] = iSwappedValue >> ((7 - i) * 8);
    }
  }
  else
  {
   testStepFail(iLevelOfDetailFail, "", "Input is too large ( > 8 bytes) for SwapBytes function.");
  }
}

/// <Helpers>
void Wait(dword fWaitTime)
{
  testStep(iLevelOfDetailStep, "", "Wait %lu ms", fWaitTime);
  testWaitForTimeout(fWaitTime);
}
/// <HESS>
//Function that simulates a speed in mm/s using only one parameter
//Examples: // SetBeltSpeed(100); // SetBeltSpeed(-100); //SetBeltSpeed(0);
//void SetBeltSpeed(int iSpeed)
//{
//  int  res;
//  int  iCount;
//  long iByte1;
//  long iByte2;
//  long iByte3;
//  long iSerialBytes;
//  char tmp1[2];
//  char tmp2[2];
//  char buffer[20];
//  char byte1[5]="0x";
//  char byte2[5]="0x";
//  char byte3[5]="0x";
//  byte inputArray[3] = {0x00, 0x00, 0x00};
//    
//  iSerialBytes = 0;  
//  
//  snprintf(byte1, 3, "%c%c", '0','x');
//  snprintf(byte2, 3, "%c%c", '0','x');
//  snprintf(byte3, 3, "%c%c", '0','x');
// 
//  if (1==rs232Open(iHESSport))
//  {
//    rs232Configure(iHESSport, iBaudrateHESS, iByteSizeHESS, iStopbitHESS, iParityHESS);
//  
//    if(iSpeed > 0)
//    {
//
//      iSerialBytes = 1048576 | iSpeed;
//      snprintf(buffer, elCount(buffer), "%02X",iSerialBytes);
//      
//      // Byte1
//      snprintf(tmp1, elCount(tmp1), "%c", buffer[0]);
//      snprintf(tmp2, elCount(tmp2), "%c", buffer[1]);
//      strncat(byte1,tmp1,4);
//      strncat(byte1,tmp2,5);
//      res = strtol(byte1,iByte1);
//            
//      // Byte2
//      snprintf(tmp1, elCount(tmp1), "%c", buffer[2]);
//      snprintf(tmp2, elCount(tmp2), "%c", buffer[3]);
//      strncat(byte2,tmp1,4);
//      strncat(byte2,tmp2,5);
//      res = strtol(byte2,iByte2);
//      
//      // Byte3
//      snprintf(tmp1, elCount(tmp1), "%c", buffer[4]);
//      snprintf(tmp2, elCount(tmp2), "%c", buffer[5]);
//      strncat(byte3,tmp1,5);
//      strncat(byte3,tmp2,5);
//      res = strtol(byte3,iByte3);
//      
//      inputArray[0] = iByte1;
//      inputArray[1] = iByte2;
//      inputArray[2] = iByte3;
//      
//      rs232Send(iHESSport,inputArray,elcount(inputArray));
//      testStep("", "Simulated values: %d, %d, %d", iByte1, iByte2, iByte3);
//    }
//      
//    if(iSpeed < 0)
//    {
//      iSerialBytes = iSpeed*(-1);
//      snprintf(buffer, elCount(buffer), "%X",iSerialBytes);
//      
//      if(strlen(buffer)==1)
//      {
//        strncat(byte3,buffer,5);
//        res = strtol(byte3,iByte3);
//      
//        inputArray[0] = 0x00;
//        inputArray[1] = 0x00;
//        inputArray[2] = iByte3;
//      
//        rs232Send(iHESSport,inputArray,elcount(inputArray));
//        testStep("", "Simulated values: %d, %d, %d", inputArray[0], inputArray[1], iByte3);
//      }
//    
//      if(strlen(buffer)==2)
//      {
//        strncat(byte3,buffer,5);
//        res = strtol(byte3,iByte3);
//      
//        inputArray[0] = 0x00;
//        inputArray[1] = 0x00;
//        inputArray[2] = iByte3;
//      
//        rs232Send(iHESSport,inputArray,elcount(inputArray));
//        testStep("", "Simulated values: %d, %d, %d", inputArray[0], inputArray[1], iByte3);
//      }
//      
//      if(strlen(buffer)==3)
//      {
//      
//        // Byte2
//        snprintf(tmp1, elCount(tmp1), "%c", buffer[0]);
//        strncat(byte2,tmp1,4);
//        res = strtol(byte2,iByte2);
//              
//        // Byte3
//        snprintf(tmp1, elCount(tmp1), "%c", buffer[1]);
//        snprintf(tmp2, elCount(tmp2), "%c", buffer[2]);
//        strncat(byte3,tmp1,4);
//        strncat(byte3,tmp2,5);
//        res = strtol(byte3,iByte3);
//      
//        inputArray[0] = 0x00;
//        inputArray[1] = iByte2;
//        inputArray[2] = iByte3;
//      
//        rs232Send(iHESSport,inputArray,elcount(inputArray));
//        testStep("", "Simulated values: %d, %d, %d", inputArray[0], iByte2, iByte3);
//      
//      }
//      
//      if(strlen(buffer)==4)
//      {
//        // Byte2
//        snprintf(tmp1, elCount(tmp1), "%c", buffer[0]);
//        snprintf(tmp2, elCount(tmp2), "%c", buffer[1]);
//        strncat(byte2,tmp1,4);
//        strncat(byte2,tmp2,5);
//        res = strtol(byte2,iByte2);
//            
//        // Byte3
//        snprintf(tmp1, elCount(tmp1), "%c", buffer[2]);
//        snprintf(tmp2, elCount(tmp2), "%c", buffer[3]);
//        strncat(byte3,tmp1,4);
//        strncat(byte3,tmp2,5);
//        res = strtol(byte3,iByte3);
//        
//        inputArray[0] = 0x00;
//        inputArray[1] = iByte2;
//        inputArray[2] = iByte3;
//
//        rs232Send(iHESSport,inputArray,elcount(inputArray));
//        testStep("", "Simulated values: %d, %d, %d", inputArray[0], iByte2, iByte3);
//      }
//    }
//    
//    if(iSpeed == 0) 
//    {
//      for(iCount=0; iCount<elcount(inputArray); iCount++)
//      {
//        inputArray[iCount] = 0x00;
//      }
//      
//      rs232Send(iHESSport,inputArray,elcount(inputArray));
//    }
//    
//    testStepPass(iLevelOfDetailPass, "Simulation done", "Simulated speed: %dmm/s", iSpeed);
//
//  }
//    
//  else
//  {
//    testStepFail(iLevelOfDetailFail, "COM Port Failure","Can't open COM port: %d",iHESSport);
//  }
//  
//  TestWaitForTimeout(200);
//  rs232Close(iHESSport);
//  
//}

/// <HESS>
//Function that simulates a speed in mm/s using two parameters
//Examples: // SetBeltSpeed(100,1); // SetBeltSpeed(-100,1);
//void SetBeltSpeed(int iSpeed, int iBlock)
//{ 
//  int  res;
//  int  iCount;
//  long iByte1;
//  long iByte2;
//  long iByte3;
//  long iSerialBytes;
//  long iNumberOfCounts;
//  char tmp1[2];
//  char tmp2[2];
//  char buffer[20];
//  char byte1[5]="0x";
//  char byte2[5]="0x";
//  char byte3[5]="0x";
//  byte inputArray[3] = {0x00, 0x00, 0x00};
//  
//  iSerialBytes = 0;
//  iNumberOfCounts = 0;
//  
//  snprintf(byte1, 3, "%c%c", '0','x');
//  snprintf(byte2, 3, "%c%c", '0','x');
//  snprintf(byte3, 3, "%c%c", '0','x');
//  
//  if (1==rs232Open(iHESSport))
//  {
//    rs232Configure(iHESSport, iBaudrateHESS, iByteSizeHESS, iStopbitHESS, iParityHESS);
//    
//    if (iBlock >= 0 && iBlock < 8)
//    {
//      
//      if(iSpeed > 0)
//      {
//        iNumberOfCounts = iBlock<<21;
//        iSerialBytes = 1048576 | iSpeed | iNumberOfCounts;
//        snprintf(buffer, elCount(buffer), "%02X",iSerialBytes);
//        
//        // Byte1
//        snprintf(tmp1, elCount(tmp1), "%c", buffer[0]);
//        snprintf(tmp2, elCount(tmp2), "%c", buffer[1]);
//        strncat(byte1,tmp1,4);
//        strncat(byte1,tmp2,5);
//        res = strtol(byte1,iByte1);
//              
//        // Byte2
//        snprintf(tmp1, elCount(tmp1), "%c", buffer[2]);
//        snprintf(tmp2, elCount(tmp2), "%c", buffer[3]);
//        strncat(byte2,tmp1,4);
//        strncat(byte2,tmp2,5);
//        res = strtol(byte2,iByte2);
//        
//        // Byte3
//        snprintf(tmp1, elCount(tmp1), "%c", buffer[4]);
//        snprintf(tmp2, elCount(tmp2), "%c", buffer[5]);
//        strncat(byte3,tmp1,4);
//        strncat(byte3,tmp2,5);
//        res = strtol(byte3,iByte3);
//        
//        inputArray[0] = iByte1;
//        inputArray[1] = iByte2;
//        inputArray[2] = iByte3;
//        
//        rs232Send(iHESSport,inputArray,elcount(inputArray));
//        testStep("", "Simulated values: %d, %d, %d", iByte1, iByte2, iByte3);
//      }
//      
//      if(iSpeed < 0)
//      {
//        iNumberOfCounts = iBlock<<21;
//  			iSerialBytes = 1048576 | iSpeed | iNumberOfCounts;
//        iSerialBytes = iSpeed*(-1)| iNumberOfCounts;
//        snprintf(buffer, elCount(buffer), "%02X",iSerialBytes);
//        
//        // Byte1
//        snprintf(tmp1, elCount(tmp1), "%c", buffer[0]);
//        snprintf(tmp2, elCount(tmp2), "%c", buffer[1]);
//        strncat(byte1,tmp1,4);
//        strncat(byte1,tmp2,5);
//        res = strtol(byte1,iByte1);
//              
//        // Byte2
//        snprintf(tmp1, elCount(tmp1), "%c", buffer[2]);
//        snprintf(tmp2, elCount(tmp2), "%c", buffer[3]);
//        strncat(byte2,tmp1,4);
//        strncat(byte2,tmp2,5);
//        res = strtol(byte2,iByte2);
//        
//        // Byte3
//        snprintf(tmp1, elCount(tmp1), "%c", buffer[4]);
//        snprintf(tmp2, elCount(tmp2), "%c", buffer[5]);
//        strncat(byte3,tmp1,4);
//        strncat(byte3,tmp2,5);
//        res = strtol(byte3,iByte3);
//        
//        inputArray[0] = iByte1;
//        inputArray[1] = iByte2;
//        inputArray[2] = iByte3;
//        
//        rs232Send(iHESSport,inputArray,elcount(inputArray));
//        testStep("", "Simulated values: %d, %d, %d", iByte1, iByte2, iByte3);
//      }
//      
//      if (iSpeed == 0)
//      {
//        for(iCount=0; iCount<elcount(inputArray); iCount++)
//        {
//          inputArray[iCount] = 0x00;
//        }
//        
//        rs232Send(iHESSport,inputArray,elcount(inputArray));
//      }
//      
//      testStepPass(iLevelOfDetailPass, "Simulation done", "Simulated speed: %dmm/s", iSpeed);
//     }
//    
//    else
//    {
//      testStepFail(iLevelOfDetailFail, "Block parameter value invalid", "Value set: %d. Value must be between [0...7]",iBlock);
//    }
//  }
//  
//  else
//  {
//    testStepFail(iLevelOfDetailFail, "COM Port Failure","Can't open COM port: %d",iHESSport);
//  }
//  
//  TestWaitForTimeout(200);
//  rs232Close(iHESSport);  
//}

/// <Evaluation>
// Evaluates the two char arrays provided as parameters and sets the test result to passed if they are equal.
// "aActionName"     = The Action name which will appear inside the report.
// "aReceivedResult" = The char array for the received result.
// "aExpectedResult" = The char array for the expected result.
// Example:          EvalManStepEqual("Check Software Version", "ER01473H.P30", "ER01473H.P30"); => pass.
void EvalManStepEqual(char aActionName[], char aReceivedResult[], char aExpectedResult[])
{
  stack long EvalManStepTable = 0;
  
  // begin table
  EvalManStepTable = TestInfoTable(aActionName);

  // header
  TestInfoHeadingBegin(EvalManStepTable, 0);
  TestInfoCell(EvalManStepTable, "Received");
  TestInfoCell(EvalManStepTable, "Expected");
  TestInfoHeadingEnd(EvalManStepTable);

  // row 1
  TestInfoRow(EvalManStepTable, 0);
  TestInfoCell(EvalManStepTable, aReceivedResult);
  TestInfoCell(EvalManStepTable, aExpectedResult);

 if(strncmp(aExpectedResult, aReceivedResult, elcount(aExpectedResult)) != 0)
  {
    TestStepFail(iLevelOfDetailFail, "", EvalManStepTable);
  }
  else
  {
    TestStepPass(iLevelOfDetailPass, "", EvalManStepTable);
  }
}

/// <Evaluation>
// Evaluates the two bytes provided as parameters and sets the test result to passed if they are equal.
// "aActionName"     = The Action name which will appear inside the report.
// "aReceivedResult" = The byte for the received result.
// "aExpectedResult" = The byte for the expected result.
// Example:          EvalManStepEqual("Check byte value", 0x0F, 0x0F); => pass.
void EvalManStepEqual(char aActionName[], byte aReceivedResult, byte aExpectedResult)
{
  stack long EvalManStepTable = 0;
  stack char tmp[5];
  
  // begin table
  EvalManStepTable = TestInfoTable(aActionName);

  // header
  TestInfoHeadingBegin(EvalManStepTable, 0);
  TestInfoCell(EvalManStepTable, "Received");
  TestInfoCell(EvalManStepTable, "Expected");
  TestInfoHeadingEnd(EvalManStepTable);

  // row 1
  TestInfoRow(EvalManStepTable, 0);
  
  snprintf(tmp, elcount(tmp), "0x%02X ", aReceivedResult); // Convert to char for table compatibility.
  TestInfoCell(EvalManStepTable, tmp);
  snprintf(tmp, elcount(tmp), "0x%02X ", aExpectedResult);  
  TestInfoCell(EvalManStepTable, tmp);

 if(aExpectedResult != aReceivedResult)
  {
    TestStepFail(iLevelOfDetailFail, "", EvalManStepTable);
  }
  else
  {
    TestStepPass(iLevelOfDetailPass, "", EvalManStepTable);
  }
}

/// <Evaluation>
// Evaluates the two float numbers provided as parameters and sets the test result to passed if they are equal.
// "aActionName"     = The Action name which will appear inside the report.
// "aReceivedResult" = The float for the received result.
// "aExpectedResult" = The float for the expected result.
// Example:          EvalManStepEqual("Check float value", 420, 420); => pass.
void EvalManStepEqual(char aActionName[], float aReceivedResult, float aExpectedResult)
{
  stack long EvalManStepTable = 0;
  stack char tmp[30];
  
  // begin table
  EvalManStepTable = TestInfoTable(aActionName);

  // header
  TestInfoHeadingBegin(EvalManStepTable, 0);
  TestInfoCell(EvalManStepTable, "Received");
  TestInfoCell(EvalManStepTable, "Expected");
  TestInfoHeadingEnd(EvalManStepTable);

  // row 1
  TestInfoRow(EvalManStepTable, 0);
  
  snprintf(tmp, elcount(tmp), "%.2f ", aReceivedResult); // Convert to char for table compatibility.
  TestInfoCell(EvalManStepTable, tmp);
  snprintf(tmp, elcount(tmp), "%.2f ", aExpectedResult);  
  TestInfoCell(EvalManStepTable, tmp);

 if(aExpectedResult != aReceivedResult)
  {
    TestStepFail(iLevelOfDetailFail, "", EvalManStepTable);
  }
  else
  {
    TestStepPass(iLevelOfDetailPass, "", EvalManStepTable);
  }
}

/// <Evaluation>
// Evaluates the two byte arrays provided as parameters and sets the test result to passed if they are equal.
// "aActionName"     = The Action name which will appear inside the report.
// "aReceivedResult" = The byte array for the received result.
// "aExpectedResult" = The byte array for the expected result.
// Example:          arr1 = {0x02, 0x03}; arr2 = {0x02, 0x03}.
//                   EvalManStepEqual("Check byte array values", arr1, arr2); => pass.
void EvalManStepEqual(char aActionName[], byte aReceivedResult[], byte aExpectedResult[])
{
  stack long EvalManStepTable = 0;
  stack char tmp[5000];
  
  // begin table
  EvalManStepTable = TestInfoTable(aActionName);

  // header
  TestInfoHeadingBegin(EvalManStepTable, 0);
  TestInfoCell(EvalManStepTable, "Received");
  TestInfoCell(EvalManStepTable, "Expected");
  TestInfoHeadingEnd(EvalManStepTable);

  // row 1
  TestInfoRow(EvalManStepTable, 0);
  
  ConvertByteArrInCharArr(aReceivedResult, tmp, 0, elcount(aReceivedResult) - 1, "true"); // Convert to char for table compatibility.
  TestInfoCell(EvalManStepTable, tmp);
  ConvertByteArrInCharArr(aExpectedResult, tmp, 0, elcount(aExpectedResult) - 1, "true");
  TestInfoCell(EvalManStepTable, tmp);

 if(memcmp(aExpectedResult, aReceivedResult, elcount(aReceivedResult)) !=0)
  {
    TestStepFail(iLevelOfDetailFail, "", EvalManStepTable);
  }
  else
  {
    TestStepPass(iLevelOfDetailPass, "", EvalManStepTable);
  }
}

/// <Evaluation>
// Evaluates the two char arrays provided as parameters and sets the test result to passed if they are unequal.
// "aActionName"     = The Action name which will appear inside the report.
// "aReceivedResult" = The char array for the received result.
// "aExpectedResult" = The char array for the expected result.
// Example:          EvalManStepEqual("Check Software Version", "ER01473H.P30", "ER01473H.P30"); => fail.
void EvalManStepUnEqual(char aActionName[], char aReceivedResult[], char aExpectedResult[])
{
  stack long EvalManStepTable = 0;
  
  // begin table
  EvalManStepTable = TestInfoTable(aActionName);

  // header
  TestInfoHeadingBegin(EvalManStepTable, 0);
  TestInfoCell(EvalManStepTable, "Received");
  TestInfoCell(EvalManStepTable, "Expected");
  TestInfoHeadingEnd(EvalManStepTable);

  // row 1
  TestInfoRow(EvalManStepTable, 0);
  TestInfoCell(EvalManStepTable, aReceivedResult);
  TestInfoCell(EvalManStepTable, aExpectedResult);

 if(strncmp(aExpectedResult, aReceivedResult, elcount(aExpectedResult)) == 0)
  {
    TestStepFail(iLevelOfDetailFail, "", EvalManStepTable);
  }
  else
  {
    TestStepPass(iLevelOfDetailPass, "", EvalManStepTable);
  }
}


/// <Evaluation>
// Evaluates the two bytes provided as parameters and sets the test result to passed if they are unequal.
// "aActionName"     = The Action name which will appear inside the report.
// "aReceivedResult" = The byte for the received result.
// "aExpectedResult" = The byte for the expected result.
// Example:          EvalManStepUnEqual("Check byte value", 0x0F, 0x0B); => pass.
void EvalManStepUnEqual(char aActionName[], byte aReceivedResult, byte aExpectedResult)
{
  stack long EvalManStepTable = 0;
  stack char tmp[5];
  
  // begin table
  EvalManStepTable = TestInfoTable(aActionName);

  // header
  TestInfoHeadingBegin(EvalManStepTable, 0);
  TestInfoCell(EvalManStepTable, "Received");
  TestInfoCell(EvalManStepTable, "Expected");
  TestInfoHeadingEnd(EvalManStepTable);

  // row 1
  TestInfoRow(EvalManStepTable, 0);
  
  snprintf(tmp, elcount(tmp), "0x%02X ", aReceivedResult); // Convert to char for table compatibility.
  TestInfoCell(EvalManStepTable, tmp);
  snprintf(tmp, elcount(tmp), "0x%02X ", aExpectedResult);  
  TestInfoCell(EvalManStepTable, tmp);

 if(aExpectedResult == aReceivedResult)
  {
    TestStepFail(iLevelOfDetailFail, "", EvalManStepTable);
  }
  else
  {
    TestStepPass(iLevelOfDetailPass, "", EvalManStepTable);
  }
}



/// <Evaluation>
// Evaluates the two float numbers provided as parameters and sets the test result to passed if they are unequal.
// "aActionName"     = The Action name which will appear inside the report.
// "aReceivedResult" = The float for the received result.
// "aExpectedResult" = The float for the expected result.
// Example:          EvalManStepUnEqual("Check float value", 420, 421); => pass.
void EvalManStepUnEqual(char aActionName[], float aReceivedResult, float aExpectedResult)
{
  stack long EvalManStepTable = 0;
  stack char tmp[30];
  
  // begin table
  EvalManStepTable = TestInfoTable(aActionName);

  // header
  TestInfoHeadingBegin(EvalManStepTable, 0);
  TestInfoCell(EvalManStepTable, "Received");
  TestInfoCell(EvalManStepTable, "Expected");
  TestInfoHeadingEnd(EvalManStepTable);

  // row 1
  TestInfoRow(EvalManStepTable, 0);
  
  snprintf(tmp, elcount(tmp), "%.2f ", aReceivedResult); // Convert to char for table compatibility.
  TestInfoCell(EvalManStepTable, tmp);
  snprintf(tmp, elcount(tmp), "%.2f ", aExpectedResult);  
  TestInfoCell(EvalManStepTable, tmp);

 if(aExpectedResult == aReceivedResult)
  {
    TestStepFail(iLevelOfDetailFail, "", EvalManStepTable);
  }
  else
  {
    TestStepPass(iLevelOfDetailPass, "", EvalManStepTable);
  }
}

/// <Evaluation>
// Evaluates the two byte arrays provided as parameters and sets the test result to passed if they are unequal.
// "aActionName"     = The Action name which will appear inside the report.
// "aReceivedResult" = The byte array for the received result.
// "aExpectedResult" = The byte array for the expected result.
// Example:          arr1 = {0x01, 0x02}; arr2 = {0x02, 0x03}.
//                   EvalManStepUnEqual("Check byte array values", arr1, arr2); => pass.
void EvalManStepUnEqual(char aActionName[], byte aReceivedResult[], byte aExpectedResult[])
{
  stack long EvalManStepTable = 0;
  stack char tmp[5000];
  
  // begin table
  EvalManStepTable = TestInfoTable(aActionName);
  
  // header
  TestInfoHeadingBegin(EvalManStepTable, 0);
  TestInfoCell(EvalManStepTable, "Received");
  TestInfoCell(EvalManStepTable, "Expected");
  TestInfoHeadingEnd(EvalManStepTable);
  
  // row 1
  TestInfoRow(EvalManStepTable, 0);
  
  ConvertByteArrInCharArr(aReceivedResult, tmp, 0, elcount(aReceivedResult) - 1, "true"); // Convert to char for table compatibility.
  TestInfoCell(EvalManStepTable, tmp);
  ConvertByteArrInCharArr(aExpectedResult, tmp, 0, elcount(aExpectedResult) - 1, "true");
  TestInfoCell(EvalManStepTable, tmp);

 if(memcmp(aExpectedResult, aReceivedResult, elcount(aReceivedResult)) == 0)
  {
    TestStepFail(iLevelOfDetailFail, "", EvalManStepTable);
  }
  else
  {
    TestStepPass(iLevelOfDetailPass, "", EvalManStepTable);
  }
}

/// <Evaluation>
void EvalManStepEqual(char aActionName[], diagResponse * dResponse, char aExpectedResult[])
{
  stack long EvalManStepTable = 0;
  stack byte bResponse[1000];
  stack char cResponse[5000];
  diagGetPrimitiveData(dResponse, bResponse, DiagGetPrimitiveSize(dResponse));
  
  ConvertByteArrInCharArr(bResponse, cResponse, 0, DiagGetPrimitiveSize(dResponse)-1, "true");
  
  // begin table
  EvalManStepTable = TestInfoTable(aActionName);

  // header
  TestInfoHeadingBegin(EvalManStepTable, 0);
  TestInfoCell(EvalManStepTable, "Received");
  TestInfoCell(EvalManStepTable, "Expected");
  TestInfoHeadingEnd(EvalManStepTable);

  // row 1
  TestInfoRow(EvalManStepTable, 0);
  TestInfoCell(EvalManStepTable, cResponse);
  TestInfoCell(EvalManStepTable, aExpectedResult);

 if(strncmp(aExpectedResult, cResponse, elcount(cResponse)) != 0)
  {
    TestStepFail(iLevelOfDetailFail, "", EvalManStepTable);
  }
  else
  {
    TestStepPass(iLevelOfDetailPass, "", EvalManStepTable);
  }
}

/// <Evaluation>
void EvalManStepEqual(char aActionName[], diagResponse * dResponse, byte bExpectedResult[])
{
  stack long EvalManStepTable = 0;
  stack byte bResponse[1000];
  stack char cResponse[5000];
  stack char cExpectedResult[5000];
  diagGetPrimitiveData(dResponse, bResponse, DiagGetPrimitiveSize(dResponse));
  
  ConvertByteArrInCharArr(bResponse      , cResponse      , 0, DiagGetPrimitiveSize(dResponse) - 1, "true");
  ConvertByteArrInCharArr(bExpectedResult, cExpectedResult, 0, elcount(bExpectedResult) - 1       , "true");

  // begin table
  EvalManStepTable = TestInfoTable(aActionName);

  // header
  TestInfoHeadingBegin(EvalManStepTable, 0);
  TestInfoCell(EvalManStepTable, "Received");
  TestInfoCell(EvalManStepTable, "Expected");
  TestInfoHeadingEnd(EvalManStepTable);

  // row 1
  TestInfoRow(EvalManStepTable, 0);
  TestInfoCell(EvalManStepTable, cResponse);
  TestInfoCell(EvalManStepTable, cExpectedResult);

 if(strncmp(cExpectedResult, cResponse, elcount(cResponse)) != 0)
  {
    TestStepFail(iLevelOfDetailFail, "", EvalManStepTable);
  }
  else
  {
    TestStepPass(iLevelOfDetailPass, "", EvalManStepTable);
  }
}

/// <Evaluation>
void EvalManStepEqual(char aActionName[], diagResponse * dResponse_1, diagResponse * dResponse_2)
{
  stack long EvalManStepTable = 0;
  stack byte bResponse_1[1000];
  stack byte bResponse_2[1000];
  stack char cResponse_1[5000];
  stack char cResponse_2[5000];
  
  diagGetPrimitiveData(dResponse_1, bResponse_1, DiagGetPrimitiveSize(dResponse_1));
  diagGetPrimitiveData(dResponse_2, bResponse_2, DiagGetPrimitiveSize(dResponse_2));
  
  ConvertByteArrInCharArr(bResponse_1, cResponse_1, 0, DiagGetPrimitiveSize(dResponse_1)-1, "true");
  
  ConvertByteArrInCharArr(bResponse_2, cResponse_2, 0, DiagGetPrimitiveSize(dResponse_2)-1, "true");
  
  // begin table
  EvalManStepTable = TestInfoTable(aActionName);

  // header
  TestInfoHeadingBegin(EvalManStepTable, 0);
  TestInfoCell(EvalManStepTable, "Received");
  TestInfoCell(EvalManStepTable, "Expected");
  TestInfoHeadingEnd(EvalManStepTable);

  // row 1
  TestInfoRow(EvalManStepTable, 0);
  TestInfoCell(EvalManStepTable, cResponse_1);
  TestInfoCell(EvalManStepTable, cResponse_2);

 if(strncmp(cResponse_1, cResponse_2, elcount(cResponse_2)) != 0)
  {
    TestStepFail(iLevelOfDetailFail, "", EvalManStepTable);
  }
  else
  {
    TestStepPass(iLevelOfDetailPass, "", EvalManStepTable);
  }
}

/// <Evaluation>
void EvalManStepUnEqual(char aActionName[], diagResponse * dResponse, char aExpectedResult[])
{
  stack long EvalManStepTable = 0;
  stack byte bResponse[1000];
  stack char cResponse[5000];
  diagGetPrimitiveData(dResponse, bResponse, DiagGetPrimitiveSize(dResponse));
  
  ConvertByteArrInCharArr(bResponse, cResponse, 0, DiagGetPrimitiveSize(dResponse)-1, "true");
  
  // begin table
  EvalManStepTable = TestInfoTable(aActionName);

  // header
  TestInfoHeadingBegin(EvalManStepTable, 0);
  TestInfoCell(EvalManStepTable, "Received");
  TestInfoCell(EvalManStepTable, "Expected");
  TestInfoHeadingEnd(EvalManStepTable);

  // row 1
  TestInfoRow(EvalManStepTable, 0);
  TestInfoCell(EvalManStepTable, cResponse);
  TestInfoCell(EvalManStepTable, aExpectedResult);

 if(strncmp(aExpectedResult, cResponse, elcount(cResponse)) != 0)
  {
    TestStepPass(iLevelOfDetailPass, "", EvalManStepTable);
  }
  else
  {
    TestStepFail(iLevelOfDetailFail, "", EvalManStepTable);
  }
}

/// <Evaluation>
// Evaluates the one int64 provided as parameters and sets the test result to passed if they are certain range.
// "aActionName"     = The Action name which will appear inside the report.
// "aReceivedResult" = The char array for the received result.
// "aExpectedResultMin" = The int64 for the expected result, minumum value.
// "aExpectedResultMax" = The int64 for the expected result, maximum value.
// Example:          EvalManStepRange("Qualification time", "20", "10","30"); => pass.
// Example:          EvalManStepRange("Qualification time", "20", "400","30"); => fail.
void EvalManStepRange(char aActionName[],  int64 iReceivedResult, int64 iExpectedResultMin, int64 iExpectedResultMax)
{
  stack long EvalManStepTable = 0;
  stack char aReceivedResult[20];
  stack char aExpectedResultMin[20];
  stack char aExpectedResultMax[20];
  
  // begin table
  EvalManStepTable = TestInfoTable(aActionName);

  // header
  TestInfoHeadingBegin(EvalManStepTable, 0);
  TestInfoCell(EvalManStepTable, "Received");
  TestInfoCell(EvalManStepTable, "MinExpected");
  TestInfoCell(EvalManStepTable, "MaxExpected");
  TestInfoHeadingEnd(EvalManStepTable);

  // row 1 
  ltoa(iReceivedResult,aReceivedResult,10);
  ltoa(iExpectedResultMin,aExpectedResultMin,10);
  ltoa(iExpectedResultMax,aExpectedResultMax,10);
  
  TestInfoRow(EvalManStepTable, 0);
  TestInfoCell(EvalManStepTable, aReceivedResult);
  TestInfoCell(EvalManStepTable, aExpectedResultMin);
  TestInfoCell(EvalManStepTable, aExpectedResultMax);

 if((iReceivedResult<=iExpectedResultMin)||(iReceivedResult>=iExpectedResultMax))
  {
    TestStepFail(iLevelOfDetailFail, "", EvalManStepTable);
  }
  else
  {
    TestStepPass(iLevelOfDetailPass, "", EvalManStepTable);
  }
}

/// <Logging>
// Generates the full log path including name for .asc log.
void SetLoggingFile(char cFullLogPath[], char cLogName[])
{
  stack char cTimeBuffer[64];
  
  strncpy(cFullLogPath, "", 1);
  
  getLocalTimeString(cTimeBuffer);
  str_replace(cTimeBuffer, " ", "_");
  str_replace(cTimeBuffer, ":", "_");
  str_replace(cTimeBuffer, "__", "_");

  strncat(cLogName, "_", elcount(cLogName));
  strncat(cLogName, cTimeBuffer, elcount(cLogName));
  strncat(cLogName, ".asc", elcount(cLogName));
  
  strncat(cFullLogPath, cLogPathAndName, elcount(cFullLogPath));
  strncat(cFullLogPath, cLogName, elcount(cFullLogPath));
}

/// <Logging>
// Starts an .ASC log with the {TestCaseTitle}_{LocalTimeString}.asc
// Log location is taken from "cLogPathAndName" variable in "Testbench_configuration.cin".
// The log name is written after the requirements table with a hyperlink to the log file.
// Example output log name: "TR6_EXT_TF_B_SW_RGS_xy_keineStraffungUeberspg_Cyclic_Thu_Nov_18_13_32_49_2021.asc"
void StartLoggingASC()
{  
  stack char cTestCaseTitle[1000];
  
  testGetCurrentTestCaseTitle(cTestCaseTitle, elcount(cTestCaseTitle));
 
  if (iOriginalTestCaseTitleLength == 0)
  {
    strncpy(cLogName, cTestCaseTitle, elcount(cLogName));  // Logging is started before PreTs(). No title length change.
  }
  else
  {
    strncpy(cLogName, cTestCaseTitle, iOriginalTestCaseTitleLength + 1); // Logging is started after PreTs(). Only copy original title.    
  }
   
  SetLoggingFile(cFullLogPath, cLogName);
  setLogFileName("TestLoggingBlock", cFullLogPath);
  startLogging("TestLoggingBlock");
  
  TestReportAddExtendedInfo("html", "<A HREF=\'%s'>Log file: %s </A>", cFullLogPath, cLogName);
}

/// <Logging>
// Starts an .ASC log with the {cInputLogName}_{LocalTimeString}.asc
// Log location is taken from "cLogPathAndName" variable in "Testbench_configuration.cin".
// The log name is written after the requirements table with a hyperlink to the log file.
// Example output log name: "{cInputLogName}_Thu_Nov_18_13_32_49_2021.asc"
void StartLoggingASC(char cInputLogName[])
{ 
  strncpy(cLogName, cInputLogName, (elcount(cInputLogName)));

  SetLoggingFile(cFullLogPath, cLogName);
  setLogFileName("TestLoggingBlock", cFullLogPath);
  startLogging("TestLoggingBlock");
  
  TestReportAddExtendedInfo("html", "<A HREF=\'%s'>Log file: %s </A>", cFullLogPath, cLogName);
}

/// <Logging>
void StopLoggingASC()
{
  stopLogging("TestLoggingBlock");
}


/// <Logging>
// Function used in PreTS for logging of the whole test case.
// Log types: .ASC and .BLF
// Log location is taken from "cLogPathAndName" variable in "Testbench_configuration.cin".
// The log name is written after the requirements table with a hyperlink to the log file.
// Two testing blocks are needed: 'TestCaseLogASC' & 'TestCaseLogBLF' for the function to work properly.
// If the testing blocks are disabled/not defined, a warning will appear in the write window
// and the test log links from the report will be invalid.
// Example output logs name: "{TestCaseTitle}_Thu_Nov_18_13_32_49_2021.asc"
//                           "{TestCaseTitle}_Thu_Nov_18_13_32_49_2021.blf"
void PreTS_StartLogging()
{
  stack char cTimeBuffer_PreTS[64];
  stack char cLogName_ASC[500];
  stack char cLogName_BLF[500];
  stack char cFullLogPath_PreTS_ASC[1000];
  stack char cFullLogPath_PreTS_BLF[1000];
  stack char cTestCaseTitle_PreTS[500];

  testGetCurrentTestCaseTitle(cTestCaseTitle_PreTS, elcount(cTestCaseTitle_PreTS));

  getLocalTimeString(cTimeBuffer_PreTS);
  str_replace(cTimeBuffer_PreTS, " ", "_");
  str_replace(cTimeBuffer_PreTS, ":", "_");
  str_replace(cTimeBuffer_PreTS, "__", "_");
  
  if (iOriginalTestCaseTitleLength == 0)
  {
    strncpy(cLogName_ASC, cTestCaseTitle_PreTS, elcount(cLogName_ASC));  // Logging is started before title is changed.
  }
  else
  {
    strncpy(cLogName_ASC, cTestCaseTitle_PreTS, iOriginalTestCaseTitleLength + 1); // Logging is started after title is changed.    
  } 
  
  strncat(cLogName_ASC, "_", elcount(cLogName_ASC));
  strncat(cLogName_ASC, cTimeBuffer_PreTS, elcount(cLogName_ASC));
  
  strncpy(cLogName_BLF, cLogName_ASC, elcount(cLogName_BLF));
  
  strncat(cLogName_ASC, ".asc", elcount(cLogName_ASC));
  strncat(cLogName_BLF, ".blf", elcount(cLogName_BLF));
  
  strncat(cFullLogPath_PreTS_ASC, cLogPathAndName, elcount(cFullLogPath_PreTS_ASC));
  strncat(cFullLogPath_PreTS_ASC, cLogName_ASC, elcount(cFullLogPath_PreTS_ASC));
  
  strncat(cFullLogPath_PreTS_BLF, cLogPathAndName, elcount(cFullLogPath_PreTS_BLF));
  strncat(cFullLogPath_PreTS_BLF, cLogName_BLF, elcount(cFullLogPath_PreTS_BLF));
  
  setLogFileName("TestCaseLogASC", cFullLogPath_PreTS_ASC);
  startLogging("TestCaseLogASC");
  
  setLogFileName("TestCaseLogBLF", cFullLogPath_PreTS_BLF);
  startLogging("TestCaseLogBLF");
  
  TestReportAddExtendedInfo("html", "<A HREF=\'%s'>Log file: %s </A>", cFullLogPath_PreTS_ASC, cLogName_ASC);
  TestReportAddExtendedInfo("html", "<A HREF=\'%s'>Log file: %s </A>", cFullLogPath_PreTS_BLF, cLogName_BLF);
}

/// <Logging>
// Function used to stop logging started in PreTS.
void PostTS_StopLogging()
{
  stopLogging("TestCaseLogASC");
  stopLogging("TestCaseLogBLF");
}

/// <Not_Used_Outside_Project_Functions>
// Function used for DetectCycleStep().This is not intended to be called outside of the DetectCycleStep() function.
// Converts an array of chars, separated by "," character, to an array of array of chars .
// Example: ConvertCharArrayInput("BSR,BPDO");
// Result:  OutputArray[0] = "BSR", OutputArray[1] = "BPDO".
ConvertCharArrayInput(char cInputArray[], char cUsedFunctionName[], char OutputArray[][])
{
  int i;
  int index;
  
  strncpy(OutputArray[0], "*", elcount("*"));
  strncpy(OutputArray[1], "*", elcount("*"));
  strncpy(OutputArray[2], "*", elcount("*"));
  
  if(str_match_regex(cInputArray, "[a-zA-Z0-8_,*]*") == 1)
  {
    for(i = 0; i <= 2; i++)
    {   
      index = strstr(cInputArray, ",");
      if (index != -1)
      {
        substr_cpy(OutputArray[i], cInputArray, 0, index, elcount(OutputArray[i]));
        substr_cpy(cInputArray, cInputArray, index + 1, -1, elcount(cInputArray));
      }
      else  
      {
        substr_cpy(OutputArray[i], cInputArray, 0, index, elcount(OutputArray[i]));
        return;
      }
    }
    
    if(strstr(OutputArray[2], ",") != -1)
    {
     testStepFail(iLevelOfDetailFail, "-", "Incorrect Array input for %s function: %s", cUsedFunctionName, cInputArray);
    }
  }
  else
  {
     testStepFail(iLevelOfDetailFail, "-", "Incorrect Array input for %s function. Only characters [a-zA-Z0-8_,] allowed: %s", cUsedFunctionName, cInputArray);
  }

}

/// <Not_Used_Outside_Project_Functions>
// Function used for CycleConfiguration().This is not intended to be called outside of the CycleConfiguration() function.
//byte ExtractOrderValueAndOptions(char cInputString[], byte bOrderValueAndOptions[])
//{
//  int i;
//  int iStepNoIndex;
//  int iIndexOfOrderValue;
//  int iIndexOfOrderType;
//  int iIndexOfOption;
//  int iOrderValueSignDetected;
//  int iOrderValue;
//  int iOrderType;
//  int iConstraintType;
//  char cNewInputString[60]; // Copy of input string.
//  char cOrderRegexString[3][2] = {"V", "%", "A"}; // Order type.
//  char cMinusSign[2] = "-";
//  char cOptionsRegexString[5][3] = {"T", "B1", "R","O", "A"}; // Options.
//  char cConstraintTypeRegexString[6][3] = {"H", "P1", "P2", "M", "W", "B2"}; // Constraint types.
//  char cOrderValueString[5];
//  char cOptionsString[50];
//
//  //----------------------
//  iOrderValue = 255;
//  iOrderType = -1;
//  iConstraintType = 0;
//  strncpy(cOrderValueString, "", 1);
//  strncpy(cOptionsString, "", 1);
//  strncpy(cNewInputString, "", 1);
//  //----------------------
//  
//  iStepNoIndex = strstr(cInputString, "STEP") + 5;
//  substr_cpy(cNewInputString, cInputString, iStepNoIndex, -1, elcount(cNewInputString));
//  
//  if(strstr(cNewInputString, "MS") == -1) // If no time input is found.
//  {
//     iIndexOfOrderValue = strstr(cNewInputString, ":") + 1;
//  }
//  else iIndexOfOrderValue = strstr(cNewInputString, "MS") + 2;
//  
//  for(i = 0; i < 3; i++) // Loop through step order types.
//  {
//    iIndexOfOrderType = strstr(cNewInputString, cOrderRegexString[i]);
//
//    if(iIndexOfOrderType != -1)
//    {
//      if ((iIndexOfOrderValue != -1) && (iIndexOfOrderValue < iIndexOfOrderType))
//      {
//        if(iIndexOfOrderType - iIndexOfOrderValue - 1 < 5)
//        {
//          substr_cpy(cOrderValueString, cNewInputString, iIndexOfOrderValue + 1, iIndexOfOrderType - iIndexOfOrderValue - 1, elcount(cOrderValueString)); // Gets the string with the order value.
//          
//          iOrderValueSignDetected = strstr(cOrderValueString, cMinusSign); // Look for "-" sign.
//
//          if(iOrderValueSignDetected != -1) // If order value sign is detected.
//          {
//            iOrderValue = -1;
//            substr_cpy(cOrderValueString, cOrderValueString, 1, -1, elcount(cOrderValueString)); // Remove "-" sign from order value string.
//          }
//          else iOrderValue = 1;
//          
//          if(strstr_regex(cOrderValueString, "[0-9]*") == -1) // If Order Value has no digits.
//          {
//            testStepFail(iLevelOfDetailFail, "", "Incorrect Order Value, please input a number! (CycleConfiguration function)");
//            return 0;
//          }
//          else 
//          {
//            substr_cpy(cOrderValueString, cOrderValueString, strstr_regex(cOrderValueString, "[0-9]{1}") , -1, elcount(cOrderValueString));
//          }
//
//          if(str_match_regex(cOrderValueString, "[0-9]*") == 0) // If Order value is not entirely comprised of digits.
//          {
//            testStepFail(iLevelOfDetailFail, "", "Incorrect Order Value, please input an Order Value of integer type! (CycleConfiguration function)");
//            return 0;
//          }
//          else
//          {
//            iOrderValue = iOrderValue * _atoi64(cOrderValueString);
//          }
//        }
//        else
//        {
//          testStepFail(iLevelOfDetailFail, "", "Order value is too large! (CycleConfiguration function)");
//          return 0;
//        } 
//      }
//      else
//      {
//        testStepFail(iLevelOfDetailFail, "", "Please make sure input commands are not empty! (CycleConfiguration function)");
//        return 0;
//      }
//      
//      switch(i)
//      {
//        case 0: iOrderType = 4; // Voltage.
//                iOrderValue *= 4;
//          break;
//        case 1: iOrderType = 0; // PWM.
//          break;
//        case 2: iOrderType = 1; // Current.
//                iOrderValue *= 2;
//          break;
//      }
//      break;
//    }
//  }
//  
//  if(iIndexOfOrderType != -1)
//  {
//    substr_cpy(cOptionsString, cNewInputString, iIndexOfOrderType + 1, -1, elcount(cOptionsString)); // Gets the string with the order options starting from order type.
//  }
//  else if (strstr(cNewInputString, "MS") != -1)
//        {
//          substr_cpy(cOptionsString, cNewInputString, strstr(cNewInputString, "MS") + 2, -1, elcount(cOptionsString)); // Gets the string with the order options starting from "MS".
//        }       
//        
//  for(i = 0; i < 5; i++) // Loops through step options.
//  {
//    iIndexOfOption = strstr(cOptionsString, cOptionsRegexString[i]);
//    
//    if(iIndexOfOption == -1) // If Option is not found.
//    {
//        // Default value remains.
//    }
//    else
//    { 
//      if(iOrderType == -1) // If order type input is NOT found.
//      {
//       iOrderType = 0x07 & bOrderValueAndOptions[1]; // Keep only default order type.
//      }
//      iOrderType += _pow(2, i + 3);
//    }
//  }
//  
//  for(i = 0; i < 6; i++) // Loops through Constraint types.
//  {
//    iIndexOfOption = strstr(cOptionsString, cConstraintTypeRegexString[i]);
//    
//    if(iIndexOfOption == -1) // If Option is not found.
//    {
//        // Default value remains.
//    }
//    else
//    {
//      iConstraintType += _pow(2, i);
//    }
//  }
//  
//  // Set Order Value.
//  if(iOrderValue != 255) // If order value input is not empty.
//  {
//    bOrderValueAndOptions[0] = (byte)iOrderValue;
//  }
//  else  if(strstr(cInputString, "NEW") != -1) // If New.
//        {
//          bOrderValueAndOptions[0] = 0;
//        }
//        
//  // Set Order Type.
//  if(iOrderType != -1) // If there is an order type input.
//  {
//    if(strstr(cInputString, "DEFAULT") != -1) // If Default.
//    {
//       bOrderValueAndOptions[1] = bOrderValueAndOptions[1] & 0xF8; // Remove order type.
//       bOrderValueAndOptions[1] = bOrderValueAndOptions[1] | (byte)iOrderType; // Keep rest of default options.
//    }
//    else bOrderValueAndOptions[1] = (byte)iOrderType;
//  }
//  else if(strstr(cInputString, "NEW") != -1)
//        {
//          bOrderValueAndOptions[1] = 0;
//        }
//  
//  // Set Constraint Value.
//  if(strstr(cInputString, "NEW") != -1)
//  {
//    bOrderValueAndOptions[2] = 0;
//  }
//       
//  // Set Constraint Type.
//  if(iConstraintType != 0) // If input constraint type is found.
//  {
//    if(strstr(cInputString, "DEFAULT") != -1) // If Default.
//    {
//       bOrderValueAndOptions[3] = bOrderValueAndOptions[3] | (byte)iConstraintType; // Keep rest of constraint types.
//    }
//    else bOrderValueAndOptions[3] = (byte)iConstraintType;
//  }
//  else if(strstr(cInputString, "NEW") != -1)
//        {
//          bOrderValueAndOptions[3] = 0;
//        }
//  
//  return 1;
//}

/// <Not_Used_Outside_Project_Functions>
// Function used for CycleConfiguration().This is not intended to be called outside of the CycleConfiguration() function.
//void ExtractTime(char cInputString[], byte bTime[])
//{
//  int iIndexOfMS;
//  int iStepNoIndex;
//  int iStepDetected;
//  char charStepDetected[2];
//  char cTimeString[20];
//  int64 iTime;
//
//  //----------------------
//  bTime[0] = bTime[1] = bTime[2] = bTime[3] = 0x00;
//  iTime = 0;
//  strncpy(cTimeString, "", 1);
//  iStepNoIndex = strstr(cInputString, "STEP") + 4;
//  substr_cpy(charStepDetected, cInputString, iStepNoIndex, 1, elcount(charStepDetected));
//  iIndexOfMS = strstr(cInputString, "MS");
//  //----------------------
//  
//  if(strncmp(charStepDetected, "N", 1) == 0) // Default Step.
//  {
//     bTime[3] = 0x0F;
//  }
//  else
//  {
//    iStepDetected = _atoi64(charStepDetected);
//    bTime[3] = iStepDetected;
//  }
//  
//  if(iIndexOfMS == -1)
//  {
//   if(strstr(cInputString, "NEW") != -1) // If Step is New.
//    {
//        bTime[0] = 0x00;
//        bTime[1] = 0x00;
//        bTime[2] = 0x01; // Valid Values.
//    }
//    else
//    {
//      bTime[2] = 0x02; // Default values.
//    }
//  }
//  else
//  {
//    substr_cpy(cTimeString, cInputString, iStepNoIndex + 2 , iIndexOfMS - iStepNoIndex - 2, elcount(cTimeString));
//    if(str_match_regex(cTimeString, "[0-9]*") == 1)
//    {
//      iTime = _atoi64(cTimeString);
//      if ((iTime <= 65535) && (iTime % 10 == 0))
//      {
//        iTime = iTime / 10;
//        bTime[0] = iTime / 256;
//        bTime[1] = iTime % 256;
//        bTime[2] = 1; // Valid Values.
//      }
//      else
//      {
//       testStepFail(iLevelOfDetailFail, "", "Step time can be max 65535ms and resolution is 10! (CycleConfiguration function)"); 
//      }
//    }
//    else
//    {
//      testStepFail(iLevelOfDetailFail, "", "MS are detected - please define the time value! (CycleConfiguration function)"); 
//    }
//  }
//}

/// <Not_Used_Outside_Project_Functions>
// Function used for CycleConfiguration().This is not intended to be called outside of the CycleConfiguration() function.
//int CheckStepParameterValidity(int iMNOStep, char cStepParameter[])
//{
//  int iStepValidation;
//  int iIsStepFound;
//  int iSizeOfStepParameter;
//  int iStartPosition;
//  char cCharTerminator[1] = "";
//  char cValidSteps[10] = "N01234567";
//  char cNChar[2] = "N";
//  char cStepsCharArray[8];
//  char cCopyOfStepParameter[300];
//  char ctmpStepsParameter[6];
//  char ctmpStep[2];
//  char cNEWChar[4] = "NEW";
//  char cDEFAULTChar[8] = "DEFAULT";
//  int index;
//  int iNoOfSteps = 0;
//  
//  //----------------------
//  iNoOfSteps = 0;
//  iIsStepFound = -1;
//  iStepValidation = 0;
//  strncpy(cStepsCharArray, "", 1);
//  strncpy(ctmpStepsParameter, "", 1);
//  strncpy(ctmpStep, "", 1);
//  iSizeOfStepParameter =  elcount(cStepParameter);
//  iStartPosition = -1;
//  //----------------------
//  
//  if(elcount(cStepParameter) > 0)
//  {
//    toUpper(cStepParameter, cStepParameter, elcount(cStepParameter));
//    str_replace(cStepParameter, " ", "");
//    strncpy(cCopyOfStepParameter, cStepParameter, elcount(cStepParameter));
//    str_replace(cStepParameter, "NEW", "");
//    str_replace(cStepParameter, "DEFAULT", "");
//    str_replace(cStepParameter, ";", "");
//    str_replace(cStepParameter, ",", "");
//    
//    iIsStepFound = strstr(cStepParameter, "STEP");
//    
//    if(iIsStepFound != -1)
//    {
//      while(iIsStepFound != -1)
//      {
//        if(strncmp(cCharTerminator, cStepParameter, iIsStepFound + 4, 1) != 0) // Check for step number presence.
//        {
//            substr_cpy(ctmpStepsParameter, cStepParameter, iIsStepFound, 5, 6);
//            if(strstr_regex(ctmpStepsParameter, "(STEP)[N0-7]{1}") != -1)
//            {
//              substr_cpy_off(cStepsCharArray, iNoOfSteps, cStepParameter, iIsStepFound + 4, 1, elcount(cStepsCharArray)); // Copy steps numbers in char array.
//              iNoOfSteps++;
//              iStepValidation = 1;
//            }
//            else
//            {
//             testStepFail(iLevelOfDetailFail, "", "Step number not correct! (CycleConfiguration function)");
//             iStepValidation = 0;
//             break;
//            }
//        }
//        else 
//        {
//          testStepFail(iLevelOfDetailFail, "", "Please add Step number! (CycleConfiguration function)"); 
//          iStepValidation = 0;
//          break;
//        } 
//        substr_cpy(cStepParameter, cStepParameter, iIsStepFound + 4, -1, elcount(cStepParameter)); 
//        
//        iIsStepFound = strstr(cStepParameter, "STEP");
//      }
//    }
//    else
//    {
//    testStepFail(iLevelOfDetailFail, "", "No step is defined - please use NewStepX or DefaultStepX where X is from 0 to 7 or N! (CycleConfiguration function)");
//    iStepValidation = 0;
//    }
//  }
//  else
//  {
//    testStepFail(iLevelOfDetailFail, "", "Please specify if you want to write a new step or just to update the default one with a new value! (CycleConfiguration function)");
//    iStepValidation = 0;
//  }
//
//  if(iStepValidation == 1)
//  {
//    if(iNoOfSteps > iMNOStep)
//    {
//      testStepFail(iLevelOfDetailFail, "", "Too many steps are defined! (CycleConfiguration function)");
//      iStepValidation = 0;
//    }
//    else if ((iNoOfSteps < iMNOStep) && (strstr_regex(cStepsCharArray, "[N]{1}") == -1))
//          {
//            testStepFail(iLevelOfDetailFail, "", "If not all steps are defined please add StepN - new or default! (CycleConfiguration function)");
//            iStepValidation = 0;
//          }
//          else
//          {
//            for(index = 0; index < iNoOfSteps; index++)
//              {
//                substr_cpy(ctmpStep, cStepsCharArray, index , 1, elcount(ctmpStep));
//                if(strncmp(ctmpStep, cNChar, 1) !=0) // Check that step is not "N".
//                {
//                  if(_atoi64(ctmpStep) >= iMNOStep)
//                  {
//                    testStepFail(iLevelOfDetailFail, "", "Step number not correct - step is higher than max no of step defined for this cycle! (CycleConfiguration function)");
//                    iStepValidation = 0;
//                    break;
//                  }
//                }
//              }
//          }
//    
//    strncpy(cStepParameter, cCopyOfStepParameter, iSizeOfStepParameter);
//
//    if(iStepValidation == 1)
//    {
//      while (iStartPosition < iSizeOfStepParameter)
//      { 
//        iStartPosition = strstr(cStepParameter, "STEP");
//        if(iStartPosition != -1)
//        {
//          if((iStartPosition - 3) < 0) // Step is neither "NEW" or "DEFAULT".
//          {
//            testStepFail(iLevelOfDetailFail, "", "Please define if it's a new or a default step (CycleConfiguration function)");
//            iStepValidation = 0;
//            iStartPosition = iSizeOfStepParameter;
//          }
//          else if(strncmp(cNEWChar, cStepParameter, iStartPosition - 3, 3) == 0) // Step is "NEW".
//                {
//                  substr_cpy(cStepParameter, cStepParameter, iStartPosition + 5, -1, elcount(cStepParameter)); 
//                  iStartPosition = -1;
//                }
//                else if((iStartPosition - 7) < 0) // Step is not "DEFAULT".
//                      {
//                        testStepFail(iLevelOfDetailFail, "", "Please define if it's a new or a default step (CycleConfiguration function)");
//                        iStepValidation = 0;
//                        iStartPosition = iSizeOfStepParameter;
//                      }
//                      else if(strncmp(cDEFAULTChar, cStepParameter, iStartPosition - 7, 7) == 0) // Step is "DEFAULT".
//                            {
//                              substr_cpy(cStepParameter, cStepParameter, iStartPosition + 5, -1, elcount(cStepParameter)); 
//                              iStartPosition = -1;
//                            }
//                            else // Step is neither "NEW" or "DEFAULT".
//                            {
//                              testStepFail(iLevelOfDetailFail, "", "Please define if it's a new or a default step (CycleConfiguration function)");
//                              iStepValidation = 0;
//                              iStartPosition = iSizeOfStepParameter;
//                            }
//        }
//        else
//        {
//          iStartPosition = iSizeOfStepParameter;
//        }
//      }     
//    } 
//  }
//
//  return iStepValidation;
//}

/// <Not_Used_Outside_Project_Functions>
// Function used for WriteStepParameters. This is not intended to be called outside of the WriteStepParameters function.
//byte ModifySteps(char cCycle[], byte bSteps[], char cOption[])
//{
//  int index;
//  byte bCycle;
//  byte bSteps_0_59[480];
//  byte bSteps_60_120[480];
//  byte bAllSteps[960];
//  byte ReadCycleRequest_PositiveR[13];
//  byte bDID_LB[8] = {0x23, 0x24, 0x00, 0x00, 0x00, 0x00, 0x00 , 0x0C}; // RMBA request.
//  byte WriteStepTableResp[3];
//  byte WriteStepTable2APosResp[3] = {0x6E, 0xFD, 0x2A};
//  byte WriteStepTable2BPosResp[3] = {0x6E, 0xFD, 0x2B};
////  char cStepTableA[1024]; // Used for display of steps in test report.
////  char cStepTableA_1[1024];
////  char cStepTableA_2[361];
////  char cStepTableB[1024];
////  char cStepTableB_1[1024];
////  char cStepTableB_2[361];
//  char cCycle_UpperCase[30];
//    
//  if(strncmp(cOption, "Initialize Steps", elcount(cOption)) == 0) // If cOption is "Initialize Steps".
//  {
//      memcpy(bAllSteps, bDefaultStepsForAllCycles, elcount(bAllSteps));
//      return 1;
//  }
//  else if(strncmp(cOption, "Write", 5) == 0) // If cOption starts with "Write".
//  {
//    memcpy(bSteps_0_59, bAllSteps, elcount(bSteps_0_59));
//    memcpy_off(bSteps_60_120, 0, bAllSteps, elcount(bSteps_60_120), elcount(bSteps_60_120));
//    
////    ConvertByteArrInCharArr(bSteps_0_59, cStepTableA, 0, 203, "true"); // Used for display of steps in test report.
////    ConvertByteArrInCharArr(bSteps_0_59, cStepTableA_1, 204, 407, "true");
////    ConvertByteArrInCharArr(bSteps_0_59, cStepTableA_2, 408, 479, "true");
////
////    ConvertByteArrInCharArr(bSteps_60_120, cStepTableB, 0,  203, "true");
////    ConvertByteArrInCharArr(bSteps_60_120, cStepTableB_1, 204, 407, "true");
////    ConvertByteArrInCharArr(bSteps_60_120, cStepTableB_2, 408, 479, "true");
////
////    testStep(0,"","Step table 1:%s %s %s \n Step table 2:%s %s %s ", cStepTableA, cStepTableA_1, cStepTableA_2, cStepTableB, cStepTableB_1, cStepTableB_2);
//        
//    if(diagSetParameterCoded(dWriteStepsDefinition2ARequest, "StepTableA", bSteps_0_59, elcount(bSteps_0_59)) != 0)
//    {
//      testStepFail(iLevelOfDetailFail, "", "Write Step table 2A: Diag request could not be formed (WriteStepParameters function).");
//    }
//    else if(diagSetParameterCoded(dWriteStepsDefinition2BRequest, "StepTableB", bSteps_60_120, elcount(bSteps_60_120)) != 0)
//    {
//      testStepFail(iLevelOfDetailFail, "", "Write Step table 2B: Diag request could not be formed (WriteStepParameters function).");
//    }
//    else
//    {
//      SetECUMode("unlock");
//      
//      testWaitForTimeout(1000);
//      
//      SendDiagnosticRequest(dWriteStepsDefinition2ARequest, dWriteStepsDefinition2AResponse);
//      dWriteStepsDefinition2AResponse.GetPrimitiveData(WriteStepTableResp, elcount(WriteStepTableResp));
//      EvalManStepEqual("Write Steps 0 to 59:", WriteStepTableResp, WriteStepTable2APosResp);
//      
//      testWaitForTimeout(1000);
//      
//      SendDiagnosticRequest(dWriteStepsDefinition2BRequest, dWriteStepsDefinition2BResponse);
//      dWriteStepsDefinition2BResponse.GetPrimitiveData(WriteStepTableResp, elcount(WriteStepTableResp));
//      EvalManStepEqual("Write Steps 60 to 120:", WriteStepTableResp, WriteStepTable2BPosResp);
//      
//      testWaitForTimeout(1000);
//      
//      SetECUMode("lock");
//      
//      testWaitForTimeout(1000);
//      
//      ResetECU("soft");
//      
//      testWaitForTimeout(_iCriticalAutotestExecutionTime + 8000);
//    }
//  }
//  else if(strncmp(cOption, "Configure", elcount(cOption)) == 0) // If cOption is "Configure". 
//  {
//    bCycle = 0xAA;
//  
//    toUpper(cCycle_UpperCase, cCycle, elcount(cCycle_UpperCase));
//    
//    for(index = 0; index < elcount(bAllCycleMeasurement); index++) // Get cycle ID for "cCycle" input.
//    {
//      if(strncmp(cAllCycles[index], cCycle_UpperCase, elcount(cCycle_UpperCase)) == 0)
//      {
//        bCycle = bAllCycleMeasurement[index];      
//      }
//    }
//    
//    if(elcount(bSteps) % 6 != 0)
//    {
//     testStepFail(iLevelOfDetailStep, "", "Wrong step profile definition! (WriteStepParameters function).");
//     return 0; 
//    }
//    else
//    {
//      switch(bCycle)
//      {
//        case(0x00): // PRECRASH_0
//        {
//          memcpy_off(bDID_LB, 2, NVP_BLOCK_ID_CYCLE_0, 0, 4);
//          break;
//        }
//        case(0x01): // PRECRASH_1
//        {
//          memcpy_off(bDID_LB, 2, NVP_BLOCK_ID_CYCLE_1, 0, 4);
//          break;
//        }
//        case(0x02): // PRECRASH_2
//        {
//          memcpy_off(bDID_LB, 2, NVP_BLOCK_ID_CYCLE_2, 0, 4);
//          break;
//        }
//        case(0x03): // PRECRASH_3
//        {
//          memcpy_off(bDID_LB, 2, NVP_BLOCK_ID_CYCLE_3, 0, 4);
//          break;
//        }
//        case(0x04): // PRECRASH_4
//        {
//          memcpy_off(bDID_LB, 2, NVP_BLOCK_ID_CYCLE_4, 0, 4);
//          break;
//        }
//        case(0x05): // PRECRASH_5
//        {
//          memcpy_off(bDID_LB, 2, NVP_BLOCK_ID_CYCLE_5, 0, 4);
//          break;
//        }
//        case(0x06): // PRECRASH_6
//        {
//          memcpy_off(bDID_LB, 2, NVP_BLOCK_ID_CYCLE_6, 0, 4);
//          break;
//        }
//        case(0x07):  // PRECRASH_7
//        {
//          memcpy_off(bDID_LB, 2, NVP_BLOCK_ID_CYCLE_7, 0, 4);
//          break;
//        }
//        case(0x08):  // PRECRASH_8
//        {
//          memcpy_off(bDID_LB, 2, NVP_BLOCK_ID_CYCLE_8, 0, 4);
//          break;
//        }
//        case(0x09):  // PRECRASH_9
//        {
//          memcpy_off(bDID_LB, 2, NVP_BLOCK_ID_CYCLE_9, 0, 4);
//          break;
//        }
//        case(0x0A):  // PRECRASH_10
//        {
//          memcpy_off(bDID_LB, 2, NVP_BLOCK_ID_CYCLE_10, 0, 4);
//          break;
//        }
//        case(0x0B):  // PRECRASH_11
//        {
//          memcpy_off(bDID_LB, 2, NVP_BLOCK_ID_CYCLE_11, 0, 4);
//          break;
//        }
//        case(0x0C): // PRECRASH_12
//        {
//          memcpy_off(bDID_LB, 2, NVP_BLOCK_ID_CYCLE_12, 0, 4);
//          break;
//        }
//        case(0x0D):  // PRECRASH_13
//        {
//          memcpy_off(bDID_LB, 2, NVP_BLOCK_ID_CYCLE_13, 0, 4);
//          break;
//        }
//        case(0x0E):  // PRECRASH_14
//        {
//          memcpy_off(bDID_LB, 2, NVP_BLOCK_ID_CYCLE_14, 0, 4);
//          break;
//        }
//        case(0x0F):  // PRECRASH_15
//        {
//          memcpy_off(bDID_LB, 2, NVP_BLOCK_ID_CYCLE_15, 0, 4);
//          break;
//        }
//        case(0x10):  // PRECRASH_16
//        {
//          memcpy_off(bDID_LB, 2, NVP_BLOCK_ID_CYCLE_16, 0, 4);
//          break;
//        }
//        case(0x11):  // PRECRASH_17
//        {
//          memcpy_off(bDID_LB, 2, NVP_BLOCK_ID_CYCLE_17, 0, 4);
//          break;
//        }
//        case(0x12):  // PRECRASH_18
//        {
//          memcpy_off(bDID_LB, 2, NVP_BLOCK_ID_CYCLE_18, 0, 4);
//          break;
//        }
//        case(0x18): // BSR
//        {   
//          memcpy_off(bDID_LB, 2, NVP_BLOCK_ID_CYCLE_24, 0, 4);
//          break;
//        }
//        case(0x1D): // Haptic_Warning_0
//        {
//          memcpy_off(bDID_LB, 2, NVP_BLOCK_ID_CYCLE_29, 0, 4);
//          break;
//        }
//        case(0x1E): // Haptic_Warning_1 
//        {
//          memcpy_off(bDID_LB, 2, NVP_BLOCK_ID_CYCLE_30, 0, 4);
//          break;
//        }
//        case(0x21): // SOFT_RELEASE
//        {
//          memcpy_off(bDID_LB, 2, NVP_BLOCK_ID_CYCLE_33, 0, 4);
//          break;
//        }
//        case(0x20): // HARD_RELEASE
//        {
//          memcpy_off(bDID_LB, 2, NVP_BLOCK_ID_CYCLE_32, 0, 4);    
//          break;
//        }
//        case(0x22): // BACKUP_SOFT_RELEASE
//        {
//          memcpy_off(bDID_LB, 2, NVP_BLOCK_ID_CYCLE_34, 0, 4);
//          break;
//        }
//        case(0x1C): // BPDC
//        {
//          memcpy_off(bDID_LB, 2, NVP_BLOCK_ID_CYCLE_28, 0, 4);
//          break;
//        }
//        case(0x1B): // BPDO
//        {
//          memcpy_off(bDID_LB, 2, NVP_BLOCK_ID_CYCLE_27, 0, 4);
//          break;
//        }
//        case(0x24): // AEE_PROCESS
//        {
//          memcpy_off(bDID_LB, 2, NVP_BLOCK_ID_CYCLE_36, 0, 4);
//          break;
//        }
//        case(0x23): // ANG_PROCESS
//        {
//          memcpy_off(bDID_LB, 2, NVP_BLOCK_ID_CYCLE_35, 0, 4);
//          break;
//        }
//        case(0x1F): // STARTUP
//        {
//          memcpy_off(bDID_LB, 2, NVP_BLOCK_ID_CYCLE_31, 0, 4);
//          break;
//        }
//        case(0x19): // OPS
//        {
//          memcpy_off(bDID_LB, 2, NVP_BLOCK_ID_CYCLE_26, 0, 4);
//          break;
//        }
//        default:
//        {     
//          testStepFail(iLevelOfDetailFail, "", "Incorrect cycle name input (WriteStepParameters function).");
//          return 0;
//          break; 
//        }
//      }
//      
//      EnterDiagnosticSession("supplier");
//      dReadMemoryByAddressRequest.SetPrimitiveData(bDID_LB, elcount(bDID_LB));
//      SendDiagnosticRequest(dReadMemoryByAddressRequest, dReadMemoryByAddressResponse);
//      
//      if (CheckPositiveResponse(dReadMemoryByAddressRequest, dReadMemoryByAddressResponse) == 1)
//      {      
//        dReadMemoryByAddressResponse.GetPrimitiveData(ReadCycleRequest_PositiveR, elcount(ReadCycleRequest_PositiveR));
//
//        for(index = 5; index < elcount(ReadCycleRequest_PositiveR); index++)
//        {
//          if(ReadCycleRequest_PositiveR[index] != 0xFF)
//          {
//            if((index - 5) * 6 >= elcount(bSteps))
//            {
//              testStepFail(iLevelOfDetailFail, "", "Number of input steps is too small for cycle:%s! (WriteStepParameters function)", cCycle_UpperCase);
//              return 0;
//            }
//            else
//            {
//              memcpy_off(bAllSteps, (dword)ReadCycleRequest_PositiveR[index] * 8, bSteps, (index - 5) * 6, 6);
//            }
//          }
//        }
//        return 1;
//      }
//      else
//      {
//       testStepFail(iLevelOfDetailFail, "", "NRC received while reading Cycle configuration (WriteStepParameters function)");
//       return 0; 
//      }
//    }
//  }
//  return 0;
//}

/// <Not_Used_Outside_Project_Functions>
// Function that writes the correct checksums for the cycle counters blocks.
//void WriteCountersChecksums()
//{
//  int iDiagOK;
//  int i;
//  int iCRCSum;
//  byte bCounterData[100];
//  byte bWriteChecksumRequest[12]; 
//  byte bEmpty[12];
//  
//  //------
//  iCRCSum = 1;
//  iDiagOK = 0;
//  
//  memcpy(bWriteChecksumRequest, bEmpty, elcount(bWriteChecksumRequest));
//  //------
//  
//  // Form WMBA for checksums.
//  bWriteChecksumRequest[0] = 0x3D; // SID.
//  bWriteChecksumRequest[1] = 0x24; // AddressAndLengthFormatIdentifier.
//  memcpy_off(bWriteChecksumRequest, 2, _au32StartOfCountersBlocks, 0, elcount(_au32StartOfCountersBlocks)); // MemoryAddress.
//  bWriteChecksumRequest[6] = 0x00; // MemorySize.
//  bWriteChecksumRequest[7] = 0x04; // MemorySize.
//  
//  // Form RMBA for counters RAM data.
//  iDiagOK += diagSetParameter(dReadMemoryByAddressRequest, "addressAndLengthFormatIdentifier", 0x24);
//  iDiagOK += diagSetParameterCoded(dReadMemoryByAddressRequest, "MemoryAddress", _au32StartOfCountersBlocks, elcount (_au32StartOfCountersBlocks));
//  iDiagOK += diagSetParameter(dReadMemoryByAddressRequest, "MemorySize", _au32LengthOfCountersBlocks);
//
//  if (iDiagOK != 0)
//  {
//    testStepFail(iLevelOfDetailFail, "", "Read counters checksum: Diag request could not be formed (WriteCountersChecksums function).");
//    return;
//  }
// 
//  SendDiagnosticRequest(dReadMemoryByAddressRequest, dReadMemoryByAddressResponse); // Read execution counter blocks.
//  if(CheckPositiveResponse(dReadMemoryByAddressRequest, dReadMemoryByAddressResponse) == 0)
//  {
//    testStepFail(iLevelOfDetailFail, "", "Checksum calculation function has failed when reading block of counters (WriteCountersChecksums function).");
//    return;
//  }
//  
//  dReadMemoryByAddressResponse.GetPrimitiveData(bCounterData, elcount(bCounterData));
//  
//  for(i = 2; i <= ((_au32LengthOfCountersBlocks / 2) - 1); i++)
//  {
//    iCRCSum += bCounterData[i];
//    
//    if(iCRCSum > 0xFE)
//    {
//      iCRCSum = iCRCSum - 0xFE;
//    }
//    if(iCRCSum > 0xFE)
//    {
//      iCRCSum = iCRCSum - 0xFE;
//    } 
//  }
//
//  memcpy_off(bWriteChecksumRequest, 8, bCounterData, 1, 4);
//  bWriteChecksumRequest[8] = iCRCSum;
//  
//  diagResize(dWriteMemoryByAddressRequest, elcount(bWriteChecksumRequest));
//  dWriteMemoryByAddressRequest.SetPrimitiveData(bWriteChecksumRequest, elcount(bWriteChecksumRequest));
//  
//  SendDiagnosticRequest(dWriteMemoryByAddressRequest, dWriteMemoryByAddressResponse); // Write first byte of checksum.
//  if(CheckPositiveResponse(dWriteMemoryByAddressRequest, dWriteMemoryByAddressResponse) == 0)
//  {
//    testStepFail(iLevelOfDetailFail, "", "Checksum calculation function has failed when writing first byte of checksum. (WriteCountersChecksums function).");
//    testReportWriteDiagResponse(dWriteMemoryByAddressRequest);
//  }
//
//  memcpy_off(bWriteChecksumRequest, 8, bCounterData, (_au32LengthOfCountersBlocks / 2) - 3, 4);
//  bWriteChecksumRequest[11] = iCRCSum;
//  
//  bWriteChecksumRequest[5] += (_au32LengthOfCountersBlocks / 2) - 4; // Set address for second checksum byte.
//  dWriteMemoryByAddressRequest.SetPrimitiveData(bWriteChecksumRequest, elcount(bWriteChecksumRequest));
// 
//  
//  SendDiagnosticRequest(dWriteMemoryByAddressRequest, dWriteMemoryByAddressResponse); // Write second byte of checksum.
//  if(CheckPositiveResponse(dWriteMemoryByAddressRequest, dWriteMemoryByAddressResponse) == 0)
//  {
//    testStepFail(iLevelOfDetailFail, "", "Checksum calculation function has failed when writing second byte of checksum. (WriteCountersChecksums function).");
//    testReportWriteDiagResponse(dWriteMemoryByAddressRequest);
//  }
//  
//  iCRCSum = 1;
//  
//  for(i = ((_au32LengthOfCountersBlocks / 2) + 2); i < _au32LengthOfCountersBlocks; i++)
//  {
//    iCRCSum += bCounterData[i];
//    
//    if(iCRCSum > 0xFE)
//    {
//      iCRCSum = iCRCSum - 0xFE;
//    }
//    if(iCRCSum > 0xFE)
//    {
//      iCRCSum = iCRCSum - 0xFE;
//    } 
//  }
//  
//  memcpy_off(bWriteChecksumRequest, 8, bCounterData, _au32LengthOfCountersBlocks / 2 + 1, 4);
//  bWriteChecksumRequest[8] = iCRCSum;
//  
//  memcpy_off(bWriteChecksumRequest, 2, _au32StartOfCountersBlocks, 0, elcount(_au32StartOfCountersBlocks)); // MemoryAddress.
//  bWriteChecksumRequest[5] +=  _au32LengthOfCountersBlocks / 2;
//  
//  dWriteMemoryByAddressRequest.SetPrimitiveData(bWriteChecksumRequest, elcount(bWriteChecksumRequest));
//  
//  SendDiagnosticRequest(dWriteMemoryByAddressRequest, dWriteMemoryByAddressResponse); // Write third byte of checksum.
//  if(CheckPositiveResponse(dWriteMemoryByAddressRequest, dWriteMemoryByAddressResponse) == 0)
//  {
//    testStepFail(iLevelOfDetailFail, "", "Checksum calculation function has failed when writing thitd byte of checksum. (WriteCountersChecksums function).");
//    testReportWriteDiagResponse(dWriteMemoryByAddressRequest);
//  }
//
//  memcpy_off(bWriteChecksumRequest, 8, bCounterData, _au32LengthOfCountersBlocks - 3, 4);
//  bWriteChecksumRequest[11] = iCRCSum;
//  
//  memcpy_off(bWriteChecksumRequest, 2, _au32StartOfCountersBlocks, 0, elcount(_au32StartOfCountersBlocks)); // MemoryAddress.
//  bWriteChecksumRequest[5] +=  _au32LengthOfCountersBlocks - 4;
//  dWriteMemoryByAddressRequest.SetPrimitiveData(bWriteChecksumRequest, elcount(bWriteChecksumRequest));
//  
//  
//  SendDiagnosticRequest(dWriteMemoryByAddressRequest, dWriteMemoryByAddressResponse); // Write fourth byte of checksum.
//  if(CheckPositiveResponse(dWriteMemoryByAddressRequest, dWriteMemoryByAddressResponse) == 0)
//  {
//    testStepFail(iLevelOfDetailFail, "", "Checksum calculation function has failed when writing fourth byte of checksum. (WriteCountersChecksums function).");
//    testReportWriteDiagResponse(dWriteMemoryByAddressRequest);
//  }
//}


/// <Profile_management>
// Function that detects a cycle or a cycle and a step from said cycle.
// Overload with no "IgnoredCycles" variable.
// No cycle is ignored.
int DetectCycleStep(char cInputCycle[], char cInputStep[], float fMaxTime)
{
  return DetectCycleStep(cInputCycle, cInputStep, fMaxTime, "*");
}

/// <Profile_management>
// Function that detects a cycle or a cycle and a step from said cycle.
// "cInputCycle"    = The cycle to search for:
//                  Input option 1: "Precrash_2".
//                  Input option 2: "0x02".
// "cInputStep"     = The cycle step to search for:
//                  Input option 1: "0x01".
//                  Input option 2: "*" -> The function will only search for "cInputCycle".
// "fMaxTime"       = Period of time in ms searching for the cycle / cycle and step.
// "cIgnoredCycles" = Cycles to be ignored.
//                  Input option 1: Char array of cycles separated by ",".
//                  Input option 2: "" or "*" -> The function will not ignore any cycle.
// Example:         DetectCycleStep("0x1F", "*", 2000, "PRECRASH_1,BSR");
// Output:          Returns the cyle or cycle/step time of detection in ms (0 if not detected).
int DetectCycleStep(char cInputCycle[], char cInputStep[], float fMaxTime, char cIgnoredCycles[])
{
  stack int index;
  stack int iIgnoredCycleIndex;
  stack int iCount = 0;
  stack int iUnexpectedCycleIndex;
  stack char cInputCycle_UpperCase[20];
  stack char cIgnoredCyclesArray[3][20];
  stack char cIgnoredCycles_UpperCase[3][20];
  stack byte bCycle = 0xAA;
  stack byte bIgnoredCycle[3] = {0xFF, 0xFF, 0xFF};  
  stack byte bCurrentCycle;
  stack byte bStep;
  stack byte bUnexpectedCycles[3];
  stack float fIgnoredCycleTime[3] = {0x00, 0x00, 0x00};
  stack float fStartTime = timeNow() / 100; // simulation time in ms.
  stack float fCycleDetectionTime;
  stack float fCurrentTime = 0; 
  message * MeasurementFrame;
  
  stack int iActiveProfile = 1;
  
  // Process input variables <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
  ConvertCharArrayInput(cIgnoredCycles, "DetectCycleStep Ignored steps", cIgnoredCyclesArray);
  
  toUpper(cInputCycle_UpperCase, cInputCycle, elcount(cInputCycle_UpperCase));
  for(iIgnoredCycleIndex = 0; iIgnoredCycleIndex < elcount(cIgnoredCyclesArray); iIgnoredCycleIndex++) // Upper case "cIgnoredCycles" array.
  { 
    toUpper(cIgnoredCycles_UpperCase[iIgnoredCycleIndex], cIgnoredCyclesArray[iIgnoredCycleIndex], elcount(cIgnoredCycles_UpperCase[iIgnoredCycleIndex]));
  }
  
  for(index = 0; index < elcount(bAllCycleMeasurement); index++) // Get cycle ID for option 1 "cInputCycle" input.
  {
    if(strncmp(cAllCycles[index], cInputCycle_UpperCase, elcount(cInputCycle_UpperCase)) == 0)
    {
      bCycle = bAllCycleMeasurement[index]; 
    }
    
    for(iIgnoredCycleIndex = 0; iIgnoredCycleIndex < elcount(cIgnoredCyclesArray); iIgnoredCycleIndex++) // Get cycle ID for "cIgnoredCycles" input.
    { 
      if(strncmp(cAllCycles[index], cIgnoredCycles_UpperCase[iIgnoredCycleIndex], elcount(cAllCycles[index])) == 0)
        {     
          bIgnoredCycle[iIgnoredCycleIndex] = bAllCycleMeasurement[index]; 
        }
    }
  }
  
  if(bCycle == 0xAA) // Check proper format for option 2 "cInputCycle" input.
  {
     if((strncmp(cInputCycle, "0x", 2) == 0) && (elcount(cInputCycle) <= 5) && (str_match_regex(cInputCycle, "0x[A-Fa-f0-9]{2}") == 1))
      {
        bCycle = atodbl(cInputCycle);
      }
      else
      {
        testStepFail(iLevelOfDetailFail, "-", "Incorrect Cycle input; Please check Cycle input for DetectCycleStep function.");
        return CYCLE_DETECT_ERROR;
      }
  }

  for(index = 0; index < elcount(cIgnoredCyclesArray); index++) // Check proper format for "cIgnoredCycles" input.
  {    
    if(strncmp(cIgnoredCyclesArray[index], "*", 1) != 0)
    {
      if(bIgnoredCycle[index] == 0xFF) 
      {          
        testStepFail(iLevelOfDetailFail, "-", "Incorrect Ignored Cycle input; Please check Ignored Cycle input for DetectCycleStep function.");
        return CYCLE_DETECT_ERROR;
      }
    }
  }

  if((strncmp(cInputStep, "0x", 2) == 0) && (elcount(cInputStep) <= 5) && (str_match_regex(cInputStep, "0x[0-8]{2}") == 1)) // Check proper format for "cInputStep" input.
  {
    bStep = atodbl(cInputStep);
  }
  else 
  {
    if (strncmp(cInputStep, "*", 1) != 0)
    {
      testStepFail(iLevelOfDetailFail, "-", "Incorrect Step input; Please check Step input for DetectCycleStep function.");
      return CYCLE_DETECT_ERROR;
    }
  }
  // Process input variables >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
  
  if (TestWaitForMessage(@sysvar::ProjectConfiguration::sysMeasurementFrameID, 30) == 1) // Check if MF is active.
  {
    if(TestGetWaitEventMsgData(MeasurementFrame) == 0)
    {   
      iCount = 0;
      while((MeasurementFrame.byte(0) != 0x01) && (MeasurementFrame.byte(0) != 0x0F) && (MeasurementFrame.byte(0) != 0x18) && (iCount < 20)) // Check if proper MF blocks are active.
      {
        TestWaitForMessage(MeasurementFrame.id, 5);
        TestGetWaitEventMsgData(MeasurementFrame);
        iCount++;
      }
    }
    else
    {
      testStepFail(iLevelOfDetailFail, "-", "Measurement Frame: Data access could not be executed, the last event was not a message event.");
      return CYCLE_DETECT_ERROR;
    }
  }
  else 
  {
    testStepFail(iLevelOfDetailFail, "-", "Measurement Frame not detected in 30 ms.");
    return CYCLE_DETECT_ERROR;
  }

  if(iCount >= 20)
  {
    testStepFail(iLevelOfDetailFail, "-", "Incorrect MF active block(s); Measurement Frame block (1 or 15 or 24) not detected in %f ms", (timeNow() / 100) - fStartTime);
    return CYCLE_DETECT_ERROR;
  }
  else
  {
  // Check for "cInputCycle" <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
    
    if (iActiveProfile == 0)
    {
      bCurrentCycle = MeasurementFrame.byte(1);
    }
    else
    {
      bCurrentCycle = bCycle;
    }
 
    iUnexpectedCycleIndex = 0;
    while((MeasurementFrame.byte(1) != bCycle) && (fCurrentTime < fMaxTime)) // Search for "cInputCycle" for "fMaxTime" or until found.
    {
      if((MeasurementFrame.byte(1) != bCurrentCycle) && (MeasurementFrame.byte(1) != 0xFF)) // Unexpected cycle case.
      {         
        if(iUnexpectedCycleIndex == 0)
        {
          bUnexpectedCycles[0] = (MeasurementFrame.byte(1));
          fIgnoredCycleTime[0] = (timeNow() / 100) - fStartTime;
          iUnexpectedCycleIndex++;
        }
        else if (MeasurementFrame.byte(1) != bUnexpectedCycles[iUnexpectedCycleIndex - 1])
              {
                bUnexpectedCycles[iUnexpectedCycleIndex] = MeasurementFrame.byte(1);
                fIgnoredCycleTime[iUnexpectedCycleIndex] = (timeNow() / 100) - fStartTime;
                iUnexpectedCycleIndex++;
              }
      }
      
      testWaitForTimeout(5);
      if (TestWaitForMessage(MeasurementFrame.id, 30) != 1)
      {
        testStepFail(iLevelOfDetailFail, "-", "Measurement Frame not detected in 30 ms.");
        return CYCLE_DETECT_ERROR;
      }
      TestGetWaitEventMsgData(MeasurementFrame);
      
      iCount = 0;
      while((MeasurementFrame.byte(0) != 0x01) && (MeasurementFrame.byte(0) != 0x0F) && (MeasurementFrame.byte(0) != 0x18) && (iCount < 20))
      {
        TestWaitForMessage(MeasurementFrame.id, 5);
        TestGetWaitEventMsgData(MeasurementFrame);
        iCount++;
      }
      
      if(iCount >= 20)
      {
        testStepFail(iLevelOfDetailFail, "-", "Incorrect MF active block(s); Measurement Frame block (1 or 15 or 24) no longer detected.");
        return CYCLE_DETECT_ERROR;
      }
      
      fCurrentTime = (timeNow() / 100) - fStartTime;
    }
  // Check for "cInputCycle" >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
   
  // Check for unexpected cycles <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
    if(iUnexpectedCycleIndex > 0)
    {
      for(index = 0; index < iUnexpectedCycleIndex; index++)
      {
        for (iIgnoredCycleIndex = 0; iIgnoredCycleIndex < elcount(bUnexpectedCycles); iIgnoredCycleIndex++)
          {        
            if(bUnexpectedCycles[index] == bIgnoredCycle[iIgnoredCycleIndex])
            {                     
              iIgnoredCycleIndex = elcount(bUnexpectedCycles);
            }
          }
        if(iIgnoredCycleIndex == elcount(bUnexpectedCycles) + 1)
        {
           testStep(iLevelOfDetailStep, "", "Unexpected cycle %x was detected in %.f ms, but you chose to ignore it.", bUnexpectedCycles[index], fIgnoredCycleTime[index]);
        }
        else
        {             
           testStepFail(iLevelOfDetailFail, "-", "Unexpected cycle %x was detected in %.f ms.", bUnexpectedCycles[index], fIgnoredCycleTime[index]);
        }         
      }
    }
  // Check for unexpected cycles >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
    
  // Check for "cInputStep" <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
    if(fCurrentTime >= fMaxTime) // Only check for "cInputStep" if "cInputCycle" was detected in "fMaxTime".
    {
     testStep(iLevelOfDetailStep, "", "%s cycle was not detected in %.f ms (simulation time).", cInputCycle, fCurrentTime);
     return CYCLE_NOT_DETECTED;
    }
    else
    {
      testStep(iLevelOfDetailStep, "", "%s cycle detected in %.f ms (simulation time).", cInputCycle, fCurrentTime);
      fCycleDetectionTime = fCurrentTime;
      
      if((strncmp(cInputStep, "*", 1) != 0))
      {
        while(bStep != MeasurementFrame.byte(2) && (fCurrentTime < fMaxTime))
        {
          if (bCycle != MeasurementFrame.byte(1)) // Stop waiting for "cInputStep" if cycle ends before "fMaxTime".
          {
            testStep(iLevelOfDetailStep, "", "Step %x was not detected. %s cycle ended in %.f ms (simulation time). ", bStep, cInputCycle, fCurrentTime);
            return CYCLE_DETECTED_STEP_NOT_DETECTED;
          }
          else
          {
            testWaitForTimeout(5);
            if (TestWaitForMessage(MeasurementFrame.id, 30) != 1)
            {
              testStepFail(iLevelOfDetailFail, "-", "Measurement Frame not detected in 30 ms.");
              return CYCLE_DETECT_ERROR;
            }
            TestGetWaitEventMsgData(MeasurementFrame);
            
            iCount = 0;
            while((MeasurementFrame.byte(0) != 0x01) && (MeasurementFrame.byte(0) != 0x0F) && (MeasurementFrame.byte(0) != 0x18) && (iCount < 20))
            {
              TestWaitForMessage(MeasurementFrame.id, 5);
              TestGetWaitEventMsgData(MeasurementFrame);
              iCount++;
            }
            
            if(iCount >= 20)
            {
              testStepFail(iLevelOfDetailFail, "-", "Incorrect MF active block(s); Measurement Frame block (1 or 15 or 24) no longer detected.");
              return CYCLE_DETECT_ERROR;
            }

            fCurrentTime = (timeNow() / 100) - fStartTime;
            } 
        }
        
        if (fCurrentTime < fMaxTime)
        {
          testStep(iLevelOfDetailStep, "", "Step %x was detected in %.f ms (simulation time) and %.f ms since %s cycle was detected.", bStep, fCurrentTime, (fCurrentTime - fCycleDetectionTime), cInputCycle);
          return CYCLE_AND_STEP_DETECTED;
        }
        else
        {
          testStep(iLevelOfDetailStep, "", "Step %x  was not detected in %.f ms (simulation time).", bStep, fCurrentTime);
          return CYCLE_DETECTED_STEP_NOT_DETECTED;
        }
      }
      else return CYCLE_DETECTED;
    }
  }
  // Check for "cInputStep" >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
}

/// <Profile_management>
int DetectCycleStep(byte bCycle, float fMaxTime, byte bIgnoredCycles)
{
  return DetectCycleStep(bCycle, 0xFF, fMaxTime, bIgnoredCycles);
}

/// <Profile_management>
int DetectCycleStep(byte bCycle, float fMaxTime)
{
  return DetectCycleStep(bCycle, 0xFF, fMaxTime, 0xFF);
}

/// <Profile_management>
int DetectCycleStep(byte bCycle, byte bStep, float fMaxTime, byte bIgnoredCycle)
{
  stack int index;
  stack int iIgnoredCycleIndex;
  stack int iCount = 0;
  stack int iUnexpectedCycleIndex;
  stack char cInputCycle_UpperCase[20];
  stack char cIgnoredCyclesArray[3][20]; 
  stack byte bCurrentCycle;
  stack byte bUnexpectedCycles[3];
  stack float fIgnoredCycleTime[3] = {0x00, 0x00, 0x00};
  stack float fStartTime = timeNow() / 100; // simulation time in ms.
  stack float fCycleDetectionTime;
  stack float fCurrentTime = 0; 
  message * MeasurementFrame;
  
  stack int iActiveProfile = 1;

  // Process input variables >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
  
  if (TestWaitForMessage(@sysvar::ProjectConfiguration::sysMeasurementFrameID, 30) == 1) // Check if MF is active.
  {
    if(TestGetWaitEventMsgData(MeasurementFrame) == 0)
    {   
      iCount = 0;
      while((MeasurementFrame.byte(0) != 0x01) && (MeasurementFrame.byte(0) != 0x0F) && (MeasurementFrame.byte(0) != 0x18) && (iCount < 20)) // Check if proper MF blocks are active.
      {
        TestWaitForMessage(MeasurementFrame.id, 5);
        TestGetWaitEventMsgData(MeasurementFrame);
        iCount++;
      }
    }
    else
    {
      testStepFail(iLevelOfDetailFail, "-", "Measurement Frame: Data access could not be executed, the last event was not a message event.");
      return CYCLE_DETECT_ERROR;
    }
  }
  else 
  {
    testStepFail(iLevelOfDetailFail, "-", "Measurement Frame not detected in 30 ms.");
    return CYCLE_DETECT_ERROR;
  }

  if(iCount >= 20)
  {
    testStepFail(iLevelOfDetailFail, "-", "Incorrect MF active block(s); Measurement Frame block (1 or 15 or 24) not detected in %f ms", (timeNow() / 100) - fStartTime);
    return CYCLE_DETECT_ERROR;
  }
  else
  {
  // Check for "cInputCycle" <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
    
    if (iActiveProfile == 0)
    {
      bCurrentCycle = MeasurementFrame.byte(1);
    }
    else
    {
      bCurrentCycle = bCycle;
    }
 
    iUnexpectedCycleIndex = 0;
    while((MeasurementFrame.byte(1) != CYCLE[bCycle].MF_ID) && (fCurrentTime < fMaxTime)) // Search for "cInputCycle" for "fMaxTime" or until found.
    {
      if((MeasurementFrame.byte(1) != bCurrentCycle) && (MeasurementFrame.byte(1) != 0xFF)) // Unexpected cycle case.
      {         
        if(iUnexpectedCycleIndex == 0)
        {
          bUnexpectedCycles[0] = (MeasurementFrame.byte(1));
          fIgnoredCycleTime[0] = (timeNow() / 100) - fStartTime;
          iUnexpectedCycleIndex++;
        }
        else if (MeasurementFrame.byte(1) != bUnexpectedCycles[iUnexpectedCycleIndex - 1])
              {
                bUnexpectedCycles[iUnexpectedCycleIndex] = MeasurementFrame.byte(1);
                fIgnoredCycleTime[iUnexpectedCycleIndex] = (timeNow() / 100) - fStartTime;
                iUnexpectedCycleIndex++;
              }
      }
      
      testWaitForTimeout(5);
      if (TestWaitForMessage(MeasurementFrame.id, 30) != 1)
      {
        testStepFail(iLevelOfDetailFail, "-", "Measurement Frame not detected in 30 ms.");
        return CYCLE_DETECT_ERROR;
      }
      TestGetWaitEventMsgData(MeasurementFrame);
      
      iCount = 0;
      while((MeasurementFrame.byte(0) != 0x01) && (MeasurementFrame.byte(0) != 0x0F) && (MeasurementFrame.byte(0) != 0x18) && (iCount < 20))
      {
        TestWaitForMessage(MeasurementFrame.id, 5);
        TestGetWaitEventMsgData(MeasurementFrame);
        iCount++;
      }
      
      if(iCount >= 20)
      {
        testStepFail(iLevelOfDetailFail, "-", "Incorrect MF active block(s); Measurement Frame block (1 or 15 or 24) no longer detected.");
        return CYCLE_DETECT_ERROR;
      }
      
      fCurrentTime = (timeNow() / 100) - fStartTime;
    }
  // Check for "cInputCycle" >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
   
  // Check for unexpected cycles <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
   
    if(iUnexpectedCycleIndex > 0)
    {
      for(index = 0; index < iUnexpectedCycleIndex; index++)
      {
        if (bIgnoredCycle != 0xFF )
        {
          if(bUnexpectedCycles[index] == CYCLE[bIgnoredCycle].MF_ID)
          {                     

             testStep(iLevelOfDetailStep, "", "Unexpected cycle %x was detected in %.f ms, but you chose to ignore it.", bUnexpectedCycles[index], fIgnoredCycleTime[index]);
          }
          else
          {             
             testStepFail(iLevelOfDetailFail, "-", "Unexpected cycle %x was detected in %.f ms.", bUnexpectedCycles[index], fIgnoredCycleTime[index]);
          }
        }
        else
        {
          testStepFail(iLevelOfDetailFail, "-", "Unexpected cycle %x was detected in %.f ms.", bUnexpectedCycles[index], fIgnoredCycleTime[index]);
        }
      }
    }
  // Check for unexpected cycles >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
    
  // Check for "cInputStep" <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
    if(fCurrentTime >= fMaxTime) // Only check for "cInputStep" if "cInputCycle" was detected in "fMaxTime".
    {
     testStep(iLevelOfDetailStep, "", "0x%02X - %s cycle was not detected in %.f ms (simulation time).", CYCLE[bCycle].MF_ID, CYCLE[bCycle].MF_Name, fCurrentTime);
     return CYCLE_NOT_DETECTED;
    }
    else
    {
      testStep(iLevelOfDetailStep, "", "0x%02X - %s  cycle detected in %.f ms (simulation time).", CYCLE[bCycle].MF_ID, CYCLE[bCycle].MF_Name, fCurrentTime);
      fCycleDetectionTime = fCurrentTime;
      
      if(bStep != 0xFF)
      {
        while(bStep != MeasurementFrame.byte(2) && (fCurrentTime < fMaxTime))
        {
          if (CYCLE[bCycle].MF_ID != MeasurementFrame.byte(1)) // Stop waiting for "cInputStep" if cycle ends before "fMaxTime".
          {
            testStep(iLevelOfDetailStep, "", "Step 0x%02X was not detected. %s cycle ended in %.f ms (simulation time). ", bStep, CYCLE[bCycle].MF_Name, fCurrentTime);
            return CYCLE_DETECTED_STEP_NOT_DETECTED;
          }
          else
          {
            testWaitForTimeout(5);
            if (TestWaitForMessage(MeasurementFrame.id, 30) != 1)
            {
              testStepFail(iLevelOfDetailFail, "-", "Measurement Frame not detected in 30 ms.");
              return CYCLE_DETECT_ERROR;
            }
            TestGetWaitEventMsgData(MeasurementFrame);
            
            iCount = 0;
            while((MeasurementFrame.byte(0) != 0x01) && (MeasurementFrame.byte(0) != 0x0F) && (MeasurementFrame.byte(0) != 0x18) && (iCount < 20))
            {
              TestWaitForMessage(MeasurementFrame.id, 5);
              TestGetWaitEventMsgData(MeasurementFrame);
              iCount++;
            }
            
            if(iCount >= 20)
            {
              testStepFail(iLevelOfDetailFail, "-", "Incorrect MF active block(s); Measurement Frame block (1 or 15 or 24) no longer detected.");
              return CYCLE_DETECT_ERROR;
            }

            fCurrentTime = (timeNow() / 100) - fStartTime;
            } 
        }
        
        if (fCurrentTime < fMaxTime)
        {
          testStep(iLevelOfDetailStep, "", "Step 0x%02X was detected in %.f ms (simulation time) and %.f ms since %s cycle was detected.", bStep, fCurrentTime, (fCurrentTime - fCycleDetectionTime), CYCLE[bCycle].MF_Name);
          return CYCLE_AND_STEP_DETECTED;
        }
        else
        {
          testStep(iLevelOfDetailStep, "", "Step 0x%02X  was not detected in %.f ms (simulation time).", bStep, fCurrentTime);
          return CYCLE_DETECTED_STEP_NOT_DETECTED;
        }
      }
      else return CYCLE_DETECTED;
    }
  }
  // Check for "cInputStep" >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
}

/// <Profile_management>
int DetectCycleStep(byte bCycle, byte bStep, float fMaxTime, byte bIgnoredCycle, byte bIgnoredCycle2)
{
  stack int index;
  stack int iIgnoredCycleIndex;
  stack int iCount = 0;
  stack int iUnexpectedCycleIndex;
  stack char cInputCycle_UpperCase[20];
  stack char cIgnoredCyclesArray[3][20];
  stack byte bCurrentCycle;
  stack byte bUnexpectedCycles[3];
  stack float fIgnoredCycleTime[3] = {0x00, 0x00, 0x00};
  stack float fStartTime = timeNow() / 100; // simulation time in ms.
  stack float fCycleDetectionTime;
  stack float fCurrentTime = 0; 
  message * MeasurementFrame;
  
  stack int iActiveProfile = 1;

  // Process input variables >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
  
  if (TestWaitForMessage(@sysvar::ProjectConfiguration::sysMeasurementFrameID, 30) == 1) // Check if MF is active.
  {
    if(TestGetWaitEventMsgData(MeasurementFrame) == 0)
    {   
      iCount = 0;
      while((MeasurementFrame.byte(0) != 0x01) && (MeasurementFrame.byte(0) != 0x0F) && (MeasurementFrame.byte(0) != 0x18) && (iCount < 20)) // Check if proper MF blocks are active.
      {
        TestWaitForMessage(MeasurementFrame.id, 5);
        TestGetWaitEventMsgData(MeasurementFrame);
        iCount++;
      }
    }
    else
    {
      testStepFail(iLevelOfDetailFail, "-", "Measurement Frame: Data access could not be executed, the last event was not a message event.");
      return CYCLE_DETECT_ERROR;
    }
  }
  else 
  {
    testStepFail(iLevelOfDetailFail, "-", "Measurement Frame not detected in 30 ms.");
    return CYCLE_DETECT_ERROR;
  }

  if(iCount >= 20)
  {
    testStepFail(iLevelOfDetailFail, "-", "Incorrect MF active block(s); Measurement Frame block (1 or 15 or 24) not detected in %f ms", (timeNow() / 100) - fStartTime);
    return CYCLE_DETECT_ERROR;
  }
  else
  {
  // Check for "cInputCycle" <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
    
    if (iActiveProfile == 0)
    {
      bCurrentCycle = MeasurementFrame.byte(1);
    }
    else
    {
      bCurrentCycle = bCycle;
    }
 
    iUnexpectedCycleIndex = 0;
    while((MeasurementFrame.byte(1) != CYCLE[bCycle].MF_ID) && (fCurrentTime < fMaxTime)) // Search for "cInputCycle" for "fMaxTime" or until found.
    {
      if((MeasurementFrame.byte(1) != bCurrentCycle) && (MeasurementFrame.byte(1) != 0xFF)) // Unexpected cycle case.
      {         
        if(iUnexpectedCycleIndex == 0)
        {
          bUnexpectedCycles[0] = (MeasurementFrame.byte(1));
          fIgnoredCycleTime[0] = (timeNow() / 100) - fStartTime;
          iUnexpectedCycleIndex++;
        }
        else if (MeasurementFrame.byte(1) != bUnexpectedCycles[iUnexpectedCycleIndex - 1])
              {
                bUnexpectedCycles[iUnexpectedCycleIndex] = MeasurementFrame.byte(1);
                fIgnoredCycleTime[iUnexpectedCycleIndex] = (timeNow() / 100) - fStartTime;
                iUnexpectedCycleIndex++;
              }
      }
      
      testWaitForTimeout(5);
      if (TestWaitForMessage(MeasurementFrame.id, 30) != 1)
      {
        testStepFail(iLevelOfDetailFail, "-", "Measurement Frame not detected in 30 ms.");
        return CYCLE_DETECT_ERROR;
      }
      TestGetWaitEventMsgData(MeasurementFrame);
      
      iCount = 0;
      while((MeasurementFrame.byte(0) != 0x01) && (MeasurementFrame.byte(0) != 0x0F) && (MeasurementFrame.byte(0) != 0x18) && (iCount < 20))
      {
        TestWaitForMessage(MeasurementFrame.id, 5);
        TestGetWaitEventMsgData(MeasurementFrame);
        iCount++;
      }
      
      if(iCount >= 20)
      {
        testStepFail(iLevelOfDetailFail, "-", "Incorrect MF active block(s); Measurement Frame block (1 or 15 or 24) no longer detected.");
        return CYCLE_DETECT_ERROR;
      }
      
      fCurrentTime = (timeNow() / 100) - fStartTime;
    }
  // Check for "cInputCycle" >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
   
  // Check for unexpected cycles <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
   
    if(iUnexpectedCycleIndex > 0)
    {
      for(index = 0; index < iUnexpectedCycleIndex; index++)
      {
        if (bIgnoredCycle != 0xFF )
        {
          if(bUnexpectedCycles[index] == CYCLE[bIgnoredCycle].MF_ID)
          {                     

             testStep(iLevelOfDetailStep, "", "Unexpected cycle %x was detected in %.f ms, but you chose to ignore it.", bUnexpectedCycles[index], fIgnoredCycleTime[index]);
          }
          else
          {             
             testStepFail(iLevelOfDetailFail, "-", "Unexpected cycle %x was detected in %.f ms.", bUnexpectedCycles[index], fIgnoredCycleTime[index]);
          }   
          
          if(bUnexpectedCycles[index] == CYCLE[bIgnoredCycle2].MF_ID)
          {                     

             testStep(iLevelOfDetailStep, "", "Unexpected cycle %x was detected in %.f ms, but you chose to ignore it.", bUnexpectedCycles[index], fIgnoredCycleTime[index]);
          }
          else
          {             
             testStepFail(iLevelOfDetailFail, "-", "Unexpected cycle %x was detected in %.f ms.", bUnexpectedCycles[index], fIgnoredCycleTime[index]);
          }   
        }
        else
        {
          testStepFail(iLevelOfDetailFail, "-", "Unexpected cycle %x was detected in %.f ms.", bUnexpectedCycles[index], fIgnoredCycleTime[index]);
        }
      }
    }
  // Check for unexpected cycles >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
    
  // Check for "cInputStep" <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
    if(fCurrentTime >= fMaxTime) // Only check for "cInputStep" if "cInputCycle" was detected in "fMaxTime".
    {
     testStep(iLevelOfDetailStep, "", "0x%02X - %s cycle was not detected in %.f ms (simulation time).", CYCLE[bCycle].MF_ID, CYCLE[bCycle].MF_Name, fCurrentTime);
     return CYCLE_NOT_DETECTED;
    }
    else
    {
      testStep(iLevelOfDetailStep, "", "0x%02X - %s  cycle detected in %.f ms (simulation time).", CYCLE[bCycle].MF_ID, CYCLE[bCycle].MF_Name, fCurrentTime);
      fCycleDetectionTime = fCurrentTime;
      
      if(bStep != 0xFF)
      {
        while(bStep != MeasurementFrame.byte(2) && (fCurrentTime < fMaxTime))
        {
          if (CYCLE[bCycle].MF_ID != MeasurementFrame.byte(1)) // Stop waiting for "cInputStep" if cycle ends before "fMaxTime".
          {
            testStep(iLevelOfDetailStep, "", "Step 0x%02X was not detected. %s cycle ended in %.f ms (simulation time). ", bStep, CYCLE[bCycle].MF_Name, fCurrentTime);
            return CYCLE_DETECTED_STEP_NOT_DETECTED;
          }
          else
          {
            testWaitForTimeout(5);
            if (TestWaitForMessage(MeasurementFrame.id, 30) != 1)
            {
              testStepFail(iLevelOfDetailFail, "-", "Measurement Frame not detected in 30 ms.");
              return CYCLE_DETECT_ERROR;
            }
            TestGetWaitEventMsgData(MeasurementFrame);
            
            iCount = 0;
            while((MeasurementFrame.byte(0) != 0x01) && (MeasurementFrame.byte(0) != 0x0F) && (MeasurementFrame.byte(0) != 0x18) && (iCount < 20))
            {
              TestWaitForMessage(MeasurementFrame.id, 5);
              TestGetWaitEventMsgData(MeasurementFrame);
              iCount++;
            }
            
            if(iCount >= 20)
            {
              testStepFail(iLevelOfDetailFail, "-", "Incorrect MF active block(s); Measurement Frame block (1 or 15 or 24) no longer detected.");
              return CYCLE_DETECT_ERROR;
            }

            fCurrentTime = (timeNow() / 100) - fStartTime;
            } 
        }
        
        if (fCurrentTime < fMaxTime)
        {
          testStep(iLevelOfDetailStep, "", "Step 0x%02X was detected in %.f ms (simulation time) and %.f ms since %s cycle was detected.", bStep, fCurrentTime, (fCurrentTime - fCycleDetectionTime), CYCLE[bCycle].MF_Name);
          return CYCLE_AND_STEP_DETECTED;
        }
        else
        {
          testStep(iLevelOfDetailStep, "", "Step 0x%02X  was not detected in %.f ms (simulation time).", bStep, fCurrentTime);
          return CYCLE_DETECTED_STEP_NOT_DETECTED;
        }
      }
      else return CYCLE_DETECTED;
    }
  }
  // Check for "cInputStep" >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
}

/// <Profile_management>
// Sets the signals values needed in order to have the tensioning functions operational.
void EnableTriggeringPreconditions()
{ 
  stack char cECU[100];

  // Frame: Ign_Stat_ST3
  $ISw_Stat_ST3 = 4; // Ignition switch state: 4 = "IGN_ON".
  testWaitForSignalUpdate(ISw_Stat_ST3, 100);
  
  diagGetCurrentEcu(cECU, elcount(cECU));
  if (strncmp(cECU, sTargetECUFrontLeftName, elcount(cECU)) == 0)
  {
    // Frame: Bckl_Sw_Fx_Stat_ST3
    $Bckl_Sw_D_Stat_ST3  = 0; // Buckle switch driver state: 0     = "STAT_OK".
    testWaitForSignalUpdate(Bckl_Sw_D_Stat_ST3, 100);
  }
  else if(strncmp(cECU, sTargetECUFrontRightName, elcount(cECU)) == 0)
  {
    $Bckl_Sw_FP_Stat_ST3 = 0; // Buckle switch passenger state: 0 = "STAT_OK".
    testWaitForSignalUpdate(Bckl_Sw_FP_Stat_ST3, 100);
  }

  //Frame: PresfAct_Adj_ST3
  $PresfAct_TensSupp_Rq_ST3 = 0; // Presafe actuator tensioning suppress request: 0 = "NO".
  testWaitForSignalUpdate(PresfAct_TensSupp_Rq_ST3, 100);
  $Presf_Enbl_ST3 = 1;           // Presafe enabled: 1 = "TRUE".
  testWaitForSignalUpdate(Presf_Enbl_ST3, 100);
  
  // Frame: Impact3_ST3
  $Impact_RO_type1_ST3 = 0; // Rollover mittels Drehratensensorik (Rollover by means of rotation rate sensor technology).
  testWaitForSignalUpdate(Impact_RO_type1_ST3, 100);
  $Impact_RO_type2_ST3 = 0; // Rollover mittels Beschleunigungssensorik (Rollover by means of acceleration sensor technology).
  testWaitForSignalUpdate(Impact_RO_type2_ST3, 100);
  
  WaitCycleToFinish();
}

/// <Profile_management>
// "cCycle" = cycle to be triggered.
// Tensioning level [1,2] is equal to tensioning cycles [0,1].
// Example: LaunchMasterBeltProfile(cAllCycleLaunchName[0]) ? Cycle 0 will be triggered.
void LaunchMasterBeltProfile(char cProfile[])
{ 
  stack int index = 0;
  stack int foundflag = 0;
  
  toUpper(cProfile, cProfile, elcount(cProfile));
  for (index = 0; index < elCount(cAllCycleLaunchName); index++)
  {
    if (strncmp(cProfile, cAllCycleLaunchName[index], elcount(cProfile)) == 0)
    {
      foundflag = 1;
      $PresfAct_Adj_ST3::Presf_Lvl_ST3 = bAllCycleLaunchCode[index];
      testWaitForSignalChange(PresfAct_Adj_ST3::Presf_Lvl_ST3, 100);
      
      if (strncmp(cProfile, "NOLVL", elcount(cProfile)) == 0)
      {
        $PresfAct_Adj_ST3::PresfAccelReset_NotExcd_ST3 = 1;
        testWaitForSignalChange(PresfAct_Adj_ST3::PresfAccelReset_NotExcd_ST3, 100);
      }
      
    }
  }
  
  if (foundflag == 0)
  {
    testStepFail(iLevelOfDetailFail, "", "Wrong parameter for LaunchMasterBeltProfile function: %s", cProfile);
  }
}

/// <Profile_management>
void LaunchMasterBeltProfile(byte bProfile)
{ 
  stack int index = 0;
  stack int foundflag = 0;
  char targetName[100];
    
  diagGetCurrentEcu(targetName, elcount(targetName));

  if (bProfile == 0x00 )
  {
    $PresfAct_Adj_ST3::PresfAccelReset_NotExcd_ST3 = 1;
    testWaitForSignalChange(PresfAct_Adj_ST3::PresfAccelReset_NotExcd_ST3, 100);
    
    $PresfAct_Adj_ST3::Presf_Lvl_ST3 = CYCLE[bProfile].Launch_ID;
    testWaitForSignalChange(PresfAct_Adj_ST3::Presf_Lvl_ST3, 100);
  }
  else
  {
    if (bProfile == BSR_1)
    {
      if (strncmp(targetName, sTargetECUFrontLeftName, elcount(targetName)) == 0)
      {
        $Bckl_Sw_D_Stat_ST3  = 1; // Buckle switch driver state: 1     = "STAT_NOK".
        testWaitForSignalUpdate(Bckl_Sw_D_Stat_ST3, 100);
        
        testWaitForTimeout(610);
        
        $Bckl_Sw_D_Stat_ST3  = 0; // Buckle switch driver state: 0     = "STAT_OK".
        testWaitForSignalUpdate(Bckl_Sw_D_Stat_ST3, 100);
      }
      else
      {
        $Bckl_Sw_FP_Stat_ST3  = 1; // Buckle switch driver state: 1     = "STAT_NOK".
        testWaitForSignalUpdate(Bckl_Sw_FP_Stat_ST3, 100);
        
        testWaitForTimeout(100);
        
        $Bckl_Sw_FP_Stat_ST3  = 0; // Buckle switch driver state: 0     = "STAT_OK".
        testWaitForSignalUpdate(Bckl_Sw_FP_Stat_ST3, 100);
      }
    }
    else
    {
      $PresfAct_Adj_ST3::Presf_Lvl_ST3 = CYCLE[bProfile].Launch_ID;
      testWaitForSignalChange(PresfAct_Adj_ST3::Presf_Lvl_ST3, 100);
    }
  }
}

/// <Profile_management>
// Check if input profile is present on RBTM_XY_Stat_ST3 status frame.
void ReadBeltProfile(char cProfile[])
{
  stack int index ;
  stack int foundflag = 0;
  char targetName[100];
    
  diagGetCurrentEcu(targetName, elcount(targetName));
  toUpper(cProfile, cProfile, elcount(cProfile));
  for (index = 0; index < elCount(cAllCycles); index++)
  {
    if (strncmp(cProfile, cAllCycles[index], elcount(cProfile)) == 0)
    {
      foundflag = 1;
      if (strncmp(targetName, sTargetECUFrontLeftName, elcount(targetName)) == 0)
      {
        if($RBTM_FL_Stat_ST3::PS_Curve_FL_Stat_ST3.raw == bSignalNotAvailable)
        {         
          testStepFail(iLevelOfDetailFail, "", "Signal not available");
        }
        else 
        {
          if ($RBTM_FL_Stat_ST3::PS_Curve_FL_Stat_ST3.raw == bAllCycleStatusFrame[index])
          {
            testStepPass(iLevelOfDetailPass, "","Cycle %s is detected on status frame left side", cAllCycles[index]);
          }
          else
          {
            testStepFail(iLevelOfDetailFail, "", "Cycle %s is NOT detected on status frame left side. Current profile 0x%.0f", cAllCycles[index], $RBTM_FL_Stat_ST3::PS_Curve_FL_Stat_ST3.phys);
          }
        }
      }
      else
      {
        if($RBTM_FR_Stat_ST3::PS_Curve_FR_Stat_ST3.raw == bSignalNotAvailable)
        {
          testStepFail(iLevelOfDetailFail, "", "Signal not available");
        }
        else
        {
          if ($RBTM_FR_Stat_ST3::PS_Curve_FR_Stat_ST3.raw == bAllCycleStatusFrame[index])
          {
            testStepPass(iLevelOfDetailPass, "", "Cycle %s is detected on status frame right side", cAllCycles[index]);
          }
          else
          {
            testStepFail(iLevelOfDetailFail, "", "Cycle %s is NOT detected on status frame right side", cAllCycles[index]);
          }
        }   
      }
    }
  }
  
  if (foundflag == 0)
  {
    testStepFail(iLevelOfDetailFail, "", "Wrong parameter for ReadBeltProfile function: %s", cProfile);
  }
}

/// <Profile_management>
void ReadBeltProfile(byte bProfile)
{
  stack int index ;
  stack int foundflag = 0;
  char targetName[100];
  
  testWaitForTimeout(15);
  diagGetCurrentEcu(targetName, elcount(targetName));
  if (strncmp(targetName, sTargetECUFrontLeftName, elcount(targetName)) == 0)
  {
    if($RBTM_FL_Stat_ST3::PS_Curve_FL_Stat_ST3.raw == bSignalNotAvailable)
    {         
      testStepFail(iLevelOfDetailFail, "", "Signal not available");
    }
    else 
    {
      if ($RBTM_FL_Stat_ST3::PS_Curve_FL_Stat_ST3.raw == CYCLE[bProfile].SF_ID)
      {
        testStepPass(iLevelOfDetailPass, "","Cycle 0x%02X - %s is detected on status frame left side", CYCLE[bProfile].SF_ID, CYCLE[bProfile].SF_Name);
      }
      else
      {
        testStepFail(iLevelOfDetailFail, "", "Cycle 0x%X - %s is NOT detected on status frame left side. Current profile 0x%.0f - %s", CYCLE[bProfile].SF_ID, CYCLE[bProfile].SF_Name, $RBTM_FL_Stat_ST3::PS_Curve_FL_Stat_ST3.phys, CYCLE[$RBTM_FL_Stat_ST3::PS_Curve_FL_Stat_ST3.phys].SF_Name);
      }
    }
  }
  else
  {
    if($RBTM_FR_Stat_ST3::PS_Curve_FR_Stat_ST3.raw == bSignalNotAvailable)
    {
      testStepFail(iLevelOfDetailFail, "", "Signal not available");
    }
    else
    {
      if ($RBTM_FR_Stat_ST3::PS_Curve_FR_Stat_ST3.raw == CYCLE[bProfile].SF_ID)
      {
        testStepPass(iLevelOfDetailPass, "","Cycle 0x%02X - %s is detected on status frame right side", CYCLE[bProfile].SF_ID, CYCLE[bProfile].SF_Name);
      }
      else
      {
       testStepFail(iLevelOfDetailFail, "", "Cycle 0x%X - %s is NOT detected on status frame right side. Current profile 0x%.0f - %s", CYCLE[bProfile].SF_ID, CYCLE[bProfile].SF_Name, $RBTM_FR_Stat_ST3::PS_Curve_FR_Stat_ST3.phys, CYCLE[$RBTM_FR_Stat_ST3::PS_Curve_FR_Stat_ST3.phys].SF_Name);
      }
    }   
  }
}


/// <Profile_management>
void WaitCycleToFinish()
{
  stack int iCount;
  stack int iFlag;
  stack int fMaxTime = 26000;
  stack int iTotalFlag = 0;
  stack int iTotalFlagTime = 1050;
  stack int index;
  stack byte bAllCyclesFinished = 0;
  stack byte bLastCycle = 0xFF;
  stack char cCurrentCycle[100];
  message * MeasurementFrame;
  stack float fStartTime;
  stack float fCycleStartTime;
  stack float fCurrentTime;
  
  fStartTime = timeNow() / 100; // simulation time in ms.

  if (TestWaitForMessage(@sysvar::ProjectConfiguration::sysMeasurementFrameID, 30) != 1) // Check if MF is active.
  {
    testStepFail(iLevelOfDetailFail, "-", "Measurement Frame not detected in 30 ms.");
    return;
  }
  TestGetWaitEventMsgData(MeasurementFrame);
  if(TestGetWaitEventMsgData(MeasurementFrame) != 0)
  {   
     testStepFail(iLevelOfDetailFail, "-", "Measurement Frame: Data access could not be executed, the last event was not a message event.");
     return;
  }

  if (MeasurementFrame.byte(1) == 14)
  {
    testStepFail(iLevelOfDetailFail, "-", "Detect_Cycle_Step for block 13 / 14 not implemented");
    return;
  }
  else if (MeasurementFrame.byte(1) == 13)
  {
    testStepFail(iLevelOfDetailFail, "-", "Detect_Cycle_Step for block 13 / 14 not implemented");
    return;
  }
  else
  {
    iCount = 0;
    while((MeasurementFrame.byte(0) != 0x01) && (MeasurementFrame.byte(0) != 0x0F) && (MeasurementFrame.byte(0) != 0x18) && (iCount < 20)) // Check if proper MF blocks are active.
    {
      TestWaitForMessage(MeasurementFrame.id, 5);
      TestGetWaitEventMsgData(MeasurementFrame);
      iCount++;
    }
     
    if(iCount >= 20)
    {
      testStepFail(iLevelOfDetailFail, "-", "Incorrect MF active block(s); Measurement Frame block (1 or 15 or 24) not detected in 100 ms");
      return;
    }
    else
    {
      while(bAllCyclesFinished != 1)
      {
        fCycleStartTime = timeNow() / 100; // simulation time in ms.
        iFlag = 0;
        testStep(iLevelOfDetailStep, "", "Waiting for current cycle to finish...");
        
        while((MeasurementFrame.byte(1) != 0xFF) && (iFlag < fMaxTime))
        {          
          if(MeasurementFrame.byte(1) != bLastCycle)
          {
            bLastCycle = MeasurementFrame.byte(1);
            testStep(iLevelOfDetailStep, "", "Current cycle detected is 0x%02x", bLastCycle); 
          }
          
          testWaitForTimeout(5);
          iFlag++;
          
          if (TestWaitForMessage(MeasurementFrame.id, 30) != 1)
          {
            testStepFail(iLevelOfDetailFail, "-", "Measurement Frame not detected in 30 ms.");
            return;
          }
          TestGetWaitEventMsgData(MeasurementFrame);
          
          iCount = 0;
          while((MeasurementFrame.byte(0) != 0x01) && (MeasurementFrame.byte(0) != 0x0F) && (MeasurementFrame.byte(0) != 0x18) && (iCount < 20))
          {
            TestWaitForMessage(MeasurementFrame.id, 5);
            TestGetWaitEventMsgData(MeasurementFrame);
            iCount++;
          }
          
          if(iCount >= 20)
          {
            testStepFail(iLevelOfDetailFail, "-", "Incorrect MF active block(s); Measurement Frame block (1 or 15 or 24) no longer detected.");
            return;
          }  
        }
        
        fCurrentTime = (timeNow() / 100) - fCycleStartTime;
      
        if(iFlag >= fMaxTime) 
        {
         testStepFail(iLevelOfDetailFail, "-", "Cycle 0xFF was not detected in %.f ms (simulation time).", fCurrentTime);
         bAllCyclesFinished = 1;
         return;
        }
        else
        {
          testWaitForTimeout(70);
          if (TestWaitForMessage(MeasurementFrame.id, 30) != 1)
          {
            testStepFail(iLevelOfDetailFail, "-", "Measurement Frame not detected in 30 ms.");
            return;
          }
          TestGetWaitEventMsgData(MeasurementFrame);
          
          iCount = 0;
          while((MeasurementFrame.byte(0) != 0x01) && (MeasurementFrame.byte(0) != 0x0F) && (MeasurementFrame.byte(0) != 0x18) && (iCount < 20))
          {
            TestWaitForMessage(MeasurementFrame.id, 5);
            TestGetWaitEventMsgData(MeasurementFrame);
            iCount++;
          }
          
          if(iCount >= 20)
          {
            testStepFail(iLevelOfDetailFail, "-", "Incorrect MF active block(s); Measurement Frame block (1 or 15 or 24) no longer detected.");
            return;
          }

          if(MeasurementFrame.byte(1) != 0xFF)
          {
            bAllCyclesFinished = 0;
            testStep(iLevelOfDetailStep, "", "Cycle %x started within 100 ms after cycle %x ended.", MeasurementFrame.byte(1), bLastCycle);
          }
          else
          {
            fCurrentTime = (timeNow() / 100) - fStartTime;
            testStep(iLevelOfDetailStep, "", "All cycles finished in %.f ms (simulation time)", fCurrentTime - 70);
            bAllCyclesFinished = 1;
          }

          iTotalFlag++;
          if(iTotalFlag >= iTotalFlagTime)
          {
            fCurrentTime = (timeNow() / 100) - fStartTime;
            testStepFail(iLevelOfDetailFail, "-", "Cycle 0xFF was not detected in %.f ms", fCurrentTime);
            return;
          }
        }
      }
    }
  }
}

/// <Profile_management>
// Check the current started profile on Measurement Frame.
// "cInputCycle" = cycle that is checked.
//               Input option 1: "Precrash_2".
//               Input option 2: "0x02".
// Example:      CheckStartedProfile("BSR").
// Output:       Test Step Fail/Pass if cycle is not active/active on MF.
void CheckStartedProfile(char cInputCycle[])
{
  char cInputCycle_UpperCase[20];
  char EvalManStepString[100];
  int index;
  int iCount;
  byte bCycle;
  float fStartTime;
  message * MeasurementFrame;
  
  bCycle = 0xAA;
  fStartTime = timeNow() / 100;
  
  toUpper(cInputCycle_UpperCase, cInputCycle, elcount(cInputCycle_UpperCase));
  
  for(index = 0; index < elcount(bAllCycleMeasurement); index++) // Get cycle ID for "cInputCycle" input.
  {
    if(strncmp(cAllCycles[index], cInputCycle_UpperCase, elcount(cInputCycle_UpperCase)) == 0)
    {
      bCycle = bAllCycleMeasurement[index]; 
    }
  }
  
  if(bCycle == 0xAA) // Check proper format for "cInputCycle" input.
  {
     if((strncmp(cInputCycle, "0x", 2) == 0) && (elcount(cInputCycle) <= 5) && (str_match_regex(cInputCycle, "0x[A-Fa-f0-9]{2}") == 1))
      {
        bCycle = atodbl(cInputCycle);
      }
      else
      {
        testStepFail(iLevelOfDetailFail, "-", "Incorrect Cycle input; Please check Cycle input for CheckStartedProfile function.");
        return;
      }
  }
  
   testWaitForTimeout(15);
   if (TestWaitForMessage(@sysvar::ProjectConfiguration::sysMeasurementFrameID, 30) == 1) // Check if MF is active.
  {
    if(TestGetWaitEventMsgData(MeasurementFrame) == 0)
    {   
      iCount = 0;
      while((MeasurementFrame.byte(0) != 0x01) && (MeasurementFrame.byte(0) != 0x0F) && (MeasurementFrame.byte(0) != 0x18) && (iCount < 20)) // Check if proper MF blocks are active.
      {
        TestWaitForMessage(MeasurementFrame.id, 5);
        TestGetWaitEventMsgData(MeasurementFrame);
        iCount++;
      }
    }
    else
    {
      testStepFail(iLevelOfDetailFail, "-", "Measurement Frame: Data access could not be executed, the last event was not a message event.");
      return;
    }
  }
  else 
  {
    testStepFail(iLevelOfDetailFail, "-", "Measurement Frame not detected in 30 ms.");
    return;
  }

  if(iCount >= 20)
  {
    testStepFail(iLevelOfDetailFail, "-", "Incorrect MF active block(s); Measurement Frame block (1 or 15 or 24) not detected in %f ms", (timeNow() / 100) - fStartTime);
    return;
  }
  else
  {
    snprintf(EvalManStepString, elCount(EvalManStepString), "Verify that Belt Profile %s is active on measurement frame", cInputCycle_UpperCase);
    EvalManStepEqual(EvalManStepString, MeasurementFrame.byte(1), bCycle);
  }  
}

/// <Profile_management>
void CheckStartedProfile(byte bProfile)
{
  char cInputCycle_UpperCase[20];
  char EvalManStepString[100];
  int index;
  int iCount;
  byte bCycle;
  float fStartTime;
  message * MeasurementFrame;
  
  bCycle = 0xAA;
  fStartTime = timeNow() / 100;

   if (TestWaitForMessage(@sysvar::ProjectConfiguration::sysMeasurementFrameID, 30) == 1) // Check if MF is active.
  {
    if(TestGetWaitEventMsgData(MeasurementFrame) == 0)
    {   
      iCount = 0;
      while((MeasurementFrame.byte(0) != 0x01) && (MeasurementFrame.byte(0) != 0x0F) && (MeasurementFrame.byte(0) != 0x18) && (iCount < 20)) // Check if proper MF blocks are active.
      {
        TestWaitForMessage(MeasurementFrame.id, 5);
        TestGetWaitEventMsgData(MeasurementFrame);
        iCount++;
      }
    }
    else
    {
      testStepFail(iLevelOfDetailFail, "-", "Measurement Frame: Data access could not be executed, the last event was not a message event.");
      return;
    }
  }
  else 
  {
    testStepFail(iLevelOfDetailFail, "-", "Measurement Frame not detected in 30 ms.");
    return;
  }

  if(iCount >= 20)
  {
    testStepFail(iLevelOfDetailFail, "-", "Incorrect MF active block(s); Measurement Frame block (1 or 15 or 24) not detected in %f ms", (timeNow() / 100) - fStartTime);
    return;
  }
  else
  {
    snprintf(EvalManStepString, elCount(EvalManStepString), "Verify that Belt Profile %s is active on measurement frame", CYCLE[bProfile].Launch_Name);
    EvalManStepEqual(EvalManStepString, MeasurementFrame.byte(1), CYCLE[bProfile].MF_ID);
  }  
}

/// <Profile_management>
//Lauch tensioning profile via diagnostic request using routine control service
//void LaunchDiagBeltProfile(char sProfile[])
//{
//  int iIndex;
//  
//  iIndex = 0;
//  
//  toUpper(sProfile, sProfile, elcount(sProfile));
//  
//  GetSecurityAccess("supplier");
//  
//  for(iIndex = 0; iIndex < elcount(cAllCycles); iIndex++)
//  {   
//    if(strncmp(sProfile, "NO_ACTION", elcount(sProfile)) == 0)
//    {
//      SendDiagnosticRequest(dStopALVCycleRequest, dStopALVCycleResponse);
//        
//      CheckPositiveResponse("Profile is stopped", dStopALVCycleRequest, dStopALVCycleResponse);
//      break;
//    }
//    else
//    {
//     if (strncmp(sProfile, cAllCycles[iIndex], elcount(sProfile)) == 0)
//      {
//        DiagSetPrimitiveByte(dStartALVCycleRequest, 4, bAllCycleMeasurement[iIndex]);
//        
//        SendDiagnosticRequest(dStartALVCycleRequest, dStartALVCycleResponse);
//        
//        CheckPositiveResponse("Profile is started", dStartALVCycleRequest, dStartALVCycleResponse);
//      }
//    }
//  }
//}

/// <Profile_management>
// Function that writes cycles.
// "cComment" = Cycle description (char).
// "bCycle"   = Byte array that contains cycle write request (0x2E or 0x3D) and parameters.
// Example:   WriteCycleParameters("Tens level 0", bDefaultCycle[0]);
//void WriteCycleParameters(char cComment[], byte bCycle[])
//{
//  char EvalResponseString[100]; 
//  diagRequest * dWriteCycleRequest;
//  diagResponse * dWriteCycleResponse;
//  
//  SetECUMode("unlock");
//  
//  diagResize(dWriteCycleRequest, elCount(bCycle));
//  dWriteCycleRequest.SetPrimitiveData(bCycle, elcount(bCycle));
//  
//  SendDiagnosticRequest(dWriteCycleRequest, dWriteCycleResponse);
//  
//  if(dWriteCycleResponse.GetPrimitiveByte(0) != 0x6E && dWriteCycleResponse.GetPrimitiveByte(1) != 0x7D)
//  {
//    snprintf(EvalResponseString, elCount(EvalResponseString), "%s cycle was not written. Response: %X", cComment, dWriteCycleResponse.GetPrimitiveByte(0));
//  }
//  
//  if(dWriteCycleRequest.GetPrimitiveByte(0) == 0x2E)
//  {
//    snprintf(EvalResponseString, elCount(EvalResponseString), "Write %s cycle with WDBI (0x2E) service. Response: %X", cComment, dWriteCycleResponse.GetPrimitiveByte(0));
//  }
//  if (dWriteCycleRequest.GetPrimitiveByte(0) == 0x3D)
//  {
//    snprintf(EvalResponseString, elCount(EvalResponseString), "Write %s cycle with WMBA (0x3D) service. Response: %X %X", cComment, dWriteCycleResponse.GetPrimitiveByte(0), dWriteCycleResponse.GetPrimitiveByte(1));
//  }
//
//  CheckPositiveResponse(EvalResponseString, dWriteCycleRequest, dWriteCycleResponse);
//  
//  SetECUMode("lock");
//  
//  ResetECU("soft");
//  
//  testWaitForTimeout(_iCriticalAutotestExecutionTime + 5000);
//  
//  EnterDiagnosticSession("default");
//}

/// <Profile_management>
// "cCycle"             = Defines the cycle that needs to be modified (char array).
// "sStepConfiguration" = Defines the steps configuration (char array).
// "bNewCycle"          = 48 byte array where the result is saved.
// Returns either:      1. bNewCycle modified according to input options.
//                      2. Test step fail if input is incorrect and bNewCycle will remain with the default values.
// Input formatting:    - For a default step, the new input values/options will be added to the step definition, with the rest of the options remaining as default.
//                      - For a new step, only the input values/options will be part of the step definition, with the rest of the values/options beeing disabled/set to 0.
//                      - "DefaultStepN" indicates that the rest of the steps should be the default ones.
//                      - Every step option can be configured except for "Constraint value".
// Example:             CycleConfiguration("Precrash_2","NewStep0:1000ms,3A,A;DefaultStep2:4000ms;DefaultStepN", bNewCycle);
//                      "NewStep0:1000ms,3A,A" - Step 0 of "precrash_2" cycle will be defined as: 1000ms, ramp to 3A in tensioning direction.
//                                             - Because the step is new, all other options will be disabled, including "Constraint value".
//                      "DefaultStep2:4000ms"  - Step 2 of "precrash_2" cycle will be defined as: 4000ms.
//                                             - Because the step is default, the rest of options/values are set to default.
//                      "DefaultStepN"         - Remaining steps are configured with default values.
//void CycleConfiguration(char cCycle[], char sStepConfiguration[], byte bNewCycle[])
//{
//  byte bTime[4];
//  byte bOrderValueAndOptions[4];
//  byte bCopyOfBNewCycle[48];
//  byte bCycle;
//  byte bDID_LB[8] = {0x23, 0x24, 0x00, 0x00, 0x00, 0x00, 0x00 , 0x0C}; // RMBA request.
//  byte ReadCycleRequest_PositiveR[13];
//  int index;
//  int iNewStepPosition;
//  int iDefaultStepPosition;
//  int iNextStepPosition; 
//  int iStepsSize;
//  int iSizeOfStepConfiguration;
//  int iMNOStep;
//  int iCorrectInput;
//  char ctmpStep[70];
//  char cCopyOftmpStep[70];
//  char cResultMessage[200];
//  char cCycle_UpperCase[20];
//  char cCopyOfStepConfiguration[1000];
//  char cNewSteps[240];
//  
//  
//  //------------
//  iSizeOfStepConfiguration = elcount(sStepConfiguration);
//  toUpper(sStepConfiguration, sStepConfiguration, elcount(sStepConfiguration));
//  strncpy(cCopyOfStepConfiguration, sStepConfiguration, elcount(sStepConfiguration)); // Copy of input 'sStepConfiguration'
//
//  iCorrectInput = 1;
//  strncpy(cNewSteps, "", 1);
//  strncpy(ctmpStep, "", 1);
//  strncpy(cResultMessage, "", 1);
//  strncpy(cCopyOftmpStep, "", 1);
//  iNewStepPosition = iDefaultStepPosition = iNextStepPosition = -1;
//  bCycle = 0xAA;
//  for(index = 0; index < 48; index++)
//  {
//    bNewCycle[index] = 0xFF;
//  }
//  //------------
//  toUpper(cCycle_UpperCase, cCycle, elcount(cCycle_UpperCase));
//
//  for(index = 0; index < elcount(bAllCycleMeasurement); index++) // Get cycle ID for "cCycle" input.
//  {
//    if(strncmp(cAllCycles[index], cCycle_UpperCase, elcount(cCycle_UpperCase)) == 0)
//    {
//      bCycle = bAllCycleMeasurement[index];      
//    }
//  }
//  
//  switch(bCycle)
//  {
//    case(0x00): // PRECRASH_0
//    {
//      memcpy_off(bDID_LB, 2, NVP_BLOCK_ID_CYCLE_0, 0, 4);
//      iStepsSize = elcount(_cDefaultTensioningCycle1);
//      memcpy(bNewCycle, _cDefaultTensioningCycle1, iStepsSize);
//      break;
//    }
//    case(0x01): // PRECRASH_1
//    {
//      memcpy_off(bDID_LB, 2, NVP_BLOCK_ID_CYCLE_1, 0, 4);
//      iStepsSize = elcount(_cDefaultTensioningCycle2);
//      memcpy(bNewCycle, _cDefaultTensioningCycle2, iStepsSize);
//      break;
//    }
//    case(0x02): // PRECRASH_2
//    {
//      memcpy_off(bDID_LB, 2, NVP_BLOCK_ID_CYCLE_2, 0, 4);
//	    iStepsSize = elcount(_cDefaultTensioningCycle3);
//      memcpy(bNewCycle, _cDefaultTensioningCycle3, iStepsSize);
//      break;
//    }
//    case(0x03): // PRECRASH_3
//    {
//      memcpy_off(bDID_LB, 2, NVP_BLOCK_ID_CYCLE_3, 0, 4);
//	    iStepsSize = elcount(_cDefaultTensioningCycle4);
//      memcpy(bNewCycle, _cDefaultTensioningCycle4, iStepsSize); 
//      break;
//    }
//    case(0x04): // PRECRASH_4
//    {
//      memcpy_off(bDID_LB, 2, NVP_BLOCK_ID_CYCLE_4, 0, 4);
//	    iStepsSize = elcount(_cDefaultTensioningCycle5);
//      memcpy(bNewCycle, _cDefaultTensioningCycle5, iStepsSize); 
//      break;
//    }
//    case(0x05): // PRECRASH_5
//    {
//      memcpy_off(bDID_LB, 2, NVP_BLOCK_ID_CYCLE_5, 0, 4);
//	    iStepsSize = elcount(_cDefaultTensioningCycle6);
//      memcpy(bNewCycle, _cDefaultTensioningCycle6, iStepsSize); 
//      break;
//    }
//    case(0x06): // PRECRASH_6
//    {
//      memcpy_off(bDID_LB, 2, NVP_BLOCK_ID_CYCLE_6, 0, 4);
//	    iStepsSize = elcount(_cDefaultTensioningCycle7);
//      memcpy(bNewCycle, _cDefaultTensioningCycle7, iStepsSize); 
//      break;
//    }
//    case(0x07):  // PRECRASH_7
//    {
//      memcpy_off(bDID_LB, 2, NVP_BLOCK_ID_CYCLE_7, 0, 4);
//	    iStepsSize = elcount(_cDefaultTensioningCycle8);
//      memcpy(bNewCycle, _cDefaultTensioningCycle8, iStepsSize); 
//      break;
//    }
//    case(0x08):  // PRECRASH_8
//    {
//      memcpy_off(bDID_LB, 2, NVP_BLOCK_ID_CYCLE_8, 0, 4);
//	    iStepsSize = elcount(_cDefaultTensioningCycle9);
//      memcpy(bNewCycle, _cDefaultTensioningCycle9, iStepsSize); 
//      break;
//    }
//    case(0x09):  // PRECRASH_9
//    {
//      memcpy_off(bDID_LB, 2, NVP_BLOCK_ID_CYCLE_9, 0, 4);
//	    iStepsSize = elcount(_cDefaultTensioningCycle10);
//      memcpy(bNewCycle, _cDefaultTensioningCycle10, iStepsSize); 
//      break;
//    }
//    case(0x0A):  // PRECRASH_10
//    {
//      memcpy_off(bDID_LB, 2, NVP_BLOCK_ID_CYCLE_10, 0, 4);
//	    iStepsSize = elcount(_cDefaultTensioningCycle11);
//      memcpy(bNewCycle, _cDefaultTensioningCycle11, iStepsSize);
//      break;
//    }
//    case(0x0B):  // PRECRASH_11
//    {
//      memcpy_off(bDID_LB, 2, NVP_BLOCK_ID_CYCLE_11, 0, 4);
//	    iStepsSize = elcount(_cDefaultTensioningCycle12);
//      memcpy(bNewCycle, _cDefaultTensioningCycle12, iStepsSize);
//      break;
//    }
//    case(0x0C): // PRECRASH_12
//    {
//      memcpy_off(bDID_LB, 2, NVP_BLOCK_ID_CYCLE_12, 0, 4);
//	    iStepsSize = elcount(_cDefaultTensioningCycle13);
//      memcpy(bNewCycle, _cDefaultTensioningCycle13, iStepsSize);
//      break;
//    }
//    case(0x0D):  // PRECRASH_13
//    {
//      memcpy_off(bDID_LB, 2, NVP_BLOCK_ID_CYCLE_13, 0, 4);
//	    iStepsSize = elcount(_cDefaultTensioningCycle14);
//      memcpy(bNewCycle, _cDefaultTensioningCycle14, iStepsSize);
//      break;
//    }
//    case(0x0E):  // PRECRASH_14
//    {
//      memcpy_off(bDID_LB, 2, NVP_BLOCK_ID_CYCLE_14, 0, 4);
//	    iStepsSize = elcount(_cDefaultTensioningCycle15);
//      memcpy(bNewCycle, _cDefaultTensioningCycle15, iStepsSize);
//      break;
//    }
//    case(0x0F):  // PRECRASH_15
//    {
//      memcpy_off(bDID_LB, 2, NVP_BLOCK_ID_CYCLE_15, 0, 4);
//	    iStepsSize = elcount(_cDefaultTensioningCycle16);
//      memcpy(bNewCycle, _cDefaultTensioningCycle16, iStepsSize);
//      break;
//    }
//    case(0x10):  // PRECRASH_16
//    {
//      memcpy_off(bDID_LB, 2, NVP_BLOCK_ID_CYCLE_16, 0, 4);
//	    iStepsSize = elcount(_cDefaultTensioningCycle17);
//      memcpy(bNewCycle, _cDefaultTensioningCycle17, iStepsSize);
//      break;
//    }
//    case(0x11):  // PRECRASH_17
//    {
//      memcpy_off(bDID_LB, 2, NVP_BLOCK_ID_CYCLE_17, 0, 4);
//	    iStepsSize = elcount(_cDefaultTensioningCycle18);
//      memcpy(bNewCycle, _cDefaultTensioningCycle18, iStepsSize);
//      break;
//    }
//    case(0x12):  // PRECRASH_18
//    {
//      memcpy_off(bDID_LB, 2, NVP_BLOCK_ID_CYCLE_18, 0, 4);
//	    iStepsSize = elcount(_cDefaultTensioningCycle19);
//      memcpy(bNewCycle, _cDefaultTensioningCycle19, iStepsSize);
//      break;
//    }
//    case(0x18): // BSR
//    {   
//      memcpy_off(bDID_LB, 2, NVP_BLOCK_ID_CYCLE_24, 0, 4);
//	    iStepsSize = elcount(_cDefaultBSR);
//      memcpy(bNewCycle, _cDefaultBSR, iStepsSize);
//      break;
//    }
//    case(0x1D): // Haptic_Warning_0
//    {
//      memcpy_off(bDID_LB, 2, NVP_BLOCK_ID_CYCLE_29, 0, 4);
//	    iStepsSize = elcount(_cDefaultHapticWarningCycle0);
//      memcpy(bNewCycle, _cDefaultHapticWarningCycle0, iStepsSize);
//      break;
//    }
//    case(0x1E): // Haptic_Warning_1 
//    {
//      memcpy_off(bDID_LB, 2, NVP_BLOCK_ID_CYCLE_30, 0, 4);
//	    iStepsSize = elcount(_cDefaultHapticWarningCycle1);
//      memcpy(bNewCycle, _cDefaultHapticWarningCycle1, iStepsSize);
//      break;
//    }
//    case(0x21): // SOFT_RELEASE
//    {
//      memcpy_off(bDID_LB, 2, NVP_BLOCK_ID_CYCLE_33, 0, 4);
//	    iStepsSize = elcount(_cDefaultSoftRelease);
//      memcpy(bNewCycle, _cDefaultSoftRelease, iStepsSize);
//      break;
//    }
//    case(0x20): // HARD_RELEASE
//    {
//      memcpy_off(bDID_LB, 2, NVP_BLOCK_ID_CYCLE_32, 0, 4);
//	    iStepsSize = elcount(_cDefaultHardRelease);
//      memcpy(bNewCycle, _cDefaultHardRelease, iStepsSize);      
//      break;
//    }
//    case(0x22): // BACKUP_SOFT_RELEASE
//    {
//      memcpy_off(bDID_LB, 2, NVP_BLOCK_ID_CYCLE_34, 0, 4);
//	    iStepsSize = elcount(_cDefaultBackUpRelease);
//      memcpy(bNewCycle, _cDefaultBackUpRelease, iStepsSize); 
//      break;
//    }
//    case(0x1C): // BPDC
//    {
//      memcpy_off(bDID_LB, 2, NVP_BLOCK_ID_CYCLE_28, 0, 4);
//	    iStepsSize = elcount(_cDefaultBPDC);
//      memcpy(bNewCycle, _cDefaultBPDC, iStepsSize); 
//      break;
//    }
//    case(0x1B): // BPDO
//    {
//      memcpy_off(bDID_LB, 2, NVP_BLOCK_ID_CYCLE_27, 0, 4);
//	    iStepsSize = elcount(_cDefaultBPDO);
//      memcpy(bNewCycle, _cDefaultBPDO, iStepsSize); 
//      break;
//    }
//    case(0x24): // AEE_PROCESS
//    {
//      memcpy_off(bDID_LB, 2, NVP_BLOCK_ID_CYCLE_36, 0, 4);
//	    iStepsSize = elcount(_cDefaultProdAEECycle);
//      memcpy(bNewCycle, _cDefaultProdAEECycle, iStepsSize); 
//      break;
//    }
//    case(0x23): // ANG_PROCESS
//    {
//      memcpy_off(bDID_LB, 2, NVP_BLOCK_ID_CYCLE_35, 0, 4);
//	    iStepsSize = elcount(_cDefaultProdANGCycle);
//      memcpy(bNewCycle, _cDefaultProdANGCycle, iStepsSize); 
//      break;
//    }
//    case(0x1F): // STARTUP
//    {
//      memcpy_off(bDID_LB, 2, NVP_BLOCK_ID_CYCLE_31, 0, 4);
//	    iStepsSize = elcount(_cDefaultStartUpCycle);
//      memcpy(bNewCycle, _cDefaultStartUpCycle, iStepsSize);
//      break;
//    }
//    case(0x19): // OPS
//    {
//      memcpy_off(bDID_LB, 2, NVP_BLOCK_ID_CYCLE_26, 0, 4);
//	    iStepsSize = elcount(_cDefaultOPS);
//      memcpy(bNewCycle, _cDefaultOPS, iStepsSize);
//      break;
//    }
//    default:
//    {     
//      iStepsSize = 0;
//      break; 
//    }
//  }
//  
//  memcpy(bCopyOfBNewCycle, bNewCycle, 48);
//  
//  if (iStepsSize == 0)
//  {
//    iCorrectInput = 0;
//    strncpy(cResultMessage, "Wrong belt profile parameter value (CycleConfiguration function)", elcount(cResultMessage));
//  }
//  else
//  {
//    EnterDiagnosticSession("supplier");
//    dReadMemoryByAddressRequest.SetPrimitiveData(bDID_LB, elcount(bDID_LB));
//    SendDiagnosticRequest(dReadMemoryByAddressRequest, dReadMemoryByAddressResponse);
//    
//    if (CheckPositiveResponse(dReadMemoryByAddressRequest, dReadMemoryByAddressResponse) == 1)
//    {
//      dReadMemoryByAddressResponse.GetPrimitiveData(ReadCycleRequest_PositiveR, elcount(ReadCycleRequest_PositiveR));
//      iMNOStep = 0;
//      for(index = 5; index < elcount(ReadCycleRequest_PositiveR); index++)
//      {
//        if(ReadCycleRequest_PositiveR[index] != 0xFF)
//        {
//            iMNOStep++;
//        }
//      }
//      if(iStepsSize / 6 == iMNOStep)
//      {
//       if(CheckStepParameterValidity(iMNOStep, sStepConfiguration))
//        {
//          strncpy(sStepConfiguration, cCopyOfStepConfiguration, iSizeOfStepConfiguration); // Re-initialize 'sStepConfiguration' with initial input.       
//          str_replace(sStepConfiguration, " ", "");
//          str_replace(sStepConfiguration, ";", "");
//          
//          
//          while (iNextStepPosition < iSizeOfStepConfiguration)
//          {
//            iNewStepPosition = strstr_off(sStepConfiguration, 3, "NEW");
//            iDefaultStepPosition = strstr_off(sStepConfiguration, 3, "DEFAULT");
//            
//            if(iNewStepPosition == -1 || iDefaultStepPosition == -1)
//            {
//              if(iNewStepPosition == -1 && iDefaultStepPosition == -1)
//              {
//                iNextStepPosition =  iSizeOfStepConfiguration;            
//              }
//              else
//              {
//                iNextStepPosition =  iNewStepPosition > iDefaultStepPosition ? iNewStepPosition : iDefaultStepPosition;
//              }
//            }
//            else 
//            {
//              iNextStepPosition =  iNewStepPosition < iDefaultStepPosition ? iNewStepPosition : iDefaultStepPosition;
//            }
//            
//            if(iNextStepPosition != iSizeOfStepConfiguration)
//            {
//              substr_cpy(ctmpStep, sStepConfiguration, 0, iNextStepPosition, elcount(ctmpStep));
//              substr_cpy(sStepConfiguration, sStepConfiguration, iNextStepPosition, -1, elcount(sStepConfiguration)); 
//            }
//            else
//            {
//              substr_cpy(ctmpStep, sStepConfiguration, 0, -1, elcount(ctmpStep));    
//            }
//
//            strncpy(cCopyOftmpStep, ctmpStep, elcount(cCopyOftmpStep));
//            ExtractTime(ctmpStep, bTime); // bTime[2] == 0 then step time is invalid. bTime[2] == 1 then step time is valid. bTime[2] == 2 then step time is Default. 
//
//            if(bTime[2] != 0) // If Step time is not invalid.
//            {
//              if(bTime[3] != 0x0F) // If step number is not default.
//              {
//                if(bTime[2] == 1) // If step time is valid.
//                {
//                  bNewCycle[bTime[3] * 6] = bTime[0];
//                  bNewCycle[bTime[3] * 6 + 1] = bTime[1];
//                }
//                else
//                {
//                  iCorrectInput = 0;
//                  strncpy(cResultMessage, "Incorrect step duration value! (CycleConfiguration function)", elcount(cResultMessage));
//                }
//               
//                strncpy(ctmpStep, cCopyOftmpStep, elcount(ctmpStep)); // Re-initialize step data.
//                bOrderValueAndOptions[0] = bNewCycle[bTime[3] * 6 + 2]; // Order Value.
//                bOrderValueAndOptions[1] = bNewCycle[bTime[3] * 6 + 3]; // Order Type.
//                bOrderValueAndOptions[2] = bNewCycle[bTime[3] * 6 + 4]; // Constraint Value.
//                bOrderValueAndOptions[3] = bNewCycle[bTime[3] * 6 + 5]; // Constraint type.
//                
//                if(ExtractOrderValueAndOptions(ctmpStep, bOrderValueAndOptions) == 0)
//                {
//                  iCorrectInput = 0;
//                  strncpy(cResultMessage, "Incorrect steps parameters! (CycleConfiguration function)", elcount(cResultMessage));
//                }
//                else
//                {
//                  bNewCycle[bTime[3] * 6 + 2] = bOrderValueAndOptions[0]; // Order Value.
//                  bNewCycle[bTime[3] * 6 + 3] = bOrderValueAndOptions[1]; // Order Options.
//                  bNewCycle[bTime[3] * 6 + 4] = bOrderValueAndOptions[2]; // Constraint Value.
//                  bNewCycle[bTime[3] * 6 + 5] = bOrderValueAndOptions[3]; // Constraint type.
//                }
//              }           
//            }
//            else
//            {
//              iCorrectInput = 0;
//              strncpy(cResultMessage, "Incorrect steps parameters! (CycleConfiguration function)", elcount(cResultMessage));
//            }
//          }
//        }
//        else
//        {
//          iCorrectInput = 0;
//          strncpy(cResultMessage, "Incorrect steps parameters! (CycleConfiguration function)", elcount(cResultMessage));
//        }
//      }
//      else
//      {
//        iCorrectInput = 0;
//        strncpy(cResultMessage, "Incorrect cycle configuration parameters - cycle has more steps in memory, update default cycle with the same steps number! (CycleConfiguration function)", elcount(cResultMessage));
//      } 
//    }
//    else 
//    {
//      iCorrectInput = 0;
//      strncpy(cResultMessage, "NRC received while Reading Cycle configuration (CycleConfiguration function)", elcount(cResultMessage));
//    } 
//  }
//  
//  if(iCorrectInput == 0)
//  {   
//    testStepFail(iLevelOfDetailFail, "", "Cycle steps were NOT modified: %s ", cResultMessage);
//    memcpy(bNewCycle, bCopyOfBNewCycle, 48); // Copy default cycle to output if input is incorrect. 
//  }
//  else
//  {
//    ConvertByteArrInCharArr(bNewCycle, cNewSteps, 0, elcount(bNewCycle) - 1, "true");
//    testStep(iLevelOfDetailStep,"", "New %s Cycle:%s", cCycle_UpperCase, cNewSteps);
//  }
//}

/// <Profile_management>
// Writes the default step parameters.
void WriteStepParameters()
{ 
  memcpy(bDefaultStepsRequest, bDefaultStepsLibraryRequest, elcount(bDefaultStepsLibraryRequest));
  memcpy_off(bDefaultStepsRequest, 3, bDefaultStepsLibrary, 0, elcount(bDefaultStepsLibrary));
  SendDiagnosticRequest(dWriteStepsConfigRequest, dWriteStepsConfigResponse, bDefaultStepsRequest);
  CheckPositiveResponse("Check positive response for writing steps 0 to 119.", dWriteStepsConfigRequest, dWriteStepsConfigResponse);
}

/// <Profile_management>
// Overload of WriteStepParameters: Can configure two cycles at once.
// Writes the input step parameters.
// "cCycle" = cycle name; array of chars.
// "bSteps" = steps that will be written; array of bytes.
// Example: bInputSteps = {0x05, 0xDC, 0x01, 0x02, 0x64, 0x00, 0x00, 0x0A, 0x00, 0x80, 0x00, 0x00}.  
//          WriteStepParameters("BSR", bSteps);
//void WriteStepParameters(char cCycle[], byte bSteps[])
//{
//  ModifySteps(cCycle, bSteps, "Initialize Steps");
//  if(ModifySteps(cCycle, bSteps, "Configure") == 0) // if step fails.
//  {
//    // do nothing.
//  }
//  else 
//  {
//   ModifySteps(cCycle, bSteps, "Write");
//  }
//}

/// <Profile_management>
// Overload of WriteStepParameters(): Can configure two cycles at once.
//void WriteStepParameters(char cCycle[], byte bSteps[], char cCycle_1[], byte bSteps_1[])
//{
//  ModifySteps(cCycle, bSteps, "Initialize Steps");
//  if(ModifySteps(cCycle, bSteps, "Configure") == 0)
//  {
//    
//  }
//  else if(ModifySteps(cCycle_1, bSteps_1, "Configure") == 0)
//  {
//    
//  }
//  else
//  {
//    ModifySteps(cCycle, bSteps, "Write Steps Parameters");
//  }
//}

/// <Profile_management>
// Overload of WriteStepParameters(): Can configure three cycles at once.
//void WriteStepParameters(char cCycle[], byte bSteps[], char cCycle_1[], byte bSteps_1[], char cCycle_2[], byte bSteps_2[])
//{
//  ModifySteps(cCycle, bSteps, "Initialize Steps");
//  if(ModifySteps(cCycle, bSteps, "Configure") == 0)
//  {
//    
//  }
//  else if(ModifySteps(cCycle_1, bSteps_1, "Configure") == 0)
//  {
//    
//  }
//  else if(ModifySteps(cCycle_2, bSteps_2, "Configure") == 0)
//  {
//    
//  }
//  else
//  {
//    ModifySteps(cCycle, bSteps, "Write Steps Parameters");
//  }
//}

/// <Profile_management>
// Function that reads the Cycle Counters.
// "cCounter" = the cycle that you want to read.
// Usage Example:
// ReadCycleCounter("NGU");
// ReadCycleCounter("PRECRASH");
// ReadCycleCounter("COMFORT");
// ReadCycleCounter("HAPTIC");
//int ReadCycleCounter(char cCounter[])
//{
//  byte bReadCounterPosResp[23];
//  char cAllCycleCounters[120];
//  dword lCounter;
//  
//  lCounter = -1;
//  toUpper(cCounter, cCounter, elcount(cCounter));
//  
//  EnterDiagnosticSession("supplier");
//  
//  SendDiagnosticRequest(dReadCountersRequest, dReadCountersResponse);
//  if(CheckPositiveResponse(dReadCountersRequest, dReadCountersResponse) == 1)
//  {
//    dReadCountersResponse.GetPrimitiveData(bReadCounterPosResp, elcount(bReadCounterPosResp));
//    if(strncmp(cCounter, "NGU", elcount(cCounter)) == 0)
//    {
//      lCounter = (bReadCounterPosResp[3] << 24) + (bReadCounterPosResp[4] << 16) + (bReadCounterPosResp[5] << 8) + bReadCounterPosResp[6];
//      testStep(iLevelOfDetailStep, "", "NGU activation Counter=  %ld", lCounter);
//    }
//    else if(strncmp(cCounter, "PRECRASH", elcount(cCounter)) == 0)
//    {
//      lCounter = (bReadCounterPosResp[7] << 24) + (bReadCounterPosResp[8] << 16) + (bReadCounterPosResp[9] << 8) + bReadCounterPosResp[10];
//      testStep(iLevelOfDetailStep, "", "PRECRASH activation Counter=  %ld", lCounter);
//    }
//    else if(strncmp(cCounter, "COMFORT", elcount(cCounter)) == 0)
//    {
//      lCounter = (bReadCounterPosResp[11] << 24) + (bReadCounterPosResp[12] << 16) + (bReadCounterPosResp[13] << 8) + bReadCounterPosResp[14];
//      testStep(iLevelOfDetailStep, "", "COMFORT activation Counter=  %ld", lCounter);
//    }
//    else if(strncmp(cCounter, "HAPTIC", elcount(cCounter)) == 0)
//    {
//      lCounter = (bReadCounterPosResp[15] << 24) + (bReadCounterPosResp[16] << 16) + (bReadCounterPosResp[17] << 8) + bReadCounterPosResp[18];
//      testStep(iLevelOfDetailStep, "", "HAPTIC activation Counter=  %ld", lCounter);
//    }
//    else
//    {
//      testStepFail(iLevelOfDetailFail, "", "Incorrect parameter (ReadCycleCounter function).");
//      return -1;
//    }
//    ConvertByteArrInCharArr(bReadCounterPosResp, cAllCycleCounters, 0, elcount(bReadCounterPosResp) - 1, "true");
//    testStep(iLevelOfDetailStep, "", "Response to Read Belt Activation Counters: %s", cAllCycleCounters);
//  }
//  else
//  {
//    testStepFail(iLevelOfDetailFail, "", "Read Cycle counters negative reponse (ReadCycleCounter function).");
//  }
//  return lCounter;
//}

/// <Profile_management>
// Function that reads the Cycle Counters.
// bCounter = the cycle that you want to read.
// Usage Example:
// ReadCycleCounter(Low);
// ReadCycleCounter(High);
// ReadCycleCounter(Comfort);
int ReadCycleCounter(byte bCounter)
{
  byte bReadCounterPosResp[23];
  char cAllCycleCounters[120];
  dword lCounter;
  
  lCounter = -1;
  
  EnterDiagnosticSession("development");
  
  if(bCounter == High)
  {
    SendDiagnosticRequest(dReadPreSafeCountersRequest, dReadPreSafeCountersResponse);
    CheckPositiveResponse("Check positive response of read PRE-SAFE counters diagnostic service.", dReadPreSafeCountersRequest, dReadPreSafeCountersResponse);
    testReportWriteDiagObject(dReadPreSafeCountersResponse);  
    lCounter = (dReadPreSafeCountersResponse.GetPrimitiveByte(8) << 8) +  dReadPreSafeCountersResponse.GetPrimitiveByte(7);
    testStep(iLevelOfDetailStep, "", "High activation Counter=  %ld", lCounter);
  }
  else 
    if(bCounter == Low)
    {
      SendDiagnosticRequest(dReadPreSafeCountersRequest, dReadPreSafeCountersResponse);
      CheckPositiveResponse("Check positive response of read PRE-SAFE counters diagnostic service.", dReadPreSafeCountersRequest, dReadPreSafeCountersResponse);
      testReportWriteDiagObject(dReadPreSafeCountersResponse);
      
      lCounter = (dReadPreSafeCountersResponse.GetPrimitiveByte(6) << 8) +  dReadPreSafeCountersResponse.GetPrimitiveByte(5);
      testStep(iLevelOfDetailStep, "", "Low activation Counter=  %ld", lCounter);
    }
    else 
      if(bCounter == Comfort)
      {
        SendDiagnosticRequest(dReadBSRCounterRequest, dReadBSRCounterResponse);
        CheckPositiveResponse("Check positive response of Read BSR counter diagnostic service.", dReadBSRCounterRequest, dReadBSRCounterResponse);
        
        lCounter = (dReadBSRCounterResponse.GetPrimitiveByte(5) << 16) + (dReadBSRCounterResponse.GetPrimitiveByte(4) << 8) + dReadBSRCounterResponse.GetPrimitiveByte(3);
        testStep(iLevelOfDetailStep, "", "COMFORT activation Counter=  %ld", lCounter);
      }
      else
      {
        testStepFail(iLevelOfDetailFail, "", "Incorrect parameter (ReadCycleCounter function).");
        return -1;
      }
//  ConvertByteArrInCharArr(bReadCounterPosResp, cAllCycleCounters, 0, elcount(bReadCounterPosResp) - 1, "true");
//  testStep(iLevelOfDetailStep, "", "Response to Read Belt Activation Counters: %s", cAllCycleCounters);

  return lCounter;
}



/// <Profile_management>
// Function that writes the Cycle Counters.
// "sCounter" = the cycle that you want to write.
// "iValue"   = the counter value that you want to write.
// Usage Example:
// WriteCycleCounter("BOOST",50);
// WriteCycleCounter("PRECRASH",100);
// WriteCycleCounter("COMFORT",1000);
// WriteCycleCounter("HAPTIC",2000);
//void WriteCycleCounter(char cCounter[], long iValue)
//{
//  byte bReadCounterPosResp[23];
//  byte bCounters[20];
//  byte bCountersData[100];
//  byte bBlank[36];
//  byte bWriteCountersBlock1_Request[28];
//  byte bWriteCountersBlock2_Request[28]; 
//  byte bWriteCountersToEEPROM[36];
//  byte bCounterValue[4];
//  byte bTempBytes[4];
//  long iSwappedInput;
//  int i;
//  char EvalManStepString[200];
//  
//  // ---Init Values---
//  memcpy(bCounterValue, bBlank, elcount(bCounterValue));
//  memcpy(bWriteCountersBlock1_Request, bBlank, elcount(bWriteCountersBlock1_Request));
//  memcpy(bWriteCountersBlock2_Request, bBlank, elcount(bWriteCountersBlock2_Request));
//  memcpy(bWriteCountersToEEPROM, bBlank, elcount(bWriteCountersToEEPROM));
//  // -----------------
//  
//  // ---Init Requests---
//  bWriteCountersBlock1_Request[0] = 0x3D; // SID.
//  bWriteCountersBlock1_Request[1] = 0x24; // AddressAndLengthFormatIdentifier.
//  memcpy_off(bWriteCountersBlock1_Request, 2, u8PhysicalBlockId_counters, 0, elcount(u8PhysicalBlockId_counters)); // MemoryAddress.
//  bWriteCountersBlock1_Request[6] = 0x00; // MemorySize.
//  bWriteCountersBlock1_Request[7] = 0x14; // MemorySize.
//  // -------------------
//  
//  if(iValue != -1)
//  {
//    toUpper(cCounter, cCounter, elcount(cCounter));
//    
//    if(strncmp(cCounter, "NGU", elcount(cCounter)) == 0)
//    {
//      if(iValue >= (u32HighForceEOLThrs + 2) && (iValue < 0))
//      {
//        testStepFail(iLevelOfDetailFail, "", "Incorrect value: counter for BOOST can take values between 0 and %i (WriteCycleCounter function).", (u32HighForceEOLThrs + 1));
//        return;
//      }
//    }
//    else if(strncmp(cCounter, "PRECRASH", elcount(cCounter)) == 0)
//    {
//      if(iValue >= (u32LowForceEOLThrs + 2) && (iValue < 0))
//      {
//        testStepFail(iLevelOfDetailFail, "", "Incorrect value: counter for PRECRASH can take values between 0 and %i (WriteCycleCounter function).", (u32LowForceEOLThrs + 1));
//        return;
//      }
//    }
//    else if(strncmp(cCounter, "COMFORT", elcount(cCounter)) == 0)
//    {
//      if(iValue >= (u32ComfortForceEOLThrs + 2) && (iValue < 0))
//      {
//        testStepFail(iLevelOfDetailFail, "", "Incorrect value: counter for COMFORT can take values between 0 and %i (WriteCycleCounter function).", (u32ComfortForceEOLThrs + 1));
//        return;
//      }
//    }
//    else if(strncmp(cCounter, "HAPTIC", elcount(cCounter)) == 0)
//    {
//      if(iValue >= (u32HapticWarningEOLThrs + 2) && (iValue < 0))
//      {
//        testStepFail(iLevelOfDetailFail, "", "Incorrect value: counter for HAPTIC can take values between 0 and %i (WriteCycleCounter function).", (u32HapticWarningEOLThrs + 1));
//        return;
//      }
//    }
//    else
//    {
//      testStepFail(iLevelOfDetailFail, "", "Incorrect parameter (WriteCycleCounter function).");
//      return;
//    }  
//  }
//  else
//  {
//    // All counter data remains set to 0.
//  }
//  
//  SetECUMode("unlock");
//  if(iValue != -1)
//  {
//    SendDiagnosticRequest(dReadCountersRequest, dReadCountersResponse);
//    if(CheckPositiveResponse(dReadCountersRequest, dReadCountersResponse) == 1)
//    {
//      dReadCountersResponse.GetPrimitiveData(bReadCounterPosResp, elcount(bReadCounterPosResp));
//      memcpy_off(bCounters, 0, bReadCounterPosResp, 3, elcount(bCounters));
//    }
//    else
//    {
//      testStepFail(iLevelOfDetailFail, "", "Read Cycle counters negative reponse (WriteCycleCounter function).");
//      SetECUMode("lock");
//      return;
//    }
//
//    iSwappedInput = swapLong(iValue); // Swap to little-endian.
//    bCounterValue[0] = iSwappedInput >> 24;
//    bCounterValue[1] = iSwappedInput >> 16;
//    bCounterValue[2] = iSwappedInput >> 8;
//    bCounterValue[3] = iSwappedInput;
//    
//    // Swap bytes.
//    for(i = 0; i <= 4; i++)
//    {
//      memcpy_off(bTempBytes, 0, bCounters, i * 4, 4);
//      SwapBytes(bTempBytes);
//      memcpy_off(bCounters, i * 4, bTempBytes, 0, elcount(bTempBytes));
//    }
//        
//    memcpy_off(bWriteCountersBlock1_Request, 8, bCounters, 0, elcount(bCounters));
//    if(strncmp(cCounter, "NGU", elcount(cCounter)) == 0)
//    {
//      memcpy_off(bWriteCountersBlock1_Request, 8, bCounterValue, 0, elcount(bCounterValue));  
//    }
//    else if(strncmp(cCounter, "PRECRASH", elcount(cCounter)) == 0)
//    {
//      memcpy_off(bWriteCountersBlock1_Request, 12, bCounterValue, 0, elcount(bCounterValue));
//    }
//    else if(strncmp(cCounter, "COMFORT", elcount(cCounter)) == 0)
//    {
//      memcpy_off(bWriteCountersBlock1_Request, 16, bCounterValue, 0, elcount(bCounterValue)); 
//    }
//    else if(strncmp(cCounter, "HAPTIC", elcount(cCounter)) == 0)
//    {
//      memcpy_off(bWriteCountersBlock1_Request, 20, bCounterValue, 0, elcount(bCounterValue)); 
//    }
//    else
//    {
//      testStepFail(iLevelOfDetailFail, "", "Incorrect parameter (WriteCycleCounter function).");
//      return;
//    } 
//    
//    memcpy(bWriteCountersBlock2_Request, bWriteCountersBlock1_Request, elcount(bWriteCountersBlock1_Request));
//    bWriteCountersBlock2_Request[5] += 0x1C; // MemoryAddress.
//      
//    diagResize(dWriteMemoryByAddressRequest, elcount(bWriteCountersBlock1_Request));
//    dWriteMemoryByAddressRequest.SetPrimitiveData(bWriteCountersBlock1_Request, elcount(bWriteCountersBlock1_Request));
//    
//    snprintf(EvalManStepString, elCount(EvalManStepString), "Write first %s counter to %i", cCounter, iValue);
//    SendDiagnosticRequest(dWriteMemoryByAddressRequest, dWriteMemoryByAddressResponse);
//    CheckPositiveResponse(EvalManStepString, dWriteMemoryByAddressRequest, dWriteMemoryByAddressResponse);
//
//    dWriteMemoryByAddressRequest.SetPrimitiveData(bWriteCountersBlock2_Request, elcount(bWriteCountersBlock2_Request));
//    
//    snprintf(EvalManStepString, elCount(EvalManStepString), "Write second %s counter to %i", cCounter, iValue);
//    SendDiagnosticRequest(dWriteMemoryByAddressRequest, dWriteMemoryByAddressResponse);
//    CheckPositiveResponse(EvalManStepString, dWriteMemoryByAddressRequest, dWriteMemoryByAddressResponse); 
//  }
//  else
//  {
//    memcpy_off(bWriteCountersBlock1_Request, 8, bCounters, 0, elcount(bCounters));
//    
//    diagResize(dWriteMemoryByAddressRequest, elcount(bWriteCountersBlock1_Request));
//    dWriteMemoryByAddressRequest.SetPrimitiveData(bWriteCountersBlock1_Request, elcount(bWriteCountersBlock1_Request));   
//    SendDiagnosticRequest(dWriteMemoryByAddressRequest, dWriteMemoryByAddressResponse);
//    
//    CheckPositiveResponse("IMPORTANT! CHECK!!! Write all counters block 1 to 00 in RAM", dWriteMemoryByAddressRequest, dWriteMemoryByAddressResponse);
//    
//    memcpy(bWriteCountersBlock2_Request, bWriteCountersBlock1_Request, elcount(bWriteCountersBlock1_Request));
//    bWriteCountersBlock2_Request[5] += 0x1C; // MemoryAddress.
//    
//    dWriteMemoryByAddressRequest.SetPrimitiveData(bWriteCountersBlock2_Request, elcount(bWriteCountersBlock2_Request));   
//    SendDiagnosticRequest(dWriteMemoryByAddressRequest, dWriteMemoryByAddressResponse);
//    
//    CheckPositiveResponse("IMPORTANT! CHECK!!! Write all counters block 2 to 00 in RAM", dWriteMemoryByAddressRequest, dWriteMemoryByAddressResponse);
//  }
//  
//  WriteCountersChecksums();
//  
//  // Form RMBA request for counters RAM data.
//  diagSetParameter(dReadMemoryByAddressRequest, "addressAndLengthFormatIdentifier", 0x24);
//  diagSetParameterCoded(dReadMemoryByAddressRequest, "MemoryAddress", _au32StartOfCountersBlocks, elcount (_au32StartOfCountersBlocks));
//  diagSetParameter(dReadMemoryByAddressRequest, "MemorySize", _au32LengthOfCountersBlocks);
//  
//  SendDiagnosticRequest(dReadMemoryByAddressRequest, dReadMemoryByAddressResponse); // Read execution counter blocks.
//  if(CheckPositiveResponse(dReadMemoryByAddressRequest, dReadMemoryByAddressResponse) == 0)
//  {
//    testStepFail(iLevelOfDetailFail, "", "Negative response when reading block of counters (WriteCountersChecksums function).");
//    return;
//  }
//  
//  dReadMemoryByAddressResponse.GetPrimitiveData(bCountersData, elcount(bCountersData));
//  
//  // Write cycles in EEPROM.
//  bWriteCountersToEEPROM[0] = 0x3D; // SID.
//  bWriteCountersToEEPROM[1] = 0x24; // AddressAndLengthFormatIdentifier.
//  memcpy_off(bWriteCountersToEEPROM, 2, NVP_BLOCK_ID_EXECUTION_COUNTERS, 0, elcount(NVP_BLOCK_ID_EXECUTION_COUNTERS)); // MemoryAddress.
//  bWriteCountersToEEPROM[6] = 0x00; // MemorySize.
//  bWriteCountersToEEPROM[7] = 0x1C; // MemorySize.
//  memcpy_off(bWriteCountersToEEPROM, 8, bCountersData, 1, 28); // Data. 
// 
//  diagResize(dWriteMemoryByAddressRequest, elcount(bWriteCountersToEEPROM));
//  dWriteMemoryByAddressRequest.SetPrimitiveData(bWriteCountersToEEPROM, elcount(bWriteCountersToEEPROM));
//  SendDiagnosticRequest(dWriteMemoryByAddressRequest, dWriteMemoryByAddressResponse);
//  
//  snprintf(EvalManStepString, elCount(EvalManStepString), "Write all counters block 1 to EEPROM: %i", iValue);
//  CheckPositiveResponse(EvalManStepString, dWriteMemoryByAddressRequest, dWriteMemoryByAddressResponse);
//   
//  memcpy_off(bWriteCountersToEEPROM, 2, NVP_BLOCK_ID_EXECUTION_COUNTERS_1, 0, elcount(NVP_BLOCK_ID_EXECUTION_COUNTERS_1)); // MemoryAddress.
//  memcpy_off(bWriteCountersToEEPROM, 8, bCountersData, 29, 28); // Data.
//   
//  dWriteMemoryByAddressRequest.SetPrimitiveData(bWriteCountersToEEPROM, elcount(bWriteCountersToEEPROM));
//  SendDiagnosticRequest(dWriteMemoryByAddressRequest, dWriteMemoryByAddressResponse);
//  
//  snprintf(EvalManStepString, elCount(EvalManStepString), "Write all counters block 2 to EEPROM: %i", iValue);
//  CheckPositiveResponse(EvalManStepString, dWriteMemoryByAddressRequest, dWriteMemoryByAddressResponse); 
//
//  SetECUMode("lock");
//}

/// <Profile_management>
//Read deficiency level from RAM 
//long ReadDeficiencyLevel()
//{
//  long iDeficiencylevel;
//  
//  DiagSetPrimitiveByte(dReadMemoryByAddressRequest, 1, 0x24);
//  DiagSetPrimitiveByte(dReadMemoryByAddressRequest, 2, CurrentDeficiencylevel[0]);
//  DiagSetPrimitiveByte(dReadMemoryByAddressRequest, 3, CurrentDeficiencylevel[1]);
//  DiagSetPrimitiveByte(dReadMemoryByAddressRequest, 4, CurrentDeficiencylevel[2]);
//  DiagSetPrimitiveByte(dReadMemoryByAddressRequest, 5, CurrentDeficiencylevel[3]);
//  DiagSetPrimitiveByte(dReadMemoryByAddressRequest, 6, 0x00);
//  DiagSetPrimitiveByte(dReadMemoryByAddressRequest, 7, bCurrentDeficiencylevelSize);
//  
//  GetSecurityAccess("supplier");
//  SendDiagnosticRequest(dReadMemoryByAddressRequest, dReadMemoryByAddressResponse);
//  
//  if (CheckPositiveResponse(dReadMemoryByAddressRequest, dReadMemoryByAddressResponse) == 1)
//  {    
//    iDeficiencylevel = swapDWord(dReadMemoryByAddressResponse.GetParameter(0, "DataFromRam"));
//    
//    return iDeficiencylevel;
//  }
//  else
//  {
//    testStepWarning("", "Negative response received in ReadDeficiencyLevel function");
//    return -1;
//  }
//}

/// <CyberSecurity>
void SetSecTickCount()
{
 
  stack int i;
  diagRequest SecOC_Local_TickCount_Read Req_ReadSecTickCount;
  diagResponse SecOC_Local_TickCount_Read Resp_ReadSecTickCount;
  stack byte secTickCount[6];
  stack qword secTickCountValue;
  stack qword maxSecTickCountValue = 0;
  stack long currP2Timeout;
  stack long ret;
  stack char ecuQual[100]; 

  TestStep(iLevelOfDetailStep, "1","Authentication for all targets");
     
  currP2Timeout = diagGetP2Timeout();

  testStep(iLevelOfDetailStep, "","Authenticate");
  
  AuthenticateECU(1);
  
  //if( @sysvar::LocalAuthentication::AuthResult == 1 )
  if(1)
  {
    testStep(iLevelOfDetailStep, "","ReadSecTickCount");
   
    diagSendRequest(Req_ReadSecTickCount);
    testWaitForDiagRequestSent(Req_ReadSecTickCount,1000);
    ret = testWaitForDiagResponse(Req_ReadSecTickCount,currP2Timeout);
    if( ret == 1) // response received
    {
      diagGetLastResponse(Req_ReadSecTickCount,Resp_ReadSecTickCount);
      diagGetParameterRaw(Resp_ReadSecTickCount,"TickCount",secTickCount,elCount(secTickCount));
      ConvertFreshnessArrayToQword(secTickCount,secTickCountValue);

      sysGetVariableString("LocalAuthentication", "DiagTarget", ecuQual, elCount(ecuQual));
      testStep(iLevelOfDetailStep, "","Target:%s LocalSecTickCount:0x%I64x",ecuQual,secTickCountValue);
      
      testStep(iLevelOfDetailStep, "","Calculate max TickCount");
      if( secTickCountValue > maxSecTickCountValue )
        maxSecTickCountValue = secTickCountValue;
      testStep(iLevelOfDetailStep,"","MaxSecTickCount:0x%I64x LocalSecTickCount:0x%I64x",maxSecTickCountValue,secTickCountValue);
      
      if( maxSecTickCountValue > 0 )
      {     
        @sysvar::SeckTickSynchronization::SyncedMaxSecTickCount = maxSecTickCountValue;
      }
   
    }
    else if( ret == 0) // p2 timeout occured
    {
      teststep(iLevelOfDetailStep,"", "No response within P2 timeout.");
    }
    else
    {
      teststepFail(iLevelOfDetailFail,"Error ocurred returncode=%i",ret);
    }
  }
  else
  {
    testStepFail();
  }
  
  if( @sysvar::SeckTickSynchronization::SignTickCountOffset == 1 )
    @sysvar::SeckTickSynchronization::CalculatedSecTickCountWithOffset = maxSecTickCountValue + @sysvar::SeckTickSynchronization::TickCountOffset;
  else
    @sysvar::SeckTickSynchronization::CalculatedSecTickCountWithOffset = maxSecTickCountValue - @sysvar::SeckTickSynchronization::TickCountOffset;
}


/// <CyberSecurity>
int ConvertFreshnessArrayToQword(byte array[], qword& freshness)
{
  stack int offset = 1;
  if( elCount(array) < 5 + offset )
    return -1;
  
  freshness = array[4 + offset] + 
              ((qword)array[3+ offset] << 8) + 
              ((qword)array[2+ offset] << 16) + 
              ((qword)array[1+ offset] << 24) + 
              ((qword)array[0+ offset] << 32);
  
  return 0;
}
/// <CyberSecurity>
int AuthenticateECU(int iAuthLevel)
{
  stack char targetName[400];
  stack char jobQualifier[40];
  stack int authResult;

//  sysGetVariableString("LocalAuthentication", "DiagTarget", targetName, elCount(targetName));
  diagGetCurrentEcu(targetName, 9);
  
  switch(iAuthLevel)
  {
    case 0:
      snprintf(jobQualifier,elCount(jobQualifier),"Job_Anybody");
      break;
    case 1:
      snprintf(jobQualifier,elCount(jobQualifier),"Job_Supplier");
      break;
    case 2:
      snprintf(jobQualifier,elCount(jobQualifier),"Job_Development_Enhanced");
      break;
    case 3:
      snprintf(jobQualifier,elCount(jobQualifier),"Job_Production");
      break;
    case 4:
      snprintf(jobQualifier,elCount(jobQualifier),"Job_After_Sales_Enhanced");
      break;
    case 5:
      snprintf(jobQualifier,elCount(jobQualifier),"Job_After_Sales_Standard");
      break;
    case 6:
      snprintf(jobQualifier,elCount(jobQualifier),"Job_After_Sales_Basic");
      break;
    case 7:
      snprintf(jobQualifier,elCount(jobQualifier),"Job_Internal_Diagnostic_Test_Tool");
      break;
    case 8:
      snprintf(jobQualifier,elCount(jobQualifier),"Job_ePTI_Test_Tool");
      break;
    default:
      break;
  }

  authResult = testWaitForDiagAuthCompleted(targetName, jobQualifier);
  if (authResult == 0)
  {
     testStep(iLevelOfDetailStep, "", "ECU Authentication has succeeded");
  }
  else
  {
    testStepFail(iLevelOfDetailFail, "", "ECU Authentication has failed with error code:%i", authResult);
  }
  
  return authResult;
}


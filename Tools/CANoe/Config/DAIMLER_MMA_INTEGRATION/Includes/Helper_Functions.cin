/*@!Encoding:1252*/
includes
{
  #include "S:\Tools\CANoe\Config\DAIMLER_MMA_INTEGRATION\Includes\Debugger_Functions.cin"
  #include "S:\Tools\CANoe\Config\DAIMLER_MMA_INTEGRATION\Includes\Diagnostic_Functions.cin"
}

variables
{
  char        gTestIdStr[10];             // Identifier generated for each test step shown in the test report
  word        gTestStepIndex=0;
  enum        bool {TRUE = 1, FALSE = 0};
  const int   cApplicationTimeoutMs = 400;
  char        gResultString[200];         // String for temporary test step result outputs
  char        gDebuggerPath[200] = "S:\\Tools\\WinIDEA\\Workspace\\Daimler_MMA_debug_tc322.xjrf";
  char        gManualScript[200] = "C:\\Temp\\GUI.exe";
  char        dataArray[10][50];          // for split_string function
  long        table = 0;
}

// Test Report and external programs execution functions //
fctSetTestId(word tsIndex)
{
  gTestStepIndex=tsIndex;
  fctUpdateTestIdStr();
}

fctIncrementTestStepId()
{
  gTestStepIndex++;
  fctUpdateTestIdStr();
}

fctUpdateTestIdStr()
{
  snprintf(gTestIdStr, elcount(gTestIdStr), "%d", gTestStepIndex);
}

fctStartDebugger()
{
  sysExec(gDebuggerPath, "");
}

fctStartManual()
{
  sysExec(gManualScript, "");
}


void Check_KL15_ON()
{
  
 @sysvar::ModelGlobal::ISw_Stat = @sysvar::ModelGlobal::ISw_Stat::I_C03_ISW_STAT_IGN_ON;
 if (@sysvar::ModelGlobal::ISw_Stat == @sysvar::ModelGlobal::ISw_Stat::I_C03_ISW_STAT_IGN_ON) {
    snprintf(gResultString, elcount(gResultString), "Ignition set to ON");
    CreateActualExpectedTable ("Ignition set to ON", gResultString);
    testStepPass(0, "", table);
  }
  else {
    snprintf(gResultString, elcount(gResultString), "No answer from ECU!");
    CreateActualExpectedTable ("Ignition set to ON", gResultString);
    testStepFail(0, "", table);
  }

}

void Check_ECU_ON()
{
  long ret;
  ret = testWaitForSignalsAvailable (RBTM_FL, 2000);
  if (1 == ret) {
    snprintf(gResultString, elcount(gResultString), "ECU is responsive", ret);
    CreateActualExpectedTable ("ECU is responsive", gResultString);
    testStepPass(0, "", table);
  }
  else { 
    snprintf(gResultString, elcount(gResultString), "ECU is NOT responsive (Return code=%d)!", ret);
    CreateActualExpectedTable ("ECU is responsive", gResultString);
    testStepFail(0, "", table);
  }
}

on message 0x18E1A480x
{
  write ("%x %x %x %x" , this.byte(0),this.byte(1),this.byte(2),this.byte(3));
  if (this.byte(2) == 0x02 && this.byte(3) ==  0x60)
  {
  write ("merge");
  }
}

void Check_Authentication_DevEnhanced()
{
 int bIsResponseReceived = 0;
 @sysvar::LocalAuthentication::DiagnosticsRole = @sysvar::LocalAuthentication::DiagnosticsRole::Development_Enhanced;
 @sysvar::LocalAuthentication::TargetMode = @sysvar::LocalAuthentication::TargetMode::AuthForSingleTarget;
 @sysvar::LocalAuthentication::Button_Authenticate = 1;
  
 diagSendRequest(dAuthenticationResponse);
 testWaitForDiagRequestSent(dAuthenticationResponse, 10000);
 bIsResponseReceived = testWaitForDiagResponse(dAuthenticationResponse, 10000);
 switch (bIsResponseReceived)
  {
  case 0: // Timeout: The ECU did not respond in 10s
    snprintf(gResultString, elcount(gResultString),"No answer from ECU!");
    CreateActualExpectedTable ("Positive response reached!", gResultString);
    testStepFail(0, "", table);
    break;
  case 1: // Response received
    if (diagGetLastResponseCode(dAuthenticationResponse) == -1)
    {
        testReportWriteDiagResponse (dAuthenticationResponse);
        snprintf(gResultString, elcount(gResultString), "Positive response reached!");
        CreateActualExpectedTable ("Positive response reached!", gResultString);
        testStepPass (0, "", table); // write response to report
    }
    else
    {
      //Negative response reached
      testReportWriteDiagResponse (dAuthenticationResponse);
      snprintf(gResultString, elcount(gResultString), "Negative response reached! NRC:%X", (long)diagGetLastResponseCode(dAuthenticationResponse));
      CreateActualExpectedTable ("Positive response reached!", gResultString);
      teststepfail(0, "", table); // write response to report
    }
    break;
      default:
      snprintf(gResultString, elcount(gResultString), "Error, verdict unreliable.");
      CreateActualExpectedTable ("Positive response reached!", gResultString);
      teststepfail(0, "", table);
  }
}

void Check_setTickCount()
{
  int bIsResponseReceived = 0;
  @sysvar::LocalAuthentication::DiagnosticsRole = @sysvar::LocalAuthentication::DiagnosticsRole::Development_Enhanced;
  @sysvar::LocalAuthentication::TargetMode = @sysvar::LocalAuthentication::TargetMode::AuthForSingleTarget;
  @sysvar::SeckTickSynchronization::Button_SecTickCountSync = 1;
  
  bIsResponseReceived = testWaitForDiagResponse(dReadSetOClocalTickCountRequest, 15000);
  diagSendRequest(dAuthenticationResponse);
 switch (bIsResponseReceived)
  {
  case 0: // Timeout: The ECU did not respond in 10s
    snprintf(gResultString, elcount(gResultString),"No answer from ECU!");
    CreateActualExpectedTable ("Positive response reached!", gResultString);
    testStepFail(0, "", table);
    break;
  case 1: // Response received
    if (diagGetLastResponseCode(dReadSetOClocalTickCountRequest) == -1)
    {
      // Positive response reached
      testReportWriteDiagResponse (dReadSetOClocalTickCountRequest);
      snprintf(gResultString, elcount(gResultString), "Positive response reached!");
      CreateActualExpectedTable ("Positive response reached!", gResultString);
      testStepPass (0, "", table); // write response to report
    }
    else
    {
      //Negative response reached
      testReportWriteDiagResponse (dReadSetOClocalTickCountRequest);
      snprintf(gResultString, elcount(gResultString), "Negative response reached! NRC:%X", (long)diagGetLastResponseCode(dReadSetOClocalTickCountRequest));
      CreateActualExpectedTable ("Positive response reached!", gResultString);
      teststepfail(0, "", table); // write response to report
    }
    break;
      default:
      snprintf(gResultString, elcount(gResultString), "Error, verdict unreliable.");
      CreateActualExpectedTable ("Positive response reached!", gResultString);
      teststepfail(0, "", table);
  }
}
  
void ResetECU(char reset[])
{
  toUpper(reset, reset, elcount(reset));
  if(strncmp(reset, "SOFT", strlen(reset)) == 0)
  {    
    diagFctSendRequestAndWaitForFirstResponse(dSoftResetRequest, TRUE, FALSE, tRequestSentMaxTimeout);
  }
  else
  {
    if(strncmp(reset, "HARD", strlen(reset)) == 0)
    {
      diagFctSendRequestAndWaitForFirstResponse(dHardResetRequest, TRUE, FALSE, tRequestSentMaxTimeout);
    }
    else
    {
      testStepFail("Error", "Invalid parameter for ResetECU function: %s", reset);
    }
  }
}

void hwSetupChecks()
{
  //Buckle Switch State
  $BODY3::Bckl_Sw_Fx_Stat_ST3::Bckl_Sw_D_Stat_ST3 = 0;
  testWaitForTimeout(2000);
  $BODY3::Bckl_Sw_Fx_Stat_ST3::Bckl_Sw_D_Stat_ST3 = 1;
  
  //PRE-SAFE
  $BODY3::Presf_Enbl_ST3 = 0;
  $BODY3::PresfAccelReset_NotExcd_ST3 = 0;
  $BODY3::PresfAct_TensSupp_Rq_ST3 = 1;
  testWaitForTimeout(1000);
  $BODY3::Presf_Enbl_ST3 = 1;
  $BODY3::PresfAccelReset_NotExcd_ST3 = 1;
  $BODY3::PresfAct_TensSupp_Rq_ST3 = 0;
}
void ReadFromFile(char response[], int line)
{ 
  char fin[255];
  dword getFile;
  int iterator;
  getFile = openFileRead("isystem_response.INI", 0);
//  write("getFile: %d", getFile);
  for (iterator = 0; iterator <= line; iterator++)
  {
    if (getFile != 0)
    {
      fileGetString(fin, elcount(fin), getFile);
    } 
    else
    {
      write("End of file");
    }
  }
  
  snprintf(response, elcount(response), "%s", fin);
//  write("Response called from ReadFromFile(): %s", response);
  fileClose(getFile);
  write("__________________________________________________________________________________________________________________");
}


void ExpectedTestResult(char stepNo[], char description[], char expected_result[], int line)
{
  char lresult[124];
  
  ReadFromFile(lresult, line);
  testWaitForTimeout(500);
  testStepBegin (stepNo, description);
  
  CreateActualExpectedTable(expected_result, lresult);
  
  write("Step #%s:   %s", stepNo, description);
  
  if (strncmp(lresult, expected_result, elcount(lresult)) == 0)
  {
    testStepPass(0, "", table);
    write("Result:    PASSED");
  }
  else
  {
    testStepFail(0, "", table);
    write("Result:    FAILED");
  }
  
  write("Expected:  %s", expected_result);
  write("Actual:    %s", lresult);
}

// Splits a line into an array of strings
int split_string(char string[], char delim[])
{
  int start_pos, end_pos;
  int i, j;
  int num_strings;
  
  start_pos = 0;
  end_pos = 0;
  num_strings = 0;
  
  while (start_pos < strlen(string))
  {
    j = 0;
    end_pos = strstr_off(string, start_pos, delim);
    if (end_pos == -1)
    {
      end_pos = strlen(string);
    }
    for (i=start_pos; i<end_pos; i++)
    {
      dataArray[num_strings][j++] = string[i];
    }
    dataArray[num_strings][j] = '\0';
    num_strings++;
    start_pos = end_pos+strlen(delim);
  }
  
  return num_strings;
}

void CreateActualExpectedTable(char expected_result[], char actual_result[])
{
  table = testInfoTable("");
  TestInfoHeadingBegin(table, 0);
  TestInfoCell(table, "Expected Result");
  TestInfoCell(table, "Actual Result");
  TestInfoHeadingEnd(table);  
  // info row
  TestInfoRow(table, 0);
  TestInfoCell(table, expected_result);
  TestInfoCell(table, actual_result);
}
/*@!Encoding:1252*/

variables
{
  //                            <TestBench 1>          <TestBench 2>          <TestBench 3>         <TestBench 4>         <TestBench 5>
  enum TestBencheIdentifier   { AGR,                    PVI,                   VUR,                  SMA,                  DOL};
  char cTesterName[5][4]     = {"AGR",                 "PVI",                 "VUR",                "SMA",                "DOL"};
  char cPCId[5][20]          = {"ART-OF-WD3149",       "ART-OF-WD3145",       "ART-OF-WD3***",      "ART-OF-WD3121",      "ART-OF-WD3124"};
  char cCAN_CaseId[5][11]    = {"RBE-COM-25",          "RBE-COM-34",          "RBE-COM-03",         "RBE-COM-04",         "RBE-COM-05"};
  char cSBC_BOARD[5][50]     = {"-",                   "PP V2 - TLE49X1",     "19M***",             "19****",             "-"};
  char cPowerSupplyId[5][12] = {"RBE-PWR-030",         "RBE-PWR-18",          "RBE-PWR-033",        "RBE-PWR-034",        "RBE-PWR-07"};
  char cMOTHER_BOARD[5][50]  = {"-",                   "AEEC17-0026R",        "AEEC17_00***",       "AEEC17_0025R",       "-"};
  char cMCU[5][50]           = {"-",                   "TC322LP16F160F",      "19M***",             "19****",             "-"};
  char cDUT[5][50]           = {"Sample 1",            "DAI_MMA",       "AUDI TR6 PPMI",      "AUDI TR6 PPMI",      "Sample_1"};
  char cHWVersion[5][50]     = {"22/04.00",            "22/25.00",            "22/04.00",           "22/04.00",           "22/04.00"};
  char cSwVersion[500]       = "0x17 0x0B 0x00 0x17 0x0B 0x00";
  char cSWV_Read_FD01[500]   = "ER01860H.P52";
  char cSWRelease[500]       = "5.1";
  int iTestBenchUsed = AGR; // This value is changed through ConfigureTestModuleInformation in  <<< InitTestModule >>> testcase.
  
  //*********************************Reset cause manager parameters********************************
  
  const byte bWARM_RESET_CAUSE_PLL                  = 0x82;
  const byte bRESET_CAUSE_WD_TEST                   = 0x4;
  const byte bRESET_CAUSE_OS_EXCEPTION              = 0x10;
  const byte bRESET_CAUSE_INTERNAL_WATCHDOG         = 0x12;
  const byte bWARM_RESET_CAUSE_WD                   = 0x80;
  const byte bRESET_CAUSE_RAM_ECC                   = 0x83;
  const byte bRESET_CAUSE_PFLASH                    = 0x84;
  const byte bRESET_CAUSE_INVALID_INT               = 0x85;
  const byte bRESET_CAUSE_UNIDENTIFIED_ECC          = 0x86;
  const byte bRESET_CAUSE_BTLD                      = 0x87;
  const byte bKU8_RESET_CAUSE_STACK_OVERFLOW        = 0x88;
  const byte bRESET_CAUSE_RAM_DATA_CORRUPTED        = 0x89;
  const byte bRESET_CAUSE_E2P_ECC                   = 0x8A;
  const byte bRESET_CAUSE_EXTERNAL_WATCHDOG         = 0x90;
  const byte bWARM_RESET_CAUSE_UNKNOWN              = 0xFF;
  const dword bWR_WARM_RESET_CAUSE_UNKNOWN           = 0x00000000;
  const dword bWR_WARM_RESET_BAT_LOSS                = 0x02000000;
  const dword bWR_WARM_RESET_CAUSE_PLL               = 0x08000000;
  const dword bWR_RESET_CAUSE_RAM_ECC                = 0x00010000;
  const dword bWR_RESET_CAUSE_PFLASH                 = 0x00020000;
  const dword bWR_RESET_CAUSE_OS_EXCEPTION           = 0x00040000;
  const dword bWR_RESET_CAUSE_INVALID_INT            = 0x00080000;
  const dword bWR_RESET_CAUSE_UNIDENTIFIED_ECC       = 0x00400000;
  const dword bWR_RESET_CAUSE_E2P_ECC                = 0x00800000;
  const dword bWR_RESET_CAUSE_STACK_OVERFLOW         = 0x00000200;
  const dword bWR_RESET_CAUSE_EXTERNAL_WATCHDOG      = 0x00000800;
  
  //*********************************AEC configuration parameters********************************
  const int iNoOfAECs = 56; // Number of AECs.
  
  // AEC IDs.
  const  FREE_MOTOR = 0x99;
  // AEC IDs.
  const bERR_ADC_OUT_OF_ORDER                  = 0x01;
  const bERR_HIGH_SIDE_SWITCH                  = 0x02;
  const bERR_ENABLE_OUT_OF_ORDER               = 0x03;
  const bERR_MOSFET_HIGH_SC                    = 0x04;
  const bERR_MOSFET_LOW_SC                     = 0x05;
  const bERR_MOTOR_DISCONNECTED                = 0x06;
  const bERR_HW_SELF_PROTECTION                = 0x07; 
  const bERR_MOSFET_OC                         = 0x08;
 //  const bERR_PRELIMINARY_BOOSTER               = 0x09; 
  const bERR_HALL_SENSOR                       = 0x0A;
  const bERR_MOTOR_CURRENT                     = 0x0B;
  const bERR_MOTOR_BLOCKED                     = 0x0C;
  const bERR_SW_SELF_PROTECTION                = 0x0D;
  const bERR_TEMPERATURE_SENSOR_FAILURE        = 0x0E;
  const bERR_MOTOR_IN_SC                       = 0x0F;
  const bERR_MOTOR_ORDER                       = 0x10;
  const bERR_BAT_PWR_UNDER_VOLTAGE             = 0x11;
  const bERR_BAT_PWR_OVER_VOLTAGE              = 0x12;
  const bERR_BAT_PWR_UNDER_VOLTAGE_DURING_TENS = 0x13;
  const bERR_BAT_PWR_OVER_VOLTAGE_DURING_TENS  = 0x14;
//  const bERR_FLS_E_ERASE                       = 0x15;
//  const bERR_FLS_E_READ                        = 0x16;
//  const bERR_FLS_E_WRITE                       = 0x17;
//  const bERR_FLS_ECC                           = 0x18;
//  const bERR_NVM_INTEGRITY                     = 0x19;
//  const bERR_NVM_E_REQ_FAILED                  = 0x1A;
  const bERR_WARM_RESET                        = 0x1B;
  const bERR_COMFORT_END_OF_LIFE               = 0x1C;
  const bERR_LOW_FORCE_END_OF_LIFE             = 0x1D;
  const bERR_HIGH_FORCE_END_OF_LIFE            = 0x1E;
//  const bERR_NVM_E_QUEUE_OVERFLOW              = 0x1E;
  const bERR_MAX_FORCE_END_OF_LIFE             = 0x1F;
//  const bERR_NVM_NOT_PROG                      = 0x20;
  const bERR_TIMEOUT_PRESAFE                   = 0x21;
  const bERR_TIMEOUT_BUCKLE                    = 0x22;
  const bERR_IMPLAUSIBLE_DATA_PRESAFE          = 0x23;
  const bERR_IMPLAUSIBLE_DATA_IGNITION         = 0x24;
  const bERR_IMPLAUSIBLE_DATA_BUCKLE           = 0x25;
  const bERR_TIMEOUT_IGNITION                  = 0x26;
  const bERR_TIMEOUT_POWERTRAIN                = 0x27;
  const bERR_IMPLAUSIBLE_DATA_POWERTRAIN       = 0x28;
  const bERR_IMPLAUSIBLE_DATA_ORC              = 0x29;
  const bERR_TIMEOUT_BELT_HANDOVER_LEFT        = 0x2A;
  const bERR_TIMEOUT_BELT_HANDOVER_RIGHT       = 0x2B;
  const bERR_BAT_PWR_OVER_VOLTAGE_SYSTEM       = 0x2C;
  const bERR_BAT_PWR_UNDER_VOLTAGE_SYSTEM      = 0x2D;
  const bERR_STEERING_CONFIGURATION            = 0x2E;
  const bERR_TIMEOUT_API_INTERFACE             = 0x2F;
//  const bERR_ECU_KNOCKOUT_TIMEOUT              = 0x30;
  const bERR_CANSM_E_BUS_OFF                   = 0x98; // BUS OFF has no AEC id. This variable is used for easier use of functions.  
  
  // <<< AEC status definition >>>
  const byte bAEC_Qualified 						       = 0x17;
  const byte bAEC_ReQualifingInProgress			   = 0x1E;
  const byte bAEC_QualifingInProgress				   = 0x1C;
  const byte bAEC_DeskillingInProgress		     = 0x1F;
  const byte bAEC_DeskilledFailed					     = 0x16;
  const byte bAEC_AbsentFailed					       = 0x14;
  const byte bAEC_DeskilledNotFailed				   = 0x06;
  const byte bAEC_EverQualified					       = 0x02;
  const byte bAEC_EverQualifiedStartup			   = 0x03;
  const byte bAEC_NotEverDeskilled 				     = 0x07;
  const byte bAEC_TestedNotPresent				     = 0x04;
  const byte bAEC_NotEverQualified				     = 0x00;
  const byte bAEC_NotCompletedSincePowerOffOn  = bAEC_NotEverQualified;
  const byte bAEC_NotFailedDeskilledInProgress = 0x0F;
  
  // Functions configured for the following PR Structure: PR & LID; 3 bytes  + (AEC ID; 2 bytes + AEC Status; 1 byte) * Total nr. of AECs.
  // <<< All RDBLI AEC functions >>>
  // Ignored AECs. Not displayed in the report. 
  // Example use case: disabled autotests with incorrect status.
  // Set to '0xFF' for no ignored autotest.
  byte bIgnoredAECS[5] = {0x34, 0x35, 0x36, 0x37, 0x38};
  
  // Structure: {AEC_ID, AEC_status}
  // <<< CheckAECPresence >>> and <<< CheckAECStatus >>>
  byte bAcceptedAECStatus[2]                       = {bAEC_TestedNotPresent, bAEC_NotEverQualified}; // If an AEC does NOT match at least one defined status, a testStepFail will be reported.
  byte bSpecificAECExpectedStatus[7][2]            = {{bERR_STEERING_CONFIGURATION, bAEC_DeskilledFailed}, 
                                                      {bERR_IMPLAUSIBLE_DATA_IGNITION, bAEC_AbsentFailed}, 
                                                      {bERR_IMPLAUSIBLE_DATA_PRESAFE, bAEC_AbsentFailed}, 
                                                      {bERR_IMPLAUSIBLE_DATA_BUCKLE, bAEC_AbsentFailed}, 
                                                      {bERR_BAT_PWR_OVER_VOLTAGE_SYSTEM, bAEC_AbsentFailed}, 
                                                      {bERR_IMPLAUSIBLE_DATA_POWERTRAIN, bAEC_AbsentFailed}, 
                                                      {bERR_IMPLAUSIBLE_DATA_ORC, bAEC_AbsentFailed}};
                                                   // If AEC_ID does not have any of the accepted statuses or the specified AEC_status, a testStepFail will be reported.
                                                   // Set the first AEC_ID to 0xFF for no special status consideration.
  // <<< CheckAECPresenceInBenchInit >>>
  byte bAcceptedAECStatus_BenchInit[1]             = {bAEC_TestedNotPresent}; // If an AEC does NOT match at least one defined status, a testStepFail will be reported. 
  byte bSpecificAECExpectedStatus_BenchInit[11][2]  = {{bERR_STEERING_CONFIGURATION, bAEC_DeskilledFailed},
                                                      {bERR_IMPLAUSIBLE_DATA_IGNITION, bAEC_AbsentFailed}, 
                                                      {bERR_IMPLAUSIBLE_DATA_PRESAFE, bAEC_AbsentFailed}, 
                                                      {bERR_IMPLAUSIBLE_DATA_BUCKLE, bAEC_AbsentFailed}, 
                                                      {bERR_BAT_PWR_OVER_VOLTAGE_SYSTEM, bAEC_AbsentFailed}, 
                                                      {bERR_IMPLAUSIBLE_DATA_POWERTRAIN, bAEC_AbsentFailed}, 
                                                      {bERR_IMPLAUSIBLE_DATA_ORC, bAEC_AbsentFailed},
                                                      {bERR_TIMEOUT_BUCKLE, bAEC_AbsentFailed},
                                                      {bERR_TIMEOUT_IGNITION, bAEC_AbsentFailed},
                                                      {bERR_TIMEOUT_PRESAFE, bAEC_AbsentFailed},
                                                      {bERR_TIMEOUT_API_INTERFACE, bAEC_AbsentFailed}
                                                      };
                                                    // Specific AEC status does NOT take precedence over accepted status.
                                                    // Set the first AEC_ID to 0xFF for no special status consideration.
  // <<< CheckDTCPresenceAfterClear >>>
  byte bAcceptedAECStatus_AfterClear[1]            = {bAEC_TestedNotPresent}; // If an AEC does NOT match at least one defined status, a testStepFail will be reported. 
  byte bSpecificAECExpectedStatus_AfterClear[11][2] = {{bERR_STEERING_CONFIGURATION, bAEC_DeskilledFailed}, 
                                                      {bERR_IMPLAUSIBLE_DATA_IGNITION, bAEC_AbsentFailed}, 
                                                      {bERR_IMPLAUSIBLE_DATA_PRESAFE, bAEC_AbsentFailed}, 
                                                      {bERR_IMPLAUSIBLE_DATA_BUCKLE, bAEC_AbsentFailed}, 
                                                      {bERR_BAT_PWR_OVER_VOLTAGE_SYSTEM, bAEC_AbsentFailed}, 
                                                      {bERR_IMPLAUSIBLE_DATA_POWERTRAIN, bAEC_AbsentFailed}, 
                                                      {bERR_IMPLAUSIBLE_DATA_ORC, bAEC_AbsentFailed},
                                                      {bERR_TIMEOUT_BUCKLE, bAEC_AbsentFailed},
                                                      {bERR_TIMEOUT_IGNITION, bAEC_AbsentFailed},
                                                      {bERR_TIMEOUT_PRESAFE, bAEC_AbsentFailed},
                                                      {bERR_TIMEOUT_API_INTERFACE, bAEC_AbsentFailed}
                                                      };
                                                    // Specific AEC status does NOT take precedence over accepted status.
                                                    // Set the first AEC_ID to 0xFF for no special status consideration.;
  
  //*********************************DTC configuration parameters********************************
  // DTC status definition
  const byte bDTC_TestedNotPresent            = 0x00;
  const byte bDTC_QualifyingInProgress        = 0x00;
  const byte bDTC_NotCompletedSincleLastClear = 0x10;
  const byte bDTC_Qualified                   = 0x29;
  const byte bDTC_DeskilledFailed             = 0x28;
  
  const dword DTC_HARDWARE                          = 0xA28B49;
  const dword DTC_TEMPERATURE_SELF_PROTECTION       = 0xA28B4B;
  const dword DTC_MOTOR                             = 0xA28B71;
  const dword DTC_BAT_PWR_UNDER_VOLTAGE             = 0xA10D00;
  const dword DTC_BAT_PWR_OVER_VOLTAGE              = 0xA10E00;
  const dword DTC_BAT_PWR_UNDER_VOLTAGE_DURING_TENS = 0xA28B16;
  const dword DTC_BAT_PWR_OVER_VOLTAGE_DURING_TENS  = 0xA28B17;
  const dword DTC_WARM_RESET                        = 0xA28B47;
  const dword DTC_TENSIONING_END_OF_LIFE            = 0xA28B96;
  const dword DTC_COMFORT_END_OF_LIFE               = 0xA28B97;
  const dword DTC_TIMEOUT_PRESAFE                   = 0xC12287;
  const dword DTC_TIMEOUT_BUCKLE                    = 0xC15187;
  const dword DTC_IMPLAUSIBLE_DATA_PRESAFE          = 0xC41608;
  const dword DTC_IMPLAUSIBLE_DATA_IGNITION         = 0xC42708;
  const dword DTC_IMPLAUSIBLE_DATA_BUCKLE           = 0xC45208;
  const dword DTC_BAT_PWR_OVER_VOLTAGE_SYSTEM       = 0xA10B00;
  const dword DTC_BAT_PWR_UNDER_VOLTAGE_SYSTEM      = 0xA10A00;
  const dword DTC_CANSM_E_BUS_OFF                   = 0xC22488;
  const dword DTC_TIMEOUT_IGNITION                  = 0xC16887;
  const dword DTC_TIMEOUT_POWERTRAIN                = 0xC11587;
  const dword DTC_IMPLAUSIBLE_DATA_POWERTRAIN       = 0xC44286;
  const dword DTC_IMPLAUSIBLE_DATA_ORC              = 0xC45208;
  const dword DTC_TIMEOUT_BELT_HANDOVER_LEFT        = 0xC20187;
  const dword DTC_TIMEOUT_BELT_HANDOVER_RIGHT       = 0xC20287;
//const dword DTC_TIMEOUT_API_INTERFACE             = No associated DTC
  const dword DTC_MAX_FORCE_END_OF_LIFE             = 0xA28BFA;
  const dword DTC_STEERING_CONFIGURATION            = 0xA20400;
  
  // <<< All 0x19 0x02 RDTCBST functions >>> Use AEC IDs for this.
  // Set to '0xFF' for no ignored autotest.
  const bUnknownDTC_1 = 0xEE;
  const bUnknownDTC_2 = 0xEF;
  byte bIgnoredDTCS[2] = {bUnknownDTC_1, bUnknownDTC_2};
  
  byte bAcceptedDTCStatus[2][2] = {{bERR_STEERING_CONFIGURATION, bDTC_DeskilledFailed}, {bERR_IMPLAUSIBLE_DATA_IGNITION, bDTC_DeskilledFailed}};
  
////*********************************************************************************************
//                                                                                            *
//                                                                                            *
//                                                                                            *
//                                                                                            *
//       Everything below this marker is configured in the CORE_* functions.                  *
//                                                                                            *
//                                                                                            *
//                                                                                            *
//                                                                                            *
////*********************************************************************************************
  
  // <<< AEC functions >>>
  byte _erh_au8AecStatus[4];
  
  char cSession_ReadAECs[30];
  byte bEnterSessionEnabled_CheckAECStatus; 
  byte bEnterSessionEnabled_ReturnAECStatusChangeTime;
  byte bEnterSessionEnabled_CheckAECStatusFromRAM;
  byte bEnterSessionEnabled_CheckAECPresence;
  byte bGetSecurityAccess_ReadAECs;
  byte bGetSecurityAccess_CheckAECStatusFromRAM;
  byte bGetSecurityAccess_ReturnAECStatusChangeTime;
  byte bGetSecurityAccess_CheckAECPresence;
  int iAECBytePosition;
  
  byte bReadAllAECsStatusRequest[3];
  const int iReadAECsResponseSize = iNoOfAECs * 3 + 3; // Total response size.
  char[50] cAECName[double, iNoOfAECs]; // AEC names: CORE_AEC_Names()
  char[50] cAEC_NotExecutedAfterReset[double, iNoOfAECs];
  
  // <<< DTC functions >>>
  byte bRDTCBST_StatusMask;
  byte bRDTCBST_StatusMask_Init;
  byte bRDTCBST_StatusMask_AfterClear;
  byte bDTC_AvailableStatusMask;
  
  char[500] cDTCName[double, iNoOfAECs];
  dword     bDTCID[double, iNoOfAECs];
  
  // .CDD variables.
  char PR_DTCAndStatusRecord[100];
  char PR_DTCRecord[100];
  char PR_StatusOfDTC[100];
  char PR_StatusOfDTC_WarningIndicatorRequested[100];
  char PR_StatusOfDTC_TestNotCompletedThisOperationCycle[100];
  char PR_StatusOfDTC_TestFailedSinceLastClear[100];
  char PR_StatusOfDTC_TestNotCompletedSinceLastClear[100];
  char PR_StatusOfDTC_ConfirmedDTC[100];
  char PR_StatusOfDTC_PendingDTC[100];
  char PR_StatusOfDTC_TestFailedThisOperationCycle[100];
  char PR_StatusOfDTC_TestFailed[100];
  
  char PR_DTCRecordExtended[100];
  char PR_StatusOfDTCExtended[100];
  char PR_StatusOfDTCExtended_WarningIndicatorRequested[100];
  char PR_StatusOfDTCExtended_TestNotCompletedThisOperationCycle[100];
  char PR_StatusOfDTCExtended_TestFailedSinceLastClear[100];
  char PR_StatusOfDTCExtended_TestNotCompletedSinceLastClear[100];
  char PR_StatusOfDTCExtended_ConfirmedDTC[100];
  char PR_StatusOfDTCExtended_PendingDTC[100];
  char PR_StatusOfDTCExtended_TestFailedThisOperationCycle[100];
  char PR_StatusOfDTCExtended_TestFailed[100];
  
  char PR_DTCAvailabilityMask[100];
  char PR_DTCAvailabilityMask_WarningIndicatorRequested[100];
  char PR_DTCAvailabilityMask_TestNotCompletedThisOperationCycle[100];
  char PR_DTCAvailabilityMask_TestFailedSinceLastClear[100];
  char PR_DTCAvailabilityMask_TestNotCompletedSinceLastClear[100];
  char PR_DTCAvailabilityMask_ConfirmedDTC[100];
  char PR_DTCAvailabilityMask_PendingDTC[100];
  char PR_DTCAvailabilityMask_TestFailedThisOperationCycle[100];
  char PR_DTCAvailabilityMask_TestFailed[100];
  
  char REQ_DTCStatusMask[100];
  char REQ_DTCStatusMask_WarningIndicatorRequested[100];
  char REQ_DTCStatusMask_TestNotCompletedThisOperationCycle[100];
  char REQ_DTCStatusMask_TestFailedSinceLastClear[100];
  char REQ_DTCStatusMask_TestNotCompletedSinceLastClear[100];
  char REQ_DTCStatusMask_ConfirmedDTC[100];
  char REQ_DTCStatusMask_PendingDTC[100];
  char REQ_DTCStatusMask_TestFailedThisOperationCycle[100];
  char REQ_DTCStatusMask_TestFailed[100];
  
  // <<< ClearAll >>>
  byte bClearAllRequest[4]; 
  
  // <<< CheckDTCPresence >>>
  byte bCheckDTCPresenceRequest[3];
  byte bReportDTCExtendedDataByDTCNbrRequest[6];
  byte bReportSupportedDTCsRequest[2];
  byte bReportNbrOfDTCByStatusMaskRequest[3];
  
  // << Read Memory By Address >>
  byte bRMBARequest[8];
  
  // <<< Basic diagnostic functions >>>
  char cDiagnosticTarget[100];
  dword dDiagRequestSentTimeout;
  dword dDiagResponseReceiveTimeout;
  dword dSessionTimeout;
  
  // <<< EnterDiagnosticSession >>>
  int iSessionControlVerbosity = 0;
  char cAvailableDiagSessions[6][12];
  byte bSessionControlRequests[6][2];
  
  // <<< ResetECU >>>
  byte bHardResetRequest[2];
  byte bSoftResetRequest[2];
  
  // <<< CheckSWVersion >>> and <<< GetSWVersion >>>
  byte bReadSWVersionRequest[3];
  char cSession_CheckSWVersion[20];
  char cKeepHexFormat[6];
  
  // <<< Logging functions >>>
  char cLogPath[500];
  char TestLoggingBlock[100];
  char TestCaseLogASC[100];
  char TestCaseLogBLF[100];
  
  // <<< SetECUMode >>>
  char cSession_SetECUMode[20];
  byte bLockECU[4];
  byte bGetECULockState[4];
  byte bUnlockECU[4];
  char cUnlock[10];
  char cLock[10];
  byte bGetSecurityAccess_SetECUMode;
  byte securityAlgoDataBuffer[8];
  
  byte bProcessModeStartRequest[4];
  byte bProcessModeStopRequest[4];
  byte bProcessModeRequestResRequest[4];
  
  // <<< Diag objects >>>
  // Dignostic session control
  diagRequest  * dDefaultSessionRequest;
  diagResponse * dDefaultSessionResponse;
  
  diagRequest  * dExtendedSessionRequest;
  diagResponse * dExtendedSessionResponse;
  
  diagRequest  * dProgrammingSessionRequest;
  diagResponse * dProgrammingSessionResponse;
  
  diagRequest  * dDevelopmentSessionRequest;
  diagResponse * dDevelopmentSessionResponse;
  
  diagRequest  * dSupplierSessionRequest;
  diagResponse * dSupplierSessionResponse;
  
  diagRequest  * dUpdateSessionRequest;
  diagResponse * dUpdateSessionResponse;
  
  // ECU reset
  diagRequest  * dHardResetRequest;
  diagResponse * dHardResetResponse;
  
  diagRequest  * dSoftResetRequest;
  diagResponse * dSoftResetResponse;
  
  // Software version
  diagRequest  * dReadSWVersionRequest;
  diagResponse * dReadSWVersionResponse;
  
  // RMBA
  diagRequest  * dReadMemoryByAddressRequest;
  diagResponse * dReadMemoryByAddressResponse;
  
  // WMBA
  diagRequest  * dWriteMemoryByAddressRequest;
  diagResponse * dWriteMemoryByAddressResponse;
  
  // Clear All DTCs
  diagRequest  * dClearAllDTCsRequest;
  diagResponse * dClearAllDTCsResponse;
  
  // Read All AEC
  diagRequest  * dReadAllAECsStatusRequest;
  diagResponse * dReadAllAECsStatusResponse;
  
  // Read DTCs.
  diagRequest  * dReportDTCByStatusMaskRequest;
  diagResponse * dReportDTCByStatusMaskResponse;
  
  diagRequest  * dReportDTCExtendedDataByDTCNbrRequest;
  diagResponse * dReportDTCExtendedDataByDTCNbrResponse;
  
  diagRequest  * dReportNbrOfDTCByStatusMaskRequest;
  diagResponse * dReportNbrOfDTCByStatusMaskResponse;
  
  diagRequest  * dReportSupportedDTCsRequest;
  diagResponse * dReportSupportedDTCsResponse;
  
  // Lock / Unlock ECU.
  diagRequest  * dUnlockECURequest;
  diagResponse * dUnlockECUResponse;
  
  diagRequest  * dLockECURequest;
  diagResponse * dLockECUResponse;
  
  diagRequest  * dGetECULockStateRequest;
  diagResponse * dGetECULockStateResponse;
  
  //  Process mode.
  diagRequest  * dProcessModeStartRequest;
  diagResponse * dProcessModeStartResponse;
  
  diagRequest  * dProcessModeStopRequest;
  diagResponse * dProcessModeStopResponse;
  
  diagRequest  * dProcessModeRequestResRequest;
  diagResponse * dProcessModeRequestResResponse;
}

// Initializes all the configured parameters.
// Do not modify the execution order.
void InitParameters()
{
  CORE_Basic_Diagonstics();
  
  // Set ECU target.
  diagSetTarget(cDiagnosticTarget);
  
  CORE_ECU_State();
  
  CORE_Logging();
  
  CORE_AEC_Names();
  
  CORE_AEC_Not_Executed_After_Reset();
  
  CORE_DTC_Names();
  
  CORE_DTC_AEC_Association();
  
  CORE_Fault_Management_AECs();
  
  CORE_Fault_Management_DTCs();
  
  CORE_Test_Traceability();
  
  CORE_Init_DiagObjects();
}

/// <CORE_Basic_Diagnostics>
void CORE_Basic_Diagonstics()
{
  strncpy(cDiagnosticTarget, "RBTMFL174", elcount(cDiagnosticTarget)); // Set ECU name.
  
  dDiagRequestSentTimeout     = 2500; // (ms) Timeout for diagnostic request sent .
  dDiagResponseReceiveTimeout = 5000; // (ms) Timeout for diagnostic response.
}

/// <CORE_ECU_State>
void CORE_ECU_State()
{
  dSessionTimeout = 5000; // (ms) Timeout for diagnostic session.
  
  // <<< EnterDiagnosticSession >>>
  iSessionControlVerbosity = 2;  // Controls what is written in the report:
                                 // 0 - Only negative response.
                                 // 1 - Comment or negative response.
                                 // 2 - A testStepPass result or negative response.
  
  strncpy(cAvailableDiagSessions[0], "default", elcount(cAvailableDiagSessions[0]));
  bSessionControlRequests[0][0] = 0x10;
  bSessionControlRequests[0][1] = 0x01;
  
  strncpy(cAvailableDiagSessions[1], "extended", elcount(cAvailableDiagSessions[1]));
  bSessionControlRequests[1][0] = 0x10;
  bSessionControlRequests[1][1] = 0x03;
  
  strncpy(cAvailableDiagSessions[2], "programming", elcount(cAvailableDiagSessions[2]));
  bSessionControlRequests[2][0] = 0x10;
  bSessionControlRequests[2][1] = 0x02;
  
  strncpy(cAvailableDiagSessions[3], "development", elcount(cAvailableDiagSessions[3]));
  bSessionControlRequests[3][0] = 0x10;
  bSessionControlRequests[3][1] = 0x7E;
  
  strncpy(cAvailableDiagSessions[4], "supplier", elcount(cAvailableDiagSessions[4]));
  bSessionControlRequests[4][0] = 0x10;
  bSessionControlRequests[4][1] = 0x7E;
  
  strncpy(cAvailableDiagSessions[5], "update", elcount(cAvailableDiagSessions[4]));
  bSessionControlRequests[5][0] = 0x10;
  bSessionControlRequests[5][1] = 0x42;
  
  // <<< ResetECU >>>
  bHardResetRequest[0] = 0x11;
  bHardResetRequest[1] = 0x01;
  
  bSoftResetRequest[0] = 0x11;
  bSoftResetRequest[1] = 0x03;
  
  // <<< SetECUMode >>>
  strncpy(cSession_SetECUMode, "supplier", elcount(cSession_SetECUMode));
  strncpy(cLock, "lock", elcount(cLock));
  strncpy(cUnlock, "unlock", elcount(cUnlock));
  // 1 - Obtains 'cSession_SetECUMode' security access before unlocking ECU.
  // 0 - Security access is not obtained.
  bGetSecurityAccess_SetECUMode = 0;

  bLockECU[0] = 0x31;
  bLockECU[1] = 0x02;
  bLockECU[2] = 0xf7;
  bLockECU[3] = 0x81;

  bUnlockECU[0] = 0x31;
  bUnlockECU[1] = 0x01;
  bUnlockECU[2] = 0xf7;
  bUnlockECU[3] = 0x81;
  
  bGetECULockState[0] = 0x31;
  bGetECULockState[1] = 0x03;
  bGetECULockState[2] = 0xf7;
  bGetECULockState[3] = 0x81;
  
  // Process mode.
  bProcessModeStartRequest[0] = 0x31;
  bProcessModeStartRequest[1] = 0x01;
  bProcessModeStartRequest[2] = 0xF7;
  bProcessModeStartRequest[3] = 0x93;
  
  bProcessModeStopRequest[0] = 0x31;
  bProcessModeStopRequest[1] = 0x02;
  bProcessModeStopRequest[2] = 0xF7;
  bProcessModeStopRequest[3] = 0x93;
  
  bProcessModeRequestResRequest[0] = 0x31;
  bProcessModeRequestResRequest[1] = 0x03;
  bProcessModeRequestResRequest[2] = 0xF7;
  bProcessModeRequestResRequest[3] = 0x93;
}

/// <CORE_Fault_Management/CORE_AECs>
void CORE_Fault_Management_AECs()
{
  iAECBytePosition = 0; // AEC ID byte position; 0 or 1 e.g. for DAI MMA = 0; for TR6 = 1;
  
  // 1 - enters 'cSession_ReadAECs' diagnostic session before reading AECs.
  // 0 - Session is not entered.
  bEnterSessionEnabled_CheckAECStatus            = 1;
  bEnterSessionEnabled_ReturnAECStatusChangeTime = 0;
  bEnterSessionEnabled_CheckAECStatusFromRAM     = 0;
  bEnterSessionEnabled_CheckAECPresence          = 1;
  
  // 1 - Obtains 'cSession_ReadAECs' security access before reading AECs.
  // 0 - Security access is not obtained.
  bGetSecurityAccess_ReadAECs                  = 0;
  bGetSecurityAccess_CheckAECStatusFromRAM     = 0;
  bGetSecurityAccess_ReturnAECStatusChangeTime = 0;
  bGetSecurityAccess_CheckAECPresence          = 0;
  
  strncpy(cSession_ReadAECs, "development", elcount(cSession_ReadAECs));    // Needed Session: Set to "none" if no special session is needed.
  
  // <<< ClearAll >>>
  bClearAllRequest[0] = 0x14;
  bClearAllRequest[1] = 0xFF;
  bClearAllRequest[2] = 0xFF;
  bClearAllRequest[3] = 0xFF;
  
  // << Read Memory By Address >>
  bRMBARequest[0] = 0x23;
  bRMBARequest[1] = 0x24;
  bRMBARequest[2] = 0x00;
  bRMBARequest[3] = 0x00;
  bRMBARequest[4] = 0x00;
  bRMBARequest[5] = 0x00;
  bRMBARequest[6] = 0x00;
  bRMBARequest[7] = 0x00;

  // <<< ReturnAECStatusChangeTime >>>
  _erh_au8AecStatus[0] = 0x70; // RAM address for Autotest Status.
  _erh_au8AecStatus[1] = 0x00;
  _erh_au8AecStatus[2] = 0xD0;
  _erh_au8AecStatus[3] = 0xCB;
  
  // <<< AEC functions >>>
  bReadAllAECsStatusRequest[0] = 0x22;
  bReadAllAECsStatusRequest[1] = 0xFE;
  bReadAllAECsStatusRequest[2] = 0x00;
}

/// <CORE_Logging>
// Each of the following test logging block name variables must have their corresponding block defined and configured.
// e.g. an .ASC logging block called "TestLoggingBlock" must be defined in the measurement setup and set to "Test trigger" mode.
void CORE_Logging()
{
   strncpy(cLogPath, "c:\\\\Temp\\\\", elcount(cLogPath)); // Default location for logs if no other path is provided before any test starts.
                                        // As a recommendation this value should be declared with the desired path at 
                                        // the start of each test module.
  
  // Each of the following test logging block name variables must have their corresponding block defined and configured.
  // e.g. an .ASC logging block called "TestLoggingBlock" must be defined in the measurement setup and set to "Test trigger" mode.
  strncpy(TestLoggingBlock, "TestLoggingBlock", elcount(TestLoggingBlock)); // Logging block used for .ASC logging.
  strncpy(TestCaseLogASC,   "TestCaseLogASC",   elcount(TestCaseLogASC));   // Logging block used for .ASC logging of the whole test case (Starts in PreTS, ends in PostTS).
  strncpy(TestCaseLogBLF,   "TestCaseLogBLF",   elcount(TestCaseLogBLF));   // Logging block used for .BLF logging of the whole test case (Starts in PreTS, ends in PostTS).
}

/// <CORE_Fault_Management/CORE_AECs>
void CORE_AEC_Names()
{
  // AEC names.
  strncpy(cAECName[bERR_ADC_OUT_OF_ORDER                  ], "ERR_ADC_OUT_OF_ORDER"           			   , 50);
  strncpy(cAECName[bERR_MOSFET_HIGH_SC                    ], "ERR_MOSFET_HIGH_SC"             			   , 50);
  strncpy(cAECName[bERR_MOSFET_LOW_SC                     ], "ERR_MOSFET_LOW_SC"              			   , 50);
  strncpy(cAECName[bERR_MOSFET_OC                         ], "ERR_MOSFET_OC"                  		     , 50);
  strncpy(cAECName[bERR_HALL_SENSOR                       ], "ERR_HALL_SENSOR"               			     , 50);
  strncpy(cAECName[bERR_ENABLE_OUT_OF_ORDER               ], "ERR_ENABLE_OUT_OF_ORDER"       			     , 50);
  strncpy(cAECName[bERR_HW_SELF_PROTECTION                ], "ERR_HW_SELF_PROTECTION"         			   , 50);
  strncpy(cAECName[bERR_HIGH_SIDE_SWITCH                  ], "ERR_HIGH_SIDE_SWITCH"           			   , 50);
  strncpy(cAECName[bERR_WARM_RESET                        ], "ERR_WARM_RESET"                 			   , 50);
  strncpy(cAECName[bERR_TEMPERATURE_SENSOR_FAILURE        ], "ERR_TEMPERATURE_SENSOR_FAILURE" 			   , 50);
  strncpy(cAECName[bERR_MOTOR_BLOCKED                     ], "ERR_MOTOR_BLOCKED"              			   , 50);
  strncpy(cAECName[bERR_MOTOR_IN_SC                       ], "ERR_MOTOR_IN_SC"                		     , 50);
  strncpy(cAECName[bERR_MOTOR_CURRENT                     ], "ERR_MOTOR_CURRENT"               			   , 50);
  strncpy(cAECName[bERR_MOTOR_DISCONNECTED                ], "ERR_MOTOR_DISCONNECTED"             	   , 50);
  strncpy(cAECName[bERR_MOTOR_ORDER                       ], "ERR_MOTOR_ORDER"                         , 50);
  strncpy(cAECName[bERR_SW_SELF_PROTECTION                ], "ERR_SW_SELF_PROTECTION"           	 	   , 50);
  strncpy(cAECName[bERR_TIMEOUT_PRESAFE                   ], "ERR_TIMEOUT_PRESAFE"                     , 50);
  strncpy(cAECName[bERR_TIMEOUT_BUCKLE                    ], "ERR_TIMEOUT_BUCKLE"                      , 50);
  strncpy(cAECName[bERR_IMPLAUSIBLE_DATA_PRESAFE          ], "ERR_IMPLAUSIBLE_DATA_PRESAFE"            , 50);
  strncpy(cAECName[bERR_IMPLAUSIBLE_DATA_IGNITION         ], "ERR_IMPLAUSIBLE_DATA_IGNITION"           , 50);
  strncpy(cAECName[bERR_IMPLAUSIBLE_DATA_BUCKLE           ], "ERR_IMPLAUSIBLE_DATA_BUCKLE"             , 50);
  strncpy(cAECName[bERR_BAT_PWR_OVER_VOLTAGE              ], "ERR_BAT_PWR_OVER_VOLTAGE"                , 50);
  strncpy(cAECName[bERR_BAT_PWR_UNDER_VOLTAGE             ], "ERR_BAT_PWR_UNDER_VOLTAGE"               , 50);
  strncpy(cAECName[bERR_BAT_PWR_UNDER_VOLTAGE_DURING_TENS ], "ERR_BAT_PWR_UNDER_VOLTAGE_DURING_TENS"   , 50);
  strncpy(cAECName[bERR_BAT_PWR_OVER_VOLTAGE_DURING_TENS  ], "ERR_ERR_BAT_PWR_OVER_VOLTAGE_DURING_TENS", 50);
  strncpy(cAECName[bERR_TIMEOUT_IGNITION                  ], "ERR_TIMEOUT_IGNITION"                    , 50);
  strncpy(cAECName[bERR_TIMEOUT_POWERTRAIN                ], "ERR_TIMEOUT_POWERTRAIN"                  , 50);
  strncpy(cAECName[bERR_IMPLAUSIBLE_DATA_POWERTRAIN       ], "ERR_IMPLAUSIBLE_DATA_POWERTRAIN"         , 50);
  strncpy(cAECName[bERR_IMPLAUSIBLE_DATA_ORC              ], "ERR_IMPLAUSIBLE_DATA_ORC"                , 50);
  strncpy(cAECName[bERR_TIMEOUT_BELT_HANDOVER_LEFT        ], "ERR_TIMEOUT_BELT_HANDOVER_LEFT"          , 50);
  strncpy(cAECName[bERR_TIMEOUT_BELT_HANDOVER_RIGHT       ], "ERR_TIMEOUT_BELT_HANDOVER_RIGHT"         , 50);
  strncpy(cAECName[bERR_TIMEOUT_API_INTERFACE             ], "ERR_TIMEOUT_API_INTERFACE"               , 50);
  strncpy(cAECName[bERR_LOW_FORCE_END_OF_LIFE             ], "ERR_LOW_FORCE_END_OF_LIFE"               , 50);
  strncpy(cAECName[bERR_COMFORT_END_OF_LIFE               ], "ERR_COMFORT_END_OF_LIFE"                 , 50);
  strncpy(cAECName[bERR_HIGH_FORCE_END_OF_LIFE            ], "ERR_HIGH_FORCE_END_OF_LIFE"              , 50);
  strncpy(cAECName[bERR_MAX_FORCE_END_OF_LIFE             ], "ERR_MAX_FORCE_END_OF_LIFE"               , 50);
  strncpy(cAECName[bERR_BAT_PWR_OVER_VOLTAGE_SYSTEM       ], "ERR_BAT_PWR_OVER_VOLTAGE_SYSTEM"         , 50);
  strncpy(cAECName[bERR_BAT_PWR_UNDER_VOLTAGE_SYSTEM      ], "ERR_BAT_PWR_UNDER_VOLTAGE_SYSTEM"        , 50);
  strncpy(cAECName[bERR_STEERING_CONFIGURATION            ], "ERR_STEERING_CONFIGURATION"              , 50);
}

/// <CORE_Fault_Management/CORE_AECs>
void CORE_AEC_Not_Executed_After_Reset()
{
   strncpy(cAEC_NotExecutedAfterReset[bERR_MOTOR_BLOCKED                     ], "ERR_MOTOR_BLOCKED"                         , 50);
   strncpy(cAEC_NotExecutedAfterReset[bERR_BAT_PWR_OVER_VOLTAGE_DURING_TENS  ], "ERR_ERR_BAT_PWR_OVER_VOLTAGE_DURING_TENS"  , 50);
   strncpy(cAEC_NotExecutedAfterReset[bERR_BAT_PWR_UNDER_VOLTAGE_DURING_TENS ], "ERR_BAT_PWR_UNDER_VOLTAGE_DURING_TENS"     , 50);
   strncpy(cAEC_NotExecutedAfterReset[bERR_TIMEOUT_BELT_HANDOVER_LEFT        ], "ERR_TIMEOUT_BELT_HANDOVER_LEFT"            , 50);
   strncpy(cAEC_NotExecutedAfterReset[bERR_TIMEOUT_BELT_HANDOVER_RIGHT       ], "ERR_TIMEOUT_BELT_HANDOVER_RIGHT"           , 50);
}

/// <CORE_Fault_Management/CORE_DTCs>
void CORE_DTC_Names()
{
  strncpy(cDTCName[DTC_HARDWARE                         ], "ERR_HARDWARE"                         , 50);
  strncpy(cDTCName[DTC_TEMPERATURE_SELF_PROTECTION      ], "ERR_TEMPERATURE_SELF_PROTECTION"      , 50);
  strncpy(cDTCName[DTC_MOTOR                            ], "ERR_MOTOR"                            , 50);
  strncpy(cDTCName[DTC_BAT_PWR_UNDER_VOLTAGE            ], "ERR_BAT_PWR_UNDER_VOLTAGE"            , 50);
  strncpy(cDTCName[DTC_BAT_PWR_OVER_VOLTAGE             ], "ERR_BAT_PWR_OVER_VOLTAGE"             , 50);
  strncpy(cDTCName[DTC_BAT_PWR_UNDER_VOLTAGE_DURING_TENS], "ERR_BAT_PWR_UNDER_VOLTAGE_DURING_TENS", 50);
  strncpy(cDTCName[DTC_BAT_PWR_OVER_VOLTAGE_DURING_TENS ], "ERR_BAT_PWR_OVER_VOLTAGE_DURING_TENS" , 50);
  strncpy(cDTCName[DTC_WARM_RESET                       ], "ERR_WARM_RESET"                       , 50);
  strncpy(cDTCName[DTC_TENSIONING_END_OF_LIFE           ], "ERR_TENSIONING_END_OF_LIFE"           , 50);
  strncpy(cDTCName[DTC_COMFORT_END_OF_LIFE              ], "ERR_COMFORT_END_OF_LIFE"              , 50);
  strncpy(cDTCName[DTC_TIMEOUT_PRESAFE                  ], "ERR_TIMEOUT_PRESAFE"                  , 50);
  strncpy(cDTCName[DTC_TIMEOUT_BUCKLE                   ], "ERR_TIMEOUT_BUCKLE"                   , 50);
  strncpy(cDTCName[DTC_IMPLAUSIBLE_DATA_PRESAFE         ], "ERR_IMPLAUSIBLE_DATA_PRESAFE"         , 50);
  strncpy(cDTCName[DTC_IMPLAUSIBLE_DATA_IGNITION        ], "ERR_IMPLAUSIBLE_DATA_IGNITION"        , 50);
  strncpy(cDTCName[DTC_IMPLAUSIBLE_DATA_BUCKLE          ], "ERR_IMPLAUSIBLE_DATA_BUCKLE"          , 50);
  strncpy(cDTCName[bUnknownDTC_1                        ], "COM_ERR: Incorrect data."             , 50);
  strncpy(cDTCName[bUnknownDTC_2                        ], "COM_ERR: Missing message."            , 50);
  strncpy(cDTCName[DTC_BAT_PWR_OVER_VOLTAGE_SYSTEM      ], "ERR_BAT_PWR_OVER_VOLTAGE_SYSTEM"      , 50);
  strncpy(cDTCName[DTC_BAT_PWR_UNDER_VOLTAGE_SYSTEM     ], "ERR_BAT_PWR_UNDER_VOLTAGE_SYSTEM"     , 50);
  strncpy(cDTCName[DTC_CANSM_E_BUS_OFF                  ], "ERR_CANSM_E_BUS_OFF"                  , 50);
  strncpy(cDTCName[DTC_TIMEOUT_IGNITION                 ], "ERR_TIMEOUT_IGNITION"                 , 50);
  strncpy(cDTCName[DTC_TIMEOUT_POWERTRAIN               ], "ERR_TIMEOUT_POWERTRAIN "              , 50);
  strncpy(cDTCName[DTC_IMPLAUSIBLE_DATA_POWERTRAIN      ], "ERR_IMPLAUSIBLE_DATA_POWERTRAIN"      , 50);
  strncpy(cDTCName[DTC_IMPLAUSIBLE_DATA_ORC             ], "ERR_IMPLAUSIBLE_DATA_ORC"             , 50);
  strncpy(cDTCName[DTC_TIMEOUT_BELT_HANDOVER_LEFT       ], "ERR_TIMEOUT_BELT_HANDOVER_LEFT"       , 50);
  strncpy(cDTCName[DTC_TIMEOUT_BELT_HANDOVER_RIGHT      ], "ERR_TIMEOUT_BELT_HANDOVER_RIGHT"      , 50);
  strncpy(cDTCName[DTC_MAX_FORCE_END_OF_LIFE            ], "ERR_MAX_FORCE_END_OF_LIFE"            , 50);
  strncpy(cDTCName[DTC_STEERING_CONFIGURATION           ], "ERR_STEERING_CONFIGURATION"           , 50);
}

/// <CORE_Fault_Management/CORE_DTCs>
void CORE_DTC_AEC_Association()
{
  bDTCID[bERR_HIGH_SIDE_SWITCH                 ] = DTC_HARDWARE;
  bDTCID[bERR_ENABLE_OUT_OF_ORDER              ] = DTC_HARDWARE;
  bDTCID[bERR_MOSFET_HIGH_SC                   ] = DTC_HARDWARE;
  bDTCID[bERR_MOSFET_LOW_SC                    ] = DTC_HARDWARE;
  bDTCID[bERR_MOTOR_DISCONNECTED               ] = DTC_HARDWARE;
  bDTCID[bERR_MOSFET_OC                        ] = DTC_HARDWARE;
  bDTCID[bERR_HALL_SENSOR                      ] = DTC_HARDWARE;
  bDTCID[bERR_MOTOR_IN_SC                      ] = DTC_HARDWARE;
  
  bDTCID[bERR_HW_SELF_PROTECTION               ] = DTC_TEMPERATURE_SELF_PROTECTION;
  bDTCID[bERR_SW_SELF_PROTECTION               ] = DTC_TEMPERATURE_SELF_PROTECTION;

  bDTCID[bERR_MOTOR_CURRENT                    ] = DTC_MOTOR;
  bDTCID[bERR_MOTOR_BLOCKED                    ] = DTC_MOTOR;
  bDTCID[bERR_MOTOR_ORDER                      ] = DTC_MOTOR;
  
  bDTCID[bERR_BAT_PWR_UNDER_VOLTAGE            ] = DTC_BAT_PWR_UNDER_VOLTAGE;
  bDTCID[bERR_BAT_PWR_OVER_VOLTAGE             ] = DTC_BAT_PWR_OVER_VOLTAGE;
  bDTCID[bERR_BAT_PWR_UNDER_VOLTAGE_DURING_TENS] = DTC_BAT_PWR_UNDER_VOLTAGE_DURING_TENS;
  bDTCID[bERR_BAT_PWR_OVER_VOLTAGE_DURING_TENS ] = DTC_BAT_PWR_OVER_VOLTAGE_DURING_TENS;
  
  bDTCID[bERR_WARM_RESET                       ] = DTC_WARM_RESET;
  
  bDTCID[bERR_HIGH_FORCE_END_OF_LIFE           ] = DTC_TENSIONING_END_OF_LIFE;
  bDTCID[bERR_LOW_FORCE_END_OF_LIFE            ] = DTC_TENSIONING_END_OF_LIFE;
  bDTCID[bERR_COMFORT_END_OF_LIFE              ] = DTC_COMFORT_END_OF_LIFE;
  
  bDTCID[bERR_TIMEOUT_PRESAFE                  ] = DTC_TIMEOUT_PRESAFE;
  bDTCID[bERR_TIMEOUT_BUCKLE                   ] = DTC_TIMEOUT_BUCKLE;
  bDTCID[bERR_IMPLAUSIBLE_DATA_PRESAFE         ] = DTC_IMPLAUSIBLE_DATA_PRESAFE;
  bDTCID[bERR_IMPLAUSIBLE_DATA_IGNITION        ] = DTC_IMPLAUSIBLE_DATA_IGNITION;
  bDTCID[bERR_IMPLAUSIBLE_DATA_BUCKLE          ] = DTC_IMPLAUSIBLE_DATA_BUCKLE;
  
  bDTCID[bUnknownDTC_1                         ] = 0xD12081; // R3.0 DTCs with no requirements
  bDTCID[bUnknownDTC_2                         ] = 0xD12087;
  
  bDTCID[bERR_BAT_PWR_OVER_VOLTAGE_SYSTEM      ] = DTC_BAT_PWR_OVER_VOLTAGE_SYSTEM;
  bDTCID[bERR_BAT_PWR_UNDER_VOLTAGE_SYSTEM     ] = DTC_BAT_PWR_UNDER_VOLTAGE_SYSTEM;
  
  bDTCID[bERR_CANSM_E_BUS_OFF                  ] = DTC_CANSM_E_BUS_OFF; // BUS OFF has not AEC id. This variable is used for easier use of functions.
  bDTCID[bERR_TIMEOUT_IGNITION                 ] = DTC_TIMEOUT_IGNITION;
  bDTCID[bERR_TIMEOUT_POWERTRAIN               ] = DTC_TIMEOUT_POWERTRAIN;
  bDTCID[bERR_IMPLAUSIBLE_DATA_POWERTRAIN      ] = DTC_IMPLAUSIBLE_DATA_POWERTRAIN;
  bDTCID[bERR_IMPLAUSIBLE_DATA_ORC             ] = DTC_IMPLAUSIBLE_DATA_ORC;
  bDTCID[bERR_TIMEOUT_BELT_HANDOVER_LEFT       ] = DTC_TIMEOUT_BELT_HANDOVER_LEFT;
  bDTCID[bERR_TIMEOUT_BELT_HANDOVER_RIGHT      ] = DTC_TIMEOUT_BELT_HANDOVER_RIGHT;
  bDTCID[bERR_MAX_FORCE_END_OF_LIFE            ] = DTC_MAX_FORCE_END_OF_LIFE;
  bDTCID[bERR_STEERING_CONFIGURATION           ] = DTC_STEERING_CONFIGURATION;
}

/// <CORE_Fault_Management/CORE_DTCs>
void CORE_Fault_Management_DTCs()
{
  // Status mask used to read DTCs.
  bRDTCBST_StatusMask            = 0x21; // CheckDTCStatus().
  
  bRDTCBST_StatusMask_Init       = 0x21; // CheckDTCPresenceInBenchInit().
  
  bRDTCBST_StatusMask_AfterClear = 0x21; // CheckDTCPresenceAfterClear().
  
  bDTC_AvailableStatusMask       = 0x39; // CheckDTCStatus(char cDescription[], dword dDTC, byte bMask, char cPresence[]);
  
  // .CDD qualifiers:
  strncpy(PR_DTCAndStatusRecord                             , "DTCAndStatusRecord"                            , elcount(PR_DTCAndStatusRecord));
  strncpy(PR_DTCRecord                                      , "DTCRecord"                                     , elcount(PR_DTCRecord));
  strncpy(PR_StatusOfDTC                                    , "StatusOfDTC"                                   , elcount(PR_StatusOfDTC));
  strncpy(PR_StatusOfDTC_WarningIndicatorRequested          , "StatusOfDTC.WarningIndicatorRequested"         , elcount(PR_StatusOfDTC_WarningIndicatorRequested));
  strncpy(PR_StatusOfDTC_TestNotCompletedThisOperationCycle , "StatusOfDTC.TestNotCompletedThisOperationCycle", elcount(PR_StatusOfDTC_TestNotCompletedThisOperationCycle));
  strncpy(PR_StatusOfDTC_TestFailedSinceLastClear           , "StatusOfDTC.TestFailedSinceLastClear"          , elcount(PR_StatusOfDTC_TestFailedSinceLastClear));
  strncpy(PR_StatusOfDTC_TestNotCompletedSinceLastClear     , "StatusOfDTC.TestNotCompletedSinceLastClear"    , elcount(PR_StatusOfDTC_TestNotCompletedSinceLastClear));
  strncpy(PR_StatusOfDTC_ConfirmedDTC                       , "StatusOfDTC.ConfirmedDTC"                      , elcount(PR_StatusOfDTC_ConfirmedDTC));
  strncpy(PR_StatusOfDTC_PendingDTC                         , "StatusOfDTC.PendingDTC"                        , elcount(PR_StatusOfDTC_PendingDTC));
  strncpy(PR_StatusOfDTC_TestFailedThisOperationCycle       , "StatusOfDTC.TestFailedThisOperationCycle"      , elcount(PR_StatusOfDTC_TestFailedThisOperationCycle));
  strncpy(PR_StatusOfDTC_TestFailed                         , "StatusOfDTC.TestFailed"                        , elcount(PR_StatusOfDTC_TestFailed));
  
  strncpy(PR_DTCRecordExtended                                      , "DTCRecord"                                     , elcount(PR_DTCRecordExtended));
  strncpy(PR_StatusOfDTCExtended                                    , "StatusOfDtc"                                   , elcount(PR_StatusOfDTCExtended));
  strncpy(PR_StatusOfDTCExtended_WarningIndicatorRequested          , "StatusOfDTC.WarningIndicatorRequested"         , elcount(PR_StatusOfDTCExtended_WarningIndicatorRequested));
  strncpy(PR_StatusOfDTCExtended_TestNotCompletedThisOperationCycle , "StatusOfDTC.TestNotCompletedThisOperationCycle", elcount(PR_StatusOfDTCExtended_TestNotCompletedThisOperationCycle));
  strncpy(PR_StatusOfDTCExtended_TestFailedSinceLastClear           , "StatusOfDTC.TestFailedSinceLastClear"          , elcount(PR_StatusOfDTCExtended_TestFailedSinceLastClear));
  strncpy(PR_StatusOfDTCExtended_TestNotCompletedSinceLastClear     , "StatusOfDTC.TestNotCompletedSinceLastClear"    , elcount(PR_StatusOfDTCExtended_TestNotCompletedSinceLastClear));
  strncpy(PR_StatusOfDTCExtended_ConfirmedDTC                       , "StatusOfDTC.ConfirmedDTC"                      , elcount(PR_StatusOfDTCExtended_ConfirmedDTC));
  strncpy(PR_StatusOfDTCExtended_PendingDTC                         , "StatusOfDTC.PendingDTC"                        , elcount(PR_StatusOfDTCExtended_PendingDTC));
  strncpy(PR_StatusOfDTCExtended_TestFailedThisOperationCycle       , "StatusOfDTC.TestFailedThisOperationCycle"      , elcount(PR_StatusOfDTCExtended_TestFailedThisOperationCycle));
  strncpy(PR_StatusOfDTCExtended_TestFailed                         , "StatusOfDTC.TestFailed"                        , elcount(PR_StatusOfDTCExtended_TestFailed));
  
  strncpy(PR_DTCAvailabilityMask_WarningIndicatorRequested          , "DTCAvailabilityMask.WarningIndicatorRequested"         , elcount(PR_DTCAvailabilityMask_WarningIndicatorRequested));
  strncpy(PR_DTCAvailabilityMask_TestNotCompletedThisOperationCycle , "DTCAvailabilityMask.TestNotCompletedThisOperationCycle", elcount(PR_DTCAvailabilityMask_TestNotCompletedThisOperationCycle));
  strncpy(PR_DTCAvailabilityMask_TestFailedSinceLastClear           , "DTCAvailabilityMask.TestFailedSinceLastClear"          , elcount(PR_DTCAvailabilityMask_TestFailedSinceLastClear));
  strncpy(PR_DTCAvailabilityMask_TestNotCompletedSinceLastClear     , "DTCAvailabilityMask.TestNotCompletedSinceLastClear"    , elcount(PR_DTCAvailabilityMask_TestNotCompletedSinceLastClear));
  strncpy(PR_DTCAvailabilityMask_ConfirmedDTC                       , "DTCAvailabilityMask.ConfirmedDTC"                      , elcount(PR_DTCAvailabilityMask_ConfirmedDTC));
  strncpy(PR_DTCAvailabilityMask_PendingDTC                         , "DTCAvailabilityMask.PendingDTC"                        , elcount(PR_DTCAvailabilityMask_PendingDTC));
  strncpy(PR_DTCAvailabilityMask_TestFailedThisOperationCycle       , "DTCAvailabilityMask.TestFailedThisOperationCycle"      , elcount(PR_DTCAvailabilityMask_TestFailedThisOperationCycle));
  strncpy(PR_DTCAvailabilityMask_TestFailed                         , "DTCAvailabilityMask.TestFailed_1Bit"                   , elcount(PR_DTCAvailabilityMask_TestFailed));
  
  strncpy(REQ_DTCStatusMask                                    , "DTCStatusMask"                                   , elcount(REQ_DTCStatusMask));
  strncpy(REQ_DTCStatusMask_WarningIndicatorRequested          , "DTCStatusMask.WarningIndicatorRequested"         , elcount(REQ_DTCStatusMask_WarningIndicatorRequested));
  strncpy(REQ_DTCStatusMask_TestNotCompletedThisOperationCycle , "DTCStatusMask.TestNotCompletedThisOperationCycle", elcount(REQ_DTCStatusMask_TestNotCompletedThisOperationCycle));
  strncpy(REQ_DTCStatusMask_TestFailedSinceLastClear           , "DTCStatusMask.TestFailedSinceLastClear"          , elcount(REQ_DTCStatusMask_TestFailedSinceLastClear));
  strncpy(REQ_DTCStatusMask_TestNotCompletedSinceLastClear     , "DTCStatusMask.TestNotCompletedSinceLastClear"    , elcount(REQ_DTCStatusMask_TestNotCompletedSinceLastClear));
  strncpy(REQ_DTCStatusMask_ConfirmedDTC                       , "DTCStatusMask.ConfirmedDTC"                      , elcount(REQ_DTCStatusMask_ConfirmedDTC));
  strncpy(REQ_DTCStatusMask_PendingDTC                         , "DTCStatusMask.PendingDTC"                        , elcount(REQ_DTCStatusMask_PendingDTC));
  strncpy(REQ_DTCStatusMask_TestFailedThisOperationCycle       , "DTCStatusMask.TestFailedThisOperationCycle"      , elcount(REQ_DTCStatusMask_TestFailedThisOperationCycle));
  strncpy(REQ_DTCStatusMask_TestFailed                         , "DTCStatusMask.TestFailed"                        , elcount(REQ_DTCStatusMask_TestFailed));
  
  // <<< CheckDTCPresence >>>
  bCheckDTCPresenceRequest[0] = 0x19;
  bCheckDTCPresenceRequest[1] = 0x02;
  bCheckDTCPresenceRequest[2] = 0x00;
  
    // <<< Report DTC by extended data >>>
  bReportDTCExtendedDataByDTCNbrRequest[0] = 0x19;
  bReportDTCExtendedDataByDTCNbrRequest[1] = 0x06;
  
  // <<< Report supported DTCs >>>
  bReportSupportedDTCsRequest[0] = 0x19;
  bReportSupportedDTCsRequest[1] = 0x0A;
  
  // <<< Report number of DTCs by status mask request >>>
  bReportNbrOfDTCByStatusMaskRequest[0] = 0x19;
  bReportNbrOfDTCByStatusMaskRequest[1] = 0x01;
  bReportNbrOfDTCByStatusMaskRequest[2] = 0x00;
}

/// <CORE_Test_Traceability>
void CORE_Test_Traceability()
{
  // <<< Read SW version >>>
  bReadSWVersionRequest[0] = 0x22;
  bReadSWVersionRequest[1] = 0xF1;
  bReadSWVersionRequest[2] = 0x51;
  
  // <<< CheckSWVersion >>> and <<< GetSWVersion >>>
  strncpy(cSession_CheckSWVersion, "supplier"      , elcount(cSession_CheckSWVersion)); // Needed Session: Set to "none" if no special session is needed.
  strncpy(cKeepHexFormat         , "true"          , elcount(cKeepHexFormat)); // If "cSwVersion" is in HEX format (e.g "0x16 0x0B 0x00"), set to "true", otherwise set to "false".
}

// These objects are not used in the CORE functions.
// Their purpose is to avoid declaring diagnostic objects for specific test cases.
void CORE_Init_DiagObjects()
{
  // EnterDiagnosticSession
  dDefaultSessionRequest.Resize(elcount(bSessionControlRequests[0]));
  dDefaultSessionRequest.SetPrimitiveData(bSessionControlRequests[0], elcount(bSessionControlRequests[0]));
  
  dExtendedSessionRequest.Resize(elcount(bSessionControlRequests[1]));
  dExtendedSessionRequest.SetPrimitiveData(bSessionControlRequests[1], elcount(bSessionControlRequests[1]));
  
  dProgrammingSessionRequest.Resize(elcount(bSessionControlRequests[2]));
  dProgrammingSessionRequest.SetPrimitiveData(bSessionControlRequests[2], elcount(bSessionControlRequests[2]));
  
  dDevelopmentSessionRequest.Resize(elcount(bSessionControlRequests[3]));
  dDevelopmentSessionRequest.SetPrimitiveData(bSessionControlRequests[3], elcount(bSessionControlRequests[3]));
  
  dSupplierSessionRequest.Resize(elcount(bSessionControlRequests[4]));
  dSupplierSessionRequest.SetPrimitiveData(bSessionControlRequests[4], elcount(bSessionControlRequests[4]));
  
  // ResetECU
  dHardResetRequest.Resize(elcount(bHardResetRequest));
  dHardResetRequest.SetPrimitiveData(bHardResetRequest, elcount(bHardResetRequest));
  
  dSoftResetRequest.Resize(elcount(bSoftResetRequest));
  dSoftResetRequest.SetPrimitiveData(bSoftResetRequest, elcount(bSoftResetRequest));
  
  // Read SW version
  dReadSWVersionRequest.Resize(elcount(bReadSWVersionRequest));
  dReadSWVersionRequest.SetPrimitiveData(bReadSWVersionRequest, elcount(bReadSWVersionRequest));
  
  // RMBA
  dReadMemoryByAddressRequest.Resize(elcount(bRMBARequest));
  dReadMemoryByAddressRequest.SetPrimitiveData(bRMBARequest, elcount(bRMBARequest));
  
  // WMBA
  dWriteMemoryByAddressRequest.Resize(elcount(bRMBARequest));
  dWriteMemoryByAddressRequest.SetPrimitiveData(bRMBARequest, elcount(bRMBARequest));

  // Clear All DTCs
  dClearAllDTCsRequest.Resize(elcount(bClearAllRequest));
  dClearAllDTCsRequest.SetPrimitiveData(bClearAllRequest, elcount(bClearAllRequest));
  
  // Read All AECs
  dReadAllAECsStatusRequest.Resize(elcount(bReadAllAECsStatusRequest));
  dReadAllAECsStatusRequest.SetPrimitiveData(bReadAllAECsStatusRequest, elcount(bReadAllAECsStatusRequest));
  
  // Read DTCs
  dReportDTCByStatusMaskRequest.Resize(elcount(bCheckDTCPresenceRequest));
  dReportDTCByStatusMaskRequest.SetPrimitiveData(bCheckDTCPresenceRequest, elcount(bCheckDTCPresenceRequest));
  
  dReportDTCExtendedDataByDTCNbrRequest.Resize(elcount(bReportDTCExtendedDataByDTCNbrRequest));
  dReportDTCExtendedDataByDTCNbrResponse.SetPrimitiveData(bReportDTCExtendedDataByDTCNbrRequest, elcount(bReportDTCExtendedDataByDTCNbrRequest));
  
  dReportNbrOfDTCByStatusMaskRequest.Resize(elcount(bReportNbrOfDTCByStatusMaskRequest));
  dReportNbrOfDTCByStatusMaskRequest.SetPrimitiveData(bReportNbrOfDTCByStatusMaskRequest, elcount(bReportNbrOfDTCByStatusMaskRequest));
  
  dReportSupportedDTCsRequest.Resize(elcount(bReportSupportedDTCsRequest));
  dReportSupportedDTCsRequest.SetPrimitiveData(bReportNbrOfDTCByStatusMaskRequest, elcount(bReportSupportedDTCsRequest));
  
  // Lock / Unlock ECU.
  dUnlockECURequest.Resize(elcount(bUnlockECU));
  dUnlockECURequest.SetPrimitiveData(bUnlockECU, elcount(bUnlockECU));
  
  dGetECULockStateRequest.Resize(elcount(bGetECULockState));
  dGetECULockStateRequest.SetPrimitiveData(bGetECULockState, elcount(bGetECULockState));
  
  //  Process mode.
  dProcessModeStartRequest.Resize(elcount(bProcessModeStartRequest));
  dProcessModeStartRequest.SetPrimitiveData(bProcessModeStartRequest, elcount(bProcessModeStartRequest));
  
  dProcessModeStopRequest.Resize(elcount(bProcessModeStopRequest));
  dProcessModeStopRequest.SetPrimitiveData(bProcessModeStopRequest, elcount(bProcessModeStopRequest));
  
  dProcessModeRequestResRequest.Resize(elcount(bProcessModeRequestResRequest));
  dProcessModeRequestResRequest.SetPrimitiveData(bProcessModeRequestResRequest, elcount(bProcessModeRequestResRequest));
}
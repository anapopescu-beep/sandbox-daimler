/*@!Encoding:1252*/
includes
{
  
}

variables
{
  char DDS_dataBuf_Symbolic[8192];
  char d[4096]; // temporrary buffer for debug messages
  long bytesCopied = 0;
  
  //// Certificate data
  byte DDS_Backend_certKeyID[20];// = {0x51,0x82,0xB1,0xC2,0xD6,0x8C,0xF7,0x9A,0x52,0xEC,0x83,0x4A,0x1A,0x80,0x82,0x8F,0x0C,0x53,0x58,0xD4};
  byte DDS_Default_VariantCoding_Serial[4];// = {0x0D,0x00,0x00,0x01};
  dword DDS_Default_VariantCoding_SerialLength = 4; 
  
  //// Session change
  diagRequest "Extended_Start" Req_SessionExtended;
  diagResponse "Extended_Start" Resp_SessionExtended;
  
  //// VINDataIdentifier_Read
  byte vinRespData[32];
  byte vinRespSize;
  diagRequest "VINDataIdentifier_Read" Req_VINDataIdentifier_Read;
  diagResponse "VINDataIdentifier_Read" Resp_VINDataIdentifier_Read;
  
  //// Data_Verification_Certificate_Start
  diagRequest "Evaluate_Data_Verification_Certificate_Start" Req_Evaluate_Data_Verification_Certificate_Start;
  diagResponse "Evaluate_Data_Verification_Certificate_Start" Resp_Evaluate_Data_Verification_Certificate_Start;
    
  //// Coding Requests
  byte codingDataReq[4096];
  long codingDataReqSize;
  diagRequest "Activate_SAR_Data_Storage_Write" Req_WriteData_Activate_SAR_Data_Storage_Write;
  diagResponse "Activate_SAR_Data_Storage_Write" Resp_WriteData_Activate_SAR_Data_Storage_Write;

  byte codingDataBuffer[4096];
  long codingDataBufferMaxSize = 4096;
  long copiedBytesCodingDataBuffer = 0;
  
  //// Calibration_Identifications_CAL_ID
  byte calidReq[4096];
  long calidReqSize;
  diagRequest "Calibration_Identifications_CAL_ID_Write" Req_Calibration_Identifications_CAL_ID_Write;
  diagResponse "Calibration_Identifications_CAL_ID_Write" Resp_Calibration_Identifications_CAL_ID_Write;
  
  //// Array for coding data
  char signatureSymbolic[1024];
  byte hashData[4096];
  long hashDataSize;
  diagRequest "Verify_Signature_Start" Req_Verify_Signature_Start;
  diagResponse "Verify_Signature_Start" Resp_Verify_Signature_Start;
}

on start
{
  char targetName[400];
  
  // Init DiagTarget by ECU Name
  SetDiagTargetByECU();
  
  // Init Panel
  PrintSecVarCodingState();
  SetSecVarCodingSequenceLED();
  ResetPanelData();
}

// Register a new ECU as Diag Target
on sysvar_update sysvar::SecVarCodingControl::Target
{
    char targetName[400];
    long bytesCopied;
  
    sysGetVariableString("SecVarCodingControl","Target",targetName,elCount(targetName));
    sysSetVariableString("LocalAuthentication","DiagTarget",targetName);
  
    SetDiagTargetByECU();
}

// utility function to set new DiagTarget
void SetDiagTargetByECU()
{
  char targetName[400];
  
  if( @sysvar::SecVarCodingControl::SecVarCodingSequence == Standby)
  {
    sysGetVariableString("SecVarCodingControl","Target",targetName,elCount(targetName));
    if( diagSetTarget(targetName) == 0 )
    {
      write("Current diag target node is %s",targetName );
      enableControl("SecVarCodingControl", "Button_StartCoding", 1);
      @sysvar::SecVarCodingPanel::LED_Target = 1;
    }
    else
    {
      enableControl("SecVarCodingControl", "Button_StartCoding", 0);
      @sysvar::SecVarCodingPanel::LED_Target = 0;
    }
  }
  else
  {
    _TestStepFail("Change of Diag Target is only possible outside of an active coding sequence");
  }
}

// Panel handler for Button Start Coding
on sysvar_update sysvar::SecVarCodingPanel::Button_CodingStart
{
  if(@this == 1)
  {
    // Target string is set during diag authentication
    // check, if this has been done before
    if (CheckCurrentDiagTarget() == 1)
    {    
      @sysvar::SecVarCodingControl::SecVarCodingSequence = StartCoding;
    }
    else
    {
      _TestStepFail("Could not start variant coding. Execute diag authentication before.");
    }
  }
}


// Actions for change of state of coding sequence
on sysvar_update sysvar::SecVarCodingControl::SecVarCodingSequence
{
  SetSecVarCodingSequenceLED();
  switch( @this )
  {
    case StartCoding:
      ResetPanelData();
      ReadVIN();
      //EnterExtendedSession(); // Added change to extended session
      copiedBytesCodingDataBuffer = 0;
      enableControl("SecVarCodingControl", "Button_StartCoding", 0);
      enableControl("SecVarCodingControl", "Button_CancelSequence",1);
      break;
    case WriteData:
      enableControl("SecVarCodingControl", "Button_FinishCoding", 1);
      break;
    case Standby:
      enableControl("SecVarCodingControl", "Button_StartCoding", 1);
      break;
    case FinishCoding:
      WriteCalibration_Identification();
      enableControl("SecVarCodingControl", "Button_CancelSequence",0);
      enableControl("SecVarCodingControl", "Button_FinishCoding", 0);
      break;
    default:
      break;
  }
  PrintSecVarCodingState();
}


// Step 1aa (added compared to the example)
// Change to extended session because it's always needed to write the Calibration ID
// and if it's done automatically, this minimizes fault usage
void EnterExtendedSession()
{
  Req_SessionExtended.SendRequest();
}

// Step 1ab: 
// Waits until the Ecu has responded on the Service "Extended"
/*on diagResponse Extended_Start
{
  if( CheckCurrentDiagTarget() == 1 )
  {
    if( diagGetResponseCode (this) == -1 ) //pos
    {  
      ReadVIN();
    }
    else
    {
      // if entering the extended session doesn't work, the tester is probably not 
      // authenticated -> cancel automatically
      ResetPanelData();
      @sysvar::SecVarCodingControl::SecVarCodingSequence = Standby;
      _TestStepFail("Step 1ab: Entering extended session failed. Try to authenticate again.");
    }
  } 
  else
  {
    _TestStepFail("Mismatch between target ECU and response ECU");
  }    
}

*/
// Step 1a: 
// Send a Diagnostic Request to Read the VIN currently stored in the ECU using the
// Service "VINDataIdentifier" (DID 0xF190) 
void ReadVIN()
{
  Req_VINDataIdentifier_Read.SendRequest();
}

// Step 1b: 
// Waits until the Ecu has responded on the Service "VINDataIdentifier"
on diagResponse VINDataIdentifier_Read
{
  int VINLength = 17;
  byte vin[17];
  
  if(@sysvar::SecVarCodingControl::SecVarCodingSequence!=Standby)
  {
    if( CheckCurrentDiagTarget() == 1 )
    {
      if( diagGetResponseCode (this) == -1 ) //pos
      {
        vinRespSize = diagGetPrimitiveData(this, vinRespData, elcount(vinRespData));
        memcpy_off(vin, 0, vinRespData, 3, VINLength);
        @sysvar::SecVarCodingPanel::ECU_VIN_Length = VINLength;
        write("Step 1b: VINDataIdentifier_Read vinRespSize=%i",vinRespSize);
        sysSetVariableData("SecVarCodingPanel","ECU_VIN",vin,VINLength);
        Evaluate_Data_Verification_Certificate_Start_Seq1();
      }
    }
    else
    {
      _TestStepFail("Mismatch between target ECU and response ECU ");
    }
  }
}

// Step 2a: 
// Prepare the Diagnostic Routine to transmit the Certificate for Signature Verification 
// to the ECU using the Service "Evaluate Signature Verification Key Certificate" (DID 0x0262)
// Reads the certificate at ZenZefi with serial and backend ID
void Evaluate_Data_Verification_Certificate_Start_Seq1()
{
  sysGetVariableData("Backend", "Authority_Key_ID", DDS_Backend_certKeyID, bytesCopied);// sync from panel
  if( bytesCopied != 20)
    { 
      _TestStepFail("Step 2a: The exspected number of bytes for Authority_Key_ID could not be read.");
      return;
    }
  sysGetVariableData("Backend", "VarCodingSerial", DDS_Default_VariantCoding_Serial, bytesCopied);// sync from panel
  if( bytesCopied != 4)
  { 
    _TestStepFail("Step 2a: The exspected number of bytes for VarCodingSerial could not be read.");
    return;
  }
  GetCertificateAsync(DDS_Backend_certKeyID, elcount(DDS_Backend_certKeyID),
                      DDS_Default_VariantCoding_Serial, DDS_Default_VariantCoding_SerialLength);
}

// Step 2b: 
// ZenZefi: Certifcate Read is finished
long GetCertificateCompleted(long statusCode,  char errorMessage[], byte certificate[]) 
{
  if (statusCode != 0 && statusCode != 200)
  {
    snprintf(d, elcount(d), "Step 2b: Cannot get certificate (Error message: %s)", errorMessage);
    sysSetVariableString("SecVarCodingPanel","MessageString",d);
    _TestStepFail(d);
    @sysvar::SecVarCodingControl::SecVarCodingSequence = Standby; // go back into initial state
  }
  else
  {
    DDS_byte2HexString(certificate, elCount(certificate), DDS_dataBuf_Symbolic);
  
    Evaluate_Data_Verification_Certificate_Start_Seq2();
  }
  return statusCode;
}

// Step 2c: 
// Send the Diagnostic Routine to transmit the Certificate for Signature Verification 
// to the ECU using the Service "Evaluate Signature Verification Key Certificate" (DID 0x0262)
void Evaluate_Data_Verification_Certificate_Start_Seq2()
{
  DiagSetParameter(Req_Evaluate_Data_Verification_Certificate_Start, "Data_Verification_Certificate", DDS_dataBuf_Symbolic);
  Req_Evaluate_Data_Verification_Certificate_Start.SendRequest();
}

// Step 2d: 
// Waits until the Ecu has responded on the Service "Evaluate Signature Verification Key Certificate"
on diagResponse Evaluate_Data_Verification_Certificate_Start
{
  
  if( CheckCurrentDiagTarget() == 1 )
  {
    if( diagGetResponseCode (this) == -1 ) //pos
    {
      @sysvar::SecVarCodingControl::SecVarCodingSequence = WriteData;
    }
    else
    {
      snprintf(d, elcount(d), "No positive response received, responseCode=%i",diagGetResponseCode (this) );
      _TestStepFail(d);
    }
  }
  else
  {
    _TestStepFail("Mismatch between traget ECU and response ECU ");
  }
  
  
}

// Step 3a: 
// Write Secure Coding Data using WriteDataByIdentifier for "Activate_SAR_Data_Storage_Write"

on sysvar_update sysvar::SecVarCodingControl::CodingVariantWriteData
{
  byte tmpCodingBuffer[2048];
  long copiedBytes;
  
  if( @sysvar::SecVarCodingControl::SecVarCodingSequence == WriteData)
  {
    // get data of writeDataByIdentifier
    sysGetVariableData("SecVarCodingControl","CodingVariantWriteData",tmpCodingBuffer,copiedBytes);
    memcpy_off(codingDataBuffer,copiedBytesCodingDataBuffer,tmpCodingBuffer,1,@sysvar::SecVarCodingControl::CodingVariantWriteDataLength-1);
    copiedBytesCodingDataBuffer += @sysvar::SecVarCodingControl::CodingVariantWriteDataLength-1;
    // update buffer for hash
    sysSetVariableData("SecVarCodingControl","CumulatedCodingBufferVariantData",codingDataBuffer,copiedBytesCodingDataBuffer);
    @sysvar::SecVarCodingControl::CumulatedCodingBufferVariantDataLength = copiedBytesCodingDataBuffer;
  }
}

// Step 4a: 
// Send the Diagnostic Service to transmit the Calibration ID (=CAL-ID = SCN) to the ECU 
// using the Service "Calibration Identifications" (CALID) (DID 0xF804)
void WriteCalibration_Identification()
{
  byte tmpCalidBuffer[20];
  long copiedBytes;
  
  // Update of CAL ID / Numbor of items
  DiagResize(Req_Calibration_Identifications_CAL_ID_Write, 20);
  diagSetParameterRawTo(Req_Calibration_Identifications_CAL_ID_Write,"Calibration_Identifications_CAL_ID/Number_of_data_items",0x00,1);
  diagSetParameter(Req_Calibration_Identifications_CAL_ID_Write,"Calibration_Identifications_CAL_ID/Number_of_data_items",@sysvar::SecVarCodingControl::CALIDNumberOfItems);
  // Update of CAL ID
  DiagResize(Req_Calibration_Identifications_CAL_ID_Write, 20);
  diagSetParameterRawTo(Req_Calibration_Identifications_CAL_ID_Write,"Calibration_Identifications_CAL_ID/Calibration_Identification/EndOfServiceIteration0/CAL_ID",0x00,16);
  sysGetVariableData("SecVarCodingControl","CALIDId",tmpCalidBuffer,copiedBytes);
  diagSetParameterRaw(Req_Calibration_Identifications_CAL_ID_Write,"Calibration_Identifications_CAL_ID/Calibration_Identification/EndOfServiceIteration0/CAL_ID",tmpCalidBuffer,16);
  
  Req_Calibration_Identifications_CAL_ID_Write.SendRequest();
  calidReqSize = diagGetPrimitiveData(Req_Calibration_Identifications_CAL_ID_Write, calidReq, elcount(calidReq));
}

// Step 4b: 
// Waits until the Ecu has responded on the Service "Calibration Identifications"
on diagResponse Calibration_Identifications_CAL_ID_Write
{
  byte tmpCodingBuffer[2048];
  long copiedBytes;
  
  if( CheckCurrentDiagTarget() == 1 )
  {
    if( diagGetResponseCode (this) == -1 ) //pos
    {
      sysGetVariableData("SecVarCodingControl","CumulatedCodingBufferVariantData",tmpCodingBuffer,copiedBytes);
      hashDataSize = DDS_CreateCodingDataHash(vinRespData, tmpCodingBuffer, @sysvar::SecVarCodingControl::CumulatedCodingBufferVariantDataLength, calidReq, calidReqSize, hashData);
      //ActivateCertifacte(serial,serialLength); // Activate is not yet possible in ZenZefi. Has to be done manually. 
      sysGetVariableData("Backend", "Authority_Key_ID", DDS_Backend_certKeyID, bytesCopied); // sync from panel
      if( bytesCopied != 20)
      { 
        _TestStepFail("Step 4b: The exspected number of bytes for Authority_Key_ID could not be read.");
        return;
      }
        
      GetVariantCodingUserCertificateAsync(DDS_Backend_certKeyID,elcount(DDS_Backend_certKeyID),hashData,hashDataSize,"","");
    }
  }
  else
  {
    _TestStepFail("Mismatch between traget ECU and response ECU ");
  }
  
}

// Step 4c:
// ZenZefi: Signature creation using VariantCodingUserCertificate finshed
long GetVariantCodingUserCertificateCompleted(long statusCode,  byte serialNumber[],  byte signature[],  
                                              byte varCodingCertificate[],  int64 expirationDate[], char msg[]) 
{ 
  write( "Step 4c: statuscode %i", statusCode);
  DDS_byte2HexString(signature, elcount(signature), signatureSymbolic);
  diagSetParameterRawTo(Req_Verify_Signature_Start,"Data_to_be_checked",0x00,1);
  DiagSetParameter(Req_Verify_Signature_Start, "Signature_Value", signatureSymbolic);
  sysSetVariableData("SecVarCodingControl","Signature",signature,elcount(signature));  
  @sysvar::SecVarCodingControl::SignatureLength = elcount(signature);
  SendSignatureVerify();
  return statusCode;
}

// Step 5a:
// Send the Diagnostic Service to verify the Signature to the ECU using the Service
// "Verify_Signature_Start" (DID 0x0263) 
SendSignatureVerify()
{
  Req_Verify_Signature_Start.SendRequest();
}

// Step 5b:
// Waits until the Ecu has responded on the Service "Verify_Signature_Start"
on diagResponse Verify_Signature_Start
{
  char buffer[100];
  
  if( CheckCurrentDiagTarget() == 1 )
  {
    if( diagGetResponseCode (this) == -1) // pos
    {
      DiagGetLastResponse(Resp_Verify_Signature_Start);
      Resp_Verify_Signature_Start.GetParameter("Verification_Result",buffer,elcount(buffer));
      write("Step 5b: Verify_Signature_Start: Verification_Result = %s",buffer );
    }
  }
  else
  {
    _TestStepFail("Mismatch between traget ECU and response ECU ");
  }
  
  @sysvar::SecVarCodingControl::SecVarCodingSequence = Standby;
}


////////// Utility Functions  ///////////////////////////////////////////////////////////////////

int CheckCurrentDiagTarget()
{
  char qualifier[100]; 
  dword bufferLen = 100;
  char targetName[100];
  
  diagGetCurrentEcu ( qualifier,  bufferLen);
  sysGetVariableString("SecVarCodingControl","Target",targetName,elCount(targetName));
  
  // Sysvar SecVarCodingControl.Target is set during diag authentication
  // this also checks, if this has carried out before
  if( (strncmp(qualifier, targetName ,strlen(qualifier) )== 0) && (strlen(targetName) > 0) )
  {
    return 1;
  }
  else
  {
    return 0;
  }
}


void PrintSecVarCodingState()
{
  switch( @sysvar::SecVarCodingControl::SecVarCodingSequence)
  {
    case StartCoding:
      write("SecVarCodingState: %s","Start Coding");
      break;
    case WriteData:
      write("SecVarCodingState: %s","Write Data");
      break;
    case FinishCoding:
      write("SecVarCodingState: %s","Finish Coding");
      break;
    case Standby:
      write("SecVarCodingState: %s","Standby");
      break;
    default:
      write("SecVarCodingState: %s","Unknown state");
      break;
  }
  
}

void ResetPanelData()
{
  byte buffer[10];
  
  @sysvar::SecVarCodingPanel::ECU_VIN_Length = 0;
  sysSetVariableData("SecVarCodingPanel","ECU_VIN",buffer,0);
  @sysvar::SecVarCodingControl::CodingVariantWriteDataLength = 0;
  sysSetVariableData("SecVarCodingControl","CodingVariantWriteData",buffer,0);
  @sysvar::SecVarCodingControl::CumulatedCodingBufferVariantDataLength = 0;
  sysSetVariableData("SecVarCodingControl","CumulatedCodingBufferVariantData",buffer,0);
  enableControl("SecVarCodingControl", "Button_FinishCoding", 0);
  enableControl("SecVarCodingControl", "Button_StartCoding", 1);
  sysSetVariableData("SecVarCodingControl","HashData",buffer,0);
  SetControlVisibility("SecVarCodingControl", "LEDControl_AuthKey", 0);
  SetControlVisibility("SecVarCodingControl", "LEDControl_VarCodSer", 0);
  SetControlVisibility("SecVarCodingControl", "LEDControl_SupplierSer", 0);
  SetControlVisibility("SecVarCodingControl", "LEDControl_RoleCertAvailable",0);
  sysSetVariableData("SecVarCodingControl","Signature",buffer,0);
  enableControl("SecVarCodingControl", "Button_CancelSequence",0);
}

// Panel handler for Button Finish Coding
on sysvar_update sysvar::SecVarCodingPanel::Button_CodingFinished
{
  if( @this == 1)
  {
    if(@this == 1 && @sysvar::SecVarCodingControl::SecVarCodingSequence == WriteData)
      @sysvar::SecVarCodingControl::SecVarCodingSequence = FinishCoding;
    else
    {
      write("Coding Finished can be called in state Write Sec Var Coding Data only.");
    }
  }
}

// Utility function to Update the Sequence LEDs
void SetSecVarCodingSequenceLED()
{
  if( @sysvar::SecVarCodingControl::SecVarCodingSequence == StartCoding )
  {
    @sysvar::SecVarCodingPanel::LED_CodingFinished = 0;
    @sysvar::SecVarCodingPanel::LED_CodingStart = 1;
    @sysvar::SecVarCodingPanel::LED_WriteData = 0;
  }
  else if( @sysvar::SecVarCodingControl::SecVarCodingSequence == WriteData)
  {
    @sysvar::SecVarCodingPanel::LED_CodingFinished = 0;
    @sysvar::SecVarCodingPanel::LED_CodingStart = 1;
    @sysvar::SecVarCodingPanel::LED_WriteData = 1;
  }
  else if( @sysvar::SecVarCodingControl::SecVarCodingSequence == FinishCoding )
  {
    @sysvar::SecVarCodingPanel::LED_CodingFinished = 1;
    @sysvar::SecVarCodingPanel::LED_CodingStart = 1;
    @sysvar::SecVarCodingPanel::LED_WriteData = 1; 
  }
  else if(@sysvar::SecVarCodingControl::SecVarCodingSequence == Standby)
  {
    @sysvar::SecVarCodingPanel::LED_CodingFinished = 0;
    @sysvar::SecVarCodingPanel::LED_CodingStart = 0;
    @sysvar::SecVarCodingPanel::LED_WriteData = 0; 
  }
}

// Get hash data from variant coding data for signature
// hash data = VIN|coding data (with DID)|CALID data (with DID)
// return length of hash data
long DDS_CreateCodingDataHash(byte vinRespData[], byte codingDataReq[], long codingDataReqSize, byte calidReq[], long calidReqSize, byte hashDataOut[])
{
  long vinSize = 17;
  long codingDataSize;
  long calidDataSize;
  long hashDataSize;
  char hashstring[4096];

  // hash data = VIN|coding data (with DID)|CALID data (with DID)
  codingDataSize = codingDataReqSize;
  calidDataSize = calidReqSize - 1/*SID*/;
  hashDataSize = vinSize + codingDataSize + calidDataSize;
  
  memcpy_off(hashDataOut, 0, vinRespData, 3, vinSize);
  memcpy_off(hashDataOut, vinSize, codingDataReq, 0, codingDataSize);
  memcpy_off(hashDataOut, vinSize + codingDataSize, calidReq, 1, calidDataSize);

  DDS_byte2HexString(hashDataOut, hashDataSize, hashstring);
  sysSetVariableData("SecVarCodingControl","HashData",hashDataOut,hashDataSize); // display in panel
  @sysvar::SecVarCodingControl::HashDataSize = hashDataSize; // display in panel
  write("Hash data for signature: %s", hashstring );

  return hashDataSize;
}


diagSetParameterRawTo(diagRequest * obj,char diagSpecRef[],byte val,int length)
{
  byte dataBuffer [4096];
  int i;
  for(i=0;i<length;i++)
  {
    dataBuffer[i]=val;
  }
  diagSetParameterRaw(obj,diagSpecRef, dataBuffer, length);
}

void _TestStepFail ( char msg[])
{
  writeLineEx(0,3,msg);
}

void DDS_byte2HexString(byte data[], int length, char outString[])
{
  char emptyString[2] = "";
  int i=0;
  int val;
  int outPos;
  int isCut=0;
  i=0;
  isCut=0;
  snprintf(outString, elCount(emptyString), emptyString);
  if (elcount(data)<length) length=elcount(data);
  outPos=strlen(outString);
  if (outPos+(3*length)+2>elcount(outString))
  {
    length=(elcount(outString)-outPos);//rest string length
    length=length-2; //leading 0x
    length=length/3; //count of numbers, 3 chars per number
    length=length-1; //reserve space for '...'
    isCut=1;
  }
  if(length > 0)
  {
    for(i=0; i < length; i++)
    {
      outString[outPos++]='0';
      outString[outPos++]='x';
      val = data[i] >> 4;
      outString[outPos++] = (val <= 9) ? val + '0' : val + 'A' - 10;
      val = data[i] & 0xF;
      outString[outPos++] = (val <= 9) ? val + '0' : val + 'A' - 10;
      outString[outPos++] = ' ';
    }
    outString[outPos++]=0;
    if (isCut>0)
    {
      strncat(outString, "...", elcount(outString));
    }
  }
}


on sysvar_update sysvar::SecVarCodingPanel::Button_CancelSequence
{
  if(@this == 1)
  {
    ResetPanelData();
    @sysvar::SecVarCodingControl::SecVarCodingSequence = Standby;
  }
}

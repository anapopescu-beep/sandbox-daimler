* qac.usr.m3cm
*
* copyright:  (c) 2013 - Programming Research
*
* Purpose:  M3CM-1.0-QAC-8.1.2 configuration user message file
*
* History:  Auto-created from Database on 30-Jul-13
*
* CMS version: 0.1a
*
#levelname                         0     Information
#levelname                         1     Obsolete Messages
#levelname                         2     Minor
#levelname                         3     Major
#levelname                         4     MISRA Advisory Directives
#levelname                         5     MISRA Advisory Rules
#levelname                         6     MISRA Required Directives
#levelname                         7     MISRA Required Rules
#levelname                         8     MISRA Mandatory Rules
#levelname                         9     Errors
#define    ANT_information         0     Annotations
#define    CMA_information         0     CMA information
#define    Parser_Rec              0     Parsing recovery
#define    DF_Recovery             0     Dataflow recovery         
#define    submsg                  0     Sub-Messages
#define    ODF_Signed              1     Dataflow - Conversion to signed      
#define    ODF_Unsigned            1     Dataflow - Conversion to unsigned
#define    ODF_Shift               1     Dataflow - Shift operations
#define    ODF_Overflow            1     Dataflow - Overflow and wraparound
#define    ODF_Arrays              1     Dataflow - Arrays       
#define    ODF_Unset               1     Dataflow - Unset data
#define    ODF_NULL                1     Dataflow - NULL pointers
#define    ODF_Redundancy          1     Dataflow - Redundancy
#define    ODF_Invariant           1     Dataflow - Invariant operations
#define    ODF_Control             1     Dataflow - Control flow
#define    OTC_Implicit            1     Arithmetic type - Implicit conversions
#define    OTC_Complex             1     Arithmetic type - Complex expressions
#define    OTC_Enums               1     Arithmetic type - Enum types 
#define    OTC_Operations          1     Arithmetic type - Operations
#define    Obsolete                1     Miscellaneous
#define    ISO_ExpU                1     Explicitly undefined
#define    ISO_ImplDef             1     Implementation defined
#define    Lang_ext                1     Language extensions
#define    C99_ext                 1     ISO C99 Language features
#define    CMA_warning             1     CMA undefined
#define    Constraint              1     Constraint violations
#define    DF_Redundancy           1     Redundancy
#define    ISO_ImpU                1     Implicitly undefined
#define    Min_Brace               2     Bracing and Indentation
#define    Min_Array               2     Arrays, structures, unions and bit-fields
#define    CMA_declaration         2     CMA declaration checks
#define    Min_Cpp                 2     C++ compatibility
#define    Min_Balancing           2     Arithmetic type - Balancing
#define    Min_Casts               2     Arithmetic type - Casts
#define    Min_Complex             2     Arithmetic type - Composite expressions
#define    Min_Prom                2     Arithmetic type - Integral promotion
#define    Min_Assignment          2     Arithmetic type - Assignment
#define    Min_Operations          2     Arithmetic type - Operations
#define    Min_KandR               2     K+R compatibility
#define    Min_MacroDefs           2     Macro Definition
#define    Metrics                 2     Metric thresholds
#define    Min_Pointers            2     Pointers
#define    Min_Prepro              2     Preprocessing
#define    Min_Read                2     Readability
#define    Min_Redun               2     Redundancy
#define    Min_Side                2     Side Effects
#define    Min_Switch              2     Switch statements
#define    DF_Invariant            2     Dataflow - Invariant operations
#define    DF_Control              2     Dataflow - Control flow
#define    ISO_C90_Limits          2     ISO C90 Conformance limits
#define    ISO_C99_Limits          2     ISO C99 Conformance limits
#define    CMA_maintenance         2     CMA maintenance checks
#define    Min_Const               2     Constants
#define    Min_Ctrl                2     Control flow
#define    Min_Decl                2     Declarations and Definitions
#define    Min_Enum                2     Enumerations
#define    Min_Func                2     Functions
#define    Min_Ident               2     Identifiers
#define    DF_Signed               2     Dataflow - Conversion to signed
#define    DF_Unsigned             2     Dataflow - Conversion to unsigned
#define    DF_Shift                2     Dataflow - Shift operations
#define    DF_Overflow             2     Dataflow - Overflow and wraparound
#define    DF_Arrays               2     Dataflow - Arrays
#define    DF_Pointers             2     Dataflow - Pointers
#define    DF_NULL                 2     Dataflow - NULL pointers
#define    DF_Unset                2     Dataflow - Unset data
#define    Min_Operands            2     Arithmetic type - Operands
#define    Maj_Assignment          3     Arithmetic type - Assignment
#define    Maj_Balancing           3     Arithmetic type - Balancing
#define    Maj_Casts               3     Arithmetic type - Casts
#define    Maj_Operands            3     Arithmetic type - Operands
#define    Maj_Operations          3     Arithmetic type - Operations
#define    Maj_Decl                3     Declarations and definitions
#define    Maj_Func                3     Functions
#define    Maj_Pointers            3     Pointers
#define    Maj_Prepro              3     Preprocessing
#define    Maj_Redun               3     Redundancy
#define    Maj_Switch              3     Switch statements
#define    Config                  9     QAC configuration
#define    Syntax                  9     Syntax errors
#define    Dir_1_1                 6     M3CM Dir-1.1
#define    Dir_2_1                 6     M3CM Dir-2.1
#define    Dir_3_1                 6     M3CM Dir-3.1
#define    Dir_4_1                 6     M3CM Dir-4.1
#define    Dir_4_2                 4     M3CM Dir-4.2
#define    Dir_4_3                 6     M3CM Dir-4.3
#define    Dir_4_4                 4     M3CM Dir-4.4
#define    Dir_4_5                 4     M3CM Dir-4.5
#define    Dir_4_6                 4     M3CM Dir-4.6
#define    Dir_4_7                 6     M3CM Dir-4.7
#define    Dir_4_8                 4     M3CM Dir-4.8
#define    Dir_4_9                 4     M3CM Dir-4.9
#define    Dir_4_10                6     M3CM Dir-4.10
#define    Dir_4_11                6     M3CM Dir-4.11
#define    Dir_4_12                6     M3CM Dir-4.12
#define    Dir_4_13                4     M3CM Dir-4.13
#define    Rule_1_1                7     M3CM Rule-1.1
#define    Rule_1_2                5     M3CM Rule-1.2
#define    Rule_1_3                7     M3CM Rule-1.3
#define    Rule_2_1                7     M3CM Rule-2.1
#define    Rule_2_2                7     M3CM Rule-2.2
#define    Rule_2_3                5     M3CM Rule-2.3
#define    Rule_2_4                5     M3CM Rule-2.4
#define    Rule_2_5                5     M3CM Rule-2.5
#define    Rule_2_6                5     M3CM Rule-2.6
#define    Rule_2_7                5     M3CM Rule-2.7
#define    Rule_3_1                7     M3CM Rule-3.1
#define    Rule_3_2                7     M3CM Rule-3.2
#define    Rule_4_1                7     M3CM Rule-4.1
#define    Rule_4_2                5     M3CM Rule-4.2
#define    Rule_5_1                7     M3CM Rule-5.1
#define    Rule_5_2                7     M3CM Rule-5.2
#define    Rule_5_3                7     M3CM Rule-5.3
#define    Rule_5_4                7     M3CM Rule-5.4
#define    Rule_5_5                7     M3CM Rule-5.5
#define    Rule_5_6                7     M3CM Rule-5.6
#define    Rule_5_7                7     M3CM Rule-5.7
#define    Rule_5_8                7     M3CM Rule-5.8
#define    Rule_5_9                5     M3CM Rule-5.9
#define    Rule_6_1                7     M3CM Rule-6.1
#define    Rule_6_2                7     M3CM Rule-6.2
#define    Rule_7_1                7     M3CM Rule-7.1
#define    Rule_7_2                7     M3CM Rule-7.2
#define    Rule_7_3                7     M3CM Rule-7.3
#define    Rule_7_4                7     M3CM Rule-7.4
#define    Rule_8_1                7     M3CM Rule-8.1
#define    Rule_8_2                7     M3CM Rule-8.2
#define    Rule_8_3                7     M3CM Rule-8.3
#define    Rule_8_4                7     M3CM Rule-8.4
#define    Rule_8_5                7     M3CM Rule-8.5
#define    Rule_8_6                7     M3CM Rule-8.6
#define    Rule_8_7                5     M3CM Rule-8.7
#define    Rule_8_8                7     M3CM Rule-8.8
#define    Rule_8_9                5     M3CM Rule-8.9
#define    Rule_8_10               7     M3CM Rule-8.10
#define    Rule_8_11               5     M3CM Rule-8.11
#define    Rule_8_12               7     M3CM Rule-8.12
#define    Rule_8_13               5     M3CM Rule-8.13
#define    Rule_8_14               7     M3CM Rule-8.14
#define    Rule_9_1                8     M3CM Rule-9.1
#define    Rule_9_2                7     M3CM Rule-9.2
#define    Rule_9_3                7     M3CM Rule-9.3
#define    Rule_9_4                7     M3CM Rule-9.4
#define    Rule_9_5                7     M3CM Rule-9.5
#define    Rule_10_1               7     M3CM Rule-10.1
#define    Rule_10_2               7     M3CM Rule-10.2
#define    Rule_10_3               7     M3CM Rule-10.3
#define    Rule_10_4               7     M3CM Rule-10.4
#define    Rule_10_5               5     M3CM Rule-10.5
#define    Rule_10_6               7     M3CM Rule-10.6
#define    Rule_10_7               7     M3CM Rule-10.7
#define    Rule_10_8               7     M3CM Rule-10.8
#define    Rule_11_1               7     M3CM Rule-11.1
#define    Rule_11_2               7     M3CM Rule-11.2
#define    Rule_11_3               7     M3CM Rule-11.3
#define    Rule_11_4               5     M3CM Rule-11.4
#define    Rule_11_5               5     M3CM Rule-11.5
#define    Rule_11_6               7     M3CM Rule-11.6
#define    Rule_11_7               7     M3CM Rule-11.7
#define    Rule_11_8               7     M3CM Rule-11.8
#define    Rule_11_9               7     M3CM Rule-11.9
#define    Rule_12_1               5     M3CM Rule-12.1
#define    Rule_12_2               7     M3CM Rule-12.2
#define    Rule_12_3               5     M3CM Rule-12.3
#define    Rule_12_4               5     M3CM Rule-12.4
#define    Rule_13_1               7     M3CM Rule-13.1
#define    Rule_13_2               7     M3CM Rule-13.2
#define    Rule_13_3               5     M3CM Rule-13.3
#define    Rule_13_4               5     M3CM Rule-13.4
#define    Rule_13_5               7     M3CM Rule-13.5
#define    Rule_13_6               8     M3CM Rule-13.6
#define    Rule_14_1               7     M3CM Rule-14.1
#define    Rule_14_2               7     M3CM Rule-14.2
#define    Rule_14_3               7     M3CM Rule-14.3
#define    Rule_14_4               7     M3CM Rule-14.4
#define    Rule_15_1               5     M3CM Rule-15.1
#define    Rule_15_2               7     M3CM Rule-15.2
#define    Rule_15_3               7     M3CM Rule-15.3
#define    Rule_15_4               5     M3CM Rule-15.4
#define    Rule_15_5               5     M3CM Rule-15.5
#define    Rule_15_6               7     M3CM Rule-15.6
#define    Rule_15_7               7     M3CM Rule-15.7
#define    Rule_16_1               7     M3CM Rule-16.1
#define    Rule_16_2               7     M3CM Rule-16.2
#define    Rule_16_3               7     M3CM Rule-16.3
#define    Rule_16_4               7     M3CM Rule-16.4
#define    Rule_16_5               7     M3CM Rule-16.5
#define    Rule_16_6               7     M3CM Rule-16.6
#define    Rule_16_7               7     M3CM Rule-16.7
#define    Rule_17_1               7     M3CM Rule-17.1
#define    Rule_17_2               7     M3CM Rule-17.2
#define    Rule_17_3               8     M3CM Rule-17.3
#define    Rule_17_4               8     M3CM Rule-17.4
#define    Rule_17_5               5     M3CM Rule-17.5
#define    Rule_17_6               8     M3CM Rule-17.6
#define    Rule_17_7               7     M3CM Rule-17.7
#define    Rule_17_8               5     M3CM Rule-17.8
#define    Rule_18_1               7     M3CM Rule-18.1
#define    Rule_18_2               7     M3CM Rule-18.2
#define    Rule_18_3               7     M3CM Rule-18.3
#define    Rule_18_4               5     M3CM Rule-18.4
#define    Rule_18_5               5     M3CM Rule-18.5
#define    Rule_18_6               7     M3CM Rule-18.6
#define    Rule_18_7               7     M3CM Rule-18.7
#define    Rule_18_8               7     M3CM Rule-18.8
#define    Rule_19_1               8     M3CM Rule-19.1
#define    Rule_19_2               5     M3CM Rule-19.2
#define    Rule_20_1               5     M3CM Rule-20.1
#define    Rule_20_2               7     M3CM Rule-20.2
#define    Rule_20_3               7     M3CM Rule-20.3
#define    Rule_20_4               7     M3CM Rule-20.4
#define    Rule_20_5               5     M3CM Rule-20.5
#define    Rule_20_6               7     M3CM Rule-20.6
#define    Rule_20_7               7     M3CM Rule-20.7
#define    Rule_20_8               7     M3CM Rule-20.8
#define    Rule_20_9               7     M3CM Rule-20.9
#define    Rule_20_10              5     M3CM Rule-20.10
#define    Rule_20_11              7     M3CM Rule-20.11
#define    Rule_20_12              7     M3CM Rule-20.12
#define    Rule_20_13              7     M3CM Rule-20.13
#define    Rule_20_14              7     M3CM Rule-20.14
#define    Rule_21_1               7     M3CM Rule-21.1
#define    Rule_21_2               7     M3CM Rule-21.2
#define    Rule_21_3               7     M3CM Rule-21.3
#define    Rule_21_4               7     M3CM Rule-21.4
#define    Rule_21_5               7     M3CM Rule-21.5
#define    Rule_21_6               7     M3CM Rule-21.6
#define    Rule_21_7               7     M3CM Rule-21.7
#define    Rule_21_8               7     M3CM Rule-21.8
#define    Rule_21_9               7     M3CM Rule-21.9
#define    Rule_21_10              7     M3CM Rule-21.10
#define    Rule_21_11              7     M3CM Rule-21.11
#define    Rule_21_12              5     M3CM Rule-21.12
#define    Rule_22_1               7     M3CM Rule-22.1
#define    Rule_22_2               8     M3CM Rule-22.2
#define    Rule_22_3               7     M3CM Rule-22.3
#define    Rule_22_4               8     M3CM Rule-22.4
#define    Rule_22_5               8     M3CM Rule-22.5
#define    Rule_22_6               8     M3CM Rule-22.6
#define    HIS_METRICS_REQUIRED	   7 	 Metric thresholds
#define    HIS_METRICS_MANDATORY   8 	 Metric thresholds


160    Rule_1_3              [U] Using unsupported conversion specifier number %s.\\
MISRA C:2012 Rule-1.3; REFERENCE - ISO:C90-7.9.6 Formatted input/output functions

161    Rule_1_3              [U] Unknown length modifier used with 'i' or 'd' conversion specifier, number %s.\\
MISRA C:2012 Rule-1.3; REFERENCE - ISO:C90-7.9.6.1 Formatted input/output functions

162    Rule_1_3              [U] Unknown length modifier used with 'o' conversion specifier, number %s.\\
MISRA C:2012 Rule-1.3; REFERENCE - ISO:C90-7.9.6.1 Formatted input/output functions

163    Rule_1_3              [U] Unknown length modifier used with 'u' conversion specifier, number %s.\\
MISRA C:2012 Rule-1.3; REFERENCE - ISO:C90-7.9.6.1 Formatted input/output functions

164    Rule_1_3              [U] Unknown length modifier used with 'x' conversion specifier, number %s.\\
MISRA C:2012 Rule-1.3; REFERENCE - ISO:C90-7.9.6.1 Formatted input/output functions

165    Rule_1_3              [U] Unknown length modifier used with 'X' conversion specifier, number %s.\\
MISRA C:2012 Rule-1.3; REFERENCE - ISO:C90-7.9.6.1 Formatted input/output functions

166    Rule_1_3              [U] Unknown length modifier used with 'f' conversion specifier, number %s.\\
MISRA C:2012 Rule-1.3; REFERENCE - ISO:C90-7.9.6.1 Formatted input/output functions

167    Rule_1_3              [U] Unknown length modifier used with 'e' conversion specifier, number %s.\\
MISRA C:2012 Rule-1.3; REFERENCE - ISO:C90-7.9.6.1 Formatted input/output functions

168    Rule_1_3              [U] Unknown length modifier used with 'E' conversion specifier, number %s.\\
MISRA C:2012 Rule-1.3; REFERENCE - ISO:C90-7.9.6.1 Formatted input/output functions

169    Rule_1_3              [U] Unknown length modifier used with 'g' conversion specifier, number %s.\\
MISRA C:2012 Rule-1.3; REFERENCE - ISO:C90-7.9.6.1 Formatted input/output functions

170    Rule_1_3              [U] Unknown length modifier used with 'G' conversion specifier, number %s.\\
MISRA C:2012 Rule-1.3; REFERENCE - ISO:C90-7.9.6.1 Formatted input/output functions

171    Rule_1_3              [U] Unknown length modifier used with 'c' conversion specifier, number %s.\\
MISRA C:2012 Rule-1.3; REFERENCE - ISO:C90-7.9.6.1 Formatted input/output functions

172    Rule_1_3              [U] Unknown length modifier used with '%%' conversion specifier, number %s.\\
MISRA C:2012 Rule-1.3; REFERENCE - ISO:C90-7.9.6.1 Formatted input/output functions

173    Rule_1_3              [U] Unknown length modifier used with 's' conversion specifier, number %s.\\
MISRA C:2012 Rule-1.3; REFERENCE - ISO:C90-7.9.6.1 Formatted input/output functions

174    Rule_1_3              [U] Unknown length modifier used with 'n' conversion specifier, number %s.\\
MISRA C:2012 Rule-1.3; REFERENCE - ISO:C90-7.9.6.1 Formatted input/output functions

175    Rule_1_3              [U] Unknown length modifier used with 'p' conversion specifier, number %s.\\
MISRA C:2012 Rule-1.3; REFERENCE - ISO:C90-7.9.6.1 Formatted input/output functions

176    Rule_1_3              [U] Incomplete conversion specifier, number %s.\\
MISRA C:2012 Rule-1.3; REFERENCE - ISO:C90-7.9.6.1 Formatted input/output functions

177    Rule_1_3              [U] Field width of format conversion specifier exceeds 509 characters.\\
MISRA C:2012 Rule-1.3; REFERENCE - ISO:C90-7.9.6.1 Environmental limit

178    Rule_1_3              [U] Precision of format conversion specifier exceeds 509 characters.\\
MISRA C:2012 Rule-1.3; REFERENCE - ISO:C90-7.9.6.1 Environmental limit

179    Rule_1_3              [U] Argument type does not match conversion specifier number %s.\\
MISRA C:2012 Rule-1.3; REFERENCE - ISO:C90-7.9.6.1 Formatted input/output functions

180    Dir_1_1               [C99] Use of ll for conversion specifier.\\
MISRA C:2012 Dir-1.1; REFERENCE - ISO:C99-7.19.6 Formatted input/output functions

184    Rule_1_3              [U] Insufficient arguments to satisfy conversion specifier, number %s.\\
MISRA C:2012 Rule-1.3; REFERENCE - ISO:C90-7.9.6 Formatted input/output functions

185    Rule_1_3              [U] Call contains more arguments than conversion specifiers.\\
MISRA C:2012 Rule-1.3; REFERENCE - ISO:C90-7.9.6 Formatted input/output functions

186    Rule_1_3              [U] A call to this function must include at least one argument.\\
MISRA C:2012 Rule-1.3; REFERENCE - ISO:C90-7.9.6 Formatted input/output functions

190    Rule_1_3              [U] Using unsupported conversion specifier number %s.\\
MISRA C:2012 Rule-1.3; REFERENCE - ISO:C90-7.9.6.2 Formatted input/output functions

191    Rule_1_3              [U] Unknown length modifier used with 'd/i/n' conversion specifier, number %s.\\
MISRA C:2012 Rule-1.3; REFERENCE - ISO:C90-7.9.6.2 Formatted input/output functions

192    Rule_1_3              [U] Unknown length modifier used with 'o' conversion specifier, number %s.\\
MISRA C:2012 Rule-1.3; REFERENCE - ISO:C90-7.9.6.2 Formatted input/output functions

193    Rule_1_3              [U] Unknown length modifier used with 'u' conversion specifier, number %s.\\
MISRA C:2012 Rule-1.3; REFERENCE - ISO:C90-7.9.6.2 Formatted input/output functions

194    Rule_1_3              [U] Unknown length modifier used with 'x/X' conversion specifier, number %s.\\
MISRA C:2012 Rule-1.3; REFERENCE - ISO:C90-7.9.6.2 Formatted input/output functions

195    Rule_1_3              [U] Unknown length modifier used with 'e/E/f/F/g/G' conversion specifier, number %s.\\
MISRA C:2012 Rule-1.3; REFERENCE - ISO:C90-7.9.6.2 Formatted input/output functions

196    Rule_1_3              [U] Unknown length modifier used with 's' conversion specifier, number %s.\\
MISRA C:2012 Rule-1.3; REFERENCE - ISO:C90-7.9.6.2 Formatted input/output functions

197    Rule_1_3              [U] Unknown length modifier used with 'p' conversion specifier, number %s.\\
MISRA C:2012 Rule-1.3; REFERENCE - ISO:C90-7.9.6.2 Formatted input/output functions

198    Rule_1_3              [U] Unknown length modifier used with '%%' conversion specifier, number %s.\\
MISRA C:2012 Rule-1.3; REFERENCE - ISO:C90-7.9.6.2 Formatted input/output functions

199    Rule_1_3              [U] Unknown length modifier used with '[' conversion specifier, number %s.\\
MISRA C:2012 Rule-1.3; REFERENCE - ISO:C90-7.9.6.2 Formatted input/output functions

200    Rule_1_3              [U] Unknown length modifier used with 'c' conversion specifier, number %s.\\
MISRA C:2012 Rule-1.3; REFERENCE - ISO:C90-7.9.6.2 Formatted input/output functions

201    Rule_1_3              [U] Incomplete conversion specifier, number %s.\\
MISRA C:2012 Rule-1.3; REFERENCE - ISO:C90-7.9.6.2 Formatted input/output functions

202    Dir_1_1               [I] '-' character in '[]' conversion specification is implementation defined.\\
MISRA C:2012 Dir-1.1; REFERENCE - ISO:C90-7.9.6.2 Formatted input/output functions

203    Rule_1_3              [U] Value of character prior to '-' in '[]' is greater than following character.\\
MISRA C:2012 Rule-1.3; REFERENCE - ISO:C90-7.9.6.2 The fscanf Function

204    Rule_1_3              [U] Field width of format conversion specifier exceeds 509 characters.\\
MISRA C:2012 Rule-1.3; REFERENCE - ISO:C90-7.9.6.2 Formatted input/output functions

206    Rule_1_3              [U] Argument type does not match conversion specifier number %s.\\
MISRA C:2012 Rule-1.3; REFERENCE - ISO:C90-7.9.6.2 Formatted input/output functions

207    Rule_1_3              [U] 'scanf' expects address of objects being stored into.\\
MISRA C:2012 Rule-1.3; REFERENCE - ISO:C90-7.9, ISO:C90-7.9.6.4 - The scanf Function

208    Rule_1_3              [U] Same character occurs in scanset more than once.\\
MISRA C:2012 Rule-1.3; REFERENCE - ISO:C90-7.9.6.2 Formatted input/output functions

232    Rule_1_1              [C] Value of hex escape sequence is not representable in type 'unsigned char'.\\
MISRA C:2012 Rule-1.1; REFERENCE - ISO:C90-6.1.3.4 Character Constants - Constraints

233    Rule_1_1              [C] Value of octal escape sequence is not representable in type 'unsigned char'.\\
MISRA C:2012 Rule-1.1; REFERENCE - ISO:C90-6.1.3.4 Character Constants - Constraints

235    Rule_1_3              [U] Unknown escape sequence.\\
MISRA C:2012 Rule-1.3; REFERENCE - ISO:C90-6.1.3.4 Description, ISO:C90-6.9.2 Future Language Directions

240    Rule_1_2              [E] This file contains the control-M character at the end of a line.\\
MISRA C:2012 Rule-1.2

241    Rule_1_2              [E] This file contains the control-Z character - was this transferred from a PC?\\
MISRA C:2012 Rule-1.2

244    Rule_1_1              [C] Value of character constant is not representable in type 'int'.\\
MISRA C:2012 Rule-1.1; REFERENCE - ISO:C90-6.1.3 Constants - Constraints

246    Rule_1_2              [E] Binary integer constants are a language extension.\\
MISRA C:2012 Rule-1.2; REFERENCE - ISO:C90-6.1.3.2 Integer Constants

261    Rule_1_1              [C] Comment still open at end of included file.\\
MISRA C:2012 Rule-1.1; REFERENCE - ISO:C90-5.1.1.2 Translation phases

275    Rule_1_3              [U] Floating value is out of range for conversion to destination type.\\
MISRA C:2012 Rule-1.3; REFERENCE - ISO:C90-6.2.1.3 Conversions (Floating and Integral)

284    Dir_1_1               [I] Multiple character constants have implementation defined values.\\
MISRA C:2012 Dir-1.1; REFERENCE - ISO:C90-6.1.3.4 Character Constants - Semantics

285    Dir_1_1               [I] Character constant contains character which is not a member of the basic source character set.\\
MISRA C:2012 Dir-1.1; REFERENCE - ISO:C90-5.2.1 Character Sets

286    Dir_1_1               [I] String literal contains character which is not a member of the basic source character set.\\
MISRA C:2012 Dir-1.1; REFERENCE - ISO:C90-5.2.1 Character Sets

287    Dir_1_1               [I] Header name contains character which is not a member of the basic source character set.\\
MISRA C:2012 Dir-1.1; REFERENCE - ISO:C90-5.2.1 Character Sets

288    Dir_1_1               [I] Source file '%s' has comments containing characters which are not members of the basic source character set.\\
MISRA C:2012 Dir-1.1; REFERENCE - ISO:C90-5.2.1 Character Sets

289    Dir_1_1               [I] Source file '%s' has preprocessing tokens containing characters which are not members of the basic source character set.\\
MISRA C:2012 Dir-1.1; REFERENCE - ISO:C90-5.2.1 Character Sets

292    Dir_1_1               [I] Source file '%s' has comments containing one of the characters '$', '@' or '`'.\\
MISRA C:2012 Dir-1.1; REFERENCE - ISO:C90-5.2.1 Character Sets

299    Dir_1_1               [I] Source file '%s' includes #pragma directives containing characters which are not members of the basic source character set.\\
MISRA C:2012 Dir-1.1; REFERENCE - ISO:C90-5.2.1 Character Sets

301    Rule_11_7             [u] Cast between a pointer to object and a floating type.\\
MISRA C:2012 Rule-1.3, Rule-11.7; REFERENCE - ISO:C90-6.3.4 Cast Operators - Semantics

302    Rule_11_1             [u] Cast between a pointer to function and a floating type.\\
MISRA C:2012 Rule-1.3, Rule-11.1; REFERENCE - ISO:C90-6.3.4 Cast Operators - Semantics

303    Rule_11_4             [I] Cast between a pointer to volatile object and an integral type.\\
MISRA C:2012 Rule-11.4; REFERENCE - ISO:C90-6.3.4 Cast Operators - Semantics

304    Rule_1_3              [U] The address of an array declared 'register' may not be computed.\\
MISRA C:2012 Rule-1.3; REFERENCE - ISO:C90-6.5.1 Storage-Class Specifiers - Semantics

305    Rule_11_1             [I] Cast between a pointer to function and an integral type.\\
MISRA C:2012 Rule-11.1; REFERENCE - ISO:C90-6.3.4 Cast Operators - Semantics

306    Rule_11_4             [I] Cast between a pointer to object and an integral type.\\
MISRA C:2012 Rule-11.4, Rule-11.6; REFERENCE - ISO:C90-6.3.4 Cast Operators - Semantics

307    Rule_11_1             [u] Cast between a pointer to object and a pointer to function.\\
MISRA C:2012 Rule-1.3, Rule-11.1; REFERENCE - ISO:C90-6.3.4 Cast Operators - Semantics

308    Rule_11_2             Non-portable cast involving pointer to an incomplete type.\\
MISRA C:2012 Rule-11.2; REFERENCE - ISO:C90-6.3.4 Cast Operators - Semantics

309    Rule_1_3              [U] Integral type is not large enough to hold a pointer value.\\
MISRA C:2012 Rule-1.3; REFERENCE - ISO:C90-6.3.4 Cast Operators - Semantics

310    Rule_11_3             Casting to different object pointer type.\\
MISRA C:2012 Rule-11.3; REFERENCE - ISO:C90-6.3.4 Cast Operators - Semantics

311    Rule_11_8             Dangerous pointer cast results in loss of const qualification.\\
MISRA C:2012 Rule-11.8

312    Rule_11_8             Dangerous pointer cast results in loss of volatile qualification.\\
MISRA C:2012 Rule-11.8

313    Rule_11_1             Casting to different function pointer type.\\
MISRA C:2012 Rule-11.1; REFERENCE - ISO:C90-6.3.4 Cast Operators - Semantics

316    Rule_11_5             [I] Cast from a pointer to void to a pointer to object type.\\
MISRA C:2012 Rule-11.5; REFERENCE - ISO:C90-6.3.4 Cast Operators - Semantics

317    Rule_11_5             [I] Implicit conversion from a pointer to void to a pointer to object type.\\
MISRA C:2012 Rule-11.5; REFERENCE - ISO:C90-6.3.4 Cast Operators - Semantics

320    Dir_1_1               [C99] Declaration within 'for' statement.\\
MISRA C:2012 Dir-1.1; REFERENCE - ISO:C99-6.8.5 Iteration statements

321    Rule_1_1              [C] Declaration within 'for' statement defines an identifier '%s' which is not an object.\\
MISRA C:2012 Rule-1.1; REFERENCE - ISO:C99-6.8.5 Iteration statements - Constraints

322    Rule_1_1              [C] Illegal storage class specifier used in 'for' statement declaration.\\
MISRA C:2012 Rule-1.1; REFERENCE - ISO:C99-6.8.5 Iteration statements - Constraints

336    Rule_7_1              Macro defined as an octal constant.\\
MISRA C:2012 Rule-7.1

337    Rule_1_3              [U] String literal has undefined value. This may be a result of using '#' on \\.\\
MISRA C:2012 Rule-1.3; REFERENCE - ISO:C90-6.8.3.2 The # Operator - Semantics

338    Rule_1_1              [C] Octal or hex escape sequence value is too large for 'unsigned char' or 'wchar_t' type.\\
MISRA C:2012 Rule-1.1; REFERENCE - ISO:C90-6.1.3.4 Character Constants - Constraints

339    Rule_7_1              Octal constant used.\\
MISRA C:2012 Rule-7.1

341    Rule_20_10            Using the stringify operator '#'.\\
MISRA C:2012 Rule-20.10; REFERENCE - ISO:C90-6.8.3.2 The # Operator

342    Rule_20_10            Using the glue operator '##'.\\
MISRA C:2012 Rule-20.10; REFERENCE - ISO:C90-6.8.3.3 The ## Operator

360    Rule_11_4             An expression of pointer type is being converted to type _Bool on assignment.\\
MISRA C:2012 Rule-11.4; REFERENCE - ISO:C99-6.5.16.1 Simple assignment

361    Rule_11_4             An expression of pointer type is being cast to type _Bool.\\
MISRA C:2012 Rule-11.4; REFERENCE - ISO:C99-6.3.1.2 Boolean type

362    Rule_11_4             An expression of essentially Boolean type is being cast to a pointer.\\
MISRA C:2012 Rule-11.4; REFERENCE - ISO:C99-6.3.1.2 Boolean type

371    Dir_1_1               [L] Nesting levels of blocks exceeds 127 - program does not conform strictly to ISO:C99.\\
MISRA C:2012 Dir-1.1; REFERENCE - ISO:C99-5.2.4.1 Translation Limits

372    Dir_1_1               [L] More than 63 levels of nested conditional inclusion - program does not conform strictly to ISO:C99.\\
MISRA C:2012 Dir-1.1; REFERENCE - ISO:C99-5.2.4.1 Translation Limits

375    Dir_1_1               [L] Nesting of parenthesized expressions exceeds 63 - program does not conform strictly to ISO:C99.\\
MISRA C:2012 Dir-1.1; REFERENCE - ISO:C99-5.2.4.1 Translation Limits

380    Dir_1_1               [L] Number of macro definitions exceeds 4095 - program does not conform strictly to ISO:C99.\\
MISRA C:2012 Dir-1.1; REFERENCE - ISO:C99-5.2.4.1 Translation Limits

388    Dir_1_1               [L] '#include "%s"' causes nesting to exceed 15 levels - program does not conform strictly to ISO:C99.\\
MISRA C:2012 Dir-1.1; REFERENCE - ISO:C99-5.2.4.1 Translation Limits

390    Dir_1_1               [L] Number of members in 'struct' or 'union' exceeds 1023 - program does not conform strictly to ISO:C99.\\
MISRA C:2012 Dir-1.1; REFERENCE - ISO:C99-5.2.4.1 Translation Limits

391    Dir_1_1               [L] Number of enumeration constants exceeds 1023 - program does not conform strictly to ISO:C99.\\
MISRA C:2012 Dir-1.1; REFERENCE - ISO:C99-5.2.4.1 Translation Limits

392    Dir_1_1               [L] Nesting of 'struct' or 'union' types exceeds 63 - program does not conform strictly to ISO:C99.\\
MISRA C:2012 Dir-1.1; REFERENCE - ISO:C99-5.2.4.1 Translation Limits

400    Rule_13_2             [U] '%s' is modified more than once between sequence points - evaluation order unspecified.\\
MISRA C:2012 Rule-1.3, Rule-13.2; REFERENCE - ISO:C90-6.3 Expressions

401    Rule_13_2             [U] '%s' may be modified more than once between sequence points - evaluation order unspecified.\\
MISRA C:2012 Rule-1.3, Rule-13.2; REFERENCE - ISO:C90-6.3 Expressions

402    Rule_13_2             [U] '%s' is modified and accessed between sequence points - evaluation order unspecified.\\
MISRA C:2012 Rule-1.3, Rule-13.2; REFERENCE - ISO:C90-6.3 Expressions

403    Rule_13_2             [U] '%s' may be modified and accessed between sequence points - evaluation order unspecified.\\
MISRA C:2012 Rule-1.3, Rule-13.2; REFERENCE - ISO:C90-6.3 Expressions

410    Dir_1_1               [L] Nesting of parentheses exceeds 32 - program does not conform strictly to ISO:C90.\\
MISRA C:2012 Dir-1.1; REFERENCE - ISO:C90-5.2.4.1 Translation Limits

422    Rule_1_1              [C] Function call contains fewer arguments than prototype specifies.\\
MISRA C:2012 Rule-1.1; REFERENCE - ISO:C90-6.3.2.2 Function calls

423    Rule_1_1              [C] Function call contains more arguments than prototype specifies.\\
MISRA C:2012 Rule-1.1; REFERENCE - ISO:C90-6.3.2.2 Function calls

426    Rule_1_1              [C] Called function has incomplete return type.\\
MISRA C:2012 Rule-1.1; REFERENCE - ISO:C90-6.3.2.2 Function calls

427    Rule_1_1              [C] Object identifier used as if it were a function or a function pointer identifier.\\
MISRA C:2012 Rule-1.1; REFERENCE - ISO:C90-6.3.2.2 Function calls

429    Rule_1_1              [C] Function argument is not of arithmetic type.\\
MISRA C:2012 Rule-1.1; REFERENCE - ISO:C90-6.3.2.2 Function calls

430    Rule_1_1              [C] Function argument is not of compatible 'struct'/'union' type.\\
MISRA C:2012 Rule-1.1; REFERENCE - ISO:C90-6.3.2.2 Function calls

431    Rule_1_1              [C] Function argument points to a more heavily qualified type.\\
MISRA C:2012 Rule-1.1; REFERENCE - ISO:C90-6.3.2.2 Function calls

432    Rule_1_1              [C] Function argument is not of compatible pointer type.\\
MISRA C:2012 Rule-1.1; REFERENCE - ISO:C90-6.3.2.2 Function calls, ISO:C90-6.3.4

435    Rule_1_1              [C] The 'struct'/'union' member '%s' does not exist.\\
MISRA C:2012 Rule-1.1; REFERENCE - ISO:C90-6.3.2.3 Structure and union members

436    Rule_1_1              [C] Left operand of '.' must be a 'struct' or 'union' object.\\
MISRA C:2012 Rule-1.1; REFERENCE - ISO:C90-6.3.2.3 Structure and union members

437    Rule_1_1              [C] Left operand of '->' must be a pointer to a 'struct' or 'union' object.\\
MISRA C:2012 Rule-1.1; REFERENCE - ISO:C90-6.3.2.3 Structure and union members

446    Rule_1_1              [C] Operand of ++/-- must have scalar (arithmetic or pointer) type.\\
MISRA C:2012 Rule-1.1; REFERENCE - ISO:C90-6.3.2.4 (Postfix), ISO:C90-6.3.3.1 (Prefix) Increment and Decrement Operators

447    Rule_1_1              [C] Operand of ++/-- must be a modifiable object.\\
MISRA C:2012 Rule-1.1; REFERENCE - ISO:C90-6.3.2.4 (Postfix), ISO:C90-6.3.3.1 (Prefix) Increment and Decrement Operators

448    Rule_1_1              [C] Operand of ++/-- must not be a pointer to an object of unknown size.\\
MISRA C:2012 Rule-1.1; REFERENCE - ISO:C90-6.3.2.4 (Postfix), ISO:C90-6.3.3.1 (Prefix) Increment and Decrement Operators

449    Rule_1_1              [C] Operand of ++/-- must not be a pointer to a function.\\
MISRA C:2012 Rule-1.1; REFERENCE - ISO:C90-6.3.2.4 (Postfix), ISO:C90-6.3.3.1 (Prefix) Increment and Decrement Operators

450    Rule_1_1              [C] An expression of array type cannot be cast.\\
MISRA C:2012 Rule-1.1; REFERENCE - ISO:C90-6.3.4 Cast Operators - Constraints, ISO:C90-6.2.2.1 Lvalues and Function Designators

451    Rule_1_1              [C] Subscripting requires a pointer (or array lvalue).\\
MISRA C:2012 Rule-1.1; REFERENCE - ISO:C90-6.3.2.1 Array subscripting

452    Rule_1_1              [C] Cannot subscript a pointer to an object of unknown size.\\
MISRA C:2012 Rule-1.1; REFERENCE - ISO:C90-6.3.2.1 Array subscripting

453    Rule_1_1              [C] An array subscript must have integral type.\\
MISRA C:2012 Rule-1.1; REFERENCE - ISO:C90-6.3.2.1 Array subscripting

454    Rule_1_1              [C] The address-of operator '&' cannot be applied to an object declared with 'register'.\\
MISRA C:2012 Rule-1.1; REFERENCE - ISO:C90-6.3.3.2 Address and Indirection Operators - Constraints

456    Rule_1_1              [C] This expression does not have an address - '&' may only be applied to an lvalue or a function designator.\\
MISRA C:2012 Rule-1.1; REFERENCE - ISO:C90-6.3.3.2 Address and Indirection Operators - Constraints

457    Rule_1_1              [C] The address-of operator '&' cannot be applied to a bit-field.\\
MISRA C:2012 Rule-1.1; REFERENCE - ISO:C90-6.3.3.2 Address and Indirection Operators - Constraints

458    Rule_1_1              [C] Indirection operator '*' requires operand of pointer type.\\
MISRA C:2012 Rule-1.1; REFERENCE - ISO:C90-6.3.3.2 Address and Indirection Operators - Constraints

466    Rule_1_1              [C] Unary '+' requires arithmetic operand.\\
MISRA C:2012 Rule-1.1; REFERENCE - ISO:C90-6.3.3.3 Unary Arithmetic Operators - Constraints

467    Rule_1_1              [C] Operand of '!' must have scalar (arithmetic or pointer) type.\\
MISRA C:2012 Rule-1.1; REFERENCE - ISO:C90-6.3.3.3 Unary Arithmetic Operators - Constraints

468    Rule_1_1              [C] Unary '-' requires arithmetic operand.\\
MISRA C:2012 Rule-1.1; REFERENCE - ISO:C90-6.3.3.3 Unary Arithmetic Operators - Constraints

469    Rule_1_1              [C] Bitwise not '~' requires integral operand.\\
MISRA C:2012 Rule-1.1; REFERENCE - ISO:C90-6.3.3.3 Unary Arithmetic Operators - Constraints

475    Rule_1_3              [u] Operand of 'sizeof' is an expression designating a bit-field.\\
MISRA C:2012 Rule-1.3; REFERENCE - ISO:C90-6.3.3.4 The sizeof Operator

476    Rule_1_1              [C] 'sizeof' cannot be applied to a bit-field.\\
MISRA C:2012 Rule-1.1; REFERENCE - ISO:C90-6.3.3.4 The sizeof Operator - Constraints

477    Rule_1_1              [C] 'sizeof' cannot be applied to a function.\\
MISRA C:2012 Rule-1.1; REFERENCE - ISO:C90-6.3.3.4 The sizeof Operator - Constraints

478    Rule_1_1              [C] 'sizeof' cannot be applied to an object of unknown size.\\
MISRA C:2012 Rule-1.1; REFERENCE - ISO:C90-6.3.3.4 The sizeof Operator - Constraints

481    Rule_1_1              [C] Only scalar expressions may be cast to other types.\\
MISRA C:2012 Rule-1.1; REFERENCE - ISO:C90-6.3.4 Cast Operators - Constraints

482    Rule_1_1              [C] Expressions may only be cast to 'void' or scalar types.\\
MISRA C:2012 Rule-1.1; REFERENCE - ISO:C90-6.3.4 Cast Operators - Constraints

483    Rule_1_1              [C] A pointer to an object of unknown size cannot be the operand of an addition operator.\\
MISRA C:2012 Rule-1.1; REFERENCE - ISO:C90-6.3.6 Additive Operators - Constraints

484    Rule_1_1              [C] A pointer to an object of unknown size cannot be the operand of a subtraction operator.\\
MISRA C:2012 Rule-1.1; REFERENCE - ISO:C90-6.3.6 Additive Operators - Constraints

485    Rule_1_1              [C] Only integral expressions may be added to pointers.\\
MISRA C:2012 Rule-1.1; REFERENCE - ISO:C90-6.3.6 Additive Operators - Constraints

486    Rule_1_1              [C] Only integral expressions and compatible pointers may be subtracted from pointers.\\
MISRA C:2012 Rule-1.1; REFERENCE - ISO:C90-6.3.6 Additive Operators - Constraints

487    Rule_1_1              [C] If two pointers are subtracted, they must be pointers that address compatible types.\\
MISRA C:2012 Rule-1.1; REFERENCE - ISO:C90-6.3.6 Additive Operators - Constraints

488    Rule_18_4             Performing pointer arithmetic.\\
MISRA C:2012 Rule-18.4; REFERENCE - ISO:C90-6.3.6 Additive Operators - Constraints

493    Rule_1_1              [C] Type of left operand is not compatible with this operator.\\
MISRA C:2012 Rule-1.1; REFERENCE - ISO:C90-6.3.5 Multiplicative Operators - Constraints

494    Rule_1_1              [C] Type of right operand is not compatible with this operator.\\
MISRA C:2012 Rule-1.1; REFERENCE - ISO:C90-6.3.5 Multiplicative Operators - Constraints

495    Rule_1_1              [C] Left operand of '%', '<<', '>>', '&', '^' or '|' must have integral type.\\
MISRA C:2012 Rule-1.1; REFERENCE - ISO:C90-6.3.5, ISO:C90-6.3.7, ISO:C90-6.3.10, ISO:C90-6.3.11, ISO:C90-6.3.12

496    Rule_1_1              [C] Right operand of '%', '<<', '>>', '&', '^' or '|' must have integral type.\\
MISRA C:2012 Rule-1.1; REFERENCE - ISO:C90-6.3.5, ISO:C90-6.3.7, ISO:C90-6.3.10, ISO:C90-6.3.11, ISO:C90-6.3.12

499    Rule_12_2             Right operand of shift operator is greater than or equal to the width of the essential type of the left operand.\\
MISRA C:2012 Rule-12.2; REFERENCE - ISO:C90-6.3.7 Bitwise Shift Operators - Semantics

513    Rule_1_1              [C] Relational operator used to compare pointers to incompatible types.\\
MISRA C:2012 Rule-1.1; REFERENCE - ISO:C90-6.3.8 Relational Operators - Constraints

514    Rule_1_1              [C] Relational operator used to compare a pointer with an incompatible operand.\\
MISRA C:2012 Rule-1.1; REFERENCE - ISO:C90-6.3.8 Relational Operators - Constraints

515    Rule_1_1              [C] Equality operator used to compare a pointer with an incompatible operand.\\
MISRA C:2012 Rule-1.1; REFERENCE - ISO:C90-6.3.9 Equality Operators - Constraints

536    Rule_1_1              [C] First operand of '&&', '||' or '?' must have scalar (arithmetic or pointer) type.\\
MISRA C:2012 Rule-1.1; REFERENCE - ISO:C90-6.3.13-15 Logical AND Operator - Constraints

537    Rule_1_1              [C] Second operand of '&&' or '||' must have scalar (arithmetic or pointer) type.\\
MISRA C:2012 Rule-1.1; REFERENCE - ISO:C90-6.3.13-14 Logical AND Operator - Constraints

540    Rule_1_1              [C] 2nd and 3rd operands of conditional operator '?' must have compatible types.\\
MISRA C:2012 Rule-1.1; REFERENCE - ISO:C90-6.3.15 Conditional Operator - Constraints

541    Rule_1_1              [C] Argument no. %s does not have object type.\\
MISRA C:2012 Rule-1.1; REFERENCE - ISO:C90-6.3.2.2 Function Calls - Constraints

542    Rule_1_1              [C] Controlling expression must have scalar (arithmetic or pointer) type.\\
MISRA C:2012 Rule-1.1; REFERENCE - ISO:C90-6.6.4.1 The if Statement - Constraints, ISO:C90-6.6.5 Iteration Statements - Constraints

543    Rule_1_3              [U] 'void' expressions have no value and may not be used in expressions.\\
MISRA C:2012 Rule-1.3; REFERENCE - ISO:C90-6.2.2.2 void

544    Rule_1_3              [U] The value of an incomplete 'union' may not be used.\\
MISRA C:2012 Rule-1.3; REFERENCE - ISO:C90-6.2.2.1 lvalues

545    Rule_1_3              [U] The value of an incomplete 'struct' may not be used.\\
MISRA C:2012 Rule-1.3; REFERENCE - ISO:C90-6.2.2.1 lvalues

546    Rule_1_1              [C] 'enum %s' has unknown content. Use of an enum tag with undefined content is not permitted.\\
MISRA C:2012 Rule-1.1; REFERENCE - ISO:C90-6.5.2.3 Tags

547    Rule_1_1              [C] This declaration of tag '%s' conflicts with a previous declaration.\\
MISRA C:2012 Rule-1.1; REFERENCE - ISO:C90-6.5 Declarations - Constraints, ISO:C90-6.5.2.3 Tags

550    Rule_1_1              [C] Left operand of '+=' or '-=' is a pointer to an object of unknown size.\\
MISRA C:2012 Rule-1.1; REFERENCE - ISO:C90-6.3.16.2 Compound Assignment - Constraints

551    Rule_1_2              [E] Cast may not operate on the left operand of the assignment operator.\\
MISRA C:2012 Rule-1.2

554    Rule_1_1              [C] 'static %s()' has been declared and called but no definition has been given.\\
MISRA C:2012 Rule-1.1; REFERENCE - ISO:C90-6.7 External Definitions - Constraints

555    Rule_1_1              [C] Invalid assignment to object of void type or array type.\\
MISRA C:2012 Rule-1.1; REFERENCE - ISO:C90-6.3.16 Assignment Operators - Constraints

556    Rule_1_1              [C] Left operand of assignment must be a modifiable object.\\
MISRA C:2012 Rule-1.1; REFERENCE - ISO:C90-6.3.16 Assignment Operators - Constraints

557    Rule_1_1              [C] Right operand of assignment is not of arithmetic type.\\
MISRA C:2012 Rule-1.1; REFERENCE - ISO:C90-6.3.16 Assignment Operators - Constraints

558    Rule_1_1              [C] Right operand of '+=' or '-=' must have integral type when left operand is a pointer.\\
MISRA C:2012 Rule-1.1; REFERENCE - ISO:C90-6.3.16.2 Compound Assignment - Constraints

559    Rule_1_1              [C] Right operand of '<<=', '>>=', '&=', '|=', '^=' or '%=' must have integral type.\\
MISRA C:2012 Rule-1.1; REFERENCE - ISO:C90-6.3.16.2 Compound Assignment - Constraints

560    Rule_1_1              [C] Left operand of '<<=', '>>=', '&=', '|=', '^=' or '%=' must have integral type.\\
MISRA C:2012 Rule-1.1; REFERENCE - ISO:C90-6.3.16.2 Compound Assignment - Constraints

561    Rule_1_1              [C] Right operand of assignment is not of compatible 'struct'/'union' type.\\
MISRA C:2012 Rule-1.1; REFERENCE - ISO:C90-6.3.16.1 Simple Assignment - Constraints

562    Rule_1_1              [C] Right operand of assignment points to a more heavily qualified type.\\
MISRA C:2012 Rule-1.1; REFERENCE - ISO:C90-6.3.16.1 Simple Assignment - Constraints

563    Rule_1_1              [C] Right operand of assignment is not of compatible pointer type.\\
MISRA C:2012 Rule-1.1; REFERENCE - ISO:C90-6.3.16.1 Simple Assignment - Constraints

564    Rule_1_1              [C] Left operand of assignment must be an lvalue (it must designate an object).\\
MISRA C:2012 Rule-1.1; REFERENCE - ISO:C90-6.3.16 Assignment Operators - Constraints

565    Rule_1_1              [C] Left operand of '+=' or '-=' must be of arithmetic or pointer to object type.\\
MISRA C:2012 Rule-1.1; REFERENCE - ISO:C90-6.3.16.2 Compound Assignment - Constraints

570    Rule_10_3             This switch case label of 'essential type' '%1s', is not consistent with a controlling expression of essential type '%2s'.\\
MISRA C:2012 Rule-10.3

572    Rule_10_3             This switch case label of 'essential type' '%1s' is not consistent with a controlling expression which has an essential type of lower rank (%2s).\\
MISRA C:2012 Rule-10.3

580    Rule_1_1              [C] Constant is too large to be representable.\\
MISRA C:2012 Rule-1.1; REFERENCE - ISO:C90-6.4 Constant Expressions - Constraints

581    Dir_1_1               [I] Floating-point constant may be too small to be representable.\\
MISRA C:2012 Dir-1.1; REFERENCE - ISO:C90-5.2.4.2.2 Characteristics of Floating Types

588    Rule_1_1              [C] Width of bit-field must be an integral constant expression.\\
MISRA C:2012 Rule-1.1; REFERENCE - ISO:C90-6.5.2.1 Structure and Union Specifiers - Constraints

589    Rule_1_1              [C] Enumeration constant must be an integral constant expression.\\
MISRA C:2012 Rule-1.1; REFERENCE - ISO:C90-6.5.2.2 Enumeration Specifiers - Constraints

590    Rule_1_1              [C] Array bound must be an integral constant expression.\\
MISRA C:2012 Rule-1.1; REFERENCE - ISO:C90-6.5.4.2 Array Declarators - Constraints

591    Rule_1_1              [C] A 'case' label must be an integral constant expression.\\
MISRA C:2012 Rule-1.1; REFERENCE - ISO:C90-6.6.4.2 The switch Statement - Constraints

594    Rule_2_1              Negative 'case' label expression is incompatible with unsigned controlling expression in 'switch' statement.\\
MISRA C:2012 Rule-2.1

601    Rule_1_2              [E] Function 'main()' is not of type 'int (void)' or 'int (int, char *[])'.\\
MISRA C:2012 Rule-1.2; REFERENCE - ISO:C90-5.1.2.2 Hosted environment

602    Rule_21_2             [U] The identifier '%s' is reserved for use by the library.\\
MISRA C:2012 Rule-1.3, Rule-21.2; REFERENCE - ISO:C90-7.1.3 Reserved Identifiers

604    Dir_1_1               [C99] Declaration appears after statements in a compound statement.\\
MISRA C:2012 Dir-1.1; REFERENCE - ISO:C90-6.6.2 Compound Statement, or Block - Syntax

605    Rule_1_1              [C] A declaration must declare a tag or an identifier.\\
MISRA C:2012 Rule-1.1; REFERENCE - ISO:C90-6.5 Declarations - Constraints

609    Dir_1_1               [L] More than 12 pointer, array or function declarators modifying a declaration - program does not conform strictly to ISO:C90.\\
MISRA C:2012 Dir-1.1; REFERENCE - ISO:C90-5.2.4.1 Translation Limits

611    Dir_1_1               [L] Nesting of 'struct' or 'union' types exceeds 15 - program does not conform strictly to ISO:C90.\\
MISRA C:2012 Dir-1.1; REFERENCE - ISO:C90-5.2.4.1 Translation Limits

612    Dir_1_1               [L] Size of object '%s' exceeds 32767 bytes - program does not conform strictly to ISO:C90.\\
MISRA C:2012 Dir-1.1; REFERENCE - ISO:C90-5.2.4.1 Translation Limits

614    Dir_1_1               [L] More than 127 block scope identifiers defined within a block - program does not conform strictly to ISO:C90.\\
MISRA C:2012 Dir-1.1; REFERENCE - ISO:C90-5.2.4.1 Translation Limits

616    Rule_1_1              [C] Illegal combination of type specifiers or storage class specifiers.\\
MISRA C:2012 Rule-1.1; REFERENCE - ISO:C90-6.5.1 Storage-Class Specifiers - Constraints, ISO:C90-6.5.2 Type Specifiers - Constraints

617    Dir_1_1               [C99] 'const' qualifier has been duplicated.\\
MISRA C:2012 Dir-1.1; REFERENCE - ISO:C90-6.5.3 Type Qualifiers, ISO:C99-6.7.3 Type Qualifiers

618    Dir_1_1               [C99] 'volatile' qualifier has been duplicated.\\
MISRA C:2012 Dir-1.1; REFERENCE - ISO:C90-6.5.3 Type Qualifiers, ISO:C99-6.7.3 Type Qualifiers

619    Rule_1_1              [C] The identifier '%s' has already been defined in the current scope within the ordinary identifier namespace.\\
MISRA C:2012 Rule-1.1; REFERENCE - ISO:C90-6.5 Declarations - Constraints, ISO:C90-6.7 External Definitions - Semantics

620    Rule_1_1              [C] Cannot initialize '%s' because it has unknown size.\\
MISRA C:2012 Rule-1.1; REFERENCE - ISO:C90-6.5.7 Initialization - Constraints

621    Rule_1_1              [C] The struct/union '%s' cannot be initialized because it has unknown size.\\
MISRA C:2012 Rule-1.1; REFERENCE - ISO:C90-6.5.7 Initialization - Constraints

622    Rule_1_1              [C] The identifier '%s' has been declared both with and without linkage in the same scope.\\
MISRA C:2012 Rule-1.1; REFERENCE - ISO:C90-6.5 Declarations - Constraints

623    Rule_1_3              [U] '%s' has incomplete type and no linkage - this is undefined.\\
MISRA C:2012 Rule-1.3; REFERENCE - ISO:C90-6.5 Declarations - Semantics

624    Rule_8_3              Function '%s' is declared using typedefs which are different to those in a previous declaration.\\
MISRA C:2012 Rule-8.3; REFERENCE - ISO:C90-6.1.2.6 Compatible Type and Composite Type

625    Rule_1_3              [U] '%s' has been declared with both internal and external linkage - the behaviour is undefined.\\
MISRA C:2012 Rule-1.3; REFERENCE - ISO:C90-6.1.2.2 Linkages of Identifiers

626    Rule_1_3              [U] '%s' has different type to previous declaration (which is no longer in scope).\\
MISRA C:2012 Rule-1.3; REFERENCE - ISO:C90-6.1.2.6 Compatible Type and Composite Type

627    Rule_1_1              [C] '%s' has different type to previous declaration in the same scope.\\
MISRA C:2012 Rule-1.1; REFERENCE - ISO:C90-6.5 Declarations - Constraints

628    Rule_1_1              [C] '%s' has different type to previous declaration at wider scope.\\
MISRA C:2012 Rule-1.1; REFERENCE - ISO:C90-6.5 Declarations - Constraints

629    Rule_1_1              [C] More than one definition of '%s' (with internal linkage).\\
MISRA C:2012 Rule-1.1; REFERENCE - ISO:C90-6.7 External Definitions - Constraints

630    Rule_8_6              [U] More than one definition of '%s' (with external linkage).\\
MISRA C:2012 Rule-1.3, Rule-8.6; REFERENCE - ISO:C90-6.7 External Definitions - Semantics

631    Rule_1_1              [C] More than one declaration of '%s' (with no linkage).\\
MISRA C:2012 Rule-1.1; REFERENCE - ISO:C90-6.5 Declarations - Constraints

632    Rule_1_3              [U] Tentative definition of '%s' with internal linkage cannot have unknown size.\\
MISRA C:2012 Rule-1.3; REFERENCE - ISO:C90-6.7.2 External Object Definitions

633    Rule_1_2              [E] Empty structures and unions are a language extension.\\
MISRA C:2012 Rule-1.2; REFERENCE - ISO:C90-6.5.2.1 Structure and Union Specifiers - Syntax

634    Rule_6_1              [I] Bit-fields in this struct/union have not been declared explicitly as unsigned or signed.\\
MISRA C:2012 Dir-1.1, Rule-6.1; REFERENCE - ISO:C90-6.5.2.1 Structure and Union Specifiers - Semantics

635    Rule_6_1              [E] Bit-fields in this struct/union have been declared with types other than int, signed int or unsigned int.\\
MISRA C:2012 Rule-1.2, Rule-6.1; REFERENCE - ISO:C90-6.5.2.1 Structure and Union Specifiers - Semantics

636    Rule_1_3              [U] There are no named members in this 'struct' or 'union'.\\
MISRA C:2012 Rule-1.3; REFERENCE - ISO:C90-6.5.2.1 Structure and Union Specifiers - Semantics

638    Rule_1_1              [C] Duplicate member name '%s' in 'struct' or 'union'.\\
MISRA C:2012 Rule-1.1; REFERENCE - ISO:C90-6.5 Declarations - Constraints

639    Dir_1_1               [L] Number of members in 'struct' or 'union' exceeds 127 - program does not conform strictly to ISO:C90.\\
MISRA C:2012 Dir-1.1; REFERENCE - ISO:C90-5.2.4.1 Translation Limits

640    Rule_1_1              [C] '%s' in 'struct' or 'union' type may not have 'void' type.\\
MISRA C:2012 Rule-1.1; REFERENCE - ISO:C90-6.5.2.1 Structure and Union Specifiers - Constraints

641    Rule_1_1              [C] '%s' in 'struct' or 'union' type may not have function type.\\
MISRA C:2012 Rule-1.1; REFERENCE - ISO:C90-6.5.2.1 Structure and Union Specifiers - Constraints

642    Rule_1_1              [C] '%s' in 'struct' or 'union' type may not be an array of unknown size.\\
MISRA C:2012 Rule-1.1; REFERENCE - ISO:C90-6.5.2.1 Structure and Union Specifiers - Constraints

643    Rule_1_1              [C] '%s' in 'struct' or 'union' type may not be a 'struct' or 'union' with unknown content.\\
MISRA C:2012 Rule-1.1; REFERENCE - ISO:C90-6.5.2.1 Structure and Union Specifiers - Constraints

644    Rule_1_1              [C] Width of bit-field must be no bigger than the width of an 'int'.\\
MISRA C:2012 Rule-1.1; REFERENCE - ISO:C90-6.5.2.1 Structure and Union Specifiers - Constraints

645    Rule_1_1              [C] A zero width bit-field cannot be given a name.\\
MISRA C:2012 Rule-1.1; REFERENCE - ISO:C90-6.5.2.1 Structure and Union Specifiers - Constraints

646    Rule_1_1              [C] Enumeration constants must have values representable as 'int's.\\
MISRA C:2012 Rule-1.1; REFERENCE - ISO:C90-6.5.2.2 Enumeration Specifiers - Constraints

647    Dir_1_1               [L] Number of enumeration constants exceeds 127 - program does not conform strictly to ISO:C90.\\
MISRA C:2012 Dir-1.1; REFERENCE - ISO:C90-5.2.4.1 Translation Limits

649    Rule_1_1              [C] K&R style declaration of parameters is not legal after a function header that includes a parameter list.\\
MISRA C:2012 Rule-1.1; REFERENCE - ISO:C90-6.5.4.3 Function Declarators - Constraints, ISO:C90-6.7.1 Function Definitions - Constraints

650    Rule_1_1              [C] Illegal storage class specifier on named function parameter.\\
MISRA C:2012 Rule-1.1; REFERENCE - ISO:C90-6.5.4.3 Function Declarators - Constraints, ISO:C90-6.7.1 Function Definitions - Constraints

651    Rule_1_1              [C] Missing type specifiers in function declaration.\\
MISRA C:2012 Rule-1.1; REFERENCE - ISO:C90-6.5.4.3 Function Declarators - Constraints

653    Rule_1_1              [C] Duplicate definition of 'struct', 'union' or 'enum' tag '%s'.\\
MISRA C:2012 Rule-1.1; REFERENCE - ISO:C90-6.5 Declarations - Constraints, ISO:C90-6.5.2.3 Tags

654    Rule_1_3              [U] Using 'const' or 'volatile' in a function return type is undefined.\\
MISRA C:2012 Rule-1.3; REFERENCE - ISO:C90-6.5.3 Type Qualifiers - Semantics

655    Rule_1_1              [C] Illegal storage class specifier on unnamed function parameter.\\
MISRA C:2012 Rule-1.1; REFERENCE - ISO:C90-6.5.4.3 Function Declarators - Constraints, ISO:C90-6.7.1 Function Definitions - Constraints

656    Rule_1_1              [C] Function return type cannot be function or array type, or an incomplete struct/union (for function definition).\\
MISRA C:2012 Rule-1.1; REFERENCE - ISO:C90-6.5.4.3 Function Declarators - Constraints, ISO:C90-6.7.1 Function Definitions - Constraints

657    Rule_1_1              [C] Unnamed parameter specified in function definition.\\
MISRA C:2012 Rule-1.1; REFERENCE - ISO:C90-6.7.1 Function Definitions - Constraints

658    Rule_1_3              [U] Parameter cannot have 'void' type.\\
MISRA C:2012 Rule-1.3; REFERENCE - ISO:C90-6.5.4.3 Function Declarators - Semantics

659    Rule_1_1              [C] The identifier '%s' was not given in the parameter list.\\
MISRA C:2012 Rule-1.1; REFERENCE - ISO:C90-6.7.1 Function Definitions - Constraints

660    Rule_1_2              [E] Defining an unnamed member in a struct or union. This is a language extension.\\
MISRA C:2012 Rule-1.2

661    Rule_1_3              [U] '%s()' may not have a storage class specifier of 'static' when declared at block scope.\\
MISRA C:2012 Rule-1.3; REFERENCE - ISO:C90-6.5.1 Storage-Class Specifiers - Semantics

662    Rule_1_2              [E] Accessing a member of an unnamed struct or union member in this way is a language extension.\\
MISRA C:2012 Rule-1.2

664    Rule_1_1              [C] Parameter specified with type 'void'.\\
MISRA C:2012 Rule-1.1; REFERENCE - ISO:C90-6.5.4.3 Function Declarators - Semantics, ISO:C90-6.5 Declarations - Constraints

665    Rule_1_1              [C] Two parameters have been declared with the same name '%s'.\\
MISRA C:2012 Rule-1.1; REFERENCE - ISO:C90-6.5 Declarations - Constraints

667    Rule_1_3              [U] '%s' is declared as a typedef and may not be redeclared as an object at an inner scope without an explicit type specifier.\\
MISRA C:2012 Rule-1.3; REFERENCE - ISO:C90-6.5.6 Type Definitions - Semantics

668    Rule_1_3              [U] '%s' is declared as a typedef and may not be redeclared as a member of a 'struct' or 'union' without an explicit type specifier.\\
MISRA C:2012 Rule-1.3; REFERENCE - ISO:C90-6.5.6 Type Definitions - Semantics

671    Rule_1_1              [C] Initializer for object of arithmetic type is not of arithmetic type.\\
MISRA C:2012 Rule-1.1; REFERENCE - ISO:C90-6.5.7 Initialization - Semantics, ISO:C90-6.3.16.1 Simple Assignment - Constraints

672    Rule_1_3              [U] The initializer for a 'struct', 'union' or array is not enclosed in braces.\\
MISRA C:2012 Rule-1.3; REFERENCE - ISO:C90-6.5.7 Initialization - Semantics

673    Rule_1_1              [C] Initializer points to a more heavily qualified type.\\
MISRA C:2012 Rule-1.1; REFERENCE - ISO:C90-6.5.7 Initialization - Semantics, ISO:C90-6.3.16.1 Simple Assignment - Constraints

674    Rule_1_1              [C] Initializer for pointer is of incompatible type.\\
MISRA C:2012 Rule-1.1; REFERENCE - ISO:C90-6.5.7 Semantics, ISO:C90-6.3.16.1 Simple Assignment - Constraints

675    Rule_1_1              [C] Initializer is not of compatible 'struct'/'union' type.\\
MISRA C:2012 Rule-1.1; REFERENCE - ISO:C90-6.5.7 Semantics, ISO:C90-6.3.16.1 Simple Assignment - Constraints

676    Rule_1_3              [u] Array element is of function type. Arrays cannot be constructed from function types.\\
MISRA C:2012 Rule-1.3; REFERENCE - ISO:C90-6.1.2.5 Types

677    Rule_1_1              [C] Array size is negative, or unrepresentable.\\
MISRA C:2012 Rule-1.1; REFERENCE - ISO:C90-6.5.4.2 Array Declarators - Constraints

678    Rule_1_3              [u] Array element is array of unknown size. Arrays cannot be constructed from incomplete types.\\
MISRA C:2012 Rule-1.3; REFERENCE - ISO:C90-6.1.2.5 Types

680    Rule_1_3              [u] Array element is 'void' or an incomplete 'struct' or 'union'. Arrays cannot be constructed from incomplete types.\\
MISRA C:2012 Rule-1.3; REFERENCE - ISO:C90-6.1.2.5 Types

682    Rule_1_1              [C] Initializer for object of a character type is a string literal.\\
MISRA C:2012 Rule-1.1; REFERENCE - ISO:C90-6.5.7 Initialization - Semantics, ISO:C90-6.3.16.1 Simple Assignment - Constraints

683    Rule_1_1              [C] Initializer for object of a character type is a wide string literal.\\
MISRA C:2012 Rule-1.1; REFERENCE - ISO:C90-6.5.7 Initialization - Semantics, ISO:C90-6.3.16.1 Simple Assignment - Constraints

684    Rule_1_1              [C] Too many initializers.\\
MISRA C:2012 Rule-1.1; REFERENCE - ISO:C90-6.5.7 Initialization - Constraints

685    Rule_1_1              [C] Initializer for any object with static storage duration must be a constant expression.\\
MISRA C:2012 Rule-1.1; REFERENCE - ISO:C90-6.5.7 Initialization - Constraints, ISO:C90-6.4 Constant Expressions - Constraints.

686    Rule_9_3              Array has fewer initializers than its declared size. Default initialization is applied to the remainder of the array elements.\\
MISRA C:2012 Rule-9.3; REFERENCE - ISO:C90-6.5.7 Initialization - Semantics

690    Rule_1_1              [C] String literal contains too many characters to initialize object.\\
MISRA C:2012 Rule-1.1; REFERENCE - ISO:C90-6.5.7 Initialization - Constraints, Semantics

693    Rule_9_2              Struct initializer is missing the optional {.\\
MISRA C:2012 Rule-9.2; REFERENCE - ISO:C90-6.5.7 Initialization - Semantics

694    Rule_9_2              Array initializer is missing the optional {.\\
MISRA C:2012 Rule-9.2; REFERENCE - ISO:C90-6.5.7 Initialization - Semantics

698    Rule_1_1              [C] String literal used to initialize an object of incompatible type.\\
MISRA C:2012 Rule-1.1; REFERENCE - ISO:C90-6.5.7 Initialization - Semantics, ISO:C90-6.3.16.1 Simple Assignment - Constraints

699    Rule_1_1              [C] String literal used to initialize a pointer of incompatible type.\\
MISRA C:2012 Rule-1.1; REFERENCE - ISO:C90-6.5.7 Initialization - Semantics, ISO:C90-6.3.16.1 Simple Assignment - Constraints

706    Rule_1_3              [U] Label '%s' is not unique within this function.\\
MISRA C:2012 Rule-1.3; REFERENCE - ISO:C90-6.1.2.1 Scopes of Identifiers

708    Rule_1_1              [C] No definition found for the label '%s' in this function.\\
MISRA C:2012 Rule-1.1; REFERENCE - ISO:C90-6.6.6.1 The goto Statement - Constraints

709    Rule_1_1              [C] Initialization of locally declared 'extern %s' is illegal.\\
MISRA C:2012 Rule-1.1; REFERENCE - ISO:C90-6.5.7 Initialization - Constraints

715    Dir_1_1               [L] Nesting of control structures (statements) exceeds 15 - program does not conform strictly to ISO:C90.\\
MISRA C:2012 Dir-1.1; REFERENCE - ISO:C90-5.2.4.1 Translation Limits

735    Rule_16_7             Using relational or logical operators in a 'switch' expression is usually a programming error.\\
MISRA C:2012 Rule-16.7

736    Rule_1_1              [C] 'case' label does not have unique value within this 'switch' statement.\\
MISRA C:2012 Rule-1.1; REFERENCE - ISO:C90-6.6.4.2 The switch Statement - Constraints

737    Rule_1_1              [C] More than one 'default' label found in 'switch' statement.\\
MISRA C:2012 Rule-1.1; REFERENCE - ISO:C90-6.6.4.2 The switch Statement - Constraints

738    Rule_1_1              [C] Controlling expression in a 'switch' statement must have integral type.\\
MISRA C:2012 Rule-1.1; REFERENCE - ISO:C90-6.6.4.2 The switch Statement - Constraints

739    Dir_1_1               [L] Number of 'case' labels exceeds 257 - program does not conform strictly to ISO:C90.\\
MISRA C:2012 Dir-1.1; REFERENCE - ISO:C90-5.2.4.1 Translation Limits

745    Rule_17_4             [U] 'return;' found in '%s()', which has been defined with a non-'void' return type.\\
MISRA C:2012 Rule-1.3, Rule-17.4; REFERENCE - ISO:C90-6.6.6.4 The return Statement - Semantics

746    Rule_1_1              [C] 'return exp;' found in '%s()' whose return type is 'void'.\\
MISRA C:2012 Rule-1.1; REFERENCE - ISO:C90-6.6.6.4 The return Statement - Constraints

747    Rule_1_1              [C] 'return exp;' found in '%s()' whose return type is qualified 'void'.\\
MISRA C:2012 Rule-1.1; REFERENCE - ISO:C90-6.6.6.4 The return Statement - Constraints

750    Rule_19_2             A union type specifier has been defined.\\
MISRA C:2012 Rule-19.2

752    Rule_7_4              String literal passed as argument to function whose parameter is not a 'pointer to const'.\\
MISRA C:2012 Rule-7.4; REFERENCE - ISO:C90-6.1.4 String Literals - Semantics

753    Rule_7_4              String literal assigned to pointer which is not a 'pointer to const'.\\
MISRA C:2012 Rule-7.4; REFERENCE - ISO:C90-6.1.4 String Literals - Semantics

755    Rule_1_1              [C] 'return' expression is not of arithmetic type.\\
MISRA C:2012 Rule-1.1; REFERENCE - ISO:C90-6.6.6.4 The return Statement - Semantics, ISO:C90-6.3.16.1 Simple Assignment - Constraints

756    Rule_1_1              [C] 'return' expression is not of compatible 'struct'/'union' type.\\
MISRA C:2012 Rule-1.1; REFERENCE - ISO:C90-6.6.6.4 The return Statement - Semantics, ISO:C90-6.3.16.1 Simple Assignment - Constraints

757    Rule_1_1              [C] 'return' expression points to a more heavily qualified type.\\
MISRA C:2012 Rule-1.1; REFERENCE - ISO:C90-6.6.6.4 The return Statement - Semantics, ISO:C90-6.3.16.1 Simple Assignment - Constraints

758    Rule_1_1              [C] 'return' expression is not of compatible pointer type.\\
MISRA C:2012 Rule-1.1; REFERENCE - ISO:C90-6.6.6.4 The return Statement - Semantics, ISO:C90-6.3.16.1 Simple Assignment - Constraints

759    Rule_19_2             An object of union type has been defined.\\
MISRA C:2012 Rule-19.2

766    Rule_1_1              [C] 'continue' statement found outside an iteration statement.\\
MISRA C:2012 Rule-1.1; REFERENCE - ISO:C90-6.6.6.2 The continue Statement - Constraints

767    Rule_1_1              [C] 'break' statement found outside a 'switch' or iteration statement.\\
MISRA C:2012 Rule-1.1; REFERENCE - ISO:C90-6.6.6.3 The break Statement - Constraints

768    Rule_1_1              [C] 'case' or 'default' found outside a 'switch' statement.\\
MISRA C:2012 Rule-1.1; REFERENCE - ISO:C90-6.6.1 Labeled Statements - Constraints

771    Rule_15_4             More than one 'break' statement has been used to terminate this iteration statement.\\
MISRA C:2012 Rule-15.4

774    Rule_1_1              [C] 'auto' may not be specified on global declaration of '%s'.\\
MISRA C:2012 Rule-1.1; REFERENCE - ISO:C90-6.7 External Definitions - Constraints

775    Rule_1_1              [C] 'register' may not be specified on global declaration of '%s'.\\
MISRA C:2012 Rule-1.1; REFERENCE - ISO:C90-6.7 External Definitions - Constraints

777    Rule_5_1              [U] External identifier does not differ from other identifier(s) (e.g. '%s') within the specified number of significant characters.\\
MISRA C:2012 Rule-1.3, Rule-5.1; REFERENCE - ISO:C90-6.1.2 Identifiers - Implementation Limits

779    Rule_5_2              [U] Identifier does not differ from other identifier(s) (e.g. '%s') within the specified number of significant characters.\\
MISRA C:2012 Rule-1.3, Rule-5.2; REFERENCE - ISO:C90-6.1.2 Identifiers - Implementation Limits

801    Rule_1_1              [C] The '##' operator may not be the first token in a macro replacement list.\\
MISRA C:2012 Rule-1.1; REFERENCE - ISO:C90-6.8.3.3 The ## Operator - Constraints

802    Rule_1_1              [C] The '##' operator may not be the last token in a macro replacement list.\\
MISRA C:2012 Rule-1.1; REFERENCE - ISO:C90-6.8.3.3 The ## Operator - Constraints

803    Rule_1_1              [C] The '#' operator may only appear before a macro parameter.\\
MISRA C:2012 Rule-1.1; REFERENCE - ISO:C90-6.8.3.2 The # Operator - Constraints

804    Rule_1_1              [C] Macro parameter '%s' is not unique.\\
MISRA C:2012 Rule-1.1; REFERENCE - ISO:C90-6.8.3 Macro Replacement - Constraints

809    Rule_20_3             [U] The '#include' preprocessing directive has not been followed by <h-char-sequence> or "s-char-sequence".\\
MISRA C:2012 Rule-1.3, Rule-20.3; REFERENCE - ISO:C90-6.8.2 Source File Inclusion - Semantics

810    Dir_1_1               [L] '#include "%s"' causes nesting to exceed 8 levels - program does not conform strictly to ISO:C90.\\
MISRA C:2012 Dir-1.1; REFERENCE - ISO:C90-5.2.4.1 Translation Limits

811    Rule_1_1              [C] The glue operator '##' may only appear in a '#define' preprocessing directive.\\
MISRA C:2012 Rule-1.1; REFERENCE - ISO:C90-6.1.5 Operators - Constraints

812    Rule_1_1              [C] Header name token '<text>' found outside '#include' preprocessing directive.\\
MISRA C:2012 Rule-1.1; REFERENCE - ISO:C90-6.1.7 Header Names - Constraints

813    Rule_20_2             [U] Using any of the characters ' " or /* in '#include <%s>' gives undefined behaviour.\\
MISRA C:2012 Rule-1.3, Rule-20.2; REFERENCE - ISO:C90-6.1.7 Header Names

814    Rule_20_2             [U] Using the characters ' or /* in '#include "%s"' gives undefined behaviour.\\
MISRA C:2012 Rule-1.3, Rule-20.2; REFERENCE - ISO:C90-6.1.7 Header Names

821    Rule_1_1              [C] '#include %s' does not identify a header or source file that can be processed.\\
MISRA C:2012 Rule-1.1; REFERENCE - ISO:C90-6.8.2 Source File Inclusion - Constraints

828    Dir_1_1               [L] More than 8 levels of nested conditional inclusion - program does not conform strictly to ISO:C90.\\
MISRA C:2012 Dir-1.1; REFERENCE - ISO:C90-5.2.4.1 Translation Limits

830    Rule_1_2              [E] Unrecognized text encountered after a preprocessing directive.\\
MISRA C:2012 Rule-1.2; REFERENCE - ISO:C90-6.8 Preprocessing Directives - Syntax

831    Rule_20_2             [E] Use of '\\' in this '#include' line is a PC extension - this usage is non-portable.\\
MISRA C:2012 Rule-1.2, Rule-20.2; REFERENCE - ISO:C90-6.1.7 Header Names - Semantics

834    Rule_1_1              [C] Function-like macro '%s()' is being redefined as an object-like macro.\\
MISRA C:2012 Rule-1.1; REFERENCE - ISO:C90-6.8.3 Macro Replacement - Constraints

835    Rule_1_1              [C] Macro '%s' is being redefined with different parameter names.\\
MISRA C:2012 Rule-1.1; REFERENCE - ISO:C90-6.8.3 Macro Replacement - Constraints

836    Rule_21_1             [U] Definition of macro named 'defined'.\\
MISRA C:2012 Rule-1.3, Rule-21.1; REFERENCE - ISO:C90-6.8.8 Predefined Macro Names

837    Rule_1_3              [U] Use of '#undef' to remove the operator 'defined'.\\
MISRA C:2012 Rule-1.3; REFERENCE - ISO:C90-6.8.8 Predefined Macro Names

841    Rule_20_5             Using '#undef'.\\
MISRA C:2012 Rule-20.5; REFERENCE - ISO:C90-6.8.3.5 Scope of Macro Definitions

844    Rule_1_1              [C] Macro '%s' is being redefined with a different replacement list.\\
MISRA C:2012 Rule-1.1; REFERENCE - ISO:C90-6.8.3 Macro Replacement - Constraints

845    Rule_1_1              [C] Object-like macro '%s' is being redefined as a function-like macro.\\
MISRA C:2012 Rule-1.1; REFERENCE - ISO:C90-6.8.3 Macro Replacement - Constraints

848    Rule_21_1             [U] Attempting to #undef '%s', which is a predefined macro name.\\
MISRA C:2012 Rule-1.3, Rule-21.1; REFERENCE - ISO:C90-6.8.8 Predefined Macro Names

850    Dir_1_1               [C99] Macro argument is empty.\\
MISRA C:2012 Dir-1.1; REFERENCE - ISO:C90-6.8.3 Macro Replacement - Semantics; ISO:C99 6.10.3

851    Rule_1_1              [C] More arguments in macro call than specified in definition.\\
MISRA C:2012 Rule-1.1; REFERENCE - ISO:C90-6.8.3 Macro Replacement - Constraints

852    Rule_1_1              [C] Unable to find the ')' that marks the end of the macro call.\\
MISRA C:2012 Rule-1.1; REFERENCE - ISO:C90-6.8.3 Macro Replacement - Constraints

853    Rule_20_6             [U] Macro arguments contain a sequence of tokens that has the form of a preprocessing directive.\\
MISRA C:2012 Rule-1.3, Rule-20.6; REFERENCE - ISO:C90-6.8.3 Macro Replacement - Semantics

854    Rule_21_1             [U] Attempting to #define '%s', which is a predefined macro name.\\
MISRA C:2012 Rule-1.3, Rule-21.1; REFERENCE - ISO:C90-6.8.8 Predefined Macro Names

856    Rule_1_1              [C] Fewer arguments in macro call than specified in definition.\\
MISRA C:2012 Rule-1.1; REFERENCE - ISO:C90-6.8.3 Macro Replacement - Constraints

857    Dir_1_1               [L] Number of macro definitions exceeds 1024 - program does not conform strictly to ISO:C90.\\
MISRA C:2012 Dir-1.1; REFERENCE - ISO:C90-5.2.4.1 Translation Limits

858    Dir_1_1               [L] Number of macro parameters exceeds 31 - program does not conform strictly to ISO:C90.\\
MISRA C:2012 Dir-1.1; REFERENCE - ISO:C90-5.2.4.1 Translation Limits

859    Dir_1_1               [L] Number of arguments in macro call exceeds 31 - program does not conform strictly to ISO:C90.\\
MISRA C:2012 Dir-1.1; REFERENCE - ISO:C90-5.2.4.1 Translation Limits

864    Rule_1_3              [U] '#line' directive specifies line number which is not in the range 1 to 32767.\\
MISRA C:2012 Rule-1.3; REFERENCE - ISO:C90-6.8.4 Line Control - Semantics

865    Rule_1_3              [U] '#line' directive is badly formed.\\
MISRA C:2012 Rule-1.3; REFERENCE - ISO:C90-6.8.4 Line Control - Semantics

866    Rule_1_1              [C] The string literal in a '#line' directive cannot be a 'wide string literal'.\\
MISRA C:2012 Rule-1.1; REFERENCE - ISO:C90-6.8.4 Line Control - Constraints

867    Rule_1_3              [U] '#line' has not been followed by a line number.\\
MISRA C:2012 Rule-1.3; REFERENCE - ISO:C90-6.8.4 Line Control - Semantics

872    Rule_1_3              [U] Result of '##' operator is not a legal preprocessing token.\\
MISRA C:2012 Rule-1.3; REFERENCE - ISO:C90-6.8.3.3 The ## Operator - Semantics

873    Rule_1_1              [C] Preprocessing token cannot be converted to an actual token.\\
MISRA C:2012 Rule-1.1; REFERENCE - ISO:C90-6.1 Lexical Elements - Constraints

874    Rule_1_3              [U] Character string literal and wide character string literal are adjacent.\\
MISRA C:2012 Rule-1.3; REFERENCE - ISO:C90-6.1.4 String Literals - Semantics

875    Dir_1_1               [L] String literal exceeds 509 characters - program does not conform strictly to ISO:C90.\\
MISRA C:2012 Dir-1.1; REFERENCE - ISO:C90-5.2.4.1 Translation limits

877    Rule_1_1              [C] '#if' and '#elif' expressions may contain only integral constants.\\
MISRA C:2012 Rule-1.1; REFERENCE - ISO:C90-6.8.1 Conditional Inclusion - Constraints

883    Dir_4_10              Include file code is not protected against repeated inclusion\\
MISRA C:2012 Dir-4.10

885    Rule_1_3              [U] The token 'defined' is generated in the expansion of this macro.\\
MISRA C:2012 Rule-1.3; REFERENCE - ISO:C90-6.8.1 Conditional Inclusion - Semantics

887    Rule_1_3              [U] Use of 'defined' must match either 'defined(identifier)' or 'defined identifier'.\\
MISRA C:2012 Rule-1.3; REFERENCE - ISO:C90-6.8.1 Conditional Inclusion - Semantics

888    Rule_1_3              [U] 'defined' requires an identifier as an argument.\\
MISRA C:2012 Rule-1.3; REFERENCE - ISO:C90-6.8.1 Conditional Inclusion - Semantics

899    Rule_1_2              [E] Unrecognized preprocessing directive has been ignored - assumed to be a language extension.\\
MISRA C:2012 Rule-1.2; REFERENCE - ISO:C90-6.8 Preprocessing Directives, ISO:C90-6.8.3.2 The # Operator

914    Rule_1_3              [U] Source file does not end with a newline character.\\
MISRA C:2012 Rule-1.3; REFERENCE - ISO:C90-5.1.1.2 Translation Phases

915    Rule_1_3              [U] Source file ends with a backslash character followed by a newline.\\
MISRA C:2012 Rule-1.3; REFERENCE - ISO:C90-5.1.1.2 Translation Phases

930    Dir_1_1               [C99] Trailing comma at the end of an enumerator-list.\\
MISRA C:2012 Dir-1.1; REFERENCE - ISO:C90-6.5.2.2 Syntax

940    Rule_1_1              [C] Illegal usage of a variably modified type.\\
MISRA C:2012 Rule-1.1; REFERENCE - ISO:C99-6.7.5.2 Array declarators - Constraints

941    Rule_1_1              [C] A variable length array may not be initialized.\\
MISRA C:2012 Rule-1.1; REFERENCE - ISO:C99-6.7.8 Initialization - Constraints

942    Rule_1_3              [U] A * can only be used to specify array size within function prototype scope.\\
MISRA C:2012 Rule-1.3; REFERENCE - ISO:C99-6.7.5.3 Function Declarators - Semantics

943    Rule_1_1              [C] Jump to label '%s' is a jump into the scope of an identifier with variably modified type.\\
MISRA C:2012 Rule-1.1; REFERENCE - ISO:C99-6.8.6.1 The goto statement - Constraints

944    Rule_1_1              [C] The label '%s' is inside the scope of an identifier with variably modified type.\\
MISRA C:2012 Rule-1.1; REFERENCE - ISO:C99-6.8.6.1 The goto statement - Constraints

945    Rule_18_8             [C99] WARNING. Operand of sizeof is an expression of variable length array type.\\
MISRA C:2012 Rule-18.8; REFERENCE - ISO:C99-6.5.3.4 The sizeof operator - Semantics

1001   Rule_1_2              [E] '#include %s' is a VMS extension.\\
MISRA C:2012 Rule-1.2; REFERENCE - ISO:C90-6.8.2 Form of '#include' directives

1002   Rule_1_2              [E] '%s' is not a legal identifier in ISO C.\\
MISRA C:2012 Rule-1.2; REFERENCE - ISO:C90-6.1.2 Identifiers

1003   Rule_1_2              [E] '#%s' is a language extension for in-line assembler. All statements located between #asm and #endasm will be ignored.\\
MISRA C:2012 Dir-4.2, Rule-1.2; REFERENCE - ISO:C90-6.8 Preprocessing Directives - Syntax

1006   Rule_1_2              [E] This in-line assembler construct is a language extension. The code has been ignored.\\
MISRA C:2012 Dir-4.2, Rule-1.2

1008   Rule_1_2              [E] '#%s' is not a legal ISO C preprocessing directive.\\
MISRA C:2012 Rule-1.2; REFERENCE - ISO:C90-6.8 Preprocessing Directives - Syntax

1011   Dir_1_1               [C99] Use of '//' comment.\\
MISRA C:2012 Dir-1.1; REFERENCE - ISO:C99-6.4.9 Comments

1012   Rule_1_2              [E] Use of a C++ reference type ('type &') will be treated as a language extension.\\
MISRA C:2012 Rule-1.2

1014   Rule_1_2              [E] Non-standard type specifier - this will be treated as a language extension.\\
MISRA C:2012 Rule-1.2

1015   Rule_1_2              [E] '%s' is not a legal keyword in ISO C - this will be treated as a language extension.\\
MISRA C:2012 Rule-1.2

1018   Dir_1_1               [C99] Use of LL suffix.\\
MISRA C:2012 Dir-1.1; REFERENCE - ISO:C99-6.4.4.1 Integer Constants - Syntax

1019   Rule_1_2              [E] '@ address' is not supported in ISO C - this will be treated as a language extension.\\
MISRA C:2012 Rule-1.2

1020   Rule_1_2              [E] '__typeof__' is not supported in ISO C, and is treated as a language extension.\\
MISRA C:2012 Rule-1.2

1021   Rule_1_2              [E] A statement expression is not supported in ISO C, and is treated as a language extension.\\
MISRA C:2012 Rule-1.2

1022   Rule_1_2              [E] '__alignof__' is not supported in ISO C, and is treated as a language extension.\\
MISRA C:2012 Rule-1.2

1023   Rule_1_1              [C] Using '__alignof__' on function types is illegal.\\
MISRA C:2012 Rule-1.1

1024   Rule_1_1              [C] Using '__alignof__' on incomplete types is illegal.\\
MISRA C:2012 Rule-1.1

1025   Rule_1_1              [C] Using '__alignof__' on bit-fields is illegal.\\
MISRA C:2012 Rule-1.1

1026   Rule_1_2              [E] The indicated @word construct has been ignored.\\
MISRA C:2012 Rule-1.2

1027   Dir_1_1               [C99] Use of type 'long long'.\\
MISRA C:2012 Dir-1.1; REFERENCE - ISO:C99-6.2.5 Types

1028   Rule_1_2              [E] Use of the sizeof operator in a preprocessing directive is a language extension.\\
MISRA C:2012 Rule-1.2; REFERENCE - ISO:C90-6.8.1 Conditional Inclusion - Semantics, ISO:C90-6.1.1 Keywords

1029   Rule_1_2              [E] Whitespace encountered between backslash and new-line has been ignored.\\
MISRA C:2012 Rule-1.2; REFERENCE - ISO:C90-5.1.1.2 Translation Phases

1030   Dir_1_1               [C99] Macro defined with variable argument list.\\
MISRA C:2012 Dir-1.1; REFERENCE - ISO:C99-6.10 Preprocessing directives - Syntax

1031   Dir_1_1               [C99] Initializer for 'struct', 'union' or array type is not a constant expression.\\
MISRA C:2012 Dir-1.1; REFERENCE - ISO:C90-6.5.7 Initialization - Constraints

1033   Rule_1_1              [C] The identifier __VA_ARGS__ may only be used in the replacement list of a variadic macro.\\
MISRA C:2012 Rule-1.1; REFERENCE - ISO:C99-6.10.3 Macro Replacement - Constraints

1034   Rule_1_2              [E] Macro defined with named variable argument list. This is a language extension.\\
MISRA C:2012 Rule-1.2

1035   Rule_1_2              [E] No macro arguments supplied for variable argument list. This is a language extension.\\
MISRA C:2012 Rule-1.2

1036   Rule_1_2              [E] Comma before ## ignored in expansion of variadic macro. This is a language extension.\\
MISRA C:2012 Rule-1.2

1037   Rule_1_2              [E] Arrays of length zero are a language extension.\\
MISRA C:2012 Rule-1.2

1038   Rule_1_2              [E] The sequence ", ##__VA_ARGS__" is a language extension.\\
MISRA C:2012 Rule-1.2

1041   Rule_1_2              [E] Empty aggregate initializers are a language extension.\\
MISRA C:2012 Rule-1.2

1042   Rule_1_2              [E] Using I64 or UI64 as an integer constant suffix. This is a language extension.\\
MISRA C:2012 Rule-1.2

1043   Rule_1_2              [E] Defining an anonymous union object. This is a language extension.\\
MISRA C:2012 Rule-1.2

1044   Rule_1_2              [E] Defining an anonymous struct object. This is a language extension.\\
MISRA C:2012 Rule-1.2

1045   Rule_1_2              [E] Use of the #include_next preprocessing directive is a language extension.\\
MISRA C:2012 Rule-1.2

1046   Rule_1_2              [E] Function is being declared with default argument syntax. This is a language extension.\\
MISRA C:2012 Rule-1.2

1047   Rule_1_1              [C] Function is being declared with default argument syntax after a previous call to the function. This is not allowed.\\
MISRA C:2012 Rule-1.1

1048   Rule_1_1              [C] Default argument values are missing for some parameters in this function declaration. This is not allowed.\\
MISRA C:2012 Rule-1.1

1051   Rule_18_8             [C99] A variable length array has been declared.\\
MISRA C:2012 Rule-18.8; REFERENCE - ISO:C99-6.7.5.2 Array declarators

1052   Rule_18_8             [C99] A variable length array of unspecified size has been declared.\\
MISRA C:2012 Rule-18.8; REFERENCE - ISO:C99-6.7.5.2 Array declarators

1053   Dir_1_1               [C99] Designators have been used in this initialization list.\\
MISRA C:2012 Dir-1.1; REFERENCE - ISO:C99-6.7.8 Initialization

1054   Dir_1_1               [C99] A compound literal has been used.\\
MISRA C:2012 Dir-1.1; REFERENCE - ISO:C99-6.5.2.5 Compound literals

1055   Dir_1_1               [C99] The keyword 'inline' has been used.\\
MISRA C:2012 Dir-1.1; REFERENCE - ISO:C99-6.7.4 Function specifiers

1056   Dir_1_1               [C99] The keyword '_Bool' has been used.\\
MISRA C:2012 Dir-1.1; REFERENCE - ISO:C99-6.2.5 Types

1257   Rule_10_3             An integer constant suffixed with L or LL is being converted to a type of lower rank on assignment.\\
MISRA C:2012 Rule-10.3

1264   Rule_10_3             A suffixed floating constant is being converted to a different floating type on assignment.\\
MISRA C:2012 Rule-10.3

1265   Rule_10_3             An unsuffixed floating constant is being converted to a different floating type on assignment.\\
MISRA C:2012 Rule-10.3

1266   Rule_10_3             A floating constant is being converted to integral type on assignment.\\
MISRA C:2012 Rule-10.3

1280   Rule_7_3              A lowercase letter L (l) has been used in an integer or floating suffix.\\
MISRA C:2012 Rule-7.3; REFERENCE - ISO:C90-6.1.3.1 (Floating Constants) & 6.1.3.2 (Integer Constants)

1281   Rule_7_2              Integer literal constant is of an unsigned type but does not include a "U" suffix.\\
MISRA C:2012 Rule-7.2; REFERENCE - ISO:C90-6.1.3.2 (Integer Constants)

1291   Rule_10_3             An integer constant of 'essentially unsigned' type is being converted to signed type on assignment.\\
MISRA C:2012 Rule-10.3

1292   Rule_10_3             An integer constant of 'essentially signed' type is being converted to type char on assignment.\\
MISRA C:2012 Rule-10.3

1293   Rule_10_3             An integer constant of 'essentially unsigned' type is being converted to type char on assignment.\\
MISRA C:2012 Rule-10.3

1294   Rule_10_3             An integer constant of 'essentially signed' type is being converted to type _Bool on assignment.\\
MISRA C:2012 Rule-10.3

1295   Rule_10_3             An integer constant of 'essentially unsigned' type is being converted to type _Bool on assignment.\\
MISRA C:2012 Rule-10.3

1296   Rule_10_3             An integer constant of 'essentially signed' type is being converted to enum type on assignment.\\
MISRA C:2012 Rule-10.3

1297   Rule_10_3             An integer constant of 'essentially unsigned' type is being converted to enum type on assignment.\\
MISRA C:2012 Rule-10.3

1298   Rule_10_3             An integer constant of 'essentially signed' type is being converted to floating type on assignment.\\
MISRA C:2012 Rule-10.3

1299   Rule_10_3             An integer constant of 'essentially unsigned' type is being converted to floating type on assignment.\\
MISRA C:2012 Rule-10.3

1330   Rule_8_3              The parameter identifiers in this function declaration differ from those in a previous declaration.\\
MISRA C:2012 Rule-8.3

1331   Rule_1_3              Type or number of arguments doesn't match previous use of the function.\\
MISRA C:2012 Rule-1.3

1332   Rule_1_3              Type or number of arguments doesn't match prototype found later.\\
MISRA C:2012 Rule-1.3

1333   Rule_1_3              Type or number of arguments doesn't match function definition found later.\\
MISRA C:2012 Rule-1.3

1335   Rule_8_2              Parameter identifiers missing in function prototype declaration.\\
MISRA C:2012 Rule-8.2

1336   Rule_8_2              Parameter identifiers missing in declaration of a function type.\\
MISRA C:2012 Rule-8.2

1337   Rule_17_1             Function defined with a variable number of parameters.\\
MISRA C:2012 Rule-17.1

1460   Rule_2_1              'Switch' label value, %s, not contained in enum type.\\
MISRA C:2012 Rule-2.1; REFERENCE - ISO:C90-6.5.2.2 Enumeration Specifiers

1503   Rule_2_1              The function '%1s' is defined but is not used within this project.\\
MISRA C:2012 Rule-2.1

1504   Rule_8_7              The object '%1s' is only referenced in the translation unit where it is defined.\\
MISRA C:2012 Rule-8.7

1505   Rule_8_7              The function '%1s' is only referenced in the translation unit where it is defined.\\
MISRA C:2012 Rule-8.7

1506   Rule_5_6              The identifier '%1s' is declared as a typedef and is used elsewhere for a different kind of declaration.\\
MISRA C:2012 Rule-5.6

1507   Rule_5_6              '%1s' is used as a typedef for different types.\\
MISRA C:2012 Rule-5.6

1508   Rule_5_6              The typedef '%1s' is declared in more than one location.\\
MISRA C:2012 Rule-5.6

1509   Rule_8_6              '%1s' has external linkage and has multiple definitions.\\
MISRA C:2012 Rule-1.3, Rule-8.6

1510   Rule_1_3              '%1s' has external linkage and has incompatible declarations.\\
MISRA C:2012 Rule-1.3

1513   Rule_8_5              Identifier '%1s' with external linkage has separate non-defining declarations in more than one location.\\
MISRA C:2012 Rule-8.5

1514   Rule_8_9              The object '%1s' is only referenced by function '%2s', in the translation unit where it is defined\\
MISRA C:2012 Rule-8.9

1520   Rule_17_2             Functions are indirectly recursive.\\
MISRA C:2012 Rule-17.2

1525   Rule_5_8              Object/function with external linkage has same identifier as another object/function with internal linkage.\\
MISRA C:2012 Rule-5.8, Rule-5.9

1526   Rule_5_8              Object with no linkage has same identifier as another object/function with external linkage.\\
MISRA C:2012 Rule-5.8

1527   Rule_5_9              Object/function with internal linkage has same identifier as another object/function with internal linkage.\\
MISRA C:2012 Rule-5.9

1528   Rule_5_9              Object with no linkage has same identifier as another object/function with internal linkage.\\
MISRA C:2012 Rule-5.9

1800   Rule_10_4             The %1s operand (essential type: '%2s') will be implicitly converted to a floating type, '%3s', in this arithmetic operation.\\
MISRA C:2012 Rule-10.4

1802   Rule_10_4             The %1s operand (essential type: '%2s') will be implicitly converted to a floating type, '%3s', in this relational operation.\\
MISRA C:2012 Rule-10.4

1803   Rule_10_4             The %1s operand (essential type: '%2s') will be implicitly converted to a floating type, '%3s', in this equality operation.\\
MISRA C:2012 Rule-10.4

1804   Rule_10_4             The %1s operand (essential type: '%2s') will be implicitly converted to a floating type, '%3s', in this conditional operation.\\
MISRA C:2012 Rule-10.4

1810   Rule_10_2             An operand of 'essentially character' type is being added to another operand of 'essentially character' type.\\
MISRA C:2012 Rule-10.2

1811   Rule_10_2             An operand of 'essentially character' type is being subtracted from an operand of 'essentially signed' type.\\
MISRA C:2012 Rule-10.2

1812   Rule_10_2             An operand of 'essentially character' type is being subtracted from an operand of 'essentially unsigned' type.\\
MISRA C:2012 Rule-10.2

1813   Rule_10_2             An operand of 'essentially character' type is being balanced with an operand of 'essentially floating' type in this arithmetic operation.\\
MISRA C:2012 Rule-10.2

1820   Rule_10_4             The %1s operand is non-constant and 'essentially signed' (%2s) but will be implicitly converted to an unsigned type (%3s) in this arithmetic operation.\\
MISRA C:2012 Rule-10.4

1821   Rule_10_4             The %1s operand is non-constant and 'essentially signed' (%2s) but will be implicitly converted to an unsigned type (%3s) in this bitwise operation.\\
MISRA C:2012 Rule-10.4

1822   Rule_10_4             The %1s operand is non-constant and 'essentially signed' (%2s) but will be implicitly converted to an unsigned type (%3s) in this relational operation.\\
MISRA C:2012 Rule-10.4

1823   Rule_10_4             The %1s operand is non-constant and 'essentially signed' (%2s) but will be implicitly converted to an unsigned type (%3s) in this equality operation.\\
MISRA C:2012 Rule-10.4

1824   Rule_10_4             The %1s operand is non-constant and 'essentially signed' (%2s) but will be implicitly converted to an unsigned type (%3s) in this conditional operation.\\
MISRA C:2012 Rule-10.4

1830   Rule_10_4             The %1s operand is constant, 'essentially signed' (%2s) and negative but will be implicitly converted to an unsigned type (%3s) in this arithmetic operation.\\
MISRA C:2012 Rule-10.4

1831   Rule_10_4             The %1s operand is constant, 'essentially signed' (%2s) and negative but will be implicitly converted to an unsigned type (%3s) in this bitwise operation.\\
MISRA C:2012 Rule-10.4

1832   Rule_10_4             The %1s operand is constant, 'essentially signed' (%2s) and negative but will be implicitly converted to an unsigned type (%3s) in this relational operation.\\
MISRA C:2012 Rule-10.4

1833   Rule_10_4             The %1s operand is constant, 'essentially signed' (%2s) and negative but will be implicitly converted to an unsigned type (%3s) in this equality operation.\\
MISRA C:2012 Rule-10.4

1834   Rule_10_4             The %1s operand is constant, 'essentially signed' (%2s) and negative but will be implicitly converted to an unsigned type (%3s) in this conditional operation.\\
MISRA C:2012 Rule-10.4

1840   Rule_10_4             The %1s operand is constant, 'essentially signed' (%2s) and non-negative but will be implicitly converted to an unsigned type (%3s) in this arithmetic operation.\\
MISRA C:2012 Rule-10.4

1841   Rule_10_4             The %1s operand is constant, 'essentially signed' (%2s) and non-negative but will be implicitly converted to an unsigned type (%3s) in this bitwise operation.\\
MISRA C:2012 Rule-10.4

1842   Rule_10_4             The %1s operand is constant, 'essentially signed' (%2s) and non-negative but will be implicitly converted to an unsigned type (%3s) in this relational operation.\\
MISRA C:2012 Rule-10.4

1843   Rule_10_4             The %1s operand is constant, 'essentially signed' (%2s) and non-negative but will be implicitly converted to an unsigned type (%3s) in this equality operation.\\
MISRA C:2012 Rule-10.4

1844   Rule_10_4             The %1s operand is constant, 'essentially signed' (%2s) and non-negative but will be implicitly converted to an unsigned type (%3s) in this conditional operation.\\
MISRA C:2012 Rule-10.4

1850   Rule_10_4             The %1s operand is 'essentially unsigned' (%2s) but will be implicitly converted to a signed type (%3s) in this arithmetic operation.\\
MISRA C:2012 Rule-10.4

1851   Rule_10_4             The %1s operand is 'essentially unsigned' (%2s) but will be implicitly converted to a signed type (%3s) in this bitwise operation.\\
MISRA C:2012 Rule-10.4

1852   Rule_10_4             The %1s operand is 'essentially unsigned' (%2s) but will be implicitly converted to a signed type (%3s) in this relational operation.\\
MISRA C:2012 Rule-10.4

1853   Rule_10_4             The %1s operand is 'essentially unsigned' (%2s) but will be implicitly converted to a signed type (%3s) in this equality operation.\\
MISRA C:2012 Rule-10.4

1854   Rule_10_4             The %1s operand is 'essentially unsigned' (%2s) but will be implicitly converted to a signed type (%3s) in this conditional operation.\\
MISRA C:2012 Rule-10.4

1860   Rule_10_4             The operands of this arithmetic operator are of different 'essential signedness' but will generate a result of type 'signed int'.\\
MISRA C:2012 Rule-10.4

1861   Rule_10_4             The operands of this bitwise operator are of different 'essential signedness' but will generate a result of type 'signed int'.\\
MISRA C:2012 Rule-10.4

1862   Rule_10_4             The operands of this relational operator are of different 'essential signedness' but will both be promoted to 'signed int' for comparison.\\
MISRA C:2012 Rule-10.4

1863   Rule_10_4             The operands of this equality operator are of different 'essential signedness' but will both be promoted to 'signed int' for comparison.\\
MISRA C:2012 Rule-10.4

1864   Rule_10_4             The 2nd and 3rd operands of this conditional operator are of different 'essential signedness'. The result will be in the promoted type 'signed int'.\\
MISRA C:2012 Rule-10.4

1880   Rule_10_4             The operands of this relational operator are expressions of different 'essential type' categories (%1s and %2s).\\
MISRA C:2012 Rule-10.4

1881   Rule_10_4             The operands of this equality operator are expressions of different 'essential type' categories (%1s and %2s).\\
MISRA C:2012 Rule-10.4

1882   Rule_10_4             The 2nd and 3rd operands of this conditional operator are expressions of different 'essential type' categories (%1s and %2s).\\
MISRA C:2012 Rule-10.4

1890   Rule_10_7             A composite expression of 'essentially signed' type (%1s) is being implicitly converted to a wider signed type, '%2s'.\\
MISRA C:2012 Rule-10.7

1891   Rule_10_7             A composite expression of 'essentially unsigned' type (%1s) is being implicitly converted to a wider unsigned type, '%2s'.\\
MISRA C:2012 Rule-10.7

1892   Rule_10_7             A composite expression of 'essentially floating' type (%1s) is being implicitly converted to a wider floating type, '%2s'.\\
MISRA C:2012 Rule-10.7

1893   Rule_10_7             The 2nd and 3rd operands of this conditional operator are both 'essentially signed' ('%1s' and '%2s') but one is a composite expression of a narrower type than the other.\\
MISRA C:2012 Rule-10.7

1894   Rule_10_7             The 2nd and 3rd operands of this conditional operator are both 'essentially unsigned' ('%1s' and '%2s') but one is a composite expression of a narrower type than the other.\\
MISRA C:2012 Rule-10.7

1895   Rule_10_7             The 2nd and 3rd operands of this conditional operator are both 'essentially floating' ('%1s' and '%2s') but one is a composite expression of a narrower type than the other.\\
MISRA C:2012 Rule-10.7

2001   Rule_15_1             A 'goto' statement has been used.\\
MISRA C:2012 Rule-15.1

2002   Rule_16_4             No 'default' label found in this 'switch' statement.\\
MISRA C:2012 Rule-16.4

2003   Rule_16_3             The preceding 'switch' clause is not empty and does not end with a 'jump' statement. Execution will fall through.\\
MISRA C:2012 Rule-16.3

2004   Rule_15_7             No concluding 'else' exists in this 'if'-'else'-'if' statement.\\
MISRA C:2012 Rule-15.7

2008   Rule_16_1             Code statements precede the first label in this 'switch' construct.\\
MISRA C:2012 Rule-16.1; REFERENCE - ISO:C90-6.6.4.2 The switch Statement - Semantics

2009   Rule_16_5             This 'default' label is not the final 'case' label within the 'switch' block.\\
MISRA C:2012 Rule-16.5

2019   Rule_16_2             'Switch' label is located within a nested code block.\\
MISRA C:2012 Rule-16.2

2020   Rule_16_3             Final 'switch' clause does not end with an explicit 'jump' statement.\\
MISRA C:2012 Rule-16.3

2050   Rule_8_1              The 'int' type specifier has been omitted from a function declaration.\\
MISRA C:2012 Rule-8.1

2051   Rule_8_1              The 'int' type specifier has been omitted from an object declaration.\\
MISRA C:2012 Rule-8.1

2212   Rule_15_6             Body of control statement is not enclosed within braces.\\
MISRA C:2012 Rule-15.6

2214   Rule_15_6             Body of control statement is on the same line and is not enclosed within braces.\\
MISRA C:2012 Rule-15.6

2461   Rule_14_2             Loop control variable, %s, has file scope.\\
MISRA C:2012 Rule-14.2

2462   Rule_14_2             The variable initialized in the first expression of this 'for' statement is not the variable identified as the 'loop control variable' (%s).\\
MISRA C:2012 Rule-14.2

2463   Rule_14_2             The variable incremented in the third expression of this 'for' statement is not the variable identified as the 'loop control variable' (%s).\\
MISRA C:2012 Rule-14.2

2464   Rule_14_2             Loop control variable, %s, modified twice in for-loop header.\\
MISRA C:2012 Rule-14.2

2467   Rule_14_2             Loop control variable, %s, is not modified inside loop.\\
MISRA C:2012 Rule-14.2

2469   Rule_14_2             Loop control variable in this 'for' statement, %s, is modified in the body of the loop.\\
MISRA C:2012 Rule-14.2

2471   Rule_14_2             Unable to identify a loop control variable.\\
MISRA C:2012 Rule-14.2

2472   Rule_14_2             More than one possible loop control variable.\\
MISRA C:2012 Rule-14.2

2547   Rule_5_3              This declaration of tag '%s' hides a more global declaration.\\
MISRA C:2012 Rule-5.3

2742   Rule_2_1              This 'if' controlling expression is a constant expression and its value is 'false'.\\
MISRA C:2012 Rule-2.1

2744   Rule_2_1              This 'while' or 'for' loop controlling expression is a constant expression and its value is 'false'. The loop will not be entered.\\
MISRA C:2012 Rule-2.1

2771   Rule_18_2             Definite: These pointers address different objects.\\
MISRA C:2012 Rule-18.2, Rule-18.3

2772   Rule_18_2             Apparent: These pointers address different objects.\\
MISRA C:2012 Rule-18.2, Rule-18.3

2776   Rule_19_1             Definite: Copy between overlapping objects.\\
MISRA C:2012 Rule-19.1

2777   Rule_19_1             Apparent: Copy between overlapping objects.\\
MISRA C:2012 Rule-19.1

2790   Rule_12_2             Constant: Right hand operand of shift operator is negative or too large.\\
MISRA C:2012 Rule-12.2

2791   Dir_4_1               Definite: Right hand operand of shift operator is negative or too large.\\
MISRA C:2012 Dir-4.1

2792   Dir_4_1               Apparent: Right hand operand of shift operator is negative or too large.\\
MISRA C:2012 Dir-4.1

2800   Rule_1_3              Constant: Overflow in signed arithmetic operation.\\
MISRA C:2012 Rule-1.3

2801   Dir_4_1               Definite: Overflow in signed arithmetic operation.\\
MISRA C:2012 Dir-4.1

2802   Dir_4_1               Apparent: Overflow in signed arithmetic operation.\\
MISRA C:2012 Dir-4.1

2810   Rule_1_3              Constant: Dereference of NULL pointer.\\
MISRA C:2012 Rule-1.3

2811   Dir_4_1               Definite: Dereference of NULL pointer.\\
MISRA C:2012 Dir-4.1

2812   Dir_4_1               Apparent: Dereference of NULL pointer.\\
MISRA C:2012 Dir-4.1

2820   Rule_1_3              Constant: Arithmetic operation on NULL pointer.\\
MISRA C:2012 Rule-1.3

2821   Dir_4_1               Definite: Arithmetic operation on NULL pointer.\\
MISRA C:2012 Dir-4.1

2822   Dir_4_1               Apparent: Arithmetic operation on NULL pointer.\\
MISRA C:2012 Dir-4.1

2830   Rule_1_3              Constant: Division by zero.\\
MISRA C:2012 Rule-1.3

2831   Dir_4_1               Definite: Division by zero.\\
MISRA C:2012 Dir-4.1

2832   Dir_4_1               Apparent: Division by zero.\\
MISRA C:2012 Dir-4.1

2840   Rule_1_3              Constant: Dereference of an invalid pointer value.\\
MISRA C:2012 Rule-1.3

2841   Dir_4_1               Definite: Dereference of an invalid pointer value.\\
MISRA C:2012 Dir-4.1

2842   Dir_4_1               Apparent: Dereference of an invalid pointer value.\\
MISRA C:2012 Dir-4.1

2845   Dir_4_1               Constant: Maximum number of characters to be written is larger than the target buffer size.\\
MISRA C:2012 Dir-4.1

2846   Dir_4_1               Definite: Maximum number of characters to be written is larger than the target buffer size.\\
MISRA C:2012 Dir-4.1

2847   Dir_4_1               Apparent: Maximum number of characters to be written is larger than the target buffer size.\\
MISRA C:2012 Dir-4.1

2850   Rule_10_3             Constant: Implicit conversion to a signed integer type of insufficient size.\\
MISRA C:2012 Rule-10.3

2851   Rule_10_3             Definite: Implicit conversion to a signed integer type of insufficient size.\\
MISRA C:2012 Rule-10.3

2852   Rule_10_3             Apparent: Implicit conversion to a signed integer type of insufficient size.\\
MISRA C:2012 Rule-10.3

2855   Dir_1_1               Constant: Casting to a signed integer type of insufficient size.\\
MISRA C:2012 Dir-1.1

2856   Dir_1_1               Definite: Casting to a signed integer type of insufficient size.\\
MISRA C:2012 Dir-1.1

2857   Dir_1_1               Apparent: Casting to a signed integer type of insufficient size.\\
MISRA C:2012 Dir-1.1

2860   Dir_1_1               Constant: Implementation-defined value resulting from left shift operation on expression of signed type.\\
MISRA C:2012 Dir-1.1

2861   Dir_1_1               Definite: Implementation-defined value resulting from left shift operation on expression of signed type.\\
MISRA C:2012 Dir-1.1

2862   Dir_1_1               Apparent: Implementation-defined value resulting from left shift operation on expression of signed type.\\
MISRA C:2012 Dir-1.1

2871   Dir_4_1               Infinite loop identified.\\
MISRA C:2012 Dir-4.1

2872   Dir_4_1               This loop, if entered, will never terminate.\\
MISRA C:2012 Dir-4.1

2877   Dir_4_1               This loop will never be executed more than once.\\
MISRA C:2012 Dir-4.1

2880   Rule_2_1              This code is unreachable.\\
MISRA C:2012 Rule-2.1

2882   Rule_2_1              This 'switch' statement will bypass the initialization of local variables.\\
MISRA C:2012 Rule-2.1

2883   Rule_9_1              This 'goto' statement will always bypass the initialization of local variables.\\
MISRA C:2012 Rule-9.1

2887   Rule_17_4             Function 'main' ends with an implicit 'return' statement.\\
MISRA C:2012 Rule-17.4

2888   Rule_17_4             This function has been declared with a non-void 'return' type but ends with an implicit 'return ;' statement.\\
MISRA C:2012 Rule-17.4

2889   Rule_15_5             This function has more than one 'return' path.\\
MISRA C:2012 Rule-15.5

2890   Dir_1_1               Constant: Negative value implicitly converted to an unsigned type.\\
MISRA C:2012 Dir-1.1

2891   Dir_1_1               Definite: Negative value implicitly converted to an unsigned type.\\
MISRA C:2012 Dir-1.1

2892   Dir_1_1               Apparent: Negative value implicitly converted to an unsigned type.\\
MISRA C:2012 Dir-1.1

2895   Dir_1_1               Constant: Negative value cast to an unsigned type.\\
MISRA C:2012 Dir-1.1

2896   Dir_1_1               Definite: Negative value cast to an unsigned type.\\
MISRA C:2012 Dir-1.1

2897   Dir_1_1               Apparent: Negative value cast to an unsigned type.\\
MISRA C:2012 Dir-1.1

2900   Rule_10_3             Constant: Positive integer value truncated by implicit conversion to a smaller unsigned type.\\
MISRA C:2012 Rule-10.3

2901   Rule_10_3             Definite: Positive integer value truncated by implicit conversion to a smaller unsigned type.\\
MISRA C:2012 Rule-10.3

2902   Rule_10_3             Apparent: Positive integer value truncated by implicit conversion to a smaller unsigned type.\\
MISRA C:2012 Rule-10.3

2910   Rule_12_4             Constant: Wraparound in unsigned arithmetic operation.\\
MISRA C:2012 Rule-12.4

2930   Rule_18_1             Constant: Computing an invalid pointer value.\\
MISRA C:2012 Rule-18.1

2931   Rule_18_1             Definite: Computing an invalid pointer value.\\
MISRA C:2012 Rule-18.1

2932   Rule_18_1             Apparent: Computing an invalid pointer value.\\
MISRA C:2012 Rule-18.1

2961   Rule_9_1              Definite: Using value of uninitialized automatic object '%s'.\\
MISRA C:2012 Rule-9.1

2962   Rule_9_1              Apparent: Using value of uninitialized automatic object '%s'.\\
MISRA C:2012 Rule-9.1

2971   Rule_9_1              Definite: Passing address of uninitialized object '%s' to a function parameter declared as a pointer to const.\\
MISRA C:2012 Rule-9.1

2972   Rule_9_1              Apparent: Passing address of uninitialized object '%s' to a function parameter declared as a pointer to const.\\
MISRA C:2012 Rule-9.1

2980   Rule_2_2              The value of this function parameter is never used before being modified.\\
MISRA C:2012 Rule-2.2

2981   Rule_2_2              This initialization is redundant. The value of this object is never used before being modified.\\
MISRA C:2012 Rule-2.2

2982   Rule_2_2              This assignment is redundant. The value of this object is never used before being modified.\\
MISRA C:2012 Rule-2.2

2983   Rule_2_2              This assignment is redundant. The value of this object is never subsequently used.\\
MISRA C:2012 Rule-2.2

2984   Rule_2_2              This operation is redundant. The value of the result is always '%1s'.\\
MISRA C:2012 Rule-2.2

2985   Rule_2_2              This operation is redundant. The value of the result is always that of the left-hand operand.\\
MISRA C:2012 Rule-2.2

2986   Rule_2_2              This operation is redundant. The value of the result is always that of the right-hand operand.\\
MISRA C:2012 Rule-2.2

2990   Rule_14_3             The value of this loop controlling expression is always 'true'.\\
MISRA C:2012 Rule-14.3

2991   Rule_14_3             The value of this 'if' controlling expression is always 'true'.\\
MISRA C:2012 Rule-14.3

2992   Rule_14_3             The value of this 'if' controlling expression is always 'false'.\\
MISRA C:2012 Rule-14.3

2993   Rule_14_3             The value of this 'do - while' loop controlling expression is always 'false'. The loop will only be executed once.\\
MISRA C:2012 Rule-14.3

2994   Rule_14_3             The value of this 'while' or 'for' loop controlling expression is always 'false'. The loop will not be entered.\\
MISRA C:2012 Rule-14.3

2995   Rule_2_2              The result of this logical operation is always 'true'.\\
MISRA C:2012 Rule-2.2

2996   Rule_2_2              The result of this logical operation is always 'false'.\\
MISRA C:2012 Rule-2.2

3001   Rule_8_2              Function has been declared with an empty parameter list.\\
MISRA C:2012 Rule-8.2; REFERENCE - ISO:C90-6.5.4.3 Function Declarators (Including Prototypes) - Semantics, ISO:C90-6.9.4 Future Language Directions

3002   Rule_8_2              Defining '%s()' with an identifier list and separate parameter declarations is an obsolescent feature.\\
MISRA C:2012 Rule-8.2; REFERENCE - ISO:C90-6.9.5 Future Language Directions

3003   Rule_11_9             This character constant is being interpreted as a NULL pointer constant.\\
MISRA C:2012 Rule-11.9

3004   Rule_11_9             This integral constant expression is being interpreted as a NULL pointer constant.\\
MISRA C:2012 Rule-11.9; REFERENCE - ISO:C90-6.2.2.3 Pointers, ISO:C99-6.3.2.3 Pointers

3006   Dir_4_3               This function contains a mixture of in-line assembler statements and C statements.\\
MISRA C:2012 Dir-4.3

3007   Rule_8_2              "void" has been omitted when defining a function with no parameters.\\
MISRA C:2012 Rule-8.2; REFERENCE - ISO:C90-6.5.4.3 Function Declarators (Including Prototypes) - Semantics, ISO:C90-6.7.1 Function Definitions - Constraints

3101   Rule_10_1             Unary '-' applied to an operand of type unsigned int or unsigned long gives an unsigned result.\\
MISRA C:2012 Rule-10.1; REFERENCE - ISO:C90-6.3.3.3 Unary Arithmetic Operators - Semantics

3102   Rule_10_1             Unary '-' applied to an operand whose underlying type is unsigned.\\
MISRA C:2012 Rule-10.1; REFERENCE - ISO:C90-6.3.3.3 Unary Arithmetic Operators - Semantics

3108   Rule_3_1              Nested comments are not recognized in the ISO standard.\\
MISRA C:2012 Rule-3.1; REFERENCE - ISO:C90-6.1.9 Comments (footnote 26)

3110   Rule_2_2              The left-hand operand of this ',' has no side effects.\\
MISRA C:2012 Rule-2.2; REFERENCE - ISO:C90-6.6.3 Expression and Null Statements

3112   Rule_2_2              This statement has no side-effect - it can be removed.\\
MISRA C:2012 Rule-2.2

3113   Rule_17_4             [U] 'return' statement includes no expression but function '%s()' is implicitly of type 'int'.\\
MISRA C:2012 Rule-1.3, Rule-17.4; REFERENCE - ISO:C90-6.6.6.4 The return Statement - Semantics

3114   Rule_17_4             [U] Function '%s()' is implicitly of type 'int' but ends without returning a value.\\
MISRA C:2012 Rule-1.3, Rule-17.4; REFERENCE - ISO:C90-6.6.6.4 The return Statement - Semantics

3115   Rule_20_13            Unrecognized preprocessing directive has been ignored because of conditional inclusion directives.\\
MISRA C:2012 Rule-20.13

3116   Dir_1_1               Unrecognized #pragma arguments '%s' This #pragma directive has been ignored.\\
MISRA C:2012 Dir-1.1; REFERENCE - ISO:C90-6.8.6 Pragma Directive

3200   Rule_17_7             '%s' returns a value which is not being used.\\
MISRA C:2012 Rule-17.7

3202   Rule_2_6              The label '%s:' is not used in this function and could be removed.\\
MISRA C:2012 Rule-2.6; REFERENCE - ISO:C90-6.6.1 Labeled Statements

3206   Rule_2_7              The parameter '%s' is not used in this function.\\
MISRA C:2012 Rule-2.7

3217   Rule_18_6             Address of automatic object exported to a pointer with linkage or wider scope.\\
MISRA C:2012 Rule-18.6; REFERENCE - ISO:C90-6.1.2.4 Storage Durations of Objects

3218   Rule_8_9              File scope static, '%s', is only accessed in one function.\\
MISRA C:2012 Rule-8.9

3219   Rule_2_1              Static function '%s()' is not used within this translation unit.\\
MISRA C:2012 Rule-2.1

3221   Rule_8_5              Function with external linkage declared at block scope.\\
MISRA C:2012 Rule-8.5

3222   Rule_8_5              Object with external linkage declared at block scope.\\
MISRA C:2012 Rule-8.5

3224   Rule_8_8              This identifier has previously been declared with internal linkage but is not declared here with the static storage class specifier.\\
MISRA C:2012 Rule-8.8

3225   Rule_18_6             Address of automatic object exported using a function parameter.\\
MISRA C:2012 Rule-18.6; REFERENCE - ISO:C90-6.1.2.4 Storage Durations of Objects

3226   Rule_13_4             The result of an assignment is being used in an arithmetic operation or another assigning operation.\\
MISRA C:2012 Rule-13.4

3230   Rule_18_6             Address of automatic object assigned to local pointer with static storage duration.\\
MISRA C:2012 Rule-18.6; REFERENCE - ISO:C90-6.1.2.4 Storage Durations of Objects

3234   Rule_16_1             Declarations precede the first label in this 'switch' construct.\\
MISRA C:2012 Rule-16.1

3236   Rule_1_1              [C] 'inline' may not be applied to function 'main'.\\
MISRA C:2012 Rule-1.1; REFERENCE - ISO:C99-6.7.4 Function specifiers - Constraints

3237   Rule_1_1              [C] inline function '%1s' has external linkage and is defining an object, '%2s', with static storage duration.\\
MISRA C:2012 Rule-1.1; REFERENCE - ISO:C99-6.7.4 Function specifiers - Constraints

3238   Rule_1_1              [C] inline function '%1s' has external linkage and is referring to an object, '%2s', with internal linkage.\\
MISRA C:2012 Rule-1.1; REFERENCE - ISO:C99-6.7.4 Function specifiers - Constraints

3239   Rule_1_3              [U] inline function '%1s' has external linkage, but is not defined within this translation unit.\\
MISRA C:2012 Rule-1.3; REFERENCE - ISO:C99-6.7.4 Function specifiers - Semantics

3240   Rule_8_10             inline function '%s' is being defined with external linkage.\\
MISRA C:2012 Rule-8.10; REFERENCE - ISO:C99-6.7.4 Function specifiers - Semantics

3243   Rule_8_10             inline function '%s' is also an 'external definition'.\\
MISRA C:2012 Rule-8.10; REFERENCE - ISO:C99-6.7.4 Function specifiers - Semantics

3244   Rule_1_1              [C] 'inline' may only be used in the declaration of a function identifier.\\
MISRA C:2012 Rule-1.1; REFERENCE - ISO:C99-6.7.4 Function specifiers - Constraints

3260   Rule_18_5             Typedef defined with more than 2 levels of indirection.\\
MISRA C:2012 Rule-18.5; REFERENCE - ISO:C90-6.5.4.1 Pointer Declarators

3261   Rule_18_5             Member of struct/union defined with more than 2 levels of indirection.\\
MISRA C:2012 Rule-18.5; REFERENCE - ISO:C90-6.5.4.1 Pointer Declarators

3262   Rule_18_5             Object defined or declared with more than 2 levels of indirection.\\
MISRA C:2012 Rule-18.5; REFERENCE - ISO:C90-6.5.4.1 Pointer Declarators

3263   Rule_18_5             Function defined or declared with a return type which has more than 2 levels of indirection.\\
MISRA C:2012 Rule-18.5; REFERENCE - ISO:C90-6.5.4.1 Pointer Declarators

3305   Rule_11_3             Pointer cast to stricter alignment.\\
MISRA C:2012 Rule-11.3

3307   Rule_13_6             The operand of 'sizeof' is an expression with implied side effects, but they will not be evaluated.\\
MISRA C:2012 Rule-13.6; REFERENCE - ISO:C90-6.3.3.4 The sizeof Operator - Semantics

3311   Rule_15_3             [u] An earlier jump to this statement will bypass the initialization of local variables.\\
MISRA C:2012 Rule-1.3, Rule-15.3; REFERENCE - ISO:C90-6.1.2.4 Storage Durations of Objects

3312   Rule_1_3              [u] This goto statement will jump into a previous block and bypass the initialization of local variables.\\
MISRA C:2012 Rule-1.3; REFERENCE - ISO:C90-6.1.2.4 Storage Durations of Objects

3315   Rule_16_6             This 'switch' statement contains only a single path - it is redundant.\\
MISRA C:2012 Rule-16.6; REFERENCE - ISO:C90-6.6.4.2 The switch Statement

3317   Rule_20_14            '#if...' not matched by '#endif' in included file. This is probably an error.\\
MISRA C:2012 Rule-20.14

3318   Rule_20_14            '#else'/'#elif'/'#endif' in included file matched '#if...' in parent file. This is probably an error.\\
MISRA C:2012 Rule-20.14

3319   Rule_1_3              [U] Function called with number of arguments which differs from number of parameters in definition.\\
MISRA C:2012 Rule-1.3; REFERENCE - ISO:C90-6.3.2.2 Function Calls

3320   Rule_1_3              Type of argument no. %s differs from its type in definition of function.\\
MISRA C:2012 Rule-1.3; REFERENCE - ISO:C90-6.3.2.2 Function Calls

3326   Rule_13_4             The result of an assignment is being used in a logical operation.\\
MISRA C:2012 Rule-13.4

3332   Rule_20_9             The macro '%s' used in this '#if' or '#elif' expression is not defined.\\
MISRA C:2012 Rule-20.9

3334   Rule_5_3              This declaration of '%s' hides a more global declaration.\\
MISRA C:2012 Rule-5.3

3335   Rule_17_3             No function declaration. Implicit declaration inserted: 'extern int %s();'.\\
MISRA C:2012 Rule-17.3; REFERENCE - ISO:C90-6.3.2.2 Function Calls - Semantics

3340   Rule_14_1             Floating point variable used as 'for' loop control variable.\\
MISRA C:2012 Rule-14.1

3342   Rule_14_1             Controlling expression of 'for' loop is a floating point comparison.\\
MISRA C:2012 Rule-14.1

3344   Rule_14_4             Controlling expression is not an 'essentially Boolean' expression.\\
MISRA C:2012 Rule-14.4

3389   Rule_12_1             Extra parentheses recommended to clarify the ordering of a % operator and another arithmetic operator (* / % + -).\\
MISRA C:2012 Rule-12.1

3391   Rule_12_1             Extra parentheses recommended. A conditional operation is the operand of another conditional operator.\\
MISRA C:2012 Rule-12.1

3392   Rule_12_1             Extra parentheses recommended. A shift, relational or equality operation is the operand of a second identical operator.\\
MISRA C:2012 Rule-12.1

3394   Rule_12_1             Extra parentheses recommended. A shift, relational or equality operation is the operand of a different operator with the same precedence.\\
MISRA C:2012 Rule-12.1

3395   Rule_12_1             Extra parentheses recommended. A * or / operation is the operand of a + or - operator.\\
MISRA C:2012 Rule-12.1

3396   Rule_12_1             Extra parentheses recommended. A binary operation is the operand of a conditional operator.\\
MISRA C:2012 Rule-12.1

3397   Rule_12_1             Extra parentheses recommended. A binary operation is the operand of a binary operator with different precedence.\\
MISRA C:2012 Rule-12.1

3402   Rule_15_6             Braces are needed to clarify the structure of this 'if'-'if'-'else' statement.\\
MISRA C:2012 Rule-15.6; REFERENCE - ISO:C90-6.6.4.1 The if statement - Semantics

3406   Rule_8_6              Object/function '%s', with external linkage, has been defined in a header file.\\
MISRA C:2012 Rule-8.6

3408   Rule_8_4              '%s' has external linkage and is being defined without any previous declaration.\\
MISRA C:2012 Rule-8.4

3410   Rule_20_7             Macro parameter not enclosed in ().\\
MISRA C:2012 Rule-20.7

3415   Rule_13_5             Right hand operand of '&&' or '||' is an expression with possible side effects.\\
MISRA C:2012 Rule-13.5; REFERENCE - ISO:C90-5,1,2,3 Program Execution

3417   Rule_12_3             The comma operator has been used outside a 'for' statement.\\
MISRA C:2012 Rule-12.3

3418   Rule_12_3             The comma operator has been used in a 'for' statement.\\
MISRA C:2012 Rule-12.3

3425   Rule_2_2              One branch of this conditional operation is a redundant expression.\\
MISRA C:2012 Rule-2.2

3426   Rule_2_2              Right hand side of comma expression has no side effect and its value is not used.\\
MISRA C:2012 Rule-2.2

3427   Rule_2_2              Right hand side of logical operator has no side effect and its value is not used.\\
MISRA C:2012 Rule-2.2

3437   Rule_1_3              [u] The assert macro has been suppressed to call a function of that name.\\
MISRA C:2012 Rule-1.3; REFERENCE - ISO:C90-7.2 Diagnostics <assert.h>

3438   Rule_1_3              [U] #undef'ing the assert macro to call a function of that name causes undefined behaviour.\\
MISRA C:2012 Rule-1.3; REFERENCE - ISO:C90-7.2 Diagnostics <assert.h>

3439   Rule_20_4             Macro redefines a keyword.\\
MISRA C:2012 Rule-20.4

3440   Rule_13_3             Using the value resulting from a ++ or -- operation.\\
MISRA C:2012 Rule-13.3; REFERENCE - ISO:C90-6.3.2.4 Postfix Increment and Decrement Operators, ISO:C90-6.3.3.1 Prefix Increment and Decrement Operators

3447   Rule_8_5              '%s' is being declared with external linkage but this declaration is not in a header file.\\
MISRA C:2012 Rule-8.5

3448   Rule_5_6              Declaration of typedef '%s' is not in a header file although it is used in a definition or declaration with external linkage.\\
MISRA C:2012 Rule-5.6

3451   Rule_8_5              The global identifier '%s' has been declared in more than one file.\\
MISRA C:2012 Rule-8.5

3453   Dir_4_9               A function could probably be used instead of this function-like macro.\\
MISRA C:2012 Dir-4.9

3601   Rule_4_2              Trigraphs (??x) are an ISO feature.\\
MISRA C:2012 Rule-4.2; REFERENCE - ISO:C90-5.2.1.1 Trigraph Sequences

3628   Rule_7_1              Octal escape sequences used in a character constant or string literal.\\
MISRA C:2012 Rule-7.1

3660   Rule_6_2              Named bit-field consisting of a single bit declared with a signed type.\\
MISRA C:2012 Rule-6.2; REFERENCE - ISO:C90-6.5.2.1 Structure and Union Specifiers - Semantics

3664   Rule_1_2              [E] Using a dot operator to access an individual bit is a language extension.\\
MISRA C:2012 Rule-1.2

3665   Rule_6_2              Unnamed bit-field consisting of a single bit declared with a signed type.\\
MISRA C:2012 Rule-6.2; REFERENCE - ISO:C90-6.5.2.1 Structure and Union Specifiers - Semantics

3670   Rule_17_2             Recursive call to function containing this call.\\
MISRA C:2012 Rule-17.2

3673   Rule_8_13             The object addressed by the pointer parameter '%s' is not modified and so the pointer could be of type 'pointer to const'.\\
MISRA C:2012 Rule-8.13

3675   Rule_8_3              Function parameter declared with type qualification which differs from previous declaration.\\
MISRA C:2012 Rule-8.3

3684   Rule_8_11             Array declared with unknown size.\\
MISRA C:2012 Rule-8.11

4140   Rule_18_6             Address of automatic object exported in function return value.\\
MISRA C:2012 Rule-18.6; REFERENCE - ISO:C90-6.1.2.4 Storage Durations of Objects

4301   Rule_10_5             An expression of 'essentially Boolean' type (%1s) is being cast to character type '%2s'.\\
MISRA C:2012 Rule-10.5

4302   Rule_10_5             An expression of 'essentially Boolean' type (%1s) is being cast to enum type '%2s'.\\
MISRA C:2012 Rule-10.5

4303   Rule_10_5             An expression of 'essentially Boolean' type (%1s) is being cast to signed type '%2s'.\\
MISRA C:2012 Rule-10.5

4304   Rule_10_5             An expression of 'essentially Boolean' type (%1s) is being cast to unsigned type '%2s'.\\
MISRA C:2012 Rule-10.5

4305   Rule_10_5             An expression of 'essentially Boolean' type (%1s) is being cast to floating type '%2s'.\\
MISRA C:2012 Rule-10.5

4310   Rule_10_5             An expression of 'essentially character' type (%1s) is being cast to Boolean type, '%2s'.\\
MISRA C:2012 Rule-10.5

4312   Rule_10_5             An expression of 'essentially character' type (%1s) is being cast to enum type, '%2s'.\\
MISRA C:2012 Rule-10.5

4315   Rule_10_5             An expression of 'essentially character' type (%1s) is being cast to floating type, '%2s'.\\
MISRA C:2012 Rule-10.5

4320   Rule_10_5             An expression of 'essentially enum' type (%1s) is being cast to Boolean type, '%2s'.\\
MISRA C:2012 Rule-10.5

4322   Rule_10_5             An expression of 'essentially enum' type (%1s) is being cast to a different enum type, '%2s'.\\
MISRA C:2012 Rule-10.5

4330   Rule_10_5             An expression of 'essentially signed' type (%1s) is being cast to Boolean type '%2s'.\\
MISRA C:2012 Rule-10.5

4332   Rule_10_5             An expression of 'essentially signed' type (%1s) is being cast to enum type, '%2s'.\\
MISRA C:2012 Rule-10.5

4340   Rule_10_5             An expression of 'essentially unsigned' type (%1s) is being cast to Boolean type '%2s'.\\
MISRA C:2012 Rule-10.5

4342   Rule_10_5             An expression of 'essentially unsigned' type (%1s) is being cast to enum type '%2s'.\\
MISRA C:2012 Rule-10.5

4350   Rule_10_5             An expression of 'essentially floating' type (%1s) is being cast to Boolean type '%2s'.\\
MISRA C:2012 Rule-10.5

4351   Rule_10_5             An expression of 'essentially floating' type (%1s) is being cast to character type '%2s'.\\
MISRA C:2012 Rule-10.5

4352   Rule_10_5             An expression of 'essentially floating' type (%1s) is being cast to enum type, '%2s'.\\
MISRA C:2012 Rule-10.5

4390   Rule_10_8             A composite expression of 'essentially signed' type (%1s) is being cast to a wider signed type, '%2s'.\\
MISRA C:2012 Rule-10.8

4391   Rule_10_8             A composite expression of 'essentially unsigned' type (%1s) is being cast to a wider unsigned type, '%2s'.\\
MISRA C:2012 Rule-10.8

4392   Rule_10_8             A composite expression of 'essentially floating' type (%1s) is being cast to a wider floating type, '%2s'.\\
MISRA C:2012 Rule-10.8

4393   Rule_10_8             A composite expression of 'essentially signed' type (%1s) is being cast to a different type category, '%2s'.\\
MISRA C:2012 Rule-10.8

4394   Rule_10_8             A composite expression of 'essentially unsigned' type (%1s) is being cast to a different type category, '%2s'.\\
MISRA C:2012 Rule-10.8

4395   Rule_10_8             A composite expression of 'essentially floating' type (%1s) is being cast to a different type category, '%2s'.\\
MISRA C:2012 Rule-10.8

4397   Rule_10_7             An expression which is the result of a ~ or << operation has not been cast to its essential type.\\
MISRA C:2012 Rule-10.7

4398   Rule_10_8             An expression which is the result of a ~ or << operation has been cast to a different essential type category.\\
MISRA C:2012 Rule-10.8

4399   Rule_10_8             An expression which is the result of a ~ or << operation has been cast to a wider type.\\
MISRA C:2012 Rule-10.8

4401   Rule_10_3             An expression of 'essentially Boolean' type (%1s) is being converted to character type, '%2s' on assignment.\\
MISRA C:2012 Rule-10.3

4402   Rule_10_3             An expression of 'essentially Boolean' type (%1s) is being converted to enum type, '%2s' on assignment.\\
MISRA C:2012 Rule-10.3

4403   Rule_10_3             An expression of 'essentially Boolean' type (%1s) is being converted to signed type, '%2s' on assignment.\\
MISRA C:2012 Rule-10.3

4404   Rule_10_3             An expression of 'essentially Boolean' type (%1s) is being converted to unsigned type, '%2s' on assignment.\\
MISRA C:2012 Rule-10.3

4405   Rule_10_3             An expression of 'essentially Boolean' type (%1s) is being converted to floating type, '%2s' on assignment.\\
MISRA C:2012 Rule-10.3

4410   Rule_10_3             An expression of 'essentially character' type (%1s) is being converted to Boolean type, '%2s' on assignment.\\
MISRA C:2012 Rule-10.3

4412   Rule_10_3             An expression of 'essentially character' type (%1s) is being converted to enum type, '%2s' on assignment.\\
MISRA C:2012 Rule-10.3

4413   Rule_10_3             An expression of 'essentially character' type (%1s) is being converted to signed type, '%2s' on assignment.\\
MISRA C:2012 Rule-10.3

4414   Rule_10_3             An expression of 'essentially character' type (%1s) is being converted to unsigned type, '%2s' on assignment.\\
MISRA C:2012 Rule-10.3

4415   Rule_10_3             An expression of 'essentially character' type (%1s) is being converted to floating type, '%2s' on assignment.\\
MISRA C:2012 Rule-10.3

4420   Rule_10_3             An expression of 'essentially enum' type (%1s) is being converted to Boolean type, '%2s' on assignment.\\
MISRA C:2012 Rule-10.3

4421   Rule_10_3             An expression of 'essentially enum' type (%1s) is being converted to character type, '%2s' on assignment.\\
MISRA C:2012 Rule-10.3

4422   Rule_10_3             An expression of 'essentially enum' type (%1s) is being converted to a different enum type, '%2s' on assignment.\\
MISRA C:2012 Rule-10.3

4423   Rule_10_3             An expression of 'essentially enum' type (%1s) is being converted to signed type, '%2s' on assignment.\\
MISRA C:2012 Rule-10.3

4424   Rule_10_3             An expression of 'essentially enum' type (%1s) is being converted to unsigned type, '%2s' on assignment.\\
MISRA C:2012 Rule-10.3

4425   Rule_10_3             An expression of 'essentially enum' type (%1s) is being converted to floating type, '%2s' on assignment.\\
MISRA C:2012 Rule-10.3

4430   Rule_10_3             An expression of 'essentially signed' type (%1s) is being converted to Boolean type, '%2s' on assignment.\\
MISRA C:2012 Rule-10.3

4431   Rule_10_3             An expression of 'essentially signed' type (%1s) is being converted to character type, '%2s' on assignment.\\
MISRA C:2012 Rule-10.3

4432   Rule_10_3             An expression of 'essentially signed' type (%1s) is being converted to enum type, '%2s' on assignment.\\
MISRA C:2012 Rule-10.3

4434   Rule_10_3             A non-constant expression of 'essentially signed' type (%1s) is being converted to unsigned type, '%2s' on assignment.\\
MISRA C:2012 Rule-10.3

4435   Rule_10_3             A non-constant expression of 'essentially signed' type (%1s) is being converted to floating type, '%2s' on assignment.\\
MISRA C:2012 Rule-10.3

4436   Rule_10_3             A constant expression of 'essentially signed' type (%1s) is being converted to unsigned type, '%2s' on assignment.\\
MISRA C:2012 Rule-10.3

4437   Rule_10_3             A constant expression of 'essentially signed' type (%1s) is being converted to floating type, '%2s' on assignment.\\
MISRA C:2012 Rule-10.3

4440   Rule_10_3             An expression of 'essentially unsigned' type (%1s) is being converted to Boolean type, '%2s' on assignment.\\
MISRA C:2012 Rule-10.3

4441   Rule_10_3             An expression of 'essentially unsigned' type (%1s) is being converted to character type, '%2s' on assignment.\\
MISRA C:2012 Rule-10.3

4442   Rule_10_3             An expression of 'essentially unsigned' type (%1s) is being converted to enum type, '%2s' on assignment.\\
MISRA C:2012 Rule-10.3

4443   Rule_10_3             A non-constant expression of 'essentially unsigned' type (%1s) is being converted to a wider signed type, '%2s' on assignment.\\
MISRA C:2012 Rule-10.3

4445   Rule_10_3             An expression of 'essentially unsigned' type (%1s) is being converted to floating type, '%2s' on assignment.\\
MISRA C:2012 Rule-10.3

4446   Rule_10_3             A non-constant expression of 'essentially unsigned' type (%1s) is being converted to signed type, '%2s' on assignment.\\
MISRA C:2012 Rule-10.3

4447   Rule_10_3             A constant expression of 'essentially unsigned' type (%1s) is being converted to signed type, '%2s' on assignment.\\
MISRA C:2012 Rule-10.3

4450   Rule_10_3             An expression of 'essentially floating' type (%1s) is being converted to Boolean type, '%2s' on assignment.\\
MISRA C:2012 Rule-10.3

4451   Rule_10_3             An expression of 'essentially floating' type (%1s) is being converted to character type, '%2s' on assignment.\\
MISRA C:2012 Rule-10.3

4452   Rule_10_3             An expression of 'essentially floating' type (%1s) is being converted to enum type, '%2s' on assignment.\\
MISRA C:2012 Rule-10.3

4453   Rule_10_3             An expression of 'essentially floating' type (%1s) is being converted to signed type, '%2s' on assignment.\\
MISRA C:2012 Rule-10.3

4454   Rule_10_3             An expression of 'essentially floating' type (%1s) is being converted to unsigned type, '%2s' on assignment.\\
MISRA C:2012 Rule-10.3

4460   Rule_10_3             A non-constant expression of 'essentially signed' type (%1s) is being converted to narrower signed type, '%2s' on assignment.\\
MISRA C:2012 Rule-10.3

4461   Rule_10_3             A non-constant expression of 'essentially unsigned' type (%1s) is being converted to narrower unsigned type, '%2s' on assignment.\\
MISRA C:2012 Rule-10.3

4462   Rule_10_3             A non-constant expression of 'essentially floating' type (%1s) is being converted to narrower floating type, '%2s' on assignment.\\
MISRA C:2012 Rule-10.3

4463   Rule_10_3             A constant expression of 'essentially signed' type (%1s) is being converted to narrower signed type, '%2s' on assignment.\\
MISRA C:2012 Rule-10.3

4464   Rule_10_3             A constant expression of 'essentially unsigned' type (%1s) is being converted to narrower unsigned type, '%2s' on assignment.\\
MISRA C:2012 Rule-10.3

4465   Rule_10_3             A constant expression of 'essentially floating' type (%1s) is being converted to narrower floating type, '%2s' on assignment.\\
MISRA C:2012 Rule-10.3

4490   Rule_10_6             A composite expression of 'essentially signed' type (%1s) is being converted to wider signed type, '%2s' on assignment.\\
MISRA C:2012 Rule-10.6

4491   Rule_10_6             A composite expression of 'essentially unsigned' type (%1s) is being converted to wider unsigned type, '%2s' on assignment.\\
MISRA C:2012 Rule-10.6

4492   Rule_10_6             A composite expression of 'essentially floating' type (%1s) is being converted to wider floating type, '%2s' on assignment.\\
MISRA C:2012 Rule-10.6

4499   Rule_10_6             An expression which is the result of a ~ or << operation has been converted to a wider essential type on assignment.\\
MISRA C:2012 Rule-10.6

4500   Rule_10_1             An expression of 'essentially Boolean' type (%1s) is being used as an array subscript.\\
MISRA C:2012 Rule-10.1

4501   Rule_10_1             An expression of 'essentially Boolean' type (%1s) is being used as the %2s operand of this arithmetic operator (%3s).\\
MISRA C:2012 Rule-10.1

4502   Rule_10_1             An expression of 'essentially Boolean' type (%1s) is being used as the %2s operand of this bitwise operator (%3s).\\
MISRA C:2012 Rule-10.1

4503   Rule_10_1             An expression of 'essentially Boolean' type (%1s) is being used as the left-hand operand of this shift operator (%2s).\\
MISRA C:2012 Rule-10.1

4504   Rule_10_1             An expression of 'essentially Boolean' type (%1s) is being used as the right-hand operand of this shift operator (%2s).\\
MISRA C:2012 Rule-10.1

4505   Rule_10_1             An expression of 'essentially Boolean' type (%1s) is being used as the %2s operand of this relational operator (%3s).\\
MISRA C:2012 Rule-10.1

4507   Rule_10_1             An expression of 'essentially Boolean' type (%1s) is being used as the operand of this increment/decrement operator (%2s).\\
MISRA C:2012 Rule-10.1

4510   Rule_10_1             An expression of 'essentially character' type (%1s) is being used as an array subscript.\\
MISRA C:2012 Rule-10.1

4511   Rule_10_1             An expression of 'essentially character' type (%1s) is being used as the %2s operand of this arithmetic operator (%3s).\\
MISRA C:2012 Rule-10.1

4512   Rule_10_1             An expression of 'essentially character' type (%1s) is being used as the %2s operand of this bitwise operator (%3s).\\
MISRA C:2012 Rule-10.1

4513   Rule_10_1             An expression of 'essentially character' type (%1s) is being used as the left-hand operand of this shift operator (%2s).\\
MISRA C:2012 Rule-10.1

4514   Rule_10_1             An expression of 'essentially character' type (%1s) is being used as the right-hand operand of this shift operator (%2s).\\
MISRA C:2012 Rule-10.1

4518   Rule_10_1             An expression of 'essentially character' type (%1s) is being used as the %2s operand of this logical operator (%3s).\\
MISRA C:2012 Rule-10.1

4519   Rule_10_1             An expression of 'essentially character' type (%1s) is being used as the first operand of this conditional operator (%2s).\\
MISRA C:2012 Rule-10.1

4521   Rule_10_1             An expression of 'essentially enum' type (%1s) is being used as the %2s operand of this arithmetic operator (%3s).\\
MISRA C:2012 Rule-10.1

4522   Rule_10_1             An expression of 'essentially enum' type (%1s) is being used as the %2s operand of this bitwise operator (%3s).\\
MISRA C:2012 Rule-10.1

4523   Rule_10_1             An expression of 'essentially enum' type (%1s) is being used as the left-hand operand of this shift operator (%2s).\\
MISRA C:2012 Rule-10.1

4524   Rule_10_1             An expression of 'essentially enum' type (%1s) is being used as the right-hand operand of this shift operator (%2s).\\
MISRA C:2012 Rule-10.1

4527   Rule_10_1             An expression of 'essentially enum' type is being used as the operand of this increment/decrement operator.\\
MISRA C:2012 Rule-10.1

4528   Rule_10_1             An expression of 'essentially enum' type (%1s) is being used as the %2s operand of this logical operator (%3s).\\
MISRA C:2012 Rule-10.1

4529   Rule_10_1             An expression of 'essentially enum' type (%1s) is being used as the first operand of this conditional operator (%2s).\\
MISRA C:2012 Rule-10.1

4532   Rule_10_1             An expression of 'essentially signed' type (%1s) is being used as the %2s operand of this bitwise operator (%3s).\\
MISRA C:2012 Rule-10.1

4533   Rule_10_1             An expression of 'essentially signed' type (%1s) is being used as the left-hand operand of this shift operator (%2s).\\
MISRA C:2012 Rule-10.1

4534   Rule_10_1             An expression of 'essentially signed' type (%1s) is being used as the right-hand operand of this shift operator (%2s).\\
MISRA C:2012 Rule-10.1

4538   Rule_10_1             An expression of 'essentially signed' type (%1s) is being used as the %2s operand of this logical operator (%3s).\\
MISRA C:2012 Rule-10.1

4539   Rule_10_1             An expression of 'essentially signed' type (%1s) is being used as the first operand of this conditional operator (%2s).\\
MISRA C:2012 Rule-10.1

4542   Rule_10_1             A non-negative constant expression of 'essentially signed' type (%1s) is being used as the %2s operand of this bitwise operator (%3s).\\
MISRA C:2012 Rule-10.1

4543   Rule_10_1             A non-negative constant expression of 'essentially signed' type (%1s) is being used as the left-hand operand of this shift operator (%2s).\\
MISRA C:2012 Rule-10.1

4544   Rule_10_1             A non-negative constant expression of 'essentially signed' type (%1s) is being used as the right-hand operand of this shift operator (%2s).\\
MISRA C:2012 Rule-10.1

4548   Rule_10_1             A non-negative constant expression of 'essentially signed' type (%1s) is being used as the %2s operand of this logical operator (%3s).\\
MISRA C:2012 Rule-10.1

4549   Rule_10_1             A non-negative constant expression of 'essentially signed' type (%1s) is being used as the first operand of this conditional operator (%2s).\\
MISRA C:2012 Rule-10.1

4558   Rule_10_1             An expression of 'essentially unsigned' type (%1s) is being used as the %2s operand of this logical operator (%3s).\\
MISRA C:2012 Rule-10.1

4559   Rule_10_1             An expression of 'essentially unsigned' type (%1s) is being used as the first operand of this conditional operator (%2s).\\
MISRA C:2012 Rule-10.1

4568   Rule_10_1             An expression of 'essentially floating' type (%1s) is being used as the %2s operand of this logical operator (%3s).\\
MISRA C:2012 Rule-10.1

4569   Rule_10_1             An expression of 'essentially floating' type (%1s) is being used as the first operand of this conditional operator (%2s).\\
MISRA C:2012 Rule-10.1

4600   Rule_21_1             The macro '%1s' is also defined in '<%2s>'.\\
MISRA C:2012 Rule-21.1; REFERENCE - ISO:C90-7.1.2.1 Reserved Identifiers, ISO:C99-7.1.3 Reserved Identifiers

4601   Rule_21_1             The macro '%1s' is the name of an identifier in '<%2s>'.\\
MISRA C:2012 Rule-21.1; REFERENCE - ISO:C90-7.1.2.1 Reserved Identifiers, ISO:C99-7.1.3 Reserved Identifiers

4602   Rule_21_2             The identifier '%1s' is declared as a macro in '<%2s>'.\\
MISRA C:2012 Rule-21.2; REFERENCE - ISO:C90-7.1.2.1 Reserved Identifiers, ISO:C99-7.1.3 Reserved Identifiers

4603   Rule_21_2             The object/function '%1s'is being defined with the same name as an ordinary identifier defined in '<%2s>'.\\
MISRA C:2012 Rule-21.2; REFERENCE - ISO:C90-7.1.2.1 Reserved Identifiers, ISO:C99-7.1.3 Reserved Identifiers

4604   Rule_21_2             The object/function '%1s' is being declared with the same name as an ordinary identifier defined in '<%2s>'.\\
MISRA C:2012 Rule-21.2; REFERENCE - ISO:C90-7.1.2.1 Reserved Identifiers, ISO:C99-7.1.3 Reserved Identifiers

4605   Rule_21_2             The typedef '%1s' is also defined in '<%2s>'.\\
MISRA C:2012 Rule-21.2; REFERENCE - ISO:C90-7.1.2.1 Reserved Identifiers, ISO:C99-7.1.3 Reserved Identifiers

4606   Rule_21_2             The typedef '%1s' has the same name as another ordinary identifier in '<%2s>'.\\
MISRA C:2012 Rule-21.2; REFERENCE - ISO:C90-7.1.2.1 Reserved Identifiers, ISO:C99-7.1.3 Reserved Identifiers

4607   Rule_21_2             The enum constant '%1s' has the same name as another ordinary identifier in '<%2s>'.\\
MISRA C:2012 Rule-21.2; REFERENCE - ISO:C90-7.1.2.1 Reserved Identifiers, ISO:C99-7.1.3 Reserved Identifiers

4608   Rule_21_2             The tag '%1s' is also defined in '<%2s>'.\\
MISRA C:2012 Rule-21.2; REFERENCE - ISO:C90-7.1.2.1 Reserved Identifiers, ISO:C99-7.1.3 Reserved Identifiers

5087   Rule_20_1             Use of #include directive after code fragment.\\
MISRA C:2012 Rule-20.1

5118   Rule_21_3             Use of memory allocation or deallocation function: calloc, malloc, realloc or free.\\
MISRA C:2012 Rule-21.3

5123   Rule_21_5             Use of standard header file <signal.h>.\\
MISRA C:2012 Rule-21.5

5124   Rule_21_6             Use of standard header file <stdio.h>.\\
MISRA C:2012 Rule-21.6

5125   Rule_21_7             Use of function: atof, atoi, atol or atoll.\\
MISRA C:2012 Rule-21.7

5126   Rule_21_8             Use of function: abort, exit, getenv or system.\\
MISRA C:2012 Rule-21.8

5127   Rule_21_10            Use of standard header file <time.h>.\\
MISRA C:2012 Rule-21.10

5130   Rule_17_1             Use of standard header file <stdarg.h>.\\
MISRA C:2012 Rule-17.1

5131   Rule_21_11            Use of standard header file <tgmath.h>.\\
MISRA C:2012 Rule-21.11

5132   Rule_21_4             Use of standard header file <setjmp.h>.\\
MISRA C:2012 Rule-21.4

5133   Rule_3_1              Comment delimiter /* or // found within comment.\\
MISRA C:2012 Rule-3.1

5134   Rule_3_2              C++ style comment uses line splicing.\\
MISRA C:2012 Rule-3.2

5135   Rule_21_9             Use of function: bsearch or qsort.\\
MISRA C:2012 Rule-21.9

5136   Rule_21_12            Use of exception handling identifier: feclearexcept, fegetexceptflag, feraiseexcept, fesetexceptflag or fetestexcept.\\
MISRA C:2012 Rule-21.12

5137   Rule_8_14             Use of 'restrict' type qualifier.\\
MISRA C:2012 Rule-8.14

5209   Dir_4_6               Use of basic type '%s'.\\
MISRA C:2012 Dir-4.6

5002    HIS_METRICS_REQUIRED          [PATH violation] Number of non-cyclic execution paths.\n <<(FUNC: %1s - LIMIT:80)>>
5003    HIS_METRICS_REQUIRED          [GOTO violation] Number of GOTO statements.\n <<(FUNC: %1s - LIMIT:0)>>
5004    HIS_METRICS_REQUIRED          [v(G) violation] Cyclomatic Complexity.\n <<(FUNC: %1s - LIMIT:10)>>
5005    HIS_METRICS_REQUIRED          [CALLING violation] Number of functions calling the designated function.\n <<(FUNC:%1s - LIMIT:5)>>
5006    HIS_METRICS_REQUIRED          [CALLS violation] Number of function calls in a function.\n <<FUNC:%1s - LIMIT:7)>>
5007    HIS_METRICS_REQUIRED          [PARAM violation] Number of Function Parameters.\n <<(FUNC: %1s - LIMIT:5)>>
5008    HIS_METRICS_REQUIRED          [STMT violation] Number of Instructions per function.\n <<FUNC: %1s - LIMIT:50)>>
5009    HIS_METRICS_REQUIRED          [LEVEL violation] Number of call Levels.\n <<FUNC:%1s - LIMIT:4)>>
5010    HIS_METRICS_REQUIRED          [RETURN violation] Number of return points.\n <<FUNC:%1s - LIMIT:1)>>

5012    HIS_METRICS_MANDATORY         [PATH violation] Number of non-cyclic execution paths.\n <<FUNC: %1s - LIMIT:160)>>
5013    HIS_METRICS_MANDATORY         [GOTO violation] Number of GOTO statements.\n <<FUNC: %1s - LIMIT:0)>>
5014    HIS_METRICS_MANDATORY         [v(G) violation] Cyclomatic Complexity.\n <<FUNC: %1s - LIMIT:40)>>
5015    HIS_METRICS_MANDATORY         [CALLING violation] Number of functions calling the designated function.\n <<FUNC:%1s - LIMIT:10)>>
5016    HIS_METRICS_MANDATORY         [CALLS violation] Number of function calls in a function.\n <<(FUNC:%1s - LIMIT:14)>>
5017    HIS_METRICS_MANDATORY         [PARAM violation] Number of Function Parameters.\n <<(FUNC: %1s - LIMIT:10)>>
5018    HIS_METRICS_MANDATORY         [STMT violation] Number of Instructions per function.\n <<(FUNC: %1s - LIMIT:100)>>
5019    HIS_METRICS_MANDATORY         [LEVEL violation] Number of call Levels. \n <<FUNC:%1s - LIMIT:8)>>
5020    HIS_METRICS_MANDATORY         [RETURN violation] Number of return points.\n <<(FUNC:%1s - LIMIT:2)>>


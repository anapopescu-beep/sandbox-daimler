/**********************************************************************************************************************
 *  COPYRIGHT
 *  -------------------------------------------------------------------------------------------------------------------
 *  \verbatim
 *  Copyright (c) 2021 by Vector Informatik GmbH.                                                  All rights reserved.
 *
 *                This software is copyright protected and proprietary to Vector Informatik GmbH.
 *                Vector Informatik GmbH grants to you only those rights as set out in the license conditions.
 *                All other rights remain with Vector Informatik GmbH.
 *  \endverbatim
 *  -------------------------------------------------------------------------------------------------------------------
 *  FILE DESCRIPTION
 *  -----------------------------------------------------------------------------------------------------------------*/
/*!        \file  Crypto_30_Hwa_Aead.c
 *        \brief  Crypto Hwa AEAD implementation
 *
 *      \details  This file implements AEAD crypto algorithm.
 *
 *********************************************************************************************************************/

/**********************************************************************************************************************
 *  REVISION HISTORY
 *  -------------------------------------------------------------------------------------------------------------------
 *  Refer to the module's header file.
 *********************************************************************************************************************/

#define CRYPTO_30_HWA_AEAD_SOURCE

/**********************************************************************************************************************
 *  INCLUDES
 *********************************************************************************************************************/

#include "Crypto_30_Hwa.h"
#include "Crypto_30_Hwa_Private.h"
#include "Crypto_30_Hwa_Custom.h"

#include "vHsm_Api.h"

/**********************************************************************************************************************
 *  LOCAL CONSTANT MACROS
 *********************************************************************************************************************/
#if !defined (CRYPTO_30_HWA_LOCAL) /* COV_CRYPTO_30_HWA_LOCAL_DEFINE */
# define CRYPTO_30_HWA_LOCAL                                        static
#endif

#if !defined (CRYPTO_30_HWA_LOCAL_INLINE) /* COV_CRYPTO_30_HWA_LOCAL_DEFINE */
# define CRYPTO_30_HWA_LOCAL_INLINE                                 LOCAL_INLINE
#endif

 /* the polynomial is 1+a+a^2+a^7+a^128 => 111000010...01 in little endian representation. */
#define CRYPTO_30_HWA_GF128POLY                                     (0xE1000000u)
#define CRYPTO_30_HWA_GHASH_TAG_SIZE_BIT                            (128u)

#define CRYPTO_30_HWA_AES_GCM_SIV_NONCE_MASK                        (0x80u)
#define CRYPTO_30_HWA_AES_GCM_IV_LAST_BYTE_INDEX                    (15u)

/**********************************************************************************************************************
 *  LOCAL FUNCTION MACROS
 *********************************************************************************************************************/

/**********************************************************************************************************************
 *  LOCAL DATA TYPES AND STRUCTURES
 *********************************************************************************************************************/

/**********************************************************************************************************************
 *  LOCAL DATA PROTOTYPES
 *********************************************************************************************************************/

#if (CRYPTO_30_HWA_PRIMITIVE_AES_GCMSIV == STD_ON) /* COV_CRYPTO_30_HWA_HARDWARE_DEPENDENT_FEATURE */
# define CRYPTO_30_HWA_START_SEC_CONST_UNSPECIFIED
# include "MemMap.h" /* PRQA S 5087 */ /* MD_MSR_MemMap */

 /* Reduction table R:
 * This table was generated by computing the 2^i possible different
 * XOR-combinations of the k-bit-shifted reduction polynomial 0xe1
 * for i = 4 and 0 <= k < i.
 * Having this, one can shift by one blocksize of i bits and reduce by
 * just XORing the table item with the out-shifted value as table index.
 */
CRYPTO_30_HWA_LOCAL CONST(uint16, CRYPTO_30_HWA_CONST) R2[16] = /* PRQA S 3218 */ /* MD_CRYPTO_30_HWA_3218_REDUCTION_TABLE */
{
  0x0000, 0x1c20, 0x3840, 0x2460, 0x7080, 0x6ca0, 0x48c0, 0x54e0,
  0xe100, 0xfd20, 0xd940, 0xc560, 0x9180, 0x8da0, 0xa9c0, 0xb5e0
};

# define CRYPTO_30_HWA_STOP_SEC_CONST_UNSPECIFIED
# include "MemMap.h" /* PRQA S 5087 */ /* MD_MSR_MemMap */
#endif /* (CRYPTO_30_HWA_PRIMITIVE_AES_GCMSIV == STD_ON) */

/**********************************************************************************************************************
 *  GLOBAL DATA
 *********************************************************************************************************************/

/**********************************************************************************************************************
 *  LOCAL FUNCTION PROTOTYPES
 *********************************************************************************************************************/

#define CRYPTO_30_HWA_START_SEC_CODE
#include "MemMap.h" /* PRQA S 5087 */ /* MD_MSR_MemMap */

#if (CRYPTO_30_HWA_PRIMITIVE_AES_GCM == STD_ON) /* COV_CRYPTO_30_HWA_HARDWARE_DEPENDENT_FEATURE */
/**********************************************************************************************************************
 *  Crypto_30_Hwa_AesGcmProcessBlocksAadSlicing()
 *********************************************************************************************************************/
/*! \brief          Splits data blocks according a threashold and sends it to the hardware
 *  \details        -
 *  \param[in,out]  workspace          AES GCM workspace.
 *  \param[in]      blockCount         Number of complete blocks that should be processed. Must be at least 1.
 *  \param[in]      inputPtr           Pointer to input data.
 *  \return         E_OK               Processing was successful.
 *                  E_NOT_OK           Processing failed.
 *  \pre            BlockCount has to be at least 1.
 *  \context        TASK
 *  \reentrant      TRUE, on different driver objects
 *  \synchronous    TRUE
 *********************************************************************************************************************/
CRYPTO_30_HWA_LOCAL_INLINE FUNC(Std_ReturnType, CRYPTO_30_HWA_CODE) Crypto_30_Hwa_AesGcmProcessBlocksAadSlicing(
  Crypto_30_Hwa_WorkSpaceGCM_PtrType workspace,
  uint32 blockCount,
  P2CONST(uint8, AUTOMATIC, CRYPTO_30_HWA_APPL_DATA) inputPtr);

/**********************************************************************************************************************
 *  Crypto_30_Hwa_AesGcmProcessBlocksSlicing()
 *********************************************************************************************************************/
/*! \brief          Splits data blocks according a threashold and sends it to the hardware
 *  \details        -
 *  \param[in,out]  workspace          AES GCM workspace.
 *  \param[in]      blockCount         Number of complete blocks that should be processed. Must be at least 1.
 *  \param[in]      inputPtr           Pointer to input data.
 *  \param[out]     outputPtr          Pointer to output data.
 *  \return         E_OK               Processing was successful.
 *                  E_NOT_OK           Processing failed.
 *  \pre            BlockCount has to be at least 1.
 *  \context        TASK
 *  \reentrant      TRUE, on different driver objects
 *  \synchronous    TRUE
 *********************************************************************************************************************/
CRYPTO_30_HWA_LOCAL_INLINE FUNC(Std_ReturnType, CRYPTO_30_HWA_CODE) Crypto_30_Hwa_AesGcmProcessBlocksSlicing(
  Crypto_30_Hwa_WorkSpaceGCM_PtrType workspace,
  uint32 blockCount,
  P2CONST(uint8, AUTOMATIC, CRYPTO_30_HWA_APPL_DATA) inputPtr,
  P2VAR(uint8, AUTOMATIC, CRYPTO_30_HWA_APPL_VAR) outputPtr);

/**********************************************************************************************************************
 *  Crypto_30_Hwa_AesGcmStart()
 *********************************************************************************************************************/
/*! \brief          Initializes AES GCM calculation.
 *  \details        Sets the key and IV.
 *                  Calculates the key for GHASH.
 *                  Starts the GCM operation.
 *  \param[in,out]  workspace            GCM Workspace.
 *  \param[in]      cryptoKeyId          Crypto Key ID.
 *  \return         E_OK                 Starting AES GCM was successful.
 *                  E_NOT_OK             Starting AES GCM was not successful.
 *  \pre            -
 *  \context        TASK
 *  \reentrant      TRUE, on different driver objects
 *  \synchronous    TRUE
 *********************************************************************************************************************/
CRYPTO_30_HWA_LOCAL_INLINE FUNC(Std_ReturnType, CRYPTO_30_HWA_CODE) Crypto_30_Hwa_AesGcmStart(
  Crypto_30_Hwa_WorkSpaceGCM_PtrType workspace,
  uint32 cryptoKeyId);

/**********************************************************************************************************************
 *  Crypto_30_Hwa_AesGcmUpdateAad()
 *********************************************************************************************************************/
/*! \brief          Performs AES GCM operation on additional authenticated data.
 *  \details        This function is called to update the additional authenticated data. The function is only called,
 *                  when AAD is provided with the first update. This function does not produce output.
 *  \param[in,out]  workspace          GCM Workspace.
 *  \param[in]      inputPtr           Input data buffer.
 *  \param[in]      inputLength        Input data length.
 *  \return         E_OK               Update of AAD was successful.
 *                  E_NOT_OK           Update of AAD failed.
 *  \pre            Crypto_30_Hwa_AesGcmStart() called before.
 *  \context        TASK
 *  \reentrant      TRUE, on different driver objects
 *  \synchronous    TRUE
 *********************************************************************************************************************/
CRYPTO_30_HWA_LOCAL_INLINE FUNC(Std_ReturnType, CRYPTO_30_HWA_CODE) Crypto_30_Hwa_AesGcmUpdateAad(
  Crypto_30_Hwa_WorkSpaceGCM_PtrType workspace,
  P2CONST(uint8, AUTOMATIC, CRYPTO_30_HWA_APPL_DATA) inputPtr,
  uint32 inputLength);

/**********************************************************************************************************************
 *  Crypto_30_Hwa_AesGcmUpdateInput()
 *********************************************************************************************************************/
/*! \brief          Performs AES GCM operation on input data and writes result to output buffer.
 *  \details        This function is called to update the plaintext or ciphertext.
 *  \param[in,out]  workspace          GCM Workspace.
 *  \param[in]      inputPtr           Input data buffer.
 *  \param[in]      inputLength        Input data length.
 *  \param[out]     outputPtr          Output data buffer.
 *  \param[in,out]  outputLengthPtr    Output data length.
 *  \return         E_OK               Update was successful.
 *                  E_NOT_OK           Update failed.
 *  \pre            Crypto_30_Hwa_AesGcmStart() called before.
 *  \context        TASK
 *  \reentrant      TRUE, on different driver objects
 *  \synchronous    TRUE
 *********************************************************************************************************************/
CRYPTO_30_HWA_LOCAL_INLINE FUNC(Std_ReturnType, CRYPTO_30_HWA_CODE) Crypto_30_Hwa_AesGcmUpdateInput(
  Crypto_30_Hwa_WorkSpaceGCM_PtrType workspace,
  P2CONST(uint8, AUTOMATIC, CRYPTO_30_HWA_APPL_DATA) inputPtr,
  uint32 inputLength,
  P2VAR(uint8, AUTOMATIC, CRYPTO_30_HWA_APPL_VAR) outputPtr,
  P2VAR(uint32, AUTOMATIC, CRYPTO_30_HWA_APPL_VAR) outputLengthPtr);

/**********************************************************************************************************************
 *  Crypto_30_Hwa_AesGcmEncFinish()
 *********************************************************************************************************************/
/*! \brief          Finishes AES GCM encryption operation.
 *  \details        Calls hardware specific GCM finish function.
 *  \param[in,out]  workspace                   GCM Workspace.
 *  \param[out]     outputPtr                   Output data buffer.
 *  \param[in,out]  outputLengthPtr             Output data length.
 *  \param[out]     secondaryOutputPtr          Secondary Output data buffer.
 *  \param[in,out]  secondaryOutputLengthPtr    Secondary Output data length.
 *  \return         E_OK                        Finishing AES GCM was successful.
 *                  E_NOT_OK                    Finishing AES GCM failed.
 *  \pre            Crypto_30_Hwa_AesGcmStart() called before.
 *  \context        TASK
 *  \reentrant      TRUE, on different driver objects
 *  \synchronous    TRUE
 *********************************************************************************************************************/
CRYPTO_30_HWA_LOCAL_INLINE FUNC(Std_ReturnType, CRYPTO_30_HWA_CODE) Crypto_30_Hwa_AesGcmEncFinish(
  Crypto_30_Hwa_WorkSpaceGCM_PtrType workspace,  /* PRQA S 3673 */ /* MD_MSR_Rule8.13 */
  P2VAR(uint8, AUTOMATIC, CRYPTO_30_HWA_APPL_VAR) outputPtr,
  P2VAR(uint32, AUTOMATIC, CRYPTO_30_HWA_APPL_VAR) outputLengthPtr,
  P2VAR(uint8, AUTOMATIC, CRYPTO_30_HWA_APPL_VAR) secondaryOutputPtr,
  P2VAR(uint32, AUTOMATIC, CRYPTO_30_HWA_APPL_VAR) secondaryOutputLengthPtr);

/**********************************************************************************************************************
 *  Crypto_30_Hwa_AesGcmDecFinish()
 *********************************************************************************************************************/
/*! \brief          Finishes AES GCM encryption operation.
 *  \details        Calls hardware specific GCM finish function. Compares calculated tag and provided tag
 *                  and handles output.
 *  \param[in,out]  workspace                   GCM Workspace.
 *  \param[in]      tertiaryInputPtr            Provided tag of ciphertext.
 *  \param[in]      tertiaryInputLength         Length of provided tag.
 *  \param[out]     outputPtr                   Output data buffer.
 *  \param[in,out]  outputLengthPtr             Output data length.
 *  \param[out]     verifyPtr                   Output buffer where result from tag comparison is stored.
 *  \return         E_OK                        Finishing AES GCM was successful.
 *                  E_NOT_OK                    Finishing AES GCM failed.
 *  \pre            Crypto_30_Hwa_AesGcmStart() called before.
 *  \context        TASK
 *  \reentrant      TRUE, on different driver objects
 *  \synchronous    TRUE
 *********************************************************************************************************************/
CRYPTO_30_HWA_LOCAL_INLINE FUNC(Std_ReturnType, CRYPTO_30_HWA_CODE) Crypto_30_Hwa_AesGcmDecFinish(
  Crypto_30_Hwa_WorkSpaceGCM_PtrType workspace,  /* PRQA S 3673 */ /* MD_MSR_Rule8.13 */
  P2CONST(uint8, AUTOMATIC, CRYPTO_30_HWA_APPL_DATA) tertiaryInputPtr,
  uint32 tertiaryInputLength,
  P2VAR(uint8, AUTOMATIC, CRYPTO_30_HWA_APPL_VAR) outputPtr,
  P2VAR(uint32, AUTOMATIC, CRYPTO_30_HWA_APPL_VAR) outputLengthPtr,
  P2VAR(uint8, AUTOMATIC, CRYPTO_30_HWA_APPL_VAR) verifyPtr);
#endif /* (CRYPTO_30_HWA_PRIMITIVE_AES_GCM == STD_ON)  */

#if (CRYPTO_30_HWA_PRIMITIVE_AES_GCMSIV == STD_ON) /* COV_CRYPTO_30_HWA_HARDWARE_DEPENDENT_FEATURE */
/**********************************************************************************************************************
 *  Crypto_30_Hwa_XOR()
 *********************************************************************************************************************/
/*! \brief          XORs an array bytewise to another.
 *  \details        XORs an array bytewise to another. The number of bytes to be XORed is defined in parameter count.
                    XOR (buf1 ^= buf2).
 *  \param[in,out]  buf1  In-Out buffer which gets XORed.
 *  \param[in]      buf2  Input pointer of the XOR values.
 *  \param[in]      count Number of bytes which shall XORed.
 *  \pre            buf1, buf2 must be valid pointers
 *  \context        TASK
 *  \reentrant      TRUE
 *  \synchronous    TRUE
 *********************************************************************************************************************/
CRYPTO_30_HWA_LOCAL_INLINE FUNC(void, CRYPTO_30_HWA_CODE) Crypto_30_Hwa_XOR(
  P2VAR(uint8, AUTOMATIC, CRYPTO_30_HWA_APPL_VAR) buf1,
  P2CONST(uint8, AUTOMATIC, CRYPTO_30_HWA_APPL_DATA) buf2,
  uint32 count);

/**********************************************************************************************************************
 *  Crypto_30_Hwa_CpyU32toBE()
 *********************************************************************************************************************/
/*! \brief       Copy u32 to u8 big endian array
 *  \details     This function copies u32 array into u8 array in big endian format.
 *  \param[out]  tgt  Pointer to target array
 *  \param[in]   src  Pointer to source array
 *  \param[in]   length  Size of tgt/src array in bytes
 *  \pre         Pointers must be valid.
 *               Array sizes must be correct.
 *               elements of tgt = 4 * elements of src
 *  \context     TASK
 *  \reentrant   TRUE
 *  \synchronous TRUE
 *********************************************************************************************************************/
CRYPTO_30_HWA_LOCAL_INLINE FUNC(void, CRYPTO_30_HWA_CODE) Crypto_30_Hwa_CpyU32toBE(
  P2VAR(uint8, AUTOMATIC, CRYPTO_30_HWA_APPL_VAR) tgt,
  P2CONST(uint32, AUTOMATIC, CRYPTO_30_HWA_APPL_DATA) src,
  const uint32 length);

/**********************************************************************************************************************
 *  Crypto_30_Hwa_CpyBEtoU32()
 *********************************************************************************************************************/
/*! \brief       Copy u8 big endian array to u32 array
 *  \details     This function copies u8 array in big endian format into u32 array.
 *  \param[out]  tgt  Pointer to target array
 *  \param[in]   src  Pointer to source array
 *  \param[in]   length  Size of tgt/src array in bytes
 *  \pre         Pointers must be valid.
 *               Array sizes must be correct.
 *               elements of src * 4 = elements of tgt
 *  \context     TASK
 *  \reentrant   TRUE
 *  \synchronous TRUE
 *********************************************************************************************************************/
CRYPTO_30_HWA_LOCAL_INLINE FUNC(void, CRYPTO_30_HWA_CODE) Crypto_30_Hwa_CpyBEtoU32(
  P2VAR(uint32, AUTOMATIC, CRYPTO_30_HWA_APPL_VAR) tgt,
  P2CONST(uint8, AUTOMATIC, CRYPTO_30_HWA_APPL_DATA) src,
  const uint32 length);

/**********************************************************************************************************************
 *  Crypto_30_Hwa_AddInputToPolyval()
 *********************************************************************************************************************/
/*! \brief          Adds input to the calculation of the polyval value, which is needed for the GCM SIV tag.
 *  \details        Slices the input into full AES blocks and forwards them to the polyval calculation. If the last block
                    is no full AES block, it is padded with zeros.
 *  \param[in,out]  workspace    GCM SIV Workspace.
 *  \param[in]      inputPtr     Pointer to the input buffer.
 *  \param[in]      inputLength  Length of the input.
 *  \pre            Crypto_30_Hwa_AesGcmStart() called before.
 *  \context        TASK
 *  \reentrant      TRUE, on different driver objects
 *  \synchronous    TRUE
 *********************************************************************************************************************/
CRYPTO_30_HWA_LOCAL FUNC(void, CRYPTO_30_HWA_CODE) Crypto_30_Hwa_AddInputToPolyval(
  Crypto_30_Hwa_WorkSpaceGCMSIV_PtrType workspace,
  P2CONST(uint8, AUTOMATIC, CRYPTO_30_HWA_APPL_DATA) inputPtr,
  uint32 inputLength);

/**********************************************************************************************************************
 *  Crypto_30_Hwa_Gf128Zero()
 **********************************************************************************************************************/
/*! \brief         Zeroes a GF128 block.
 *  \details       -
 *  \param[in,out] Z  The GF128 block that shall be zeroed.
 *  \pre           Z must point to a valid buffer of at least the size (4 * sizeof(uint32)) bytes
 *  \context       ANY
 *  \reentrant     TRUE
 *  \synchronous   TRUE
 *********************************************************************************************************************/
CRYPTO_30_HWA_LOCAL FUNC(void, CRYPTO_30_HWA_CODE) Crypto_30_Hwa_Gf128Zero(
  P2VAR(uint32, AUTOMATIC, CRYPTO_30_HWA_APPL_VAR) Z);

/**********************************************************************************************************************
 *  Crypto_30_Hwa_Gf128Add()
 **********************************************************************************************************************/
/*! \brief         XOR two blocks in GF(2^128).
 *  \details       This function computes Z = X + Y for full blocks X and Y, which is a simple XOR in GF(2^128).
 *  \param[out]    Z  Result of XOR operation.
 *  \param[in]     X  First operand
 *  \param[in]     Y  Second operand
 *  \pre           Z, X, Y must point to valid buffers each of at least the size (4 * sizeof(uint32)) bytes
 *  \context       ANY
 *  \reentrant     TRUE
 *  \synchronous   TRUE
 *********************************************************************************************************************/
CRYPTO_30_HWA_LOCAL FUNC(void, CRYPTO_30_HWA_CODE) Crypto_30_Hwa_Gf128Add(
  P2VAR(uint32, AUTOMATIC, CRYPTO_30_HWA_APPL_VAR) Z,
  P2CONST(uint32, AUTOMATIC, CRYPTO_30_HWA_APPL_DATA) X,
  P2CONST(uint32, AUTOMATIC, CRYPTO_30_HWA_APPL_DATA) Y);

/**********************************************************************************************************************
 *  Crypto_30_Hwa_Gf128Rightshift_4()
 **********************************************************************************************************************/
/*! \brief         Rightshift by 4 bit positions.
 *  \details       Rightshift by 4 bit positions. Instead of reducing directly, return the
 *                 bits that were shifted out.
 *  \param[in,out] block  Output block
 *  \pre           block must must point to valid buffers of at least the size (4 * sizeof(uint32)) bytes
 *  \context       ANY
 *  \reentrant     TRUE
 *  \synchronous   TRUE
 *********************************************************************************************************************/
CRYPTO_30_HWA_LOCAL FUNC(uint8, CRYPTO_30_HWA_CODE) Crypto_30_Hwa_Gf128Rightshift_4(
  P2VAR(uint32, AUTOMATIC, CRYPTO_30_HWA_APPL_VAR) block);

/**********************************************************************************************************************
 *  Crypto_30_Hwa_GF128Mul()
 **********************************************************************************************************************/
/*! \brief         Performs a multiplication in GF(2^128) speeded up by using a rightshift by 4 bit positions.
 *  \details       This function performs a multiplication Z = X * H, with Z in GF(2^128),
 *                 using the GCM reduction polynomial R = 1 + a + a^2 + a^7 + a^128. Speeding up is achieved by using
 *                 a rightshift by 4 bit positions.
 *  \param[in]     info  pointer to context structure
 *  \param[out]    Z  pointer to memory location for the result, Z = X * H with H being the internally stored sub-key
 *  \param[in]     X  pointer to the polynomial to multiply
 *  \pre           info must be a valid workspace pointer
 *                 Z, X must point to valid buffers each of at least the size (4 * sizeof(uint32)) bytes
 *  \context       ANY
 *  \reentrant     TRUE
 *  \synchronous   TRUE
 *********************************************************************************************************************/
CRYPTO_30_HWA_LOCAL_INLINE FUNC(void, CRYPTO_30_HWA_CODE) Crypto_30_Hwa_GF128Mul(
  P2CONST(Crypto_30_Hwa_GhashStruct, AUTOMATIC, CRYPTO_30_HWA_APPL_DATA) info,
  P2VAR(uint32, AUTOMATIC, CRYPTO_30_HWA_APPL_VAR) Z,
  P2CONST(uint8, AUTOMATIC, CRYPTO_30_HWA_APPL_DATA) X);

/**********************************************************************************************************************
 *  Crypto_30_Hwa_MulXGHash()
 **********************************************************************************************************************/
/*! \brief         Bitshift in GF(2^128).
 *  \details       Compute Z = 2 * X for a full block X, which is a simple bitshift in GF(2^128).
 *                 If the result is greater than the field polynomial, it is reduced.
 *  \param[out]    Z  Output block
 *  \param[in]     X  Input block
 *  \pre           Z, X must must point to valid buffers each of at least the size (4 * sizeof(uint32)) bytes
 *  \context       ANY
 *  \reentrant     TRUE
 *  \synchronous   TRUE
 *********************************************************************************************************************/
CRYPTO_30_HWA_LOCAL FUNC(void, CRYPTO_30_HWA_CODE) Crypto_30_Hwa_MulXGHash(
  P2VAR(uint32, AUTOMATIC, CRYPTO_30_HWA_APPL_VAR) Z,
  P2CONST(uint32, AUTOMATIC, CRYPTO_30_HWA_APPL_DATA) X);

/**********************************************************************************************************************
 *  Crypto_30_Hwa_GHashTransformBlock()
 **********************************************************************************************************************/
/*! \brief         GHashes a complete input block.
 *  \details       This function GHashes a complete input block and stores the result internally.
 *  \param[in,out] info  pointer to context structure
 *  \param[in]     X  pointer to input block, which is expected to be a complete block of GHASH_BLOCK_SIZE
 *  \pre           info must be a valid workspace pointer
 *                 X must be a valid pointer
 *  \context       ANY
 *  \reentrant     TRUE, for different workspaces
 *  \synchronous   TRUE
 *********************************************************************************************************************/
CRYPTO_30_HWA_LOCAL_INLINE FUNC(void, CRYPTO_30_HWA_CODE) Crypto_30_Hwa_GHashTransformBlock(
  P2VAR(Crypto_30_Hwa_GhashStruct, AUTOMATIC, CRYPTO_30_HWA_APPL_VAR) info,
  P2CONST(uint8, AUTOMATIC, CRYPTO_30_HWA_APPL_DATA) X);

/**********************************************************************************************************************
 *  Crypto_30_Hwa_GHashReset()
 *********************************************************************************************************************/
/*! \brief          Resets the hash-block Y to zero.
 *  \details        This function resets the hash-block Y to zero.
 *                  It does NOT import the hash-subkey.
 *  \param[in,out]  info  pointer to context structure
 *  \return         E_OK always
 *  \pre            info must be a valid workspace pointer
 *  \context        TASK
 *  \reentrant      TRUE, for different workspaces.
 *  \synchronous    TRUE
 *********************************************************************************************************************/
CRYPTO_30_HWA_LOCAL_INLINE FUNC(Std_ReturnType, CRYPTO_30_HWA_CODE) Crypto_30_Hwa_GHashReset(
  P2VAR(Crypto_30_Hwa_GhashStruct, AUTOMATIC, CRYPTO_30_HWA_APPL_VAR) info);

/**********************************************************************************************************************
 *  Crypto_30_Hwa_GHashInit()
 *********************************************************************************************************************/
/*! \brief          Initializes the hash-block Y to zero.
 *  \details        This function initializes the hash-block Y to zero.
 *  \param[in,out]  info  (in)  pointer to context structure
 *                        (out) initialized context structure
 *  \param[in]      H  the hash subkey
 *  \return         E_OK always
 *  \pre            info must be a valid workspace pointer
 *  \context        TASK
 *  \reentrant      TRUE, for different workspaces.
 *  \synchronous    TRUE
 *********************************************************************************************************************/
CRYPTO_30_HWA_LOCAL_INLINE FUNC(Std_ReturnType, CRYPTO_30_HWA_CODE) Crypto_30_Hwa_GHashInit(
  P2VAR(Crypto_30_Hwa_GhashStruct, AUTOMATIC, CRYPTO_30_HWA_APPL_VAR) info,
  P2CONST(uint8, AUTOMATIC, CRYPTO_30_HWA_APPL_DATA) H);

/**********************************************************************************************************************
 *  Crypto_30_Hwa_ByteReverse()
 *********************************************************************************************************************/
/*! \brief        Reverses the byte order of a 16-byte input block.
 *  \details      -
 *  \param[out]   out     Buffer for the output array with reversed byte order.
 *  \param[in]    in      Buffer for the input array.
 *  \param[in]    in_len  Length of the input.
 *  \pre          info must be a valid workspace pointer
 *  \context      TASK
 *  \reentrant    TRUE, for different workspaces.
 *  \synchronous  TRUE
 *********************************************************************************************************************/
CRYPTO_30_HWA_LOCAL FUNC(void, CRYPTO_30_HWA_CODE) Crypto_30_Hwa_ByteReverse(
   P2VAR(uint8, AUTOMATIC, CRYPTO_30_HWA_APPL_VAR) out,
   P2CONST(uint8, AUTOMATIC, CRYPTO_30_HWA_APPL_DATA) in,
   uint32 in_len);

/**********************************************************************************************************************
 *  Crypto_30_Hwa_PolyvalInit()
 *********************************************************************************************************************/
/*! \brief          Initializes the calculation of the polyval value.
 *  \details        -
 *  \param[in,out]  info  (in)  pointer to context structure
 *                        (out) initialized context structure
 *  \param[in]      key   the hash subkey
 *  \return         E_OK  always
 *  \pre            info must be a valid workspace pointer
 *  \context        TASK
 *  \reentrant      TRUE, for different workspaces.
 *  \synchronous    TRUE
 *********************************************************************************************************************/
CRYPTO_30_HWA_LOCAL_INLINE FUNC(Std_ReturnType, CRYPTO_30_HWA_CODE) Crypto_30_Hwa_PolyvalInit(
  P2VAR(Crypto_30_Hwa_PolyvalStruct, AUTOMATIC, CRYPTO_30_HWA_APPL_VAR) info,
  P2CONST(uint8, AUTOMATIC, CRYPTO_30_HWA_APPL_DATA) key);

/**********************************************************************************************************************
 *  Crypto_30_Hwa_PolyvalUpdate()
 *********************************************************************************************************************/
/*! \brief          Initializes the hash-block Y to zero.
 *  \details        This function initializes the hash-block Y to zero.
 *  \param[in,out]  info       (in)  pointer to context structure
 *                             (out) initialized context structure
 *  \param[in]      input      Pointer to the input buffer.
 *  \param[in]      input_len  Length of the input.
 *  \pre            info must be a valid workspace pointer
 *  \context        TASK
 *  \reentrant      TRUE, for different workspaces.
 *  \synchronous    TRUE
 *********************************************************************************************************************/
CRYPTO_30_HWA_LOCAL FUNC(void, CRYPTO_30_HWA_CODE) Crypto_30_Hwa_PolyvalUpdate(
  P2VAR(Crypto_30_Hwa_PolyvalStruct, AUTOMATIC, CRYPTO_30_HWA_APPL_VAR) info,
  P2CONST(uint8, AUTOMATIC, CRYPTO_30_HWA_APPL_DATA) input,
  uint32 input_len);

/**********************************************************************************************************************
 *  Crypto_30_Hwa_PolyvalFinalize()
 *********************************************************************************************************************/
/*! \brief          Finalizes the GHash algorithm and outputs the hash value.
 *  \details        This function finalizes the GHash algorithm and outputs the hash value.
 *                  Incomplete blocks are padded with zeroes.
 *  \param[in,out]  info    (in)  pointer to initialized context structure
 *                          (out) the updated context structure
 *  \param[out]     output  byte array to contain the final hash value
 *  \pre            info must be a valid workspace pointer
 *                  Crypto_30_Hwa_PolyvalInit() is called once before calling this function
 *                  hash must point to a valid buffer of at least the size CRYPTO_30_HWA_GHASH_BLOCK_SIZE
 *  \context        TASK
 *  \reentrant      TRUE, for different workspaces.
 *  \synchronous    TRUE
 *********************************************************************************************************************/
CRYPTO_30_HWA_LOCAL FUNC(void, CRYPTO_30_HWA_CODE) Crypto_30_Hwa_PolyvalFinalize(
  P2VAR(Crypto_30_Hwa_PolyvalStruct, AUTOMATIC, CRYPTO_30_HWA_APPL_VAR) info,
  P2VAR(uint8, AUTOMATIC, CRYPTO_30_HWA_APPL_VAR) output);

/**********************************************************************************************************************
 *  Crypto_30_Hwa_CalculateLengthBlock()
 *********************************************************************************************************************/
/*! \brief          Creates an AES block which contains the length of the additional authenticated input and the
 *                  plain-/ciphertext in the correct format.
 *  \details        The length values are calculated in bits and placed in a little endian array.
 *  \param[in]      secondaryInputLength   Length of the additional authenticated data
 *  \param[in]      inputLength            Length of the plain- or ciphertext.
 *  \param[out]     lengthBlock            Array which contains both length values.
 *  \pre            -
 *  \context        TASK
 *  \reentrant      TRUE, on different driver objects
 *  \synchronous    TRUE
 *********************************************************************************************************************/
CRYPTO_30_HWA_LOCAL FUNC(void, CRYPTO_30_HWA_CODE) Crypto_30_Hwa_CalculateLengthBlock(
  uint32 secondaryInputLength,
  uint32 inputLength,
  P2VAR(uint8, AUTOMATIC, CRYPTO_30_HWA_APPL_VAR) lengthBlock);

/**********************************************************************************************************************
 *  Crypto_30_Hwa_AesGcmSivStart()
 *********************************************************************************************************************/
/*! \brief          Initializes the AES GCM SIV calculation.
 *  \details        Gets the initial key and initialisation vector and initiates the key derivation and polyval
 *                  calculation.
 *  \param[in,out]  workspace    GCM SIV Workspace.
 *  \param[in]      cryptoKeyId  Crypto Key ID.
 *  \return         E_OK         Start step of AES GCM SIV was successful.
 *                  E_NOT_OK     Start step of AES GCM SIV failed.
 *  \pre            -
 *  \context        TASK
 *  \reentrant      TRUE, on different driver objects
 *  \synchronous    TRUE
 *********************************************************************************************************************/
CRYPTO_30_HWA_LOCAL_INLINE FUNC(Std_ReturnType, CRYPTO_30_HWA_CODE) Crypto_30_Hwa_AesGcmSivStart(
  Crypto_30_Hwa_WorkSpaceGCMSIV_PtrType workspace,
  uint32 cryptoKeyId);

/**********************************************************************************************************************
 *  Crypto_30_Hwa_AesGcmSivEncUpdate()
 *********************************************************************************************************************/
/*! \brief          Performs the AES GCM SIV operation over the additional authenticated data and the plaintext.
 *  \details        The tag is calculated and the plaintext is encrypted and returned by the output buffer.
 *  \param[in,out]  workspace             GCM SIV Workspace.
 *  \param[in]      inputPtr              Buffer for the plaintext.
 *  \param[in]      inputLength           Length of the plaintext.
 *  \param[in]      secondaryInputPtr     Buffer for the additional authenticated data
 *  \param[in]      secondaryInputLength  Length of the additional authenticated data
 *  \param[out]     outputPtr             Buffer for the cipher text.
 *  \param[in,out]  outputLengthPtr       Length of the output buffer.
 *  \return         E_OK                  Encrypt update step of AES GCM SIV was successful.
 *                  E_NOT_OK              Encrypt update step of AES GCM SIV failed.
 *  \pre            Crypto_30_Hwa_AesGcmSivStart() called before.
 *  \context        TASK
 *  \reentrant      TRUE, on different driver objects
 *  \synchronous    TRUE
 *********************************************************************************************************************/
CRYPTO_30_HWA_LOCAL_INLINE FUNC(Std_ReturnType, CRYPTO_30_HWA_CODE) Crypto_30_Hwa_AesGcmSivEncUpdate(
  Crypto_30_Hwa_WorkSpaceGCMSIV_PtrType workspace,
  P2CONST(uint8, AUTOMATIC, CRYPTO_30_HWA_APPL_DATA) inputPtr,
  uint32 inputLength,
  P2CONST(uint8, AUTOMATIC, CRYPTO_30_HWA_APPL_DATA) secondaryInputPtr,
  uint32 secondaryInputLength,
  P2VAR(uint8, AUTOMATIC, CRYPTO_30_HWA_APPL_VAR) outputPtr,
  P2VAR(uint32, AUTOMATIC, CRYPTO_30_HWA_APPL_VAR) outputLengthPtr);

/**********************************************************************************************************************
 *  Crypto_30_Hwa_AesGcmSivEncFinish()
 *********************************************************************************************************************/
/*! \brief          Returns the tag of the ciphertext.
 *  \details        -
 *  \param[in,out]  workspace                 GCM SIV Workspace.
 *  \param[out]     secondaryOutputPtr        Buffer for the tag.
 *  \param[in,out]  secondaryOutputLengthPtr  Length of the secondary output buffer.
 *  \return         E_OK                      Encrypt finish step of AES GCM SIV was successful.
 *                  E_NOT_OK                  Encrypt finish step of AES GCM SIV failed.
 *  \pre            Crypto_30_Hwa_AesGcmSivEncUpdate() called before.
 *  \context        TASK
 *  \reentrant      TRUE, on different driver objects
 *  \synchronous    TRUE
 *********************************************************************************************************************/
CRYPTO_30_HWA_LOCAL_INLINE FUNC(Std_ReturnType, CRYPTO_30_HWA_CODE) Crypto_30_Hwa_AesGcmSivEncFinish(
  Crypto_30_Hwa_WorkSpaceGCMSIV_PtrType workspace,
  P2VAR(uint8, AUTOMATIC, CRYPTO_30_HWA_APPL_VAR) secondaryOutputPtr,
  P2VAR(uint32, AUTOMATIC, CRYPTO_30_HWA_APPL_VAR) secondaryOutputLengthPtr);

/**********************************************************************************************************************
 *  Crypto_30_Hwa_AesGcmSivDecUpdate()
 *********************************************************************************************************************/
/*! \brief          Performs the AES GCM SIV operation over the additional authenticated data and the ciphertext.
 *  \details        The ciphertext is decrypted and returned by the output buffer and the tag verified.
 *  \param[in,out]  workspace             GCM SIV Workspace.
 *  \param[in]      inputPtr              Buffer for the ciphertext.
 *  \param[in]      inputLength           Length of the ciphertext.
 *  \param[in]      secondaryInputPtr     Buffer for the additional authenticated data.
 *  \param[in]      secondaryInputLength  Length of the additional authenticated data.
 *  \param[in]      tertiaryInputPtr      Provided tag of input.
 *  \param[in]      tertiaryInputLength   Length of provided tag.
 *  \param[out]     outputPtr             Output buffer for plaintext.
 *  \param[in,out]  outputLengthPtr       Size of output data buffer.
 *  \return         E_OK                  Decrypt update step of AES GCM SIV was successful.
 *                  E_NOT_OK              Decrypt update step of AES GCM SIV failed.
 *  \pre            Crypto_30_Hwa_AesGcmSivStart() called before.
 *  \context        TASK
 *  \reentrant      TRUE, on different driver objects
 *  \synchronous    TRUE
 *********************************************************************************************************************/
CRYPTO_30_HWA_LOCAL_INLINE FUNC(Std_ReturnType, CRYPTO_30_HWA_CODE) Crypto_30_Hwa_AesGcmSivDecUpdate(
  Crypto_30_Hwa_WorkSpaceGCMSIV_PtrType workspace,
  P2CONST(uint8, AUTOMATIC, CRYPTO_30_HWA_APPL_DATA) inputPtr,
  uint32 inputLength,
  P2CONST(uint8, AUTOMATIC, CRYPTO_30_HWA_APPL_DATA) secondaryInputPtr,
  uint32 secondaryInputLength,
  P2CONST(uint8, AUTOMATIC, CRYPTO_30_HWA_APPL_DATA) tertiaryInputPtr,
  uint32 tertiaryInputLength,
  P2VAR(uint8, AUTOMATIC, CRYPTO_30_HWA_APPL_VAR) outputPtr,
  P2VAR(uint32, AUTOMATIC, CRYPTO_30_HWA_APPL_VAR) outputLengthPtr);

/**********************************************************************************************************************
 *  Crypto_30_Hwa_AesGcmSivDecFinish()
 *********************************************************************************************************************/
/*! \brief          Returns the value of the verification of the tag.
 *  \details        -
 *  \param[in,out]  workspace   GCM Workspace.
 *  \param[out]     verifyPtr   Output buffer where result from tag comparison is stored.
 *  \return         E_OK        Always
 *  \pre            Crypto_30_Hwa_AesGcmSivDecUpdate() called before.
 *  \context        TASK
 *  \reentrant      TRUE, on different driver objects
 *  \synchronous    TRUE
 *********************************************************************************************************************/
CRYPTO_30_HWA_LOCAL_INLINE FUNC(Std_ReturnType, CRYPTO_30_HWA_CODE) Crypto_30_Hwa_AesGcmSivDecFinish(
  Crypto_30_Hwa_WorkSpaceGCMSIV_PtrType workspace,
  P2VAR(Crypto_VerifyResultType, AUTOMATIC, CRYPTO_30_HWA_APPL_VAR) verifyPtr);
#endif /* (CRYPTO_30_HWA_PRIMITIVE_AES_GCMSIV == STD_ON) */

#define CRYPTO_30_HWA_STOP_SEC_CODE
#include "MemMap.h" /* PRQA S 5087 */ /* MD_MSR_MemMap */

/**********************************************************************************************************************
 *  LOCAL FUNCTIONS
 *********************************************************************************************************************/

#define CRYPTO_30_HWA_START_SEC_CODE
#include "MemMap.h" /* PRQA S 5087 */ /* MD_MSR_MemMap */

#if (CRYPTO_30_HWA_PRIMITIVE_AES_GCM == STD_ON) /* COV_CRYPTO_30_HWA_HARDWARE_DEPENDENT_FEATURE */
/**********************************************************************************************************************
 *  Crypto_30_Hwa_AesGcmProcessBlocksAadSlicing()
 **********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 */
CRYPTO_30_HWA_LOCAL_INLINE FUNC(Std_ReturnType, CRYPTO_30_HWA_CODE) Crypto_30_Hwa_AesGcmProcessBlocksAadSlicing(
  Crypto_30_Hwa_WorkSpaceGCM_PtrType workspace,
  uint32 blockCount,
  P2CONST(uint8, AUTOMATIC, CRYPTO_30_HWA_APPL_DATA) inputPtr)
{
  Std_ReturnType retVal = E_OK; /* PRQA S 2981 */ /* MD_MSR_RetVal */
#if (CRYPTO_30_HWA_DATA_SLICING == STD_ON)
  uint32 i;
  uint32 offset;
  uint32 reminder = blockCount % CRYPTO_30_HWA_NON_PREEMPTIVE_BLOCK_COUNT_ROUNDED_AES;

  /* Process multiples of CRYPTO_30_HWA_NON_PREEMPTIVE_BLOCK_COUNT_ROUNDED_AES */
  for (i = 0; i < (blockCount / CRYPTO_30_HWA_NON_PREEMPTIVE_BLOCK_COUNT_ROUNDED_AES); ++i)
  {
    offset = i * CRYPTO_30_HWA_AES_BLOCK_SIZE_BYTES * CRYPTO_30_HWA_NON_PREEMPTIVE_BLOCK_COUNT_ROUNDED_AES;
    SchM_Enter_Crypto_30_Hwa_CRYPTO_30_HWA_EXCLUSIVE_AREA_1();
    retVal |= Crypto_30_Hwa_Hw_AesGcmProcessBlocksAad(workspace, CRYPTO_30_HWA_NON_PREEMPTIVE_BLOCK_COUNT_ROUNDED_AES, &inputPtr[offset]);
    SchM_Exit_Crypto_30_Hwa_CRYPTO_30_HWA_EXCLUSIVE_AREA_1();
  }

  /* Process not multiples of CRYPTO_30_HWA_NON_PREEMPTIVE_BLOCK_COUNT_ROUNDED_AES */
  if (reminder > 0u)
  {
    offset = i * CRYPTO_30_HWA_AES_BLOCK_SIZE_BYTES * CRYPTO_30_HWA_NON_PREEMPTIVE_BLOCK_COUNT_ROUNDED_AES;
    SchM_Enter_Crypto_30_Hwa_CRYPTO_30_HWA_EXCLUSIVE_AREA_1();
    retVal |= Crypto_30_Hwa_Hw_AesGcmProcessBlocksAad(workspace, reminder, &inputPtr[offset]);
    SchM_Exit_Crypto_30_Hwa_CRYPTO_30_HWA_EXCLUSIVE_AREA_1();
  }

#else
  retVal = Crypto_30_Hwa_Hw_AesGcmProcessBlocksAad(workspace, blockCount, inputPtr);
#endif /* (CRYPTO_30_HWA_DATA_SLICING == STD_ON) */

  return retVal;
}

/**********************************************************************************************************************
 *  Crypto_30_Hwa_AesGcmProcessBlocksSlicing()
 **********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 */
CRYPTO_30_HWA_LOCAL_INLINE FUNC(Std_ReturnType, CRYPTO_30_HWA_CODE) Crypto_30_Hwa_AesGcmProcessBlocksSlicing(
  Crypto_30_Hwa_WorkSpaceGCM_PtrType workspace,
  uint32 blockCount,
  P2CONST(uint8, AUTOMATIC, CRYPTO_30_HWA_APPL_DATA) inputPtr,
  P2VAR(uint8, AUTOMATIC, CRYPTO_30_HWA_APPL_VAR) outputPtr)
{
  Std_ReturnType retVal = E_OK; /* PRQA S 2981 */ /* MD_MSR_RetVal */
#if (CRYPTO_30_HWA_DATA_SLICING == STD_ON)
  uint32 i;
  uint32 offset;
  uint32 reminder = blockCount % CRYPTO_30_HWA_NON_PREEMPTIVE_BLOCK_COUNT_ROUNDED_AES;

  /* Process multiples of CRYPTO_30_HWA_NON_PREEMPTIVE_CHUNK_SIZE */
  for (i = 0; i < (blockCount / CRYPTO_30_HWA_NON_PREEMPTIVE_BLOCK_COUNT_ROUNDED_AES); ++i)
  {
    offset = i * CRYPTO_30_HWA_AES_BLOCK_SIZE_BYTES * CRYPTO_30_HWA_NON_PREEMPTIVE_BLOCK_COUNT_ROUNDED_AES;
    SchM_Enter_Crypto_30_Hwa_CRYPTO_30_HWA_EXCLUSIVE_AREA_1();
    retVal |= Crypto_30_Hwa_Hw_AesGcmProcessBlocksInput(workspace, CRYPTO_30_HWA_NON_PREEMPTIVE_BLOCK_COUNT_ROUNDED_AES, &inputPtr[offset], &outputPtr[offset]);
    SchM_Exit_Crypto_30_Hwa_CRYPTO_30_HWA_EXCLUSIVE_AREA_1();
  }

  /* Process not multiples of CRYPTO_30_HWA_NON_PREEMPTIVE_CHUNK_SIZE */
  if (reminder > 0u)
  {
    offset = i * CRYPTO_30_HWA_AES_BLOCK_SIZE_BYTES * CRYPTO_30_HWA_NON_PREEMPTIVE_BLOCK_COUNT_ROUNDED_AES;
    SchM_Enter_Crypto_30_Hwa_CRYPTO_30_HWA_EXCLUSIVE_AREA_1();
    retVal |= Crypto_30_Hwa_Hw_AesGcmProcessBlocksInput(workspace, reminder, &inputPtr[offset], &outputPtr[offset]);
    SchM_Exit_Crypto_30_Hwa_CRYPTO_30_HWA_EXCLUSIVE_AREA_1();
  }

#else
  retVal = Crypto_30_Hwa_Hw_AesGcmProcessBlocksInput(workspace, blockCount, inputPtr, outputPtr);
#endif /* (CRYPTO_30_HWA_DATA_SLICING == STD_ON) */

  return retVal;
}

/**********************************************************************************************************************
 *  Crypto_30_Hwa_AesGcmStart()
 **********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 */
CRYPTO_30_HWA_LOCAL_INLINE FUNC(Std_ReturnType, CRYPTO_30_HWA_CODE) Crypto_30_Hwa_AesGcmStart(
  Crypto_30_Hwa_WorkSpaceGCM_PtrType workspace,
  uint32 cryptoKeyId)
{
  Std_ReturnType retVal = E_OK; /* PRQA S 2981 */ /* MD_MSR_RetVal */
  vHsm_Api_KeyStorageIndexType index = 0;

  P2CONST(uint8, AUTOMATIC, CRYPTO_30_HWA_APPL_DATA) key = NULL_PTR; /* PRQA S 2981 */ /* MD_CRYPTO_30_HWA_2981_REDUNDANT_INITIALIZATION */
  P2CONST(uint8, AUTOMATIC, CRYPTO_30_HWA_APPL_DATA) iv;

  uint32 ivKeyId = cryptoKeyId;

  /* Init workspace */
  workspace->cryptoKeyId = cryptoKeyId;
  workspace->processingFinishedAad = FALSE;
  workspace->bufferFillLevel = 0u;
  workspace->outputLength = 0u;
  workspace->processedLengthAad = 0u;
  workspace->processedLengthInput = 0u;
  VStdLib_MemClr(workspace->ivPadded, CRYPTO_30_HWA_AES_BLOCK_SIZE_BYTES); /* PRQA S 0315 */ /* MD_MSR_VStdLibCopy */

# if (CRYPTO_30_HWA_ROMKEY == STD_ON) /* COV_CRYPTO_30_HWA_HARDWARE_DEPENDENT_FEATURE */
  workspace->romKeyMapIndex = 0;

  Crypto_30_Hwa_CheckRomKeyUsage(workspace->cryptoKeyId, &workspace->romKeyMapIndex);

  /* Verify if provided key is ROM_Key */
  if (workspace->romKeyMapIndex == CRYPTO_30_HWA_ROMKEY_USE_IMPORTED_KEY)
# endif /* (CRYPTO_30_HWA_ROMKEY == STD_ON) */
  {
    /* Get AES key */
    retVal = vHsm_Api_KeyElementGetForCryptoJobs(cryptoKeyId, CRYPTO_KE_CIPHER_KEY,
      &index, CRYPTO_30_HWA_AES_KEY_SIZE, VHSM_API_SHE_SERVICE_ENCRYPT_DECRYPT);

    if (retVal == E_OK)
    {
      key = vHsm_Api_GetAddrKeyStorage(index);
    }
  }

  if(retVal == E_OK)
  {
    /* Get IV */
# if (CRYPTO_30_HWA_ROMKEY == STD_ON) /* COV_CRYPTO_30_HWA_HARDWARE_DEPENDENT_FEATURE */
    index = 0u;
    if (workspace->romKeyMapIndex != CRYPTO_30_HWA_ROMKEY_USE_IMPORTED_KEY)
    {
      ivKeyId = Crypto_30_Hwa_GetAggregatedCryptoKeyIdOfKeyMap(workspace->romKeyMapIndex);
    }
# endif /* (CRYPTO_30_HWA_ROMKEY == STD_ON) */

    retVal = vHsm_Api_KeyElementGetForCryptoJobs(ivKeyId,
      CRYPTO_KE_CIPHER_IV, &index, CRYPTO_30_HWA_AESGCM_IV_LENGTH_BYTES, VHSM_API_SHE_SERVICE_ENCRYPT_DECRYPT);

    /* Call platform specific AES GCM start function */
    if (retVal == E_OK)
    {
      iv = vHsm_Api_GetAddrKeyStorage(index);

      /* Apply GCM IV padding and store IV for later use in finish step */
      workspace->ivPadded[CRYPTO_30_HWA_AES_GCM_IV_LAST_BYTE_INDEX] = 1u;
      VStdMemCpy(workspace->ivPadded, iv, CRYPTO_30_HWA_AESGCM_IV_LENGTH_BYTES); /* PRQA S 0315 */ /* MD_MSR_VStdLibCopy */

      SchM_Enter_Crypto_30_Hwa_CRYPTO_30_HWA_EXCLUSIVE_AREA_1();
      retVal = Crypto_30_Hwa_Hw_AesGcmStart(workspace, key, CRYPTO_30_HWA_AES_KEY_SIZE, workspace->ivPadded, CRYPTO_30_HWA_AES_BLOCK_SIZE_BYTES);
      SchM_Exit_Crypto_30_Hwa_CRYPTO_30_HWA_EXCLUSIVE_AREA_1();
    }
  }

  return retVal;
} /* Crypto_30_Hwa_AesGcmStart() */

/**********************************************************************************************************************
 *  Crypto_30_Hwa_AesGcmUpdateAad()
 **********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 */
CRYPTO_30_HWA_LOCAL_INLINE FUNC(Std_ReturnType, CRYPTO_30_HWA_CODE) Crypto_30_Hwa_AesGcmUpdateAad(
  Crypto_30_Hwa_WorkSpaceGCM_PtrType workspace,
  P2CONST(uint8, AUTOMATIC, CRYPTO_30_HWA_APPL_DATA) inputPtr,
  uint32 inputLength)
{
  Std_ReturnType retVal = E_NOT_OK; /* PRQA S 2981 */ /* MD_MSR_RetVal */

  uint8 tempDataBufferInput[CRYPTO_30_HWA_AES_BLOCK_SIZE_BYTES] = { 0u };
  uint32 tempDataBufferInputLength;
  uint32 inputProcessed = 0u;
  uint32 blockCount;

  /* Calculate number of blocks */
  blockCount = CRYPTO_30_HWA_AES_BYTES_TO_BLOCKS(inputLength);

  if (blockCount > 0u)
  {
    /* Process blocks on hardware */
    retVal = Crypto_30_Hwa_AesGcmProcessBlocksAadSlicing(workspace, blockCount, inputPtr);
    inputProcessed = CRYPTO_30_HWA_AES_BLOCKS_TO_BYTES(blockCount);
  }

  /* Rest of Additional Authenticated Data (AAD) is not a full AES byte block, process with UpdateLastBlock-Function */
  if (inputProcessed < inputLength)
  {
    tempDataBufferInputLength = inputLength - inputProcessed;
    VStdLib_MemCpy(tempDataBufferInput, &inputPtr[inputProcessed], tempDataBufferInputLength); /* PRQA S 0315 */ /* MD_MSR_VStdLibCopy */

    SchM_Enter_Crypto_30_Hwa_CRYPTO_30_HWA_EXCLUSIVE_AREA_1();
    retVal = Crypto_30_Hwa_Hw_AesGcmProcessLastBlockAad(workspace, tempDataBufferInput, tempDataBufferInputLength);
    SchM_Exit_Crypto_30_Hwa_CRYPTO_30_HWA_EXCLUSIVE_AREA_1();
  }

  workspace->processedLengthAad = inputLength;

  return retVal;
} /* Crypto_30_Hwa_AesGcmUpdateAad() */

/**********************************************************************************************************************
 *  Crypto_30_Hwa_AesGcmUpdateInput()
 **********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
CRYPTO_30_HWA_LOCAL_INLINE FUNC(Std_ReturnType, CRYPTO_30_HWA_CODE) Crypto_30_Hwa_AesGcmUpdateInput(
  Crypto_30_Hwa_WorkSpaceGCM_PtrType workspace,
  P2CONST(uint8, AUTOMATIC, CRYPTO_30_HWA_APPL_DATA) inputPtr,
  uint32 inputLength,
  P2VAR(uint8, AUTOMATIC, CRYPTO_30_HWA_APPL_VAR) outputPtr,
  P2VAR(uint32, AUTOMATIC, CRYPTO_30_HWA_APPL_VAR) outputLengthPtr)
{
  Std_ReturnType retVal = E_OK; /* PRQA S 2981 */ /* MD_MSR_RetVal */

  uint32 inputProcessed = 0u;
  uint32 outputWritten = 0u;
  uint32 blockCount = CRYPTO_30_HWA_AES_BYTES_TO_BLOCKS(workspace->bufferFillLevel + inputLength - 1u);

  /* #10 Check if output buffer is sufficient for input that is going to be processed */
  if (*outputLengthPtr < CRYPTO_30_HWA_AES_BLOCKS_TO_BYTES(blockCount) )
  {
    retVal = E_NOT_OK;
  }
  else
  {
    /* #20 Process buffered data first if available */
    if ((workspace->bufferFillLevel > 0u) && (blockCount > 0u))
    {
      /* Complete buffer with input data */
      inputProcessed = (CRYPTO_30_HWA_AES_BLOCK_SIZE_BYTES - workspace->bufferFillLevel);
      if (inputProcessed > 0u)
      {
        VStdLib_MemCpy(&workspace->buffer[workspace->bufferFillLevel], inputPtr, inputProcessed); /* PRQA S 0315 */ /* MD_MSR_VStdLibCopy */
      }
      /* Push data to hardware */
      SchM_Enter_Crypto_30_Hwa_CRYPTO_30_HWA_EXCLUSIVE_AREA_1();
      retVal = Crypto_30_Hwa_Hw_AesGcmProcessBlocksInput(workspace, 1u, workspace->buffer, outputPtr);
      SchM_Exit_Crypto_30_Hwa_CRYPTO_30_HWA_EXCLUSIVE_AREA_1();
      blockCount--;
      workspace->bufferFillLevel = 0u;
      outputWritten = CRYPTO_30_HWA_AES_BLOCK_SIZE_BYTES;
    }

    if (blockCount > 0u)
    {
      /* #30 Process input data */
      retVal |= Crypto_30_Hwa_AesGcmProcessBlocksSlicing(workspace, blockCount, &inputPtr[inputProcessed], &outputPtr[outputWritten]);
      inputProcessed += CRYPTO_30_HWA_AES_BLOCKS_TO_BYTES(blockCount);
      outputWritten += CRYPTO_30_HWA_AES_BLOCKS_TO_BYTES(blockCount);
    }

    /* #40 Store remaining data buffer for later processing which is done either in next update step or in finish step for the final block */
    VStdLib_MemCpy(&(workspace->buffer[workspace->bufferFillLevel]), &inputPtr[inputProcessed], (inputLength - inputProcessed)); /* PRQA S 0315 */ /* MD_MSR_VStdLibCopy */
    workspace->bufferFillLevel += (inputLength - inputProcessed);

    workspace->processedLengthInput += outputWritten;
    *outputLengthPtr = outputWritten;
  }

  return retVal;
} /* Crypto_30_Hwa_AesGcmUpdateInput() */

/**********************************************************************************************************************
 *  Crypto_30_Hwa_AesGcmEncFinish()
 **********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
CRYPTO_30_HWA_LOCAL_INLINE FUNC(Std_ReturnType, CRYPTO_30_HWA_CODE) Crypto_30_Hwa_AesGcmEncFinish(
  Crypto_30_Hwa_WorkSpaceGCM_PtrType workspace,  /* PRQA S 3673 */ /* MD_MSR_Rule8.13 */
  P2VAR(uint8, AUTOMATIC, CRYPTO_30_HWA_APPL_VAR) outputPtr,
  P2VAR(uint32, AUTOMATIC, CRYPTO_30_HWA_APPL_VAR) outputLengthPtr,
  P2VAR(uint8, AUTOMATIC, CRYPTO_30_HWA_APPL_VAR) secondaryOutputPtr,
  P2VAR(uint32, AUTOMATIC, CRYPTO_30_HWA_APPL_VAR) secondaryOutputLengthPtr)
{
  Std_ReturnType retVal;

  /* Call platform specific Aes finish function */
    SchM_Enter_Crypto_30_Hwa_CRYPTO_30_HWA_EXCLUSIVE_AREA_1();
    retVal = Crypto_30_Hwa_Hw_AesGcmFinish(workspace,
                                      outputPtr,
                                      outputLengthPtr,
                                      secondaryOutputPtr,
                                      secondaryOutputLengthPtr,
                                      workspace->processedLengthAad,
                                      workspace->processedLengthInput,
                                      workspace->ivPadded);
    SchM_Exit_Crypto_30_Hwa_CRYPTO_30_HWA_EXCLUSIVE_AREA_1();

  return retVal;
} /* Crypto_30_Hwa_AesGcmEncFinish() */ /* PRQA S 6060 */ /* MD_MSR_STPAR */

/**********************************************************************************************************************
 *  Crypto_30_Hwa_AesGcmDecFinish()
 **********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 */
CRYPTO_30_HWA_LOCAL_INLINE FUNC(Std_ReturnType, CRYPTO_30_HWA_CODE) Crypto_30_Hwa_AesGcmDecFinish(
  Crypto_30_Hwa_WorkSpaceGCM_PtrType workspace,  /* PRQA S 3673 */ /* MD_MSR_Rule8.13 */
  P2CONST(uint8, AUTOMATIC, CRYPTO_30_HWA_APPL_DATA) tertiaryInputPtr,
  uint32 tertiaryInputLength,
  P2VAR(uint8, AUTOMATIC, CRYPTO_30_HWA_APPL_VAR) outputPtr,
  P2VAR(uint32, AUTOMATIC, CRYPTO_30_HWA_APPL_VAR) outputLengthPtr,
  P2VAR(uint8, AUTOMATIC, CRYPTO_30_HWA_APPL_VAR) verifyPtr)
{
  Std_ReturnType retVal;

  uint8 calculatedTag[16] = { 0u };
  uint32 calculatedTagLength = CRYPTO_30_HWA_AES_BLOCK_SIZE_BYTES;
  uint32 tertiaryInputLengthBit = tertiaryInputLength << 3u;

  /* Call platform specific Aes Gcm finish function */
  SchM_Enter_Crypto_30_Hwa_CRYPTO_30_HWA_EXCLUSIVE_AREA_1();
  retVal = Crypto_30_Hwa_Hw_AesGcmFinish(workspace,
                                    outputPtr,
                                    outputLengthPtr,
                                    calculatedTag,
                                    &calculatedTagLength,
                                    workspace->processedLengthAad,
                                    workspace->processedLengthInput,
                                    workspace->ivPadded);
  SchM_Exit_Crypto_30_Hwa_CRYPTO_30_HWA_EXCLUSIVE_AREA_1();

  /* Verify that the provided tag has the correct length */
  if (tertiaryInputLengthBit == CRYPTO_30_HWA_GHASH_TAG_SIZE_BIT)
  {
    /* Compare provided tag and calculated tag */
    *verifyPtr = Crypto_30_Hwa_MacCompare(tertiaryInputPtr, calculatedTag, tertiaryInputLengthBit);
  }
  else
  {
    retVal = E_NOT_OK;
  }

  return retVal;
} /* Crypto_30_Hwa_AesGcmDecFinish() */ /* PRQA S 6060 */ /* MD_MSR_STPAR */
#endif /* (CRYPTO_30_HWA_PRIMITIVE_AES_GCM == STD_ON) */

#if (CRYPTO_30_HWA_PRIMITIVE_AES_GCMSIV == STD_ON) /* COV_CRYPTO_30_HWA_HARDWARE_DEPENDENT_FEATURE */
/**********************************************************************************************************************
 *  Crypto_30_Hwa_XOR()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
CRYPTO_30_HWA_LOCAL_INLINE FUNC(void, CRYPTO_30_HWA_CODE) Crypto_30_Hwa_XOR(
  P2VAR(uint8, AUTOMATIC, CRYPTO_30_HWA_APPL_VAR) buf1,
  P2CONST(uint8, AUTOMATIC, CRYPTO_30_HWA_APPL_DATA) buf2,
  uint32 count)
{
  uint32_least i = count;
  while (i > 0u)
  {
    --i;
    /* XOR (buf1 ^= buf2) */
    buf1[i] ^= buf2[i];
  }
}

/**********************************************************************************************************************
 *  Crypto_30_Hwa_CpyU32toBE()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
CRYPTO_30_HWA_LOCAL_INLINE FUNC(void, CRYPTO_30_HWA_CODE) Crypto_30_Hwa_CpyU32toBE(
  P2VAR(uint8, AUTOMATIC, CRYPTO_30_HWA_APPL_VAR) tgt,
  P2CONST(uint32, AUTOMATIC, CRYPTO_30_HWA_APPL_DATA)src,
  const uint32 length)
{
  uint32_least i;

  for (i = 0u; i < length; i++)
  {
    /* PRQA S 2985 4 */ /* MD_CRYPTO_30_HWA_2985_REDUNDANT_OP */
    tgt[(i*4u) + 0u] = (uint8)(src[i] >> 24u);
    tgt[(i*4u) + 1u] = (uint8)(src[i] >> 16u);
    tgt[(i*4u) + 2u] = (uint8)(src[i] >> 8u);
    tgt[(i*4u) + 3u] = (uint8)src[i];
  }
}

/**********************************************************************************************************************
 *  Crypto_30_Hwa_CpyBEtoU32()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
CRYPTO_30_HWA_LOCAL_INLINE FUNC(void, CRYPTO_30_HWA_CODE) Crypto_30_Hwa_CpyBEtoU32(
  P2VAR(uint32, AUTOMATIC, CRYPTO_30_HWA_APPL_VAR) tgt,
  P2CONST(uint8, AUTOMATIC, CRYPTO_30_HWA_APPL_DATA) src,
  const uint32 length)
{
  uint32_least  i;

  for (i = 0u; i < (length / 4u); i++)
  {
    /* PRQA S 2985 4 */ /* MD_CRYPTO_30_HWA_2985_REDUNDANT_OP */
    tgt[i]  = ((uint32)src[(i*4u) + 0u]) << 24u;
    tgt[i] |= ((uint32)src[(i*4u) + 1u]) << 16u;
    tgt[i] |= ((uint32)src[(i*4u) + 2u]) << 8u;
    tgt[i] |= ((uint32)src[(i*4u) + 3u]);
  }
}

/**********************************************************************************************************************
 *  Crypto_30_Hwa_AddInputToPolyval()
 **********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 */
CRYPTO_30_HWA_LOCAL FUNC(void, CRYPTO_30_HWA_CODE) Crypto_30_Hwa_AddInputToPolyval(
  Crypto_30_Hwa_WorkSpaceGCMSIV_PtrType workspace,
  P2CONST(uint8, AUTOMATIC, CRYPTO_30_HWA_APPL_DATA) inputPtr,
  uint32 inputLength)
{
  uint8_least index;
  uint8 tmp[CRYPTO_30_HWA_AES_BLOCK_SIZE_BYTES] = { 0u };
  uint32 blocks = inputLength / CRYPTO_30_HWA_AES_BLOCK_SIZE_BYTES;

  /* #10 Split input in AES block sizes */
  for (index = 0; index < blocks; index++)
  {
    /* #11 Forward each block to polyval calculation */
    Crypto_30_Hwa_PolyvalUpdate(&workspace->polyvalStruct, &inputPtr[index*CRYPTO_30_HWA_AES_BLOCK_SIZE_BYTES], CRYPTO_30_HWA_AES_BLOCK_SIZE_BYTES);
  }

  /* #12 If last block is smaller than AES block size, pad input with zeros and forward to polyval calculation */
  if ((blocks * CRYPTO_30_HWA_AES_BLOCK_SIZE_BYTES) < inputLength)
  {
    VStdMemCpy(tmp, &inputPtr[blocks * CRYPTO_30_HWA_AES_BLOCK_SIZE_BYTES], (inputLength - (blocks * CRYPTO_30_HWA_AES_BLOCK_SIZE_BYTES))); /* PRQA S 0315 */ /* MD_MSR_VStdLibCopy */

    /* #13 Forward last block to polyval calculation */
    Crypto_30_Hwa_PolyvalUpdate(&workspace->polyvalStruct, tmp, CRYPTO_30_HWA_AES_BLOCK_SIZE_BYTES);
  }
}

/**********************************************************************************************************************
 *  Crypto_30_Hwa_Gf128Zero()
 **********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
CRYPTO_30_HWA_LOCAL FUNC(void, CRYPTO_30_HWA_CODE) Crypto_30_Hwa_Gf128Zero(P2VAR(uint32, AUTOMATIC, CRYPTO_30_HWA_APPL_VAR) Z)
{
  Z[3] = 0;
  Z[2] = 0;
  Z[1] = 0;
  Z[0] = 0;
}

/**********************************************************************************************************************
 *  Crypto_30_Hwa_Gf128Add()
 **********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
CRYPTO_30_HWA_LOCAL FUNC(void, CRYPTO_30_HWA_CODE) Crypto_30_Hwa_Gf128Add(
   P2VAR(uint32, AUTOMATIC, CRYPTO_30_HWA_APPL_VAR) Z,
   P2CONST(uint32, AUTOMATIC, CRYPTO_30_HWA_APPL_DATA) X,
   P2CONST(uint32, AUTOMATIC, CRYPTO_30_HWA_APPL_DATA) Y)
{
  Z[3] = X[3] ^ Y[3];
  Z[2] = X[2] ^ Y[2];
  Z[1] = X[1] ^ Y[1];
  Z[0] = X[0] ^ Y[0];
}

/**********************************************************************************************************************
 *  Crypto_30_Hwa_Gf128Rightshift_4()
 **********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 */
CRYPTO_30_HWA_LOCAL FUNC(uint8, CRYPTO_30_HWA_CODE) Crypto_30_Hwa_Gf128Rightshift_4(P2VAR(uint32, AUTOMATIC, CRYPTO_30_HWA_APPL_VAR) block)
{
  uint8 v = (uint8)(block[CRYPTO_30_HWA_GHASH_WORDS_PER_BLOCK - 1u] & 0xFu);

   /* Right-shift the given block by 4 bit positions.
    * Do not reduce, but return the bits that were shifted out! */
   block[3] = (block[3] >> 4) | ((block[2] & 0xFuL) << 28);
   block[2] = (block[2] >> 4) | ((block[1] & 0xFuL) << 28);
   block[1] = (block[1] >> 4) | ((block[0] & 0xFuL) << 28);
   block[0] >>= 4;

   return v;
}

/**********************************************************************************************************************
 *  Crypto_30_Hwa_GF128Mul()
 **********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 */
CRYPTO_30_HWA_LOCAL_INLINE FUNC(void, CRYPTO_30_HWA_CODE) Crypto_30_Hwa_GF128Mul(
  P2CONST(Crypto_30_Hwa_GhashStruct, AUTOMATIC, CRYPTO_30_HWA_APPL_DATA) info,
   P2VAR(uint32, AUTOMATIC, CRYPTO_30_HWA_APPL_VAR) Z,
   P2CONST(uint8, AUTOMATIC, CRYPTO_30_HWA_APPL_DATA) X)
{
  uint8 i;
  uint8 X_i, A;

  /* Z = 0 */
  Crypto_30_Hwa_Gf128Zero(Z);

  i = CRYPTO_30_HWA_GHASH_BLOCK_SIZE;
  do /* loop over X: MSB ... LSB */
  {
    /* next byte */
    i--;
    X_i = X[i];

    /* Z *= 16 */
    A = Crypto_30_Hwa_Gf128Rightshift_4(Z);
    /* handle carry bits */
    Z [0] ^= (((uint32) R2 [A]) << 16);
    /* Z += (X * (4 MSbits)) */
    Crypto_30_Hwa_Gf128Add(Z, Z, info->M [X_i & 0xfu]);

    /* Z *= 16 */
    A = Crypto_30_Hwa_Gf128Rightshift_4(Z);
    /* handle carry bits */
    Z [0] ^= (((uint32) R2 [A]) << 16);
    /* Z += (X * (4 next bits)) */
    Crypto_30_Hwa_Gf128Add(Z, Z, info->M [X_i >> 4]);
  } while (i > 0u);
}

/**********************************************************************************************************************
 *  Crypto_30_Hwa_MulXGHash()
 **********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 */
CRYPTO_30_HWA_LOCAL FUNC(void, CRYPTO_30_HWA_CODE) Crypto_30_Hwa_MulXGHash(
  P2VAR(uint32, AUTOMATIC, CRYPTO_30_HWA_APPL_VAR) Z,
  P2CONST(uint32, AUTOMATIC, CRYPTO_30_HWA_APPL_DATA) X)
{
  uint8 carry = (uint8)(X[3] & 1uL);

  Z[3] = (X[3] >> 1) | ((X[2] & 1uL) << 31);
  Z[2] = (X[2] >> 1) | ((X[1] & 1uL) << 31);
  Z[1] = (X[1] >> 1) | ((X[0] & 1uL) << 31);
  Z[0] = (X[0] >> 1);
  if (carry > 0u)
  {
    Z[0] ^= CRYPTO_30_HWA_GF128POLY;
  }
}

/**********************************************************************************************************************
 *  Crypto_30_Hwa_GHashTransformBlock()
 **********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 */
CRYPTO_30_HWA_LOCAL_INLINE FUNC(void, CRYPTO_30_HWA_CODE) Crypto_30_Hwa_GHashTransformBlock(
   P2VAR(Crypto_30_Hwa_GhashStruct, AUTOMATIC, CRYPTO_30_HWA_APPL_VAR) info,
   P2CONST(uint8, AUTOMATIC, CRYPTO_30_HWA_APPL_DATA) X)
{
  uint32 tmpY[CRYPTO_30_HWA_GHASH_WORDS_PER_BLOCK];

  /* Y_i = Y_i-1 XOR X_i */
  Crypto_30_Hwa_XOR(info->Y, X, CRYPTO_30_HWA_GHASH_BLOCK_SIZE);
  /* Y_i = Y_i * H */
  Crypto_30_Hwa_GF128Mul(info, tmpY, info->Y);

  /* Convert uint32 to uint8 and store internally */
  Crypto_30_Hwa_CpyU32toBE(info->Y, tmpY, CRYPTO_30_HWA_GHASH_WORDS_PER_BLOCK);
}

/**********************************************************************************************************************
 *  Crypto_30_Hwa_GHashReset()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
CRYPTO_30_HWA_LOCAL_INLINE FUNC(Std_ReturnType, CRYPTO_30_HWA_CODE) Crypto_30_Hwa_GHashReset(
  P2VAR(Crypto_30_Hwa_GhashStruct, AUTOMATIC, CRYPTO_30_HWA_APPL_VAR) info)
{
  /* Y = 0^128 */
  VStdMemSet(info->Y, 0, CRYPTO_30_HWA_GHASH_BLOCK_SIZE);  /* PRQA S 0315 */ /* MD_MSR_VStdLibCopy */

  info->buffer_used = 0;

  return E_OK;
}

/**********************************************************************************************************************
 *  Crypto_30_Hwa_GHashInit()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 */
CRYPTO_30_HWA_LOCAL_INLINE FUNC(Std_ReturnType, CRYPTO_30_HWA_CODE) Crypto_30_Hwa_GHashInit(
   P2VAR(Crypto_30_Hwa_GhashStruct, AUTOMATIC, CRYPTO_30_HWA_APPL_VAR) info,
   P2CONST(uint8, AUTOMATIC, CRYPTO_30_HWA_APPL_DATA) H)
{
  uint16 i, j;

   /* Store the subkey internally. */
   Crypto_30_Hwa_CpyBEtoU32(info->H, H, CRYPTO_30_HWA_GHASH_BLOCK_SIZE);

   /* Algorithm 3 from the paper for pre-computing the lookup-table */
   /* somewhat awkward indexing, as the bit-order of the index is inverted (little-endian) */
   /* must be adhered to for the powers of two only, because an addition is just an XOR! */
   Crypto_30_Hwa_Gf128Zero(info->M [0]);
   Crypto_30_Hwa_CpyBEtoU32(info->M [8], H, CRYPTO_30_HWA_GHASH_BLOCK_SIZE);

   /* Powers of 2 by shifting */
   for (i = 4u; i > 0u; i /= 2u)
   {
      Crypto_30_Hwa_MulXGHash(info->M[i], info->M[2u * i]);
   }
   /* Compose the rest by adding */
   for (i = 2u; i <= 8u; i = (uint16)(i * 2u))
   {
      for (j = 1u; j < i; j++)
      {
        Crypto_30_Hwa_Gf128Add(info->M[i+j], info->M[i], info->M[j]);
      }
   }

  return Crypto_30_Hwa_GHashReset(info);
}

/**********************************************************************************************************************
 *  Crypto_30_Hwa_ByteReverse()
 **********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
CRYPTO_30_HWA_LOCAL FUNC(void, CRYPTO_30_HWA_CODE) Crypto_30_Hwa_ByteReverse(
  P2VAR(uint8, AUTOMATIC, CRYPTO_30_HWA_APPL_VAR) out,
  P2CONST(uint8, AUTOMATIC, CRYPTO_30_HWA_APPL_DATA) in,
  uint32 in_len)
{
  uint32_least i;

  for (i = 0u; i < in_len; i++)
  {
    out[i] = in[in_len - (i+1u)];
  }
}

/**********************************************************************************************************************
 *  Crypto_30_Hwa_PolyvalInit()
 **********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 */
CRYPTO_30_HWA_LOCAL_INLINE FUNC(Std_ReturnType, CRYPTO_30_HWA_CODE) Crypto_30_Hwa_PolyvalInit(
  P2VAR(Crypto_30_Hwa_PolyvalStruct, AUTOMATIC, CRYPTO_30_HWA_APPL_VAR) info,
  P2CONST(uint8, AUTOMATIC, CRYPTO_30_HWA_APPL_DATA) key)
{
  /* #10 Reverse byte order of MAC key, copy to uint32 array */
  Crypto_30_Hwa_ByteReverse(info->tmp, key, CRYPTO_30_HWA_GHASH_BLOCK_SIZE);
  Crypto_30_Hwa_CpyBEtoU32(info->fieldElement1, info->tmp, 16);

  /* #11 Compute mulx_GHash(reversed MAC key), copy result to uint8 array */
  Crypto_30_Hwa_MulXGHash(info->fieldElement2, info->fieldElement1);
  Crypto_30_Hwa_CpyU32toBE(info->tmp, info->fieldElement2, 4);

  /* #12 Initialize GHash with the reversed and multiplied MAC key */
  return Crypto_30_Hwa_GHashInit(&info->wsGHash, info->tmp);
}

/**********************************************************************************************************************
 *  Crypto_30_Hwa_PolyvalUpdate()
 **********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 */
CRYPTO_30_HWA_LOCAL FUNC(void, CRYPTO_30_HWA_CODE) Crypto_30_Hwa_PolyvalUpdate(
  P2VAR(Crypto_30_Hwa_PolyvalStruct, AUTOMATIC, CRYPTO_30_HWA_APPL_VAR) info,
  P2CONST(uint8, AUTOMATIC, CRYPTO_30_HWA_APPL_DATA) input,
  uint32 input_len)
{
  /* #10 Check if input length is equal to GHASH block size */
  if (input_len == CRYPTO_30_HWA_GHASH_BLOCK_SIZE)
  {
    /* #11 Reverses the byte order of a 16-byte input block. */
    Crypto_30_Hwa_ByteReverse(info->tmp, input, CRYPTO_30_HWA_GHASH_BLOCK_SIZE);

    /* #12 Passes reversed block to Crypto_30_Hwa_GHashUpdate */
    Crypto_30_Hwa_GHashTransformBlock(&info->wsGHash, info->tmp);
  }
}

/**********************************************************************************************************************
 *  Crypto_30_Hwa_PolyvalFinalize()
 **********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 */
CRYPTO_30_HWA_LOCAL FUNC(void, CRYPTO_30_HWA_CODE) Crypto_30_Hwa_PolyvalFinalize(
  P2VAR(Crypto_30_Hwa_PolyvalStruct, AUTOMATIC, CRYPTO_30_HWA_APPL_VAR) info,
  P2VAR(uint8, AUTOMATIC, CRYPTO_30_HWA_APPL_VAR) output)
{
  /* #10 Copy GHASH value from workspace */
  VStdMemCpy(info->tmp, info->wsGHash.Y, CRYPTO_30_HWA_GHASH_BLOCK_SIZE); /* PRQA S 0315 */ /* MD_MSR_VStdLibCopy */

  /* #11 Reverses the byte order of GHASH value and copy into output variable */
  Crypto_30_Hwa_ByteReverse(output, info->tmp, CRYPTO_30_HWA_GHASH_BLOCK_SIZE);
}

/**********************************************************************************************************************
 *  Crypto_30_Hwa_CalculateLengthBlock()
 **********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 */
CRYPTO_30_HWA_LOCAL FUNC(void, CRYPTO_30_HWA_CODE) Crypto_30_Hwa_CalculateLengthBlock(
  uint32 secondaryInputLength,
  uint32 inputLength,
  P2VAR(uint8, AUTOMATIC, CRYPTO_30_HWA_APPL_VAR) lengthBlock)
{
  /* Calculate length of additional authenticated data in bits and copy to little endian array */
  Crypto_30_Hwa_Uint32ToArray((secondaryInputLength << 3), lengthBlock);

  /* Calculate length of plain- or ciphertext in bits and copy to little endian array */
  Crypto_30_Hwa_Uint32ToArray((inputLength << 3), &lengthBlock[8u]);
}

/**********************************************************************************************************************
 *  Crypto_30_Hwa_AesGcmSivStart()
 **********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 */
CRYPTO_30_HWA_LOCAL_INLINE FUNC(Std_ReturnType, CRYPTO_30_HWA_CODE) Crypto_30_Hwa_AesGcmSivStart(
  Crypto_30_Hwa_WorkSpaceGCMSIV_PtrType workspace,
  uint32 cryptoKeyId)
{
  Std_ReturnType retVal = E_OK; /* PRQA S 2981 */ /* MD_MSR_RetVal */
  vHsm_Api_KeyStorageIndexType index = 0;

  P2CONST(uint8, AUTOMATIC, CRYPTO_30_HWA_APPL_DATA) key = NULL_PTR; /* PRQA S 2981 */ /* MD_CRYPTO_30_HWA_2981_REDUNDANT_INITIALIZATION */
  P2CONST(uint8, AUTOMATIC, CRYPTO_30_HWA_APPL_DATA) iv;

  uint32 ivKeyId = cryptoKeyId;

  /* Init workspace */
  workspace->cryptoKeyId = cryptoKeyId;

#if (CRYPTO_30_HWA_ROMKEY == STD_ON) /* COV_CRYPTO_30_HWA_HARDWARE_DEPENDENT_FEATURE */
  workspace->romKeyMapIndex = 0;

  Crypto_30_Hwa_CheckRomKeyUsage(workspace->cryptoKeyId, &workspace->romKeyMapIndex);

  /* Verify if provided key is ROM_Key */
  if (workspace->romKeyMapIndex == CRYPTO_30_HWA_ROMKEY_USE_IMPORTED_KEY)
#endif /* (CRYPTO_30_HWA_ROMKEY == STD_ON) */
  {
    /* Get AES key */
    retVal = vHsm_Api_KeyElementGetForCryptoJobs(cryptoKeyId, CRYPTO_KE_CIPHER_KEY,
      &index, CRYPTO_30_HWA_AES_KEY_SIZE, VHSM_API_SHE_SERVICE_ENCRYPT_DECRYPT);

    if (retVal == E_OK)
    {
      key = vHsm_Api_GetAddrKeyStorage(index);
    }
  }

  if(retVal == E_OK)
  {
    /* Get IV */
#if (CRYPTO_30_HWA_ROMKEY == STD_ON) /* COV_CRYPTO_30_HWA_HARDWARE_DEPENDENT_FEATURE */
    index = 0u;
    if (workspace->romKeyMapIndex != CRYPTO_30_HWA_ROMKEY_USE_IMPORTED_KEY)
    {
      ivKeyId = Crypto_30_Hwa_GetAggregatedCryptoKeyIdOfKeyMap(workspace->romKeyMapIndex);
    }
#endif /* (CRYPTO_30_HWA_ROMKEY == STD_ON) */

    retVal = vHsm_Api_KeyElementGetForCryptoJobs(ivKeyId,
      CRYPTO_KE_CIPHER_IV, &index, CRYPTO_30_HWA_AESGCM_IV_LENGTH_BYTES, VHSM_API_SHE_SERVICE_ENCRYPT_DECRYPT);

    if (retVal == E_OK)
    {
      iv = vHsm_Api_GetAddrKeyStorage(index);

      /* Copy IV for later use */
      VStdMemCpy(workspace->nonce, iv, CRYPTO_30_HWA_AESGCM_IV_LENGTH_BYTES); /* PRQA S 0315 */ /* MD_MSR_VStdLibCopy */

      /* Call platform specific AES GCM START start function for key derivation */
      SchM_Enter_Crypto_30_Hwa_CRYPTO_30_HWA_EXCLUSIVE_AREA_1();
      retVal = Crypto_30_Hwa_Hw_AesGcmSivStart(workspace, key, CRYPTO_30_HWA_AES_KEY_SIZE, iv, CRYPTO_30_HWA_AESGCM_IV_LENGTH_BYTES);
      SchM_Exit_Crypto_30_Hwa_CRYPTO_30_HWA_EXCLUSIVE_AREA_1();

      /* Initialize polyval calculation with derived GHASH key */
      retVal |= Crypto_30_Hwa_PolyvalInit(&workspace->polyvalStruct, workspace->keyAuth);
    }
  }

  return retVal;
} /* Crypto_30_Hwa_AesGcmSivStart() */

/**********************************************************************************************************************
 *  Crypto_30_Hwa_AesGcmSivEncUpdate()
 **********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
CRYPTO_30_HWA_LOCAL_INLINE FUNC(Std_ReturnType, CRYPTO_30_HWA_CODE) Crypto_30_Hwa_AesGcmSivEncUpdate(
  Crypto_30_Hwa_WorkSpaceGCMSIV_PtrType workspace,
  P2CONST(uint8, AUTOMATIC, CRYPTO_30_HWA_APPL_DATA) inputPtr,
  uint32 inputLength,
  P2CONST(uint8, AUTOMATIC, CRYPTO_30_HWA_APPL_DATA) secondaryInputPtr,
  uint32 secondaryInputLength,
  P2VAR(uint8, AUTOMATIC, CRYPTO_30_HWA_APPL_VAR) outputPtr,
  P2VAR(uint32, AUTOMATIC, CRYPTO_30_HWA_APPL_VAR) outputLengthPtr)
{
  Std_ReturnType retVal; /* PRQA S 2981 */ /* MD_MSR_RetVal */

  uint8 lengthBlock[16] = { 0u };
  uint8_least index;
  uint8 tmp[CRYPTO_30_HWA_AES_BLOCK_SIZE_BYTES] = { 0u };
  uint32 blocks = inputLength / CRYPTO_30_HWA_AES_BLOCK_SIZE_BYTES;

  /* #10 Check if output buffer is sufficient for input which is going to be processed */
  if (*outputLengthPtr < inputLength )
  {
    retVal = E_NOT_OK;
  }
  else
  {
    /* #11 Reset output length value */
    *outputLengthPtr = 0;

    if (secondaryInputLength == 0u)
    {
      /* No AAD provided. */
      retVal = E_OK;
    }
    else if (secondaryInputPtr == NULL_PTR)
    {
      /* AAD is provided but pointer is not set. */
      retVal = E_NOT_OK;
    }
    else
    {
      /* #12 Add additional authenticated data to polyval calculation */
      Crypto_30_Hwa_AddInputToPolyval(workspace, secondaryInputPtr, secondaryInputLength);
      retVal = E_OK;
    }

    if (retVal == E_OK)
    {
      /* #13 Add plaintext to polyval calculation */
      Crypto_30_Hwa_AddInputToPolyval(workspace, inputPtr, inputLength);

      /* #14 Calculate length values */
      Crypto_30_Hwa_CalculateLengthBlock(secondaryInputLength, inputLength, lengthBlock);

      /* #15 Add length block to polyval calculation */
      Crypto_30_Hwa_AddInputToPolyval(workspace, lengthBlock, CRYPTO_30_HWA_AES_BLOCK_SIZE_BYTES);

      /* #16 Finalize polyval calculation */
      Crypto_30_Hwa_PolyvalFinalize(&workspace->polyvalStruct, workspace->tag);

      /* #17 Finalize tag calculation */
      SchM_Enter_Crypto_30_Hwa_CRYPTO_30_HWA_EXCLUSIVE_AREA_1();
      retVal = Crypto_30_Hwa_Hw_AesGcmSivTagFinalize(workspace);
      SchM_Exit_Crypto_30_Hwa_CRYPTO_30_HWA_EXCLUSIVE_AREA_1();
    }

    if (retVal == E_OK)
    {
      /* #20 Prepare IV for encryption */
      VStdMemCpy(tmp, workspace->tag, CRYPTO_30_HWA_AES_BLOCK_SIZE_BYTES); /* PRQA S 0315 */ /* MD_MSR_VStdLibCopy */

      tmp[CRYPTO_30_HWA_AES_BLOCK_SIZE_BYTES -1u] |= CRYPTO_30_HWA_AES_GCM_SIV_NONCE_MASK;

      VStdMemCpy(workspace->counterCtr, tmp, CRYPTO_30_HWA_AES_BLOCK_SIZE_BYTES); /* PRQA S 0315 */ /* MD_MSR_VStdLibCopy */

      /* #21 Initialize AES CTR encryption */
      SchM_Enter_Crypto_30_Hwa_CRYPTO_30_HWA_EXCLUSIVE_AREA_1();
      retVal = Crypto_30_Hwa_Hw_AesGcmSivAesCtrCryptionInit(workspace);
      SchM_Exit_Crypto_30_Hwa_CRYPTO_30_HWA_EXCLUSIVE_AREA_1();
    }

    if (retVal == E_OK)
    {
      /* #22 Split plaintext into AES blocks */
      for (index = 0; index < blocks; index++)
      {
        /* #23 Add one block to encryption */
        SchM_Enter_Crypto_30_Hwa_CRYPTO_30_HWA_EXCLUSIVE_AREA_1();
        retVal |= Crypto_30_Hwa_Hw_AesGcmSivAesCtrCryptionUpdate(workspace, &inputPtr[index * CRYPTO_30_HWA_AES_BLOCK_SIZE_BYTES], CRYPTO_30_HWA_AES_BLOCK_SIZE_BYTES,
          &outputPtr[index * CRYPTO_30_HWA_AES_BLOCK_SIZE_BYTES], outputLengthPtr);
        SchM_Exit_Crypto_30_Hwa_CRYPTO_30_HWA_EXCLUSIVE_AREA_1();
      }

      /* #24 Add remaining input to encryption */
      if ((blocks * CRYPTO_30_HWA_AES_BLOCK_SIZE_BYTES) < inputLength)
      {
        SchM_Enter_Crypto_30_Hwa_CRYPTO_30_HWA_EXCLUSIVE_AREA_1();
        retVal |= Crypto_30_Hwa_Hw_AesGcmSivAesCtrCryptionUpdate(workspace, &inputPtr[blocks * CRYPTO_30_HWA_AES_BLOCK_SIZE_BYTES], (inputLength - (blocks * CRYPTO_30_HWA_AES_BLOCK_SIZE_BYTES)),
          &outputPtr[blocks * CRYPTO_30_HWA_AES_BLOCK_SIZE_BYTES], outputLengthPtr);
        SchM_Exit_Crypto_30_Hwa_CRYPTO_30_HWA_EXCLUSIVE_AREA_1();
      }
    }
  }

  return retVal;
} /* Crypto_30_Hwa_AesGcmSivEncUpdate() */ /* PRQA S 6050, 6060 */ /* MD_MSR_STCAL, MD_MSR_STPAR */

/**********************************************************************************************************************
 *  Crypto_30_Hwa_AesGcmSivEncFinish()
 **********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 */
CRYPTO_30_HWA_LOCAL_INLINE FUNC(Std_ReturnType, CRYPTO_30_HWA_CODE) Crypto_30_Hwa_AesGcmSivEncFinish(
  Crypto_30_Hwa_WorkSpaceGCMSIV_PtrType workspace,  /* PRQA S 3673 */ /* MD_MSR_Rule8.13 */
  P2VAR(uint8, AUTOMATIC, CRYPTO_30_HWA_APPL_VAR) secondaryOutputPtr,
  P2VAR(uint32, AUTOMATIC, CRYPTO_30_HWA_APPL_VAR) secondaryOutputLengthPtr)
{
  Std_ReturnType retVal = E_NOT_OK;

  /* #10 Check if output buffer is sufficient for tag */
  if (*secondaryOutputLengthPtr >= CRYPTO_30_HWA_AES_BLOCK_SIZE_BYTES)
  {
    /* #11 Copy tag to output buffer */
    VStdMemCpy(secondaryOutputPtr, workspace->tag, CRYPTO_30_HWA_AES_BLOCK_SIZE_BYTES); /* PRQA S 0315 */ /* MD_MSR_VStdLibCopy */
    *secondaryOutputLengthPtr = CRYPTO_30_HWA_AES_BLOCK_SIZE_BYTES;

    retVal = E_OK;
  }

  return retVal;
} /* Crypto_30_Hwa_AesGcmSivEncFinish() */

/**********************************************************************************************************************
 *  Crypto_30_Hwa_AesGcmSivDecUpdate()
 **********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
CRYPTO_30_HWA_LOCAL_INLINE FUNC(Std_ReturnType, CRYPTO_30_HWA_CODE) Crypto_30_Hwa_AesGcmSivDecUpdate(
  Crypto_30_Hwa_WorkSpaceGCMSIV_PtrType workspace,
  P2CONST(uint8, AUTOMATIC, CRYPTO_30_HWA_APPL_DATA) inputPtr,
  uint32 inputLength,
  P2CONST(uint8, AUTOMATIC, CRYPTO_30_HWA_APPL_DATA) secondaryInputPtr,
  uint32 secondaryInputLength,
  P2CONST(uint8, AUTOMATIC, CRYPTO_30_HWA_APPL_DATA) tertiaryInputPtr,
  uint32 tertiaryInputLength,
  P2VAR(uint8, AUTOMATIC, CRYPTO_30_HWA_APPL_VAR) outputPtr,
  P2VAR(uint32, AUTOMATIC, CRYPTO_30_HWA_APPL_VAR) outputLengthPtr)
{
  Std_ReturnType retVal; /* PRQA S 2981 */ /* MD_MSR_RetVal */

  uint8 lengthBlock[16] = { 0u };
  uint8_least index;
  uint32 blocks = inputLength / CRYPTO_30_HWA_AES_BLOCK_SIZE_BYTES;

  /* #10 Check if output buffer is sufficient for input which is going to be processed */
  if (*outputLengthPtr < inputLength )
  {
    retVal = E_NOT_OK;
  }
  /* #11 Check if tag has the correct length */
  else if ((tertiaryInputLength << 3) != CRYPTO_30_HWA_GHASH_TAG_SIZE_BIT)
  {
    retVal = E_NOT_OK;
  }
  else
  {
    /* #12 Reset output length value */
    *outputLengthPtr = 0;

    /* #13 Prepare IV for decryption */
    VStdMemCpy(workspace->counterCtr, tertiaryInputPtr, CRYPTO_30_HWA_AES_BLOCK_SIZE_BYTES);  /* PRQA S 0315 */ /* MD_MSR_VStdLibCopy */

    workspace->counterCtr[CRYPTO_30_HWA_AES_BLOCK_SIZE_BYTES - 1u] |= CRYPTO_30_HWA_AES_GCM_SIV_NONCE_MASK;

    /* #14 Initialize AES CTR decryption */
    SchM_Enter_Crypto_30_Hwa_CRYPTO_30_HWA_EXCLUSIVE_AREA_1();
    retVal = Crypto_30_Hwa_Hw_AesGcmSivAesCtrCryptionInit(workspace);
    SchM_Exit_Crypto_30_Hwa_CRYPTO_30_HWA_EXCLUSIVE_AREA_1();

    if (retVal == E_OK)
    {
      /* #15 Split ciphertext into AES blocks */
      for (index = 0; index < blocks; index++)
      {
        /* #16 Add one block to decryption */
        SchM_Enter_Crypto_30_Hwa_CRYPTO_30_HWA_EXCLUSIVE_AREA_1();
        retVal |= Crypto_30_Hwa_Hw_AesGcmSivAesCtrCryptionUpdate(workspace,
          &inputPtr[index * CRYPTO_30_HWA_AES_BLOCK_SIZE_BYTES], CRYPTO_30_HWA_AES_BLOCK_SIZE_BYTES,
          &outputPtr[index * CRYPTO_30_HWA_AES_BLOCK_SIZE_BYTES], outputLengthPtr);
        SchM_Exit_Crypto_30_Hwa_CRYPTO_30_HWA_EXCLUSIVE_AREA_1();
      }

      /* #17 Add remaining input to decryption */
      if ((blocks * CRYPTO_30_HWA_AES_BLOCK_SIZE_BYTES) < inputLength)
      {
        SchM_Enter_Crypto_30_Hwa_CRYPTO_30_HWA_EXCLUSIVE_AREA_1();
        retVal |= Crypto_30_Hwa_Hw_AesGcmSivAesCtrCryptionUpdate(workspace, &inputPtr[blocks * CRYPTO_30_HWA_AES_BLOCK_SIZE_BYTES], (inputLength - (blocks * CRYPTO_30_HWA_AES_BLOCK_SIZE_BYTES)), &outputPtr[blocks * CRYPTO_30_HWA_AES_BLOCK_SIZE_BYTES], outputLengthPtr);
        SchM_Exit_Crypto_30_Hwa_CRYPTO_30_HWA_EXCLUSIVE_AREA_1();
      }
    }

    if (retVal == E_OK)
    {
      if (secondaryInputLength == 0u)
      {
        /* No AAD provided. */
      }
      else if (secondaryInputPtr == NULL_PTR)
      {
        /* AAD is provided but pointer is not set. */
        retVal = E_NOT_OK;
      }
      else
      {
        /* #20 Add additional authenticated data to polyval calculation */
        Crypto_30_Hwa_AddInputToPolyval(workspace, secondaryInputPtr, secondaryInputLength);
      }

      if (retVal == E_OK)
      {
        /* #21 Add plaintext to polyval calculation */
        Crypto_30_Hwa_AddInputToPolyval(workspace, outputPtr, *outputLengthPtr);

        /* #22 Calculate length values */
        Crypto_30_Hwa_CalculateLengthBlock(secondaryInputLength, inputLength, lengthBlock);

        /* #23 Add length block to polyval calculation */
        Crypto_30_Hwa_AddInputToPolyval(workspace, lengthBlock, CRYPTO_30_HWA_AES_BLOCK_SIZE_BYTES);

        /* #24 Finalize polyval calculation */
        Crypto_30_Hwa_PolyvalFinalize(&workspace->polyvalStruct, workspace->tag);

        /* #25 Finalize tag calculation */
        SchM_Enter_Crypto_30_Hwa_CRYPTO_30_HWA_EXCLUSIVE_AREA_1();
        retVal = Crypto_30_Hwa_Hw_AesGcmSivTagFinalize(workspace);
        SchM_Exit_Crypto_30_Hwa_CRYPTO_30_HWA_EXCLUSIVE_AREA_1();
      }

      if (retVal == E_OK)
      {
        /* #26 Compare calculated tag with provided tag */
        workspace->verify = Crypto_30_Hwa_MacCompare(tertiaryInputPtr, workspace->tag, CRYPTO_30_HWA_GHASH_TAG_SIZE_BIT);
      }
    }
  }

  return retVal;
} /* Crypto_30_Hwa_AesGcmSivDecUpdate() */ /* PRQA S 6030, 6050, 6060, 6080 */ /* MD_MSR_STCYC, MD_MSR_STCAL, MD_MSR_STPAR, MD_MSR_STMIF */

/**********************************************************************************************************************
 *  Crypto_30_Hwa_AesGcmSivDecFinish()
 **********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
CRYPTO_30_HWA_LOCAL_INLINE FUNC(Std_ReturnType, CRYPTO_30_HWA_CODE) Crypto_30_Hwa_AesGcmSivDecFinish(
  Crypto_30_Hwa_WorkSpaceGCMSIV_PtrType workspace, /* PRQA S 3673 */ /* MD_MSR_Rule8.13 */
  P2VAR(Crypto_VerifyResultType, AUTOMATIC, CRYPTO_30_HWA_APPL_VAR) verifyPtr)
{
  /* Return result of tag evaluation */
  *verifyPtr = workspace->verify;

  return E_OK;
} /* Crypto_30_Hwa_AesGcmSivDecFinish() */
#endif /* (CRYPTO_30_HWA_PRIMITIVE_AES_GCMSIV == STD_ON) */

#define CRYPTO_30_HWA_STOP_SEC_CODE
#include "MemMap.h" /* PRQA S 5087 */ /* MD_MSR_MemMap */

/**********************************************************************************************************************
 *  GLOBAL FUNCTIONS
 *********************************************************************************************************************/
#define CRYPTO_30_HWA_START_SEC_CODE
#include "MemMap.h" /* PRQA S 5087 */ /* MD_MSR_MemMap */

#if (CRYPTO_30_HWA_PRIMITIVE_AES_GCM == STD_ON) /* COV_CRYPTO_30_HWA_HARDWARE_DEPENDENT_FEATURE */
/*********************************************************************************************************************
 *  Crypto_30_Hwa_ProcessAeadJobAesGcm()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
FUNC(Std_ReturnType, CRYPTO_30_HWA_CODE) Crypto_30_Hwa_ProcessAeadJobAesGcm(
  uint32 objectId,
  P2VAR(uint8, AUTOMATIC, CRYPTO_30_HWA_APPL_VAR) errorIdPtr,
  Crypto_30_Hwa_JobPtrType job,
  Crypto_30_Hwa_WorkSpaceGCM_PtrType workspace)
{
  Std_ReturnType retVal = E_NOT_OK;
  uint8 tmpBuffer[CRYPTO_30_HWA_AES_BLOCK_SIZE_BYTES] = { 0u };

  /* [SWS_Crypto_00017] [SWS_Crypto_00020] START while IDLE or ACTIVE */
  if (((job->state == CRYPTO_JOBSTATE_IDLE) || (job->state == CRYPTO_JOBSTATE_ACTIVE))
    && Crypto_30_Hwa_IsJobMode(job, CRYPTO_OPERATIONMODE_START))
  {
    /* #10 Prepare workspace */
    workspace->primitiveInfo = job->jobPrimitiveInfo->primitiveInfo;
    workspace->driverObjectId = objectId;

    /* #11 Call start operation */
    retVal = Crypto_30_Hwa_AesGcmStart(workspace, job->cryptoKeyId);
    Crypto_30_Hwa_UpdateJobState(retVal, job); /* SBSW_CRYPTO_30_HWA_FORWARDING_OF_JOB_PTR */
  }

  /* UPDATE while ACTIVE */
  if ((job->state == CRYPTO_JOBSTATE_ACTIVE)
    && Crypto_30_Hwa_IsJobMode(job, CRYPTO_OPERATIONMODE_UPDATE)) /* [SWS_Crypto_00024] */
  {
    uint32 tmpOutputLength = *job->jobPrimitiveInputOutput.outputLengthPtr;

    /* #20 Verify if AAD has already been processed */
    if (workspace->processingFinishedAad == FALSE)
    {
      /* #21 Verify if AAD is provided. This only happens in the first call of update */
      if (job->jobPrimitiveInputOutput.secondaryInputLength > 0u)
      {
        /* #22 Process AAD */
        retVal = Crypto_30_Hwa_AesGcmUpdateAad(workspace, job->jobPrimitiveInputOutput.secondaryInputPtr, job->jobPrimitiveInputOutput.secondaryInputLength);
      }
      else
      {
        /* No AAD provided */
        retVal = E_OK;
      }

      workspace->processingFinishedAad = TRUE;
    }
    else
    {
      /* No further processing of AAD possible */
      retVal = E_OK;
    }

    /* #23 Process plaintext/ciphertext */
    retVal |= Crypto_30_Hwa_AesGcmUpdateInput(workspace,
      job->jobPrimitiveInputOutput.inputPtr, job->jobPrimitiveInputOutput.inputLength,
      job->jobPrimitiveInputOutput.outputPtr, &tmpOutputLength);

    /* #24 Handle output length information */
    if (Crypto_30_Hwa_IsJobMode(job, CRYPTO_OPERATIONMODE_FINISH))
    {
      /* For single call store output length in workspace */
      workspace->outputLength += tmpOutputLength;
    }
    else
    {
      *(job->jobPrimitiveInputOutput.outputLengthPtr) = tmpOutputLength;
    }

    Crypto_30_Hwa_UpdateJobState(retVal, job); /* SBSW_CRYPTO_30_HWA_FORWARDING_OF_JOB_PTR */
  }

  /* [SWS_Crypto_00023] FINISH while ACTIVE */
  if ((job->state == CRYPTO_JOBSTATE_ACTIVE)
    && Crypto_30_Hwa_IsJobMode(job, CRYPTO_OPERATIONMODE_FINISH)) /* [SWS_Crypto_00024] */
  {
    /* #30 For single call: calculate remaining output length and new position in output buffer */
    uint32 tmpOutputLength = *job->jobPrimitiveInputOutput.outputLengthPtr - workspace->outputLength;
    uint8 *tmpOutputPtr = &(job->jobPrimitiveInputOutput.outputPtr[workspace->outputLength]);

    /* #31 Process last block of input data */
    if (tmpOutputLength < (workspace->bufferFillLevel))
    {
      retVal = E_NOT_OK;
    }
    else
    {
      /* #32 Check if last block is smaller than AES block size. If yes, store AES output in buffer and only copy required number of bytes */
      if (workspace->bufferFillLevel < CRYPTO_30_HWA_AES_BLOCK_SIZE_BYTES)
      {
        SchM_Enter_Crypto_30_Hwa_CRYPTO_30_HWA_EXCLUSIVE_AREA_1();
        retVal = Crypto_30_Hwa_Hw_AesGcmProcessLastBlockInput(workspace, workspace->buffer, workspace->bufferFillLevel, tmpBuffer);
        SchM_Exit_Crypto_30_Hwa_CRYPTO_30_HWA_EXCLUSIVE_AREA_1();

        VStdMemCpy(tmpOutputPtr, tmpBuffer, workspace->bufferFillLevel);  /* PRQA S 0315 */ /* MD_MSR_VStdLibCopy */
      }
      else
      {
        SchM_Enter_Crypto_30_Hwa_CRYPTO_30_HWA_EXCLUSIVE_AREA_1();
        retVal = Crypto_30_Hwa_Hw_AesGcmProcessLastBlockInput(workspace, workspace->buffer, workspace->bufferFillLevel, tmpOutputPtr);
        SchM_Exit_Crypto_30_Hwa_CRYPTO_30_HWA_EXCLUSIVE_AREA_1();
      }

      workspace->processedLengthInput += workspace->bufferFillLevel;

      tmpOutputLength = workspace->bufferFillLevel;

      /* #33 Handle output length information */
      *job->jobPrimitiveInputOutput.outputLengthPtr = tmpOutputLength;
      if (Crypto_30_Hwa_IsJobMode(job, CRYPTO_OPERATIONMODE_UPDATE))
      {
        /* For single call, calculate written output length */
        *job->jobPrimitiveInputOutput.outputLengthPtr += workspace->outputLength;
      }

      /* #34 Call finish operation */
      if (job->jobPrimitiveInfo->primitiveInfo->service == CRYPTO_AEADENCRYPT)
      {
        SchM_Enter_Crypto_30_Hwa_CRYPTO_30_HWA_EXCLUSIVE_AREA_1();
        retVal |= Crypto_30_Hwa_AesGcmEncFinish(workspace,
          tmpOutputPtr,
          &tmpOutputLength,
          job->jobPrimitiveInputOutput.secondaryOutputPtr,
          job->jobPrimitiveInputOutput.secondaryOutputLengthPtr);
        SchM_Exit_Crypto_30_Hwa_CRYPTO_30_HWA_EXCLUSIVE_AREA_1();
      }
      else if (job->jobPrimitiveInfo->primitiveInfo->service == CRYPTO_AEADDECRYPT)
      {
        SchM_Enter_Crypto_30_Hwa_CRYPTO_30_HWA_EXCLUSIVE_AREA_1();
        retVal |= Crypto_30_Hwa_AesGcmDecFinish(workspace,
          job->jobPrimitiveInputOutput.tertiaryInputPtr,
          job->jobPrimitiveInputOutput.tertiaryInputLength,
          tmpOutputPtr,
          &tmpOutputLength,
          job->jobPrimitiveInputOutput.verifyPtr);
        SchM_Exit_Crypto_30_Hwa_CRYPTO_30_HWA_EXCLUSIVE_AREA_1();
      }
      else
      {
        /* Not supported service */
      }

# if(CRYPTO_30_HWA_CLEAR_WORKSPACE_BUFFERS == STD_ON)
      /* PRQA S 0315 2 */ /* MD_MSR_VStdLibCopy */
      VStdLib_MemClr(workspace->buffer, sizeof(workspace->buffer));
# endif

    }

    job->state = CRYPTO_JOBSTATE_IDLE; /* SBSW_CRYPTO_30_HWA_DIRECT_ACCESS_TO_JOB_STATE */
  }

  *errorIdPtr = CRYPTO_E_NO_ERROR;

  return retVal;
} /* Crypto_30_Hwa_ProcessAeadJobAesGcm() */ /* PRQA S 6010, 6030, 6050, 6080 */ /* MD_MSR_STPTH, MD_MSR_STCYC, MD_MSR_STCAL, MD_MSR_STMIF */
#endif /* (CRYPTO_30_HWA_PRIMITIVE_AES_GCM == STD_ON) */

#if (CRYPTO_30_HWA_PRIMITIVE_AES_GCMSIV == STD_ON) /* COV_CRYPTO_30_HWA_HARDWARE_DEPENDENT_FEATURE */
/*********************************************************************************************************************
 *  Crypto_30_Hwa_ProcessAeadJobAesGcmSiv()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 */
FUNC(Std_ReturnType, CRYPTO_30_HWA_CODE) Crypto_30_Hwa_ProcessAeadJobAesGcmSiv(
  uint32 objectId,
  P2VAR(uint8, AUTOMATIC, CRYPTO_30_HWA_APPL_VAR) errorIdPtr,
  Crypto_30_Hwa_JobPtrType job,
  Crypto_30_Hwa_WorkSpaceGCMSIV_PtrType workspace)
{
  Std_ReturnType retVal = E_NOT_OK;

  /* [SWS_Crypto_00017] [SWS_Crypto_00020] START while IDLE or ACTIVE */
  if (((job->state == CRYPTO_JOBSTATE_IDLE) || (job->state == CRYPTO_JOBSTATE_ACTIVE))
    && Crypto_30_Hwa_IsJobMode(job, CRYPTO_OPERATIONMODE_START))
  {
    /* #10 Prepare workspace */
    workspace->primitiveInfo = job->jobPrimitiveInfo->primitiveInfo;
    workspace->driverObjectId = objectId;

    /* #11 Call start operation */
    retVal = Crypto_30_Hwa_AesGcmSivStart(workspace, job->cryptoKeyId);
    Crypto_30_Hwa_UpdateJobState(retVal, job); /* SBSW_CRYPTO_30_HWA_FORWARDING_OF_JOB_PTR */
  }

  /* UPDATE while ACTIVE */
  if ((job->state == CRYPTO_JOBSTATE_ACTIVE)
    && Crypto_30_Hwa_IsJobMode(job, CRYPTO_OPERATIONMODE_UPDATE)) /* [SWS_Crypto_00024] */
  {
    /* #20 Check which service to use and call update associated update function */
    if ((job->jobPrimitiveInfo->primitiveInfo->service == CRYPTO_AEADENCRYPT))
    {
      retVal = Crypto_30_Hwa_AesGcmSivEncUpdate(workspace, job->jobPrimitiveInputOutput.inputPtr, job->jobPrimitiveInputOutput.inputLength,
        job->jobPrimitiveInputOutput.secondaryInputPtr, job->jobPrimitiveInputOutput.secondaryInputLength,
        job->jobPrimitiveInputOutput.outputPtr, job->jobPrimitiveInputOutput.outputLengthPtr);
    }
    else if (job->jobPrimitiveInfo->primitiveInfo->service == CRYPTO_AEADDECRYPT)
    {
      retVal = Crypto_30_Hwa_AesGcmSivDecUpdate(workspace, job->jobPrimitiveInputOutput.inputPtr, job->jobPrimitiveInputOutput.inputLength,
        job->jobPrimitiveInputOutput.secondaryInputPtr, job->jobPrimitiveInputOutput.secondaryInputLength,
        job->jobPrimitiveInputOutput.tertiaryInputPtr, job->jobPrimitiveInputOutput.tertiaryInputLength,
        job->jobPrimitiveInputOutput.outputPtr, job->jobPrimitiveInputOutput.outputLengthPtr);
    }
    else
    {
      /* Not supported service */
    }

    Crypto_30_Hwa_UpdateJobState(retVal, job); /* SBSW_CRYPTO_30_HWA_FORWARDING_OF_JOB_PTR */
  }

  /* [SWS_Crypto_00023] FINISH while ACTIVE */
  if ((job->state == CRYPTO_JOBSTATE_ACTIVE)
    && Crypto_30_Hwa_IsJobMode(job, CRYPTO_OPERATIONMODE_FINISH)) /* [SWS_Crypto_00024] */
  {
    /* #30 Check which service to use and call update associated finish function */
    if ((job->jobPrimitiveInfo->primitiveInfo->service == CRYPTO_AEADENCRYPT))
    {
      retVal = Crypto_30_Hwa_AesGcmSivEncFinish(workspace, job->jobPrimitiveInputOutput.secondaryOutputPtr, job->jobPrimitiveInputOutput.secondaryOutputLengthPtr);
    }
    else if (job->jobPrimitiveInfo->primitiveInfo->service == CRYPTO_AEADDECRYPT)
    {
      retVal = Crypto_30_Hwa_AesGcmSivDecFinish(workspace, job->jobPrimitiveInputOutput.verifyPtr);
    }
    else
    {
      /* Not supported service */
    }

# if (CRYPTO_30_HWA_CLEAR_WORKSPACE_BUFFERS == STD_ON)
    /* PRQA S 0315 13 */ /* MD_MSR_VStdLibCopy */
    VStdLib_MemClr(workspace->keyAuth, sizeof(workspace->keyAuth));
    VStdLib_MemClr(workspace->keyCipher, sizeof(workspace->keyCipher));
    VStdLib_MemClr(workspace->ghashValue, sizeof(workspace->ghashValue));
    VStdLib_MemClr(workspace->tag, sizeof(workspace->tag));
    VStdLib_MemClr(workspace->nonce, sizeof(workspace->nonce));
    VStdLib_MemClr(workspace->counterCtr, sizeof(workspace->counterCtr));
    VStdLib_MemClr(workspace->polyvalStruct.tmp, sizeof(workspace->polyvalStruct.tmp));
    VStdLib_MemClr(workspace->polyvalStruct.fieldElement1, sizeof(workspace->polyvalStruct.fieldElement1));
    VStdLib_MemClr(workspace->polyvalStruct.fieldElement2, sizeof(workspace->polyvalStruct.fieldElement2));
    VStdLib_MemClr(workspace->polyvalStruct.wsGHash.H, sizeof(workspace->polyvalStruct.wsGHash.H));
    VStdLib_MemClr(workspace->polyvalStruct.wsGHash.M, sizeof(workspace->polyvalStruct.wsGHash.M));
    VStdLib_MemClr(workspace->polyvalStruct.wsGHash.buffer, sizeof(workspace->polyvalStruct.wsGHash.buffer));
    VStdLib_MemClr(workspace->polyvalStruct.wsGHash.Y, sizeof(workspace->polyvalStruct.wsGHash.Y));
# endif

    job->state = CRYPTO_JOBSTATE_IDLE; /* SBSW_CRYPTO_30_HWA_DIRECT_ACCESS_TO_JOB_STATE */
  }

  *errorIdPtr = CRYPTO_E_NO_ERROR;

  return retVal;
} /* Crypto_30_Hwa_ProcessAeadJobAesGcmSiv() */
#endif /* (CRYPTO_30_HWA_PRIMITIVE_AES_GCMSIV == STD_ON) */

#define CRYPTO_30_HWA_STOP_SEC_CODE
#include "MemMap.h" /* PRQA S 5087 */ /* MD_MSR_MemMap */

/**********************************************************************************************************************
 *  END OF FILE: Crypto_30_Hwa_Aead.c
 *********************************************************************************************************************/

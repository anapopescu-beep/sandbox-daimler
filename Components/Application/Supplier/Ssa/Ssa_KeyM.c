/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << Start of version logging area >>                DO NOT CHANGE THIS COMMENT!
 *********************************************************************************************************************/

/**********************************************************************************************************************
 *  COPYRIGHT
 *  -------------------------------------------------------------------------------------------------------------------
 *  \verbatim
 *  Copyright (c) 2024 by Vector Informatik GmbH.                                                  All rights reserved.
 *
 *                This software is copyright protected and proprietary to Vector Informatik GmbH.
 *                Vector Informatik GmbH grants to you only those rights as set out in the license conditions.
 *                All other rights remain with Vector Informatik GmbH.
 *  \endverbatim
 *  -------------------------------------------------------------------------------------------------------------------
 *  FILE DESCRIPTION
 *  -----------------------------------------------------------------------------------------------------------------*/
/*!        \file  Ssa_KeyM.c
 *        \brief  Key Manager of the Standard Security Architecture (Ssa).
 *
 *      \details  The Key Manager provides services to install keys for the ECU.
 *
 *********************************************************************************************************************/

/**********************************************************************************************************************
 *  REVISION HISTORY
 *  -------------------------------------------------------------------------------------------------------------------
 *  Refer to the module's header file.
 *********************************************************************************************************************/

/* PRQA S 0777, 0779 EOF */ /* MD_MSR_Rule5.1, MD_MSR_Rule5.2 */

/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << End of version logging area >>                  DO NOT CHANGE THIS COMMENT!
 *********************************************************************************************************************/

/**********************************************************************************************************************
 *
 * AUTOSAR Modelling Object Descriptions
 *
 **********************************************************************************************************************
 *
 * Data Types:
 * ===========
 * CertP_PkiRoleType
 *   uint8 represents integers with a minimum value of 0 and a maximum value of 255.
 *      The order-relation on uint8 is: x < y if y - x is positive.
 *      uint8 has a lexical representation consisting of a finite-length sequence 
 *      of decimal digits (#x30-#x39).
 *      
 *      For example: 1, 0, 126, +10.
 *
 * CertP_VerificationResultType
 *   uint8 represents integers with a minimum value of 0 and a maximum value of 255.
 *      The order-relation on uint8 is: x < y if y - x is positive.
 *      uint8 has a lexical representation consisting of a finite-length sequence 
 *      of decimal digits (#x30-#x39).
 *      
 *      For example: 1, 0, 126, +10.
 *
 * Coding_MemoryStatusType
 *   uint8 represents integers with a minimum value of 0 and a maximum value of 255.
 *      The order-relation on uint8 is: x < y if y - x is positive.
 *      uint8 has a lexical representation consisting of a finite-length sequence 
 *      of decimal digits (#x30-#x39).
 *      
 *      For example: 1, 0, 126, +10.
 *
 * Coding_ModeType
 *   uint8 represents integers with a minimum value of 0 and a maximum value of 255.
 *      The order-relation on uint8 is: x < y if y - x is positive.
 *      uint8 has a lexical representation consisting of a finite-length sequence 
 *      of decimal digits (#x30-#x39).
 *      
 *      For example: 1, 0, 126, +10.
 *
 * Crypto_OperationModeType
 *   uint8 represents integers with a minimum value of 0 and a maximum value of 255.
 *      The order-relation on uint8 is: x < y if y - x is positive.
 *      uint8 has a lexical representation consisting of a finite-length sequence 
 *      of decimal digits (#x30-#x39).
 *      
 *      For example: 1, 0, 126, +10.
 *
 * Crypto_VerifyResultType
 *   uint8 represents integers with a minimum value of 0 and a maximum value of 255.
 *      The order-relation on uint8 is: x < y if y - x is positive.
 *      uint8 has a lexical representation consisting of a finite-length sequence 
 *      of decimal digits (#x30-#x39).
 *      
 *      For example: 1, 0, 126, +10.
 *
 * Csm_DecryptDataType_AES128Decrypt
 *   Used as Buffer for service.
 *
 * Csm_DecryptDataType_AES128DecryptWithPadding
 *   Used as Buffer for service.
 *
 * Csm_DecryptResultType_AES128Decrypt
 *   Used as Buffer for service.
 *
 * Csm_DecryptResultType_AES128DecryptWithPadding
 *   Used as Buffer for service.
 *
 * Csm_EncryptDataType_AES128Encrypt
 *   Used as Buffer for service.
 *
 * Csm_EncryptResultType_AES128Encrypt
 *   Used as Buffer for service.
 *
 * Csm_KeyDataType_Ssa_AesRamKey
 *   Used as Buffer for service.
 *
 * Csm_KeyDataType_Ssa_BackendCert
 *   Used as Buffer for service.
 *
 * Csm_KeyDataType_Ssa_EcuCert
 *   Used as Buffer for service.
 *
 * Csm_KeyDataType_Ssa_RootCert
 *   Used as Buffer for service.
 *
 * Csm_KeyDataType_Ssa_SharedSecret
 *   Used as Buffer for service.
 *
 * Csm_KeyDataType_Ssa_SharedSecretHash
 *   Used as Buffer for service.
 *
 * Csm_KeyDataType_Ssa_SharedSecretKeyExchange
 *   Used as Buffer for service.
 *
 * Csm_KeyDataType_Ssa_SigPubKey_ReplacementAuthority
 *   Used as Buffer for service.
 *
 * Csm_KeyDataType_Ssa_SignatureRamKey
 *   Used as Buffer for service.
 *
 * Csm_KeyDataType_Ssa_TrustModelEcuCsrPublicKey
 *   Used as Buffer for service.
 *
 * Csm_KeyDataType_Ssa_TrustModelEcuLivePublicKey
 *   Used as Buffer for service.
 *
 * Csm_KeyDataType_Ssa_TrustModelTempPublicKey
 *   Used as Buffer for service.
 *
 * Csm_MacGenerateDataType_MacGenAesCmac
 *   Used as Buffer for service.
 *
 * Csm_MacGenerateResultType_MacGenAesCmac
 *   Used as Buffer for service.
 *
 * Csm_PublicValueDataType_Ssa_SharedSecretKeyExchange
 *   Used as Buffer for service.
 *
 * Csm_RandomGenerateResultType_Random
 *   Used as Buffer for service.
 *
 * Csm_ResultType
 *   uint8 represents integers with a minimum value of 0 and a maximum value of 255.
 *      The order-relation on uint8 is: x < y if y - x is positive.
 *      uint8 has a lexical representation consisting of a finite-length sequence 
 *      of decimal digits (#x30-#x39).
 *      
 *      For example: 1, 0, 126, +10.
 *
 * Csm_SeedDataTypeSsa_RandomSeed
 *   Used as Buffer for service.
 *
 * Dcm_DiagnosticSessionControlType
 *   uint8 represents integers with a minimum value of 0 and a maximum value of 255.
 *      The order-relation on uint8 is: x < y if y - x is positive.
 *      uint8 has a lexical representation consisting of a finite-length sequence 
 *      of decimal digits (#x30-#x39).
 *      
 *      For example: 1, 0, 126, +10.
 *
 * Dcm_NegativeResponseCodeType
 *   uint8 represents integers with a minimum value of 0 and a maximum value of 255.
 *      The order-relation on uint8 is: x < y if y - x is positive.
 *      uint8 has a lexical representation consisting of a finite-length sequence 
 *      of decimal digits (#x30-#x39).
 *      
 *      For example: 1, 0, 126, +10.
 *
 * Dcm_OpStatusType
 *   uint8 represents integers with a minimum value of 0 and a maximum value of 255.
 *      The order-relation on uint8 is: x < y if y - x is positive.
 *      uint8 has a lexical representation consisting of a finite-length sequence 
 *      of decimal digits (#x30-#x39).
 *      
 *      For example: 1, 0, 126, +10.
 *
 * KeyM_CertElementIdType
 *   uint16 represents integers with a minimum value of 0 and a maximum value of 65535.
 *      The order-relation on uint16 is: x < y if y - x is positive.
 *      uint16 has a lexical representation consisting of a finite-length sequence 
 *      of decimal digits (#x30-#x39).
 *      
 *      For example: 1, 0, 1267, +10000.
 *
 * KeyM_CertificateElementType_Ssa_TrustModelBackendCert_Issuer
 *   Used as Buffer for service.
 *
 * KeyM_CertificateElementType_Ssa_TrustModelBackendCert_SerialNo
 *   Used as Buffer for service.
 *
 * KeyM_CertificateElementType_Ssa_TrustModelBackendCert_SubjectPublicKeyInfoKey
 *   Used as Buffer for service.
 *
 * KeyM_CertificateElementType_Ssa_TrustModelBackendCert_Version
 *   Used as Buffer for service.
 *
 * KeyM_CertificateElementType_Ssa_TrustModelBackendCert_ext_authKeyId
 *   Used as Buffer for service.
 *
 * KeyM_CertificateElementType_Ssa_TrustModelBackendCert_ext_basicConstraints
 *   Used as Buffer for service.
 *
 * KeyM_CertificateElementType_Ssa_TrustModelBackendCert_ext_subKeyId
 *   Used as Buffer for service.
 *
 * KeyM_CertificateElementType_Ssa_TrustModelBackendCert_subject
 *   Used as Buffer for service.
 *
 * KeyM_CertificateElementType_Ssa_TrustModelBackendCert_validityNotAfter
 *   Used as Buffer for service.
 *
 * KeyM_CertificateElementType_Ssa_TrustModelBackendPeerCert_SerialNo
 *   Used as Buffer for service.
 *
 * KeyM_CertificateElementType_Ssa_TrustModelBackendPeerCert_Version
 *   Used as Buffer for service.
 *
 * KeyM_CertificateElementType_Ssa_TrustModelBackendPeerCert_ext_authKeyId
 *   Used as Buffer for service.
 *
 * KeyM_CertificateElementType_Ssa_TrustModelBackendPeerCert_ext_basicConstraints
 *   Used as Buffer for service.
 *
 * KeyM_CertificateElementType_Ssa_TrustModelBackendPeerCert_ext_subKeyId
 *   Used as Buffer for service.
 *
 * KeyM_CertificateElementType_Ssa_TrustModelBackendPeerCert_validityNotAfter
 *   Used as Buffer for service.
 *
 * KeyM_CertificateElementType_Ssa_TrustModelEcuCert_Issuer
 *   Used as Buffer for service.
 *
 * KeyM_CertificateElementType_Ssa_TrustModelEcuCert_SerialNo
 *   Used as Buffer for service.
 *
 * KeyM_CertificateElementType_Ssa_TrustModelEcuCert_SubjectPublicKeyInfoKey
 *   Used as Buffer for service.
 *
 * KeyM_CertificateElementType_Ssa_TrustModelEcuCert_Version
 *   Used as Buffer for service.
 *
 * KeyM_CertificateElementType_Ssa_TrustModelEcuCert_ext_authKeyId
 *   Used as Buffer for service.
 *
 * KeyM_CertificateElementType_Ssa_TrustModelEcuCert_ext_specialEcu
 *   Used as Buffer for service.
 *
 * KeyM_CertificateElementType_Ssa_TrustModelEcuCert_ext_subKeyId
 *   Used as Buffer for service.
 *
 * KeyM_CertificateElementType_Ssa_TrustModelEcuCert_ext_uniqueECUID
 *   Used as Buffer for service.
 *
 * KeyM_CertificateElementType_Ssa_TrustModelEcuCert_subject
 *   Used as Buffer for service.
 *
 * KeyM_CertificateElementType_Ssa_TrustModelEcuCert_validityNotAfter
 *   Used as Buffer for service.
 *
 * KeyM_CertificateElementType_Ssa_TrustModelEcuPeerCert_SerialNo
 *   Used as Buffer for service.
 *
 * KeyM_CertificateElementType_Ssa_TrustModelEcuPeerCert_Version
 *   Used as Buffer for service.
 *
 * KeyM_CertificateElementType_Ssa_TrustModelEcuPeerCert_ext_authKeyId
 *   Used as Buffer for service.
 *
 * KeyM_CertificateElementType_Ssa_TrustModelEcuPeerCert_ext_specialEcu
 *   Used as Buffer for service.
 *
 * KeyM_CertificateElementType_Ssa_TrustModelEcuPeerCert_ext_subKeyId
 *   Used as Buffer for service.
 *
 * KeyM_CertificateElementType_Ssa_TrustModelEcuPeerCert_validityNotAfter
 *   Used as Buffer for service.
 *
 * KeyM_CertificateElementType_Ssa_TrustModelIntermediateCert_Issuer
 *   Used as Buffer for service.
 *
 * KeyM_CertificateElementType_Ssa_TrustModelIntermediateCert_SerialNo
 *   Used as Buffer for service.
 *
 * KeyM_CertificateElementType_Ssa_TrustModelIntermediateCert_SubjectPublicKeyInfoKey
 *   Used as Buffer for service.
 *
 * KeyM_CertificateElementType_Ssa_TrustModelIntermediateCert_Version
 *   Used as Buffer for service.
 *
 * KeyM_CertificateElementType_Ssa_TrustModelIntermediateCert_ext_authKeyId
 *   Used as Buffer for service.
 *
 * KeyM_CertificateElementType_Ssa_TrustModelIntermediateCert_ext_basicConstraints
 *   Used as Buffer for service.
 *
 * KeyM_CertificateElementType_Ssa_TrustModelIntermediateCert_ext_subKeyId
 *   Used as Buffer for service.
 *
 * KeyM_CertificateElementType_Ssa_TrustModelIntermediateCert_subject
 *   Used as Buffer for service.
 *
 * KeyM_CertificateElementType_Ssa_TrustModelIntermediateCert_validityNotAfter
 *   Used as Buffer for service.
 *
 * KeyM_CertificateElementType_Ssa_TrustModelIntermediatePeerCert_SerialNo
 *   Used as Buffer for service.
 *
 * KeyM_CertificateElementType_Ssa_TrustModelIntermediatePeerCert_Version
 *   Used as Buffer for service.
 *
 * KeyM_CertificateElementType_Ssa_TrustModelIntermediatePeerCert_ext_authKeyId
 *   Used as Buffer for service.
 *
 * KeyM_CertificateElementType_Ssa_TrustModelIntermediatePeerCert_ext_basicConstraints
 *   Used as Buffer for service.
 *
 * KeyM_CertificateElementType_Ssa_TrustModelIntermediatePeerCert_ext_subKeyId
 *   Used as Buffer for service.
 *
 * KeyM_CertificateElementType_Ssa_TrustModelIntermediatePeerCert_validityNotAfter
 *   Used as Buffer for service.
 *
 * KeyM_CertificateElementType_Ssa_TrustModelRootCert_Issuer
 *   Used as Buffer for service.
 *
 * KeyM_CertificateElementType_Ssa_TrustModelRootCert_SerialNo
 *   Used as Buffer for service.
 *
 * KeyM_CertificateElementType_Ssa_TrustModelRootCert_SubjectPublicKeyInfoKey
 *   Used as Buffer for service.
 *
 * KeyM_CertificateElementType_Ssa_TrustModelRootCert_Version
 *   Used as Buffer for service.
 *
 * KeyM_CertificateElementType_Ssa_TrustModelRootCert_ext_basicConstraints
 *   Used as Buffer for service.
 *
 * KeyM_CertificateElementType_Ssa_TrustModelRootCert_ext_keyUsage
 *   Used as Buffer for service.
 *
 * KeyM_CertificateElementType_Ssa_TrustModelRootCert_ext_subKeyId
 *   Used as Buffer for service.
 *
 * KeyM_CertificateElementType_Ssa_TrustModelRootCert_subject
 *   Used as Buffer for service.
 *
 * KeyM_CertificateElementType_Ssa_TrustModelRootCert_validityNotAfter
 *   Used as Buffer for service.
 *
 * KeyM_CertificateIdType
 *   uint16 represents integers with a minimum value of 0 and a maximum value of 65535.
 *      The order-relation on uint16 is: x < y if y - x is positive.
 *      uint16 has a lexical representation consisting of a finite-length sequence 
 *      of decimal digits (#x30-#x39).
 *      
 *      For example: 1, 0, 1267, +10000.
 *
 * KeyM_CertificateStatusType
 *   uint8 represents integers with a minimum value of 0 and a maximum value of 255.
 *      The order-relation on uint8 is: x < y if y - x is positive.
 *      uint8 has a lexical representation consisting of a finite-length sequence 
 *      of decimal digits (#x30-#x39).
 *      
 *      For example: 1, 0, 126, +10.
 *
 * KeyM_CsrEncodingType
 *   uint8 represents integers with a minimum value of 0 and a maximum value of 255.
 *      The order-relation on uint8 is: x < y if y - x is positive.
 *      uint8 has a lexical representation consisting of a finite-length sequence 
 *      of decimal digits (#x30-#x39).
 *      
 *      For example: 1, 0, 126, +10.
 *
 * KeyM_ResultType
 *   uint8 represents integers with a minimum value of 0 and a maximum value of 255.
 *      The order-relation on uint8 is: x < y if y - x is positive.
 *      uint8 has a lexical representation consisting of a finite-length sequence 
 *      of decimal digits (#x30-#x39).
 *      
 *      For example: 1, 0, 126, +10.
 *
 * KeyM_ServiceCertificateType
 *   uint8 represents integers with a minimum value of 0 and a maximum value of 255.
 *      The order-relation on uint8 is: x < y if y - x is positive.
 *      uint8 has a lexical representation consisting of a finite-length sequence 
 *      of decimal digits (#x30-#x39).
 *      
 *      For example: 1, 0, 126, +10.
 *
 * KeyM_const_CryptoKeyDataType
 *   Byte-pointer to the input or output data.
 *
 * NvM_RequestResultType
 *   uint8 represents integers with a minimum value of 0 and a maximum value of 255.
 *      The order-relation on uint8 is: x < y if y - x is positive.
 *      uint8 has a lexical representation consisting of a finite-length sequence 
 *      of decimal digits (#x30-#x39).
 *      
 *      For example: 1, 0, 126, +10.
 *
 * RightsM_ACL_BitMaskType
 *   uint32 represents integers with a minimum value of 0 and a maximum value 
 *      of 4294967295. The order-relation on uint32 is: x < y if y - x is positive.
 *      uint32 has a lexical representation consisting of a finite-length sequence 
 *      of decimal digits (#x30-#x39). 
 *      
 *      For example: 1, 0, 12234567, 104400.
 *
 * RightsM_AuthenticationModeType
 *   uint8 represents integers with a minimum value of 0 and a maximum value of 255.
 *      The order-relation on uint8 is: x < y if y - x is positive.
 *      uint8 has a lexical representation consisting of a finite-length sequence 
 *      of decimal digits (#x30-#x39).
 *      
 *      For example: 1, 0, 126, +10.
 *
 * RightsM_DiagnosticUserRoleType
 *   uint8 represents integers with a minimum value of 0 and a maximum value of 255.
 *      The order-relation on uint8 is: x < y if y - x is positive.
 *      uint8 has a lexical representation consisting of a finite-length sequence 
 *      of decimal digits (#x30-#x39).
 *      
 *      For example: 1, 0, 126, +10.
 *
 * Ssa_KeyElementType
 *   uint32 represents integers with a minimum value of 0 and a maximum value 
 *      of 4294967295. The order-relation on uint32 is: x < y if y - x is positive.
 *      uint32 has a lexical representation consisting of a finite-length sequence 
 *      of decimal digits (#x30-#x39). 
 *      
 *      For example: 1, 0, 12234567, 104400.
 *
 * Ssa_KeyStorageTaskType
 *   uint8 represents integers with a minimum value of 0 and a maximum value of 255.
 *      The order-relation on uint8 is: x < y if y - x is positive.
 *      uint8 has a lexical representation consisting of a finite-length sequence 
 *      of decimal digits (#x30-#x39).
 *      
 *      For example: 1, 0, 126, +10.
 *
 * Ssa_KeyStorageUseCaseType
 *   uint8 represents integers with a minimum value of 0 and a maximum value of 255.
 *      The order-relation on uint8 is: x < y if y - x is positive.
 *      uint8 has a lexical representation consisting of a finite-length sequence 
 *      of decimal digits (#x30-#x39).
 *      
 *      For example: 1, 0, 126, +10.
 *
 * Ssa_OnOff_StateType
 *   uint8 represents integers with a minimum value of 0 and a maximum value of 255.
 *      The order-relation on uint8 is: x < y if y - x is positive.
 *      uint8 has a lexical representation consisting of a finite-length sequence 
 *      of decimal digits (#x30-#x39).
 *      
 *      For example: 1, 0, 126, +10.
 *
 * Ssa_OpStatusType
 *   uint8 represents integers with a minimum value of 0 and a maximum value of 255.
 *      The order-relation on uint8 is: x < y if y - x is positive.
 *      uint8 has a lexical representation consisting of a finite-length sequence 
 *      of decimal digits (#x30-#x39).
 *      
 *      For example: 1, 0, 126, +10.
 *
 * Ssa_OperationModeType
 *   uint8 represents integers with a minimum value of 0 and a maximum value of 255.
 *      The order-relation on uint8 is: x < y if y - x is positive.
 *      uint8 has a lexical representation consisting of a finite-length sequence 
 *      of decimal digits (#x30-#x39).
 *      
 *      For example: 1, 0, 126, +10.
 *
 * Ssa_PostProductionStatusType
 *   uint8 represents integers with a minimum value of 0 and a maximum value of 255.
 *      The order-relation on uint8 is: x < y if y - x is positive.
 *      uint8 has a lexical representation consisting of a finite-length sequence 
 *      of decimal digits (#x30-#x39).
 *      
 *      For example: 1, 0, 126, +10.
 *
 * Ssa_TrustModelChainState_Type
 *   uint8 represents integers with a minimum value of 0 and a maximum value of 255.
 *      The order-relation on uint8 is: x < y if y - x is positive.
 *      uint8 has a lexical representation consisting of a finite-length sequence 
 *      of decimal digits (#x30-#x39).
 *      
 *      For example: 1, 0, 126, +10.
 *
 * TimeM_CompareOperatorType
 *   uint8 represents integers with a minimum value of 0 and a maximum value of 255.
 *      The order-relation on uint8 is: x < y if y - x is positive.
 *      uint8 has a lexical representation consisting of a finite-length sequence 
 *      of decimal digits (#x30-#x39).
 *      
 *      For example: 1, 0, 126, +10.
 *
 *
 * Port Prototypes:
 * ================
 * CallbackNotification_KeyExchangeCalcPubVal
 *   Callback notification from the CSM key exchange calculate public value job.
 *      Configuration Variant(s): Asynchronous key management job processing.
 *
 * CallbackNotification_KeyExchangeCalcSecret
 *   Callback notification from the CSM key exchange calculate secret job.
 *      Configuration Variant(s): Asynchronous key management job processing.
 *
 * CallbackNotification_KeyGenerate_TrustModelEcuCsr
 *   Callback notification from the CSM key generate job.
 *      Configuration Variant(s): Asynchronous key management job processing.
 *
 * CallbackNotification_RandomGenerate
 *   Callback notification from the CSM random generate job.
 *      Configuration Variant(s): Asynchronous job processing.
 *
 * CallbackNotification_RandomSeed
 *   Callback notification from the CSM random seed job.
 *      Configuration Variant(s): Asynchronous key management job processing.
 *      Configuration Variant(s): Not in VSM.
 *
 * CallbackNotification_SignatureGenerate
 *   Callback notification from the CSM signature generation job used for generating signatures with the private ECU key.
 *      Configuration Variant(s): Asynchronous job processing.
 *      Configuration Variant(s): VSM only.
 *
 * CallbackNotification_SignatureGenerate_TrustModelEcuCsr
 *   Callback notification from the CSM signature generation job used for generating signatures with the Trust Model ECU CSR key.
 *      Configuration Variant(s): Asynchronous job processing.
 *
 * CallbackNotification_SignatureGenerate_TrustModelEcuLive
 *   Callback notification from the CSM signature generation job used for generating signatures with the Trust Model ECU live key.
 *      Configuration Variant(s): Asynchronous job processing.
 *
 * CallbackNotification_SignatureVerify
 *   Callback notification from the CSM signature verification job used for verifying the signature of passed data with a temporary public key.
 *      Configuration Variant(s): Asynchronous job processing.
 *
 * CallbackNotification_SignatureVerify_ReplacementAuthority
 *   Callback notification from the CSM signature verification job used for verifying the signature of passed data with the replacement authority public key.
 *      Configuration Variant(s): Asynchronous job processing.
 *
 * CallbackNotification_SignatureVerify_TrustModelBackend
 *   Callback notification from the CSM signature verification job used for verifying the signature of passed data with the public key of the Trust Model Backend CA certificate.
 *      Configuration Variant(s): Asynchronous job processing.
 *      Configuration Variant(s): Not in VSM.
 *
 * CallbackNotification_SignatureVerify_TrustModelTemp
 *   Callback notification from the CSM signature verification job used for verifying the signature of passed data with a Trust Model temporary public key.
 *      Configuration Variant(s): Asynchronous job processing.
 *
 * CsmJobKeyExchangeCalcPubVal
 *   Calculates a key exchange public value.
 *      Connect to a Csm KeyExchangeCalcPubVal job.
 *      Configuration Variant(s): Asynchronous key management job processing.
 *
 * CsmJobKeyExchangeCalcSecret
 *   Calculates a key exchange secret.
 *      Connect to a Csm KeyExchangeCalcSecret job.
 *      Configuration Variant(s): Asynchronous key management job processing.
 *
 * CsmJobKeyGenerate_TrustModelEcuCsr
 *   Generates a new unique ECU key pair.
 *      Connect to a Csm KeyGenerate job of the Ed25519 algorithm family.
 *      Configuration Variant(s): Asynchronous key management job processing.
 *
 * CsmJobRandomSeed
 *   Seeding the random generation algorithm.
 *      Connect to a Csm RandomSeed job.
 *      Configuration Variant(s): Asynchronous key management job processing.
 *      Configuration Variant(s): Not in VSM.
 *
 * CsmRandomGenerate
 *   Generates a random number.
 *      Connect to a Csm Random job.
 *
 * CsmSymAES128Decrypt
 *   Decrypt data using AES128 with formerly set AesRamKey.
 *      Connect to a Csm Decrypt Job which uses the RAM key set through port Key_AesRamKey.
 *      Configuration Variant(s): Not in VSM.
 *
 * CsmSymAES128DecryptWithPadding
 *   Decrypt data using AES128 with formerly set AesRamKey. Padding bytes needs to be considered.
 *      Connect to a Csm Decrypt Job which uses the RAM key set through port Key_AesRamKey.
 *      Configuration Variant(s): Not in VSM.
 *
 * CsmSymAES128Encrypt
 *   Encrypt data using AES128 with former set AesRamKey.
 *      Connect to a Csm Encrypt Job which uses the ram key set through port Key_AesRamKey.
 *      Configuration Variant(s): VSM only.
 *
 * DataServices_Backend_CA_Certificate_Identification_Read_Backend_CA_SubjectKeyIdentifier
 *   Reads subject key identifier of backend certificate and pass it to given data parameter.
 *      Connect to corresponding Dcm port.
 *
 * DataServices_Backend_CA_Certificate_Read
 *   Reads backend certificate and pass it to given data parameter.
 *      Connect to corresponding Dcm port.
 *
 * DataServices_DID_018F_Secured_PDU_Data_IDs_and_Key_CMACs
 *   Retrieves all SecOC Data-IDs of the secured PDUs and their corresponding truncated MAC from the ECU.
 *
 * DataServices_DID_0193_Common_Name
 *   Reads the common name of the ECU Certificate nonce and passes it to given data parameter.
 *      Connect to corresponding Dcm port.
 *      Configuration Variant(s): VSM only.
 *
 * DataServices_DID_0193_SerialNumber
 *   Reads the serial number of the ECU Certificate nonce and passes it to given data parameter.
 *      Connect to corresponding Dcm port.
 *      Configuration Variant(s): VSM only.
 *
 * DataServices_DID_0193_SubjectKeyIdentifier
 *   Reads the subject key identifier of the ECU Certificate nonce and passes it to given data parameter.
 *      Connect to corresponding Dcm port.
 *      Configuration Variant(s): VSM only.
 *
 * DataServices_DID_0193_SubjectPublicKeyInfo
 *   Reads the subject public key info of the ECU Certificate nonce and passes it to given data parameter.
 *      Connect to corresponding Dcm port.
 *      Configuration Variant(s): VSM only.
 *
 * DataServices_DID_0194_ECC_CA_Certificate_Identification
 *   Reads subject key identifier of backend certificate and passes it to given data parameter.
 *      Connect to corresponding Dcm port.
 *      Configuration Variant(s): VSM only.
 *
 * DataServices_DID_0198_Root_Replacement_Key
 *   Reads the Trust Model Root Replacement Key and passes it to the given data parameter.
 *      Connect to corresponding Dcm port.
 *
 * DataServices_DID_0199_Certificates
 *   Reads the certificates and passes it to given data parameter - Unique ECU ID chain.
 *      Connect to corresponding Dcm port.
 *      Configuration Variant(s): Not in VSM.
 *
 * DataServices_DID_0199_Data_Signature
 *   Reads a signature which was calculated over nonce and ephemeral key and passes it to given data parameter - Unique ECU ID chain.
 *      Connect to corresponding Dcm port.
 *      Configuration Variant(s): Not in VSM.
 *
 * DataServices_DID_0199_Ephemeral_ECU_Public_Key
 *   Reads the ephemeral public key and passes it to given data parameter - Unique ECU ID chain.
 *      Connect to corresponding Dcm port.
 *      Configuration Variant(s): Not in VSM.
 *
 * DataServices_DID_0199_Nonce
 *   Reads the nonce and passes it to given data parameter - Unique ECU ID chain.
 *      Connect to corresponding Dcm port.
 *      Configuration Variant(s): Not in VSM.
 *
 * DataServices_ECU_Certificate_Read_Data_Signature
 *   Reads a signature which was calculated over nonce and ephemeral key and pass it to given data parameter.
 *      Configuration Variant(s): VSM only.
 *
 * DataServices_ECU_Certificate_Read_ECU_Certificate
 *   Reads the Ecu certificate and pass it to given data parameter.
 *      Configuration Variant(s): VSM only.
 *
 * DataServices_ECU_Certificate_Read_Ephemeral_ECU_Public_Key
 *   Reads the ephemeral public key and pass it to given data parameter.
 *      Configuration Variant(s): VSM only.
 *
 * DataServices_ECU_Certificate_Read_Nonce
 *   Reads the nonce and pass it to given data parameter.
 *      Configuration Variant(s): VSM only.
 *
 * DataServices_Root_CA_Certificate_Read
 *   Reads root certificate and passes it to given data parameter.
 *      Connect to corresponding Dcm port.
 *
 * DataServices_SecOC_PDU_Data_IDs_and_Key_Checksum_Read_Secured_PDU_Data_IDs_and_Key_Checksum
 *   Reads checksum of pdu data identifiers and passes it to given data parameter.
 *      Connect to corresponding Dcm port.
 *
 * DataServices_SecOC_Vehicle_Shared_Secret_Hash_Read_SecOC_Vehicle_Shared_Secret_Hash
 *   Reads hash value of shared secret and passes it to given data parameter.
 *      Connect to corresponding Dcm port.
 *
 * KeyM_Com_ReceiveSharedSecret
 *   Configuration Variant(s): Not in VSM.
 *
 * KeyM_Com_SendSharedSecret
 *   Configuration Variant(s): VSM only.
 *
 * Key_AesRamKey
 *   Sets the key used for en- or decrypting the nonce and shared secret.
 *      Connect to a Csm Key which is able to store a symmetric key and is used in AES jobs.
 *
 * Key_BackendCert
 *   Key is used to store the Backend certificate.
 *      Connect to a Csm Key which is able to store raw certificate data.
 *
 * Key_EcuCert
 *   Key is used to store the ECU certificate.
 *      Connect to a Csm Key which is able to store raw certificate data.
 *      Configuration Variant(s): VSM only.
 *
 * Key_RandomSeed
 *   Key is used to store the seed which shall be used as input for a pseudo random generator.
 *      Connect to a Csm Key which is able to store a seed and used by random generator
 *
 * Key_RootCert
 *   Key is used to store the Root certificate.
 *      Connect to a Csm Key which is able to store raw certificate data.
 *
 * Key_SharedSecret
 *   Connect to a Csm Key which is able to store a symmetric key.
 *      Key is used to store the secret key.
 *      Configuration Variant(s): VSM only.
 *
 * Key_SharedSecretHash
 *   Key is used to store the proof of the shared secret.
 *      Connect to a Csm Key which is able to store a proof of a key.
 *
 * Key_SharedSecretKeyExchange
 *   Key is used to generate a common key between two ecu based on the exchange of its public keys.
 *      Connect to a Csm Key which is able to calculate a common secret.
 *
 * Key_SignatureRamKey
 *   Sets the public key of a certificate to verify data signed by this certificate.
 *      Connect to a Csm Key which is able to store a public key and is used in job of port CsmSignatureVerify.
 *
 * Key_TrustModelEcuLivePrivateKey
 *   Connect to Csm key that is used as private key for the Trust Model ECU certificate.
 *
 * Key_TrustModelEcuLivePublicKey
 *   Connect to Csm key that is used as public key for the Trust Model ECU certificate.
 *
 * Key_TrustModelEcuStagingPrivateKey
 *   Connect to Csm key that is used as private key for the Trust Model ECU CSR certificate.
 *
 * Key_TrustModelEcuStagingPublicKey
 *   Connect to Csm key that is used as public key for the Trust Model ECU CSR certificate.
 *
 * Key_TrustModelRootReplacementKey
 *   Connect to Csm key that is used for signature verification over the New Root CA Certificate package.
 *
 * Key_TrustModelTempPublicKey
 *   Connect to Csm key that is used as public key for the Trust Model ECU peer certificate.
 *
 * MacGen_PduKeysMac
 *   Generates the MAC from PDU data ID and constant.
 *      Connect to a Csm Mac Generate Job which uses the PDU keys MAC key for ReadDataByIdentifier service 0x018F.
 *
 * RoutineServices_Get_Certificate_Entry
 *   Routine to read out a specific certificate entry of one of the stored certificates.
 *      Connect to DCM.
 *
 * RoutineServices_Inject_Seed
 *   Configuration Variant(s): Not in VSM.
 *
 * RoutineServices_Routine_Certificate_Self_Check
 *   Verifies the chain of trust of the stored certificates and their compatibility to the private key.
 *
 * RoutineServices_Routine_Replace_Certificates
 *   Replaces the currently stored ECU Certificate, Backend CA Certificate or Root CA Certificate. The Root CA Certificate may only be replaced together with the Backend CA Certificate. The Backend CA Certificate may only be exchanged together with the ECU Certificate. Replacement of Root or Backend certificate needs a corresponding link certificate.
 *
 * RoutineServices_Routine_SecOC_ECU_Shared_Secret_Encryption
 *   Start the generation of the shared secret and individual encryption for the passed ECU certificate. If standard shared secret is still used, a new one is generated.
 *      Configuration Variant(s): VSM only.
 *
 * RoutineServices_Routine_SecOC_ECU_TickCount_Synchronization
 *   Start the generation of the shared secret and individual encryption for the passed ECU certificate.
 *      Configuration Variant(s): VSM only.
 *
 * RoutineServices_Routine_SecOC_VSM_Derive_Symmetric_Keys
 *   Derives the symmetric key used for SecOc from the shared secret.
 *      Configuration Variant(s): VSM only.
 *
 * RoutineServices_Routine_SecOC_VSM_Renew_Shared_Secret
 *   Generates a new shared secret.
 *      Configuration Variant(s): VSM only.
 *
 * RoutineServices_Routine_SecOC_Vehicle_Shared_Secret_Distribution
 *   Triggers the transmission of a generated shared secret.
 *      Configuration Variant(s): VSM only.
 *
 * RoutineServices_Trust_Model_SecOC_ECU_Shared_Secret_Distribution
 *   Start the distribution of the shared secret - Unique ECU ID chain.
 *      Configuration Variant(s): Not in VSM.
 *
 * RoutineServices_Trust_Model_SecOC_ECU_Shared_Secret_Encryption
 *   Start the generation of the shared secret and individual encryption for the passed ECU certificate. If standard shared secret is still used, a new one is generated - Unique ECU ID chain.
 *      Configuration Variant(s): VSM only.
 *
 * RoutineServices_Trust_Model_SecOC_ECU_TickCount_Synchronization
 *   Encrypts the car-specific secret at the garage or dealership based on the Unique ECU ID chain.
 *      Never generates a new car-specific secret. Provides time synchronization information
 *      Configuration Variant(s): VSM only.
 *
 * SecLog_SuccessfulDiagServiceExecutionEvent_EcuSharedSecretEncryption
 *   Configuration Variant(s): VSM only.
 *
 * SecLog_SuccessfulDiagServiceExecutionEvent_InjectSeed
 *   Configuration Variant(s): Not in VSM.
 *
 * SecLog_SuccessfulDiagServiceExecutionEvent_TrustModelEcuSharedSecretDistribution
 *   Configuration Variant(s): Not in VSM.
 *
 * SecLog_SuccessfulDiagServiceExecutionEvent_TrustModelEcuSharedSecretEncryption
 *   Configuration Variant(s): VSM only.
 *
 * SecLog_SuccessfulDiagServiceExecutionEvent_TrustModelEcuTickcountSynchronization
 *   Configuration Variant(s): VSM only.
 *
 * SecLog_SuccessfulDiagServiceExecutionEvent_VehicleSharedSecretDistribution
 *   Configuration Variant(s): VSM only.
 *
 * SecLog_SuccessfulDiagServiceExecutionEvent_VsmDeriveSymmetricKeys
 *   Configuration Variant(s): VSM only.
 *
 * SecLog_SuccessfulDiagServiceExecutionEvent_VsmRenewSharedSecret
 *   Configuration Variant(s): VSM only.
 *
 * Ssa_VeDocRelevantInfo
 *   Requests for the VeDoc relevant information, e.g., to be used as common name in the Trust Model CSR.
 *
 *
 * Operation Prototypes:
 * =====================
 * CertificateVerifyCallbackNotification of Port Interface KeyMCertificateNotification
 *   Notifies the application that a certificate verification has been finished.
 *
 * ServiceCertificateCallbackNotification of Port Interface KeyMCertificateNotification
 *   Notifies the application that the certificate service operation has been finished. This function is used by the certificate submodule. This callback is only provided if KeyMServiceCertificateFunctionEnabled is set to TRUE.
 *
 * KeyExchangeCalcPubVal of Port Interface CsmJobKeyExchangeCalcPubVal
 *   Calculates the public value of the current user for the key exchange and stores the public key in the provided buffer.
 *
 * KeyExchangeCalcSecret of Port Interface CsmJobKeyExchangeCalcSecret
 *   Calculates the shared secret key for the key exchange with the key material of the key identified by the key and the partner public key. The shared secret key is stored as a key element in the same key.
 *
 * KeyGenerate of Port Interface CsmJobKeyGenerate
 *   Generates new key material and stores it in the key identified by key.
 *
 * RandomSeed of Port Interface CsmJobRandomSeed
 *   Utilize the random seed service.
 *
 * RandomGenerate of Port Interface CsmRandomGenerate_Random
 *   This interface shall be used to start the random generate service of the CSM module.
 *
 * Decrypt of Port Interface CsmDecrypt_AES128Decrypt
 *   This interface shall be used to start the Decrypt service of the CSM module.
 *
 * Decrypt of Port Interface CsmDecrypt_AES128DecryptWithPadding
 *   This interface shall be used to start the Decrypt service of the CSM module.
 *
 * Encrypt of Port Interface CsmEncrypt_AES128Encrypt
 *   This interface shall be used to start the Encrypt service of the CSM module.
 *
 * CertificateElementGet of Port Interface KeyMCertificateElement_Ssa_TrustModelBackendCert_Issuer
 *   Provides the content of a specific certificate element. The certificate configuration defines how the certificate submodule can find the element, e.g. by providing the object identifier (OID). This function is used to retrieve this information if only one element is assigned to the respective OID.
 *
 * CertificateElementGet of Port Interface KeyMCertificateElement_Ssa_TrustModelBackendCert_SerialNo
 *   Provides the content of a specific certificate element. The certificate configuration defines how the certificate submodule can find the element, e.g. by providing the object identifier (OID). This function is used to retrieve this information if only one element is assigned to the respective OID.
 *
 * CertificateElementGet of Port Interface KeyMCertificateElement_Ssa_TrustModelBackendCert_SubjectPublicKeyInfoKey
 *   Provides the content of a specific certificate element. The certificate configuration defines how the certificate submodule can find the element, e.g. by providing the object identifier (OID). This function is used to retrieve this information if only one element is assigned to the respective OID.
 *
 * CertificateElementGet of Port Interface KeyMCertificateElement_Ssa_TrustModelBackendCert_Version
 *   Provides the content of a specific certificate element. The certificate configuration defines how the certificate submodule can find the element, e.g. by providing the object identifier (OID). This function is used to retrieve this information if only one element is assigned to the respective OID.
 *
 * CertificateElementGet of Port Interface KeyMCertificateElement_Ssa_TrustModelBackendCert_ext_authKeyId
 *   Provides the content of a specific certificate element. The certificate configuration defines how the certificate submodule can find the element, e.g. by providing the object identifier (OID). This function is used to retrieve this information if only one element is assigned to the respective OID.
 *
 * CertificateElementGet of Port Interface KeyMCertificateElement_Ssa_TrustModelBackendCert_ext_basicConstraints
 *   Provides the content of a specific certificate element. The certificate configuration defines how the certificate submodule can find the element, e.g. by providing the object identifier (OID). This function is used to retrieve this information if only one element is assigned to the respective OID.
 *
 * CertificateElementGet of Port Interface KeyMCertificateElement_Ssa_TrustModelBackendCert_ext_subKeyId
 *   Provides the content of a specific certificate element. The certificate configuration defines how the certificate submodule can find the element, e.g. by providing the object identifier (OID). This function is used to retrieve this information if only one element is assigned to the respective OID.
 *
 * CertificateElementGet of Port Interface KeyMCertificateElement_Ssa_TrustModelBackendCert_subject
 *   Provides the content of a specific certificate element. The certificate configuration defines how the certificate submodule can find the element, e.g. by providing the object identifier (OID). This function is used to retrieve this information if only one element is assigned to the respective OID.
 *
 * CertificateElementGet of Port Interface KeyMCertificateElement_Ssa_TrustModelBackendCert_validityNotAfter
 *   Provides the content of a specific certificate element. The certificate configuration defines how the certificate submodule can find the element, e.g. by providing the object identifier (OID). This function is used to retrieve this information if only one element is assigned to the respective OID.
 *
 * CertificateElementGet of Port Interface KeyMCertificateElement_Ssa_TrustModelBackendPeerCert_SerialNo
 *   Provides the content of a specific certificate element. The certificate configuration defines how the certificate submodule can find the element, e.g. by providing the object identifier (OID). This function is used to retrieve this information if only one element is assigned to the respective OID.
 *
 * CertificateElementGet of Port Interface KeyMCertificateElement_Ssa_TrustModelBackendPeerCert_Version
 *   Provides the content of a specific certificate element. The certificate configuration defines how the certificate submodule can find the element, e.g. by providing the object identifier (OID). This function is used to retrieve this information if only one element is assigned to the respective OID.
 *
 * CertificateElementGet of Port Interface KeyMCertificateElement_Ssa_TrustModelBackendPeerCert_ext_authKeyId
 *   Provides the content of a specific certificate element. The certificate configuration defines how the certificate submodule can find the element, e.g. by providing the object identifier (OID). This function is used to retrieve this information if only one element is assigned to the respective OID.
 *
 * CertificateElementGet of Port Interface KeyMCertificateElement_Ssa_TrustModelBackendPeerCert_ext_basicConstraints
 *   Provides the content of a specific certificate element. The certificate configuration defines how the certificate submodule can find the element, e.g. by providing the object identifier (OID). This function is used to retrieve this information if only one element is assigned to the respective OID.
 *
 * CertificateElementGet of Port Interface KeyMCertificateElement_Ssa_TrustModelBackendPeerCert_ext_subKeyId
 *   Provides the content of a specific certificate element. The certificate configuration defines how the certificate submodule can find the element, e.g. by providing the object identifier (OID). This function is used to retrieve this information if only one element is assigned to the respective OID.
 *
 * CertificateElementGet of Port Interface KeyMCertificateElement_Ssa_TrustModelBackendPeerCert_validityNotAfter
 *   Provides the content of a specific certificate element. The certificate configuration defines how the certificate submodule can find the element, e.g. by providing the object identifier (OID). This function is used to retrieve this information if only one element is assigned to the respective OID.
 *
 * CertificateElementGet of Port Interface KeyMCertificateElement_Ssa_TrustModelEcuCert_Issuer
 *   Provides the content of a specific certificate element. The certificate configuration defines how the certificate submodule can find the element, e.g. by providing the object identifier (OID). This function is used to retrieve this information if only one element is assigned to the respective OID.
 *
 * CertificateElementGet of Port Interface KeyMCertificateElement_Ssa_TrustModelEcuCert_SerialNo
 *   Provides the content of a specific certificate element. The certificate configuration defines how the certificate submodule can find the element, e.g. by providing the object identifier (OID). This function is used to retrieve this information if only one element is assigned to the respective OID.
 *
 * CertificateElementGet of Port Interface KeyMCertificateElement_Ssa_TrustModelEcuCert_SubjectPublicKeyInfoKey
 *   Provides the content of a specific certificate element. The certificate configuration defines how the certificate submodule can find the element, e.g. by providing the object identifier (OID). This function is used to retrieve this information if only one element is assigned to the respective OID.
 *
 * CertificateElementGet of Port Interface KeyMCertificateElement_Ssa_TrustModelEcuCert_Version
 *   Provides the content of a specific certificate element. The certificate configuration defines how the certificate submodule can find the element, e.g. by providing the object identifier (OID). This function is used to retrieve this information if only one element is assigned to the respective OID.
 *
 * CertificateElementGet of Port Interface KeyMCertificateElement_Ssa_TrustModelEcuCert_ext_authKeyId
 *   Provides the content of a specific certificate element. The certificate configuration defines how the certificate submodule can find the element, e.g. by providing the object identifier (OID). This function is used to retrieve this information if only one element is assigned to the respective OID.
 *
 * CertificateElementGet of Port Interface KeyMCertificateElement_Ssa_TrustModelEcuCert_ext_specialEcu
 *   Provides the content of a specific certificate element. The certificate configuration defines how the certificate submodule can find the element, e.g. by providing the object identifier (OID). This function is used to retrieve this information if only one element is assigned to the respective OID.
 *
 * CertificateElementGet of Port Interface KeyMCertificateElement_Ssa_TrustModelEcuCert_ext_subKeyId
 *   Provides the content of a specific certificate element. The certificate configuration defines how the certificate submodule can find the element, e.g. by providing the object identifier (OID). This function is used to retrieve this information if only one element is assigned to the respective OID.
 *
 * CertificateElementGet of Port Interface KeyMCertificateElement_Ssa_TrustModelEcuCert_ext_uniqueECUID
 *   Provides the content of a specific certificate element. The certificate configuration defines how the certificate submodule can find the element, e.g. by providing the object identifier (OID). This function is used to retrieve this information if only one element is assigned to the respective OID.
 *
 * CertificateElementGet of Port Interface KeyMCertificateElement_Ssa_TrustModelEcuCert_subject
 *   Provides the content of a specific certificate element. The certificate configuration defines how the certificate submodule can find the element, e.g. by providing the object identifier (OID). This function is used to retrieve this information if only one element is assigned to the respective OID.
 *
 * CertificateElementGet of Port Interface KeyMCertificateElement_Ssa_TrustModelEcuCert_validityNotAfter
 *   Provides the content of a specific certificate element. The certificate configuration defines how the certificate submodule can find the element, e.g. by providing the object identifier (OID). This function is used to retrieve this information if only one element is assigned to the respective OID.
 *
 * CertificateElementGet of Port Interface KeyMCertificateElement_Ssa_TrustModelEcuPeerCert_SerialNo
 *   Provides the content of a specific certificate element. The certificate configuration defines how the certificate submodule can find the element, e.g. by providing the object identifier (OID). This function is used to retrieve this information if only one element is assigned to the respective OID.
 *
 * CertificateElementGet of Port Interface KeyMCertificateElement_Ssa_TrustModelEcuPeerCert_Version
 *   Provides the content of a specific certificate element. The certificate configuration defines how the certificate submodule can find the element, e.g. by providing the object identifier (OID). This function is used to retrieve this information if only one element is assigned to the respective OID.
 *
 * CertificateElementGet of Port Interface KeyMCertificateElement_Ssa_TrustModelEcuPeerCert_ext_authKeyId
 *   Provides the content of a specific certificate element. The certificate configuration defines how the certificate submodule can find the element, e.g. by providing the object identifier (OID). This function is used to retrieve this information if only one element is assigned to the respective OID.
 *
 * CertificateElementGet of Port Interface KeyMCertificateElement_Ssa_TrustModelEcuPeerCert_ext_specialEcu
 *   Provides the content of a specific certificate element. The certificate configuration defines how the certificate submodule can find the element, e.g. by providing the object identifier (OID). This function is used to retrieve this information if only one element is assigned to the respective OID.
 *
 * CertificateElementGet of Port Interface KeyMCertificateElement_Ssa_TrustModelEcuPeerCert_ext_subKeyId
 *   Provides the content of a specific certificate element. The certificate configuration defines how the certificate submodule can find the element, e.g. by providing the object identifier (OID). This function is used to retrieve this information if only one element is assigned to the respective OID.
 *
 * CertificateElementGet of Port Interface KeyMCertificateElement_Ssa_TrustModelEcuPeerCert_validityNotAfter
 *   Provides the content of a specific certificate element. The certificate configuration defines how the certificate submodule can find the element, e.g. by providing the object identifier (OID). This function is used to retrieve this information if only one element is assigned to the respective OID.
 *
 * CertificateElementGet of Port Interface KeyMCertificateElement_Ssa_TrustModelIntermediateCert_Issuer
 *   Provides the content of a specific certificate element. The certificate configuration defines how the certificate submodule can find the element, e.g. by providing the object identifier (OID). This function is used to retrieve this information if only one element is assigned to the respective OID.
 *
 * CertificateElementGet of Port Interface KeyMCertificateElement_Ssa_TrustModelIntermediateCert_SerialNo
 *   Provides the content of a specific certificate element. The certificate configuration defines how the certificate submodule can find the element, e.g. by providing the object identifier (OID). This function is used to retrieve this information if only one element is assigned to the respective OID.
 *
 * CertificateElementGet of Port Interface KeyMCertificateElement_Ssa_TrustModelIntermediateCert_SubjectPublicKeyInfoKey
 *   Provides the content of a specific certificate element. The certificate configuration defines how the certificate submodule can find the element, e.g. by providing the object identifier (OID). This function is used to retrieve this information if only one element is assigned to the respective OID.
 *
 * CertificateElementGet of Port Interface KeyMCertificateElement_Ssa_TrustModelIntermediateCert_Version
 *   Provides the content of a specific certificate element. The certificate configuration defines how the certificate submodule can find the element, e.g. by providing the object identifier (OID). This function is used to retrieve this information if only one element is assigned to the respective OID.
 *
 * CertificateElementGet of Port Interface KeyMCertificateElement_Ssa_TrustModelIntermediateCert_ext_authKeyId
 *   Provides the content of a specific certificate element. The certificate configuration defines how the certificate submodule can find the element, e.g. by providing the object identifier (OID). This function is used to retrieve this information if only one element is assigned to the respective OID.
 *
 * CertificateElementGet of Port Interface KeyMCertificateElement_Ssa_TrustModelIntermediateCert_ext_basicConstraints
 *   Provides the content of a specific certificate element. The certificate configuration defines how the certificate submodule can find the element, e.g. by providing the object identifier (OID). This function is used to retrieve this information if only one element is assigned to the respective OID.
 *
 * CertificateElementGet of Port Interface KeyMCertificateElement_Ssa_TrustModelIntermediateCert_ext_subKeyId
 *   Provides the content of a specific certificate element. The certificate configuration defines how the certificate submodule can find the element, e.g. by providing the object identifier (OID). This function is used to retrieve this information if only one element is assigned to the respective OID.
 *
 * CertificateElementGet of Port Interface KeyMCertificateElement_Ssa_TrustModelIntermediateCert_subject
 *   Provides the content of a specific certificate element. The certificate configuration defines how the certificate submodule can find the element, e.g. by providing the object identifier (OID). This function is used to retrieve this information if only one element is assigned to the respective OID.
 *
 * CertificateElementGet of Port Interface KeyMCertificateElement_Ssa_TrustModelIntermediateCert_validityNotAfter
 *   Provides the content of a specific certificate element. The certificate configuration defines how the certificate submodule can find the element, e.g. by providing the object identifier (OID). This function is used to retrieve this information if only one element is assigned to the respective OID.
 *
 * CertificateElementGet of Port Interface KeyMCertificateElement_Ssa_TrustModelIntermediatePeerCert_SerialNo
 *   Provides the content of a specific certificate element. The certificate configuration defines how the certificate submodule can find the element, e.g. by providing the object identifier (OID). This function is used to retrieve this information if only one element is assigned to the respective OID.
 *
 * CertificateElementGet of Port Interface KeyMCertificateElement_Ssa_TrustModelIntermediatePeerCert_Version
 *   Provides the content of a specific certificate element. The certificate configuration defines how the certificate submodule can find the element, e.g. by providing the object identifier (OID). This function is used to retrieve this information if only one element is assigned to the respective OID.
 *
 * CertificateElementGet of Port Interface KeyMCertificateElement_Ssa_TrustModelIntermediatePeerCert_ext_authKeyId
 *   Provides the content of a specific certificate element. The certificate configuration defines how the certificate submodule can find the element, e.g. by providing the object identifier (OID). This function is used to retrieve this information if only one element is assigned to the respective OID.
 *
 * CertificateElementGet of Port Interface KeyMCertificateElement_Ssa_TrustModelIntermediatePeerCert_ext_basicConstraints
 *   Provides the content of a specific certificate element. The certificate configuration defines how the certificate submodule can find the element, e.g. by providing the object identifier (OID). This function is used to retrieve this information if only one element is assigned to the respective OID.
 *
 * CertificateElementGet of Port Interface KeyMCertificateElement_Ssa_TrustModelIntermediatePeerCert_ext_subKeyId
 *   Provides the content of a specific certificate element. The certificate configuration defines how the certificate submodule can find the element, e.g. by providing the object identifier (OID). This function is used to retrieve this information if only one element is assigned to the respective OID.
 *
 * CertificateElementGet of Port Interface KeyMCertificateElement_Ssa_TrustModelIntermediatePeerCert_validityNotAfter
 *   Provides the content of a specific certificate element. The certificate configuration defines how the certificate submodule can find the element, e.g. by providing the object identifier (OID). This function is used to retrieve this information if only one element is assigned to the respective OID.
 *
 * CertificateElementGet of Port Interface KeyMCertificateElement_Ssa_TrustModelRootCert_Issuer
 *   Provides the content of a specific certificate element. The certificate configuration defines how the certificate submodule can find the element, e.g. by providing the object identifier (OID). This function is used to retrieve this information if only one element is assigned to the respective OID.
 *
 * CertificateElementGet of Port Interface KeyMCertificateElement_Ssa_TrustModelRootCert_SerialNo
 *   Provides the content of a specific certificate element. The certificate configuration defines how the certificate submodule can find the element, e.g. by providing the object identifier (OID). This function is used to retrieve this information if only one element is assigned to the respective OID.
 *
 * CertificateElementGet of Port Interface KeyMCertificateElement_Ssa_TrustModelRootCert_SubjectPublicKeyInfoKey
 *   Provides the content of a specific certificate element. The certificate configuration defines how the certificate submodule can find the element, e.g. by providing the object identifier (OID). This function is used to retrieve this information if only one element is assigned to the respective OID.
 *
 * CertificateElementGet of Port Interface KeyMCertificateElement_Ssa_TrustModelRootCert_Version
 *   Provides the content of a specific certificate element. The certificate configuration defines how the certificate submodule can find the element, e.g. by providing the object identifier (OID). This function is used to retrieve this information if only one element is assigned to the respective OID.
 *
 * CertificateElementGet of Port Interface KeyMCertificateElement_Ssa_TrustModelRootCert_ext_basicConstraints
 *   Provides the content of a specific certificate element. The certificate configuration defines how the certificate submodule can find the element, e.g. by providing the object identifier (OID). This function is used to retrieve this information if only one element is assigned to the respective OID.
 *
 * CertificateElementGet of Port Interface KeyMCertificateElement_Ssa_TrustModelRootCert_ext_keyUsage
 *   Provides the content of a specific certificate element. The certificate configuration defines how the certificate submodule can find the element, e.g. by providing the object identifier (OID). This function is used to retrieve this information if only one element is assigned to the respective OID.
 *
 * CertificateElementGet of Port Interface KeyMCertificateElement_Ssa_TrustModelRootCert_ext_subKeyId
 *   Provides the content of a specific certificate element. The certificate configuration defines how the certificate submodule can find the element, e.g. by providing the object identifier (OID). This function is used to retrieve this information if only one element is assigned to the respective OID.
 *
 * CertificateElementGet of Port Interface KeyMCertificateElement_Ssa_TrustModelRootCert_subject
 *   Provides the content of a specific certificate element. The certificate configuration defines how the certificate submodule can find the element, e.g. by providing the object identifier (OID). This function is used to retrieve this information if only one element is assigned to the respective OID.
 *
 * CertificateElementGet of Port Interface KeyMCertificateElement_Ssa_TrustModelRootCert_validityNotAfter
 *   Provides the content of a specific certificate element. The certificate configuration defines how the certificate submodule can find the element, e.g. by providing the object identifier (OID). This function is used to retrieve this information if only one element is assigned to the respective OID.
 *
 * GetStatus of Port Interface KeyMCertificate_Ssa_TrustModelBackendCert
 *   Provides the status of a certificate.
 *
 * GetStatus of Port Interface KeyMCertificate_Ssa_TrustModelBackendPeerCert
 *   Provides the status of a certificate.
 *
 * GetStatus of Port Interface KeyMCertificate_Ssa_TrustModelEcuCert
 *   Provides the status of a certificate.
 *
 * VerifyCertificate of Port Interface KeyMCertificate_Ssa_TrustModelEcuCert
 *   Verify certificate data from the certificate sub module .
 *
 * GetStatus of Port Interface KeyMCertificate_Ssa_TrustModelEcuPeerCert
 *   Provides the status of a certificate.
 *
 * VerifyCertificate of Port Interface KeyMCertificate_Ssa_TrustModelEcuPeerCert
 *   Verify certificate data from the certificate sub module .
 *
 * GetStatus of Port Interface KeyMCertificate_Ssa_TrustModelIntermediateCert
 *   Provides the status of a certificate.
 *
 * GetStatus of Port Interface KeyMCertificate_Ssa_TrustModelIntermediatePeerCert
 *   Provides the status of a certificate.
 *
 * GetStatus of Port Interface KeyMCertificate_Ssa_TrustModelRootCert
 *   Provides the status of a certificate.
 *
 * KeyElementSet of Port Interface CsmKeyManagement_Ssa_AesRamKey
 *   Sets the given key element bytes to the key.
 *
 * KeySetValid of Port Interface CsmKeyManagement_Ssa_AesRamKey
 *   Sets the given key element bytes to the key.
 *
 * KeyElementGet of Port Interface CsmKeyManagement_Ssa_BackendCert
 *   Retrieves the key element bytes from a specific key element of the key and stores the key element in the provided buffer.
 *
 * KeyElementGet of Port Interface CsmKeyManagement_Ssa_EcuCert
 *   Retrieves the key element bytes from a specific key element of the key and stores the key element in the provided buffer.
 *
 * KeySetValid of Port Interface CsmKeyManagement_Ssa_RandomSeed
 *   Sets the given key element bytes to the key.
 *
 * RandomSeed of Port Interface CsmKeyManagement_Ssa_RandomSeed
 *   Feeds a key element with a random seed.
 *
 * KeyElementGet of Port Interface CsmKeyManagement_Ssa_RootCert
 *   Retrieves the key element bytes from a specific key element of the key and stores the key element in the provided buffer.
 *
 * KeyElementGet of Port Interface CsmKeyManagement_Ssa_SharedSecret
 *   Retrieves the key element bytes from a specific key element of the key and stores the key element in the provided buffer.
 *
 * KeyElementSet of Port Interface CsmKeyManagement_Ssa_SharedSecret
 *   Sets the given key element bytes to the key.
 *
 * KeySetValid of Port Interface CsmKeyManagement_Ssa_SharedSecret
 *   Sets the given key element bytes to the key.
 *
 * KeyElementGet of Port Interface CsmKeyManagement_Ssa_SharedSecretHash
 *   Retrieves the key element bytes from a specific key element of the key and stores the key element in the provided buffer.
 *
 * KeyElementSet of Port Interface CsmKeyManagement_Ssa_SharedSecretHash
 *   Sets the given key element bytes to the key.
 *
 * KeySetValid of Port Interface CsmKeyManagement_Ssa_SharedSecretHash
 *   Sets the given key element bytes to the key.
 *
 * KeyElementGet of Port Interface CsmKeyManagement_Ssa_SharedSecretKeyExchange
 *   Retrieves the key element bytes from a specific key element of the key and stores the key element in the provided buffer.
 *
 * KeyElementSet of Port Interface CsmKeyManagement_Ssa_SharedSecretKeyExchange
 *   Sets the given key element bytes to the key.
 *
 * KeyExchangeCalcPubVal of Port Interface CsmKeyManagement_Ssa_SharedSecretKeyExchange
 *   Calculates the public value of the current user for the key exchange and stores the public key in the provided buffer.
 *
 * KeyExchangeCalcSecret of Port Interface CsmKeyManagement_Ssa_SharedSecretKeyExchange
 *   Calculates the shared secret key for the key exchange with the key material of the key identified by the keyId and the partner public key. The shared secret key is stored as a key element in the same key.
 *
 * KeySetValid of Port Interface CsmKeyManagement_Ssa_SharedSecretKeyExchange
 *   Sets the given key element bytes to the key.
 *
 * KeyElementSet of Port Interface CsmKeyManagement_Ssa_SignatureRamKey
 *   Sets the given key element bytes to the key.
 *
 * KeySetValid of Port Interface CsmKeyManagement_Ssa_SignatureRamKey
 *   Sets the given key element bytes to the key.
 *
 * KeyElementCopy of Port Interface CsmKeyManagement_Ssa_TrustModelEcuCsrPrivateKey
 *   This function shall copy a key elements from one key to a target key.
 *
 * KeyGenerate of Port Interface CsmKeyManagement_Ssa_TrustModelEcuCsrPrivateKey
 *   Generates new key material and store it in the key identified by keyId.
 *
 * KeySetValid of Port Interface CsmKeyManagement_Ssa_TrustModelEcuCsrPrivateKey
 *   Sets the given key element bytes to the key.
 *
 * KeyElementCopy of Port Interface CsmKeyManagement_Ssa_TrustModelEcuCsrPublicKey
 *   This function shall copy a key elements from one key to a target key.
 *
 * KeyElementGet of Port Interface CsmKeyManagement_Ssa_TrustModelEcuCsrPublicKey
 *   Retrieves the key element bytes from a specific key element of the key and stores the key element in the provided buffer.
 *
 * KeySetValid of Port Interface CsmKeyManagement_Ssa_TrustModelEcuCsrPublicKey
 *   Sets the given key element bytes to the key.
 *
 * KeySetValid of Port Interface CsmKeyManagement_Ssa_TrustModelEcuLivePrivateKey
 *   Sets the given key element bytes to the key.
 *
 * KeyElementGet of Port Interface CsmKeyManagement_Ssa_TrustModelEcuLivePublicKey
 *   Retrieves the key element bytes from a specific key element of the key and stores the key element in the provided buffer.
 *
 * KeyElementCopy of Port Interface CsmKeyManagement_Ssa_TrustModelEcuStagingPrivateKey
 *   This function shall copy a key elements from one key to a target key.
 *
 * KeySetValid of Port Interface CsmKeyManagement_Ssa_TrustModelEcuStagingPrivateKey
 *   Sets the given key element bytes to the key.
 *
 * KeyElementCopy of Port Interface CsmKeyManagement_Ssa_TrustModelEcuStagingPublicKey
 *   This function shall copy a key elements from one key to a target key.
 *
 * KeySetValid of Port Interface CsmKeyManagement_Ssa_TrustModelEcuStagingPublicKey
 *   Sets the given key element bytes to the key.
 *
 * KeyElementGet of Port Interface CsmKeyManagement_Ssa_SigPubKey_ReplacementAuthority
 *   Retrieves the key element bytes from a specific key element of the key and stores the key element in the provided buffer.
 *
 * KeyElementGet of Port Interface CsmKeyManagement_Ssa_TrustModelTempPublicKey
 *   Retrieves the key element bytes from a specific key element of the key and stores the key element in the provided buffer.
 *
 * KeyElementSet of Port Interface CsmKeyManagement_Ssa_TrustModelTempPublicKey
 *   Sets the given key element bytes to the key.
 *
 * KeySetValid of Port Interface CsmKeyManagement_Ssa_TrustModelTempPublicKey
 *   Sets the given key element bytes to the key.
 *
 * MacGenerate of Port Interface CsmMacGenerate_MacGenAesCmac
 *   This interface shall be used to start the MAC generation service of the CSM module.
 *
 *
 * Mode Declaration Groups:
 * ========================
 * Coding_MemoryStatus
 *   Notifies the Ssa of memory status changes while storing or restoring the Variant Coding Data to or from non-volatile memory.
 *
 * Coding_Mode
 *   Notifies application about an ongoing, successful or failed coding attempt.
 *
 * RightsM_AuthenticationMode
 *   RIGHTSM_AUTHENTICATED - A Tester was successfully authenticated
 *      RIGHTSM_UNAUTHENTICATED - No tester was authenticated
 *
 * Ssa_MacKeyGeneration_State
 *   Notifies application of whether the generation of the symmetric MAC keys is OFF or ON.
 *
 *
 * Runnable Entities:
 * ==================
 * Ssa_KeyM_Com_VehicleSharedSecretNotification
 *   Is called by Com when the broadcast message containing the car-specific secret signal is received.
 *      Configuration Variant(s): Not in VSM.
 *
 * Ssa_KeyM_CsmCallbackNotification_KeyExchangeCalcPubVal
 *   Configuration Variant(s): Asynchronous key management job processing.
 *
 * Ssa_KeyM_CsmCallbackNotification_KeyExchangeCalcSecret
 *   Configuration Variant(s): Asynchronous key management job processing.
 *
 * Ssa_KeyM_CsmCallbackNotification_KeyGenerate_TrustModelEcuCsr
 *   Configuration Variant(s): Asynchronous key management job processing.
 *
 * Ssa_KeyM_CsmCallbackNotification_RandomGenerate
 *   Configuration Variant(s): Asynchronous job processing.
 *
 * Ssa_KeyM_CsmCallbackNotification_RandomSeed
 *   Configuration Variant(s): Asynchronous key management job processing.
 *      Configuration Variant(s): Not in VSM.
 *
 * Ssa_KeyM_CsmCallbackNotification_SignatureGenerate
 *   Configuration Variant(s): Asynchronous job processing.
 *      Configuration Variant(s): VSM only.
 *
 * Ssa_KeyM_CsmCallbackNotification_SignatureGenerate_TrustModelEcuCsr
 *   Configuration Variant(s): Asynchronous job processing.
 *
 * Ssa_KeyM_CsmCallbackNotification_SignatureGenerate_TrustModelEcuLive
 *   Configuration Variant(s): Asynchronous job processing.
 *
 * Ssa_KeyM_CsmCallbackNotification_SignatureVerify
 *   Configuration Variant(s): Asynchronous job processing.
 *
 * Ssa_KeyM_CsmCallbackNotification_SignatureVerify_ReplacementAuthority
 *   Configuration Variant(s): Asynchronous job processing.
 *
 * Ssa_KeyM_CsmCallbackNotification_SignatureVerify_TrustModelBackend
 *   Configuration Variant(s): Asynchronous job processing.
 *      Configuration Variant(s): Not in VSM.
 *
 * Ssa_KeyM_CsmCallbackNotification_SignatureVerify_TrustModelTemp
 *   Configuration Variant(s): Asynchronous job processing.
 *
 * Ssa_KeyM_DataServices_DID_0193_Common_Name_ConditionCheckRead
 *   Configuration Variant(s): VSM only.
 *
 * Ssa_KeyM_DataServices_DID_0193_Common_Name_ReadData
 *   Configuration Variant(s): VSM only.
 *
 * Ssa_KeyM_DataServices_DID_0193_SerialNumber_ConditionCheckRead
 *   Configuration Variant(s): VSM only.
 *
 * Ssa_KeyM_DataServices_DID_0193_SerialNumber_ReadData
 *   Configuration Variant(s): VSM only.
 *
 * Ssa_KeyM_DataServices_DID_0193_SubjectKeyIdentifier_ConditionCheckRead
 *   Configuration Variant(s): VSM only.
 *
 * Ssa_KeyM_DataServices_DID_0193_SubjectKeyIdentifier_ReadData
 *   Configuration Variant(s): VSM only.
 *
 * Ssa_KeyM_DataServices_DID_0193_SubjectPublicKeyInfo_ConditionCheckRead
 *   Configuration Variant(s): VSM only.
 *
 * Ssa_KeyM_DataServices_DID_0193_SubjectPublicKeyInfo_ReadData
 *   Configuration Variant(s): VSM only.
 *
 * Ssa_KeyM_DataServices_DID_0194_ECC_CA_Certificate_Identification_ConditionCheckRead
 *   Configuration Variant(s): VSM only.
 *
 * Ssa_KeyM_DataServices_DID_0194_ECC_CA_Certificate_Identification_ReadData
 *   Configuration Variant(s): VSM only.
 *
 * Ssa_KeyM_DataServices_DID_0199_Certificates_ConditionCheckRead
 *   Configuration Variant(s): Not in VSM.
 *
 * Ssa_KeyM_DataServices_DID_0199_Certificates_ReadData
 *   Configuration Variant(s): Not in VSM.
 *
 * Ssa_KeyM_DataServices_DID_0199_Certificates_ReadDataLength
 *   Configuration Variant(s): Not in VSM.
 *
 * Ssa_KeyM_DataServices_DID_0199_Data_Signature_ConditionCheckRead
 *   Configuration Variant(s): Not in VSM.
 *
 * Ssa_KeyM_DataServices_DID_0199_Data_Signature_ReadData
 *   Configuration Variant(s): Not in VSM.
 *
 * Ssa_KeyM_DataServices_DID_0199_Ephemeral_ECU_Public_Key_ConditionCheckRead
 *   Configuration Variant(s): Not in VSM.
 *
 * Ssa_KeyM_DataServices_DID_0199_Ephemeral_ECU_Public_Key_ReadData
 *   Configuration Variant(s): Not in VSM.
 *
 * Ssa_KeyM_DataServices_DID_0199_Nonce_ConditionCheckRead
 *   Configuration Variant(s): Not in VSM.
 *
 * Ssa_KeyM_DataServices_DID_0199_Nonce_ReadData
 *   Configuration Variant(s): Not in VSM.
 *
 * Ssa_KeyM_DataServices_ECU_Certificate_Read_Data_Signature_ConditionCheckRead
 *   Configuration Variant(s): VSM only.
 *
 * Ssa_KeyM_DataServices_ECU_Certificate_Read_Data_Signature_ReadData
 *   Configuration Variant(s): VSM only.
 *
 * Ssa_KeyM_DataServices_ECU_Certificate_Read_ECU_Certificate_ConditionCheckRead
 *   Configuration Variant(s): VSM only.
 *
 * Ssa_KeyM_DataServices_ECU_Certificate_Read_ECU_Certificate_ReadData
 *   Configuration Variant(s): VSM only.
 *
 * Ssa_KeyM_DataServices_ECU_Certificate_Read_ECU_Certificate_ReadDataLength
 *   Configuration Variant(s): VSM only.
 *
 * Ssa_KeyM_DataServices_ECU_Certificate_Read_Ephemeral_ECU_Public_Key_ConditionCheckRead
 *   Configuration Variant(s): VSM only.
 *
 * Ssa_KeyM_DataServices_ECU_Certificate_Read_Ephemeral_ECU_Public_Key_ReadData
 *   Configuration Variant(s): VSM only.
 *
 * Ssa_KeyM_DataServices_ECU_Certificate_Read_Nonce_ConditionCheckRead
 *   Configuration Variant(s): VSM only.
 *
 * Ssa_KeyM_DataServices_ECU_Certificate_Read_Nonce_ReadData
 *   Configuration Variant(s): VSM only.
 *
 * Ssa_KeyM_RoutineServices_Inject_Seed
 *   Configuration Variant(s): Not in VSM.
 *
 * Ssa_KeyM_RoutineServices_Routine_SecOC_ECU_Shared_Secret_Encryption
 *   Configuration Variant(s): VSM only.
 *
 * Ssa_KeyM_RoutineServices_Routine_SecOC_ECU_TickCount_Synchronization
 *   Configuration Variant(s): VSM only.
 *
 * Ssa_KeyM_RoutineServices_Routine_SecOC_VSM_Derive_Symmetric_Keys
 *   Configuration Variant(s): VSM only.
 *
 * Ssa_KeyM_RoutineServices_Routine_SecOC_VSM_Renew_Shared_Secret
 *   Configuration Variant(s): VSM only.
 *
 * Ssa_KeyM_RoutineServices_Routine_SecOC_Vehicle_Shared_Secret_Distribution
 *   Configuration Variant(s): VSM only.
 *
 * Ssa_KeyM_RoutineServices_Trust_Model_SecOC_ECU_Shared_Secret_Distribution
 *   Configuration Variant(s): Not in VSM.
 *
 * Ssa_KeyM_RoutineServices_Trust_Model_SecOC_ECU_Shared_Secret_Encryption
 *   Configuration Variant(s): VSM only.
 *
 * Ssa_KeyM_RoutineServices_Trust_Model_SecOC_ECU_TickCount_Synchronization
 *   Configuration Variant(s): VSM only.
 *
 *********************************************************************************************************************/

#include "Rte_Ssa_KeyM.h"


/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << Start of include and declaration area >>        DO NOT CHANGE THIS COMMENT!
 *********************************************************************************************************************/

/**********************************************************************************************************************
 *  INCLUDES
 **********************************************************************************************************************/
#include "Ssa_Cfg.h"
#include "Ssa_Utils.h"

#ifdef __VCA__  /* COV_SSA_VECTOR_CODE_ANALYZER_STUB_REDIRECTION */
# include "Ssa_KeyM_Redirection.vcaspecs.h"
#endif

/* After this comment only memory mapping files may be included. Due to this turn off lint rule requesting a standard
include guard. */
/*lint -e451 */

/**********************************************************************************************************************
 *  LOCAL CONSTANT MACROS
 **********************************************************************************************************************/
#if !defined (SSA_KEYM_LOCAL)                   /* COV_SSA_LOCAL */
# define SSA_KEYM_LOCAL                                               static
#endif

#if !defined (SSA_KEYM_LOCAL_INLINE)            /* COV_SSA_LOCAL_INLINE */
# define SSA_KEYM_LOCAL_INLINE                                        LOCAL_INLINE
#endif

/*! Fragment definitions of DER encoded key extensions used for creating the CSR. */
#if !defined (SSA_KEYM_CSR_EXT_SPECIALECU)            /* COV_SSA_OVERWRITEABLE TX */
# define SSA_KEYM_CSR_EXT_SPECIALECU                                  0x04, 0x03, 0x04, 0x01, 0x01
#endif

/*! Size of array used for the DER encoded UniqueEcuIds. */
/* - Each unique ECU ID is at most of length 30 bytes.
 *   Thus, 2 additional bytes for [tag | length] are required per ECU ID --> (2u*SSA_SECLOG_NUMBER_OF_UNIQUE_ECU_IDS)
 * - The ECU IDs themselves are also part of the encoded data --> SSA_SECLOG_LENGTH_OF_ALL_UNIQUE_ECU_IDS
 * - The set [tag | length | ECU ID 1 | tag | length | ECU ID 2 | ... | tag | length | ECU ID n] is
 *   encoded as octet string.
 *   Therefore, at most 4 bytes of [octet string tag | length tag | length byte 1 | length byte 2]
 *   are required. --> + 4 
 * - The octet string itself is again encoded. Again, at most 4 addition bytes are required for that.
 *   --> + 4 (--> in total + 8)
 * Hint for silent analysis: A runtime check in KeyM_GetNumBytesNeededForEncodingUniqueEcuIds() ensures,
 * that no unique ECU ID is longer than 30 bytes.
 * A compile time assertion (see below) ensures that the number of configured ECU IDs does not exceed 255. */
#define SSA_SIZEOF_ENCODED_UNIQUEECUIDS                               ((uint16)(SSA_SECLOG_LENGTH_OF_ALL_UNIQUE_ECU_IDS + (2u* SSA_SECLOG_NUMBER_OF_UNIQUE_ECU_IDS) + 8u))
#define SSA_MAX_SIZEOF_UNIQUEECUID                                    (30u)

#define SSA_DER_ENCODING_TAG_OCTET_STRING                             (0x4u)
#define SSA_DER_ENCODING_TAG_SET                                      (0x31u)
#define SSA_DER_ENCODING_TAG_UTF8_STRING                              (0x0Cu)

/* LOCAL DATA MACROS */
/* Negatives response codes to DCM */
#define KEYM_DCM_NRC_CHALLENGE_CALCULATION_FAILED                     (0x59u)

/*! Verification result for routine service Replace_Certificates */
#define KEYM_VER_RES_CERT_VERIFIED_AND_REPLACED                       (0u)

#define KEYM_REPLACE_NO_CERT                                          (0u)
#define KEYM_REPLACE_CERT_ECU_ONLY                                    (1u) /* ECU(Only VSM) */
#define KEYM_REPLACE_CERT_BACKEND_AND_LOWER                           (2u) /* BACKEND -> ECU(Only VSM) */
#define KEYM_REPLACE_CERT_ROOT_AND_LOWER                              (3u) /* ROOT -> BACKEND -> ECU(Only VSM) */

#define KEYM_ECU_CERT                                                 (0u)
#define KEYM_BACKEND_CERT                                             (1u)
#define KEYM_ROOT_CERT                                                (2u)

#define SSA_KEYM_DIS_POSITION_DATE_AND_TIME                           (0u)
#define SSA_KEYM_DIS_POSITION_TICKCOUNT                               (SSA_KEYM_DIS_POSITION_DATE_AND_TIME + SSA_SIZEOF_REALTIME)
#define SSA_KEYM_DIS_POSITION_TICKCOUNTOFFSET                         (SSA_KEYM_DIS_POSITION_TICKCOUNT + SSA_SIZEOF_TICKCOUNT)
#define SSA_KEYM_DIS_POSITION_ENCRYPTED_NONCE_AND_SECRET              (SSA_KEYM_DIS_POSITION_TICKCOUNTOFFSET + SSA_SIZEOF_TICKCOUNT)
#define SSA_KEYM_DIS_POSITION_EPHEMERAL_PUBLIC_KEY                    (SSA_KEYM_DIS_POSITION_ENCRYPTED_NONCE_AND_SECRET + SSA_SIZEOF_ENCRYPTED_NONCE_AND_SECRET)
#define SSA_KEYM_DIS_POSITION_DECRYPTED_SECRET                        (SSA_KEYM_DIS_POSITION_ENCRYPTED_NONCE_AND_SECRET + SSA_SIZEOF_NONCE)
#define SSA_KEYM_DIS_BUFFER_SIZE                                      (SSA_KEYM_DIS_POSITION_EPHEMERAL_PUBLIC_KEY + SSA_SIZEOF_PUBLICKEY)

#define SSA_KEYM_SEEDMATERIAL_POSITION_ENTROPY                        (0u)
#define SSA_KEYM_SEEDMATERIAL_POSITION_PERSONALIZATION_STRING         (SSA_KEYM_SEEDMATERIAL_POSITION_ENTROPY + SSA_SIZEOF_HASHVALUE)
#define SSA_KEYM_SEEDMATERIAL_POSITION_ADDITIONAL_INPUT_VIN           (SSA_KEYM_SEEDMATERIAL_POSITION_PERSONALIZATION_STRING + SSA_SIZEOF_HASHVALUE)
#define SSA_KEYM_SEEDMATERIAL_POSITION_NONCE                          (SSA_KEYM_SEEDMATERIAL_POSITION_ADDITIONAL_INPUT_VIN + SSA_SIZEOF_VIN)
#define SSA_SIZEOF_SEEDMATERIAL                                       (SSA_KEYM_SEEDMATERIAL_POSITION_NONCE + SSA_SIZEOF_HASHVALUE)

/* Size defines for Key CMACs ReadData */
#define SSA_KEYM_SIZEOF_CMAC                                          (16u)
#define SSA_KEYM_SIZEOF_DATA_ID                                       (2u)
#define SSA_KEYM_KEY_CMAC_SIZEOF_KEY_CMAC_CONSTANT                    (16u)
#define SSA_KEYM_KEY_CMAC_SIZEOF_TRUNCATED_MAC                        (4u)
#define SSA_KEYM_KEY_CMAC_SIZEOF_DATA_PRO_DATA_ID                     (SSA_KEYM_SIZEOF_DATA_ID+SSA_KEYM_KEY_CMAC_SIZEOF_TRUNCATED_MAC)

/* Routine Controls: Values for Verification_Result parameter */
#define KEYM_RES_GENERATION_OF_CAR_SPECIFIC_SECRET_FAILED             (0x20u)

/* SpecialECU identifiers qualifyng ECU certificates for special use cases */
#define SSA_SPECIALECU_ID_VSM                                         (0x01u)
#define SSA_SPECIALECU_ID_NONSECOC_IS                                 (0x02u)

/*! Invalid return value. */
#define KEYM_NO_RETVAL                                                (0xFFu)
/* The following conditions must true. See compile time assertion. */
#define KEYM_NO_RETVAL_COND1                                          (KEYM_NO_RETVAL != RTE_E_OK)
#define KEYM_NO_RETVAL_COND2                                          (KEYM_NO_RETVAL != RTE_E_RoutineServices_Routine_Certificate_Self_Check_E_NOT_OK)
#define KEYM_NO_RETVAL_COND3                                          (KEYM_NO_RETVAL != RTE_E_RoutineServices_Routine_Certificate_Self_Check_DCM_E_PENDING)

/*! States for asynchronous handling of data service ECU_Certificate_Read_Data_Signature_ReadData. */
#define KEYM_GEN_SIG_STATE_IDLE                                                                       (0u)
#define KEYM_GEN_SIG_STATE_GENERATE                                                                   (1u)

/*! States for asynchronous handling of routine service Replace_Certificates. */
#define KEYM_REPLACE_CERT_STATE_IDLE                                                                  (0u)
#define KEYM_REPLACE_CERT_STATE_REPLACE                                                               (1u)
#define KEYM_REPLACE_CERT_STATE_STORE_INIT                                                            (2u)
#define KEYM_REPLACE_CERT_STATE_STORE_PENDING                                                         (3u)

/*! States for asynchronous handling of routine service Certificate_Self_Check. */
#define KEYM_CERTIFICATE_SELFCHECK_STATE_IDLE                                                         (0u)
#define KEYM_CERTIFICATE_SELFCHECK_STATE_DIAGCHAIN                                                    (0x10u)
#define KEYM_CERTIFICATE_SELFCHECK_STATE_VERIFY_ROOT_CA_CERT                                          (KEYM_CERTIFICATE_SELFCHECK_STATE_DIAGCHAIN)
#define KEYM_CERTIFICATE_SELFCHECK_STATE_VERIFY_BACKEND_CA_CERT                                       (KEYM_CERTIFICATE_SELFCHECK_STATE_DIAGCHAIN | 0x01u)
#define KEYM_CERTIFICATE_SELFCHECK_STATE_VERIFY_ECU_CERT                                              (KEYM_CERTIFICATE_SELFCHECK_STATE_DIAGCHAIN | 0x02u)
#define KEYM_CERTIFICATE_SELFCHECK_STATE_CHECK_PRIVATE_KEY_ACCESSIBILITY                              (KEYM_CERTIFICATE_SELFCHECK_STATE_DIAGCHAIN | 0x03u)
#define KEYM_CERTIFICATE_SELFCHECK_STATE_VERIFY_PRIVATE_KEY                                           (KEYM_CERTIFICATE_SELFCHECK_STATE_DIAGCHAIN | 0x04u)
#define KEYM_CERTIFICATE_SELFCHECK_STATE_ECUIDCHAIN                                                   (0x20u)
#define KEYM_CERTIFICATE_SELFCHECK_STATE_VERIFY_TRUST_MODEL_CERT_CHAIN                                (KEYM_CERTIFICATE_SELFCHECK_STATE_ECUIDCHAIN)
#define KEYM_CERTIFICATE_SELFCHECK_STATE_VERIFY_TRUST_MODEL_CERT_CHAIN_GET_STATUS                     (KEYM_CERTIFICATE_SELFCHECK_STATE_ECUIDCHAIN | 0x01u)
#define KEYM_CERTIFICATE_SELFCHECK_STATE_UPDATE_ROOT                                                  (KEYM_CERTIFICATE_SELFCHECK_STATE_ECUIDCHAIN | 0x02u)
#define KEYM_CERTIFICATE_SELFCHECK_STATE_AWAITING_VERIFICATION_RESULT_CERT_CHAIN                      (KEYM_CERTIFICATE_SELFCHECK_STATE_ECUIDCHAIN | 0x03u)
#define KEYM_CERTIFICATE_SELFCHECK_STATE_VERIFY_TRUST_MODEL_PRIVATE_KEY                               (KEYM_CERTIFICATE_SELFCHECK_STATE_ECUIDCHAIN | 0x04u)

/*! States for asynchronous handling of routine service SecOC_ECU_Shared_Secret_Distribution. */
#define KEYM_ROUTINE_SECOC_ECU_SHARED_SECRET_DIST_STATE_IDLE                                          (0u)
#define KEYM_ROUTINE_SECOC_ECU_SHARED_SECRET_DIST_STATE_VERIFY_SIGNATURE                              (1u)
#define KEYM_ROUTINE_SECOC_ECU_SHARED_SECRET_DIST_STATE_KEYEXCHANGE_DECRYPT                           (2u)
#define KEYM_ROUTINE_SECOC_ECU_SHARED_SECRET_DIST_STATE_DERIVE_SECOC_KEYS                             (3u)
#define KEYM_ROUTINE_SECOC_ECU_SHARED_SECRET_DIST_STATE_WAIT_AND_SET_NEW_TIME                         (4u)
#define KEYM_ROUTINE_SECOC_ECU_SHARED_SECRET_DIST_STATE_DESTROY_NONCE                                 (5u)
#define KeyM_IsSecOcEcuSharedSecretDistStateValid()                                                   ((KeyM_DiagProc.state)<=KEYM_ROUTINE_SECOC_ECU_SHARED_SECRET_DIST_STATE_DESTROY_NONCE)

/*! States for asynchronous handling of function KeyM_EncryptSharedSecret. */
#define KEYM_ENCRYPTSHAREDSECRET_STATE_IDLE                                                           (0u)
#define KEYM_ENCRYPTSHAREDSECRET_STATE_VERIFY_ECU_CERTIFICATE                                         (1u)
#define KEYM_ENCRYPTSHAREDSECRET_STATE_VERIFY_SIGNATURE                                               (2u)
#define KEYM_ENCRYPTSHAREDSECRET_STATE_GEN_CAR_SPEC_SECRET                                            (3u)
#define KEYM_ENCRYPTSHAREDSECRET_STATE_DERIVE_SECOC_KEYS                                              (4u)
#define KEYM_ENCRYPTSHAREDSECRET_STATE_WAIT                                                           (5u)
#define KEYM_ENCRYPTSHAREDSECRET_STATE_KEYEXCHANGE_ENCRYPT_GET_TIME                                   (6u)
#define KEYM_ENCRYPTSHAREDSECRET_STATE_GEN_SIGNATURE                                                  (7u)
#define KeyM_IsEncryptSharedSecretStateValid()                                                        ((KeyM_DiagProc.state)<=KEYM_ENCRYPTSHAREDSECRET_STATE_GEN_SIGNATURE)

/*! States for asynchronous handling of function KeyM_VerifyPublicKeyWithEcuPrivateKey. */
#define KEYM_VERIFY_CERTPUBLICKEY_WITH_ECUPRIVATEKEY_STATE_IDLE_GENERATE_SIGNATURE                    (0u)
#define KEYM_VERIFY_CERTPUBLICKEY_WITH_ECUPRIVATEKEY_STATE_VERIFY_SIGNATURE                           (1u)

/*! States for asynchronous handling of function KeyM_CarSpecificSecretDistribution_VerifyEcuCert. */
#define KEYM_SECRET_DISTRIB_VERIFY_ECUCERT_STATE_IDLE                                                 (0u)
#define KEYM_SECRET_DISTRIB_VERIFY_ECUCERT_STATE_VERIFY                                               (1u)

#define KEYM_SECRET_DISTRIB_VERIFY_ECUCERT_TM_STATE_IDLE                                              (0u)
#define KEYM_SECRET_DISTRIB_VERIFY_ECUCERT_TM_STATE_REQUESTING_FOR_VERIFICATION_CERT_CHAIN            (1u)
#define KEYM_SECRET_DISTRIB_VERIFY_ECUCERT_TM_STATE_AWAITING_VERIFICATION_RESULT                      (2u)

/*! States for asynchronous handling of function KeyM_Replace_Certificate_Verify_Ecu. */
#define KEYM_REPLACE_CERT_VERIFY_ECUCERT_STATE_IDLE                                                   (0u)
#define KEYM_REPLACE_CERT_VERIFY_ECUCERT_STATE_VERIFY_CERT                                            (1u)
#define KEYM_REPLACE_CERT_VERIFY_ECUCERT_STATE_VERIFY_PUBKEY_AGAINST_PRIVKEY                          (2u)

/*! States for asynchronous handling of function KeyM_Replace_Certificate_Replace_Ecu. */
#define KEYM_REPLACE_CERT_REPLACE_ECUCERT_STATE_IDLE                                                  (0u)
#define KEYM_REPLACE_CERT_REPLACE_ECUCERT_STATE_VERIFY_ECU_CERT                                       (1u)

/*! States for asynchronous handling of function KeyM_Replace_Certificate_Replace_BackendAndLower. */
#define KEYM_REPLACE_CERT_REPLACE_BACKEND_AND_LOWER_CERT_STATE_IDLE                                   (0u)
#define KEYM_REPLACE_CERT_REPLACE_BACKEND_AND_LOWER_CERT_STATE_VERIFY_BACKEND_LINK_CERT               (1u)
#define KEYM_REPLACE_CERT_REPLACE_BACKEND_AND_LOWER_CERT_STATE_VERIFY_BACKEND_CERT                    (2u)
#define KEYM_REPLACE_CERT_REPLACE_BACKEND_AND_LOWER_CERT_STATE_VERIFY_ECU_CERT                        (3u)

/*! States for asynchronous handling of function KeyM_Replace_Certificate_Replace_RootAndLower. */
#define KEYM_REPLACE_CERT_REPLACE_ROOT_AND_LOWER_CERT_STATE_IDLE                                      (0u)
#define KEYM_REPLACE_CERT_REPLACE_ROOT_AND_LOWER_CERT_STATE_VERIFY_ROOT_LINK_CERT                     (1u)
#define KEYM_REPLACE_CERT_REPLACE_ROOT_AND_LOWER_CERT_STATE_VERIFY_ROOT_CERT                          (2u)
#define KEYM_REPLACE_CERT_REPLACE_ROOT_AND_LOWER_CERT_STATE_VERIFY_BACKEND_CERT                       (3u)
#define KEYM_REPLACE_CERT_REPLACE_ROOT_AND_LOWER_CERT_STATE_ECU_CERT                                  (4u)

/*! Ids for Identification of certificates within the functions
 *  KeyM_Replace_Certificate_Replace_BackendAndLower, KeyM_Replace_Certificate_Replace_RootAndLower
 *  and KeyM_Replace_Certificate_Verify_Ecu. */
#define KEYM_REPLACE_CERT_REPLACE_BACKEND_AND_LOWER_CERT_ID_BACKEND_LINK_CERT                         (0u)
#define KEYM_REPLACE_CERT_REPLACE_BACKEND_AND_LOWER_CERT_ID_BACKEND_CERT                              (1u)
#define KEYM_REPLACE_CERT_REPLACE_ROOT_AND_LOWER_CERT_ID_ROOT_LINK_CERT                               (2u)
#define KEYM_REPLACE_CERT_REPLACE_ROOT_AND_LOWER_CERT_ID_ROOT_CERT                                    (3u)
#define KEYM_REPLACE_CERT_REPLACE_ROOT_AND_LOWER_CERT_ID_BACKEND_CERT                                 (4u)
#define KEYM_REPLACE_CERT_VERIFY_ECU_ECU_CERT                                                         (5u)

/*! States for asynchronous handling of the key exchange calculate symmetric key. */
#define KEYM_KEYEXCHANGECALCSYMKEY_STATE_IDLE                                                         (0u)
#define KEYM_KEYEXCHANGECALCSYMKEY_STATE_PREPARE                                                      (1u)
#define KEYM_KEYEXCHANGECALCSYMKEY_STATE_PREPARE_CHECK_STATE                                          (2u)
#define KEYM_KEYEXCHANGECALCSYMKEY_STATE_CALC_PUBVAL                                                  (3u)
#define KEYM_KEYEXCHANGECALCSYMKEY_STATE_CALC_SECRET                                                  (4u)

/*! States for asynchronous handling of routine SecOC_VSM_Derive_Symmetric_Keys. */
#define KEYM_ROUTINE_SECOC_VSM_DERIVE_SYM_KEYS_STATE_IDLE                                             (0u)
#define KEYM_ROUTINE_SECOC_VSM_DERIVE_SYM_KEYS_STATE_INIT                                             (1u)
#define KEYM_ROUTINE_SECOC_VSM_DERIVE_SYM_KEYS_STATE_WAIT                                             (2u)

/*! States for asynchronous handling of routine SecOC_VSM_Renew_Shared_Secret. */
#define KEYM_ROUTINE_SECOC_VSM_RENEW_SHARED_SECRET_STATE_IDLE                                         (0u)
#define KEYM_ROUTINE_SECOC_VSM_RENEW_SHARED_SECRET_STATE_INIT                                         (1u)
#define KEYM_ROUTINE_SECOC_VSM_RENEW_SHARED_SECRET_STATE_WAIT                                         (2u)

/*! States for asynchronous handling of the local function KeyM_InstantiateRandomNumberGenerator. */
#define KEYM_INSTANTIATE_RNG_STATE_HASH_CAR_SPECIFIC_SECRET                                           (1u)
#define KEYM_INSTANTIATE_RNG_STATE_GET_TRUE_RANDOM_INIT                                               (2u)
#define KEYM_INSTANTIATE_RNG_STATE_GET_TRUE_RANDOM_CHECKSTATE                                         (3u)
#define KEYM_INSTANTIATE_RNG_STATE_HASH_TRUE_RANDOM                                                   (4u)
#define KEYM_INSTANTIATE_RNG_STATE_SEED_RNG                                                           (5u)
#define KEYM_INSTANTIATE_RNG_STATE_IDLE                                                               (0u)

/*! Generic states for generating and storing the symmetric keys in the main loop. */
#define KEYM_GENERATE_SYM_KEYS_STATE_IDLE                                                             (0u)
#define KEYM_GENERATE_SYM_KEYS_STATE_LOCKED                                                           (1u)
#define KEYM_GENERATE_SYM_KEYS_STATE_HASH_SECRET                                                      (2u)
#define KEYM_GENERATE_SYM_KEYS_STATE_LOOP_OVER_IDS                                                    (3u)
#define KEYM_GENERATE_SYM_KEYS_STATE_STORE_INIT                                                       (4u)
#define KEYM_GENERATE_SYM_KEYS_STATE_STORE_PENDING                                                    (5u)

/*! Configurations for the KeyM mainloop processing (bit mask style). */
#define KEY_MAINLOOP_PROC_CONF_COMPLETE                                                               (0u)
#define KEY_MAINLOOP_PROC_CONF_NO_KEY_DERIVATION                                                      (1u)
#define KEY_MAINLOOP_PROC_CONF_RESET_TICK_COUNT                                                       (2u)
#define KEY_MAINLOOP_PROC_CONF_BROADCAST_PROC                                                         (4u)

/*! States for asynchronous handling of routine Ssa_KeyM_Trust_Model_Ecu_Csr_State. */
#define SSA_KEYM_TRUST_MODEL_ECU_CSR_STATE_IDLE                                                       (0u)
#define SSA_KEYM_TRUST_MODEL_ECU_CSR_STATE_VERIFYING_TRUST_MODEL_PRIVATE_KEY                          (1u)
#define SSA_KEYM_TRUST_MODEL_ECU_CSR_STATE_CREATING_CSR                                               (2u)

/*! States for asynchronous handling of routine Replace_Trust_model_Certificates. */
/* These states are used as table indices, thus start at 0 and avoid gaps. */
#define SSA_KEYM_REPLACE_TRUST_MODEL_CERTS_STATE_IDLE                                                 (0u)
#define SSA_KEYM_REPLACE_TRUST_MODEL_CERTS_STATE_REQUESTING_SERVICE_CERT_BACKEND                      (1u)
#define SSA_KEYM_REPLACE_TRUST_MODEL_CERTS_STATE_AWAITING_VERIFICATION_RESULT_BACKEND_CERT            (2u)
#define SSA_KEYM_REPLACE_TRUST_MODEL_CERTS_STATE_AWAITING_VERIFICATION_RESULT_INTERMEDIATE_CERT       (3u)
#define SSA_KEYM_REPLACE_TRUST_MODEL_CERTS_STATE_AWAITING_PARSING_RESULT_ECU_CERT                     (4u)
#define SSA_KEYM_REPLACE_TRUST_MODEL_CERTS_STATE_REQUESTING_FOR_VERIFICATION_ECU_CERT                 (5u)
#define SSA_KEYM_REPLACE_TRUST_MODEL_CERTS_STATE_AWAITING_VERIFICATION_RESULT_ECU_CERT                (6u)
#define SSA_KEYM_REPLACE_TRUST_MODEL_CERTS_STATE_VERIFY_TRUST_MODEL_PRIVATE_KEY                       (7u)
#define SSA_KEYM_REPLACE_TRUST_MODEL_CERTS_STATE_STORE_INIT                                           (8u)
#define SSA_KEYM_REPLACE_TRUST_MODEL_CERTS_STATE_STORE_PENDING                                        (9u)
#define SSA_KEYM_REPLACE_TRUST_MODEL_CERTS_STATE_NVM_WRITE                                            (10u)
#define SSA_KEYM_REPLACE_TRUST_MODEL_CERTS_STATE_NVM_WAIT                                             (11u)
#define KeyM_IsReplaceTrustModelCertsStateValid()                                                     ((KeyM_DiagProc.state)<=SSA_KEYM_REPLACE_TRUST_MODEL_CERTS_STATE_NVM_WAIT)

/*! States for asynchronous handling of routine Replace_Trust_model_Root_Certificate. */
/* These states are used as table indices, thus start at 0 and avoid gaps. */
#define SSA_KEYM_REPLACE_TRUST_MODEL_ROOT_CERT_STATE_IDLE                                             (0u)
#define SSA_KEYM_REPLACE_TRUST_MODEL_ROOT_CERT_STATE_VERIFYING_REPLACEMENT_PACKAGE_SUBKEYID           (1u)
#define SSA_KEYM_REPLACE_TRUST_MODEL_ROOT_CERT_STATE_STARTING_VERIFICATION_SIGNATURE_NEW_ROOT         (2u)
#define SSA_KEYM_REPLACE_TRUST_MODEL_ROOT_CERT_STATE_AWAITING_VERIF_RESULT_SIGNATURE_NEW_ROOT         (3u)
#define SSA_KEYM_REPLACE_TRUST_MODEL_ROOT_CERT_STATE_AWAITING_VERIF_RESULT_NEW_ROOT_CERT              (4u)
#define SSA_KEYM_REPLACE_TRUST_MODEL_ROOT_CERT_STATE_ROLLING_BACK_CERTIFICATE_DATA                    (5u)
#define SSA_KEYM_REPLACE_TRUST_MODEL_ROOT_CERT_STATE_STORE_INIT                                       (6u)
#define SSA_KEYM_REPLACE_TRUST_MODEL_ROOT_CERT_STATE_STORE_PENDING                                    (7u)
#define SSA_KEYM_REPLACE_TRUST_MODEL_ROOT_CERT_STATE_NVM_WRITE                                        (8u)
#define SSA_KEYM_REPLACE_TRUST_MODEL_ROOT_CERT_STATE_NVM_WAIT                                         (9u)
#define KeyM_IsReplaceTrustModelRootCertStateValid()                                                  ((KeyM_DiagProc.state)<=SSA_KEYM_REPLACE_TRUST_MODEL_ROOT_CERT_STATE_NVM_WAIT)

/*! States for asynchronous handling of routine Trust_Model_Generate_Key_Pair. */
/* These states are used as table indices, thus start at 0 and avoid gaps. */
#define SSA_KEYM_TRUST_MODEL_GENERATE_KEY_PAIR_STATE_IDLE                                             (0u)
#define SSA_KEYM_TRUST_MODEL_GENERATE_KEY_PAIR_STATE_GENERATING_KEY_PAIR                              (1u)
#define SSA_KEYM_TRUST_MODEL_GENERATE_KEY_PAIR_STATE_VERIFYING_KEY_PAIR                               (2u)
#define SSA_KEYM_TRUST_MODEL_GENERATE_KEY_PAIR_STATE_AWAITING_CSR                                     (3u)
#define SSA_KEYM_TRUST_MODEL_GENERATE_KEY_PAIR_STATE_CREATING_SIGNATURE                               (4u)
#define KeyM_IsTrustModelGenerateKeyPairStateValid()                                                  ((KeyM_DiagProc.state)<=SSA_KEYM_TRUST_MODEL_GENERATE_KEY_PAIR_STATE_CREATING_SIGNATURE)

/*! States for asynchronous handling of routine Inject_Seed. */
/* These states are used as table indices, thus start at 0 and avoid gaps. */
#define SSA_KEYM_ROUTINE_INJECT_SEED_STATE_IDLE                                                       (0u)
#define SSA_KEYM_ROUTINE_INJECT_SEED_STATE_VERIFY_SIGNATURE                                           (1u)
#define SSA_KEYM_ROUTINE_INJECT_SEED_STATE_KEYEXCHANGE                                                (2u)
#define SSA_KEYM_ROUTINE_INJECT_SEED_STATE_DECRYPT                                                    (3u)
#define SSA_KEYM_ROUTINE_INJECT_SEED_STATE_SEED_RNG                                                   (4u)
#define SSA_KEYM_ROUTINE_INJECT_SEED_STATE_DESTROY_NONCE                                              (5u)
#define SSA_KEYM_ROUTINE_INJECT_SEED_STATE_STORE_INIT                                                 (6u)
#define SSA_KEYM_ROUTINE_INJECT_SEED_STATE_STORE_PENDING                                              (7u)
#define KeyM_IsInjectSeedStateValid()                                                                 ((KeyM_DiagProc.state)<=SSA_KEYM_ROUTINE_INJECT_SEED_STATE_STORE_PENDING)

#define SSA_KEYM_DID191_SUCCESS                                                                       (0x01u)
#define SSA_KEYM_DID191_FAILURE                                                                       (0x00u)

#define SSA_KEYM_SIZEOF_SUBJECT                                                                       (30u)

#define SSA_KEYM_SELFCHECK_SIZEOF_VERIFICATION_RESULT                                                 (sizeof(Dcm_Data18ByteType))

/*! Rollback states. */
#define SSA_KEYM_NO_ROLLBACK                                                                          (0u)
#define SSA_KEYM_ROLLBACK_POSSIBLE                                                                    (1u)
#define SSA_KEYM_ROLLBACK_ONGOING                                                                     (2u)

/*! Number of certificates transmitted to peer for authentication purposes. */
#define SSA_KEYM_NUMBER_OF_TRANSMITTED_CERTS                                                          (3u)

/*! Sizes for handling certificates */
#define SSA_MAX_SIZE_TRUSTMODEL_ROOT_CA_CERT                                                          (1000u)
#define SSA_MAX_SIZE_TRUSTMODEL_BACKEND_CA_CERT                                                       (1000u)
#define SSA_MAX_SIZE_TRUSTMODEL_INTERMEDIATE_CA_CERT                                                  (1000u)
#define SSA_MAX_SIZE_TRUSTMODEL_ECU_CERT                                                              (1000u)
/* maximum of the max_size of the four certificates above */
#define SSA_KEYM_SIZEOF_CERTIFICATEDATA_BUFFER                                                        (1000u)

#define SSA_MAX_SIZE_KEYM_SERVICE_CERTIFICATE_RESPONSE                                                (1000u)
#define SSA_MAX_SIZE_ENHANCE_RIGHTS_CERT                                                              (1000u)

#define SSA_SIZEOF_REPLACEMENT_PACKAGE_BUFFER                                                         (SSA_MAX_SIZE_TRUSTMODEL_ROOT_CA_CERT + SSA_MAX_SIZE_ENHANCE_RIGHTS_CERT  + SSA_SIZEOF_SIGNATURE + SSA_SIZEOF_SIGNATURE)

#define SSS_KEYM_MAX_LEN_COMMON_NAME                                                                  (64u)

/* Certificate Entry */
#define SSA_KEYM_CERT_ENTRY_SIZEOF_ENTRY_BUFFER                                                       (sizeof(Dcm_Data64ByteType))

/* Sizes of certificate entries */
#define SSA_KEYM_SIZEOF_VERSION                                                                       (1u)
#define SSA_KEYM_SIZEOF_VALID_NOT_AFTER_UTCT                                                          (13u)
#define SSA_KEYM_SIZEOF_VALID_NOT_AFTER_GT                                                            (15u)
#define SSA_KEYM_SIZEOF_BASIC_CONSTRAINTS                                                             (1u)

/* Specified certificate entries */
#define SSA_KEYM_CERT_ENTRY_INVALID_VERSION                                                           (0u)
#define SSA_KEYM_CERT_ENTRY_VERSION                                                                   (2u) /* value is valid for all certificates, except for the CSR */
#define SSA_KEYM_CERT_ENTRY_BASIC_CONSTRAINTS_INVALID                                                 (0xFFu)
#define SSA_KEYM_CERT_ENTRY_BASIC_CONSTRAINTS_DEPTH_ROOT                                              (2u)
#define SSA_KEYM_CERT_ENTRY_BASIC_CONSTRAINTS_DEPTH_BACKEND                                           (1u)
#define SSA_KEYM_CERT_ENTRY_BASIC_CONSTRAINTS_DEPTH_INTERMEDIATE                                      (0u)

/*! Certificate Identifier */
/* Don't modify the following definitions without checking their usage. */
/* The order up to SSA_KEYM_CERT_ENTRY_CERT_ID_PQC_ECU_CA_CERT is specified for Routine Control GetCertificateEntry.*/
#define SSA_KEYM_CERT_ENTRY_CERT_ID_INVALID                                                           (0u)
#define SSA_KEYM_CERT_ENTRY_CERT_ID_ROOT_CA_CERT                                                      (1u)
#define SSA_KEYM_CERT_ENTRY_CERT_ID_BACKEND_CA_CERT                                                   (2u)
#define SSA_KEYM_CERT_ENTRY_CERT_ID_ECU_CA_CERT                                                       (3u)
#define SSA_KEYM_CERT_ENTRY_CERT_ID_TRUSTMODEL_ROOT_CA_CERT                                           (4u)
#define SSA_KEYM_CERT_ENTRY_CERT_ID_TRUSTMODEL_BACKEND_CA_CERT                                        (5u)
#define SSA_KEYM_CERT_ENTRY_CERT_ID_TRUSTMODEL_INTERMEDIATE_CA_CERT                                   (6u)
#define SSA_KEYM_CERT_ENTRY_CERT_ID_TRUSTMODEL_ECU_CA_CERT                                            (7u)
#define SSA_KEYM_CERT_ENTRY_CERT_ID_PQC_ROOT_CA_CERT                                                  (8u)
#define SSA_KEYM_CERT_ENTRY_CERT_ID_PQC_BACKEND_CA_CERT                                               (9u)
#define SSA_KEYM_CERT_ENTRY_CERT_ID_PQC_ECU_CA_CERT                                                   (10u)
#define SSA_KEYM_CERT_ENTRY_CERT_ID_NUM                                                               (SSA_KEYM_CERT_ENTRY_CERT_ID_PQC_ECU_CA_CERT)
/* Up to here the order of the certificate ids may not be changed! */
#define SSA_KEYM_CERT_ENTRY_CERT_ID_TRUSTMODEL_INTERMEDIATE_PEER_CERT                                 (11u)
#define SSA_KEYM_CERT_ENTRY_CERT_ID_TRUSTMODEL_BACKEND_PEER_CERT                                      (12u)
#define SSA_KEYM_CERT_ENTRY_CERT_ID_TRUSTMODEL_ECU_PEER_CERT                                          (13u)
#define SSA_KEYM_CERT_ENTRY_TOTAL_CERT_ID_NUM                                                         (SSA_KEYM_CERT_ENTRY_CERT_ID_TRUSTMODEL_ECU_PEER_CERT)

/*! Certificate Index for access to KeyM_GetCertEntry_KeyM_CertElementGet_List */
/* Don't change modify the following definitions without checking their usage. */
#define SSA_KEYM_CERT_ENTRY_CERT_INDEX_TRUSTMODEL_ROOT_CA_CERT                                        (0u)
#define SSA_KEYM_CERT_ENTRY_CERT_INDEX_TRUSTMODEL_BACKEND_CA_CERT                                     (1u)
#define SSA_KEYM_CERT_ENTRY_CERT_INDEX_TRUSTMODEL_INTERMEDIATE_CA_CERT                                (2u)
#define SSA_KEYM_CERT_ENTRY_CERT_INDEX_TRUSTMODEL_ECU_CA_CERT                                         (3u)
#define SSA_KEYM_CERT_ENTRY_CERT_INDEX_TRUSTMODEL_BACKEND_PEER_CERT                                   (4u)
#define SSA_KEYM_CERT_ENTRY_CERT_INDEX_TRUSTMODEL_INTERMEDIATE_PEER_CERT                              (5u)
#define SSA_KEYM_CERT_ENTRY_CERT_INDEX_TRUSTMODEL_ECU_PEER_CERT                                       (6u)

/*! Certificate Element Identifier */
/* Don't change modify the following definitions without checking their usage. */
/* The order up to SSA_KEYM_CERT_ENTRY_ENTRY_ID_PROD_QUALIFIER is specified for Routine Control GetCertificateEntry. */
#define SSA_KEYM_CERT_ENTRY_ENTRY_ID_INVALID                                                          (0u)
#define SSA_KEYM_CERT_ENTRY_ENTRY_ID_SERIAL_NUMBER                                                    (1u)
#define SSA_KEYM_CERT_ENTRY_ENTRY_ID_SUBJECT                                                          (2u)
#define SSA_KEYM_CERT_ENTRY_ENTRY_ID_SPECIAL_ECU                                                      (3u)
#define SSA_KEYM_CERT_ENTRY_ENTRY_ID_SUBJECT_PUBLIC_KEY                                               (4u)
#define SSA_KEYM_CERT_ENTRY_ENTRY_ID_ISSUER                                                           (5u)
#define SSA_KEYM_CERT_ENTRY_ENTRY_ID_ISSUER_SERIAL_NUMBER                                             (6u) /* Not Supported */
#define SSA_KEYM_CERT_ENTRY_ENTRY_ID_SUBJECT_KEY_IDENTIFIER                                           (7u)
#define SSA_KEYM_CERT_ENTRY_ENTRY_ID_AUTHORITY_KEY_IDENTIFIER                                         (8u)
#define SSA_KEYM_CERT_ENTRY_ENTRY_ID_PKI_ROLE                                                         (9u)
#define SSA_KEYM_CERT_ENTRY_ENTRY_ID_PROD_QUALIFIER                                                   (10u)
#define SSA_KEYM_CERT_ENTRY_ENTRY_ID_NUM                                                              (SSA_KEYM_CERT_ENTRY_ENTRY_ID_PROD_QUALIFIER)
/* Up to here the order of elements may not be changed! */
#define SSA_KEYM_CERT_ENTRY_ENTRY_ID_VERSION                                                          (11u)
#define SSA_KEYM_CERT_ENTRY_ENTRY_ID_NOT_AFTER                                                        (12u)
#define SSA_KEYM_CERT_ENTRY_ENTRY_ID_BASIC_CONSTRAINTS                                                (13u)
#define SSA_KEYM_CERT_ENTRY_TOTAL_ENTRY_ID_NUM                                                        (SSA_KEYM_CERT_ENTRY_ENTRY_ID_BASIC_CONSTRAINTS)

/* Upper boundaries for for-loops processing a switch-case */
#if ((SSA_ECU_TYPE == SSA_ECU_TYPE_VSM) && (SSA_ENABLE_ASYNC_CSM_JOB_PROCESSING == STD_ON))
# define SSA_KEYM_REPLACE_CERT_UPPER_BOUNDARY                                                         (2u)
#else
# define SSA_KEYM_REPLACE_CERT_UPPER_BOUNDARY                                                         (3u)
#endif
#define SSA_KEYM_REPLACE_CERT_VERIFY_ECU_UPPER_BOUNDARY                                               (3u)
#define SSA_KEYM_REPLACE_CERT_REPLACE_BACKENDANDLOWER_UPPER_BOUNDARY                                  (4u)
#define SSA_KEYM_REPLACE_CERT_REPLACE_ROOTANDLOWER_UPPER_BOUNDARY                                     (5u)
#if (SSA_ECU_TYPE == SSA_ECU_TYPE_VSM)
# if (SSA_ENABLE_ASYNC_CSM_JOB_PROCESSING == STD_ON)
#  define SSA_KEYM_SELFCHECK_DIAGCHAIN_UPPER_BOUNDARY                                                 (5u)
# else
#  define SSA_KEYM_SELFCHECK_DIAGCHAIN_UPPER_BOUNDARY                                                 (6u)
# endif
#else
# define SSA_KEYM_SELFCHECK_DIAGCHAIN_UPPER_BOUNDARY                                                  (3u)
#endif
#define SSA_KEYM_SELFCHECK_UNIQUEECUID_CHAIN_UPPER_BOUNDARY                                           (3u)
#define SSA_KEYM_TRUSTMODEL_ADDITIONAL_VERIFICATION_UPPER_BOUNDARY                                    (4u)

/*! Initial value for empty entries of diagnostic chain certificates */
#define SSA_KEYM_CERT_ENTRY_CONTENT_NOT_AVAILABLE                                                     (0xFFu)

/*! AUTOSAR KeyM SWC return codes */
#define SSA_KEYM_ASR_KEYM_E_OK                                                                        (0u)
#define SSA_KEYM_ASR_KEYM_E_NOT_OK                                                                    (1u)
#define SSA_KEYM_ASR_KEYM_E_KEY_CERT_SIZE_MISMATCH                                                    (4u)
#define SSA_KEYM_ASR_KEYM_E_PARAMETER_MISMATCH                                                        (5u)
#define SSA_KEYM_ASR_KEYM_E_KEY_CERT_INVALID                                                          (6u)
#define SSA_KEYM_ASR_KEYM_E_KEY_CERT_EMPTY                                                            (10u)

/*! Dummy type definition causing compile-time assertion if RTE return code is not as expected. */
Ssa_CompileTimeAssert(SSA_KEYM_ASR_KEYM_E_OK == RTE_E_OK, Ssa_KeyM_CompileTimeAssert_1);    /* PRQA S 3205, 3493 */ /* MD_SSA_COMPILE_TIME_ASSERTION */ /*lint !e506 */
Ssa_CompileTimeAssert(SSA_KEYM_ASR_KEYM_E_NOT_OK == RTE_E_KeyMCertificateElement_Ssa_TrustModelRootCert_Issuer_E_NOT_OK, Ssa_KeyM_CompileTimeAssert_2);    /* PRQA S 3205, 3493 */ /* MD_SSA_COMPILE_TIME_ASSERTION */ /*lint !e506 */
Ssa_CompileTimeAssert(SSA_KEYM_ASR_KEYM_E_KEY_CERT_SIZE_MISMATCH == RTE_E_KeyMCertificateElement_Ssa_TrustModelRootCert_Issuer_KEYM_E_KEY_CERT_SIZE_MISMATCH, Ssa_KeyM_CompileTimeAssert_3);    /* PRQA S 3205, 3493 */ /* MD_SSA_COMPILE_TIME_ASSERTION */ /*lint !e506 */
Ssa_CompileTimeAssert(SSA_KEYM_ASR_KEYM_E_PARAMETER_MISMATCH == RTE_E_KeyMCertificateElement_Ssa_TrustModelRootCert_Issuer_KEYM_E_PARAMETER_MISMATCH, Ssa_KeyM_CompileTimeAssert_4);    /* PRQA S 3205, 3493 */ /* MD_SSA_COMPILE_TIME_ASSERTION */ /*lint !e506 */
Ssa_CompileTimeAssert(SSA_KEYM_ASR_KEYM_E_KEY_CERT_INVALID == RTE_E_KeyMCertificateElement_Ssa_TrustModelRootCert_Issuer_KEYM_E_KEY_CERT_INVALID, Ssa_KeyM_CompileTimeAssert_5);    /* PRQA S 3205, 3493 */ /* MD_SSA_COMPILE_TIME_ASSERTION */ /*lint !e506 */
Ssa_CompileTimeAssert(SSA_KEYM_ASR_KEYM_E_KEY_CERT_EMPTY == RTE_E_KeyMCertificateElement_Ssa_TrustModelRootCert_Issuer_KEYM_E_KEY_CERT_EMPTY, Ssa_KeyM_CompileTimeAssert_6);    /* PRQA S 3205, 3493 */ /* MD_SSA_COMPILE_TIME_ASSERTION */ /*lint !e506 */
/*! Dummy definition to assert that the number of configured unique ECU IDs does not exceed 255. */
Ssa_CompileTimeAssert(Ssa_GetSizeOfUniqueEcuId() <= 255u, Ssa_KeyM_CompileTimeAssert_7);    /* PRQA S 3205, 3493 */ /* MD_SSA_COMPILE_TIME_ASSERTION */ /*lint !e506 */
/**********************************************************************************************************************
 *  LOCAL FUNCTION MACROS
 **********************************************************************************************************************/

/* Builds an uint16 value from two bytes. */
#define KeyM_GetUint16(hiByte, loByte)                                ((uint16)((((uint16)(hiByte)) << 8u) | ((uint16)(loByte))))  /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */
#define KeyM_GetUint16HiByte( value )                                 ((uint8)(((uint16)(value)) >> 8u))                   /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */
#define KeyM_GetUint16LoByte( value )                                 ((uint8)(((uint16)(value)) & 0xFFu))                 /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */
/* Writes an uint16 value to two bytes. */
#define KeyM_SetUint16(addr, value)                                   do { \
                                                                      addr[0] = KeyM_GetUint16HiByte((uint16)(value)); \
                                                                      addr[1] = KeyM_GetUint16LoByte((uint16)(value)); \
                                                                      } while (0)

/* Mem operations */
#if !defined (Ssa_MemCpy)                   /* COV_SSA_MEMCPY */
/* PRQA S 3453 1 */ /* MD_MSR_FctLikeMacro */
# define Ssa_MemCpy(destination, source, num)                         Ssa_Utils_MemCpy(destination, source, num)
#endif
#define KeyM_CopyDataBuffer(destination, source, num)                 Ssa_Utils_MemCpy(destination, source, num) /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */
#define KeyM_ClearDataBuffer(Data, DataSize, numBytesToClear)         KeyM_MemClear(Data, DataSize, numBytesToClear) /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */
#define KeyM_SetDataBuffer(Data, Value, DataSize)                     Ssa_Utils_MemSet((Data), (Value), (DataSize)) /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */
#define KeyM_CompareData(Data1, Data2, DataSize)                      Ssa_Utils_MemCmp((Data1), (Data2), (DataSize)) /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */
#define KeyM_CompareData_WithLengths(Data1, Data2, DataSize1, DataSize2) Ssa_Utils_MemCmp_WithLengths((Data1), (Data2), (DataSize1), (DataSize2)) /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */

/* Mapping of verification results according to Table 125 of DDS S-ISO. */
#define Map_VerRes_Ecu(x)                                             ((uint8)( 0x10u | ((x) & 0x0Fu)))   /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */
#define Map_VerRes_Backend(x)                                         ((uint8)( 0x30u | ((x) & 0x0Fu)))   /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */
#define Map_VerRes_Root(x)                                            ((uint8)( 0x40u | ((x) & 0x0Fu)))   /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */
#define Map_VerRes_Link(x)                                            ((uint8)( 0x50u | ((x) & 0x0Fu)))   /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */

/* Mapping of routine specific certificate verification results to general
 * 'failed certificate verification result' according to SSA-IS-2219. */
#define KeyM_MapRoutineSpecificVerResToFailedCertificateVerRes(x)     ((uint8)( 0x10u | ((x) & 0x0Fu)))   /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */

/* Check if KeyM mainloop processing is idle. */
#define KeyM_IsMainloopStateIdle()                                    (KeyM_MainLoopProc.state == KEYM_GENERATE_SYM_KEYS_STATE_IDLE)

/* Names of certificates configured in AsrKeyM and referenced by Ssa */
#define KeyM_TrustModelEcuCsrName()                                   Ssa_GetAddrTrustModelEcuCsrCertName(0)
#define KeyM_TrustModelEcuCertName()                                  Ssa_GetAddrTrustModelEcuCertName(0)
#define KeyM_TrustModelIntermediateCertName()                         Ssa_GetAddrTrustModelIntermediateCertName(0)
#define KeyM_TrustModelBackendCertName()                              Ssa_GetAddrTrustModelBackendCertName(0)
#define KeyM_TrustModelRootCertName()                                 Ssa_GetAddrTrustModelRootCertName(0)
#define KeyM_TrustModelEcuPeerCertName()                              Ssa_GetAddrTrustModelEcuPeerCertName(0)

#define KeyM_TrustModelEcuCsrNameLength()                             Ssa_GetSizeOfTrustModelEcuCsrCertName()
#define KeyM_TrustModelEcuCertNameLength()                            Ssa_GetSizeOfTrustModelEcuCertName()
#define KeyM_TrustModelIntermediateCertNameLength()                   Ssa_GetSizeOfTrustModelIntermediateCertName()
#define KeyM_TrustModelBackendCertNameLength()                        Ssa_GetSizeOfTrustModelBackendCertName()
#define KeyM_TrustModelRootCertNameLength()                           Ssa_GetSizeOfTrustModelRootCertName()
#define KeyM_TrustModelEcuPeerCertNameLength()                        Ssa_GetSizeOfTrustModelEcuPeerCertName()

/* CSR Common Name configured by Ssa */
#define SSS_KEYM_MAX_LEN_COMMON_NAME                                  (64u)
#define KeyM_TrustModelEcuCsrCommonName()                             KeyM_CommonName
#define KeyM_TrustModelEcuCsrCommonNameLength()                       KeyM_CommonNameLength

/**********************************************************************************************************************
 *  LOCAL DATA TYPES AND STRUCTURES
 *********************************************************************************************************************/

/* The following compile time assertions ensure the sizes of data types used within the KeyM submodule
 * when calling RTE APIs expecting these data types. 
 * The assertions ensure that the size of these data types is consistent with respective buffer lengths defined in the Ssa.
 * For ASIL-D, the vector code analyzer checks the same conditions within the KeyM_Init() function. */
/* PRQA S 3205, 3493 84 */ /* MD_SSA_COMPILE_TIME_ASSERTION */
Ssa_CompileTimeAssert( sizeof(Ssa_Data64ByteType) == 64u, InvalidSizeOf_Ssa_Data64ByteType); /*lint !e506 */
Ssa_CompileTimeAssert( sizeof(Coding_VINDataType) == 17u, InvalidSizeOf_Coding_VINDataType); /*lint !e506 */
Ssa_CompileTimeAssert( sizeof(Dcm_Data32ByteType) == 32u, InvalidSizeOf_Dcm_Data32ByteType); /*lint !e506 */
Ssa_CompileTimeAssert( sizeof(Ssa_Data7ByteType) == 7u, InvalidSizeOf_Data7ByteTypeSsa_Data7ByteType); /*lint !e506 */
Ssa_CompileTimeAssert( sizeof(Ssa_Data5ByteType) == 5u, InvalidSizeOf_Ssa_Data5ByteType); /*lint !e506 */
Ssa_CompileTimeAssert( sizeof(Csm_MacGenerateResultType_MacGenAesCmac) == 16u, InvalidSizeOf_Csm_MacGenerateResultType_MacGenAesCmac); /*lint !e506 */
Ssa_CompileTimeAssert( sizeof(Csm_KeyDataType_Ssa_SharedSecretKeyExchange) == 32u, InvalidSizeOf_Csm_KeyDataType_Ssa_SharedSecretKeyExchange); /*lint !e506 */
Ssa_CompileTimeAssert( sizeof(Csm_KeyDataType_Ssa_SharedSecretHash) == 4u, InvalidSizeOf_Csm_KeyDataType_Ssa_SharedSecretHash); /*lint !e506 */
Ssa_CompileTimeAssert( sizeof(Csm_RandomGenerateResultType_Random) == 32u, InvalidSizeOf_Csm_RandomGenerateResultType_Random); /*lint !e506 */
Ssa_CompileTimeAssert( sizeof(Csm_PublicValueDataType_Ssa_SharedSecretKeyExchange) == 32u, InvalidSizeOf_Csm_PublicValueDataType_Ssa_SharedSecretKeyExchange); /*lint !e506 */
Ssa_CompileTimeAssert( sizeof(Csm_KeyDataType_Ssa_BackendCert) <= 910u, InvalidSizeOf_Csm_KeyDataType_Ssa_BackendCert); /*lint !e506 */
Ssa_CompileTimeAssert( sizeof(Csm_KeyDataType_Ssa_RootCert) <= 910u, InvalidSizeOf_Csm_KeyDataType_Ssa_RootCert); /*lint !e506 */
Ssa_CompileTimeAssert( sizeof(Csm_KeyDataType_Ssa_TrustModelEcuCsrPublicKey) == 32u, InvalidSizeOf_Csm_KeyDataType_Ssa_TrustModelEcuCsrPublicKey); /*lint !e506 */
Ssa_CompileTimeAssert( sizeof(Csm_KeyDataType_Ssa_TrustModelEcuLivePublicKey) == 32u, InvalidSizeOf_Csm_KeyDataType_Ssa_TrustModelEcuLivePublicKey); /*lint !e506 */
Ssa_CompileTimeAssert( sizeof(Csm_KeyDataType_Ssa_TrustModelTempPublicKey) == 32u, InvalidSizeOf_Csm_KeyDataType_Ssa_TrustModelTempPublicKey); /*lint !e506 */
Ssa_CompileTimeAssert( sizeof(Csm_KeyDataType_Ssa_SigPubKey_ReplacementAuthority) == 32u, InvalidSizeOf_Csm_KeyDataType_Ssa_SigPubKey_ReplacementAuthority); /*lint !e506 */
Ssa_CompileTimeAssert( sizeof(KeyM_SharedSecretType) == 32u, InvalidSizeOf_KeyM_SharedSecretType); /*lint !e506 */
Ssa_CompileTimeAssert( sizeof(KeyM_CertificateElementType_Ssa_TrustModelEcuCert_SerialNo) == 16u, InvalidSizeOf_KeyM_CertificateElementType_Ssa_TrustModelEcuCert_SerialNo); /*lint !e506 */
Ssa_CompileTimeAssert( sizeof(KeyM_CertificateElementType_Ssa_TrustModelBackendPeerCert_SerialNo) == 16u, InvalidSizeOf_KeyM_CertificateElementType_Ssa_TrustModelBackendPeerCert_SerialNo); /*lint !e506 */
Ssa_CompileTimeAssert( sizeof(KeyM_CertificateElementType_Ssa_TrustModelIntermediatePeerCert_SerialNo) == 16u, InvalidSizeOf_KeyM_CertificateElementType_Ssa_TrustModelIntermediatePeerCert_SerialNo); /*lint !e506 */
Ssa_CompileTimeAssert( sizeof(KeyM_CertificateElementType_Ssa_TrustModelEcuPeerCert_SerialNo) == 16u, InvalidSizeOf_KeyM_CertificateElementType_Ssa_TrustModelEcuPeerCert_SerialNo); /*lint !e506 */
Ssa_CompileTimeAssert( sizeof(KeyM_CertificateElementType_Ssa_TrustModelRootCert_SerialNo) == 16u, InvalidSizeOf_KeyM_CertificateElementType_Ssa_TrustModelRootCert_SerialNo); /*lint !e506 */
Ssa_CompileTimeAssert( sizeof(KeyM_CertificateElementType_Ssa_TrustModelBackendCert_SerialNo) == 16u, InvalidSizeOf_KeyM_CertificateElementType_Ssa_TrustModelBackendCert_SerialNo); /*lint !e506 */
Ssa_CompileTimeAssert( sizeof(KeyM_CertificateElementType_Ssa_TrustModelIntermediateCert_SerialNo) == 16u, InvalidSizeOf_KeyM_CertificateElementType_Ssa_TrustModelIntermediateCert_SerialNo); /*lint !e506 */
Ssa_CompileTimeAssert( sizeof(KeyM_CertificateElementType_Ssa_TrustModelEcuCert_ext_subKeyId) == 20u, InvalidSizeOf_KeyM_CertificateElementType_Ssa_TrustModelEcuCert_ext_subKeyId); /*lint !e506 */
Ssa_CompileTimeAssert( sizeof(KeyM_CertificateElementType_Ssa_TrustModelEcuCert_ext_uniqueECUID) == 170u, InvalidSizeOf_KeyM_CertificateElementType_Ssa_TrustModelEcuCert_ext_uniqueECUID); /*lint !e506 */
Ssa_CompileTimeAssert( sizeof(KeyM_CertificateElementType_Ssa_TrustModelEcuPeerCert_ext_subKeyId) == 20u, InvalidSizeOf_KeyM_CertificateElementType_Ssa_TrustModelEcuPeerCert_ext_subKeyId); /*lint !e506 */
Ssa_CompileTimeAssert( sizeof(KeyM_CertificateElementType_Ssa_TrustModelRootCert_ext_subKeyId) == 20u, InvalidSizeOf_KeyM_CertificateElementType_Ssa_TrustModelRootCert_ext_subKeyId); /*lint !e506 */
Ssa_CompileTimeAssert( sizeof(KeyM_CertificateElementType_Ssa_TrustModelBackendCert_ext_authKeyId) == 20u, InvalidSizeOf_KeyM_CertificateElementType_Ssa_TrustModelBackendCert_ext_authKeyId); /*lint !e506 */
Ssa_CompileTimeAssert( sizeof(KeyM_CertificateElementType_Ssa_TrustModelBackendCert_ext_basicConstraints) == 1u, InvalidSizeOf_KeyM_CertificateElementType_Ssa_TrustModelBackendCert_ext_basicConstraints); /*lint !e506 */
Ssa_CompileTimeAssert( sizeof(KeyM_CertificateElementType_Ssa_TrustModelBackendCert_ext_subKeyId) == 20u, InvalidSizeOf_KeyM_CertificateElementType_Ssa_TrustModelBackendCert_ext_subKeyId); /*lint !e506 */
Ssa_CompileTimeAssert( sizeof(KeyM_CertificateElementType_Ssa_TrustModelBackendCert_Issuer) == 15u, InvalidSizeOf_KeyM_CertificateElementType_Ssa_TrustModelBackendCert_Issuer); /*lint !e506 */
Ssa_CompileTimeAssert( sizeof(KeyM_CertificateElementType_Ssa_TrustModelBackendCert_subject) == 30u, InvalidSizeOf_KeyM_CertificateElementType_Ssa_TrustModelBackendCert_subject); /*lint !e506 */
Ssa_CompileTimeAssert( sizeof(KeyM_CertificateElementType_Ssa_TrustModelBackendCert_SubjectPublicKeyInfoKey) == 33u, InvalidSizeOf_KeyM_CertificateElementType_Ssa_TrustModelBackendCert_SubjectPublicKeyInfoKey); /*lint !e506 */
Ssa_CompileTimeAssert( sizeof(KeyM_CertificateElementType_Ssa_TrustModelBackendCert_validityNotAfter) == 15u, InvalidSizeOf_KeyM_CertificateElementType_Ssa_TrustModelBackendCert_validityNotAfter); /*lint !e506 */
Ssa_CompileTimeAssert( sizeof(KeyM_CertificateElementType_Ssa_TrustModelBackendCert_Version) == 1u, InvalidSizeOf_KeyM_CertificateElementType_Ssa_TrustModelBackendCert_Version); /*lint !e506 */
Ssa_CompileTimeAssert( sizeof(KeyM_CertificateElementType_Ssa_TrustModelBackendPeerCert_ext_authKeyId) == 20u, InvalidSizeOf_KeyM_CertificateElementType_Ssa_TrustModelBackendPeerCert_ext_authKeyId); /*lint !e506 */
Ssa_CompileTimeAssert( sizeof(KeyM_CertificateElementType_Ssa_TrustModelBackendPeerCert_ext_basicConstraints) == 1u, InvalidSizeOf_KeyM_CertificateElementType_Ssa_TrustModelBackendPeerCert_ext_basicConstraints); /*lint !e506 */
Ssa_CompileTimeAssert( sizeof(KeyM_CertificateElementType_Ssa_TrustModelBackendPeerCert_ext_subKeyId) == 20u, InvalidSizeOf_KeyM_CertificateElementType_Ssa_TrustModelBackendPeerCert_ext_subKeyId); /*lint !e506 */
Ssa_CompileTimeAssert( sizeof(KeyM_CertificateElementType_Ssa_TrustModelBackendPeerCert_validityNotAfter) == 15u, InvalidSizeOfD_KeyM_CertificateElementType_Ssa_TrustModelBackendPeerCert_validityNotAfter); /*lint !e506 */
Ssa_CompileTimeAssert( sizeof(KeyM_CertificateElementType_Ssa_TrustModelBackendPeerCert_Version) == 1u, InvalidSizeOfData_KeyM_CertificateElementType_Ssa_TrustModelBackendPeerCert_Version); /*lint !e506 */
Ssa_CompileTimeAssert( sizeof(KeyM_CertificateElementType_Ssa_TrustModelEcuCert_ext_authKeyId) == 20u, InvalidSizeOf_KeyM_CertificateElementType_Ssa_TrustModelEcuCert_ext_authKeyId); /*lint !e506 */
Ssa_CompileTimeAssert( sizeof(KeyM_CertificateElementType_Ssa_TrustModelEcuCert_ext_specialEcu) == 1u, InvalidSizeOf_KeyM_CertificateElementType_Ssa_TrustModelEcuCert_ext_specialEcu); /*lint !e506 */
Ssa_CompileTimeAssert( sizeof(KeyM_CertificateElementType_Ssa_TrustModelEcuCert_Issuer) == 15u, InvalidSizeOf_KeyM_CertificateElementType_Ssa_TrustModelEcuCert_Issuer); /*lint !e506 */
Ssa_CompileTimeAssert( sizeof(KeyM_CertificateElementType_Ssa_TrustModelEcuCert_subject) == 30u, InvalidSizeOf_KeyM_CertificateElementType_Ssa_TrustModelEcuCert_subject); /*lint !e506 */
Ssa_CompileTimeAssert( sizeof(KeyM_CertificateElementType_Ssa_TrustModelEcuCert_SubjectPublicKeyInfoKey) == 33u, InvalidSizeOf_KeyM_CertificateElementType_Ssa_TrustModelEcuCert_SubjectPublicKeyInfoKey); /*lint !e506 */
Ssa_CompileTimeAssert( sizeof(KeyM_CertificateElementType_Ssa_TrustModelEcuCert_validityNotAfter) == 15u, InvalidSizeOf_KeyM_CertificateElementType_Ssa_TrustModelEcuCert_validityNotAfter); /*lint !e506 */
Ssa_CompileTimeAssert( sizeof(KeyM_CertificateElementType_Ssa_TrustModelEcuCert_Version) == 1u, InvalidSizeOf_KeyM_CertificateElementType_Ssa_TrustModelEcuCert_Version); /*lint !e506 */
Ssa_CompileTimeAssert( sizeof(KeyM_CertificateElementType_Ssa_TrustModelEcuPeerCert_ext_authKeyId) == 20u, InvalidSizeOfD_KeyM_CertificateElementType_Ssa_TrustModelEcuPeerCert_ext_authKeyId); /*lint !e506 */
Ssa_CompileTimeAssert( sizeof(KeyM_CertificateElementType_Ssa_TrustModelEcuPeerCert_ext_specialEcu) == 1u, InvalidSizeOf_KeyM_CertificateElementType_Ssa_TrustModelEcuPeerCert_ext_specialEcu); /*lint !e506 */
Ssa_CompileTimeAssert( sizeof(KeyM_CertificateElementType_Ssa_TrustModelEcuPeerCert_validityNotAfter) == 15u, InvalidSizeOf_KeyM_CertificateElementType_Ssa_TrustModelEcuPeerCert_validityNotAfter); /*lint !e506 */
Ssa_CompileTimeAssert( sizeof(KeyM_CertificateElementType_Ssa_TrustModelEcuPeerCert_Version) == 1u, InvalidSizeOf_KeyM_CertificateElementType_Ssa_TrustModelEcuPeerCert_Version); /*lint !e506 */
Ssa_CompileTimeAssert( sizeof(KeyM_CertificateElementType_Ssa_TrustModelIntermediateCert_ext_authKeyId) == 20u, InvalidSizeOf_KeyM_CertificateElementType_Ssa_TrustModelIntermediateCert_ext_authKeyId); /*lint !e506 */
Ssa_CompileTimeAssert( sizeof(KeyM_CertificateElementType_Ssa_TrustModelIntermediateCert_ext_basicConstraints) == 1u, InvalidSizeOf_KeyM_CertificateElementType_Ssa_TrustModelIntermediateCert_ext_basicConstraints); /*lint !e506 */
Ssa_CompileTimeAssert( sizeof(KeyM_CertificateElementType_Ssa_TrustModelIntermediateCert_ext_subKeyId) == 20u, InvalidSizeOf_KeyM_CertificateElementType_Ssa_TrustModelIntermediateCert_ext_subKeyId); /*lint !e506 */
Ssa_CompileTimeAssert( sizeof(KeyM_CertificateElementType_Ssa_TrustModelIntermediateCert_Issuer) == 15u, InvalidSizeOf_KeyM_CertificateElementType_Ssa_TrustModelIntermediateCert_Issuer); /*lint !e506 */
Ssa_CompileTimeAssert( sizeof(KeyM_CertificateElementType_Ssa_TrustModelIntermediateCert_subject) == 30u, InvalidSizeOf_KeyM_CertificateElementType_Ssa_TrustModelIntermediateCert_subject); /*lint !e506 */
Ssa_CompileTimeAssert( sizeof(KeyM_CertificateElementType_Ssa_TrustModelIntermediateCert_SubjectPublicKeyInfoKey) == 33u, InvalidSizeOf_KeyM_CertificateElementType_Ssa_TrustModelIntermediateCert_SubjectPublicKeyInfoKey); /*lint !e506 */
Ssa_CompileTimeAssert( sizeof(KeyM_CertificateElementType_Ssa_TrustModelIntermediateCert_validityNotAfter) == 15u, InvalidSizeOf_KeyM_CertificateElementType_Ssa_TrustModelIntermediateCert_validityNotAfter); /*lint !e506 */
Ssa_CompileTimeAssert( sizeof(KeyM_CertificateElementType_Ssa_TrustModelIntermediateCert_Version) == 1u, InvalidSizeOf_KeyM_CertificateElementType_Ssa_TrustModelIntermediateCert_Version); /*lint !e506 */
Ssa_CompileTimeAssert( sizeof(KeyM_CertificateElementType_Ssa_TrustModelIntermediatePeerCert_ext_authKeyId) == 20u, InvalidSizeOf_KeyM_CertificateElementType_Ssa_TrustModelIntermediatePeerCert_ext_authKeyId); /*lint !e506 */
Ssa_CompileTimeAssert( sizeof(KeyM_CertificateElementType_Ssa_TrustModelIntermediatePeerCert_ext_basicConstraints) == 1u, InvalidSizeOf_KeyM_CertificateElementType_Ssa_TrustModelIntermediatePeerCert_ext_basicConstraints); /*lint !e506 */
Ssa_CompileTimeAssert( sizeof(KeyM_CertificateElementType_Ssa_TrustModelIntermediatePeerCert_ext_subKeyId) == 20u, InvalidSizeOf_KeyM_CertificateElementType_Ssa_TrustModelIntermediatePeerCert_ext_subKeyId); /*lint !e506 */
Ssa_CompileTimeAssert( sizeof(KeyM_CertificateElementType_Ssa_TrustModelIntermediatePeerCert_validityNotAfter) == 15u, InvalidSizeOf_KeyM_CertificateElementType_Ssa_TrustModelIntermediatePeerCert_validityNotAfter); /*lint !e506 */
Ssa_CompileTimeAssert( sizeof(KeyM_CertificateElementType_Ssa_TrustModelIntermediatePeerCert_Version) == 1u, InvalidSizeOf_KeyM_CertificateElementType_Ssa_TrustModelIntermediatePeerCert_Version); /*lint !e506 */
Ssa_CompileTimeAssert( sizeof(KeyM_CertificateElementType_Ssa_TrustModelRootCert_ext_basicConstraints) == 1u, InvalidSizeOf_KeyM_CertificateElementType_Ssa_TrustModelRootCert_ext_basicConstraints); /*lint !e506 */
Ssa_CompileTimeAssert( sizeof(KeyM_CertificateElementType_Ssa_TrustModelRootCert_ext_keyUsage) == 2u, InvalidSizeOf_KeyM_CertificateElementType_Ssa_TrustModelRootCert_ext_keyUsage); /*lint !e506 */
Ssa_CompileTimeAssert( sizeof(KeyM_CertificateElementType_Ssa_TrustModelRootCert_Issuer) == 15u, InvalidSizeOf_KeyM_CertificateElementType_Ssa_TrustModelRootCert_Issuer); /*lint !e506 */
Ssa_CompileTimeAssert( sizeof(KeyM_CertificateElementType_Ssa_TrustModelRootCert_subject) == 30u, InvalidSizeOf_KeyM_CertificateElementType_Ssa_TrustModelRootCert_subject); /*lint !e506 */
Ssa_CompileTimeAssert( sizeof(KeyM_CertificateElementType_Ssa_TrustModelRootCert_SubjectPublicKeyInfoKey) == 33u, InvalidSizeOf_KeyM_CertificateElementType_Ssa_TrustModelRootCert_SubjectPublicKeyInfoKey); /*lint !e506 */
Ssa_CompileTimeAssert( sizeof(KeyM_CertificateElementType_Ssa_TrustModelRootCert_validityNotAfter) == 15u, InvalidSizeOf_KeyM_CertificateElementType_Ssa_TrustModelRootCert_validityNotAfter); /*lint !e506 */
Ssa_CompileTimeAssert( sizeof(KeyM_CertificateElementType_Ssa_TrustModelRootCert_Version) == 1u, InvalidSizeOf_KeyM_CertificateElementType_Ssa_TrustModelRootCert_Version); /*lint !e506 */
#if (SSA_ECU_TYPE == SSA_ECU_TYPE_VSM)
Ssa_CompileTimeAssert(sizeof(Csm_KeyDataType_Ssa_SharedSecret) == 32u, InvalidSizeOf_Csm_KeyDataType_Ssa_SharedSecret); /*lint !e506 */
Ssa_CompileTimeAssert(sizeof(Csm_EncryptResultType_AES128Encrypt) == 80u, InvalidSizeOf_Csm_EncryptResultType_AES128Encrypt); /*lint !e506 */
Ssa_CompileTimeAssert(sizeof(Csm_KeyDataType_Ssa_EcuCert) <= 910u, InvalidSizeOf_Csm_KeyDataType_Ssa_EcuCert); /*lint !e506 */
#else
Ssa_CompileTimeAssert(sizeof(Csm_DecryptResultType_AES128Decrypt) == 80u, InvalidSizeOf_Csm_DecryptResultType_AES128Decrypt); /*lint !e506 */
Ssa_CompileTimeAssert(sizeof(Csm_DecryptResultType_AES128DecryptWithPadding) == 1056u, InvalidSizeOf_Csm_DecryptResultType_AES128DecryptWithPadding); /*lint !e506 */
#endif

typedef struct
{
  uint32 certDataLength;
  Ssa_DataPtr certData;
} Ssa_KeyM_CertDataType;

/*! Information structure for the certificates to be replaced. */
typedef struct
{
  P2CONST(uint8, TYPEDEF, RTE_SSA_KEYM_APPL_DATA) ecu;
  uint16 ecuLength;
  P2CONST(uint8, TYPEDEF, RTE_SSA_KEYM_APPL_DATA) backendCa;
  uint16 backendCaLength;
  P2CONST(uint8, TYPEDEF, RTE_SSA_KEYM_APPL_DATA) backendCaLink;
  uint16 backendCaLinkLength;
  P2CONST(uint8, TYPEDEF, RTE_SSA_KEYM_APPL_DATA) rootCa;
  uint16 rootCaLength;
  P2CONST(uint8, TYPEDEF, RTE_SSA_KEYM_APPL_DATA) rootCaLink;
  uint16 rootCaLinkLength;
} Ssa_KeyM_CertChainDataType;

/*! Structure containing states, configuration and result data for controlling the mainloop processing. 
 *  Result buffer is only used for mainloop processing triggered from diagnostic service routines which
 *  never runs patrallely. So data consistency is always ensured. */
typedef struct
{
  uint16 numGenSymKeys;
  uint16 counterWaitBeforeGenerate;
  uint16 counterRetry;
  uint8 state;
  uint8 conf;
  uint8 result;
} Ssa_KeyM_MainloopProcType;

/*! Generic state handler function prototypes. */
typedef P2FUNC(Std_ReturnType, Ssa_KeyM_CODE, Ssa_StateHandlerFctPtrType_ReplaceTrustModelCertificates)(P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) Trust_Certificates_In, Dcm_OpStatusType OpStatus, P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) routineInfo_Out, P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) Verification_Result_Out, uint16 DataLength, P2VAR(Dcm_NegativeResponseCodeType, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) ErrorCode);
typedef P2FUNC(Std_ReturnType, Ssa_KeyM_CODE, Ssa_StateHandlerFctPtrType_ReplaceTrustModelRootCertificate)(P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) signature_new_Root_In, P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) signature_In, P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) Certificates_In, Dcm_OpStatusType OpStatus, P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) routineInfo_Out, P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) Verification_Result_Out, uint16 DataLength, P2VAR(Dcm_NegativeResponseCodeType, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) ErrorCode);
#if (SSA_ECU_TYPE == SSA_ECU_TYPE_VSM)
typedef P2FUNC(Std_ReturnType, Ssa_KeyM_CODE, Ssa_StateHandlerFctPtrType_EcuSharedSecretEncryption)(uint8 chainOfTrust, P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) Nonce_In, P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) Ephemeral_ECU_Public_Key_In, P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) In_Data_Signature_In, P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) In_Certificates_In, Dcm_OpStatusType OpStatus, P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) routineInfo_Out, P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) Verification_Result_Out, P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) Date_and_Time_Out, P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) Tick_Count_Out, P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) Tick_Count_Offset_Out, P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) Encrypted_Nonce_and_Shared_Secret_Out, P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) Ephemeral_VSM_Public_Key_Out, P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) Out_Data_Signature_Out, P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) Out_Certificates_Out, P2VAR(uint16, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) DataLength, P2VAR(Dcm_NegativeResponseCodeType, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) ErrorCode, boolean allowStandardSecret);
#else
typedef P2FUNC(Std_ReturnType, Ssa_KeyM_CODE, Ssa_StateHandlerFctPtrType_EcuSharedSecretDistribution)(P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) Date_and_Time_In, P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) Tick_Count_In, P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) Tick_Count_Offset_In, P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) Encrypted_Nonce_and_Shared_Secret_In, P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) Ephemeral_VSM_Public_Key_In, P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) Data_Signature_In, P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) Certificates_In, uint16 DataLength);
# if (SSA_DIAG_SERVICE_INJECT_SEED == STD_ON)
typedef P2FUNC(Std_ReturnType, Ssa_KeyM_CODE, Ssa_StateHandlerFctPtrType_InjectSeed)(P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) Ephemeral_Backend_Public_Key_In, P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) Data_Signature_In, P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) Encrypted_Seed_In, uint16 DataLength);
# endif
#endif

#if (SSA_DIAG_SERVICE_TRUST_MODEL_GENERATE_KEY_PAIR == STD_ON)
typedef P2FUNC(Std_ReturnType, Ssa_KeyM_CODE, Ssa_StateHandlerFctPtrType_TrustModelGenerateKeyPair)(
    P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) Verification_Result_Out,
    P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) CSR_Signature_Out,
    P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) Trust_Model_ECU_CSR_Out,
    P2VAR(uint16, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) DataLength);
#endif

/*! Workspace structure for processing diagnostic routine control service Replace_Trust_model_Certificates */
typedef struct
{
  uint16 certLength_ecu;
  uint16 certLength_intermediate;
  uint16 certLength_backend;
  uint16 certIdx_ecu;
  uint16 certIdx_intermediate;
  uint16 certIdx_backend;
  uint16 certLength_ecu_backup;
  uint16 certLength_intermediate_backup;
  uint16 certLength_backend_backup;
  uint16 certIdx_ecu_backup;
  uint16 certIdx_intermediate_backup;
  uint16 certIdx_backend_backup;
  uint8 verifResultBeforeRollback; /*!< The verification result of the chain that was passed to the diagnostic routine.
                                        If a rollback is performed, this will be returned to the diagnostic tester. */
  uint8 rollbackState;
  KeyM_CertificateStatusType certificateStatusBackend;
  KeyM_CertificateStatusType certificateStatusIntermediate;
  KeyM_CertificateStatusType certificateStatusEcu;
  Dcm_Data3006ByteType trustCertificatesBackup;
  uint16 dataLengthBackup;
  Ssa_KeyM_CertDataType certificateDataBackendBackup;
  Ssa_KeyM_CertDataType certificateDataIntermediateBackup;
  Ssa_KeyM_CertDataType certificateDataEcuBackup;
} KeyM_TrustModelReplaceCertificatesType;

/*! Workspace structure for processing diagnostic routine control service Replace_Trust_model_Root_Certificate */
typedef struct
{
  uint16 certLength_enh;
  uint16 certLength_newroot;
  uint16 certIdx_enh;
  uint16 certIdx_newroot;
  boolean isRollback;
  uint8 verifResultBeforeRollback; /*!< The verification result of the chain that was passed to the diagnostic routine.
                                        If a rollback is performed, this will be returned to the diagnostic tester. */
  Crypto_VerifyResultType csmSignatureVerifyCallbackResult;
  boolean csmSignatureVerifyCallbackOccurred;
  Crypto_VerifyResultType csmReplacementAuthorityCryptoVerifyResult;
  Csm_ResultType csmReplacementAuthorityCallbackResult;
  boolean csmReplacementAuthorityCallbackOccurred;
  uint8 replacementPackageBuffer[SSA_SIZEOF_REPLACEMENT_PACKAGE_BUFFER];
  uint16 replacementPackageBufferLength;
  Ssa_KeyM_CertDataType certificateDataRootBackup;
  uint8 certBufferRoot[SSA_MAX_SIZE_TRUSTMODEL_ROOT_CA_CERT];
} KeyM_TrustModelReplaceRootCertificateType;

/*! Workspace structure for processing diagnostic routine control service Commissioning */
typedef struct
{
  uint8 certBufferBackendPeer[SSA_MAX_SIZE_TRUSTMODEL_BACKEND_CA_CERT];
  uint8 certBufferIntermediatePeer[SSA_MAX_SIZE_TRUSTMODEL_INTERMEDIATE_CA_CERT];
  uint8 certBufferEcuPeer[SSA_MAX_SIZE_TRUSTMODEL_ECU_CERT];
  Ssa_KeyM_CertDataType keyMCertData[SSA_KEYM_NUMBER_OF_TRANSMITTED_CERTS];
  uint8 KeyM_TargetEcuPublicKey[SSA_SIZEOF_PUBLICKEY];
  uint16 KeyM_RoutineCtrlDataLengthOut;
  uint8 verificationResult;
  Dcm_NegativeResponseCodeType errorCode;
  uint8 KeyM_SharedSecretEncDec_Nonce[SSA_SIZEOF_NONCE];
  /* Temporary data buffer for data encryption and decryption used in routine SecOC_ECU_Shared_Secret_Encryption and SecOC_ECU_Shared_Secret_Distribution. */
  uint8 KeyM_SharedSecretEncDec_DataBuffer[SSA_KEYM_DIS_BUFFER_SIZE];
} KeyM_TrustModelCommissioningType;

/*! Workspace structure for processing diagnostic routine control service Certificate_Self_Check */
typedef struct
{
  uint8 certBufferRoot[SSA_MAX_SIZE_TRUSTMODEL_ROOT_CA_CERT];
  uint8 verResult[SSA_KEYM_SELFCHECK_SIZEOF_VERIFICATION_RESULT];
  uint8 verResultLen;
} KeyM_CertificateSelfCheckType;

/*! Workspace structure for processing diagnostic routine control service Replace_Certificates */
typedef struct
{
  uint8 certReplacement;
  Ssa_KeyM_CertChainDataType cert;
  CertP_ParsedCertStructureType receivedParsedEcuCert;
  CertP_ParsedCertStructureType receivedParsedBackendCaCert;
  CertP_ParsedCertStructureType receivedParsedRootCaCert;
  CertP_ParsedCertStructureType receivedParsedBackendCaOrRootCaLinkCert;
  boolean isDevelopCertReplaced;
} KeyM_ReplaceCertificatesType;

/*! Workspace structure for processing diagnostic data service ECU_Certificate_Read_Data_Signature_ReadData */
typedef struct
{
  uint8 genSigDataBufferIn[SSA_SIZEOF_NONCE + SSA_SIZEOF_PUBLICKEY]; /* PRQA S 3218 */ /* MD_SSA_OBJECT_AT_FILE_SCOPE */
  uint8 genSigDataBufferOut[SSA_SIZEOF_SIGNATURE];  /* PRQA S 3218 */ /* MD_SSA_OBJECT_AT_FILE_SCOPE */
} KeyM_EcuCertificateReadDataType;

/*! Workspace structure for processing diagnostic routine control service Inject_Seed */
#if ((SSA_ECU_TYPE != SSA_ECU_TYPE_VSM) && (SSA_DIAG_SERVICE_INJECT_SEED == STD_ON))
# define SSA_KEYM_INJECT_SEED_DATA_BUFFER_SIZE                        (sizeof(Dcm_Data1058ByteType) + sizeof(Dcm_Data32ByteType))
/*                                             ^ encrypted seed               ^ Nonce                  */
typedef struct
{
  uint8 dataBuffer[SSA_KEYM_INJECT_SEED_DATA_BUFFER_SIZE];
  uint8 currentNonce[SSA_SIZEOF_NONCE];
  uint32 seedLength;
  uint8 verificationResult;
  Dcm_NegativeResponseCodeType errorCode;
} KeyM_InjectSeedType;
#endif

/*! Shared data structure for workspaces used by KeyM for processing diagnostic services */
typedef union
{ /* PRQA S 0750 */ /* MD_MSR_Union */
  KeyM_TrustModelReplaceCertificatesType trustModelReplaceCerts;
  KeyM_TrustModelReplaceRootCertificateType trustModelReplaceRootCert;
  KeyM_TrustModelCommissioningType trustModelCommissioning;
  KeyM_CertificateSelfCheckType certSelfCheck;
  KeyM_ReplaceCertificatesType replaceCerts;
  KeyM_EcuCertificateReadDataType ecuCertificateReadData;
#if ((SSA_ECU_TYPE != SSA_ECU_TYPE_VSM) && (SSA_DIAG_SERVICE_INJECT_SEED == STD_ON))
  KeyM_InjectSeedType injectSeed;
#endif
} KeyM_DiagnosticWorkspaceType;

/*! KeyM diagnostic processing buffer type */
typedef struct
{
  /* generic state */
  uint8 state;
  /* State variable for sub function KeyM_CarSpecificSecretDistribution_VerifyEcuCert. */
  uint8 verifyCertState;
  /* State variable for sub function KeyM_Replace_Certificate_Replace_RootAndLower. */
  uint8 replaceCertificatesReplaceRootAndLowerState;
  /* State variable for sub function KeyM_Replace_Certificate_Replace_BackendAndLower. */
  uint8 replaceCertificatesReplaceBackendAndLowerState;
#if (SSA_ECU_TYPE == SSA_ECU_TYPE_VSM)
  /* State variable for sub function KeyM_Replace_Certificate_Replace_Ecu. */
  uint8 replaceCertificatesReplaceEcuState;
  /* State variable for sub function KeyM_Replace_Certificate_Verify_Ecu. */
  uint8 replaceCertificatesVerifyEcuState;
#endif

  /* Flag for Success of Service 22 DID 191 */
  uint8 randomNumberGeneration_Flag;

  /* General purpose buffer of size 32 byte. */
  uint8 buffer32Byte[SSA_SIZEOF_NONCE];

  /* used for certificate service requests */
  uint8 serviceResponseBuffer[SSA_MAX_SIZE_KEYM_SERVICE_CERTIFICATE_RESPONSE];
  uint16 serviceResponseBufferLength;
  boolean serviceResponseCallbackOccurred;
  KeyM_ResultType serviceResponseCallbackResult;
  /* used for certificate verify requests */
  boolean certificateVerifyCallbackOccurred;
  KeyM_CertificateStatusType certificateVerifyCallbackResult;
  uint8 extensionsUniqueEcuIds[SSA_SIZEOF_ENCODED_UNIQUEECUIDS];

  /* workspace union */
  KeyM_DiagnosticWorkspaceType ws;
} KeyM_DiagProcBufferType;

/*!  KeyM_CertElementGet function pointer type */
typedef P2FUNC(Std_ReturnType, Ssa_KeyM_CODE, Ssa_KeyM_KeyMCertificateElementFctPtrType)(P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) CertificateElementData, P2VAR(uint32, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) CertificateDataLength);

/**********************************************************************************************************************
 *  LOCAL DATA
 **********************************************************************************************************************/
#define Ssa_KeyM_START_SEC_VAR_NOINIT_UNSPECIFIED
#include "Ssa_KeyM_MemMap.h" /* PRQA S 5087 */ /* MD_MSR_MemMap */

#if (SSA_KEEP_BUFFER_VARIABLES_STATIC == STD_ON)
/*! Storage for the root certificate's raw data. */
SSA_KEYM_LOCAL VAR(uint8, Ssa_KeyM_VAR_NOINIT) KeyM_RootCertBuf[SSA_SIZEOF_CERT_MAX];
/*! Storage for the backend certificate's raw data. */
SSA_KEYM_LOCAL VAR(uint8, Ssa_KeyM_VAR_NOINIT) KeyM_BackendCertBuf[SSA_SIZEOF_CERT_MAX];
# if (SSA_ECU_TYPE == SSA_ECU_TYPE_VSM)
/*! Storage for the ECU certificate's raw data. */
SSA_KEYM_LOCAL VAR(uint8, Ssa_KeyM_VAR_NOINIT) KeyM_EcuCertBuf[SSA_SIZEOF_CERT_MAX];
# endif
#endif

/*! Storage for the parsed root certificate. */
SSA_KEYM_LOCAL VAR(CertP_ParsedCertStructureType, Ssa_KeyM_VAR_NOINIT) KeyM_ParsedRootCert;
/*! Storage for the parsed backend certificate. */
SSA_KEYM_LOCAL VAR(CertP_ParsedCertStructureType, Ssa_KeyM_VAR_NOINIT) KeyM_ParsedBackendCert;
#if (SSA_ECU_TYPE == SSA_ECU_TYPE_VSM)
/*! Storage for the parsed ECU certificate. */
SSA_KEYM_LOCAL VAR(CertP_ParsedCertStructureType, Ssa_KeyM_VAR_NOINIT) KeyM_ParsedEcuCert;
#endif

/*! State variable for asynchronous CSM handling in KeyM_CsmSignatureGenerate. */
SSA_KEYM_LOCAL VAR(uint8, Ssa_KeyM_VAR_NOINIT) KeyM_SigGenAsyncState;
#if (SSA_KEEP_BUFFER_VARIABLES_STATIC == STD_ON)
/* Storages. */
SSA_KEYM_LOCAL VAR(uint32, Ssa_KeyM_VAR_NOINIT) KeyM_SignatureOutLength;  /* PRQA S 3218 */ /* MD_SSA_OBJECT_AT_FILE_SCOPE */
#endif

/*! State variable for asynchronous CSM handling in KeyM_CsmSignatureVerify. */
SSA_KEYM_LOCAL VAR(uint8, Ssa_KeyM_VAR_NOINIT) KeyM_SigVerifAsyncState;
#if (SSA_KEEP_BUFFER_VARIABLES_STATIC == STD_ON)
/* Storages. */
SSA_KEYM_LOCAL VAR(Crypto_VerifyResultType, Ssa_KeyM_VAR_NOINIT) KeyM_CsmVerificationResult;  /* PRQA S 3218 */ /* MD_SSA_OBJECT_AT_FILE_SCOPE */
#endif

/*! State variable for asynchronous CSM handling in KeyM_CsmKeyExchangeCalcPubVal. */
SSA_KEYM_LOCAL VAR(uint8, Ssa_KeyM_VAR_NOINIT) KeyM_CalcPubValAsyncState;
/* Storages. */
SSA_KEYM_LOCAL VAR(uint32, Ssa_KeyM_VAR_NOINIT) KeyM_KeyExchangePubValLength; /* PRQA S 3218 */ /* MD_SSA_OBJECT_AT_FILE_SCOPE */

/*! State variable for asynchronous CSM handling in KeyM_CsmKeyExchangeCalcSecret. */
SSA_KEYM_LOCAL VAR(uint8, Ssa_KeyM_VAR_NOINIT) KeyM_CalcSecretAsyncState;

/*! State variable for asynchronous CSM handling in KeyM_CsmRandomGenerate. */
SSA_KEYM_LOCAL VAR(uint8, Ssa_KeyM_VAR_NOINIT) KeyM_RandomGenerateAsyncState;
/* Storages. */
SSA_KEYM_LOCAL VAR(uint32, Ssa_KeyM_VAR_NOINIT) KeyM_RandomGenerateResultLength;  /* PRQA S 3218 */ /* MD_SSA_OBJECT_AT_FILE_SCOPE */

/*! State variable for sub function KeyM_VerifyPublicKeyWithEcuPrivateKey. */
SSA_KEYM_LOCAL VAR(uint8, Ssa_KeyM_VAR_NOINIT) KeyM_VerifyPubKeyState;
#if (SSA_KEEP_BUFFER_VARIABLES_STATIC == STD_ON)
/* Storage. */
SSA_KEYM_LOCAL VAR(uint8, Ssa_KeyM_VAR_NOINIT) KeyM_SignatureTest[SSA_SIZEOF_SIGNATURE];  /* PRQA S 3218 */ /* MD_SSA_OBJECT_AT_FILE_SCOPE */
#endif

/*! State variable for asynchronous CSM handling in Ssa_KeyM_CsmCallbackNotification_KeyGenerate_TrustModelEcuCsr. */
#if ((SSA_DIAG_SERVICE_TRUST_MODEL_GENERATE_KEY_PAIR == STD_ON) && (SSA_GENERATE_KEY_PAIR_CUSTOM_CALLOUT == STD_OFF))
SSA_KEYM_LOCAL VAR(uint8, Ssa_KeyM_VAR_NOINIT) KeyM_GenerateTrustModelEcuCsrKeyAsyncState;
#endif

/*! State variable for sub function KeyM_KeyExchangeCalcSymmetricKey. */
SSA_KEYM_LOCAL VAR(uint8, Ssa_KeyM_VAR_NOINIT) KeyM_KeyExchangeCalcSymmetricKeyState;

/*! Static variables for processing the car-specific secret.
 * Context: Ssa_KeyM_Init
            Ssa_KeyM_Com_VehicleSharedSecretNotification
            Ssa_KeyM_MainFunction
            Ssa_KeyM_RoutineServices_Routine_SecOC_ECU_Shared_Secret_Encryption
            Ssa_KeyM_RoutineServices_Routine_SecOC_ECU_TickCount_Synchronization
            Ssa_KeyM_RoutineServices_Routine_SecOC_ECU_Shared_Secret_Distribution
            Ssa_KeyM_RoutineServices_Routine_SecOC_VSM_Derive_Symmetric_Keys
            Ssa_KeyM_RoutineServices_Routine_SecOC_VSM_Renew_Shared_Secret
 */
SSA_KEYM_LOCAL VAR(Ssa_KeyM_MainloopProcType, Ssa_KeyM_VAR_NOINIT) KeyM_MainLoopProc;
SSA_KEYM_LOCAL VAR(uint8, Ssa_KeyM_VAR_NOINIT) KeyM_CarSpecificSecret[SSA_SIZEOF_SECRET];

/*! KeyM buffer */
SSA_KEYM_LOCAL VAR(KeyM_DiagProcBufferType, Ssa_KeyM_VAR_NOINIT) KeyM_DiagProc;

#if ((SSA_ECU_TYPE != SSA_ECU_TYPE_VSM) && (SSA_DIAG_SERVICE_INJECT_SEED == STD_ON))
/*! State variable for asynchronous CSM handling in KeyM_CsmRandomSeed. */
SSA_KEYM_LOCAL VAR(uint8, Ssa_KeyM_VAR_NOINIT) KeyM_RandomSeedState;
#endif

/*! True if the last KeyM_ServiceCertificate() call in KeyM_TrustModel_InitCsr() has returned "busy" */
SSA_KEYM_LOCAL VAR(boolean, Ssa_KeyM_VAR_NOINIT) KeyM_lastCsrCreationReturnedBusy;

/*! Storage for common name */
/*  Use static element data buffers since buffers might be accessed
 *  not until service certificate is called (asynchronously). */
 /* PRQA S 3218 2 */ /* MD_SSA_OBJECT_AT_FILE_SCOPE */
SSA_KEYM_LOCAL VAR(uint8, Ssa_KeyM_VAR_NOINIT) KeyM_CommonName[SSS_KEYM_MAX_LEN_COMMON_NAME];
SSA_KEYM_LOCAL VAR(uint16, Ssa_KeyM_VAR_NOINIT) KeyM_CommonNameLength;

#define Ssa_KeyM_STOP_SEC_VAR_NOINIT_UNSPECIFIED
#include "Ssa_KeyM_MemMap.h" /* PRQA S 5087 */ /* MD_MSR_MemMap */

/**********************************************************************************************************************
 *  LOCAL FUNCTION PROTOTYPES
 **********************************************************************************************************************/
#define Ssa_KeyM_START_SEC_CODE
#include "Ssa_KeyM_MemMap.h" /* PRQA S 5087 */ /* MD_MSR_MemMap */

/**********************************************************************************************************************
 *  KeyM_GetAndParseStoredCert()
 *********************************************************************************************************************/
/*!
 * \brief         Gets the requested certificate and parses the certificate.
 * \details       This function gets the data of the requested certificate. If the requested certificate has not
 *                been successfully parsed yet it will be parsed during this function call.
 * \param[in]     pkiRole          The PKI role of the requested certificate. It identifies the requested certificate.
 * \param[in,out] certBuffer       Pointer to the memory where the certificate raw data shall be copied to.
 * \param[in,out] certBufferLength Length of the certificate raw data.
 * \param[in]     reParse          Parse the certificate always.
 * \return        E_OK     Request successful.
 *                E_NOT_OK Request failed.
 * \pre           All provided pointers must be valid.
 *                The buffer referenced by certBuffer must provide at least SSA_SIZEOF_CERT_MAX many bytes.
 * \context       TASK
 * \reentrant     FALSE
 * \synchronous   TRUE
 * \spec          requires $lengthOf(certBuffer) >= SSA_SIZEOF_CERT_MAX;                                       \endspec
 */
SSA_KEYM_LOCAL FUNC(Std_ReturnType, Ssa_KeyM_CODE) KeyM_GetAndParseStoredCert(
  CertP_PkiRoleType pkiRole,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) certBuffer,
  P2VAR(uint16, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) certBufferLength,
  boolean reParse);

/**********************************************************************************************************************
 *  KeyM_VerifyPublicKeyWithEcuPrivateKey()
 *********************************************************************************************************************/
/*!
 * \brief       Verifies if the public key of the given certificate belongs to the ECU private key.
 * \details     -
 * \param[in]   chainOfTrust       The chain of trust to be used.
 * \param[in]   publicKey          Used only in case of chainOfTrust SSA_DIAGNOSTIC_KEY_PAIR.
 * \param[out]  verificationResult Positive response code. CRYPTO_E_VER_OK if verification succeeded.
 * \return      E_OK          Request successful.
 *              E_NOT_OK      Request failed due to an error.
 *              SSA_E_PENDING Requested service is pending.
 * \pre         All provided pointers must be valid.
 * \context     TASK
 * \reentrant   TRUE
 * \synchronous FALSE
 */
SSA_KEYM_LOCAL FUNC(Std_ReturnType, Ssa_KeyM_CODE) KeyM_VerifyPublicKeyWithEcuPrivateKey(
  uint8 chainOfTrust,
  P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) publicKey,
  P2VAR(Crypto_VerifyResultType, AUTOMATIC, AUTOMATIC) verificationResult);

/**********************************************************************************************************************
 *  KeyM_KeyExchangeCalcSymmetricKey()
 *********************************************************************************************************************/
/*!
 * \brief       Calculates a symmetric encryption key.
 * \details     This function calculates a symmetric encryption key from the given nonce and an ECDH shared secret.
 *              The symmetric key is stored within this function.
 * \param[in]   ePubKeyOther Pointer to the ephemeral public key of the counterpart.
 * \param[in]   nonce        Pointer to the nonce used for generation of the symmetric encryption key.
 * \param[out]  ePubKeyOwn   Pointer to the own ephemeral public key. This ephemeral key is only used in VSM.
 * \return      E_OK          Request successful.
 *              E_NOT_OK      Request failed.
 *              SSA_E_PENDING Requested service is pending.
 * \pre         If ePubKeyOwn is not a null pointer, the buffer referenced by this pointer must provide at least
 *              SSA_SIZEOF_PUBLICKEY many bytes.
 * \context     TASK
 * \reentrant   FALSE
 * \synchronous FALSE
 */
SSA_KEYM_LOCAL FUNC(Std_ReturnType, Ssa_KeyM_CODE) KeyM_KeyExchangeCalcSymmetricKey(
  P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) ePubKeyOther,
  P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) nonce,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) ePubKeyOwn);

#if (SSA_ECU_TYPE == SSA_ECU_TYPE_VSM)
/**********************************************************************************************************************
*  KeyM_KeyExchangeCalcSymmetricKey_StateHandler_PrepareStates()
**********************************************************************************************************************/
/*!
* \brief       Sets return value and state according to the provided retVal.
* \details     The state KeyExchangeCalcSymmetricKeyState is used in the function KeyM_KeyExchangeCalcSymmetricKey().
* \param[out]      KeyExchangeCalcSymmetricKeyState  State that has to be set.
* \param[in,out]   retVal                            Return value after passing a prepare state.
* \pre         All proviced pointers must be valid.
* \context     TASK
* \reentrant   TRUE
* \synchronous TRUE
*/
SSA_KEYM_LOCAL FUNC(void, Ssa_KeyM_CODE) KeyM_KeyExchangeCalcSymmetricKey_StateHandler_PrepareStates(
  P2VAR(Std_ReturnType, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) KeyExchangeCalcSymmetricKeyState,
  P2VAR(Std_ReturnType, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) retVal);

/**********************************************************************************************************************
*  KeyM_KeyExchangeCalcSymmetricKey_StateHandler_CalcPubValState()
**********************************************************************************************************************/
/*!
* \brief       Sets return value and state according to the provided retVal.
* \details     The state KeyExchangeCalcSymmetricKeyState is used in the function KeyM_KeyExchangeCalcSymmetricKey().
* \param[out]      KeyExchangeCalcSymmetricKeyState   State that has to be set.
* \param[in,out]   retVal                             Return value after passing the calcPubVal state.
* \pre         All provided pointers must be valid.
* \context     TASK
* \reentrant   TRUE
* \synchronous TRUE
*/
SSA_KEYM_LOCAL FUNC(void, Ssa_KeyM_CODE) KeyM_KeyExchangeCalcSymmetricKey_StateHandler_CalcPubValState(
  P2VAR(Std_ReturnType, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) KeyExchangeCalcSymmetricKeyState,
  P2VAR(Std_ReturnType, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) retVal);
#endif

/**********************************************************************************************************************
*  KeyM_KeyExchangeCalcSymmetricKey_StateHandler_CalcSecretState()
**********************************************************************************************************************/
/*!
* \brief       Sets return value and state according to the provided retVal.
* \details     The state KeyExchangeCalcSymmetricKeyState is used in the function KeyM_KeyExchangeCalcSymmetricKey().
* \param[in]   nonce        Pointer to the nonce used for generation of the symmetric encryption key.
* \param[out]      KeyExchangeCalcSymmetricKeyState   State that has to be set.
* \param[in,out]   retVal                             Return value after passing the calcSecret state.
* \pre         All provided pointers must be valid.
* \context     TASK
* \reentrant   TRUE
* \synchronous TRUE
*/
SSA_KEYM_LOCAL FUNC(void, Ssa_KeyM_CODE) KeyM_KeyExchangeCalcSymmetricKey_StateHandler_CalcSecretState(
  P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) nonce,
  P2VAR(Std_ReturnType, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) KeyExchangeCalcSymmetricKeyState,
  P2VAR(Std_ReturnType, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) retVal);

/**********************************************************************************************************************
 *  KeyM_StoreSecretHash()
 *********************************************************************************************************************/
/*!
 * \brief       Calculates and stores the hash value of the car-specific secret.
 * \details     -
 * \param[in]   carSpecificSecret  Pointer to the car-specific secret.
 * \return      E_OK              Request succeeded.
 *              E_NOT_OK          Request failed.
 *              RTE_E_UNCONNECTED Sub-call failed due to missing RTE connection.
 * \pre         -
 * \context     TASK
 * \reentrant   FALSE
 * \synchronous TRUE
 */
SSA_KEYM_LOCAL FUNC(Std_ReturnType, Ssa_KeyM_CODE) KeyM_StoreSecretHash(
  P2CONST(uint8, AUTOMATIC, AUTOMATIC) carSpecificSecret);

/**********************************************************************************************************************
 *  KeyM_CarSpecificSecretDistribution_VerifyEcuCert()
 *********************************************************************************************************************/
/*!
 * \brief       Verifies an ECU certificate and extracts the public key from it.
 * \details     -
 * \param[in]   chainOfTrust         The chain of trust to be used.
 * \param[in]   ecuCertificate       Input buffer containing two byte ECU length information and ECU certificate raw data.
 * \param[in]   DataLength           The length of the input buffer.
 * \param[out]  ecuPublicKey         Pointer to the ECU public key extracted from the ECU certificate.
 * \param[out]  Verification_Result  Positive response code of the routine.
 * \param[out]  ErrorCode            Negative response code to be sent by DCM if return value is E_NOT_OK.
 * \return      E_OK          Request succeeded.
 *              E_NOT_OK      Request failed.
 *              SSA_E_PENDING Requested service is pending.
 * \pre         All provided pointers must be valid.
 *              The buffer referenced by ecuPublicKey must provide at least SSA_SIZEOF_PUBLICKEY many bytes.
 * \context     TASK
 * \reentrant   FALSE
 * \synchronous FALSE
 */
SSA_KEYM_LOCAL FUNC(Std_ReturnType, Ssa_KeyM_CODE) KeyM_CarSpecificSecretDistribution_VerifyEcuCert(
  uint8 chainOfTrust,
  P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) ecuCertificate,
  uint16 DataLength,
  P2VAR(uint8, AUTOMATIC, AUTOMATIC) ecuPublicKey,
  P2VAR(uint8, AUTOMATIC, AUTOMATIC) Verification_Result,
  P2VAR(Dcm_NegativeResponseCodeType, AUTOMATIC, AUTOMATIC) ErrorCode);

/**********************************************************************************************************************
 *  KeyM_CarSpecificSecretDistribution_VerifyEcuCert_UniqueEcuIdChain()
 *********************************************************************************************************************/
/*!
 * \brief       Verifies a Trust Model certificate chain  and extracts the public key from it.
 * \details     -
 * \param[in]   ecuCertificate       Input buffer containing two byte ECU length information and ECU certificate raw data.
 * \param[in]   DataLength           The length of the input buffer.
 * \param[out]  Verification_Result  Positive response code of the routine.
 * \param[out]  ErrorCode            Negative response code to be sent by DCM if return value is E_NOT_OK.
 * \return      E_OK          Request succeeded.
 *              E_NOT_OK      Request failed.
 *              SSA_E_PENDING Requested service is pending.
 * \pre         All provided pointers must be valid.
 * \context     TASK
 * \reentrant   FALSE
 * \synchronous FALSE
 */
SSA_KEYM_LOCAL FUNC(Std_ReturnType, Ssa_KeyM_CODE) KeyM_CarSpecificSecretDistribution_VerifyEcuCert_UniqueEcuIdChain(
  P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) ecuCertificate,
  uint16 DataLength,
  P2VAR(uint8, AUTOMATIC, AUTOMATIC) Verification_Result,
  P2VAR(Dcm_NegativeResponseCodeType, AUTOMATIC, AUTOMATIC) ErrorCode);

/**********************************************************************************************************************
*  KeyM_CarSpecificSecretDistribution_VerifyEcuCert_UniqueEcuIdChain_PassCertsToAsrKeyM()
**********************************************************************************************************************/
/*!
* \brief       Pass certificates to AsrKeyM.
* \details     -
* \param[out]  Verification_Result  Positive response code of the routine.
* \return      RTE_E_OK      At least one certificate could not be passed to AsrKeyM.
*              SSA_E_PENDING All certificates could be passed (continue).
* \pre         Verification_Result must be a valid pointer.
* \context     TASK
* \reentrant   TRUE
* \synchronous FALSE
*/
SSA_KEYM_LOCAL FUNC(Std_ReturnType, Ssa_KeyM_CODE) KeyM_CarSpecificSecretDistribution_VerifyEcuCert_UniqueEcuIdChain_PassCertsToAsrKeyM(
  P2VAR(uint8, AUTOMATIC, AUTOMATIC) Verification_Result);

/**********************************************************************************************************************
*  KeyM_CarSpecificSecretDistribution_VerifyEcuCert_UniqueEcuIdChain_AdditionalCertElemVerification()
**********************************************************************************************************************/
/*!
* \brief       Verifies certificate elements that have not been checked by the KeyM
*              for all certificates in the UniqueEcuIdChain.
* \details     -
* \param[out]  Verification_Result  Positive response code of the routine.
* \param[out]  ErrorCode            Negative response code to be sent by DCM if return value is E_NOT_OK.
* \return      E_OK          Additional verification succeeded.
*              E_NOT_OK      Additional verification failed.
* \pre         All provided pointers must be valid.
* \context     TASK
* \reentrant   TRUE
* \synchronous FALSE
*/
SSA_KEYM_LOCAL FUNC(Std_ReturnType, Ssa_KeyM_CODE) KeyM_CarSpecificSecretDistribution_VerifyEcuCert_UniqueEcuIdChain_AdditionalCertElemVerification(
  P2VAR(uint8, AUTOMATIC, AUTOMATIC) Verification_Result,
  P2VAR(Dcm_NegativeResponseCodeType, AUTOMATIC, AUTOMATIC) ErrorCode);

#if (SSA_ECU_TYPE == SSA_ECU_TYPE_VSM)

/**********************************************************************************************************************
 *  KeyM_CarSpecificSecretDistribution_VerifyEcuCert_DiagChain()
 *********************************************************************************************************************/
/*!
 * \brief       Verifies an ECU certificate and extracts the public key from it.
 * \details     -
 * \param[in]   ecuCertificate       Input buffer containing two byte ECU length information and ECU certificate raw data.
 * \param[in]   DataLength           The length of the input buffer.
 * \param[out]  ecuPublicKey         Pointer to the ECU public key extracted from the ECU certificate.
 * \param[out]  Verification_Result  Positive response code of the routine.
 * \param[out]  ErrorCode            Negative response code to be sent by DCM if return value is E_NOT_OK.
 * \return      E_OK          Request succeeded.
 *              E_NOT_OK      Request failed.
 *              SSA_E_PENDING Requested service is pending.
 * \pre         All provided pointers must be valid.
 *              The buffer referenced by ecuPublicKey must provide at least SSA_SIZEOF_PUBLICKEY many bytes.
 * \context     TASK
 * \reentrant   FALSE
 * \synchronous FALSE
 */
SSA_KEYM_LOCAL FUNC(Std_ReturnType, Ssa_KeyM_CODE) KeyM_CarSpecificSecretDistribution_VerifyEcuCert_DiagChain(
  P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) ecuCertificate,
  uint16 DataLength,
  P2VAR(uint8, AUTOMATIC, AUTOMATIC) ecuPublicKey,
  P2VAR(uint8, AUTOMATIC, AUTOMATIC) Verification_Result,
  P2VAR(Dcm_NegativeResponseCodeType, AUTOMATIC, AUTOMATIC) ErrorCode);

/**********************************************************************************************************************
*  KeyM_CarSpecificSecretDistribution_VerifyEcuCert_DiagChain_GetEcuCertificate()
**********************************************************************************************************************/
/*!
* \brief       Parses the ECU certificate
* \details     -
* \param[in]   ecuCertificate       Input buffer containing two byte ECU length information and ECU certificate raw data.
* \param[in]   DataLength           The length of the input buffer.
* \param[out]  Verification_Result  Positive response code of the routine.
* \param[out]  ErrorCode            Negative response code to be sent by DCM if return value is E_NOT_OK.
* \param[out]  verifyCertState      State variable for handling verification of the diagnostic chain
* \return      E_OK          Parsing the ECU certificate succeeded.
*              E_NOT_OK      Parsing the ECU certificate failed.
* \pre         All provided pointers must be valid.
* \context     TASK
* \reentrant   FALSE
* \synchronous FALSE
*/
SSA_KEYM_LOCAL FUNC(Std_ReturnType, Ssa_KeyM_CODE) KeyM_CarSpecificSecretDistribution_VerifyEcuCert_DiagChain_GetEcuCertificate(
  P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) ecuCertificate,
  uint16 DataLength,
  P2VAR(uint8, AUTOMATIC, AUTOMATIC) Verification_Result,
  P2VAR(uint8, AUTOMATIC, AUTOMATIC) ErrorCode,
  P2VAR(uint8, AUTOMATIC, AUTOMATIC) verifyCertState);

/**********************************************************************************************************************
 *  KeyM_Replace_Certificate_Replace_Ecu()
 *********************************************************************************************************************/
/*!
 * \brief       Handles the replacement of an ECU certificate.
 * \details     -
 * \param[in]   cert                 Pointer to the information data structure about the certificates to be replaced.
 * \param[out]  Verification_Result  Positive response code of the routine.
 * \param[out]  ErrorCode            Negative response code to be sent by DCM if return value is E_NOT_OK.
 * \return      E_OK          Request succeeded.
 *              E_NOT_OK      Request failed.
 *              SSA_E_PENDING Requested service is pending.
 * \pre         All provided pointers must be valid.
 * \context     TASK
 * \reentrant   FALSE
 * \synchronous FALSE
 * \spec        requires cert->ecu != NULL_PTR;                                                                \endspec
 */
SSA_KEYM_LOCAL_INLINE FUNC(Std_ReturnType, Ssa_KeyM_CODE) KeyM_Replace_Certificate_Replace_Ecu(
  P2CONST(Ssa_KeyM_CertChainDataType, AUTOMATIC, AUTOMATIC) cert,
  P2VAR(uint8, AUTOMATIC, AUTOMATIC) Verification_Result,
  P2VAR(Dcm_NegativeResponseCodeType, AUTOMATIC, AUTOMATIC) ErrorCode);
#endif

/**********************************************************************************************************************
 *  KeyM_Replace_Certificate_VerifyAndReplaceReceivedCertificates()
 **********************************************************************************************************************/
/*!
 * \brief       Handles the replacement of an ECU certificate.
 * \details     -
 * \param[in]   extractedCertificate Indicates which certificate shall be replaced.
 * \param[in]   cert                 Pointer to the information data structure about the certificates to be replaced.
 * \param[out]  Verification_Result  Positive response code of the routine.
 * \param[out]  ErrorCode            Negative response code to be sent by DCM if return value is E_NOT_OK.
 * \return      E_OK          Request succeeded.
 *              E_NOT_OK      Request failed.
 *              SSA_E_PENDING Requested service is pending.
 * \pre         All provided pointers must be valid.
 * \context     TASK
 * \reentrant   FALSE
 * \synchronous FALSE
 * \spec        requires cert != NULL_PTR;                                                                     \endspec
 */
SSA_KEYM_LOCAL_INLINE FUNC(Std_ReturnType, Ssa_KeyM_CODE) KeyM_Replace_Certificate_VerifyAndReplaceReceivedCertificates(
  uint8 extractedCertificate,
  P2CONST(Ssa_KeyM_CertChainDataType, AUTOMATIC, AUTOMATIC) cert,
  P2VAR(uint8, AUTOMATIC, AUTOMATIC) verResult,
  P2VAR(Dcm_NegativeResponseCodeType, AUTOMATIC, AUTOMATIC) errCode);

/**********************************************************************************************************************
*  KeyM_Replace_Certificate_StateHandler_VerifyAndReplace()
**********************************************************************************************************************/
/*!
* \brief       Handles the results of certificate verification and replacement.
* \details     The state is used in Ssa_KeyM_RoutineServices_Replace_Certificates(), the state handling
*              is valid within the state KEYM_REPLACE_CERT_STATE_REPLACE.
* \param[in]      verResult  The verification result after verifying and replacing the certificates.
* \param[in,out]  retVal     The return value after verifying and replacing the certificates.
* \param[out]     state      The state to be set.
* \return      E_OK          Verification and replacement was successful.
*              E_NOT_OK      Verification or replacement failed.
* \pre         All provided pointers must be valid.
* \context     TASK
* \reentrant   FALSE
* \synchronous FALSE
*/
SSA_KEYM_LOCAL_INLINE FUNC(Std_ReturnType, Ssa_KeyM_CODE) KeyM_Replace_Certificate_StateHandler_VerifyAndReplace(
  uint8 verResult,
  P2VAR(Std_ReturnType, AUTOMATIC, AUTOMATIC) retVal,
  P2VAR(uint8, AUTOMATIC, AUTOMATIC) state);

/**********************************************************************************************************************
 *  KeyM_Replace_Certificate_Replace_BackendAndLower()
 *********************************************************************************************************************/
/*!
 * \brief       Handles the replacement of an ECU(Only VSM) and Backend certificate.
 * \details     -
 * \param[in]   cert                 Pointer to the information data structure about the certificates to be replaced.
 * \param[out]  Verification_Result  Positive response code of the routine.
 * \param[out]  ErrorCode            Negative response code to be sent by DCM if return value is E_NOT_OK.
 * \return      E_OK          Request succeeded.
 *              E_NOT_OK      Request failed.
 *              SSA_E_PENDING Requested service is pending.
 * \pre         All provided pointers must be valid.
 * \context     TASK
 * \reentrant   FALSE
 * \synchronous FALSE
 * \spec        requires cert != NULL_PTR;
 *              requires cert->backendCaLink != NULL_PTR;
 *              requires cert->backendCa != NULL_PTR;                                                          \endspec
 */
SSA_KEYM_LOCAL_INLINE FUNC(Std_ReturnType, Ssa_KeyM_CODE) KeyM_Replace_Certificate_Replace_BackendAndLower(
  P2CONST(Ssa_KeyM_CertChainDataType, AUTOMATIC, AUTOMATIC) cert,
  P2VAR(uint8, AUTOMATIC, AUTOMATIC) Verification_Result,
  P2VAR(Dcm_NegativeResponseCodeType, AUTOMATIC, AUTOMATIC) ErrorCode);

/**********************************************************************************************************************
 *  KeyM_Replace_Certificate_Replace_RootAndLower()
 *********************************************************************************************************************/
/*!
 * \brief       Handles the replacement of an ECU(Only VSM), Backend and Root certificate.
 * \details     -
 * \param[in]   cert                 Pointer to the information data structure about the certificates to be replaced.
 * \param[out]  Verification_Result  Positive response code of the routine.
 * \param[out]  ErrorCode            Negative response code to be sent by DCM if return value is E_NOT_OK.
 * \return      E_OK          Request succeeded.
 *              E_NOT_OK      Request failed.
 *              SSA_E_PENDING Requested service is pending.
 * \pre         All provided pointers must be valid.
 * \context     TASK
 * \reentrant   FALSE
 * \synchronous FALSE
 * \spec        requires cert != NULL_PTR;
 *              requires cert->rootCa != NULL_PTR;
 *              requires cert->rootCaLink != NULL_PTR;
 *              requires cert->backendCa != NULL_PTR;                                                          \endspec
 */
SSA_KEYM_LOCAL_INLINE FUNC(Std_ReturnType, Ssa_KeyM_CODE) KeyM_Replace_Certificate_Replace_RootAndLower(
  P2CONST(Ssa_KeyM_CertChainDataType, AUTOMATIC, AUTOMATIC) cert,
  P2VAR(uint8, AUTOMATIC, AUTOMATIC) Verification_Result,
  P2VAR(Dcm_NegativeResponseCodeType, AUTOMATIC, AUTOMATIC) ErrorCode);

/**********************************************************************************************************************
 *  KeyM_ReplaceCertificates_ParseCertsForVerification()
 **********************************************************************************************************************/
/*!
 * \brief         Parses and gets two certifcates.
 * \details       The certificates will be verified against each other during the process of certificate replacement.
 * \param[in]     subjectCertIdentifier    Identifier of the certificate that shall be verified.
 * \param[in]     certStructure            Pointer to the information data structure about the certificates to be verified.
 * \param[out]    subjectParsedCert        Holds the pointer to the memory location where the parser information of the
 *                                         certificate to be verified shall be stored.
 * \param[in,out] issuerCertBuffer         Pointer to the memory where the certificate raw data of the issuing certificate
 *                                         shall be copied to.
 * \param[in,out] issuerCertBufferLength   Length of the certificate raw data of the issuing certificate.
 * \param[out]    replacementAbortionFlag  Indicates if the replacement process shall be aborted.
 * \param[out]    Verification_Result      Positive response code of the routine.
 * \param[out]    ErrorCode                Negative response code to be sent by DCM if return value is E_NOT_OK.
 * \return      E_OK       No error during parsing.
 *              E_NOT_OK   An error occurred during parsing.
 * \pre         -
 * \context     TASK
 * \reentrant   TRUE
 * \synchronous TRUE
 */
SSA_KEYM_LOCAL_INLINE FUNC(Std_ReturnType, Ssa_KeyM_CODE) KeyM_ReplaceCertificates_ParseCertsForVerification(
  uint8 subjectCertIdentifier,
  P2CONST(Ssa_KeyM_CertChainDataType, AUTOMATIC, AUTOMATIC) certStructure,
  P2VAR(CertP_ParsedCertStructureType, AUTOMATIC, RTE_SSA_CERTP_APPL_VAR) subjectParsedCert,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) issuerCertBuffer,
  P2VAR(uint16, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) issuerCertBufferLength,
  P2VAR(Std_ReturnType, AUTOMATIC, AUTOMATIC) replacementAbortionFlag,
  P2VAR(uint8, AUTOMATIC, AUTOMATIC) Verification_Result,
  P2VAR(Dcm_NegativeResponseCodeType, AUTOMATIC, AUTOMATIC) ErrorCode);

/**********************************************************************************************************************
 *  KeyM_ReplaceCertificates_HandleParsingResult()
 **********************************************************************************************************************/
/*!
 * \brief       Handles the return value and verification result of parsing a certificate.
 * \details     This function is intended to be used within KeyM_ReplaceBackendAndLower, KeyM_ReplaceRootAndLower and
 *              KeyM_Replace_Certificate_Verify_Ecu.
 * \param[in,out]  rVal                 Return value after parsing.
 * \param[in]      verResToBeChecked    Verification result after parsing.
 * \param[in]      parsedCertId         Internal Id of the certificate that has been parsed.
 * \param[out]     Verification_Result  Positive response code of the routine.
 * \param[out]     ErrorCode            Negative response code to be sent by DCM if return value is E_NOT_OK.
 * \return      E_OK          No error during parsing.
 *              E_NOT_OK      An error occurred during parsing.
 * \pre         All provided pointers must be valid.
 * \context     TASK
 * \reentrant   TRUE
 * \synchronous TRUE
 */
SSA_KEYM_LOCAL FUNC(Std_ReturnType, Ssa_KeyM_CODE) KeyM_ReplaceCertificates_HandleParsingResult(
  P2VAR(Std_ReturnType, AUTOMATIC, AUTOMATIC) rVal,
  uint8 verResToBeChecked,
  uint8 parsedCertId,
  P2VAR(uint8, AUTOMATIC, AUTOMATIC) Verification_Result,
  P2VAR(Dcm_NegativeResponseCodeType, AUTOMATIC, AUTOMATIC) ErrorCode);

/**********************************************************************************************************************
 *  KeyM_ReplaceCertificates_HandleCertificateCompareResult()
 **********************************************************************************************************************/
/*!
 * \brief       Handles the return value and verification result of comparing the contents of the old and the new certificate.
 * \details     This function is intended to be used within KeyM_ReplaceBackendAndLower and KeyM_ReplaceRootAndLower
 *              and KeyM_Replace_Certificate_Verify_Ecu.
 * \param[in,out]  rVal                 Return value after certificate comparison.
 * \param[in]      isEqual              Result of the comparison.
 * \param[in]      newCertId            Internal Id of the received new certificate.
 * \param[out]     Verification_Result  Positive response code of the routine.
 * \param[out]     ErrorCode            Negative response code to be sent by DCM if return value is E_NOT_OK.
 * \return      E_OK          No error during certificate comparison.
 *              E_NOT_OK      An error occurred during certificate comparison.
 * \pre         All provided pointers must be valid.
 * \context     TASK
 * \reentrant   TRUE
 * \synchronous TRUE
 */
SSA_KEYM_LOCAL FUNC(Std_ReturnType, Ssa_KeyM_CODE) KeyM_ReplaceCertificates_HandleCertificateCompareResult(
  P2VAR(Std_ReturnType, AUTOMATIC, AUTOMATIC) rVal,
  boolean isEqual,
  uint8 newCertId,
  P2VAR(uint8, AUTOMATIC, AUTOMATIC) Verification_Result,
  P2VAR(Dcm_NegativeResponseCodeType, AUTOMATIC, AUTOMATIC) ErrorCode);

/**********************************************************************************************************************
 *  KeyM_ReplaceCertificates_HandleCertificateVerificationResult()
 **********************************************************************************************************************/
/*!
 * \brief       Handles the return value and verification result of a certificate verification.
 * \details     This function is intended to be used within KeyM_ReplaceBackendAndLower, KeyM_ReplaceRootAndLower
 *              and KeyM_Replace_Certificate_Verify_Ecu.
 * \param[in,out]  rVal                 Return value after verification.
 * \param[in]      verResToBeChecked    Verification result after certificate verification.
 * \param[in]      verifiedCertId       Internal Id of the certificate that has been verified.
 * \param[out]     Verification_Result  Positive response code of the routine.
 * \param[out]     ErrorCode            Negative response code to be sent by DCM if return value is E_NOT_OK.
 * \return      E_OK          No error during certificate verification.
 *              E_NOT_OK      An error occurred during certificate verification.
 *              SSA_E_PENDING Request is pending.
 * \pre         All provided pointers must be valid.
 * \context     TASK
 * \reentrant   TRUE
 * \synchronous TRUE
 */
SSA_KEYM_LOCAL FUNC(Std_ReturnType, Ssa_KeyM_CODE) KeyM_ReplaceCertificates_HandleCertificateVerificationResult(
  P2VAR(Std_ReturnType, AUTOMATIC, AUTOMATIC) rVal,
  uint8 verResToBeChecked,
  uint8 verifiedCertId,
  P2VAR(uint8, AUTOMATIC, AUTOMATIC) Verification_Result,
  P2VAR(Dcm_NegativeResponseCodeType, AUTOMATIC, AUTOMATIC) ErrorCode);

#if (SSA_ECU_TYPE == SSA_ECU_TYPE_VSM)
/**********************************************************************************************************************
 *  KeyM_ReplaceCertificates_HandleCertificateVerification_Ecu_Result()
 **********************************************************************************************************************/
/*!
 * \brief       Handles the return value and verification result of an Ecu certificate verification.
 * \details     This function is intended to be used within KeyM_Replace_Certificate_Verify_Ecu.
 * \param[in,out]  rVal                 Return value after Ecu certificate verification.
 * \param[in]      Verification_Result  Positive response code of the routine.
 * \param[out]     ErrorCode            Negative response code to be sent by DCM if return value is E_NOT_OK.
 * \return      E_OK          No error during Ecu certificate verification.
 *              E_NOT_OK      An error occurred during Ecu certificate verification.
 *              SSA_E_PENDING Request is pending.
 * \pre         All provided pointers must be valid.
 * \context     TASK
 * \reentrant   TRUE
 * \synchronous TRUE
 */
SSA_KEYM_LOCAL FUNC(Std_ReturnType, Ssa_KeyM_CODE) KeyM_ReplaceCertificates_HandleCertificateVerification_Ecu_Result(
  P2VAR(Std_ReturnType, AUTOMATIC, AUTOMATIC) rVal,
  P2CONST(uint8, AUTOMATIC, AUTOMATIC) Verification_Result,
  P2VAR(Dcm_NegativeResponseCodeType, AUTOMATIC, AUTOMATIC) ErrorCode);
#endif

/**********************************************************************************************************************
 *  KeyM_ReplaceCertificates_StateHandling()
 **********************************************************************************************************************/
/*!
 * \brief       Sets the internal state variable according to the received return value.
 * \details     This function is used in 
 *              - KeyM_Replace_Certificate_Replace_BackendAndLower 
 *                for the state KeyM_DiagProc.replaceCertificatesReplaceBackendAndLowerState
 *              - KeyM_Replace_Certificate_Replace_RootAndLower
 *                for the state KeyM_DiagProc.replaceCertificatesReplaceRootAndLowerState
 *              - KeyM_Replace_Certificate_Verify_Ecu
 *                for the state KeyM_DiagProc.replaceCertificatesVerifyEcuState
 * \param[in]   retVal         Received return value after processing a state.
 * \param[in]   idleState      State Idle.
 * \param[in]   nextState      Next state.
 * \param[out]  state          State variable
 * \pre         State must be a valid pointer.
 * \context     TASK
 * \reentrant   TRUE
 * \synchronous TRUE
 */
SSA_KEYM_LOCAL FUNC(void, Ssa_KeyM_CODE) KeyM_ReplaceCertificates_StateHandling(
  Std_ReturnType retVal,
  uint8 idleState,
  uint8 nextState,
  P2VAR(uint8, AUTOMATIC, AUTOMATIC) state);

/**********************************************************************************************************************
 *  KeyM_Replace_Certificate_Extract_Certificates()
 *********************************************************************************************************************/
/*!
 * \brief       Extracts from the input data buffer of the replace certificates routine the certificates to be replaced.
 * \details     -
 * \param[in]   Certificates Pointer to the certificates (up to 4).
 * \param[in]   DataLength   Length of the certificates.
 * \param[out]  cert         Pointer to the information data structure about the certificates to be replaced.
 * \param[out]  errCode      The negative response code if an error occurred.
 * \return      The number of certificates to be replaced (automatically defining which certificates are to be replaced).
 * \pre         All provided pointers must be valid.
 * \context     ANY
 * \reentrant   TRUE
 * \synchronous TRUE
 */
SSA_KEYM_LOCAL_INLINE FUNC(uint8, Ssa_KeyM_CODE) KeyM_Replace_Certificate_Extract_Certificates(
  P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) Certificates,
  uint16 DataLength,
  P2VAR(Ssa_KeyM_CertChainDataType, AUTOMATIC, AUTOMATIC) cert,
  P2VAR(Dcm_NegativeResponseCodeType, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) errCode);

/**********************************************************************************************************************
*  KeyM_Replace_Certificate_Extract_Certificates_ExtractCertLengths()
**********************************************************************************************************************/
/*!
* \brief       Extracts the lengths of the certificates from the input data buffer.
* \details     -
* \param[in]     Certificates          Pointer to the certificates (up to 4).
* \param[in]     DataLength            Length of the certificates.
* \param[out]    cert                  Pointer to the information data structure about the certificates to be replaced.
* \param[out]    linkCertLength        Length of the link certificate.
* \param[in,out] byteIdx               In:  Pointer to a byte index pointing at the position in the certificate buffer where
*                                           the certificate preceded by its length information is stored.
*                                      Out: The byte index is increased by the amount of extracted data.
* \param[out]    errCode               The negative response code if an error occurred.
* \return      E_OK      The lengths could be extracted.
*              E_NOT_OK  The lengths could not be extracted.
* \pre         All provided pointers must be valid.
* \context     ANY
* \reentrant   TRUE
* \synchronous TRUE
*/
SSA_KEYM_LOCAL_INLINE FUNC(Std_ReturnType, Ssa_KeyM_CODE) KeyM_Replace_Certificate_Extract_Certificates_ExtractCertLengths(
  P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) Certificates,
  uint16 DataLength,
  P2VAR(Ssa_KeyM_CertChainDataType, AUTOMATIC, AUTOMATIC) cert,
  P2VAR(uint16, AUTOMATIC, AUTOMATIC) certificate4Length,
  P2VAR(uint16, AUTOMATIC, AUTOMATIC) byteIdx,
  P2VAR(Dcm_NegativeResponseCodeType, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) errCode);

#if (SSA_ECU_TYPE == SSA_ECU_TYPE_VSM)
/**********************************************************************************************************************
 *  KeyM_Replace_Certificate_Verify_Ecu()
 *********************************************************************************************************************/
/*!
 * \brief       Execute all verifications around the ECU certificate related to its replacement.
 * \details     -
 * \param[in]   cert                 Pointer to the information data structure about the certificates to be replaced.
 * \param[in]   backendCertBuf       Pointer to the backend certificate raw data.
 * \param[in]   parsedBackendCertPtr Pointer to the backend certificate parsed data.
 * \param[out]  Verification_Result  Positive response code of the routine.
 * \param[out]  ErrorCode            Negative response code to be sent by DCM if return value is E_NOT_OK.
 * \return      E_OK          Request succeeded.
 *              E_NOT_OK      Request failed.
 *              SSA_E_PENDING Requested service is pending.
 * \pre         All provided pointers must be valid.
 * \context     TASK
 * \reentrant   FALSE
 * \synchronous FALSE
 * \spec        requires cert->ecu != NULL_PTR;                                                                \endspec
 */
SSA_KEYM_LOCAL FUNC(Std_ReturnType, Ssa_KeyM_CODE) KeyM_Replace_Certificate_Verify_Ecu(
  P2CONST(Ssa_KeyM_CertChainDataType, AUTOMATIC, AUTOMATIC) cert,
  P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) backendCertBuf,
  P2CONST(CertP_ParsedCertStructureType, AUTOMATIC, AUTOMATIC) parsedBackendCertPtr,
  P2VAR(uint8, AUTOMATIC, AUTOMATIC) Verification_Result,
  P2VAR(Dcm_NegativeResponseCodeType, AUTOMATIC, AUTOMATIC) ErrorCode);
#endif

/**********************************************************************************************************************
 *  KeyM_GetAndParseStoredCert_GetCertificateRawDataAndCheckParsing()
 **********************************************************************************************************************/
 /*!
 * \brief         Get certificate raw data and check if the certificate has already been parsed.
 * \details       -
 * \param[in]     pkiRole          The PKI role of the requested certificate. It identifies the requested certificate.
 * \param[in]     parsedCert       Holds the pointer to the memory location where the parser information is stored.
 * \param[in,out] certRawData      Holds a pointer to the raw certificate data to be parsed.
 * \param[in,out] rawLengthCert    Contains the number of bytes of rawCertData.
 * \param[out]    certBufferLength Length of the certificate raw data, that has to be copied for storing the parsed cert.
 * \param[in,out] rVal             Return value to be evaluated and re-set.
 * \param[out]    parseCertFlag    Flag indicating if the certificate has to be parsed (again).
 * \pre           All provided pointers must be valid.
 * \context       TASK
 * \reentrant     TRUE
 * \synchronous   TRUE
 */
SSA_KEYM_LOCAL FUNC(void, Ssa_KeyM_CODE) KeyM_GetAndParseStoredCert_GetCertificateRawDataAndCheckParsing(
  CertP_PkiRoleType pkiRole,
  P2CONST(CertP_ParsedCertStructureType, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) parsedCert,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) certRawData,
  P2VAR(uint32, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) rawLengthCert,
  P2VAR(uint16, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) certBufferLength,
  P2VAR(Std_ReturnType, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) rVal,
  P2VAR(boolean, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) parseCertFlag);

/**********************************************************************************************************************
 *  KeyM_GetAndParseStoredCert_GetCertificateRawDataByPkiRole()
 **********************************************************************************************************************/
/*!
 * \brief       Copy the raw data from the crypto key element to the given buffer depending on PKI role.
 * \details     -
 * \param[in]   pkiRole           Pki role.
 * \param[in]   certRawData       Holds the pointer to the memory location where the certificate data shall be stored.
 * \param[in]   lengthCert        Holds a pointer to the memory location in which the certificate buffer length in
 *                                bytes is stored.
 * \return      E_OK       Certificate successfully stored.
 *              E_NOT_OK   Certificate could not be stored.
 * \pre         All provided pointers must be valid.
 *              The buffer referenced by certRawData must provide at least SSA_SIZEOF_CERT_MAX many bytes.
 * \context     ANY
 * \reentrant   TRUE
 * \synchronous TRUE
 * \spec        requires $lengthOf(certRawData) >= SSA_SIZEOF_CERT_MAX;                                        \endspec
 */
SSA_KEYM_LOCAL FUNC(Std_ReturnType, Ssa_KeyM_CODE) KeyM_GetAndParseStoredCert_GetCertificateRawDataByPkiRole(
  CertP_PkiRoleType pkiRole,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) certRawData,
  P2VAR(uint32, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) lengthCert);

/**********************************************************************************************************************
 *  KeyM_ExtractCertificateLength()
 *********************************************************************************************************************/
/*!
 * \brief         Extracts certificate length.
 * \details       -
 * \param[in]     certificates      Pointer to the certificates (up to 4).
 * \param[in]     dataLength        Length of the certificates.
 * \param[in,out] byteIdx           In:  Pointer to an byte index pointing at the position in the certificate buffer where
 *                                       the certificate preceded by its length information is stored.
 *                                  Out: The byte index is increased by the amount of extracted data.
 * \param[out]    certificateLength Length of the extracted certificate.
 * \return        TRUE   Certificate successfully extracted.
 *                FALSE  Invalid format detected.
 * \pre           All provided pointers must be valid.
 * \context       ANY
 * \reentrant     TRUE
 * \synchronous   TRUE
 */
SSA_KEYM_LOCAL FUNC(boolean, Ssa_KeyM_CODE) KeyM_ExtractCertificateLength(
  P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) certificates,
  uint16 dataLength,
  P2VAR(uint16, AUTOMATIC, AUTOMATIC) byteIdx,
  P2VAR(uint16, AUTOMATIC, AUTOMATIC) certificateLength);

/**********************************************************************************************************************
 *  KeyM_SelfCheck_HandleCallbackResult()
 *********************************************************************************************************************/
/*!
 * \brief         Evaluates the verification results by AsrKeyM and does additional verification of some cert entries.
 * \details       -
 * \param[in]     callbackResult  Callback result provided by AsrKeyM, indicating the verification result for root cert
 * \return        RTE_E_OK        At least one certificate is invalid.
 *                KEYM_NO_RETVAL  All certificates could be verified.
 * \pre           -
 * \context       ANY
 * \reentrant     TRUE
 * \synchronous   TRUE
 */
SSA_KEYM_LOCAL FUNC(Std_ReturnType, Ssa_KeyM_CODE) KeyM_SelfCheck_HandleCallbackResult(uint8 callbackResult);

/**********************************************************************************************************************
 *  KeyM_GetMainLoopStateLock()
 *********************************************************************************************************************/
/*!
 * \brief       Gets main loop state lock.
 * \details     -
 * \return      TRUE  Getting lock succeeded.
 *              FALSE Getting lock failed.
 * \pre         -
 * \context     TASK
 * \reentrant   TRUE
 * \synchronous TRUE
 */
SSA_KEYM_LOCAL FUNC(boolean, Ssa_KeyM_CODE) KeyM_GetMainLoopStateLock(void);

/**********************************************************************************************************************
 *  KeyM_GenerateAndStoreSecOcKeys()
 *********************************************************************************************************************/
/*!
 * \brief       Generates and stores a defined number of SecOc keys.
 * \details     This functions generates and stores a defined number of SecOc keys. The number is given by configuration.
 *              The function might have to be called several times until all SecOc keys are generated.
 * \return      E_OK     Request succeeded.
 *              E_NOT_OK Request failed.
 * \pre         -
 * \context     TASK
 * \reentrant   FALSE
 * \synchronous TRUE
 */
SSA_KEYM_LOCAL_INLINE FUNC(Std_ReturnType, Ssa_KeyM_CODE) KeyM_GenerateAndStoreSecOcKeys(void);

/**********************************************************************************************************************
*  KeyM_GenerateAndStoreSecOcKeys_RetryCheck()
**********************************************************************************************************************/
/*!
* \brief         Check the retry counter used for the handling of "busy" return values
* \details       -
* \param[in,out]     retVal              Return value after generating and storing the SecOcKeys
* \param[in,out]     retryCounter        Retry counter for handling busy return values
* \pre           All provided pointers must be valid.
* \context       ANY
* \reentrant     TRUE
* \synchronous   TRUE
*/
SSA_KEYM_LOCAL_INLINE FUNC(void, Ssa_KeyM_CODE) KeyM_GenerateAndStoreSecOcKeys_RetryCheck(
  P2VAR(Std_ReturnType, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) retVal,
  P2VAR(uint16, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) retryCounter);

/**********************************************************************************************************************
 *  KeyM_CalculateAndStoreCipherKey()
 *********************************************************************************************************************/
/*!
 * \brief       Calculates and stores a the symmetric cipher key used for
 * \details     -
 * \param[in]   nonce     Pointer to the certificates (up to 4).
 * \return      E_OK      Request succeeded.
 *              E_NOT_OK  Request failed.
 * \pre         -
 * \context     TASK
 * \reentrant   FALSE
 * \synchronous TRUE
 */
SSA_KEYM_LOCAL_INLINE FUNC(Std_ReturnType, Ssa_KeyM_CODE) KeyM_CalculateAndStoreCipherKey(
  P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) nonce);

/**********************************************************************************************************************
 *  KeyM_GetSerialNumberFromCert()
 **********************************************************************************************************************/
/*!
 * \brief       Gets serial number from certificate.
 * \details     -
 * \param[in]   certificate         Raw data of certificate.
 * \param[in]   certSerialNumber    BER element of serial number to be extracted.
 * \param[out]  serialNumber        Buffer to store the serial number.
 * \param[in]   serialNumberLength  Length of buffer to store the serial number.
 * \return      E_OK      Serial number successfully extracted.
 *              E_NOT_OK  Serial number could not get since to long for provided buffer.
 * \pre         Certificate is parsed and verified.
 *              All provided pointers must be valid.
 * \context     TASK
 * \reentrant   TRUE
 * \synchronous TRUE
 */
SSA_KEYM_LOCAL FUNC(Std_ReturnType, Ssa_KeyM_CODE) KeyM_GetSerialNumberFromCert(
  P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) certificate,
  P2CONST(CertP_BerElementType, AUTOMATIC, AUTOMATIC) certSerialNumber,
  P2VAR(uint8, AUTOMATIC, AUTOMATIC) serialNumber,
  uint16 serialNumberLength);

/**********************************************************************************************************************
 *  KeyM_CsmRandomGenerate()
 *********************************************************************************************************************/
/*!
 * \brief       Generates random data of the requested length.
 * \details     -
 * \param[in]   resultBufferLength   Number of bytes of random data to be generated.
 * \param[out]  resultBuffer         Pointer to the generated random data.
 * \return      E_OK           Request successful.
 *              E_NOT_OK       Request failed.
 *              SSA_E_PENDING  Request is pending.
 * \pre         All provided pointers must be valid.
 * \context     TASK
 * \reentrant   FALSE
 * \synchronous FALSE
 */
SSA_KEYM_LOCAL FUNC(Std_ReturnType, Ssa_KeyM_CODE) KeyM_CsmRandomGenerate(
  uint32 resultBufferLength,
  P2VAR(uint8, AUTOMATIC, AUTOMATIC) resultBuffer);

#if (SSA_ECU_TYPE == SSA_ECU_TYPE_VSM)

/**********************************************************************************************************************
 *  KeyM_CarSpecificSecretDistribution_Encrypt()
 *********************************************************************************************************************/
/*!
 * \brief         Encrypts the nonce and shared secret.
 * \details       This function derives the encryption key, encrypts the passed data and prepares the data that are to be signed.
 * \param[in,out] dataBuffer                         Buffer containing the data to be encrypted. The encrypted data is copied to this buffer.
 * \param[out]    Encrypted_Nonce_and_Shared_Secret  Pointer to the memory location to store the encrypted nonce and secret.
 * \return        E_OK     Request succeeded.
 *                E_NOT_OK Request failed.
 * \pre           All provided pointers must be valid.
 *                The buffer referenced by dataBuffer must provide at least
 *                SSA_KEYM_DIS_POSITION_ENCRYPTED_NONCE_AND_SECRET + SSA_SIZEOF_ENCRYPTED_NONCE_AND_SECRET many bytes.
 *                The buffer referenced by Encrypted_Nonce_and_Shared_Secret must provide at least 
 *                SSA_SIZEOF_ENCRYPTED_NONCE_AND_SECRET many bytes.
 * \context       TASK
 * \reentrant     FALSE
 * \synchronous   TRUE
 */
SSA_KEYM_LOCAL_INLINE FUNC(Std_ReturnType, Ssa_KeyM_CODE) KeyM_CarSpecificSecretDistribution_Encrypt(
  P2VAR(uint8, AUTOMATIC, AUTOMATIC) dataBuffer,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) Encrypted_Nonce_and_Shared_Secret);

/**********************************************************************************************************************
 *  KeyM_CarSpecificSecretDistribution_AppendVsmCert()
 *********************************************************************************************************************/
/*!
 * \brief         Appends the VSM certificate raw data.
 * \details       -
 * \param[in]     chainOfTrust           The chain of trust to be used.
 * \param[out]    VSM_s_ECU_Certificate  Pointer to the memory location where the VSM certificate raw data shall be copied to.
 * \param[in,out] DataLength             Data length. Defining the position where the VSM certificate data are copied to.
 *                                       Increased by the number of appended bytes.
 * \param[out]    ErrorCode              Negative response code to be sent by DCM if return value is E_NOT_OK.
 * \return        TRUE   Appending failed or an error occurred.
 *                FALSE  Appending succeeded.
 * \pre           All provided pointers must be valid.
 *                VSM_s_ECU_Certificate must be a buffer of at least the size (SSA_SIZEOF_CERT_MAX + 2u), if
 *                ((chainOfTrust != SSA_TRUST_MODEL_LIVE_KEY_PAIR) && (chainOfTrust != SSA_TRUST_MODEL_CSR_KEY_PAIR)).
 *                VSM_s_ECU_Certificate must be a buffer of at least the size sizeof(Dcm_Data3006ByteType), if
 *                ((chainOfTrust == SSA_TRUST_MODEL_LIVE_KEY_PAIR) || (chainOfTrust == SSA_TRUST_MODEL_CSR_KEY_PAIR)).
 * \context       TASK
 * \reentrant     FALSE
 * \synchronous   TRUE
 */
SSA_KEYM_LOCAL_INLINE FUNC(boolean, Ssa_KeyM_CODE) KeyM_CarSpecificSecretDistribution_AppendVsmCert(
  uint8 chainOfTrust,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) VSM_s_ECU_Certificate,
  P2VAR(uint16, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) DataLength,
  P2VAR(Dcm_NegativeResponseCodeType, AUTOMATIC, AUTOMATIC) ErrorCode);

/**********************************************************************************************************************
 *  KeyM_EncryptSharedSecret()
 *********************************************************************************************************************/
/*!
 * \brief         Encrypts the car-specific secret.
 * \details       -
 * \param[in]     chainOfTrust                      The chain of trust to be used.
 * \param[in]     Nonce                             Pointer to the nonce.
 * \param[in]     Ephemeral_ECU_Public_Key          Pointer to the ephemeral ECU public key.
 * \param[in]     Data_Signature_In                 Pointer to the data signature.
 * \param[in]     Target_ECU_Certificate            Pointer to target ECU certificate, the ECU obtaining the encrypted secret.
 * \param[in]     OpStatus                          Current operation status.
 * \param[out]    routineInfo                       Execution status of the routine for positive responses.
 * \param[out]    Verification_Result               Positive Response Code of the routine.
 * \param[out]    Date_and_Time                     Pointer to the memory location to store date and time.
 * \param[out]    Tick_Count                        Pointer to the memory location to store the tick count.
 * \param[out]    Tick_Count_Offset                 Pointer to the memory location to store the tick count offset.
 * \param[out]    Encrypted_Nonce_and_Shared_Secret Pointer to the memory location to store the encrypted nonce and secret.
 * \param[out]    Ephemeral_VSM_Public_Key          Pointer to the memory location to store the ephemeral VSM public key.
 * \param[out]    Data_Signature_Out                Pointer to the memory location to store the generated signature.
 * \param[out]    VSM_s_ECU_Certificate             Pointer to the memory location to store the VSM certificate.
 * \param[in,out] DataLength                        In: Length in bytes of Target_ECU_Certificate, Out: Length in bytes of VSM_s_ECU_Certificate.
 * \param[out]    ErrorCode                         Negative response code to be sent by DCM if return value is E_NOT_OK.
 * \param[in]     allowStandardSecret               Set to TRUE to allow the standard secret as car-specific secret.
 * \return        RTE_E_OK        Request successful.
 *                SSA_E_PENDING   Requested service is pending.
 *                E_NOT_OK        Request failed.
 * \pre           All provided pointers must be valid.
 *                The buffer referenced by Date_and_Time must provide at least sizeof(Dcm_Data7ByteType) many bytes.
 *                The buffer referenced by Tick_Count must provide at least sizeof(Dcm_Data5ByteType) many bytes.
 *                The buffer referenced by Tick_Count_Offset must provide at least sizeof(Dcm_Data5ByteType) many bytes.
 *                The buffer referenced by Encrypted_Nonce_and_Shared_Secret must provide at least sizeof(Dcm_Data80ByteType) many bytes.
 *                The buffer referenced by Ephemeral_VSM_Public_Key must provide at least sizeof(Dcm_Data32ByteType) many bytes.
 *                The buffer referenced by Data_Signature_Out must provide at least sizeof(Dcm_Data64ByteType) many bytes.
 *                The buffer referenced by VSM_s_ECU_Certificate must provide at least sizeof(Dcm_Data1002ByteType) many bytes, if
 *                chainOfTrust == SSA_DIAGNOSTIC_KEY_PAIR.
 *                The buffer referenced by VSM_s_ECU_Certificate must provide at least sizeof(Dcm_Data3006ByteType) many bytes, if
 *                chainOfTrust == SSA_TRUST_MODEL_LIVE_KEY_PAIR.
 * \context       TASK
 * \reentrant     FALSE
 * \synchronous   FALSE
 * \spec          requires $lengthOf(VSM_s_ECU_Certificate) >= sizeof(Dcm_Data1002ByteType);                   \endspec
 */
SSA_KEYM_LOCAL FUNC(Std_ReturnType, Ssa_KeyM_CODE) KeyM_EncryptSharedSecret(
  uint8 chainOfTrust,
  P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) Nonce,
  P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) Ephemeral_ECU_Public_Key,
  P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) Data_Signature_In,
  P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) Target_ECU_Certificate,
  Dcm_OpStatusType OpStatus, P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) routineInfo,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) Verification_Result,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) Date_and_Time,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) Tick_Count,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) Tick_Count_Offset,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) Encrypted_Nonce_and_Shared_Secret,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) Ephemeral_VSM_Public_Key,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) Data_Signature_Out,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) VSM_s_ECU_Certificate,
  P2VAR(uint16, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) DataLength,
  P2VAR(Dcm_NegativeResponseCodeType, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) ErrorCode,
  boolean allowStandardSecret);

#else

/**********************************************************************************************************************
 *  KeyM_CarSpecificSecretDistribution_Decrypt()
 *********************************************************************************************************************/
/*!
 * \brief         Decrypts the encrypted nonce and shared secret.
 * \details       This function derives the decryption key and decrypts the encrypted nonce and shared secret. It verifies the decrypted nonce,
 *                and uses the shared secret for seeding the RNG and deriving the SecOc symmetric keys.
 * \param[in]     Encrypted_Nonce_and_Shared_Secret Pointer to the encrypted nonce and secret.
 * \param[in,out] dataBuffer                        Temporary data buffer containing the nonce. Used for decrypting the encrypted data.
 * \param[out]    Verification_Result               Positive Response Code of the routine.
 * \param[out]    ErrorCode                         Negative response code to be sent by DCM if return value is E_NOT_OK.
 * \return        TRUE   Decryption failed or an error occurred.
 *                FALSE  Decryption succeeded.
 * \pre           All provided pointers must be valid.
 *                The buffer referenced by dataBuffer must provide at least
 *                SSA_KEYM_DIS_POSITION_ENCRYPTED_NONCE_AND_SECRET + SSA_SIZEOF_ENCRYPTED_NONCE_AND_SECRET
 *                many bytes.
 * \context       TASK
 * \reentrant     FALSE
 * \synchronous   TRUE
 */
SSA_KEYM_LOCAL_INLINE FUNC(boolean, Ssa_KeyM_CODE) KeyM_CarSpecificSecretDistribution_Decrypt(
  P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) Encrypted_Nonce_and_Shared_Secret,
  P2VAR(uint8, AUTOMATIC, AUTOMATIC) dataBuffer,
  P2VAR(uint8, AUTOMATIC, AUTOMATIC) Verification_Result,
  P2VAR(Dcm_NegativeResponseCodeType, AUTOMATIC, AUTOMATIC) ErrorCode);

#endif

/**********************************************************************************************************************
 *  KeyM_CsmSignatureGenerate()
 *********************************************************************************************************************/
/*!
 * \brief       Asynchronously calls the CSM signature generate API function.
 * \details     -
 * \param[in]   chainOfTrust   The chain of trust used for signature generation
 * \param[in]   dataIn         Input data.
 * \param[in]   dataInLength   Length of input data.
 * \param[out]  signatureOut   Generated signature.
 * \return      E_OK           Request successful.
 *              E_NOT_OK       Request failed.
 *              SSA_E_PENDING  Request is pending.
 * \pre         All provided pointers must be valid.
 *              The buffer referenced by signatureOut must provide at least SSA_SIZEOF_SIGNATURE many bytes.
 * \context     TASK
 * \reentrant   FALSE
 * \synchronous FALSE
 * \spec        requires $lengthOf(signatureOut) >= SSA_SIZEOF_SIGNATURE;                                      \endspec
 */
SSA_KEYM_LOCAL FUNC(Std_ReturnType, Ssa_KeyM_CODE) KeyM_CsmSignatureGenerate(
  uint8 chainOfTrust,
  P2CONST(uint8, AUTOMATIC, RTE_SSA_RIGHTSM_APPL_DATA) dataIn,
  uint16 dataInLength,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_RIGHTSM_APPL_VAR) signatureOut);

/**********************************************************************************************************************
 *  KeyM_CsmSignatureVerify()
 *********************************************************************************************************************/
/*!
 * \brief       Asynchronously calls the CSM signature verify API function.
 * \details     -
 * \param[in]   chainOfTrust    The chain of trust to be used.
 * \param[in]   dataIn          Input data.
 * \param[in]   dataInLength    Length of input data.
 * \param[in]   signatureIn     Signature to be verified.
 * \param[out]  csmVerifyResult Csm verification result.
 * \return      E_OK          Request successful.
 *              E_NOT_OK      Request failed.
 *              SSA_E_PENDING Request is pending.
 * \pre         All provided pointers must be valid.
 * \context     TASK
 * \reentrant   FALSE
 * \synchronous FALSE
 */
SSA_KEYM_LOCAL FUNC(Std_ReturnType, Ssa_KeyM_CODE) KeyM_CsmSignatureVerify(
  uint8 chainOfTrust,
  P2CONST(uint8, AUTOMATIC, RTE_SSA_RIGHTSM_APPL_DATA) dataIn,
  uint32 dataInLength,
  P2CONST(uint8, AUTOMATIC, RTE_SSA_RIGHTSM_APPL_DATA) signatureIn,
  P2VAR(Crypto_VerifyResultType, AUTOMATIC, AUTOMATIC) csmVerifyResult);

#if ((SSA_DIAG_SERVICE_TRUST_MODEL_GENERATE_KEY_PAIR == STD_ON) && (SSA_GENERATE_KEY_PAIR_CUSTOM_CALLOUT == STD_OFF))

/**********************************************************************************************************************
 *  KeyM_CsmKeyGenerate_TrustModelEcuCsrKey()
 *********************************************************************************************************************/
/*!
 * \brief       Asynchronously calls the CSM key generate API function.
 * \details     -
 * \return      E_OK           Request successful.
 *              E_NOT_OK       Request failed.
 *              SSA_E_PENDING  Request is pending.
 * \pre         -
 * \context     TASK
 * \reentrant   FALSE
 * \synchronous FALSE
 */
SSA_KEYM_LOCAL FUNC(Std_ReturnType, Ssa_KeyM_CODE) KeyM_CsmKeyGenerate_TrustModelEcuCsrKey(void);

#endif

/**********************************************************************************************************************
 *  KeyM_CsmKeyExchangeCalcPubVal()
 *********************************************************************************************************************/
/*!
 * \brief       Asynchronously calls the CSM key exchange calculate public value API function.
 * \details     -
 * \param[out]  keyExchangePubVal Calculated public value for key exchange.
 * \return      E_OK           Request successful.
 *              E_NOT_OK       Request failed.
 *              SSA_E_PENDING  Request is pending.
 * \pre         keyExchangePubVal must be a valid pointer referencing a buffer of at least SSA_SIZEOF_PUBLICKEY
 *              many bytes.
 * \context     TASK
 * \reentrant   FALSE
 * \synchronous FALSE
 */
SSA_KEYM_LOCAL FUNC(Std_ReturnType, Ssa_KeyM_CODE) KeyM_CsmKeyExchangeCalcPubVal(
  P2VAR(uint8, AUTOMATIC, RTE_SSA_RIGHTSM_APPL_VAR) keyExchangePubVal);

/**********************************************************************************************************************
 *  KeyM_CsmKeyExchangeCalcSecret()
 *********************************************************************************************************************/
/*!
 * \brief       Asynchronously calls the CSM key exchange calculate secret API function.
 * \details     -
 * \param[in]   partnerPubVal  Public value of the partner.
 * \return      E_OK           Request successful.
 *              E_NOT_OK       Request failed.
 *              SSA_E_PENDING  Request is pending.
 * \pre         -
 * \context     TASK
 * \reentrant   FALSE
 * \synchronous FALSE
 */
SSA_KEYM_LOCAL FUNC(Std_ReturnType, Ssa_KeyM_CODE) KeyM_CsmKeyExchangeCalcSecret(
  P2CONST(uint8, AUTOMATIC, RTE_SSA_RIGHTSM_APPL_VAR) partnerPubVal);

/**********************************************************************************************************************
 *  KeyM_SelfCheck_DiagnosticChain()
 *********************************************************************************************************************/
/*!
 * \brief       Performs the Certificate SelfCheck for the diagnostic chain.
 * \details     -
 * \return      RTE_E_OK                                                             SelfCheck of diagnostic chain has finished.
 *              RTE_E_RoutineServices_Routine_Certificate_Self_Check_E_NOT_OK        SelfCheck of diagnostic chain has failed.
 *              RTE_E_RoutineServices_Routine_Certificate_Self_Check_DCM_E_PENDING   SelfCheck of diagnostic chain is pending.
 * \pre         -
 * \context     TASK
 * \reentrant   FALSE
 * \synchronous FALSE
 */
SSA_KEYM_LOCAL_INLINE FUNC(Std_ReturnType, Ssa_KeyM_CODE) KeyM_SelfCheck_DiagnosticChain(void);

/**********************************************************************************************************************
 *  KeyM_SelfCheck_DiagnosticChain_Handle_CheckResults()
 *********************************************************************************************************************/
/*!
 * \brief       Evaluates the result of a verification step within the diagnostic chain.
 * \details     -
 * \param[in]   rVal                 Return value of the verification to be evaluated.
 * \param[in]   verificationResult   Value to be set as verification result in case of verification failure.
 * \param[in]   nextCheckState       State in which to proceed with verification if the verification to be evaluated is finished.
 * \return      RTE_E_OK                                                               Verification failed, quit Routine.
 *              KEYM_NO_RETVAL                                                         Verification was successful.
 *              RTE_E_RoutineServices_Routine_Certificate_Self_Check_DCM_E_PENDING     Verification is still pending.
 * \pre         -
 * \context     TASK
 * \reentrant   FALSE
 * \synchronous FALSE
 */
SSA_KEYM_LOCAL FUNC(Std_ReturnType, Ssa_KeyM_CODE) KeyM_SelfCheck_DiagnosticChain_Handle_CheckResults(
  Std_ReturnType rVal,
  uint8 verificationResult,
  uint8 nextCheckState);

/**********************************************************************************************************************
 *  KeyM_SelfCheck_DiagnosticChain_ParseCertificates()
 *********************************************************************************************************************/
/*!
 * \brief       Parses all certificates for the diagnostic chain.
 * \details     If a certificate is not available, an error is written to the verification result.
 * \param[in,out]  rootCertBuf      Pointer to the memory where the root certificate raw data shall be copied to.
 * \param[in,out]  backendCertBuf   Pointer to the memory where the backend certificate raw data shall be copied to.
 * \param[in,out]  ecuCertBuf       Pointer to the memory where the ECU certificate raw data shall be copied to.
 * \pre         All provided pointers must be valid.
 *              The buffer referenced by rootCertBuf must provide at least SSA_SIZEOF_CERT_MAX many bytes.
 *              The buffer referenced by backendCertBuf must provide at least SSA_SIZEOF_CERT_MAX many bytes.
 *              The buffer referenced by ecuCertBuf must provide at least SSA_SIZEOF_CERT_MAX many bytes.
 * \context     TASK
 * \reentrant   FALSE
 * \synchronous FALSE
 */
SSA_KEYM_LOCAL_INLINE FUNC(void, Ssa_KeyM_CODE) KeyM_SelfCheck_DiagnosticChain_ParseCertificates(
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) rootCertBuf,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) backendCertBuf,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) ecuCertBuf);

/**********************************************************************************************************************
 *  KeyM_SelfCheck_DiagnosticChain_CheckCertificateAgainstIssuer()
 *********************************************************************************************************************/
/*!
 * \brief         Verifies the validity of a certificate, also against the parent certificate.
 * \details       -
 * \param[in]     rawCertData        Pointer to the memory with the raw data of the certificate to be checked.
 * \param[in,out] parsedCert         Pointer to the memory with the parsed certificate to be checked.
 * \param[in]     rawCertIssuer      Pointer to the memory with the raw data of the issue certificate.
 * \param[in]     parsedCertIssuer   Pointer to the memory with the parsed issuer certificate.
 * \param[in]     expectedPkiRole    Expected PKI role of the certificate to be checked.
 * \return        RTE_E_OK                                                             Verification was successful.
 *                E_NOT_OK                                                             Verification failed.
 *                RTE_E_RoutineServices_Routine_Certificate_Self_Check_DCM_E_PENDING   Verification is still pending.
 * \pre           All provided pointers must be valid.
 * \context       TASK
 * \reentrant     FALSE
 * \synchronous   FALSE
 */
SSA_KEYM_LOCAL FUNC(Std_ReturnType, Ssa_KeyM_CODE) KeyM_SelfCheck_DiagnosticChain_CheckCertificateAgainstIssuer(
  P2CONST(uint8, AUTOMATIC, RTE_SSA_CERTP_APPL_DATA) rawCertData,
  P2VAR(CertP_ParsedCertStructureType, AUTOMATIC, RTE_SSA_CERTP_APPL_VAR) parsedCert,
  P2CONST(uint8, AUTOMATIC, RTE_SSA_CERTP_APPL_DATA) rawCertIssuer,
  P2CONST(CertP_ParsedCertStructureType, AUTOMATIC, RTE_SSA_CERTP_APPL_DATA) parsedCertIssuer,
  CertP_PkiRoleType expectedPkiRole);

#if (SSA_ECU_TYPE == SSA_ECU_TYPE_VSM)
/**********************************************************************************************************************
 *  KeyM_SelfCheck_DiagnosticChain_CheckPrivateKeyAccessibility()
 *********************************************************************************************************************/
/*!
 * \brief       Checks the private key of the ECU certificate
 * \details     -
 * \param[in]   ecuCertBuf       Pointer to the memory with the ECU certificate raw data.
 * \return      RTE_E_OK                                                            Private key is accessible.
 *              E_NOT_OK                                                            Private key is not accessible.
 *              RTE_E_RoutineServices_Routine_Certificate_Self_Check_DCM_E_PENDING  Check is private key is pending.
 * \pre         -
 * \context     TASK
 * \reentrant   FALSE
 * \synchronous FALSE
 */
SSA_KEYM_LOCAL_INLINE FUNC(Std_ReturnType, Ssa_KeyM_CODE) KeyM_SelfCheck_DiagnosticChain_CheckPrivateKeyAccessibility(
  P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) ecuCertBuf);
#endif

/**********************************************************************************************************************
 *  KeyM_SelfCheck_UniqueEcuIdChain()
 *********************************************************************************************************************/
/*!
 * \brief       Performs the Certificate SelfCheck for the Unique ECU ID Chain.
 * \details     -
 * \return      RTE_E_OK                                                             SelfCheck of Unique ECU ID chain has finished.
 *              RTE_E_RoutineServices_Routine_Certificate_Self_Check_E_NOT_OK        SelfCheck of Unique ECU ID chain has failed.
 *              RTE_E_RoutineServices_Routine_Certificate_Self_Check_DCM_E_PENDING   SelfCheck of Unique ECU ID chain is pending.
 * \pre         -
 * \context     TASK
 * \reentrant   FALSE
 * \synchronous FALSE
 */
SSA_KEYM_LOCAL_INLINE FUNC(Std_ReturnType, Ssa_KeyM_CODE) KeyM_SelfCheck_UniqueEcuIdChain(void);

/**********************************************************************************************************************
 *  KeyM_SelfCheck_EcuIdChain_CheckCertificateAvailability()
 **********************************************************************************************************************/
/*!
 * \brief       Checks for all certificates of the ECU ID chain if they are available.
 * \details     If a certificate is not available, the according verification result is internally stored.
 * \return      E_OK      Root certificate is available and could be parsed.
 *              E_NOT_OK  Root certificate is either not available or could not be parsed.
 * \pre         -
 * \context     TASK
 * \reentrant   FALSE
 * \synchronous TRUE
 */
SSA_KEYM_LOCAL_INLINE FUNC(Std_ReturnType, Ssa_KeyM_CODE) KeyM_SelfCheck_EcuIdChain_CheckCertificateAvailability(void);

/**********************************************************************************************************************
*  KeyM_SelfCheck_EcuIdChain_AdditionalVerificationOfCertEntries()
**********************************************************************************************************************/
/*!
* \brief       Additional verification of certificate entries not checked by the AsrKeyM.
* \details     -
* \return      KEYM_NO_RET_VAL                                                 All certificates could be verified.
*              RTE_E_OK                                                        A certificate element could not be verified.
*              RTE_E_RoutineServices_Routine_Certificate_Self_Check_E_NOT_OK   Internal error of the verification.
* \pre         -
* \context     TASK
* \reentrant   FALSE
* \synchronous TRUE
*/
SSA_KEYM_LOCAL_INLINE FUNC(Std_ReturnType, Ssa_KeyM_CODE) KeyM_SelfCheck_EcuIdChain_AdditionalVerificationOfCertEntries(void);

/**********************************************************************************************************************
 *  KeyM_SelfCheck_EcuIdChain_GetCertParseStatus()
 **********************************************************************************************************************/
/*!
 * \brief       Checks for all certificates of the ECU ID chain  can be parsed.
 * \details     If a certificate cannot be parsed, the according verification result is internally stored.
 * \return      E_OK      Request passed.
 *              E_NOT_OK  Get Status request for Asr KeyM failed.
 *              RTE_E_RoutineServices_Routine_Certificate_Self_Check_DCM_E_PENDING Request Pending.
 * \pre         -
 * \context     TASK
 * \reentrant   FALSE
 * \synchronous TRUE
 */
SSA_KEYM_LOCAL_INLINE FUNC(Std_ReturnType, Ssa_KeyM_CODE) KeyM_SelfCheck_EcuIdChain_GetCertParseStatus(void);

/**********************************************************************************************************************
 *  KeyM_SelfCheck_EcuIdChain_ParseCertificate()
 **********************************************************************************************************************/
/*!
 * \brief       Checks for the given certificate, if it is available.
 * \details     If a certificate is not available, the according verification result is internally stored.
 * \param[in]   certId               Certificate identifier.
 * \param[in]   verificationResult   Verification result which shall be set in a verification failure.
 * \return      E_OK      Certificate is available and could be parsed.
 *              E_NOT_OK  Certificate is either not available or could not be parsed.
 * \pre         -
 * \context     TASK
 * \reentrant   FALSE
 * \synchronous TRUE
 */
SSA_KEYM_LOCAL FUNC(Std_ReturnType, Ssa_KeyM_CODE) KeyM_SelfCheck_EcuIdChain_ParseCertificate(KeyM_CertificateIdType certId, uint8 verificationResult);

/**********************************************************************************************************************
 *  KeyM_SelfCheck_EcuIdChain_GetCertificateStatus()
 **********************************************************************************************************************/
/*!
 * \brief       Checks for the given certificate, if it can be parsed.
 * \details     If a certificate cannot be parsed, the according verification result is internally stored.
 * \param[in]   certId    Certificate identifier.
 * \param[out]  status    Status of the certificate.
 * \return      E_OK      Request passed.
 *              E_NOT_OK  Get Status request for Asr KeyM failed.
 *              RTE_E_RoutineServices_Routine_Certificate_Self_Check_DCM_E_PENDING Request Pending.
 * \pre         All provided pointers must be valid.
 * \context     TASK
 * \reentrant   TRUE
 * \synchronous TRUE
 */
SSA_KEYM_LOCAL FUNC(Std_ReturnType, Ssa_KeyM_CODE) KeyM_SelfCheck_EcuIdChain_GetCertificateStatus(
  KeyM_CertificateIdType certId,
  P2VAR(KeyM_CertificateStatusType, AUTOMATIC, AUTOMATIC) status);

/**********************************************************************************************************************
 *  KeyM_SelfCheck_EcuIdChain_HandleCertificateStatus()
 **********************************************************************************************************************/
/*!
 * \brief       Checks for the given certificate, if it can be parsed.
 * \details     If a certificate cannot be parsed, the according verification result is internally stored.
 * \param[in]   verificationResult   Value to be set as verification result in case of verification failure.
 * \param[in]   error                Error of the GetStatus operation.
 * \param[in]   status               Status of the certificate.
 * \return      E_OK      Request passed.
 *              E_NOT_OK  Get Status request for Asr KeyM failed.
 *              RTE_E_RoutineServices_Routine_Certificate_Self_Check_DCM_E_PENDING Request Pending.
 * \pre         -
 * \context     TASK
 * \reentrant   FALSE
 * \synchronous TRUE
 */
SSA_KEYM_LOCAL FUNC(void, Ssa_KeyM_CODE) KeyM_SelfCheck_EcuIdChain_HandleCertificateStatus(
  uint8 verificationResult,
  Std_ReturnType error,
  KeyM_CertificateStatusType status);

/**********************************************************************************************************************
 *  KeyM_IsMultiRetVal()
 **********************************************************************************************************************/
/*!
 * \brief       Search for the expected value in the given buffer.
 * \details     -
 * \param[in]   rVal       Pointer to the memory with the return value buffer.
 * \param[in]   size       Size of the return value buffer.
 * \param[in]   expected   Expected value.
 * \return      TRUE     expected found.
 *              FALSE    expected not found.
 * \pre         -
 * \context     TASK
 * \reentrant   TRUE
 * \synchronous TRUE
 */
SSA_KEYM_LOCAL_INLINE FUNC(boolean, Ssa_KeyM_CODE) KeyM_IsMultiRetVal(P2CONST(uint8, AUTOMATIC, AUTOMATIC) rVal, uint8 size, Std_ReturnType expected);

/**********************************************************************************************************************
 *  KeyM_SelfCheck_EcuIdChain_UpdateRootCertificate()
 **********************************************************************************************************************/
/*!
 * \brief       Requests an update on the root certificate.
 * \details     -
 * \return      E_OK                                                                Update request was successful.
 *              E_NOT_OK                                                            Update request failed.
 *              RTE_E_RoutineServices_Routine_Certificate_Self_Check_DCM_E_PENDING  Update is pending.
 * \pre         -
 * \context     TASK
 * \reentrant   FALSE
 * \synchronous FALSE
 */
SSA_KEYM_LOCAL_INLINE FUNC(Std_ReturnType, Ssa_KeyM_CODE) KeyM_SelfCheck_EcuIdChain_UpdateRootCertificate(void);

/**********************************************************************************************************************
 *  KeyM_SelfCheck_EcuIdChain_CheckCertificateEvaluationResult()
 **********************************************************************************************************************/
/*!
 * \brief       Checks if the certificates below the root certificate could be verified by their issuer.
 * \details     -
 * \return      KEYM_NO_RETVAL  All certificated could be verified by their issuer.
 *              RTE_E_OK        At least one certificate could not be verified by its issuer.
 * \pre         -
 * \context     TASK
 * \reentrant   FALSE
 * \synchronous FALSE
 */
SSA_KEYM_LOCAL_INLINE FUNC(Std_ReturnType, Ssa_KeyM_CODE) KeyM_SelfCheck_EcuIdChain_CheckCertificateEvaluationResult(void);

/**********************************************************************************************************************
 *  KeyM_SelfCheck_TrustModel_MapInvalidCertIdToVerificationResult()
 *********************************************************************************************************************/
/*!
 * \brief       Map invalid certificate Id to verification result.
 * \details     Mapping is valid for the self check of the trust model chain.
 * \param[in]   invalidCertificate_Id     KeyM certificate id of the invalid certificate.
 * \pre         -
 * \context     TASK
 * \reentrant   FALSE
 * \synchronous TRUE
 */
SSA_KEYM_LOCAL FUNC(void, Ssa_KeyM_CODE) KeyM_SelfCheck_TrustModel_MapInvalidCertIdToVerificationResult(
  CONST(KeyM_CertificateIdType, AUTOMATIC) invalidCertificate_Id);

/**********************************************************************************************************************
 *  KeyM_SelfCheck_SetVerificationResult()
 *********************************************************************************************************************/
/*!
 * \brief       Writes the verificationResult to the internal verificationResultBuffer, if writing is not out of bounds.
 * \details     -
 * \param[in]   verificationResult   Value to be set as verification result in case of verification failure.
 * \pre         -
 * \context     TASK
 * \reentrant   FALSE
 * \synchronous FALSE
 */
SSA_KEYM_LOCAL FUNC(void, Ssa_KeyM_CODE) KeyM_SelfCheck_SetVerificationResult(uint8 verificationResult);

/**********************************************************************************************************************
 *  KeyM_SelfCheck_UpdateLastVerificationResult()
 *********************************************************************************************************************/
/*!
 * \brief       Writes the verificationResult to the internal verificationResultBuffer, if writing is not out of bounds.
 * \details     The verificationResult is only written if it is different to the last written result.
 * \param[in]   verificationResult   Value to be set as verification result in case of verification failure.
 * \pre         -
 * \context     TASK
 * \reentrant   FALSE
 * \synchronous FALSE
 */
SSA_KEYM_LOCAL FUNC(void, Ssa_KeyM_CODE) KeyM_SelfCheck_UpdateLastVerificationResult(uint8 verificationResult);

/**********************************************************************************************************************
 * Trust Model Functions
 *********************************************************************************************************************/

/**********************************************************************************************************************
 *  KeyM_KeyM_CheckCertificateStatus()
 *********************************************************************************************************************/
/*!
 * \brief       Check status of certificate handled by AsrKeyM.
 * \details     -
 * \param[in]   CertId    Certificate identifier.
 * \param[out]  ErrorCode Negative response code to be sent by DCM if the certificate could not be read.
 * \return      The certificate status obtained from AsrKeyM.
 * \pre         All provided pointers must be valid.
 * \context     TASK
 * \reentrant   TRUE for different CertIds
 * \synchronous TRUE
 */
SSA_KEYM_LOCAL FUNC(KeyM_CertificateStatusType, Ssa_KeyM_CODE) KeyM_KeyM_CheckCertificateStatus(
  KeyM_CertificateIdType CertId,
  P2VAR(Dcm_NegativeResponseCodeType, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) ErrorCode);

/**********************************************************************************************************************
 *  KeyM_KeyM_CertificateIsReadable()
 *********************************************************************************************************************/
/*!
 * \brief       Indicate whether a specific certificate is readable.
 * \details     -
 * \param[in]   CertId    Certificate identifier.
 * \param[out]  ErrorCode Negative response code to be sent by DCM if the certificate could not be read.
 * \return      TRUE  exactly if the given certificate is readable from the AsrKeyM.
 *              FALSE else.
 * \pre         All provided pointers must be valid.
 * \context     TASK
 * \reentrant   TRUE for different CertIds
 * \synchronous TRUE
 */
SSA_KEYM_LOCAL_INLINE FUNC(boolean, Ssa_KeyM_CODE) KeyM_KeyM_CertificateIsReadable(
  KeyM_CertificateIdType CertId,
  P2VAR(Dcm_NegativeResponseCodeType, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) ErrorCode);

/**********************************************************************************************************************
 *  KeyM_DestroyTrustModelEcuCert()
 *********************************************************************************************************************/
/*!
 * \brief       Destroy the current trust model in RAM by erasing the ECU certificate.
 * \details     -
 * \pre         -
 * \context     TASK
 * \reentrant   FALSE
 * \synchronous TRUE
 */
SSA_KEYM_LOCAL_INLINE FUNC(void, Ssa_KeyM_CODE) KeyM_DestroyTrustModelEcuCert(void);

/**********************************************************************************************************************
 *  KeyM_KeyM_GetCertificateDataAsIteration()
 *********************************************************************************************************************/
/*!
 * \brief         Get data of certificate handled by AsrKeyM.
 * \details       -
 * \param[in]     CertId      Certificate identifier.
 * \param[out]    Data        Data of certificate of format [ 2 Bytes DataLength | DataLength x 1 Byte Data ].
 * \param[in,out] DataLength  In:  Size of Data
 *                            Out: Size of certificate data written into Data.
 * \return        E_OK        Getting data succeeded.
 *                E_NOT_OK    Getting data failed.
 * \pre           All provided pointers must be valid.
 * \context       TASK
 * \reentrant     TRUE for different CertIds
 * \synchronous   TRUE
 */
SSA_KEYM_LOCAL FUNC(Std_ReturnType, Ssa_KeyM_CODE) KeyM_KeyM_GetCertificateDataAsIteration(
  KeyM_CertificateIdType CertId,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) Data,
  P2VAR(uint16, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) DataLength);

/**********************************************************************************************************************
 *  KeyM_GetNextIteration()
 *********************************************************************************************************************/
/*!
 * \brief         Read next iteration from a data buffer.
 * \details       -
 * \param[in]     dataBuffer       Buffer containing data structured as iterations of format
 *                                 [ 2 Bytes DataLength | DataLength x 1 Byte Data | ... ].
 * \param[in]     dataBufferLength Length of data buffer.
 * \param[in,out] dataIdx          Index of current iteration, initially 0.
 * \param[out]    iterIdx          Start index of read iteration.
 * \param[out]    iterLength       Length of read iteration.
 * \return        E_OK      Next iteration successfully read.
 *                E_NOT_OK  Length mismatch.
 * \pre           All provided pointers must be valid.
 * \context       ANY
 * \reentrant     TRUE
 * \synchronous   TRUE
 */
SSA_KEYM_LOCAL FUNC(Std_ReturnType, Ssa_KeyM_CODE) KeyM_GetNextIteration(
  P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) dataBuffer,
  uint16 dataBufferLength,
  P2VAR(uint32, AUTOMATIC, AUTOMATIC) dataIdx,
  P2VAR(uint16, AUTOMATIC, AUTOMATIC) iterIdx,
  P2VAR(uint16, AUTOMATIC, AUTOMATIC) iterLength);

/**********************************************************************************************************************
 *  KeyM_AddNextIteration()
 *********************************************************************************************************************/
/*!
 * \brief         Get certificate data for given identifier from AsrKeyM and add it as next iteration into given buffer.
 * \details       This function gets certificate data for given identifier from AsrKeyM and add it as next iteration
 *                of format [2 bytes length information| n bytes certificate data] into given buffer.
 * \param[in]     CertId          Certificate identifier
 * \param[out]    bufferIn        Buffer to add iteration data to.
 * \param[in]     bufferInLength  Size of buffer.
 * \param[in,out] dataIdx         Index of current iteration, initially 0.
 * \return        E_OK      Next iteration successfully added.
 *                E_NOT_OK  Length mismatch.
 * \pre           All provided pointers must be valid.
 * \context       TASK
 * \reentrant     TRUE for different CertIds
 * \synchronous   TRUE
 */
SSA_KEYM_LOCAL FUNC(Std_ReturnType, Ssa_KeyM_CODE) KeyM_AddNextIteration(
  KeyM_CertificateIdType CertId,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) bufferIn,
  uint32 bufferInLength,
  P2VAR(uint32, AUTOMATIC, AUTOMATIC) dataIdx);

/**********************************************************************************************************************
 *  KeyM_CheckRequestersAuthorization()
 *********************************************************************************************************************/
/*!
 * \brief       Check requester's authorization.
 * \details     Check whether subjectKeyIdentifier of the received ECU certificate can be verified (as enhanced rights)
 *              or: user role of current diagnostic user is PRODUCTION and post production status is not active.
 * \param[in]   subjectKeyIdentifier         Pointer to the data of the subject key id
 * \return      TRUE     Requester is sufficiently authorized.
 *              FALSE    Requester is not sufficiently authorized.
 * \pre         subjectKeyIdentifier must be a valid pointer.
 * \context     TASK
 * \reentrant   FALSE
 * \synchronous TRUE
 * \spec        requires subjectKeyIdentifier != NULL_PTR;                   \endspec
 */
SSA_KEYM_LOCAL FUNC(boolean, Ssa_KeyM_CODE) KeyM_CheckRequestersAuthorization(P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) subjectKeyIdentifier);

/**********************************************************************************************************************
 *  KeyM_ReplaceCertificate_MapCertificateStatusToVerificationResult()
 *********************************************************************************************************************/
/*!
 * \brief       Maps certificate status to verification result.
 * \details     Mapping is valid for the replace certificate routine.
 * \param[in]   pkiRole                 PKI role of the certificate under verification.
 * \param[in]   certificateStatus       Certificate status.
 * \param[out]  Verification_Result_Out Verification result.
 * \pre         All provided pointers must be valid.
 * \context     ANY
 * \reentrant   TRUE
 * \synchronous TRUE
 */
SSA_KEYM_LOCAL FUNC(void, Ssa_KeyM_CODE) KeyM_ReplaceCertificate_MapCertificateStatusToVerificationResult(
  CertP_PkiRoleType pkiRole,
  KeyM_CertificateStatusType certificateStatus,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) Verification_Result_Out);

/**********************************************************************************************************************
 *  KeyM_KeepCurrentCertificates()
 *********************************************************************************************************************/
/*!
 * \brief       Gets the currently stored Trust Model certificates and keeps them static.
 * \details     Gets the currently stored Trust Model Backend CA, Intermediate CA and ECU certificates
 *              and keeps them static if all there certificates have a valid status in AsrKeyM.
 *              Set a flag that certificates need to be restored if a following replace routine fails.
 * \pre         -
 * \context     TASK
 * \reentrant   FALSE
 * \synchronous TRUE
 */
SSA_KEYM_LOCAL_INLINE FUNC(void, Ssa_KeyM_CODE) KeyM_KeepCurrentCertificates(void);

/**********************************************************************************************************************
 *  KeyM_ReplaceTrustModelCerts_HandleStateIdle()
 *********************************************************************************************************************/
/*!
 * \brief       State handler function for the state SSA_KEYM_REPLACE_TRUST_MODEL_CERTS_STATE_IDLE
 *              of function Ssa_KeyM_RoutineServices_Replace_Trust_model_Certificates.
 * \details     This function handles the states of function Ssa_KeyM_RoutineServices_Replace_Trust_model_Certificates
 *              as given by table KeyM_Replace_Trust_Model_Certificates_State_Handler.
 *              It gets length and indices of provided certificates and advances synchronously to the state
 *              SSA_KEYM_REPLACE_TRUST_MODEL_CERTS_STATE_REQUESTING_SERVICE_CERT_BACKEND.
 * \param[in]   Trust_Certificates_In   The new certificates.
 * \param[in]   OpStatus                Current operation status.
 * \param[out]  routineInfo_Out         Execution status of the routine for positive responses.
 * \param[out]  Verification_Result_Out Positive response code of the routine.
 * \param[in]   DataLength              Length of the Trust_Certificates_In.
 * \param[out]  ErrorCode               Negative response code to be sent by DCM if return value is E_NOT_OK.
 * \return      RTE_E_OK if routine and called sub routines could be successfully executed.
 *              RTE_E_RoutineServices_Replace_Trust_model_Certificates_E_NOT_OK if an error occurred.
 *              RTE_E_RoutineServices_Replace_Trust_model_Certificates_DCM_E_PENDING if requested service is pending.
 * \pre         All provided pointers must be valid (routineInfo_Out can be a null pointer).
 * \context     TASK
 * \reentrant   FALSE
 * \synchronous FALSE
 */
SSA_KEYM_LOCAL FUNC(Std_ReturnType, Ssa_KeyM_CODE) KeyM_ReplaceTrustModelCerts_HandleStateIdle(
  P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) Trust_Certificates_In,
  Dcm_OpStatusType OpStatus,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) routineInfo_Out,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) Verification_Result_Out,
  uint16 DataLength,
  P2VAR(Dcm_NegativeResponseCodeType, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) ErrorCode);

/**********************************************************************************************************************
 *  KeyM_ReplaceTrustModelCerts_HandleStateRequestingServiceCertBackend()
 *********************************************************************************************************************/
/*!
 * \brief       State handler function for the SSA_KEYM_REPLACE_TRUST_MODEL_CERTS_STATE_REQUESTING_SERVICE_CERT_BACKEND
 *              state of function Ssa_KeyM_RoutineServices_Replace_Trust_model_Certificates.
 * \details     This function handles the states of function Ssa_KeyM_RoutineServices_Replace_Trust_model_Certificates
 *              as given by table KeyM_Replace_Trust_Model_Certificates_State_Handler.
 *              It sets or updates the Trust Model Backend CA certificate.
 * \param[in]   Trust_Certificates_In   The new certificates.
 * \param[in]   OpStatus                Current operation status.
 * \param[out]  routineInfo_Out         Execution status of the routine for positive responses.
 * \param[out]  Verification_Result_Out Positive response code of the routine.
 * \param[in]   DataLength              Length of the Trust_Certificates_In.
 * \param[out]  ErrorCode               Negative response code to be sent by DCM if return value is E_NOT_OK.
 * \return      RTE_E_OK if routine and called sub routines could be successfully executed.
 *              RTE_E_RoutineServices_Replace_Trust_model_Certificates_E_NOT_OK if an error occurred.
 *              RTE_E_RoutineServices_Replace_Trust_model_Certificates_DCM_E_PENDING if requested service is pending.
 * \pre         All provided pointers must be valid (routineInfo_Out can be a null pointer).
 * \context     TASK
 * \reentrant   FALSE
 * \synchronous FALSE
 */
SSA_KEYM_LOCAL FUNC(Std_ReturnType, Ssa_KeyM_CODE) KeyM_ReplaceTrustModelCerts_HandleStateRequestingServiceCertBackend(
  P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) Trust_Certificates_In,
  Dcm_OpStatusType OpStatus,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) routineInfo_Out,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) Verification_Result_Out,
  uint16 DataLength,
  P2VAR(Dcm_NegativeResponseCodeType, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) ErrorCode);

/**********************************************************************************************************************
 *  KeyM_ReplaceTrustModelCerts_AwaitingVerificationResultBackendCert()
 *********************************************************************************************************************/
/*!
 * \brief       State handler function for the states
 *              - SSA_KEYM_REPLACE_TRUST_MODEL_CERTS_STATE_AWAITING_VERIFICATION_RESULT_BACKEND_CERT
 *              of function Ssa_KeyM_RoutineServices_Replace_Trust_model_Certificates.
 * \details     This function handles the states of function Ssa_KeyM_RoutineServices_Replace_Trust_model_Certificates
 *              as given by table KeyM_Replace_Trust_Model_Certificates_State_Handler.
 *              It awaits result of setting/updating the Trust Model Backend CA certificate and sets or updates the
 *              Trust Model Intermediate CA certificate.
 * \param[in]   Trust_Certificates_In   The new certificates.
 * \param[in]   OpStatus                Current operation status.
 * \param[out]  routineInfo_Out         Execution status of the routine for positive responses.
 * \param[out]  Verification_Result_Out Positive response code of the routine.
 * \param[in]   DataLength              Length of the Trust_Certificates_In.
 * \param[out]  ErrorCode               Negative response code to be sent by DCM if return value is E_NOT_OK.
 * \return      RTE_E_OK if routine and called sub routines could be successfully executed.
 *              RTE_E_RoutineServices_Replace_Trust_model_Certificates_E_NOT_OK if an error occurred.
 *              RTE_E_RoutineServices_Replace_Trust_model_Certificates_DCM_E_PENDING if requested service is pending.
 * \pre         All provided pointers must be valid (routineInfo_Out can be a null pointer).
 * \context     TASK
 * \reentrant   FALSE
 * \synchronous FALSE
 */
SSA_KEYM_LOCAL FUNC(Std_ReturnType, Ssa_KeyM_CODE) KeyM_ReplaceTrustModelCerts_AwaitingVerificationResultBackendCert(
  P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) Trust_Certificates_In,
  Dcm_OpStatusType OpStatus,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) routineInfo_Out,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) Verification_Result_Out,
  uint16 DataLength,
  P2VAR(Dcm_NegativeResponseCodeType, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) ErrorCode);

/**********************************************************************************************************************
 *  KeyM_ReplaceTrustModelCerts_AwaitingVerificationResultIntermediateCert()
 *********************************************************************************************************************/
/*!
 * \brief       State handler function for the state
 *              SSA_KEYM_REPLACE_TRUST_MODEL_CERTS_STATE_AWAITING_VERIFICATION_RESULT_INTERMEDIATE_CERT of function
 *              Ssa_KeyM_RoutineServices_Replace_Trust_model_Certificates.
 * \details     This function handles the states of function Ssa_KeyM_RoutineServices_Replace_Trust_model_Certificates
 *              as given by table KeyM_Replace_Trust_Model_Certificates_State_Handler.
 *              It awaits result of setting/updating the Trust Model Intermediate CA certificate and sets.
 * \param[in]   Trust_Certificates_In   The new certificates.
 * \param[in]   OpStatus                Current operation status.
 * \param[out]  routineInfo_Out         Execution status of the routine for positive responses.
 * \param[out]  Verification_Result_Out Positive response code of the routine.
 * \param[in]   DataLength              Length of the Trust_Certificates_In.
 * \param[out]  ErrorCode               Negative response code to be sent by DCM if return value is E_NOT_OK.
 * \return      RTE_E_OK if routine and called sub routines could be successfully executed.
 *              RTE_E_RoutineServices_Replace_Trust_model_Certificates_E_NOT_OK if an error occurred.
 *              RTE_E_RoutineServices_Replace_Trust_model_Certificates_DCM_E_PENDING if requested service is pending.
 * \pre         All provided pointers must be valid (routineInfo_Out can be a null pointer).
 * \context     TASK
 * \reentrant   FALSE
 * \synchronous FALSE
 */
SSA_KEYM_LOCAL FUNC(Std_ReturnType, Ssa_KeyM_CODE) KeyM_ReplaceTrustModelCerts_AwaitingVerificationResultIntermediateCert(
  P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) Trust_Certificates_In,
  Dcm_OpStatusType OpStatus,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) routineInfo_Out,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) Verification_Result_Out,
  uint16 DataLength,
  P2VAR(Dcm_NegativeResponseCodeType, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) ErrorCode);

/**********************************************************************************************************************
 *  KeyM_ReplaceTrustModelCerts_AwaitingParsingResultEcuCert()
 *********************************************************************************************************************/
/*!
 * \brief       State handler function for the state
 *              SSA_KEYM_REPLACE_TRUST_MODEL_CERTS_STATE_AWAITING_PARSING_RESULT_ECU_CERT of function
 *              Ssa_KeyM_RoutineServices_Replace_Trust_model_Certificates.
 * \details     This function handles the states of function Ssa_KeyM_RoutineServices_Replace_Trust_model_Certificates
 *              as given by table KeyM_Replace_Trust_Model_Certificates_State_Handler.
 *              It awaits result of parsing the Trust Model Intermediate CA certificate and verifies
 *              the Trust Model ECU certificate.
 * \param[in]   Trust_Certificates_In   The new certificates.
 * \param[in]   OpStatus                Current operation status.
 * \param[out]  routineInfo_Out         Execution status of the routine for positive responses.
 * \param[out]  Verification_Result_Out Positive response code of the routine.
 * \param[in]   DataLength              Length of the Trust_Certificates_In.
 * \param[out]  ErrorCode               Negative response code to be sent by DCM if return value is E_NOT_OK.
 * \return      RTE_E_OK if routine and called sub routines could be successfully executed.
 *              RTE_E_RoutineServices_Replace_Trust_model_Certificates_E_NOT_OK if an error occurred.
 *              RTE_E_RoutineServices_Replace_Trust_model_Certificates_DCM_E_PENDING if requested service is pending.
 * \pre         All provided pointers must be valid (routineInfo_Out can be a null pointer).
 * \context     TASK
 * \reentrant   FALSE
 * \synchronous FALSE
 */
SSA_KEYM_LOCAL FUNC(Std_ReturnType, Ssa_KeyM_CODE) KeyM_ReplaceTrustModelCerts_AwaitingParsingResultEcuCert(
  P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) Trust_Certificates_In,
  Dcm_OpStatusType OpStatus,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) routineInfo_Out,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) Verification_Result_Out,
  uint16 DataLength,
  P2VAR(Dcm_NegativeResponseCodeType, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) ErrorCode);

/**********************************************************************************************************************
 *  KeyM_ReplaceTrustModelCerts_RequestingVerificationEcuCert()
 *********************************************************************************************************************/
/*!
 * \brief       State handler function for the state
 *              SSA_KEYM_REPLACE_TRUST_MODEL_CERTS_STATE_REQUESTING_FOR_VERIFICATION_ECU_CERT of function
 *              Ssa_KeyM_RoutineServices_Replace_Trust_model_Certificates.
 * \details     This function handles the states of function Ssa_KeyM_RoutineServices_Replace_Trust_model_Certificates
 *              as given by table KeyM_Replace_Trust_Model_Certificates_State_Handler.
 *              It sets and verifies the Trust Model ECU certificate.
 * \param[in]   Trust_Certificates_In   The new certificates.
 * \param[in]   OpStatus                Current operation status.
 * \param[out]  routineInfo_Out         Execution status of the routine for positive responses.
 * \param[out]  Verification_Result_Out Positive response code of the routine.
 * \param[in]   DataLength              Length of the Trust_Certificates_In.
 * \param[out]  ErrorCode               Negative response code to be sent by DCM if return value is E_NOT_OK.
 * \return      RTE_E_OK if routine and called sub routines could be successfully executed.
 *              RTE_E_RoutineServices_Replace_Trust_model_Certificates_E_NOT_OK if an error occurred.
 *              RTE_E_RoutineServices_Replace_Trust_model_Certificates_DCM_E_PENDING if requested service is pending.
 * \pre         All provided pointers must be valid (routineInfo_Out can be a null pointer).
 * \context     TASK
 * \reentrant   FALSE
 * \synchronous FALSE
 */
SSA_KEYM_LOCAL FUNC(Std_ReturnType, Ssa_KeyM_CODE) KeyM_ReplaceTrustModelCerts_RequestingVerificationEcuCert(
  P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) Trust_Certificates_In,
  Dcm_OpStatusType OpStatus,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) routineInfo_Out,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) Verification_Result_Out,
  uint16 DataLength,
  P2VAR(Dcm_NegativeResponseCodeType, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) ErrorCode);

/**********************************************************************************************************************
 *  KeyM_ReplaceTrustModelCerts_AwaitingVerificationResultEcuCert()
 *********************************************************************************************************************/
/*!
 * \brief       State handler function for the states
 *              - SSA_KEYM_REPLACE_TRUST_MODEL_CERTS_STATE_AWAITING_VERIFICATION_RESULT_ECU_CERT
 *              of function Ssa_KeyM_RoutineServices_Replace_Trust_model_Certificates.
 * \details     This function handles the states of function Ssa_KeyM_RoutineServices_Replace_Trust_model_Certificates
 *              as given by table KeyM_Replace_Trust_Model_Certificates_State_Handler.
 *              It awaits result of verifying the Trust Model ECU certificate and checks its UniqueEcuId.
 * \param[in]   Trust_Certificates_In   The new certificates.
 * \param[in]   OpStatus                Current operation status.
 * \param[out]  routineInfo_Out         Execution status of the routine for positive responses.
 * \param[out]  Verification_Result_Out Positive response code of the routine.
 * \param[in]   DataLength              Length of the Trust_Certificates_In.
 * \param[out]  ErrorCode               Negative response code to be sent by DCM if return value is E_NOT_OK.
 * \return      RTE_E_OK if routine and called sub routines could be successfully executed.
 *              RTE_E_RoutineServices_Replace_Trust_model_Certificates_E_NOT_OK if an error occurred.
 *              RTE_E_RoutineServices_Replace_Trust_model_Certificates_DCM_E_PENDING if requested service is pending.
 * \pre         All provided pointers must be valid (routineInfo_Out can be a null pointer).
 * \context     TASK
 * \reentrant   FALSE
 * \synchronous FALSE
 */
SSA_KEYM_LOCAL FUNC(Std_ReturnType, Ssa_KeyM_CODE) KeyM_ReplaceTrustModelCerts_AwaitingVerificationResultEcuCert(
  P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) Trust_Certificates_In,
  Dcm_OpStatusType OpStatus,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) routineInfo_Out,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) Verification_Result_Out,
  uint16 DataLength,
  P2VAR(Dcm_NegativeResponseCodeType, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) ErrorCode);

/**********************************************************************************************************************
 *  KeyM_ReplaceTrustModelCerts_VerifyingKey()
 *********************************************************************************************************************/
/*!
 * \brief       State handler function for the states
 *              - SSA_KEYM_REPLACE_TRUST_MODEL_CERTS_STATE_VERIFY_TRUST_MODEL_PRIVATE_KEY
 *              of function Ssa_KeyM_RoutineServices_Replace_Trust_model_Certificates.
 * \details     This function handles the states of function Ssa_KeyM_RoutineServices_Replace_Trust_model_Certificates
 *              as given by table KeyM_Replace_Trust_Model_Certificates_State_Handler.
 *              It verifies the Trust Model private key against the public key of the Trust Model ECU certificate.
 * \param[in]   Trust_Certificates_In   The new certificates.
 * \param[in]   OpStatus                Current operation status.
 * \param[out]  routineInfo_Out         Execution status of the routine for positive responses.
 * \param[out]  Verification_Result_Out Positive response code of the routine.
 * \param[in]   DataLength              Length of the Trust_Certificates_In.
 * \param[out]  ErrorCode               Negative response code to be sent by DCM if return value is E_NOT_OK.
 * \return      RTE_E_OK if routine and called sub routines could be successfully executed.
 *              RTE_E_RoutineServices_Replace_Trust_model_Certificates_E_NOT_OK if an error occurred.
 *              RTE_E_RoutineServices_Replace_Trust_model_Certificates_DCM_E_PENDING if requested service is pending.
 * \pre         Verification_Result_Out must be a valid pointer.
 * \context     TASK
 * \reentrant   FALSE
 * \synchronous FALSE
 */
SSA_KEYM_LOCAL FUNC(Std_ReturnType, Ssa_KeyM_CODE) KeyM_ReplaceTrustModelCerts_VerifyingKey(
  P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) Trust_Certificates_In,
  Dcm_OpStatusType OpStatus,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) routineInfo_Out,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) Verification_Result_Out,
  uint16 DataLength,
  P2VAR(Dcm_NegativeResponseCodeType, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) ErrorCode);

/**********************************************************************************************************************
 *  KeyM_ReplaceTrustModelCerts_Storing()
 *********************************************************************************************************************/
/*!
 * \brief       State handler function for the states
 *              - SSA_KEYM_REPLACE_TRUST_MODEL_CERTS_STATE_STORE_INIT and
 *              - SSA_KEYM_REPLACE_TRUST_MODEL_CERTS_STATE_STORE_PENDING
 *              of function Ssa_KeyM_RoutineServices_Replace_Trust_model_Certificates.
 * \details     This function handles the states of function Ssa_KeyM_RoutineServices_Replace_Trust_model_Certificates
 *              as given by table KeyM_Replace_Trust_Model_Certificates_State_Handler.
 *              It triggers the application to store the Trust Model certificates.
 * \param[in]   Trust_Certificates_In   The new certificates.
 * \param[in]   OpStatus                Current operation status.
 * \param[out]  routineInfo_Out         Execution status of the routine for positive responses.
 * \param[out]  Verification_Result_Out Positive response code of the routine.
 * \param[in]   DataLength              Length of the Trust_Certificates_In.
 * \param[out]  ErrorCode               Negative response code to be sent by DCM if return value is E_NOT_OK.
 * \return      RTE_E_OK if routine and called sub routines could be successfully executed.
 *              RTE_E_RoutineServices_Replace_Trust_model_Certificates_E_NOT_OK if an error occurred.
 *              RTE_E_RoutineServices_Replace_Trust_model_Certificates_DCM_E_PENDING if requested service is pending.
 * \pre         All provided pointers must be valid (routineInfo_Out can be a null pointer).
 * \context     TASK
 * \reentrant   FALSE
 * \synchronous FALSE
 */
SSA_KEYM_LOCAL FUNC(Std_ReturnType, Ssa_KeyM_CODE) KeyM_ReplaceTrustModelCerts_Storing(
  P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) Trust_Certificates_In,
  Dcm_OpStatusType OpStatus,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) routineInfo_Out,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) Verification_Result_Out,
  uint16 DataLength,
  P2VAR(Dcm_NegativeResponseCodeType, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) ErrorCode);

/**********************************************************************************************************************
 *  KeyM_ReplaceTrustModelCerts_WritingToNVM()
 *********************************************************************************************************************/
/*!
 * \brief       State handler function for the states
 *              - SSA_KEYM_REPLACE_TRUST_MODEL_CERTS_STATE_NVM_WRITE and
 *              - SSA_KEYM_REPLACE_TRUST_MODEL_CERTS_STATE_NVM_WAIT
 *              of function Ssa_KeyM_RoutineServices_Replace_Trust_model_Certificates.
 * \details     This function handles the states of function Ssa_KeyM_RoutineServices_Replace_Trust_model_Certificates
 *              as given by table KeyM_Replace_Trust_Model_Certificates_State_Handler.
 *              It writes the KeyM NVMRam block.
 * \param[in]   Trust_Certificates_In   The new certificates.
 * \param[in]   OpStatus                Current operation status.
 * \param[out]  routineInfo_Out         Execution status of the routine for positive responses.
 * \param[out]  Verification_Result_Out Positive response code of the routine.
 * \param[in]   DataLength              Length of the Trust_Certificates_In.
 * \param[out]  ErrorCode               Negative response code to be sent by DCM if return value is E_NOT_OK.
 * \return      RTE_E_OK if routine and called sub routines could be successfully executed.
 *              RTE_E_RoutineServices_Replace_Trust_model_Certificates_E_NOT_OK if an error occurred.
 *              RTE_E_RoutineServices_Replace_Trust_model_Certificates_DCM_E_PENDING if requested service is pending.
 * \pre         Verification_Result_Out must be a valid pointer.
 * \context     TASK
 * \reentrant   FALSE
 * \synchronous FALSE
 */
SSA_KEYM_LOCAL FUNC(Std_ReturnType, Ssa_KeyM_CODE) KeyM_ReplaceTrustModelCerts_WritingToNVM(
  P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) Trust_Certificates_In,
  Dcm_OpStatusType OpStatus,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) routineInfo_Out,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) Verification_Result_Out,
  uint16 DataLength,
  P2VAR(Dcm_NegativeResponseCodeType, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) ErrorCode);

/**********************************************************************************************************************
 *  KeyM_ReplaceRoot_MapCertificateStatusToVerificationResult()
 *********************************************************************************************************************/
/*!
 * \brief       Map AsrKeyM certificate status to verification result.
 * \details     Mapping is valid for the replace root routine.
 * \param[in]   certificateStatus         KeyM certificate status.
 * \param[out]  Verification_Result_Out   Verification result.
 * \pre         Verification_Result_Out must be a valid pointer.
 * \context     TASK
 * \reentrant   TRUE
 * \synchronous TRUE
 */
SSA_KEYM_LOCAL FUNC(void, Ssa_KeyM_CODE) KeyM_ReplaceRoot_MapCertificateStatusToVerificationResult(
  KeyM_CertificateStatusType certificateStatus,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) Verification_Result_Out);

#if (SSA_DIAG_SERVICE_TRUST_MODEL_GENERATE_KEY_PAIR == STD_ON)

/**********************************************************************************************************************
 *  KeyM_TrustModelGenerateKeyPair_HandleStateIdle()
 *********************************************************************************************************************/
/*!
 * \brief       State handler function for the state SSA_KEYM_TRUST_MODEL_GENERATE_KEY_PAIR_STATE_IDLE
 *              of function Ssa_KeyM_RoutineServices_Trust_Model_Generate_Key_Pair.
 * \details     This function handles the states of function Ssa_KeyM_RoutineServices_Trust_Model_Generate_Key_Pair
 *              as given by the table KeyM_Trust_Model_Generate_Key_Pair_State_Handler.
 *              It advances the diagnostic processing state to
 *              SSA_KEYM_TRUST_MODEL_GENERATE_KEY_PAIR_STATE_VERIFYING_KEY_PAIR.
 * \param[out]  Verification_Result_Out Positive response code of the routine.
 * \param[out]  CSR_Signature_Out       CSR signature output parameter of the diagnostic routine as specified in DSUDS.
 * \param[out]  Trust_Model_ECU_CSR_Out CSR output parameter of the diagnostic routine as specified in DSUDS.
 * \param[out]  DataLength              Length Trust_Model_ECU_CSR_Out in bytes.
 * \return      SSA_E_PENDING if there was no error during routine execution but the routine service has still not
 *                            finished. This does not imply that the routine stays in the current state.
 *              E_OK          if the diagnostic service has finished successfully.
 *              E_NOT_OK      if the function or any of the sub-functions failed and the diagnostic service should
 *                            return a failure.
 * \pre         Verification_Result_Out must be a valid pointer.
 * \context     TASK
 * \reentrant   FALSE
 * \synchronous FALSE
 */
SSA_KEYM_LOCAL FUNC(Std_ReturnType, Ssa_KeyM_CODE) KeyM_TrustModelGenerateKeyPair_HandleStateIdle(
    P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) Verification_Result_Out,
    P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) CSR_Signature_Out,
    P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) Trust_Model_ECU_CSR_Out,
    P2VAR(uint16, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) DataLength);

/**********************************************************************************************************************
 *  KeyM_TrustModelGenerateKeyPair_HandleStateGeneratingKeyPair()
 *********************************************************************************************************************/
/*!
 * \brief       State handler function for the states SSA_KEYM_TRUST_MODEL_GENERATE_KEY_PAIR_STATE_GENERATING_KEY_PAIR
 *              of function Ssa_KeyM_RoutineServices_Trust_Model_Generate_Key_Pair.
 * \details     This function handles the states of function Ssa_KeyM_RoutineServices_Trust_Model_Generate_Key_Pair
 *              as given by the table KeyM_Trust_Model_Generate_Key_Pair_State_Handler.
 *              It generates a new ED25519 public/private key pair into the trust model ECU staging slots.
 * \param[out]  Verification_Result_Out Positive response code of the routine.
 * \param[out]  CSR_Signature_Out       CSR signature output parameter of the diagnostic routine as specified in DSUDS.
 * \param[out]  Trust_Model_ECU_CSR_Out CSR output parameter of the diagnostic routine as specified in DSUDS.
 * \param[out]  DataLength              Length Trust_Model_ECU_CSR_Out in bytes.
 * \return      SSA_E_PENDING if there was no error during routine execution but the routine service has still not
 *                            finished. This does not imply that the routine stays in the current state.
 *              E_OK          if the diagnostic service has finished successfully.
 *              E_NOT_OK      if the function or any of the sub-functions failed and the diagnostic service should
 *                            return a failure.
 * \pre         Verification_Result_Out must be a valid pointer.
 * \context     TASK
 * \reentrant   FALSE
 * \synchronous FALSE
 */
SSA_KEYM_LOCAL FUNC(Std_ReturnType, Ssa_KeyM_CODE) KeyM_TrustModelGenerateKeyPair_HandleStateGeneratingKeyPair(
    P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) Verification_Result_Out,
    P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) CSR_Signature_Out,
    P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) Trust_Model_ECU_CSR_Out,
    P2VAR(uint16, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) DataLength);

/**********************************************************************************************************************
 *  KeyM_TrustModelGenerateKeyPair_HandleStateVerifyingKeyPair()
 *********************************************************************************************************************/
/*!
 * \brief       State handler function for the state SSA_KEYM_TRUST_MODEL_GENERATE_KEY_PAIR_STATE_VERIFYING_KEY_PAIR
 *              of function Ssa_KeyM_RoutineServices_Trust_Model_Generate_Key_Pair.
 * \details     This function handles the states of function Ssa_KeyM_RoutineServices_Trust_Model_Generate_Key_Pair
 *              as given by the table KeyM_Trust_Model_Generate_Key_Pair_State_Handler.
 *              It verifies that the private/public key pair in the trust model ECU staging slots match and if so, asks
                the AsrKeyM to generate a CSR based on the trust model ECU staging key pair.
 * \param[out]  Verification_Result_Out Positive response code of the routine.
 * \param[out]  CSR_Signature_Out       CSR signature output parameter of the diagnostic routine as specified in DSUDS.
 * \param[out]  Trust_Model_ECU_CSR_Out CSR output parameter of the diagnostic routine as specified in DSUDS.
 * \param[out]  DataLength              Length Trust_Model_ECU_CSR_Out in bytes.
 * \return      SSA_E_PENDING if there was no error during routine execution but the routine service has still not
 *                            finished. This does not imply that the routine stays in the current state.
 *              E_OK          if the diagnostic service has finished successfully.
 *              E_NOT_OK      if the function or any of the sub-functions failed and the diagnostic service should
 *                            return a failure.
 * \pre         -
 * \context     TASK
 * \reentrant   FALSE
 * \synchronous FALSE
 */
SSA_KEYM_LOCAL FUNC(Std_ReturnType, Ssa_KeyM_CODE) KeyM_TrustModelGenerateKeyPair_HandleStateVerifyingKeyPair(
    P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) Verification_Result_Out,
    P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) CSR_Signature_Out,
    P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) Trust_Model_ECU_CSR_Out,
    P2VAR(uint16, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) DataLength);

/**********************************************************************************************************************
 *  KeyM_TrustModelGenerateKeyPair_HandleStateAwaitingCsr()
 *********************************************************************************************************************/
/*!
 * \brief       State handler function for the state SSA_KEYM_TRUST_MODEL_GENERATE_KEY_PAIR_STATE_AWAITING_CSR
 *              of function Ssa_KeyM_RoutineServices_Trust_Model_Generate_Key_Pair.
 * \details     This function handles the states of function Ssa_KeyM_RoutineServices_Trust_Model_Generate_Key_Pair
 *              as given by the table KeyM_Trust_Model_Generate_Key_Pair_State_Handler.
 *              It returns SSA_E_PENDING until the AsrKeyM finished the CSR creation. If the CSR creation has finished
                successfully, it copies the CSR into Trust_Model_ECU_CSR_Out and advances to the next state.
 * \param[out]  Verification_Result_Out Positive response code of the routine.
 * \param[out]  CSR_Signature_Out       CSR signature output parameter of the diagnostic routine as specified in DSUDS.
 * \param[out]  Trust_Model_ECU_CSR_Out CSR output parameter of the diagnostic routine as specified in DSUDS.
 * \param[out]  DataLength              Length Trust_Model_ECU_CSR_Out in bytes.
 * \return      SSA_E_PENDING if there was no error during routine execution but the routine service has still not
 *                            finished. This does not imply that the routine stays in the current state.
 *              E_OK          if the diagnostic service has finished successfully.
 *              E_NOT_OK      if the function or any of the sub-functions failed and the diagnostic service should
 *                            return a failure.
 * \pre         Trust_Model_ECU_CSR_Out and DataLength must be valid pointers.
 * \context     TASK
 * \reentrant   FALSE
 * \synchronous FALSE
 * \spec        requires $lengthOf(Trust_Model_ECU_CSR_Out) >= sizeof(Dcm_Data1002ByteType);                   \endspec
 */
SSA_KEYM_LOCAL FUNC(Std_ReturnType, Ssa_KeyM_CODE) KeyM_TrustModelGenerateKeyPair_HandleStateAwaitingCsr(
    P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) Verification_Result_Out,
    P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) CSR_Signature_Out,
    P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) Trust_Model_ECU_CSR_Out,
    P2VAR(uint16, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) DataLength);

/**********************************************************************************************************************
 *  KeyM_TrustModelGenerateKeyPair_HandleStateCreatingSignature()
 *********************************************************************************************************************/
/*!
 * \brief       State handler function for the state SSA_KEYM_TRUST_MODEL_GENERATE_KEY_PAIR_STATE_CREATING_SIGNATURE
 *              of function Ssa_KeyM_RoutineServices_Trust_Model_Generate_Key_Pair.
 * \details     This function handles the states of function Ssa_KeyM_RoutineServices_Trust_Model_Generate_Key_Pair
 *              as given by the table KeyM_Trust_Model_Generate_Key_Pair_State_Handler.
 *              It generates a signature over Trust_Model_ECU_CSR_Out, writes it into CSR_Signature_Out and if
 *              successful, finishes the diagnostic routine by returning E_OK.
 * \param[out]  Verification_Result_Out Positive response code of the routine.
 * \param[out]  CSR_Signature_Out       CSR signature output parameter of the diagnostic routine as specified in DSUDS.
 * \param[out]  Trust_Model_ECU_CSR_Out CSR output parameter of the diagnostic routine as specified in DSUDS.
 * \param[out]  DataLength              Length Trust_Model_ECU_CSR_Out in bytes.
 * \return      SSA_E_PENDING if there was no error during routine execution but the routine service has still not
 *                            finished. This does not imply that the routine stays in the current state.
 *              E_OK          if the diagnostic service has finished successfully.
 *              E_NOT_OK      if the function or any of the sub-functions failed and the diagnostic service should
 *                            return a failure.
 * \pre         All provided pointers must be valid.
 *              The buffer referenced by CSR_Signature_Out must provide at least SSA_SIZEOF_SIGNATURE many bytes.
 * \context     TASK
 * \reentrant   FALSE
 * \synchronous FALSE
 */
SSA_KEYM_LOCAL FUNC(Std_ReturnType, Ssa_KeyM_CODE) KeyM_TrustModelGenerateKeyPair_HandleStateCreatingSignature(
    P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) Verification_Result_Out,
    P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) CSR_Signature_Out,
    P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) Trust_Model_ECU_CSR_Out,
    P2VAR(uint16, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) DataLength);

#endif

/**********************************************************************************************************************
 *  KeyM_ReplaceTrustModelRootCert_HandleStateIdleAndVerifyingEnhanceCert()
 *********************************************************************************************************************/
/*!
 * \brief       State handler function for the states
 *              - SSA_KEYM_REPLACE_TRUST_MODEL_ROOT_CERT_STATE_IDLE
 *              of function Ssa_KeyM_RoutineServices_Replace_Trust_model_Root_Certificate.
 * \details     This function handles the states of function Ssa_KeyM_RoutineServices_Replace_Trust_model_Root_Certificate
 *              as given by table KeyM_Replace_Trust_model_Root_Certificate_State_Handler.
 *              It gets length and indices of provided certificates, verifies the Enhanced Rights certificate and
 *              arranges the replacement package for its verification.
 * \param[in]   signature_new_Root_In   The signature calculated over new the Trust Model Root CA certificate by the
 *                                      replacement authority.
 * \param[in]   signature_In            The signature calculated over the replacement package by Daimler Backend.
 * \param[in]   Certificates_In         The Enhanced Rights certificate authorizing the replacement of the present
 *                                      Trust Model Root CA certificate and the new Trust Model Root CA certificate.
 *                                      Must reference a buffer of at least sizeof(Dcm_Data2004ByteType) many bytes.
 * \param[in]   OpStatus                Current operation status.
 * \param[out]  routineInfo_Out         Execution status of the routine for positive responses.
 * \param[out]  Verification_Result_Out Positive response code of the routine.
 * \param[in]   DataLength              Length of Certificates_In.
 * \param[out]  ErrorCode               Negative response code to be sent by DCM if return value is E_NOT_OK.
 * \return      RTE_E_OK if routine and called sub routines could be successfully executed.
 *              RTE_E_RoutineServices_Replace_Trust_model_Root_Certificate_E_NOT_OK if an error occurred.
 *              RTE_E_RoutineServices_Replace_Trust_model_Root_Certificate_DCM_E_PENDING if requested service is pending.
 * \pre         All provided pointers must be valid.
 * \context     TASK
 * \reentrant   FALSE
 * \synchronous FALSE
 * \spec        requires $lengthOf(Certificates_In) >= sizeof(Dcm_Data2004ByteType);                           \endspec
 */
SSA_KEYM_LOCAL FUNC(Std_ReturnType, Ssa_KeyM_CODE) KeyM_ReplaceTrustModelRootCert_HandleStateIdleAndVerifyingEnhanceCert(
  P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) signature_new_Root_In,
  P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) signature_In,
  P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) Certificates_In,
  Dcm_OpStatusType OpStatus,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) routineInfo_Out,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) Verification_Result_Out,
  uint16 DataLength,
  P2VAR(Dcm_NegativeResponseCodeType, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) ErrorCode);

/**********************************************************************************************************************
 *  KeyM_ReplaceTrustModelRootCert_HandleStateVerifyingReplacementPackageAndSubjectKeyId()
 *********************************************************************************************************************/
/*!
 * \brief       State handler function for the states
 *              - SSA_KEYM_REPLACE_TRUST_MODEL_ROOT_CERT_STATE_VERIFYING_REPLACEMENT_PACKAGE_SUBKEYID
 *              of function Ssa_KeyM_RoutineServices_Replace_Trust_model_Root_Certificate.
 * \details     This function handles the states of function Ssa_KeyM_RoutineServices_Replace_Trust_model_Root_Certificate
 *              as given by table KeyM_Replace_Trust_model_Root_Certificate_State_Handler.
 *              It verifies the replacement package and the subject key identifier of stored Trust Model Root CA
 *              certificate.
 * \param[in]   signature_new_Root_In   The signature calculated over new the Trust Model Root CA certificate by the
 *                                      replacement authority.
 * \param[in]   signature_In            The signature calculated over the replacement package by Daimler Backend.
 * \param[in]   Certificates_In         The Enhanced Rights certificate authorizing the replacement of the present
 *                                      Trust Model Root CA certificate and the new Trust Model Root CA certificate.
 * \param[in]   OpStatus                Current operation status.
 * \param[out]  routineInfo_Out         Execution status of the routine for positive responses.
 * \param[out]  Verification_Result_Out Positive response code of the routine.
 * \param[in]   DataLength              Length of Certificates_In.
 * \param[out]  ErrorCode               Negative response code to be sent by DCM if return value is E_NOT_OK.
 * \return      RTE_E_OK if routine and called sub routines could be successfully executed.
 *              RTE_E_RoutineServices_Replace_Trust_model_Root_Certificate_E_NOT_OK if an error occurred.
 *              RTE_E_RoutineServices_Replace_Trust_model_Root_Certificate_DCM_E_PENDING if requested service is pending.
 * \pre         All provided pointers must be valid (routineInfo_Out can be a null pointer).
 * \context     TASK
 * \reentrant   FALSE
 * \synchronous FALSE
 */
SSA_KEYM_LOCAL FUNC(Std_ReturnType, Ssa_KeyM_CODE) KeyM_ReplaceTrustModelRootCert_HandleStateVerifyingReplacementPackageAndSubjectKeyId(
  P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) signature_new_Root_In,
  P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) signature_In,
  P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) Certificates_In,
  Dcm_OpStatusType OpStatus,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) routineInfo_Out,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) Verification_Result_Out,
  uint16 DataLength,
  P2VAR(Dcm_NegativeResponseCodeType, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) ErrorCode);

/**********************************************************************************************************************
 *  KeyM_ReplaceTrustModelRootCert_HandleStateVerifyingSignatureNewRoot()
 *********************************************************************************************************************/
/*!
 * \brief       State handler function for the states
 *              - SSA_KEYM_REPLACE_TRUST_MODEL_ROOT_CERT_STATE_STARTING_VERIFICATION_SIGNATURE_NEW_ROOT and
 *              - SSA_KEYM_REPLACE_TRUST_MODEL_ROOT_CERT_STATE_AWAITING_VERIF_RESULT_SIGNATURE_NEW_ROOT
 *              of function Ssa_KeyM_RoutineServices_Replace_Trust_model_Root_Certificate.
 * \details     This function handles the states of function Ssa_KeyM_RoutineServices_Replace_Trust_model_Root_Certificate
 *              as given by table KeyM_Replace_Trust_model_Root_Certificate_State_Handler.
 *              It verifies the signature over new Trust Model Root CA certificate and then updates it.
 * \param[in]   signature_new_Root_In   The signature calculated over new the Trust Model Root CA certificate by the
 *                                      replacement authority.
 * \param[in]   signature_In            The signature calculated over the replacement package by Daimler Backend.
 * \param[in]   Certificates_In         The Enhanced Rights certificate authorizing the replacement of the present
 *                                      Trust Model Root CA certificate and the new Trust Model Root CA certificate.
 *                                      Must reference a buffer of at least sizeof(Dcm_Data2002ByteType) many bytes.
 * \param[in]   OpStatus                Current operation status.
 * \param[out]  routineInfo_Out         Execution status of the routine for positive responses.
 * \param[out]  Verification_Result_Out Positive response code of the routine.
 * \param[in]   DataLength              Length of Certificates_In.
 * \param[out]  ErrorCode               Negative response code to be sent by DCM if return value is E_NOT_OK.
 * \return      RTE_E_OK if routine and called sub routines could be successfully executed.
 *              RTE_E_RoutineServices_Replace_Trust_model_Root_Certificate_E_NOT_OK if an error occurred.
 *              RTE_E_RoutineServices_Replace_Trust_model_Root_Certificate_DCM_E_PENDING if requested service is pending.
 * \pre         All provided pointers must be valid (routineInfo_Out can be a null pointer).
 * \context     TASK
 * \reentrant   FALSE
 * \synchronous FALSE
 * \spec        requires $lengthOf(Certificates_In) >= sizeof(Dcm_Data2004ByteType);                           \endspec
 */
SSA_KEYM_LOCAL FUNC(Std_ReturnType, Ssa_KeyM_CODE) KeyM_ReplaceTrustModelRootCert_HandleStateVerifyingSignatureNewRoot(
  P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) signature_new_Root_In,
  P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) signature_In,
  P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) Certificates_In,
  Dcm_OpStatusType OpStatus,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) routineInfo_Out,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) Verification_Result_Out,
  uint16 DataLength,
  P2VAR(Dcm_NegativeResponseCodeType, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) ErrorCode);

/**********************************************************************************************************************
 *  KeyM_ReplaceTrustModelRootCert_HandleStateAwaitingVerificationResultNewRootCertAndStoring()
 *********************************************************************************************************************/
/*!
 * \brief       State handler function for the states
 *              - SSA_KEYM_REPLACE_TRUST_MODEL_ROOT_CERT_STATE_AWAITING_VERIF_RESULT_NEW_ROOT_CERT,
 *              - SSA_KEYM_REPLACE_TRUST_MODEL_ROOT_CERT_STATE_ROLLING_BACK_CERTIFICATE_DATA,
 *              - SSA_KEYM_REPLACE_TRUST_MODEL_ROOT_CERT_STATE_STORE_INIT and
 *              - SSA_KEYM_REPLACE_TRUST_MODEL_ROOT_CERT_STATE_STORE_PENDING
 *              of function Ssa_KeyM_RoutineServices_Replace_Trust_model_Root_Certificate.
 * \details     This function handles the states of function Ssa_KeyM_RoutineServices_Replace_Trust_model_Root_Certificate
 *              as given by table KeyM_Replace_Trust_model_Root_Certificate_State_Handler.
 *              It awaits the result of updating the Trust Model Root CA certificate and then triggers the application
 *              to store it.
 * \param[in]   signature_new_Root_In   The signature calculated over new the Trust Model Root CA certificate by the
 *                                      replacement authority.
 * \param[in]   signature_In            The signature calculated over the replacement package by Daimler Backend.
 * \param[in]   Certificates_In         The Enhanced Rights certificate authorizing the replacement of the present
 *                                      Trust Model Root CA certificate and the new Trust Model Root CA certificate.
 * \param[in]   OpStatus                Current operation status.
 * \param[out]  routineInfo_Out         Execution status of the routine for positive responses.
 * \param[out]  Verification_Result_Out Positive response code of the routine.
 * \param[in]   DataLength              Length of Certificates_In.
 * \param[out]  ErrorCode               Negative response code to be sent by DCM if return value is E_NOT_OK.
 * \return      RTE_E_OK if routine and called sub routines could be successfully executed.
 *              RTE_E_RoutineServices_Replace_Trust_model_Root_Certificate_E_NOT_OK if an error occurred.
 *              RTE_E_RoutineServices_Replace_Trust_model_Root_Certificate_DCM_E_PENDING if requested service is pending.
 * \pre         All provided pointers must be valid (routineInfo_Out can be a null pointer).
 * \context     TASK
 * \reentrant   FALSE
 * \synchronous FALSE
 */
SSA_KEYM_LOCAL FUNC(Std_ReturnType, Ssa_KeyM_CODE) KeyM_ReplaceTrustModelRootCert_HandleStateAwaitingVerificationResultNewRootCertAndStoring(
  P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) signature_new_Root_In,
  P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) signature_In,
  P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) Certificates_In,
  Dcm_OpStatusType OpStatus,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) routineInfo_Out,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) Verification_Result_Out,
  uint16 DataLength,
  P2VAR(Dcm_NegativeResponseCodeType, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) ErrorCode);

/**********************************************************************************************************************
 *  KeyM_ReplaceTrustModelRootCert_HandleStateWritingToNVM()
 *********************************************************************************************************************/
/*!
 * \brief       State handler function for the states
 *              - SSA_KEYM_REPLACE_TRUST_MODEL_ROOT_CERT_STATE_NVM_WRITE,
 *              - SSA_KEYM_REPLACE_TRUST_MODEL_ROOT_CERT_STATE_NVM_WAIT
 *              of function Ssa_KeyM_RoutineServices_Replace_Trust_model_Root_Certificate.
 * \details     This function handles the states of function Ssa_KeyM_RoutineServices_Replace_Trust_model_Root_Certificate
 *              as given by table KeyM_Replace_Trust_model_Root_Certificate_State_Handler.
 *              It writes the KeyM NVMRam block.
 * \param[in]   signature_new_Root_In   The signature calculated over new the Trust Model Root CA certificate by the
 *                                      replacement authority.
 * \param[in]   signature_In            The signature calculated over the replacement package by Daimler Backend.
 * \param[in]   Certificates_In         The Enhanced Rights certificate authorizing the replacement of the present
 *                                      Trust Model Root CA certificate and the new Trust Model Root CA certificate.
 * \param[in]   OpStatus                Current operation status.
 * \param[out]  routineInfo_Out         Execution status of the routine for positive responses.
 * \param[out]  Verification_Result_Out Positive response code of the routine.
 * \param[in]   DataLength              Length of Certificates_In.
 * \param[out]  ErrorCode               Negative response code to be sent by DCM if return value is E_NOT_OK.
 * \return      RTE_E_OK if routine and called sub routines could be successfully executed.
 *              RTE_E_RoutineServices_Replace_Trust_model_Root_Certificate_E_NOT_OK if an error occurred.
 *              RTE_E_RoutineServices_Replace_Trust_model_Root_Certificate_DCM_E_PENDING if requested service is pending.
 * \pre         Verification_Result_Out must be a valid pointer.
 * \context     TASK
 * \reentrant   FALSE
 * \synchronous FALSE
 */
SSA_KEYM_LOCAL FUNC(Std_ReturnType, Ssa_KeyM_CODE) KeyM_ReplaceTrustModelRootCert_HandleStateWritingToNVM(
  P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) signature_new_Root_In,
  P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) signature_In,
  P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) Certificates_In,
  Dcm_OpStatusType OpStatus,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) routineInfo_Out,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) Verification_Result_Out,
  uint16 DataLength,
  P2VAR(Dcm_NegativeResponseCodeType, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) ErrorCode);

#if (SSA_ECU_TYPE == SSA_ECU_TYPE_VSM)

/**********************************************************************************************************************
 *  KeyM_EcuSharedSecretEncryption_HandleStateIdle()
 *********************************************************************************************************************/
/*!
 * \brief         State handler function for the states
 *                - KEYM_ENCRYPTSHAREDSECRET_STATE_IDLE
 *                - KEYM_ENCRYPTSHAREDSECRET_STATE_VERIFY_ECU_CERTIFICATE
 *                of function KeyM_EncryptSharedSecret.
 * \details       It verifies the received certificates.
 * \param[in]     chainOfTrust                      The chain of trust to be used.
 * \param[in]     Nonce                             Pointer to the nonce.
 * \param[in]     Ephemeral_ECU_Public_Key          Pointer to the ephemeral ECU public key.
 * \param[in]     Data_Signature_In                 Pointer to the data signature, can be a null pointer.
 * \param[in]     Target_ECU_Certificate            Pointer to target ECU certificate, the ECU obtaining the encrypted secret.
 * \param[in]     OpStatus                          Current operation status.
 * \param[out]    routineInfo                       Execution status of the routine for positive responses, can be a null pointer.
 * \param[out]    Verification_Result               Positive Response Code of the routine.
 * \param[out]    Date_and_Time                     Pointer to the memory location to store date and time, can be a null pointer.
 * \param[out]    Tick_Count                        Pointer to the memory location to store the tick count, can be a null pointer.
 * \param[out]    Tick_Count_Offset                 Pointer to the memory location to store the tick count offset, can be a null pointer.
 * \param[out]    Encrypted_Nonce_and_Shared_Secret Pointer to the memory location to store the encrypted nonce and secret, can be a null pointer.
 * \param[out]    Ephemeral_VSM_Public_Key          Pointer to the memory location to store the ephemeral VSM public key, can be a null pointer.
 * \param[out]    Data_Signature_Out                Pointer to the memory location to store the generated signature, can be a null pointer.
 * \param[out]    VSM_s_ECU_Certificate             Pointer to the memory location to store the VSM certificate, can be a null pointer.
 * \param[in,out] DataLength                        In: Length in bytes of Target_ECU_Certificate, Out: Length in bytes of VSM_s_ECU_Certificate.
 * \param[out]    ErrorCode                         Negative response code to be sent by DCM if return value is E_NOT_OK.
 * \param[in]     allowStandardSecret               Set to TRUE to allow the standard secret as car-specific secret.
 * \return        E_OK                              Request successful.
 *                E_NOT_OK                          Request failed.
 *                SSA_E_PENDING                     Requested service is pending.
 * \pre           Verification_Result, DataLength and ErrorCode must be valid pointers.
 * \context       TASK
 * \reentrant     FALSE
 * \synchronous   FALSE
 */
SSA_KEYM_LOCAL FUNC(Std_ReturnType, Ssa_KeyM_CODE) KeyM_EcuSharedSecretEncryption_HandleStateIdle(
  uint8 chainOfTrust,
  P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) Nonce,
  P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) Ephemeral_ECU_Public_Key,
  P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) Data_Signature_In,
  P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) Target_ECU_Certificate,
  Dcm_OpStatusType OpStatus,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) routineInfo,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) Verification_Result,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) Date_and_Time,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) Tick_Count,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) Tick_Count_Offset,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) Encrypted_Nonce_and_Shared_Secret,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) Ephemeral_VSM_Public_Key,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) Data_Signature_Out,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) VSM_s_ECU_Certificate,
  P2VAR(uint16, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) DataLength,
  P2VAR(Dcm_NegativeResponseCodeType, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) ErrorCode,
  boolean allowStandardSecret);

/**********************************************************************************************************************
 *  KeyM_EcuSharedSecretEncryption_HandleStateVerifySignature()
 *********************************************************************************************************************/
/*!
 * \brief         State handler function for the states
 *                - KEYM_ENCRYPTSHAREDSECRET_STATE_VERIFY_SIGNATURE
 *                of function KeyM_EncryptSharedSecret.
 * \details       It verifies the signature over the input data.
 * \param[in]     chainOfTrust                      The chain of trust to be used.
 * \param[in]     Nonce                             Pointer to the nonce.
 * \param[in]     Ephemeral_ECU_Public_Key          Pointer to the ephemeral ECU public key.
 * \param[in]     Data_Signature_In                 Pointer to the data signature.
 * \param[in]     Target_ECU_Certificate            Pointer to target ECU certificate, the ECU obtaining the encrypted secret.
 * \param[in]     OpStatus                          Current operation status.
 * \param[out]    routineInfo                       Execution status of the routine for positive responses, can be a null pointer.
 * \param[out]    Verification_Result               Positive Response Code of the routine.
 * \param[out]    Date_and_Time                     Pointer to the memory location to store date and time, can be a null pointer.
 * \param[out]    Tick_Count                        Pointer to the memory location to store the tick count, can be a null pointer.
 * \param[out]    Tick_Count_Offset                 Pointer to the memory location to store the tick count offset, can be a null pointer.
 * \param[out]    Encrypted_Nonce_and_Shared_Secret Pointer to the memory location to store the encrypted nonce and secret, can be a null pointer.
 * \param[out]    Ephemeral_VSM_Public_Key          Pointer to the memory location to store the ephemeral VSM public key, can be a null pointer.
 * \param[out]    Data_Signature_Out                Pointer to the memory location to store the generated signature, can be a null pointer.
 * \param[out]    VSM_s_ECU_Certificate             Pointer to the memory location to store the VSM certificate, can be a null pointer.
 * \param[in,out] DataLength                        In: Length in bytes of Target_ECU_Certificate, Out: Length in bytes of VSM_s_ECU_Certificate, can be a null pointer.
 * \param[out]    ErrorCode                         Negative response code to be sent by DCM if return value is E_NOT_OK.
 * \param[in]     allowStandardSecret               Set to TRUE to allow the standard secret as car-specific secret.
 * \return        E_OK                              Request successful.
 *                E_NOT_OK                          Request failed.
 *                SSA_E_PENDING                     Requested service is pending.
 * \pre           Verification_Result and ErrorCode must be valid pointers.
 * \context       TASK
 * \reentrant     FALSE
 * \synchronous   FALSE
 */
SSA_KEYM_LOCAL FUNC(Std_ReturnType, Ssa_KeyM_CODE) KeyM_EcuSharedSecretEncryption_HandleStateVerifySignature(
  uint8 chainOfTrust,
  P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) Nonce,
  P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) Ephemeral_ECU_Public_Key,
  P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) Data_Signature_In,
  P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) Target_ECU_Certificate,
  Dcm_OpStatusType OpStatus,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) routineInfo,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) Verification_Result,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) Date_and_Time,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) Tick_Count,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) Tick_Count_Offset,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) Encrypted_Nonce_and_Shared_Secret,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) Ephemeral_VSM_Public_Key,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) Data_Signature_Out,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) VSM_s_ECU_Certificate,
  P2VAR(uint16, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) DataLength,
  P2VAR(Dcm_NegativeResponseCodeType, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) ErrorCode,
  boolean allowStandardSecret);

/**********************************************************************************************************************
 *  KeyM_EcuSharedSecretEncryption_HandleStateGenCarSpecificSecret()
 *********************************************************************************************************************/
/*!
 * \brief         State handler function for the states
 *                - KEYM_ENCRYPTSHAREDSECRET_STATE_GEN_CAR_SPEC_SECRET
 *                of function KeyM_EncryptSharedSecret.
 * \details       It generates a random number to be used as car-specific secret.
 * \param[in]     chainOfTrust                      The chain of trust to be used.
 * \param[in]     Nonce                             Pointer to the nonce.
 * \param[in]     Ephemeral_ECU_Public_Key          Pointer to the ephemeral ECU public key.
 * \param[in]     Data_Signature_In                 Pointer to the data signature.
 * \param[in]     Target_ECU_Certificate            Pointer to target ECU certificate, the ECU obtaining the encrypted secret.
 * \param[in]     OpStatus                          Current operation status.
 * \param[out]    routineInfo                       Execution status of the routine for positive responses, can be a null pointer.
 * \param[out]    Verification_Result               Positive Response Code of the routine, can be a null pointer.
 * \param[out]    Date_and_Time                     Pointer to the memory location to store date and time, can be a null pointer.
 * \param[out]    Tick_Count                        Pointer to the memory location to store the tick count, can be a null pointer.
 * \param[out]    Tick_Count_Offset                 Pointer to the memory location to store the tick count offset, can be a null pointer.
 * \param[out]    Encrypted_Nonce_and_Shared_Secret Pointer to the memory location to store the encrypted nonce and secret, can be a null pointer.
 * \param[out]    Ephemeral_VSM_Public_Key          Pointer to the memory location to store the ephemeral VSM public key, can be a null pointer.
 * \param[out]    Data_Signature_Out                Pointer to the memory location to store the generated signature, can be a null pointer.
 * \param[out]    VSM_s_ECU_Certificate             Pointer to the memory location to store the VSM certificate, can be a null pointer.
 * \param[in,out] DataLength                        In: Length in bytes of Target_ECU_Certificate, Out: Length in bytes of VSM_s_ECU_Certificate, can be a null pointer.
 * \param[out]    ErrorCode                         Negative response code to be sent by DCM if return value is E_NOT_OK.
 * \param[in]     allowStandardSecret               Set to TRUE to allow the standard secret as car-specific secret.
 * \return        E_OK                              Request successful.
 *                E_NOT_OK                          Request failed.
 *                SSA_E_PENDING                     Requested service is pending.
 * \pre           ErrorCode must be a valid pointer.
 * \context       TASK
 * \reentrant     FALSE
 * \synchronous   FALSE
 */
SSA_KEYM_LOCAL FUNC(Std_ReturnType, Ssa_KeyM_CODE) KeyM_EcuSharedSecretEncryption_HandleStateGenCarSpecificSecret(
  uint8 chainOfTrust,
  P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) Nonce,
  P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) Ephemeral_ECU_Public_Key,
  P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) Data_Signature_In,
  P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) Target_ECU_Certificate,
  Dcm_OpStatusType OpStatus,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) routineInfo,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) Verification_Result,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) Date_and_Time,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) Tick_Count,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) Tick_Count_Offset,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) Encrypted_Nonce_and_Shared_Secret,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) Ephemeral_VSM_Public_Key,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) Data_Signature_Out,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) VSM_s_ECU_Certificate,
  P2VAR(uint16, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) DataLength,
  P2VAR(Dcm_NegativeResponseCodeType, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) ErrorCode,
  boolean allowStandardSecret);

/**********************************************************************************************************************
 *  KeyM_EcuSharedSecretEncryption_HandleStateGenSecOcKeys()
 *********************************************************************************************************************/
/*!
 * \brief         State handler function for the states
 *                - KEYM_ENCRYPTSHAREDSECRET_STATE_IDLE
 *                - KEYM_ENCRYPTSHAREDSECRET_STATE_VERIFY_ECU_CERTIFICATE
 *                of function KeyM_EncryptSharedSecret.
 * \details       This function handles the states of function KeyM_EncryptSharedSecret
 *                as given by table KeyM_Shared_Secret_Encryption_State_Handler.
 *                It verifies the received certificates.
 * \param[in]     chainOfTrust                      The chain of trust to be used.
 * \param[in]     Nonce                             Pointer to the nonce.
 * \param[in]     Ephemeral_ECU_Public_Key          Pointer to the ephemeral ECU public key.
 * \param[in]     Data_Signature_In                 Pointer to the data signature.
 * \param[in]     Target_ECU_Certificate            Pointer to target ECU certificate, the ECU obtaining the encrypted secret.
 * \param[in]     OpStatus                          Current operation status.
 * \param[out]    routineInfo                       Execution status of the routine for positive responses, can be a null pointer.
 * \param[out]    Verification_Result               Positive Response Code of the routine, can be a null pointer.
 * \param[out]    Date_and_Time                     Pointer to the memory location to store date and time, can be a null pointer.
 * \param[out]    Tick_Count                        Pointer to the memory location to store the tick count, can be a null pointer.
 * \param[out]    Tick_Count_Offset                 Pointer to the memory location to store the tick count offset, can be a null pointer.
 * \param[out]    Encrypted_Nonce_and_Shared_Secret Pointer to the memory location to store the encrypted nonce and secret, can be a null pointer.
 * \param[out]    Ephemeral_VSM_Public_Key          Pointer to the memory location to store the ephemeral VSM public key, can be a null pointer.
 * \param[out]    Data_Signature_Out                Pointer to the memory location to store the generated signature, can be a null pointer.
 * \param[out]    VSM_s_ECU_Certificate             Pointer to the memory location to store the VSM certificate, can be a null pointer.
 * \param[in,out] DataLength                        In: Length in bytes of Target_ECU_Certificate, Out: Length in bytes of VSM_s_ECU_Certificate, can be a null pointer.
 * \param[out]    ErrorCode                         Negative response code to be sent by DCM if return value is E_NOT_OK.
 * \param[in]     allowStandardSecret               Set to TRUE to allow the standard secret as car-specific secret.
 * \return        E_OK                              Request successful.
 *                E_NOT_OK                          Request failed.
 *                SSA_E_PENDING                     Requested service is pending.
 * \pre           ErrorCode must be a valid pointer.
 * \context       TASK
 * \reentrant     FALSE
 * \synchronous   FALSE
 */
SSA_KEYM_LOCAL FUNC(Std_ReturnType, Ssa_KeyM_CODE) KeyM_EcuSharedSecretEncryption_HandleStateGenSecOcKeys(
  uint8 chainOfTrust,
  P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) Nonce,
  P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) Ephemeral_ECU_Public_Key,
  P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) Data_Signature_In,
  P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) Target_ECU_Certificate,
  Dcm_OpStatusType OpStatus,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) routineInfo,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) Verification_Result,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) Date_and_Time,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) Tick_Count,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) Tick_Count_Offset,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) Encrypted_Nonce_and_Shared_Secret,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) Ephemeral_VSM_Public_Key,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) Data_Signature_Out,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) VSM_s_ECU_Certificate,
  P2VAR(uint16, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) DataLength,
  P2VAR(Dcm_NegativeResponseCodeType, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) ErrorCode,
  boolean allowStandardSecret);

/**********************************************************************************************************************
 *  KeyM_EcuSharedSecretEncryption_HandleStateKeyExchangeEncrypt()
 *********************************************************************************************************************/
/*!
 * \brief         State handler function for the states
 *                - KEYM_ENCRYPTSHAREDSECRET_STATE_VERIFY_ECU_CERTIFICATE
 *                of function KeyM_EncryptSharedSecret.
 * \details       It derives the session key, encrypts the data and gets the current time information.
 * \param[in]     chainOfTrust                      The chain of trust to be used.
 * \param[in]     Nonce                             Pointer to the nonce.
 * \param[in]     Ephemeral_ECU_Public_Key          Pointer to the ephemeral ECU public key.
 * \param[in]     Data_Signature_In                 Pointer to the data signature.
 * \param[in]     Target_ECU_Certificate            Pointer to target ECU certificate, the ECU obtaining the encrypted secret.
 * \param[in]     OpStatus                          Current operation status.
 * \param[out]    routineInfo                       Execution status of the routine for positive responses, can be a null pointer.
 * \param[out]    Verification_Result               Positive Response Code of the routine, can be a null pointer.
 * \param[out]    Date_and_Time                     Pointer to the memory location to store date and time.
 * \param[out]    Tick_Count                        Pointer to the memory location to store the tick count.
 * \param[out]    Tick_Count_Offset                 Pointer to the memory location to store the tick count offset.
 * \param[out]    Encrypted_Nonce_and_Shared_Secret Pointer to the memory location to store the encrypted nonce and secret.
 * \param[out]    Ephemeral_VSM_Public_Key          Pointer to the memory location to store the ephemeral VSM public key.
 * \param[out]    Data_Signature_Out                Pointer to the memory location to store the generated signature, can be a null pointer.
 * \param[out]    VSM_s_ECU_Certificate             Pointer to the memory location to store the VSM certificate, can be a null pointer.
 * \param[in,out] DataLength                        In: Length in bytes of Target_ECU_Certificate, Out: Length in bytes of VSM_s_ECU_Certificate, can be a null pointer.
 * \param[out]    ErrorCode                         Negative response code to be sent by DCM if return value is E_NOT_OK.
 * \param[in]     allowStandardSecret               Set to TRUE to allow the standard secret as car-specific secret.
 * \return        E_OK                              Request successful.
 *                E_NOT_OK                          Request failed.
 *                SSA_E_PENDING                     Requested service is pending.
 * \pre           Date_and_Time must be a valid pointer referring a buffer of at least SSA_SIZEOF_REALTIME many bytes.
                  Tick_Count must be a valid pointer referring a buffer of at least SSA_SIZEOF_TICKCOUNT many bytes.
                  Tick_Count_Offset must be a valid pointer referring a buffer of at least SSA_SIZEOF_TICKCOUNT many bytes.
                  Encrypted_Nonce_and_Shared_Secret must be a valid pointer referring a buffer of at least SSA_SIZEOF_ENCRYPTED_NONCE_AND_SECRET many bytes.
                  Ephemeral_VSM_Public_Key must be a valid pointer referring a buffer of at least SSA_SIZEOF_PUBLICKEY many bytes.
                  ErrorCode must be a valid pointer.
 * \context       TASK
 * \reentrant     FALSE
 * \synchronous   FALSE
 */
SSA_KEYM_LOCAL FUNC(Std_ReturnType, Ssa_KeyM_CODE) KeyM_EcuSharedSecretEncryption_HandleStateKeyExchangeEncrypt(
  uint8 chainOfTrust,
  P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) Nonce,
  P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) Ephemeral_ECU_Public_Key,
  P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) Data_Signature_In,
  P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) Target_ECU_Certificate,
  Dcm_OpStatusType OpStatus,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) routineInfo,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) Verification_Result,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) Date_and_Time,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) Tick_Count,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) Tick_Count_Offset,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) Encrypted_Nonce_and_Shared_Secret,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) Ephemeral_VSM_Public_Key,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) Data_Signature_Out,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) VSM_s_ECU_Certificate,
  P2VAR(uint16, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) DataLength,
  P2VAR(Dcm_NegativeResponseCodeType, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) ErrorCode,
  boolean allowStandardSecret);

/**********************************************************************************************************************
 *  KeyM_EcuSharedSecretEncryption_HandleStateGenSignature()
 *********************************************************************************************************************/
/*!
 * \brief         State handler function for the states
 *                - KEYM_ENCRYPTSHAREDSECRET_STATE_VERIFY_ECU_CERTIFICATE
 *                of function KeyM_EncryptSharedSecret.
 * \details       It generates the signature of the encrypted data.
 * \param[in]     chainOfTrust                      The chain of trust to be used.
 * \param[in]     Nonce                             Pointer to the nonce.
 * \param[in]     Ephemeral_ECU_Public_Key          Pointer to the ephemeral ECU public key.
 * \param[in]     Data_Signature_In                 Pointer to the data signature.
 * \param[in]     Target_ECU_Certificate            Pointer to target ECU certificate, the ECU obtaining the encrypted secret.
 * \param[in]     OpStatus                          Current operation status.
 * \param[out]    routineInfo                       Execution status of the routine for positive responses, can be a null pointer.
 * \param[out]    Verification_Result               Positive Response Code of the routine, can be a null pointer.
 * \param[out]    Date_and_Time                     Pointer to the memory location to store date and time, can be a null pointer.
 * \param[out]    Tick_Count                        Pointer to the memory location to store the tick count, can be a null pointer.
 * \param[out]    Tick_Count_Offset                 Pointer to the memory location to store the tick count offset, can be a null pointer.
 * \param[out]    Encrypted_Nonce_and_Shared_Secret Pointer to the memory location to store the encrypted nonce and secret, can be a null pointer.
 * \param[out]    Ephemeral_VSM_Public_Key          Pointer to the memory location to store the ephemeral VSM public key, can be a null pointer.
 * \param[out]    Data_Signature_Out                Pointer to the memory location to store the generated signature.
 * \param[out]    VSM_s_ECU_Certificate             Pointer to the memory location to store the VSM certificate.
 * \param[in,out] DataLength                        In: Length in bytes of Target_ECU_Certificate, Out: Length in bytes of VSM_s_ECU_Certificate, can be a null pointer.
 * \param[out]    ErrorCode                         Negative response code to be sent by DCM if return value is E_NOT_OK.
 * \param[in]     allowStandardSecret               Set to TRUE to allow the standard secret as car-specific secret.
 * \return        E_OK                              Request successful.
 *                E_NOT_OK                          Request failed.
 *                SSA_E_PENDING                     Requested service is pending.
 * \pre           Data_Signature_Out must be a valid pointer referrencing a buffer of at least SSA_SIZEOF_SIGNATURE many bytes.
 *                VSM_s_ECU_Certificate must be a valid pointer referrencing a buffer of at least (SSA_SIZEOF_CERT_MAX + 2u)
 *                many bytes, if
 *                ((chainOfTrust != SSA_TRUST_MODEL_LIVE_KEY_PAIR) && (chainOfTrust != SSA_TRUST_MODEL_CSR_KEY_PAIR)).
 *                VSM_s_ECU_Certificate must be a valid pointer referrencing a buffer of at least sizeof(Dcm_Data3006ByteType)
 *                many bytes, if
 *                ((chainOfTrust == SSA_TRUST_MODEL_LIVE_KEY_PAIR) || (chainOfTrust == SSA_TRUST_MODEL_CSR_KEY_PAIR)).
 *                ErrorCode must be a valid pointer.
 * \context       TASK
 * \reentrant     FALSE
 * \synchronous   FALSE
 * \spec          requires $lengthOf(VSM_s_ECU_Certificate) >= sizeof(Dcm_Data1002ByteType);                   \endspec
 */
SSA_KEYM_LOCAL FUNC(Std_ReturnType, Ssa_KeyM_CODE) KeyM_EcuSharedSecretEncryption_HandleStateGenSignature(
  uint8 chainOfTrust,
  P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) Nonce,
  P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) Ephemeral_ECU_Public_Key,
  P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) Data_Signature_In,
  P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) Target_ECU_Certificate,
  Dcm_OpStatusType OpStatus,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) routineInfo,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) Verification_Result,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) Date_and_Time,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) Tick_Count,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) Tick_Count_Offset,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) Encrypted_Nonce_and_Shared_Secret,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) Ephemeral_VSM_Public_Key,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) Data_Signature_Out,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) VSM_s_ECU_Certificate,
  P2VAR(uint16, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) DataLength,
  P2VAR(Dcm_NegativeResponseCodeType, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) ErrorCode,
  boolean allowStandardSecret);

#else

/**********************************************************************************************************************
 *  KeyM_EcuSharedSecretDistribution_HandleStateIdle()
 *********************************************************************************************************************/
/*!
 * \brief       State handler function for the states
 *              - KEYM_ROUTINE_SECOC_ECU_SHARED_SECRET_DIST_STATE_IDLE
 *              of function Ssa_KeyM_RoutineServices_Trust_Model_SecOC_ECU_Shared_Secret_Distribution.
 * \details     It verifies the received certificates and gets the current nonce.
 * \param[in]   Date_and_Time_In                      The date and time the target ECU shall be set to.
 * \param[in]   Tick_Count_In                         The tick-count the target ECU shall be set to.
 * \param[in]   Tick_Count_Offset_In                  The tick-count offset the target ECU shall be set to.
 * \param[in]   Encrypted_Nonce_and_Shared_Secret_In  The encrypted nonce and car-specific secret to be decrypted by the target ECU.
 * \param[in]   Ephemeral_VSM_Public_Key_In           The ephemeral VSM public key.
 * \param[in]   Data_Signature_In                     The signature to be verified.
 * \param[in]   Certificates_In                       The VSM's certificates.
 * \param[in]   DataLength                            Length of Certificates_In.
 * \return      RTE_E_OK if routine and called sub routines could be successfully executed.
 *              RTE_E_RoutineServices_Trust_Model_SecOC_ECU_Shared_Secret_Distribution_E_NOT_OK if an error occurred.
 *              RTE_E_RoutineServices_Trust_Model_SecOC_ECU_Shared_Secret_Distribution_DCM_E_PENDING if requested service is pending.
 * \pre         -
 * \context     TASK
 * \reentrant   FALSE
 * \synchronous FALSE
 */
SSA_KEYM_LOCAL FUNC(Std_ReturnType, Ssa_KeyM_CODE) KeyM_EcuSharedSecretDistribution_HandleStateIdle(
  P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) Date_and_Time_In,
  P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) Tick_Count_In,
  P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) Tick_Count_Offset_In,
  P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) Encrypted_Nonce_and_Shared_Secret_In,
  P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) Ephemeral_VSM_Public_Key_In,
  P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) Data_Signature_In,
  P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) Certificates_In,
  uint16 DataLength);

/**********************************************************************************************************************
 *  KeyM_EcuSharedSecretDistribution_HandleStateVerifySignature()
 *********************************************************************************************************************/
/*!
 * \brief       State handler function for the states
 *              - KEYM_ROUTINE_SECOC_ECU_SHARED_SECRET_DIST_STATE_VERIFY_SIGNATURE
 *              of function Ssa_KeyM_RoutineServices_Trust_Model_SecOC_ECU_Shared_Secret_Distribution.
 * \details     It verifies the signatures over the input data.
 * \param[in]   Date_and_Time_In                      The date and time the target ECU shall be set to.
 * \param[in]   Tick_Count_In                         The tick-count the target ECU shall be set to.
 * \param[in]   Tick_Count_Offset_In                  The tick-count offset the target ECU shall be set to.
 * \param[in]   Encrypted_Nonce_and_Shared_Secret_In  The encrypted nonce and car-specific secret to be decrypted by the target ECU.
 * \param[in]   Ephemeral_VSM_Public_Key_In           The ephemeral VSM public key.
 * \param[in]   Data_Signature_In                     The signature to be verified.
 * \param[in]   Certificates_In                       The VSM's certificates.
 * \param[in]   DataLength                            Length of Certificates_In.
 * \return      RTE_E_OK if routine and called sub routines could be successfully executed.
 *              RTE_E_RoutineServices_Trust_Model_SecOC_ECU_Shared_Secret_Distribution_E_NOT_OK if an error occurred.
 *              RTE_E_RoutineServices_Trust_Model_SecOC_ECU_Shared_Secret_Distribution_DCM_E_PENDING if requested service is pending.
 * \pre         -
 * \context     TASK
 * \reentrant   FALSE
 * \synchronous FALSE
 */
SSA_KEYM_LOCAL FUNC(Std_ReturnType, Ssa_KeyM_CODE) KeyM_EcuSharedSecretDistribution_HandleStateVerifySignature(
  P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) Date_and_Time_In,
  P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) Tick_Count_In,
  P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) Tick_Count_Offset_In,
  P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) Encrypted_Nonce_and_Shared_Secret_In,
  P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) Ephemeral_VSM_Public_Key_In,
  P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) Data_Signature_In,
  P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) Certificates_In,
  uint16 DataLength);

/**********************************************************************************************************************
 *  KeyM_EcuSharedSecretDistribution_HandleStateKeyExchangeDecrypt()
 *********************************************************************************************************************/
/*!
 * \brief       State handler function for the states
 *              - KEYM_ROUTINE_SECOC_ECU_SHARED_SECRET_DIST_STATE_KEYEXCHANGE_DECRYPT
 *              of function Ssa_KeyM_RoutineServices_Trust_Model_SecOC_ECU_Shared_Secret_Distribution.
 * \details     It derives the session key and decrypts the data.
 * \param[in]   Date_and_Time_In                      The date and time the target ECU shall be set to.
 * \param[in]   Tick_Count_In                         The tick-count the target ECU shall be set to.
 * \param[in]   Tick_Count_Offset_In                  The tick-count offset the target ECU shall be set to.
 * \param[in]   Encrypted_Nonce_and_Shared_Secret_In  The encrypted nonce and car-specific secret to be decrypted by the target ECU.
 * \param[in]   Ephemeral_VSM_Public_Key_In           The ephemeral VSM public key.
 * \param[in]   Data_Signature_In                     The signature to be verified.
 * \param[in]   Certificates_In                       The VSM's certificates.
 * \param[in]   DataLength                            Length of Certificates_In.
 * \return      RTE_E_OK if routine and called sub routines could be successfully executed.
 *              RTE_E_RoutineServices_Trust_Model_SecOC_ECU_Shared_Secret_Distribution_E_NOT_OK if an error occurred.
 *              RTE_E_RoutineServices_Trust_Model_SecOC_ECU_Shared_Secret_Distribution_DCM_E_PENDING if requested service is pending.
 * \pre         -
 * \context     TASK
 * \reentrant   FALSE
 * \synchronous FALSE
 */
SSA_KEYM_LOCAL FUNC(Std_ReturnType, Ssa_KeyM_CODE) KeyM_EcuSharedSecretDistribution_HandleStateKeyExchangeDecrypt(
  P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) Date_and_Time_In,
  P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) Tick_Count_In,
  P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) Tick_Count_Offset_In,
  P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) Encrypted_Nonce_and_Shared_Secret_In,
  P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) Ephemeral_VSM_Public_Key_In,
  P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) Data_Signature_In,
  P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) Certificates_In,
  uint16 DataLength);

/**********************************************************************************************************************
 *  KeyM_EcuSharedSecretDistribution_HandleStateDeriveSecOcKeys()
 *********************************************************************************************************************/
/*!
 * \brief       State handler function for the states
 *              - KEYM_ROUTINE_SECOC_ECU_SHARED_SECRET_DIST_STATE_DERIVE_SECOC_KEYS
 *              - KEYM_ROUTINE_SECOC_ECU_SHARED_SECRET_DIST_STATE_WAIT_AND_SET_NEW_TIME
 *              of function Ssa_KeyM_RoutineServices_Trust_Model_SecOC_ECU_Shared_Secret_Distribution.
 * \details     It derives the SecOC keys and sets the time informations.
 * \param[in]   Date_and_Time_In                      The date and time the target ECU shall be set to.
 * \param[in]   Tick_Count_In                         The tick-count the target ECU shall be set to.
 * \param[in]   Tick_Count_Offset_In                  The tick-count offset the target ECU shall be set to.
 * \param[in]   Encrypted_Nonce_and_Shared_Secret_In  The encrypted nonce and car-specific secret to be decrypted by the target ECU.
 * \param[in]   Ephemeral_VSM_Public_Key_In           The ephemeral VSM public key.
 * \param[in]   Data_Signature_In                     The signature to be verified.
 * \param[in]   Certificates_In                       The VSM's certificates.
 * \param[in]   DataLength                            Length of Certificates_In.
 * \return      RTE_E_OK if routine and called sub routines could be successfully executed.
 *              RTE_E_RoutineServices_Trust_Model_SecOC_ECU_Shared_Secret_Distribution_E_NOT_OK if an error occurred.
 *              RTE_E_RoutineServices_Trust_Model_SecOC_ECU_Shared_Secret_Distribution_DCM_E_PENDING if requested service is pending.
 * \pre         -
 * \context     TASK
 * \reentrant   FALSE
 * \synchronous FALSE
 */
SSA_KEYM_LOCAL FUNC(Std_ReturnType, Ssa_KeyM_CODE) KeyM_EcuSharedSecretDistribution_HandleStateDeriveSecOcKeys(
  P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) Date_and_Time_In,
  P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) Tick_Count_In,
  P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) Tick_Count_Offset_In,
  P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) Encrypted_Nonce_and_Shared_Secret_In,
  P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) Ephemeral_VSM_Public_Key_In,
  P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) Data_Signature_In,
  P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) Certificates_In,
  uint16 DataLength);

/**********************************************************************************************************************
 *  KeyM_EcuSharedSecretDistribution_HandleStateDestroyNonce()
 *********************************************************************************************************************/
/*!
 * \brief       State handler function for the states
 *              - KEYM_ROUTINE_SECOC_ECU_SHARED_SECRET_DIST_STATE_DESTROY_NONCE
 *              - KEYM_ROUTINE_SECOC_ECU_SHARED_SECRET_DIST_STATE_DESTROY_NONCE_ERROR
 *              of function Ssa_KeyM_RoutineServices_Trust_Model_SecOC_ECU_Shared_Secret_Distribution.
 * \details     It destroys the nonce.
 * \param[in]   Date_and_Time_In                      The date and time the target ECU shall be set to.
 * \param[in]   Tick_Count_In                         The tick-count the target ECU shall be set to.
 * \param[in]   Tick_Count_Offset_In                  The tick-count offset the target ECU shall be set to.
 * \param[in]   Encrypted_Nonce_and_Shared_Secret_In  The encrypted nonce and car-specific secret to be decrypted by the target ECU.
 * \param[in]   Ephemeral_VSM_Public_Key_In           The ephemeral VSM public key.
 * \param[in]   Data_Signature_In                     The signature to be verified.
 * \param[in]   Certificates_In                       The VSM's certificates.
 * \param[in]   DataLength                            Length of Certificates_In.
 * \return      RTE_E_OK if routine and called sub routines could be successfully executed.
 *              RTE_E_RoutineServices_Trust_Model_SecOC_ECU_Shared_Secret_Distribution_E_NOT_OK if an error occurred.
 *              RTE_E_RoutineServices_Trust_Model_SecOC_ECU_Shared_Secret_Distribution_DCM_E_PENDING if requested service is pending.
 * \pre         -
 * \context     TASK
 * \reentrant   FALSE
 * \synchronous FALSE
 */
SSA_KEYM_LOCAL FUNC(Std_ReturnType, Ssa_KeyM_CODE) KeyM_EcuSharedSecretDistribution_HandleStateDestroyNonce(
  P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) Date_and_Time_In,
  P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) Tick_Count_In,
  P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) Tick_Count_Offset_In,
  P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) Encrypted_Nonce_and_Shared_Secret_In,
  P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) Ephemeral_VSM_Public_Key_In,
  P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) Data_Signature_In,
  P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) Certificates_In,
  uint16 DataLength);

#endif

/**********************************************************************************************************************
 *  KeyM_CopyValidEntry()
 *********************************************************************************************************************/
/*!
 * \brief       Read certificate entry for diagnostic chain.
 * \details     -
 * \param[in]   certBuf           Holds the certificate data.
 * \param[out]  targetDataBuf     Provided entry content.
 * \param[out]  targetLength      Length of entry content.
 * \param[in]   entry             Holds the certificate parse data.
 * \param[in]   dataLength        Holds the max buffer length.
 * \return      E_OK      Request passed.
 *              E_NOT_OK  Request failed.
 * \pre         All provided pointers must be valid.
 *              The buffer referenced by targetDataBuf must provide at least dataLength many bytes.
 * \context     TASK
 * \reentrant   FALSE
 * \synchronous FALSE
 * \spec        requires $lengthOf(targetDataBuf) >= dataLength;                                               \endspec
 */
SSA_KEYM_LOCAL FUNC(Std_ReturnType, Ssa_KeyM_CODE) KeyM_CopyValidEntry(
  P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) certBuf,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) targetDataBuf,
  P2VAR(uint16, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) targetLength,
  P2CONST(CertP_BerElementType, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) entry,
  uint32_least dataLength);

/**********************************************************************************************************************
 *  KeyM_GetEntry_SetVerification()
 *********************************************************************************************************************/
/*!
 * \brief       Map the result to a verification result.
 * \details     -
 * \param[in]   result                      Get entry result.
 * \param[out]  Verification_Result_Out     Positive Response Code of the routine.
 * \pre         Verification_Result_Out must be a valid pointer.
 * \context     TASK
 * \reentrant   FALSE
 * \synchronous FALSE
 */
SSA_KEYM_LOCAL FUNC(void, Ssa_KeyM_CODE) KeyM_GetEntry_SetVerification(
  Std_ReturnType result,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) Verification_Result_Out);

/**********************************************************************************************************************
 *  KeyM_GetCertEntry_DiagnosticChain_ReadEntry()
 *********************************************************************************************************************/
/*!
 * \brief           Read certificate entry for diagnostic chain.
 * \details         -
 * \param[in]       entryId                   Entry identification
 * \param[in,out]   Verification_Result_Out   Positive Response Code of the routine.
 * \param[out]      Certificate_Content_Out   Provided entry content.
 * \param[out]      DataLength                Length of entry content.
 * \param[in]       certBuf                    Holds the certificate data.
 * \param[in]       parsedCert                 Holds the certificate parse data.
 * \pre             All provided pointers must be valid.
 *                  certificate must be parsed. Verification_Result_Out is only modified in case of an error.
 *                  The buffer referenced by Certificate_Content_Out must provide at least 
 *                  SSA_KEYM_CERT_ENTRY_SIZEOF_ENTRY_BUFFER many bytes.
 * \context         TASK
 * \reentrant       FALSE
 * \synchronous     TRUE
 * \spec            requires $lengthOf(Certificate_Content_Out) >= sizeof(Dcm_Data64ByteType);                 \endspec
 */
SSA_KEYM_LOCAL_INLINE FUNC(void, Ssa_KeyM_CODE) KeyM_GetCertEntry_DiagnosticChain_ReadEntry(
  uint8 entryId,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) Verification_Result_Out,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) Certificate_Content_Out,
  P2VAR(uint16, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) DataLength,
  P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) certBuf,
  P2CONST(CertP_ParsedCertStructureType, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) parsedCert);

/**********************************************************************************************************************
 *  KeyM_GetCertEntry_IsIdValid()
 *********************************************************************************************************************/
/*!
 * \brief       Check if entry id is valid
 * \details     -
 * \param[in]   lowerInvalid        Lowest invalid identification (lowest valid identification - 1)
 * \param[in]   upperValid          Highest valid identification
 * \param[in]   id                  Current identification
 * \return      TRUE    Valid
 *              FALSE   Not Valid
 * \pre         -
 * \context     ANY
 * \reentrant   TRUE
 * \synchronous TRUE
 */
SSA_KEYM_LOCAL_INLINE FUNC(boolean, Ssa_KeyM_CODE) KeyM_GetCertEntry_IsIdValid(
  uint8 lowerInvalid,
  uint8 upperValid,
  uint8 id);

/**********************************************************************************************************************
 *  KeyM_GetCertEntry_DiagnosticChain()
 *********************************************************************************************************************/
/*!
 * \brief       Provide the requested certificate entry for diagnostic chain.
 * \details     -
 * \param[in]   Certificate_Identification_In   Certificate identification
 * \param[in]   In_Certificate_Entry_In         Entry identification
 * \param[out]  Verification_Result_Out         Positive Response Code of the routine.
 * \param[out]  Certificate_Content_Out         Provided entry content.
 * \param[out]  DataLength                      Length of entry content.
 * \pre         All provided pointers must be valid.
 *              The buffer referenced by Certificate_Content_Out must provide at least 
 *              SSA_KEYM_CERT_ENTRY_SIZEOF_ENTRY_BUFFER many bytes.
 * \context     TASK
 * \reentrant   FALSE
 * \synchronous TRUE
 * \spec        requires $lengthOf(Certificate_Content_Out) >= sizeof(Dcm_Data64ByteType);                     \endspec
 */
SSA_KEYM_LOCAL_INLINE FUNC(void, Ssa_KeyM_CODE) KeyM_GetCertEntry_DiagnosticChain(
  uint8 Certificate_Identification_In,
  uint8 In_Certificate_Entry_In,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) Verification_Result_Out,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) Certificate_Content_Out,
  P2VAR(uint16, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) DataLength);

/**********************************************************************************************************************
 *  KeyM_GetCertEntry_TrustModel()
 *********************************************************************************************************************/
/*!
 * \brief       Provide the requested certificate entry for trust model.
 * \details     -
 * \param[in]   Certificate_Identification_In   Certificate identification
 * \param[in]   In_Certificate_Entry_In         Entry identification
 * \param[out]  Verification_Result_Out         Positive Response Code of the routine.
 * \param[out]  Certificate_Content_Out         Provided entry content.
 * \param[out]  DataLength                      Length of entry content.
 * \param[out]  ErrorCode                       Negative response code to be sent by DCM if return value is E_NOT_OK.
 * \return      RTE_E_OK                                                        if routine could be successfully executed.
 *              RTE_E_RoutineServices_Get_Certificate_Entry_E_NOT_OK            if request failed.
 * \pre         Certificate_Identification_In must be in a valid range. (Trust Model Certificate)
 *              In_Certificate_Entry_In must be in a valid range.
 *              All provided pointers must be valid.
 *              The buffer referenced by Certificate_Content_Out must provide at least
 *              SSA_KEYM_CERT_ENTRY_SIZEOF_ENTRY_BUFFER many bytes.
 * \context     TASK
 * \reentrant   FALSE
 * \synchronous TRUE
 */
SSA_KEYM_LOCAL_INLINE FUNC(Std_ReturnType, Ssa_KeyM_CODE) KeyM_GetCertEntry_TrustModel(
  uint8 Certificate_Identification_In,
  uint8 In_Certificate_Entry_In,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) Verification_Result_Out,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) Certificate_Content_Out,
  P2VAR(uint16, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) DataLength,
  P2VAR(Dcm_NegativeResponseCodeType, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) ErrorCode);

#if ((SSA_ECU_TYPE != SSA_ECU_TYPE_VSM) && (SSA_DIAG_SERVICE_INJECT_SEED == STD_ON))

/**********************************************************************************************************************
 *  KeyM_InjectSeed_HandleStateIdle()
 *********************************************************************************************************************/
/*!
 * \brief       State handler function for the states
 *              - SSA_KEYM_ROUTINE_INJECT_SEED_STATE_IDLE
 *              of function Ssa_KeyM_RoutineServices_Inject_Seed.
 * \details     It gets the current ECU's nonce.
 * \param[in]   Ephemeral_Backend_Public_Key_In The ephemeral Backend public key.
 * \param[in]   Data_Signature_In               Signature over the encrypted seed and ephemeral key.
 * \param[in]   Encrypted_Seed_In               The encrypted seed data.
 * \param[in]   DataLength                      Length of encrypted seed stored in Encrypted_Seed_In.
 * \return      RTE_E_OK                                        if routine could be successfully executed.
 *              RTE_E_RoutineServices_Inject_Seed_E_NOT_OK      if request failed.
 *              RTE_E_RoutineServices_Inject_Seed_DCM_E_PENDING if request is pending.
 * \pre         -
 * \context     TASK
 * \reentrant   FALSE
 * \synchronous FALSE
 */
SSA_KEYM_LOCAL FUNC(Std_ReturnType, Ssa_KeyM_CODE) KeyM_InjectSeed_HandleStateIdle(
  P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) Ephemeral_Backend_Public_Key_In,
  P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) Data_Signature_In,
  P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) Encrypted_Seed_In,
  uint16 DataLength);

/**********************************************************************************************************************
 *  KeyM_InjectSeed_HandleStateVerifySignature()
 *********************************************************************************************************************/
/*!
 * \brief       State handler function for the states
 *              - SSA_KEYM_ROUTINE_INJECT_SEED_STATE_VERIFY_SIGNATURE
 *              of function Ssa_KeyM_RoutineServices_Inject_Seed.
 * \details     It verifies the signature.
 * \param[in]   Ephemeral_Backend_Public_Key_In The ephemeral Backend public key.
 * \param[in]   Data_Signature_In               Signature over the encrypted seed and ephemeral key.
 * \param[in]   Encrypted_Seed_In               The encrypted seed data.
 * \param[in]   DataLength                      Length of encrypted seed stored in Encrypted_Seed_In.
 * \return      RTE_E_OK                                        if routine could be successfully executed.
 *              RTE_E_RoutineServices_Inject_Seed_E_NOT_OK      if request failed.
 *              RTE_E_RoutineServices_Inject_Seed_DCM_E_PENDING if request is pending.
 * \pre         -
 * \context     TASK
 * \reentrant   FALSE
 * \synchronous FALSE
 */
SSA_KEYM_LOCAL FUNC(Std_ReturnType, Ssa_KeyM_CODE) KeyM_InjectSeed_HandleStateVerifySignature(
  P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) Ephemeral_Backend_Public_Key_In,
  P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) Data_Signature_In,
  P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) Encrypted_Seed_In,
  uint16 DataLength);

/**********************************************************************************************************************
 *  KeyM_InjectSeed_HandleStateKeyExchange()
 *********************************************************************************************************************/
/*!
 * \brief       State handler function for the states
 *              - SSA_KEYM_ROUTINE_INJECT_SEED_STATE_KEYEXCHANGE
 *              of function Ssa_KeyM_RoutineServices_Inject_Seed.
 * \details     It derives the session key from the ephemeral public key.
 * \param[in]   Ephemeral_Backend_Public_Key_In The ephemeral Backend public key.
 * \param[in]   Data_Signature_In               Signature over the encrypted seed and ephemeral key.
 * \param[in]   Encrypted_Seed_In               The encrypted seed data.
 * \param[in]   DataLength                      Length of encrypted seed stored in Encrypted_Seed_In.
 * \return      RTE_E_OK                                        if routine could be successfully executed.
 *              RTE_E_RoutineServices_Inject_Seed_E_NOT_OK      if request failed.
 *              RTE_E_RoutineServices_Inject_Seed_DCM_E_PENDING if request is pending.
 * \pre         -
 * \context     TASK
 * \reentrant   FALSE
 * \synchronous FALSE
 */
SSA_KEYM_LOCAL FUNC(Std_ReturnType, Ssa_KeyM_CODE) KeyM_InjectSeed_HandleStateKeyExchange(
  P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) Ephemeral_Backend_Public_Key_In,
  P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) Data_Signature_In,
  P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) Encrypted_Seed_In,
  uint16 DataLength);

/**********************************************************************************************************************
 *  KeyM_InjectSeed_HandleStateDecrypt()
 *********************************************************************************************************************/
/*!
 * \brief       State handler function for the states
 *              - SSA_KEYM_ROUTINE_INJECT_SEED_STATE_DECRYPT
 *              of function Ssa_KeyM_RoutineServices_Inject_Seed.
 * \details     It decrypts the encrypted data and verifies the decrypted nonce.
 * \param[in]   Ephemeral_Backend_Public_Key_In The ephemeral Backend public key.
 * \param[in]   Data_Signature_In               Signature over the encrypted seed and ephemeral key.
 * \param[in]   Encrypted_Seed_In               The encrypted seed data.
 * \param[in]   DataLength                      Length of encrypted seed stored in Encrypted_Seed_In.
 * \return      RTE_E_OK                                        if routine could be successfully executed.
 *              RTE_E_RoutineServices_Inject_Seed_E_NOT_OK      if request failed.
 *              RTE_E_RoutineServices_Inject_Seed_DCM_E_PENDING if request is pending.
 * \pre         -
 * \context     TASK
 * \reentrant   FALSE
 * \synchronous FALSE
 */
SSA_KEYM_LOCAL FUNC(Std_ReturnType, Ssa_KeyM_CODE) KeyM_InjectSeed_HandleStateDecrypt(
  P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) Ephemeral_Backend_Public_Key_In,
  P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) Data_Signature_In,
  P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) Encrypted_Seed_In,
  uint16 DataLength);

/**********************************************************************************************************************
 *  Ssa_KeyM_InjectSeed_HandleStateSeedRng()
 *********************************************************************************************************************/
/*!
 * \brief       State handler function for the states
 *              - SSA_KEYM_ROUTINE_INJECT_SEED_STATE_SEED_RNG
 *              of function Ssa_KeyM_RoutineServices_Inject_Seed.
 * \details     It seeds the RNG.
 * \param[in]   Ephemeral_Backend_Public_Key_In The ephemeral Backend public key.
 * \param[in]   Data_Signature_In               Signature over the encrypted seed and ephemeral key.
 * \param[in]   Encrypted_Seed_In               The encrypted seed data.
 * \param[in]   DataLength                      Length of encrypted seed stored in Encrypted_Seed_In.
 * \return      RTE_E_OK                                        if routine could be successfully executed.
 *              RTE_E_RoutineServices_Inject_Seed_E_NOT_OK      if request failed.
 *              RTE_E_RoutineServices_Inject_Seed_DCM_E_PENDING if request is pending.
 * \pre         -
 * \context     TASK
 * \reentrant   FALSE
 * \synchronous FALSE
 */
SSA_KEYM_LOCAL FUNC(Std_ReturnType, Ssa_KeyM_CODE) Ssa_KeyM_InjectSeed_HandleStateSeedRng(
  P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) Ephemeral_Backend_Public_Key_In,
  P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) Data_Signature_In,
  P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) Encrypted_Seed_In,
  uint16 DataLength);

/**********************************************************************************************************************
 *  KeyM_InjectSeed_HandleStateDestroyNonce()
 *********************************************************************************************************************/
/*!
 * \brief       State handler function for the states
 *              - SSA_KEYM_ROUTINE_INJECT_SEED_STATE_DESTROY_NONCE
 *              of function Ssa_KeyM_RoutineServices_Inject_Seed.
 * \details     It destroys the nonce.
 * \param[in]   Ephemeral_Backend_Public_Key_In The ephemeral Backend public key.
 * \param[in]   Data_Signature_In               Signature over the encrypted seed and ephemeral key.
 * \param[in]   Encrypted_Seed_In               The encrypted seed data.
 * \param[in]   DataLength                      Length of encrypted seed stored in Encrypted_Seed_In.
 * \return      RTE_E_OK                                        if routine could be successfully executed.
 *              RTE_E_RoutineServices_Inject_Seed_E_NOT_OK      if request failed.
 *              RTE_E_RoutineServices_Inject_Seed_DCM_E_PENDING if request is pending.
 * \pre         -
 * \context     TASK
 * \reentrant   FALSE
 * \synchronous FALSE
 */
SSA_KEYM_LOCAL FUNC(Std_ReturnType, Ssa_KeyM_CODE) KeyM_InjectSeed_HandleStateDestroyNonce(
  P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) Ephemeral_Backend_Public_Key_In,
  P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) Data_Signature_In,
  P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) Encrypted_Seed_In,
  uint16 DataLength);

/**********************************************************************************************************************
 *  KeyM_InjectSeed_HandleStateStorePermanently()
 *********************************************************************************************************************/
/*!
 * \brief       State handler function for the states
 *              - SSA_KEYM_ROUTINE_INJECT_SEED_STATE_STORE_INIT,
 *              - SSA_KEYM_ROUTINE_INJECT_SEED_STATE_STORE_PENDING
 *              of function Ssa_KeyM_RoutineServices_Inject_Seed.
 * \details     It triggers the application callback for storing the RNG seed state permanently.
 * \param[in]   Ephemeral_Backend_Public_Key_In The ephemeral Backend public key.
 * \param[in]   Data_Signature_In               Signature over the encrypted seed and ephemeral key.
 * \param[in]   Encrypted_Seed_In               The encrypted seed data.
 * \param[in]   DataLength                      Length of encrypted seed stored in Encrypted_Seed_In.
 * \return      RTE_E_OK                                        if routine could be successfully executed.
 *              RTE_E_RoutineServices_Inject_Seed_E_NOT_OK      if request failed.
 *              RTE_E_RoutineServices_Inject_Seed_DCM_E_PENDING if request is pending.
 * \pre         -
 * \context     TASK
 * \reentrant   FALSE
 * \synchronous FALSE
 */
SSA_KEYM_LOCAL FUNC(Std_ReturnType, Ssa_KeyM_CODE) KeyM_InjectSeed_HandleStateStorePermanently(
  P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) Ephemeral_Backend_Public_Key_In,
  P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) Data_Signature_In,
  P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) Encrypted_Seed_In,
  uint16 DataLength);

#endif

/**********************************************************************************************************************
 *  KeyM_GetNumBytesNeededForDerEncoding()
 *********************************************************************************************************************/
/*!
 * \brief       Gets the number of bytes that are needed to DER encode data into a TLV triplet
 * \details     -
 * \param[in]   lenIn The length of the data filed to be encoded
 * \return      The number of bytes needed.
 * \pre         -
 * \context     ANY
 * \reentrant   TRUE
 * \synchronous TRUE
 */
SSA_KEYM_LOCAL FUNC(uint16, Ssa_KeyM_CODE) KeyM_GetNumBytesNeededForDerEncoding(
  uint16 lenIn);

/**********************************************************************************************************************
 *  KeyM_GetNumBytesNeededForEncodingUniqueEcuIds()
 *********************************************************************************************************************/
/*!
 * \brief       Gets the number of bytes needed to DER encode the configured UniqueEcuIds as UTF8Strings into a SET
 *              and then into an OCTET STRING.
 * \details     -
 * \param[out]  sizeOctetString  Length of the OCTET STING TLV
 * \param[out]  sizeSet          Length of the SET TLV
 * \return      E_NOT_OK         The length of a unique ECU ID exceeds SSA_MAX_SIZEOF_UNIQUEECUID (30) bytes.
 *              E_OK             sizeSet and sizeOctetString computed successfully.
 * \pre         ALl provided pointers must be valid.
 * \context     ANY
 * \reentrant   TRUE
 * \synchronous TRUE
 */
SSA_KEYM_LOCAL FUNC(Std_ReturnType, Ssa_KeyM_CODE) KeyM_GetNumBytesNeededForEncodingUniqueEcuIds(
  P2VAR(uint16, AUTOMATIC, AUTOMATIC) sizeOctetString,
  P2VAR(uint16, AUTOMATIC, AUTOMATIC) sizeSet);

/**********************************************************************************************************************
 *  KeyM_PrepareDerEncodingElement()
 *********************************************************************************************************************/
/*!
 * \brief         Prepares tag and length of the TLV triplet based on given tag and length.
 * \details       -
 * \param[in,out] buffer      Buffer for the encoded data
 * \param[in,out] bufferIndex Index used to fill in tag and length, updated with each call
 * \param[in]     bufferLen   Length of buffer
 * \param[in]     tag         Tag to be encoded
 * \param[in]     lenIn       Length to be encoded
 * \pre           Use as bufferIndex the output from previous call of this function.
 *                All provided pointers must be valid.
 * \context       ANY
 * \reentrant     FALSE
 * \synchronous   TRUE
 * \spec          requires $lengthOf(buffer) >= bufferLen;                                                     \endspec
 */
SSA_KEYM_LOCAL FUNC(void, Ssa_KeyM_CODE) KeyM_PrepareDerEncodingElement(
  P2VAR(uint8, AUTOMATIC, AUTOMATIC) buffer,
  P2VAR(uint16, AUTOMATIC, AUTOMATIC) bufferIndex,
  uint16 bufferLen,
  uint8 tag,
  uint16 lenIn);

/**********************************************************************************************************************
 *  KeyM_EncodeUniqueEcuIds()
 *********************************************************************************************************************/
/*!
 * \brief         DER encodes the configured UniqueEciIds as need for calling the AsrKeyM API KeyM_CsrElementSet.
 * \details       -
 * \param[out]    buffer    Buffer for the encoded data
 * \param[in,out] bufferLen IN: Length of buffer; OUT: Length of encoded data.
 * \return        E_NOT_OK  Unique ECU IDs not encoded, (at least) one ECU ID length exceeds SSA_MAX_SIZEOF_UNIQUEECUID
                            (30) bytes.
 *                E_OK      Unique ECU IDs encoded successfully.
 * \pre           All provided pointers must be valid.
 *                The buffer referenced by buffer must provide at least *bufferLen many bytes.
 * \context       ANY
 * \reentrant     TRUE
 * \synchronous   TRUE
 * \spec          requires buffer != NULL_PTR;
 *                requires bufferLen != NULL_PTR;
 *                requires $lengthOf(buffer) >= *bufferLen;                                                    \endspec
 */
SSA_KEYM_LOCAL FUNC(Std_ReturnType, Ssa_KeyM_CODE) KeyM_EncodeUniqueEcuIds(
  P2VAR(uint8, AUTOMATIC, AUTOMATIC) buffer,
  P2VAR(uint16, AUTOMATIC, AUTOMATIC) bufferLen);

/**********************************************************************************************************************
 *  KeyM_TrustModel_CopyCsrKey()
 *********************************************************************************************************************/
/*!
 * \brief         Copy staging key to Csr and set valid.
 * \details       -
 * \return        E_OK      Keys copied and valid
 *                E_NOT_OK  Operation failed
 * \pre           -
 * \context       ANY
 * \reentrant     FALSE
 * \synchronous   TRUE
 */
SSA_KEYM_LOCAL FUNC(Std_ReturnType, Ssa_KeyM_CODE) KeyM_TrustModel_CopyCsrKey(void);

/**********************************************************************************************************************
 *  KeyM_TrustModel_VerifyPrivateKeyAndInitCsr()
 *********************************************************************************************************************/
/*!
 * \brief       Verify that the staging private and public key are a valid key pair and if so, start generating a CSR
 *              based on the staging key pair
 * \details     After its successful creation, the CSR is stored in KeyM_DiagProc.serviceResponseBuffer and
 *              KeyM_DiagProc.serviceResponseBufferLength.
 * \return      E_OK if no error occurred.
 *              E_NOT_OK if an error occurred.
 *              SSA_E_PENDING if the CSR creation is still in process. The completion of CSR creation is indicated by
 *                            the flag KeyM_DiagProc.serviceResponseCallbackOccurred.
 * \pre         -
 * \context     TASK
 * \reentrant   FALSE
 * \synchronous FALSE
 */
SSA_KEYM_LOCAL FUNC(Std_ReturnType, Ssa_KeyM_CODE) KeyM_TrustModel_VerifyPrivateKeyAndInitCsr(void);

/**********************************************************************************************************************
 *  KeyM_TrustModel_InitCsr()
 *********************************************************************************************************************/
/*!
 * \brief       Start generating a CSR based on the staging key pair.
 * \details     After its successful creation, the CSR is stored in KeyM_DiagProc.serviceResponseBuffer and
 *              KeyM_DiagProc.serviceResponseBufferLength.
 * \return      E_OK if no error occurred.
 *              E_NOT_OK if an error occurred.
 *              SSA_E_PENDING if the CSR creation is still in process. The completion of CSR creation is indicated by
 *                            the flag KeyM_DiagProc.serviceResponseCallbackOccurred.
 * \pre         -
 * \context     TASK
 * \reentrant   FALSE
 * \synchronous FALSE
 */
SSA_KEYM_LOCAL FUNC(Std_ReturnType, Ssa_KeyM_CODE) KeyM_TrustModel_InitCsr(void);

/**********************************************************************************************************************
 *  KeyM_EvalPeerTrustModelChain()
 *********************************************************************************************************************/
/*!
 * \brief       Checks the verification result of the peer Trust Model certificate chain.
 * \details     This function checks the verification result of the peer Trust Model certificate chain.
 * \param[in]   verifResultIn   Verification result indicated by AsrKeyM.
 * \param[out]  verifResultOut  Mapped verification result.
 * \return      TRUE  Verification passed.
 *              FALSE Verification failed.
 * \pre         verifResultOut must be a valid pointer.
 * \context     TASK
 * \reentrant   FALSE
 * \synchronous FALSE
 */
SSA_KEYM_LOCAL FUNC(boolean, Ssa_KeyM_CODE) KeyM_EvalPeerTrustModelChain(
  uint8 verifResultIn,
  P2VAR(uint8, AUTOMATIC, AUTOMATIC) verifResultOut);

/**********************************************************************************************************************
 *  KeyM_SharedSecretDistribution_MapCertificateStatusToVerificationResult()
 *********************************************************************************************************************/
/*!
 * \brief       Maps the KeyM certificate status to the verification result.
 * \details     Mapping is valid for the shared secret distribution routine.
 * \param[in]   certId                Certificate Id of the certificate under investigation.
 * \param[in]   certificate status    KeyM certificate status.
 * \param[out]  verifResultOut        Mapped verification result.
 * \pre         All provided pointers must be valid.
 * \context     TASK
 * \reentrant   TRUE
 * \synchronous TRUE
 */
SSA_KEYM_LOCAL FUNC(void, Ssa_KeyM_CODE) KeyM_SharedSecretDistribution_MapCertificateStatusToVerificationResult(
  CONST(KeyM_CertificateIdType, AUTOMATIC) certId,
  CONST(KeyM_CertificateStatusType, AUTOMATIC) certificateStatus,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) verifResultOut);

/**********************************************************************************************************************
 *  KeyM_KeyM_GetCertificate()
 *********************************************************************************************************************/
/*!
 * \brief       Gets certificate data from AsrKeyM via Ssa_Cdd.
 * \details     -
 * \param[in]   CertId              The certificate identifier.
 * \param[out]  CertificateDataPtr  Pointer to data structure where certificate data and length shall be written to.
 * \return      See the description of Ssa_Cdd_KeyM_GetCertificate().
 * \pre         CertificateDataPtr must be a valid pointer.
 * \context     TASK
 * \reentrant   TRUE
 * \synchronous TRUE
 */
SSA_KEYM_LOCAL FUNC(Std_ReturnType, Ssa_KeyM_CODE) KeyM_KeyM_GetCertificate(
KeyM_CertificateIdType CertId,
P2VAR(Ssa_KeyM_CertDataType, AUTOMATIC, AUTOMATIC) CertificateDataPtr);

/**********************************************************************************************************************
 *  KeyM_KeyM_SetCertificate()
 *********************************************************************************************************************/
/*!
 * \brief       Sets certificate data from AsrKeyM via Ssa_Cdd.
 * \details     -
 * \param[in]   CertId              The certificate identifier.
 * \param[in]   CertificateDataPtr  Pointer to data structure containing certificate data and length.
 * \return      See the description of Ssa_Cdd_KeyM_SetCertificate().
 * \pre         -
 * \context     TASK
 * \reentrant   TRUE
 * \synchronous TRUE
 */
SSA_KEYM_LOCAL FUNC(Std_ReturnType, Ssa_KeyM_CODE) KeyM_KeyM_SetCertificate(
KeyM_CertificateIdType CertId,
P2CONST(Ssa_KeyM_CertDataType, AUTOMATIC, AUTOMATIC) CertificateDataPtr);

/**********************************************************************************************************************
 *  KeyM_KeyM_CertGetStatus()
 *********************************************************************************************************************/
/*!
 * \brief       Get certificate status from AsrKeyM.
 * \details     -
 * \param[in]   CertId                    The certificate identifier.
 * \param[out]  Status                    The retrieved status.
 * \return      E_OK                      Certificate status available and provided.
 *              KEYM_E_PARAMETER_MISMATCH Certificate identifier is invalid.
 * \pre         Status must be a valid pointer.
 * \context     TASK
 * \reentrant   TRUE
 * \synchronous TRUE
 */
SSA_KEYM_LOCAL FUNC(Std_ReturnType, Ssa_KeyM_CODE) KeyM_KeyM_CertGetStatus(
  KeyM_CertificateIdType CertId,
  P2VAR(KeyM_CertificateStatusType, AUTOMATIC, AUTOMATIC) Status);

/**********************************************************************************************************************
 *  KeyM_IsUniqueEcuIdFieldEqual()
 *********************************************************************************************************************/
/*!
 * \brief       Checks if uniqueECUID field filled into the ECU CSR Body is equal to the uniqueECUID field of
 *              the Trust Model ECU Certificate.
 * \details     -
 * \return      TRUE  is equal
 *              FALSE is not equal
 * \pre         Trust Model ECU Certificate has been parsed successfully-
 * \context     TASK
 * \reentrant   FALSE
 * \synchronous TRUE
 */
SSA_KEYM_LOCAL FUNC(boolean, Ssa_KeyM_CODE) KeyM_IsUniqueEcuIdFieldEqual(void);

#if ((SSA_ECU_TYPE != SSA_ECU_TYPE_VSM) && (SSA_DIAG_SERVICE_INJECT_SEED == STD_ON))

/**********************************************************************************************************************
 *  KeyM_CsmRandomSeed()
 *********************************************************************************************************************/
/*!
 * \brief       Asynchronously calls the CSM random seed API function.
 * \details     -
 * \param[in]   seed           The seed data.
 * \param[in]   seedLength     Length of the seed data.
 * \return      E_OK           Request successful.
 *              E_NOT_OK       Request failed.
 *              SSA_E_PENDING  Request is pending.
 * \pre         -
 * \context     TASK
 * \reentrant   FALSE
 * \synchronous FALSE
 */
SSA_KEYM_LOCAL FUNC(Std_ReturnType, Ssa_KeyM_CODE) KeyM_CsmRandomSeed(
  P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) seed, uint32 seedLength);

#endif

/**********************************************************************************************************************
 *  KeyM_TrustModel_AdditionalVerificationOfCertEntries_CertificateChain()
 **********************************************************************************************************************/
/*!
 * \brief       Checks certificate entries that are not checked by the AsrKeyM for a chain of certificates.
 * \details     -
 * \param[in]   certIdBackend         KeyM certificate Id of the backend certificate to be checked.
 * \param[in]   certIdIntermediate    KeyM certificate Id of the intermediate certificate to be checked.
 * \param[in]   certIdEcu             KeyM certificate Id of the ecu certificate to be checked.
 * \param[out]  certIdInvalidCert     KeyM certificate Id of the first certificate for which the verification failed.
 * \param[out]  certificateStatus     KeyM certificate status for the certificate for which the verification failed.
 * \return      E_OK                  Check was successful.
 *              E_NOT_OK              Check failed.
 * \pre         All provided pointers must be valid.
 * \context     TASK
 * \reentrant   FALSE
 * \synchronous TRUE
 */
SSA_KEYM_LOCAL FUNC(Std_ReturnType, Ssa_KeyM_CODE) KeyM_TrustModel_AdditionalVerificationOfCertEntries_CertificateChain(
  CONST(KeyM_CertificateIdType, AUTOMATIC) certIdBackend,
  CONST(KeyM_CertificateIdType, AUTOMATIC) certIdIntermediate,
  CONST(KeyM_CertificateIdType, AUTOMATIC) certIdEcu,
  P2VAR(KeyM_CertificateIdType, AUTOMATIC, AUTOMATIC) certIdInvalidCert,
  P2VAR(KeyM_CertificateStatusType, AUTOMATIC, AUTOMATIC) certificateStatus);

/**********************************************************************************************************************
*  KeyM_TrustModel_AdditionalVerificationOfCertificateEntries_StateHandling_Chain()
**********************************************************************************************************************/
/*!
* \brief       Handles the result of the verification of a single certificate within the certificate chain.
* \details     -
* \param[in]   retVal                Return value after checking a single certificate of the certificate chain.
* \param[in]   certStatus            KeyM certificate status after checking a certificate.
* \param[in]   checkedCertId         The Id of the certificate that has been checked.
* \param[out]  invalidCertId         KeyM certificate Id of the certificate, which has to be set if the verification failed.
* \return      E_OK                  Verification was successful.
*              E_NOT_OK              Verification failed.
* \pre         invalidCertId must be a valid pointer.
* \context     TASK
* \reentrant   TRUE
* \synchronous TRUE
*/
SSA_KEYM_LOCAL_INLINE FUNC(Std_ReturnType, Ssa_KeyM_CODE) KeyM_TrustModel_AdditionalVerificationOfCertificateEntries_StateHandling_Chain(
  Std_ReturnType retVal,
  KeyM_CertificateStatusType certStatus,
  KeyM_CertificateIdType checkedCertId,
  P2VAR(KeyM_CertificateIdType, AUTOMATIC, AUTOMATIC) invalidCertId);

/**********************************************************************************************************************
 *  KeyM_TrustModel_AdditionalVerificationOfCertificateEntries_SingleCertificate()
 **********************************************************************************************************************/
/*!
 * \brief       Checks certificate entries that are not checked by the AsrKeyM.
 * \details     -
 * \param[in]   certId         KeyM certificate Id of the certificate to be checked.
 * \param[in]   issuerCertId   KeyM certificate Id of the issuer certificate of certId.
 * \param[out]  certStatus     KeyM certificate status of the certificate to be checked.
 * \return      E_OK           Check was successful.
 *              E_NOT_OK       Check failed.
 * \pre         certStatus must be a valid pointer.
 * \context     TASK
 * \reentrant   FALSE
 * \synchronous TRUE
 */
SSA_KEYM_LOCAL FUNC(Std_ReturnType, Ssa_KeyM_CODE) KeyM_TrustModel_AdditionalVerificationOfCertificateEntries_SingleCertificate(
  CONST(KeyM_CertificateIdType, AUTOMATIC) certId,
  CONST(KeyM_CertificateIdType, AUTOMATIC) issuerCertId,
  P2VAR(KeyM_CertificateStatusType, AUTOMATIC, AUTOMATIC) certStatus);

/**********************************************************************************************************************
*  KeyM_TrustModel_AdditionalVerificationOfCertificateEntries_StateHandling_CertEntry()
**********************************************************************************************************************/
/*!
* \brief       Handles the result of the verification of a single certificate entry.
* \details     -
* \param[in]   retVal                Return value after checking a single certificate entry
* \param[in]   certStatus            KeyM certificate status after checking a single certificate entry.
* \param[in]   nextElementState      The next certificate element state.
* \param[out]  certElementState    The next certificate element to be checked.
* \param[out]  stopVerificationFlag  Flag indicating if the verification has to be aborted.
* \pre         elementToBeChecked must be a valid pointer.
*              stopVerificationFlag must be a valid pointer.
* \context     TASK
* \reentrant   FALSE
* \synchronous TRUE
*/
SSA_KEYM_LOCAL_INLINE FUNC(void, Ssa_KeyM_CODE) KeyM_TrustModel_AdditionalVerificationOfCertificateEntries_StateHandling_CertEntry(
  Std_ReturnType retVal,
  KeyM_CertificateStatusType certStatus,
  uint8 nextCertElement,
  P2VAR(uint8, AUTOMATIC, AUTOMATIC) certElementState,
  P2VAR(boolean, AUTOMATIC, AUTOMATIC) stopVerificationFlag);

/**********************************************************************************************************************
 *  KeyM_MapInternalCertIdToListIndex()
 **********************************************************************************************************************/
/*!
 * \brief       Maps internal Certificate Id to List Index for accessing getEntry functions.
 * \details     -
 * \param[in]   certId          KeyM certificate Id.
 * \param[out]  listIndex       Index for accessing certificate list.
 * \return      E_OK            Mapping was successful.
 *              E_NOT_OK        Mapping failed.
 * \pre         listIndex must be a valid pointer.
 * \context     TASK
 * \reentrant   FALSE
 * \synchronous TRUE
 */
SSA_KEYM_LOCAL_INLINE FUNC(Std_ReturnType, Ssa_KeyM_CODE) KeyM_MapInternalCertIdToListIndex(
  CONST(KeyM_CertificateIdType, AUTOMATIC) certId,
  P2VAR(uint8, AUTOMATIC, AUTOMATIC) listIndex);

/**********************************************************************************************************************
 *  KeyM_CheckCertificateVersion()
 **********************************************************************************************************************/
/*!
 * \brief       Check if the certificate version is as specified.
 * \details     This check is not valid for CSR-Certificates!
 * \param[in]   certIdx        Certificate Idx
 * \param[out]  certStatus     KeyM certificate status
 * \return      E_OK           Check was successfull.
 *              E_NOT_OK       Check failed.
 * \pre         certStatus must be a valid pointer.
 * \context     TASK
 * \reentrant   FALSE
 * \synchronous TRUE
 */
SSA_KEYM_LOCAL_INLINE FUNC(Std_ReturnType, Ssa_KeyM_CODE) KeyM_CheckCertificateVersion(
  CONST(uint8, AUTOMATIC) certIdx,
  P2VAR(KeyM_CertificateStatusType, AUTOMATIC, AUTOMATIC) certStatus);

/**********************************************************************************************************************
 *  KeyM_CheckCertificateBasicConstraints_DepthOfCertPath()
 **********************************************************************************************************************/
/*!
 * \brief       Check if the maximum depth of certification path in the basic constraints are as specified.
 * \details     -
 * \param[in]   certIdx        Certificate Idx
 * \param[out]  certStatus     KeyM certificate status
 * \return      E_OK           Check was successfull.
 *              E_NOT_OK       Check failed.
 * \pre         certStatus must be a valid pointer.
 * \context     TASK
 * \reentrant   FALSE
 * \synchronous TRUE
 */
SSA_KEYM_LOCAL_INLINE FUNC(Std_ReturnType, Ssa_KeyM_CODE) KeyM_CheckCertificateBasicConstraints_DepthOfCertPath(
  CONST(uint8, AUTOMATIC) certIdx,
  P2VAR(KeyM_CertificateStatusType, AUTOMATIC, AUTOMATIC) certStatus);

/**********************************************************************************************************************
 *  KeyM_CheckCertificateTime_ValidNotAfter()
 **********************************************************************************************************************/
/*!
 * \brief       Check if realTime is smaller than or equal to the time validNotAfter.
 * \details     -
 * \param[in]   certIdx        Certificate Idx
 * \param[out]  certStatus     KeyM certificate status
 * \return      E_OK           Check was successfull.
 *              E_NOT_OK       Check failed.
 * \pre         certStatus must be a valid pointer.
 * \context     TASK
 * \reentrant   FALSE
 * \synchronous TRUE
 */
SSA_KEYM_LOCAL_INLINE FUNC(Std_ReturnType, Ssa_KeyM_CODE) KeyM_CheckCertificateTime_ValidNotAfter(
  CONST(uint8, AUTOMATIC) certIdx,
  P2VAR(KeyM_CertificateStatusType, AUTOMATIC, AUTOMATIC) certStatus);

/**********************************************************************************************************************
 *  KeyM_CheckTrustModelKeyIds()
 **********************************************************************************************************************/
/*!
 * \brief       Compares the authorityKeyId of a certificate against the subjectKeyId of its issuing certificate.
 * \details     -
 * \param[in]   certIdxSubject  Certificate Idx of certificate to be checked.
 * \param[in]   certIdxIssuer   Certificate Idx of issuing certificate for certificate to be checked.
 * \param[out]  certStatus      KeyM certificate status
 * \return      E_OK            Check was successful.
 *              E_NOT_OK        Check failed.
 * \pre         certStatus must be a valid pointer.
 * \context     TASK
 * \reentrant   FALSE
 * \synchronous TRUE
 */
SSA_KEYM_LOCAL FUNC(Std_ReturnType, Ssa_KeyM_CODE) KeyM_CheckTrustModelKeyIds(
  CONST(uint8, AUTOMATIC) certIdxSubject,
  CONST(uint8, AUTOMATIC) certIdxIssuer,
  P2VAR(KeyM_CertificateStatusType, AUTOMATIC, AUTOMATIC) certStatus);

/**********************************************************************************************************************
 *  KeyM_SetCertificateStatusToNotAvailable()
 **********************************************************************************************************************/
/*!
 * \brief       Sets the certificate status to not available.
 * \details     -
 * \param[in]   certId          certificate Id
 * \pre         -
 * \context     TASK
 * \reentrant   FALSE
 * \synchronous TRUE
 */
SSA_KEYM_LOCAL FUNC(void, Ssa_KeyM_CODE) KeyM_SetCertificateStatusToNotAvailable(
  CONST(KeyM_CertificateIdType, AUTOMATIC) certId);

/**********************************************************************************************************************
 *  KeyM_LogTrustModelCertificateVerificationResult()
 **********************************************************************************************************************/
/*!
 * \brief       Logs the result of verification of a Trust Model certificate.
 * \details     -
 * \param[in]   certId              Certificate identifier
 * \param[in]   verificationResult  Verification result: 0 for successful verification, else unsuccessful verification.
 * \pre         -
 * \context     TASK
 * \reentrant   FALSE
 * \synchronous TRUE
 */
SSA_KEYM_LOCAL FUNC(void, Ssa_KeyM_CODE) KeyM_LogTrustModelCertificateVerificationResult(
  KeyM_CertificateIdType certId,
  uint8 verificationResult);

/**********************************************************************************************************************
 *  Ssa_KeyM_Certificate_SignDataWithEcuPrivateKey()
 **********************************************************************************************************************/
/*!
 * \brief       Signs passed data with the private Key of the ECU.
 * \details     -
 * \param[in]   data Holds the pointer to the memory location to be signed.
 * \param[in]   dataLength Length in bytes of memory location to be signed
 * \param[out]  signature Holds the pointer to the memory location where the signature shall be stored.
 *                        Must reference a buffer of at least SSA_SIZEOF_SIGNATURE many bytes.
 * \return      RTE_E_OK if signature was build
 *              RTE_E_KeyM_Certificate_E_NOT_OK otherwise.
 *              RTE_E_KeyM_Certificate_E_PENDING Requested service is pending. Try again with operation status Pending.
 * \pre         The buffer referenced by signature must provide at least SSA_SIZEOF_SIGNATURE many bytes.
 * \context     TASK
 * \reentrant   FALSE
 * \synchronous TRUE|FALSE
 * \spec        requires $lengthOf(signature) >= SSA_SIZEOF_SIGNATURE;                                         \endspec
 */
SSA_KEYM_LOCAL FUNC(Std_ReturnType, Ssa_KeyM_CODE) Ssa_KeyM_Certificate_SignDataWithEcuPrivateKey(
  P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) data,
  uint16 dataLength,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) signature);

/**********************************************************************************************************************
 * KeyM_MemClear()
 *********************************************************************************************************************/
/*!
 * \brief       Sets each byte of the target data buffer to 0.
 * \details     At most targetDataBufLength many bytes are cleared.
 * \param[out]  targetDataBuf        Memory address of the target data buffer.
 * \param[in]   targetDataBufLength  The length of targetDataBuf in bytes.
 * \param[in]   lengthToClear        The number of bytes of the target buffer that shall be cleared.
 * \pre         targetDataBuf must be a valid pointer and reference a buffer of at least targetDataBufLength
 *              many bytes.
 * \context     ANY
 * \reentrant   TRUE
 * \synchronous TRUE
 * \spec        requires targetDataBuf != NULL_PTR;
 *              requires $lengthOf(targetDataBuf) >= targetDataBufLength;                                       \endspec
 **********************************************************************************************************************/
SSA_KEYM_LOCAL FUNC(void, Ssa_KeyM_CODE) KeyM_MemClear(
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) targetDataBuf,
  uint16_least targetDataBufLength,
  uint16_least lengthToClear);

#define Ssa_KeyM_STOP_SEC_CODE
#include "Ssa_KeyM_MemMap.h" /* PRQA S 5087 */ /* MD_MSR_MemMap */

/**********************************************************************************************************************
 *  LOCAL CONST DATA
 **********************************************************************************************************************/
#define Ssa_KeyM_START_SEC_CONST_UNSPECIFIED
#include "Ssa_KeyM_MemMap.h" /* PRQA S 5087 */ /* MD_MSR_MemMap */

/*! The standard car-specific secret. */
/* Triple size is needed as dummy data. */
SSA_KEYM_LOCAL CONST(uint8, Ssa_KeyM_CONST) KeyM_StandardSharedSecret[SSA_SIZEOF_SECRET] = { 0x55, 0x77, 0x65, 0x4d, 0x61, 0x72, 0x74, 0x69, 0x6e, 0x4a, 0x75, 0x6c, 0x69, 0x61, 0x6e, 0x41, 0x6e, 0x64, 0x72, 0x65, 0x61, 0x73, 0x4d, 0x61, 0x72, 0x6b, 0x75, 0x73, 0x32, 0x30, 0x31, 0x36 }; /* PRQA S 3218 */ /* MD_SSA_OBJECT_AT_FILE_SCOPE */

/*! The CMAC input constant for Key CMACs. */
SSA_KEYM_LOCAL CONST(uint8, Ssa_KeyM_CONST) KeyM_Key_CMAC_Constant[SSA_KEYM_KEY_CMAC_SIZEOF_KEY_CMAC_CONSTANT] = { 0x4AU, 0x61U, 0x6EU, 0x2DU, 0x4EU, 0x69U, 0x63U, 0x6CU, 0x61U, 0x73U, 0x2DU, 0x4BU, 0x75U, 0x6EU, 0x7AU, 0x65U }; /* PRQA S 3218 */ /* MD_SSA_OBJECT_AT_FILE_SCOPE */

/*! Fragments of DER encoded key extensions used for creating the CSR. */
#if (SSA_ECU_TYPE == SSA_ECU_TYPE_VSM)
SSA_KEYM_LOCAL CONST(uint8, Ssa_KeyM_CONST) extensionSpecialEcu[] = { SSA_KEYM_CSR_EXT_SPECIALECU }; /* PRQA S 3218 */ /* MD_SSA_OBJECT_AT_FILE_SCOPE */
#endif

/*! Dummy buffer used for calling service certificate API for use case KEYM_SERVICE_CERT_REQUEST_CSR */
SSA_KEYM_LOCAL CONST(uint8, Ssa_KeyM_CONST) InitCsrRespBuffer[2] = { 0 }; /* PRQA S 3218 */ /* MD_SSA_OBJECT_AT_FILE_SCOPE */

/*! Compile-time assertion if KEYM_NO_RETVAL is defined as an invalid value. */
Ssa_CompileTimeAssert(KEYM_NO_RETVAL_COND1 && KEYM_NO_RETVAL_COND2 && KEYM_NO_RETVAL_COND3, InvalidNoRetValDefinition); /* PRQA S 3205, 3493 */ /* MD_SSA_COMPILE_TIME_ASSERTION */ /*lint !e506 */

/*! State handler functions for diagnostic routine Replace_Trust_model_Certificates. */
SSA_KEYM_LOCAL CONST(Ssa_StateHandlerFctPtrType_ReplaceTrustModelCertificates, Ssa_KeyM_CONST) KeyM_Replace_Trust_Model_Certificates_State_Handler[] =  /* PRQA S 3218 */ /* MD_SSA_OBJECT_AT_FILE_SCOPE */
{
  /* IDLE */ KeyM_ReplaceTrustModelCerts_HandleStateIdle,
  /* REQUESTING_SERVICE_CERT_BACKEND */ KeyM_ReplaceTrustModelCerts_HandleStateRequestingServiceCertBackend,
  /* AWAITING_VERIFICATION_RESULT_BACKEND_CERT */ KeyM_ReplaceTrustModelCerts_AwaitingVerificationResultBackendCert,
  /* AWAITING_VERIFICATION_RESULT_INTERMEDIATE_CERT */ KeyM_ReplaceTrustModelCerts_AwaitingVerificationResultIntermediateCert,
  /* AWAITING_PARSING_RESULT_ECU_CERT */ KeyM_ReplaceTrustModelCerts_AwaitingParsingResultEcuCert,
  /* REQUESTING_FOR_VERIFICATION_ECU_CERT */ KeyM_ReplaceTrustModelCerts_RequestingVerificationEcuCert,
  /* AWAITING_VERIFICATION_RESULT_ECU_CERT */ KeyM_ReplaceTrustModelCerts_AwaitingVerificationResultEcuCert,
  /* VERIFY_TRUST_MODEL_PRIVATE_KEY */ KeyM_ReplaceTrustModelCerts_VerifyingKey,
  /* STORE_INIT */ KeyM_ReplaceTrustModelCerts_Storing,
  /* STORE_PENDING */ KeyM_ReplaceTrustModelCerts_Storing,
  /* NVM_WRITE */ KeyM_ReplaceTrustModelCerts_WritingToNVM,
  /* NVM_WAIT */ KeyM_ReplaceTrustModelCerts_WritingToNVM
};

/*! State handler functions for diagnostic routine Replace_Trust_model_Root_Certificate. */
SSA_KEYM_LOCAL CONST(Ssa_StateHandlerFctPtrType_ReplaceTrustModelRootCertificate, Ssa_KeyM_CONST) KeyM_Replace_Trust_model_Root_Certificate_State_Handler[] =  /* PRQA S 3218 */ /* MD_SSA_OBJECT_AT_FILE_SCOPE */
{
  /* IDLE */ KeyM_ReplaceTrustModelRootCert_HandleStateIdleAndVerifyingEnhanceCert,
  /* VERIFYING_REPLACEMENT_PACKAGE_SUBKEYID */ KeyM_ReplaceTrustModelRootCert_HandleStateVerifyingReplacementPackageAndSubjectKeyId,
  /* STARTING_VERIFICATION_SIGNATURE_NEW_ROOT */ KeyM_ReplaceTrustModelRootCert_HandleStateVerifyingSignatureNewRoot,
  /* AWAITING_VERIF_RESULT_SIGNATURE_NEW_ROOT */ KeyM_ReplaceTrustModelRootCert_HandleStateVerifyingSignatureNewRoot,
  /* AWAITING_VERIF_RESULT_NEW_ROOT_CERT */ KeyM_ReplaceTrustModelRootCert_HandleStateAwaitingVerificationResultNewRootCertAndStoring,
  /* ROLLING_BACK_CERTIFICATE_DATA */ KeyM_ReplaceTrustModelRootCert_HandleStateAwaitingVerificationResultNewRootCertAndStoring,
  /* STORE_INIT */ KeyM_ReplaceTrustModelRootCert_HandleStateAwaitingVerificationResultNewRootCertAndStoring,
  /* STORE_PENDING */ KeyM_ReplaceTrustModelRootCert_HandleStateAwaitingVerificationResultNewRootCertAndStoring,
  /* NVM_WRITE */KeyM_ReplaceTrustModelRootCert_HandleStateWritingToNVM,
  /* NVM_WAIT */ KeyM_ReplaceTrustModelRootCert_HandleStateWritingToNVM
};

#if (SSA_DIAG_SERVICE_TRUST_MODEL_GENERATE_KEY_PAIR == STD_ON)

/*! State handler functions for diagnostic routine Replace_Trust_model_Root_Certificate. */
SSA_KEYM_LOCAL CONST(Ssa_StateHandlerFctPtrType_TrustModelGenerateKeyPair, Ssa_KeyM_CONST) KeyM_Trust_Model_Generate_Key_Pair_State_Handler[] =  /* PRQA S 3218 */ /* MD_SSA_OBJECT_AT_FILE_SCOPE */
{
  /* IDLE */ KeyM_TrustModelGenerateKeyPair_HandleStateIdle,
  /* GENERATING_KEY_PAIR */ KeyM_TrustModelGenerateKeyPair_HandleStateGeneratingKeyPair,
  /* VERIFYING_KEY_PAIR */ KeyM_TrustModelGenerateKeyPair_HandleStateVerifyingKeyPair,
  /* AWAITING_CSR */ KeyM_TrustModelGenerateKeyPair_HandleStateAwaitingCsr,
  /* CREATING_SIGNATURE */ KeyM_TrustModelGenerateKeyPair_HandleStateCreatingSignature
};

#endif

#if (SSA_ECU_TYPE == SSA_ECU_TYPE_VSM)

/*! State handler functions for function KeyM_EncryptSharedSecret called by diagnostic routines
 *  - Ssa_KeyM_RoutineServices_Routine_SecOC_ECU_Shared_Secret_Encryption,
 *  - Ssa_KeyM_RoutineServices_Routine_SecOC_ECU_TickCount_Synchronization,
 *  - Ssa_KeyM_RoutineServices_Trust_Model_SecOC_ECU_Shared_Secret_Encryption,
 *  - Ssa_KeyM_RoutineServices_Trust_Model_SecOC_ECU_TickCount_Synchronization. */
SSA_KEYM_LOCAL CONST(Ssa_StateHandlerFctPtrType_EcuSharedSecretEncryption, Ssa_KeyM_CONST) KeyM_Shared_Secret_Encryption_State_Handler[] =  /* PRQA S 3218 */ /* MD_SSA_OBJECT_AT_FILE_SCOPE */
{
  /* IDLE */ KeyM_EcuSharedSecretEncryption_HandleStateIdle,
  /* VERIFY_ECU_CERTIFICATE */ KeyM_EcuSharedSecretEncryption_HandleStateIdle,
  /* VERIFY_SIGNATURE */ KeyM_EcuSharedSecretEncryption_HandleStateVerifySignature,
  /* GEN_CAR_SPEC_SECRET */ KeyM_EcuSharedSecretEncryption_HandleStateGenCarSpecificSecret,
  /* DERIVE_SECOC_KEYS */ KeyM_EcuSharedSecretEncryption_HandleStateGenSecOcKeys,
  /* WAIT */ KeyM_EcuSharedSecretEncryption_HandleStateGenSecOcKeys,
  /* KEYEXCHANGE_ENCRYPT_GET_TIME */ KeyM_EcuSharedSecretEncryption_HandleStateKeyExchangeEncrypt,
  /* GEN_SIGNATURE */ KeyM_EcuSharedSecretEncryption_HandleStateGenSignature
};

#else

/*! State handler functions for diagnostic routine Trust_Model_SecOC_ECU_Shared_Secret_Distribution. */
SSA_KEYM_LOCAL CONST(Ssa_StateHandlerFctPtrType_EcuSharedSecretDistribution, Ssa_KeyM_CONST) KeyM_Shared_Secret_Distribution_State_Handler[] =  /* PRQA S 3218 */ /* MD_SSA_OBJECT_AT_FILE_SCOPE */
{
  /* IDLE */ KeyM_EcuSharedSecretDistribution_HandleStateIdle,
  /* VERIFY_SIGNATURE */ KeyM_EcuSharedSecretDistribution_HandleStateVerifySignature,
  /* KEYEXCHANGE_DECRYPT */ KeyM_EcuSharedSecretDistribution_HandleStateKeyExchangeDecrypt,
  /* DERIVE_SECOC_KEYS */ KeyM_EcuSharedSecretDistribution_HandleStateDeriveSecOcKeys,
  /* WAIT_AND_SET_NEW_TIME */ KeyM_EcuSharedSecretDistribution_HandleStateDeriveSecOcKeys,
  /* DESTROY_NONCE */ KeyM_EcuSharedSecretDistribution_HandleStateDestroyNonce
};

# if (SSA_DIAG_SERVICE_INJECT_SEED == STD_ON)

/*! State handler functions for diagnostic routine Ssa_KeyM_RoutineServices_Inject_Seed. */
SSA_KEYM_LOCAL CONST(Ssa_StateHandlerFctPtrType_InjectSeed, Ssa_KeyM_CONST) KeyM_Inject_Seed_State_Handler[] =  /* PRQA S 3218 */ /* MD_SSA_OBJECT_AT_FILE_SCOPE */
{
  /* IDLE */ KeyM_InjectSeed_HandleStateIdle,
  /* VERIFY_SIGNATURE */ KeyM_InjectSeed_HandleStateVerifySignature,
  /* KEYEXCHANGE */ KeyM_InjectSeed_HandleStateKeyExchange,
  /* DECRYPT */ KeyM_InjectSeed_HandleStateDecrypt,
  /* SEED_RNG */ Ssa_KeyM_InjectSeed_HandleStateSeedRng,
  /* DESTROY_NONCE */ KeyM_InjectSeed_HandleStateDestroyNonce,
  /* STORE_INIT */ KeyM_InjectSeed_HandleStateStorePermanently,
  /* STORE_PENDING */ KeyM_InjectSeed_HandleStateStorePermanently
};

# endif
#endif

/*! KeyM_CertElementGet function pointer for get certificate entry
 *  The entries KeyM_GetCertEntry_KeyM_CertElementGet_List[0-4][0-10] may not be changed, as they are defined in the specification.
 *  Extensions of the list for other usage than the RC GetCertificateEntry are allowed only below the specified entries. */
SSA_KEYM_LOCAL CONST(Ssa_KeyM_KeyMCertificateElementFctPtrType, Ssa_KeyM_CONST)  KeyM_GetCertEntry_KeyM_CertElementGet_List[7][SSA_KEYM_CERT_ENTRY_TOTAL_ENTRY_ID_NUM] =
{
/* SSA_KEYM_CERT_ENTRY_CERT_ID_TRUSTMODEL_ROOT_CA_CERT         */
  {
    Rte_Call_KeyMCertificateElement_Ssa_TrustModelRootCert_SerialNo_CertificateElementGet, /* SSA_KEYM_CERT_ENTRY_ENTRY_ID_SERIAL_NUMBER            */
    Rte_Call_KeyMCertificateElement_Ssa_TrustModelRootCert_subject_CertificateElementGet, /* SSA_KEYM_CERT_ENTRY_ENTRY_ID_SUBJECT                  */
    NULL_PTR, /* SSA_KEYM_CERT_ENTRY_ENTRY_ID_SPECIAL_ECU              */
    Rte_Call_KeyMCertificateElement_Ssa_TrustModelRootCert_SubjectPublicKeyInfoKey_CertificateElementGet, /* SSA_KEYM_CERT_ENTRY_ENTRY_ID_SUBJECT_PUBLIC_KEY       */
    Rte_Call_KeyMCertificateElement_Ssa_TrustModelRootCert_Issuer_CertificateElementGet, /* SSA_KEYM_CERT_ENTRY_ENTRY_ID_ISSUER                   */
    NULL_PTR, /* SSA_KEYM_CERT_ENTRY_ENTRY_ID_ISSUER_SERIAL_NUMBER     */
    Rte_Call_KeyMCertificateElement_Ssa_TrustModelRootCert_ext_subKeyId_CertificateElementGet, /* SSA_KEYM_CERT_ENTRY_ENTRY_ID_SUBJECT_KEY_IDENTIFIER   */
    NULL_PTR, /* SSA_KEYM_CERT_ENTRY_ENTRY_ID_AUTHORITY_KEY_IDENTIFIER */
    NULL_PTR, /* SSA_KEYM_CERT_ENTRY_ENTRY_ID_PKI_ROLE                 */
    NULL_PTR,  /* SSA_KEYM_CERT_ENTRY_PROD_QUALIFIER           */
    Rte_Call_KeyMCertificateElement_Ssa_TrustModelRootCert_Version_CertificateElementGet, /* SSA_KEYM_CERT_ENTRY_ENTRY_ID_VERSION          */
    Rte_Call_KeyMCertificateElement_Ssa_TrustModelRootCert_validityNotAfter_CertificateElementGet, /* SSA_KEYM_CERT_ENTRY_ENTRY_ID_NOT_AFTER         */
    Rte_Call_KeyMCertificateElement_Ssa_TrustModelRootCert_ext_basicConstraints_CertificateElementGet /* SSA_KEYM_CERT_ENTRY_ENTRY_ID_BASIC_CONSTRAINTS     */
  },
/* SSA_KEYM_CERT_ENTRY_CERT_ID_TRUSTMODEL_BACKEND_CA_CERT      */
  {
    Rte_Call_KeyMCertificateElement_Ssa_TrustModelBackendCert_SerialNo_CertificateElementGet, /* SSA_KEYM_CERT_ENTRY_ENTRY_ID_SERIAL_NUMBER            */
    Rte_Call_KeyMCertificateElement_Ssa_TrustModelBackendCert_subject_CertificateElementGet, /* SSA_KEYM_CERT_ENTRY_ENTRY_ID_SUBJECT                  */
    NULL_PTR, /* SSA_KEYM_CERT_ENTRY_ENTRY_ID_SPECIAL_ECU              */
    Rte_Call_KeyMCertificateElement_Ssa_TrustModelBackendCert_SubjectPublicKeyInfoKey_CertificateElementGet, /* SSA_KEYM_CERT_ENTRY_ENTRY_ID_SUBJECT_PUBLIC_KEY       */
    Rte_Call_KeyMCertificateElement_Ssa_TrustModelBackendCert_Issuer_CertificateElementGet, /* SSA_KEYM_CERT_ENTRY_ENTRY_ID_ISSUER                   */
    NULL_PTR, /* SSA_KEYM_CERT_ENTRY_ENTRY_ID_ISSUER_SERIAL_NUMBER     */
    Rte_Call_KeyMCertificateElement_Ssa_TrustModelBackendCert_ext_subKeyId_CertificateElementGet, /* SSA_KEYM_CERT_ENTRY_ENTRY_ID_SUBJECT_KEY_IDENTIFIER   */
    Rte_Call_KeyMCertificateElement_Ssa_TrustModelBackendCert_ext_authKeyId_CertificateElementGet, /* SSA_KEYM_CERT_ENTRY_ENTRY_ID_AUTHORITY_KEY_IDENTIFIER */
    NULL_PTR, /* SSA_KEYM_CERT_ENTRY_ENTRY_ID_PKI_ROLE                 */
    NULL_PTR,  /* SSA_KEYM_CERT_ENTRY_ENTRY_ID_PROD_QUALIFIER           */
    Rte_Call_KeyMCertificateElement_Ssa_TrustModelBackendCert_Version_CertificateElementGet, /* SSA_KEYM_CERT_ENTRY_ENTRY_ID_VERSION          */
    Rte_Call_KeyMCertificateElement_Ssa_TrustModelBackendCert_validityNotAfter_CertificateElementGet, /* SSA_KEYM_CERT_ENTRY_ENTRY_ID_NOT_AFTER         */
    Rte_Call_KeyMCertificateElement_Ssa_TrustModelBackendCert_ext_basicConstraints_CertificateElementGet /* SSA_KEYM_CERT_ENTRY_ENTRY_ID_BASIC_CONSTRAINTS     */
  },
/* SSA_KEYM_CERT_ENTRY_CERT_ID_TRUSTMODEL_INTERMEDIATE_CA_CERT */
  {
    Rte_Call_KeyMCertificateElement_Ssa_TrustModelIntermediateCert_SerialNo_CertificateElementGet, /* SSA_KEYM_CERT_ENTRY_ENTRY_ID_SERIAL_NUMBER            */
    Rte_Call_KeyMCertificateElement_Ssa_TrustModelIntermediateCert_subject_CertificateElementGet, /* SSA_KEYM_CERT_ENTRY_ENTRY_ID_SUBJECT                  */
    NULL_PTR, /* SSA_KEYM_CERT_ENTRY_ENTRY_ID_SPECIAL_ECU              */
    Rte_Call_KeyMCertificateElement_Ssa_TrustModelIntermediateCert_SubjectPublicKeyInfoKey_CertificateElementGet, /* SSA_KEYM_CERT_ENTRY_ENTRY_ID_SUBJECT_PUBLIC_KEY       */
    Rte_Call_KeyMCertificateElement_Ssa_TrustModelIntermediateCert_Issuer_CertificateElementGet, /* SSA_KEYM_CERT_ENTRY_ENTRY_ID_ISSUER                   */
    NULL_PTR, /* SSA_KEYM_CERT_ENTRY_ENTRY_ID_ISSUER_SERIAL_NUMBER     */
    Rte_Call_KeyMCertificateElement_Ssa_TrustModelIntermediateCert_ext_subKeyId_CertificateElementGet, /* SSA_KEYM_CERT_ENTRY_ENTRY_ID_SUBJECT_KEY_IDENTIFIER   */
    Rte_Call_KeyMCertificateElement_Ssa_TrustModelIntermediateCert_ext_authKeyId_CertificateElementGet, /* SSA_KEYM_CERT_ENTRY_ENTRY_ID_AUTHORITY_KEY_IDENTIFIER */
    NULL_PTR, /* SSA_KEYM_CERT_ENTRY_ENTRY_ID_PKI_ROLE                 */
    NULL_PTR,  /* SSA_KEYM_CERT_ENTRY_ENTRY_ID_PROD_QUALIFIER           */
    Rte_Call_KeyMCertificateElement_Ssa_TrustModelIntermediateCert_Version_CertificateElementGet, /* SSA_KEYM_CERT_ENTRY_ENTRY_ID_VERSION          */
    Rte_Call_KeyMCertificateElement_Ssa_TrustModelIntermediateCert_validityNotAfter_CertificateElementGet, /* SSA_KEYM_CERT_ENTRY_ENTRY_ID_NOT_AFTER         */
    Rte_Call_KeyMCertificateElement_Ssa_TrustModelIntermediateCert_ext_basicConstraints_CertificateElementGet /* SSA_KEYM_CERT_ENTRY_ENTRY_ID_BASIC_CONSTRAINTS     */
  },
/* SSA_KEYM_CERT_ENTRY_CERT_ID_TRUSTMODEL_ECU_CA_CERT          */
  {
    Rte_Call_KeyMCertificateElement_Ssa_TrustModelEcuCert_SerialNo_CertificateElementGet, /* SSA_KEYM_CERT_ENTRY_ENTRY_ID_SERIAL_NUMBER            */
    Rte_Call_KeyMCertificateElement_Ssa_TrustModelEcuCert_subject_CertificateElementGet, /* SSA_KEYM_CERT_ENTRY_ENTRY_ID_SUBJECT                  */
    Rte_Call_KeyMCertificateElement_Ssa_TrustModelEcuCert_ext_specialEcu_CertificateElementGet, /* SSA_KEYM_CERT_ENTRY_ENTRY_ID_SPECIAL_ECU              */
    Rte_Call_KeyMCertificateElement_Ssa_TrustModelEcuCert_SubjectPublicKeyInfoKey_CertificateElementGet, /* SSA_KEYM_CERT_ENTRY_ENTRY_ID_SUBJECT_PUBLIC_KEY       */
    Rte_Call_KeyMCertificateElement_Ssa_TrustModelEcuCert_Issuer_CertificateElementGet, /* SSA_KEYM_CERT_ENTRY_ENTRY_ID_ISSUER                   */
    NULL_PTR, /* SSA_KEYM_CERT_ENTRY_ENTRY_ID_ISSUER_SERIAL_NUMBER     */
    Rte_Call_KeyMCertificateElement_Ssa_TrustModelEcuCert_ext_subKeyId_CertificateElementGet, /* SSA_KEYM_CERT_ENTRY_ENTRY_ID_SUBJECT_KEY_IDENTIFIER   */
    Rte_Call_KeyMCertificateElement_Ssa_TrustModelEcuCert_ext_authKeyId_CertificateElementGet, /* SSA_KEYM_CERT_ENTRY_ENTRY_ID_AUTHORITY_KEY_IDENTIFIER */
    NULL_PTR, /* SSA_KEYM_CERT_ENTRY_ENTRY_ID_PKI_ROLE                 */
    NULL_PTR,  /* SSA_KEYM_CERT_ENTRY_ENTRY_ID_PROD_QUALIFIER           */
    Rte_Call_KeyMCertificateElement_Ssa_TrustModelEcuCert_Version_CertificateElementGet, /* SSA_KEYM_CERT_ENTRY_ENTRY_ID_VERSION          */
    Rte_Call_KeyMCertificateElement_Ssa_TrustModelEcuCert_validityNotAfter_CertificateElementGet, /* SSA_KEYM_CERT_ENTRY_ENTRY_ID_NOT_AFTER         */
    NULL_PTR /* SSA_KEYM_CERT_ENTRY_ENTRY_ID_BASIC_CONSTRAINTS     */
  },
  /* SSA_KEYM_CERT_ENTRY_CERT_ID_TRUSTMODEL_BACKEND_PEER_CERT      */
  {
    NULL_PTR, /* SSA_KEYM_CERT_ENTRY_ENTRY_ID_SERIAL_NUMBER            */
    NULL_PTR, /* SSA_KEYM_CERT_ENTRY_ENTRY_ID_SUBJECT                  */
    NULL_PTR, /* SSA_KEYM_CERT_ENTRY_ENTRY_ID_SPECIAL_ECU              */
    NULL_PTR, /* SSA_KEYM_CERT_ENTRY_ENTRY_ID_SUBJECT_PUBLIC_KEY       */
    NULL_PTR, /* SSA_KEYM_CERT_ENTRY_ENTRY_ID_ISSUER                   */
    NULL_PTR, /* SSA_KEYM_CERT_ENTRY_ENTRY_ID_ISSUER_SERIAL_NUMBER     */
    Rte_Call_KeyMCertificateElement_Ssa_TrustModelBackendPeerCert_ext_subKeyId_CertificateElementGet, /* SSA_KEYM_CERT_ENTRY_ENTRY_ID_SUBJECT_KEY_IDENTIFIER   */
    Rte_Call_KeyMCertificateElement_Ssa_TrustModelBackendPeerCert_ext_authKeyId_CertificateElementGet, /* SSA_KEYM_CERT_ENTRY_ENTRY_ID_AUTHORITY_KEY_IDENTIFIER */
    NULL_PTR, /* SSA_KEYM_CERT_ENTRY_ENTRY_ID_PKI_ROLE                 */
    NULL_PTR,  /* SSA_KEYM_CERT_ENTRY_ENTRY_ID_PROD_QUALIFIER           */
    Rte_Call_KeyMCertificateElement_Ssa_TrustModelBackendPeerCert_Version_CertificateElementGet, /* SSA_KEYM_CERT_ENTRY_ENTRY_ID_VERSION          */
    Rte_Call_KeyMCertificateElement_Ssa_TrustModelBackendPeerCert_validityNotAfter_CertificateElementGet, /* SSA_KEYM_CERT_ENTRY_ENTRY_ID_NOT_AFTER         */
    Rte_Call_KeyMCertificateElement_Ssa_TrustModelBackendPeerCert_ext_basicConstraints_CertificateElementGet /* SSA_KEYM_CERT_ENTRY_ENTRY_ID_BASIC_CONSTRAINTS     */
  },
  /* SSA_KEYM_CERT_ENTRY_CERT_ID_TRUSTMODEL_INTERMEDIATE_PEER_CERT */
  {
    NULL_PTR, /* SSA_KEYM_CERT_ENTRY_ENTRY_ID_SERIAL_NUMBER            */
    NULL_PTR, /* SSA_KEYM_CERT_ENTRY_ENTRY_ID_SUBJECT                  */
    NULL_PTR, /* SSA_KEYM_CERT_ENTRY_ENTRY_ID_SPECIAL_ECU              */
    NULL_PTR, /* SSA_KEYM_CERT_ENTRY_ENTRY_ID_SUBJECT_PUBLIC_KEY       */
    NULL_PTR, /* SSA_KEYM_CERT_ENTRY_ENTRY_ID_ISSUER                   */
    NULL_PTR, /* SSA_KEYM_CERT_ENTRY_ENTRY_ID_ISSUER_SERIAL_NUMBER     */
    Rte_Call_KeyMCertificateElement_Ssa_TrustModelIntermediatePeerCert_ext_subKeyId_CertificateElementGet, /* SSA_KEYM_CERT_ENTRY_ENTRY_ID_SUBJECT_KEY_IDENTIFIER   */
    Rte_Call_KeyMCertificateElement_Ssa_TrustModelIntermediatePeerCert_ext_authKeyId_CertificateElementGet, /* SSA_KEYM_CERT_ENTRY_ENTRY_ID_AUTHORITY_KEY_IDENTIFIER */
    NULL_PTR, /* SSA_KEYM_CERT_ENTRY_ENTRY_ID_PKI_ROLE                 */
    NULL_PTR,  /* SSA_KEYM_CERT_ENTRY_ENTRY_ID_PROD_QUALIFIER           */
    Rte_Call_KeyMCertificateElement_Ssa_TrustModelIntermediatePeerCert_Version_CertificateElementGet, /* SSA_KEYM_CERT_ENTRY_ENTRY_ID_VERSION          */
    Rte_Call_KeyMCertificateElement_Ssa_TrustModelIntermediatePeerCert_validityNotAfter_CertificateElementGet, /* SSA_KEYM_CERT_ENTRY_ENTRY_ID_NOT_AFTER         */
    Rte_Call_KeyMCertificateElement_Ssa_TrustModelIntermediatePeerCert_ext_basicConstraints_CertificateElementGet /* SSA_KEYM_CERT_ENTRY_ENTRY_ID_BASIC_CONSTRAINTS     */
  },
  /* SSA_KEYM_CERT_ENTRY_CERT_ID_TRUSTMODEL_ECU_PEER_CERT          */
  {
    NULL_PTR, /* SSA_KEYM_CERT_ENTRY_ENTRY_ID_SERIAL_NUMBER            */
    NULL_PTR, /* SSA_KEYM_CERT_ENTRY_ENTRY_ID_SUBJECT                  */
    NULL_PTR, /* SSA_KEYM_CERT_ENTRY_ENTRY_ID_SPECIAL_ECU              */
    NULL_PTR, /* SSA_KEYM_CERT_ENTRY_ENTRY_ID_SUBJECT_PUBLIC_KEY       */
    NULL_PTR, /* SSA_KEYM_CERT_ENTRY_ENTRY_ID_ISSUER                   */
    NULL_PTR, /* SSA_KEYM_CERT_ENTRY_ENTRY_ID_ISSUER_SERIAL_NUMBER     */
    Rte_Call_KeyMCertificateElement_Ssa_TrustModelEcuPeerCert_ext_subKeyId_CertificateElementGet, /* SSA_KEYM_CERT_ENTRY_ENTRY_ID_SUBJECT_KEY_IDENTIFIER   */
    Rte_Call_KeyMCertificateElement_Ssa_TrustModelEcuPeerCert_ext_authKeyId_CertificateElementGet, /* SSA_KEYM_CERT_ENTRY_ENTRY_ID_AUTHORITY_KEY_IDENTIFIER */
    NULL_PTR, /* SSA_KEYM_CERT_ENTRY_ENTRY_ID_PKI_ROLE                 */
    NULL_PTR,  /* SSA_KEYM_CERT_ENTRY_ENTRY_ID_PROD_QUALIFIER           */
    Rte_Call_KeyMCertificateElement_Ssa_TrustModelEcuPeerCert_Version_CertificateElementGet, /* SSA_KEYM_CERT_ENTRY_ENTRY_ID_VERSION          */
    Rte_Call_KeyMCertificateElement_Ssa_TrustModelEcuPeerCert_validityNotAfter_CertificateElementGet, /* SSA_KEYM_CERT_ENTRY_ENTRY_ID_NOT_AFTER         */
    NULL_PTR /* SSA_KEYM_CERT_ENTRY_ENTRY_ID_BASIC_CONSTRAINTS     */
  }
};

#define Ssa_KeyM_STOP_SEC_CONST_UNSPECIFIED
#include "Ssa_KeyM_MemMap.h" /* PRQA S 5087 */ /* MD_MSR_MemMap */

/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << End of include and declaration area >>          DO NOT CHANGE THIS COMMENT!
 *********************************************************************************************************************/

/**********************************************************************************************************************
 *
 * Used AUTOSAR Data Types
 *
 **********************************************************************************************************************
 *
 * Primitive Types:
 * ================
 * Csm_DataPtr: DataReference
 * Csm_LengthPtr: DataReference
 * Csm_const_DataPtr: DataReference
 * Dcm_DiagnosticSessionControlType: Integer in interval [0...255]
 * KeyM_CertElementIdType: Integer in interval [0...65535]
 * KeyM_CertificateIdType: Integer in interval [0...65535]
 * KeyM_const_CryptoKeyDataType: DataReference
 * Ssa_ConstDataPtr: DataReference
 * Ssa_DataPtr: DataReference
 * Ssa_LengthPtr: DataReference
 * Ssa_VerifyResultPtr: DataReference
 * boolean: Boolean (standard type)
 * dtRef_const_VOID: DataReference
 * uint16: Integer in interval [0...65535] (standard type)
 * uint32: Integer in interval [0...4294967295] (standard type)
 * uint8: Integer in interval [0...255] (standard type)
 *
 * Enumeration Types:
 * ==================
 * CertP_PkiRoleType: Enumeration of integer in interval [0...255] with enumerators
 *   CERTP_PKI_ROLE_ROOT (1U)
 *   CERTP_PKI_ROLE_BACKEND (2U)
 *   CERTP_PKI_ROLE_TESTER (3U)
 *   CERTP_PKI_ROLE_ECU (4U)
 *   CERTP_PKI_ROLE_ENHANCE_ACCESS_RIGHTS (5U)
 *   CERTP_PKI_ROLE_VARIANT_CODING (7U)
 *   CERTP_PKI_ROLE_USER_CERT_FOR_CODING (9U)
 *   CERTP_PKI_ROLE_ROOT_CA_LINK_CERT (10U)
 *   CERTP_PKI_ROLE_BACKEND_CA_LINK_CERT (11U)
 *   CERTP_PKI_ROLE_TRUST_MODEL_ROOT_CA (12U)
 *   CERTP_PKI_ROLE_TRUST_MODEL_BACKEND_CA (13U)
 *   CERTP_PKI_ROLE_TRUST_MODEL_INTERMEDIATE_CA (14U)
 *   CERTP_PKI_ROLE_TRUST_MODEL_ECU (15U)
 *   CERTP_PKI_ROLE_TRUST_MODEL_ROOT_CA_LINK (16U)
 *   CERTP_PKI_ROLE_TRUST_MODEL_BACKEND_CA_LINK (17U)
 *   CERTP_PKI_ROLE_TRUST_MODEL_INTERMEDIATE_CA_LINK (18U)
 *   CERTP_PKI_ROLE_PQC_ROOT_CA (19U)
 *   CERTP_PKI_ROLE_PQC_BACKEND_CA (20U)
 *   CERTP_PKI_ROLE_PQC_TESTER (21U)
 *   CERTP_PKI_ROLE_PQC_ECU (22U)
 *   CERTP_PKI_ROLE_INVALID (0U)
 * CertP_VerificationResultType: Enumeration of integer in interval [0...255] with enumerators
 *   CERTP_VER_OK (0U)
 *   CERTP_VER_INVALID_TIME_PERIOD (16U)
 *   CERTP_VER_INVALID_SIGNATURE (17U)
 *   CERTP_VER_INVALID_CHAIN_OF_TRUST (18U)
 *   CERTP_VER_INVALID_TYPE (19U)
 *   CERTP_VER_INVALID_FORMAT (20U)
 *   CERTP_VER_INVALID_CONTENT (21U)
 *   CERTP_VER_INVALID_SCOPE (22U)
 *   CERTP_VER_SYNCHRONIZE_TIME_FAILED_NONCE_NOT_ACCEPTED (64U)
 *   CERTP_VER_PARSE_OK (253U)
 *   CERTP_VER_PARSE_FAILED (254U)
 *   CERTP_VER_NOT_PARSED (255U)
 * Coding_MemoryStatusType: Enumeration of integer in interval [0...255] with enumerators
 *   CODING_OK (0U)
 *   CODING_FAILED (1U)
 *   CODING_ACTIVE (2U)
 * Coding_ModeType: Enumeration of integer in interval [0...255] with enumerators
 *   CODING_OK (0U)
 *   CODING_FAILED (1U)
 *   CODING_ACTIVE (2U)
 * Crypto_OperationModeType: Enumeration of integer in interval [0...255] with enumerators
 *   CRYPTO_OPERATIONMODE_START (1U)
 *   CRYPTO_OPERATIONMODE_UPDATE (2U)
 *   CRYPTO_OPERATIONMODE_STREAMSTART (3U)
 *   CRYPTO_OPERATIONMODE_FINISH (4U)
 *   CRYPTO_OPERATIONMODE_SINGLECALL (7U)
 * Crypto_VerifyResultType: Enumeration of integer in interval [0...1] with enumerators
 *   CRYPTO_E_VER_OK (0U)
 *   CRYPTO_E_VER_NOT_OK (1U)
 * Csm_ResultType: Enumeration of integer in interval [0...8] with enumerators
 *   E_NOT_OK (1U)
 *   E_SMALL_BUFFER (2U)
 *   E_ENTROPY_EXHAUSTION (3U)
 *   E_KEY_READ_FAIL (4U)
 *   E_KEY_NOT_AVAILABLE (4U)
 *   E_KEY_NOT_VALID (6U)
 *   E_JOB_CANCELED (7U)
 *   E_KEY_EMPTY (8U)
 * Dcm_NegativeResponseCodeType: Enumeration of integer in interval [0...254] with enumerators
 *   DCM_E_POSITIVERESPONSE (0U)
 *   DCM_E_GENERALREJECT (16U)
 *   DCM_E_SERVICENOTSUPPORTED (17U)
 *   DCM_E_SUBFUNCTIONNOTSUPPORTED (18U)
 *   DCM_E_INCORRECTMESSAGELENGTHORINVALIDFORMAT (19U)
 *   DCM_E_RESPONSETOOLONG (20U)
 *   DCM_E_BUSYREPEATREQUEST (33U)
 *   DCM_E_CONDITIONSNOTCORRECT (34U)
 *   DCM_E_REQUESTSEQUENCEERROR (36U)
 *   DCM_E_NORESPONSEFROMSUBNETCOMPONENT (37U)
 *   DCM_E_FAILUREPREVENTSEXECUTIONOFREQUESTEDACTION (38U)
 *   DCM_E_REQUESTOUTOFRANGE (49U)
 *   DCM_E_SECURITYACCESSDENIED (51U)
 *   DCM_E_INVALIDKEY (53U)
 *   DCM_E_EXCEEDNUMBEROFATTEMPTS (54U)
 *   DCM_E_REQUIREDTIMEDELAYNOTEXPIRED (55U)
 *   DCM_E_UPLOADDOWNLOADNOTACCEPTED (112U)
 *   DCM_E_TRANSFERDATASUSPENDED (113U)
 *   DCM_E_GENERALPROGRAMMINGFAILURE (114U)
 *   DCM_E_WRONGBLOCKSEQUENCECOUNTER (115U)
 *   DCM_E_REQUESTCORRECTLYRECEIVEDRESPONSEPENDING (120U)
 *   DCM_E_SUBFUNCTIONNOTSUPPORTEDINACTIVESESSION (126U)
 *   DCM_E_SERVICENOTSUPPORTEDINACTIVESESSION (127U)
 *   DCM_E_RPMTOOHIGH (129U)
 *   DCM_E_RPMTOOLOW (130U)
 *   DCM_E_ENGINEISRUNNING (131U)
 *   DCM_E_ENGINEISNOTRUNNING (132U)
 *   DCM_E_ENGINERUNTIMETOOLOW (133U)
 *   DCM_E_TEMPERATURETOOHIGH (134U)
 *   DCM_E_TEMPERATURETOOLOW (135U)
 *   DCM_E_VEHICLESPEEDTOOHIGH (136U)
 *   DCM_E_VEHICLESPEEDTOOLOW (137U)
 *   DCM_E_THROTTLE_PEDALTOOHIGH (138U)
 *   DCM_E_THROTTLE_PEDALTOOLOW (139U)
 *   DCM_E_TRANSMISSIONRANGENOTINNEUTRAL (140U)
 *   DCM_E_TRANSMISSIONRANGENOTINGEAR (141U)
 *   DCM_E_BRAKESWITCH_NOTCLOSED (143U)
 *   DCM_E_SHIFTERLEVERNOTINPARK (144U)
 *   DCM_E_TORQUECONVERTERCLUTCHLOCKED (145U)
 *   DCM_E_VOLTAGETOOHIGH (146U)
 *   DCM_E_VOLTAGETOOLOW (147U)
 *   DCM_E_VMSCNC_0 (240U)
 *   DCM_E_VMSCNC_1 (241U)
 *   DCM_E_VMSCNC_2 (242U)
 *   DCM_E_VMSCNC_3 (243U)
 *   DCM_E_VMSCNC_4 (244U)
 *   DCM_E_VMSCNC_5 (245U)
 *   DCM_E_VMSCNC_6 (246U)
 *   DCM_E_VMSCNC_7 (247U)
 *   DCM_E_VMSCNC_8 (248U)
 *   DCM_E_VMSCNC_9 (249U)
 *   DCM_E_VMSCNC_A (250U)
 *   DCM_E_VMSCNC_B (251U)
 *   DCM_E_VMSCNC_C (252U)
 *   DCM_E_VMSCNC_D (253U)
 *   DCM_E_VMSCNC_E (254U)
 * Dcm_OpStatusType: Enumeration of integer in interval [0...64] with enumerators
 *   DCM_INITIAL (0U)
 *   DCM_PENDING (1U)
 *   DCM_CANCEL (2U)
 *   DCM_FORCE_RCRRP_OK (3U)
 *   DCM_FORCE_RCRRP_NOT_OK (64U)
 * KeyM_CertificateStatusType: Enumeration of integer in interval [0...11] with enumerators
 *   KEYM_CERTIFICATE_VALID (0U)
 *   KEYM_CERTIFICATE_INVALID (1U)
 *   KEYM_CERTIFICATE_NOT_PARSED (2U)
 *   KEYM_CERTIFICATE_PARSED_NOT_VALIDATED (3U)
 *   KEYM_CERTIFICATE_NOT_AVAILABLE (4U)
 *   KEYM_E_CERTIFICATE_VALIDITY_PERIOD_FAIL (5U)
 *   KEYM_E_CERTIFICATE_SIGNATURE_FAIL (6U)
 *   KEYM_E_CERTIFICATE_INVALID_CHAIN_OF_TRUST (7U)
 *   KEYM_E_CERTIFICATE_INVALID_TYPE (8U)
 *   KEYM_E_CERTIFICATE_INVALID_FORMAT (9U)
 *   KEYM_E_CERTIFICATE_INVALID_CONTENT (10U)
 *   KEYM_E_CERTIFICATE_REVOKED (11U)
 * KeyM_CsrEncodingType: Enumeration of integer in interval [0...1] with enumerators
 *   KEYM_CSR_ENCODING_NONE (0U)
 *   KEYM_CSR_ENCODING_DER (1U)
 * KeyM_ResultType: Enumeration of integer in interval [0...5] with enumerators
 *   KEYM_RT_OK (0U)
 *   KEYM_RT_NOT_OK (1U)
 *   KEYM_RT_KEY_CERT_INVALID (2U)
 *   KEYM_RT_KEY_CERT_WRITE_FAIL (3U)
 *   KEYM_RT_KEY_CERT_UPDATE_FAIL (4U)
 *   KEYM_RT_CERT_INVALID_CHAIN_OF_TRUST (5U)
 * KeyM_ServiceCertificateType: Enumeration of integer in interval [1...7] with enumerators
 *   KEYM_SERVICE_CERT_REQUEST_CSR (1U)
 *   KEYM_SERVICE_CERT_UPDATE_SIGNED_CSR (2U)
 *   KEYM_SERVICE_CERT_SET_ROOT (3U)
 *   KEYM_SERVICE_CERT_UPDATE_ROOT (4U)
 *   KEYM_SERVICE_CERT_SET_INTERMEDIATE (5U)
 *   KEYM_SERVICE_CERT_UPDATE_INTERMEDIATE (6U)
 *   KEYM_SERVICE_CERT_UPDATE_CRL (7U)
 * NvM_RequestResultType: Enumeration of integer in interval [0...255] with enumerators
 *   NVM_REQ_OK (0U)
 *   NVM_REQ_NOT_OK (1U)
 *   NVM_REQ_PENDING (2U)
 *   NVM_REQ_INTEGRITY_FAILED (3U)
 *   NVM_REQ_BLOCK_SKIPPED (4U)
 *   NVM_REQ_NV_INVALIDATED (5U)
 *   NVM_REQ_CANCELED (6U)
 *   NVM_REQ_REDUNDANCY_FAILED (7U)
 *   NVM_REQ_RESTORED_FROM_ROM (8U)
 * RightsM_ACL_BitMaskType: Enumeration of integer in interval [0...4294967295] with enumerators
 *   RIGHTSM_ACL_BITMASK_ANYBODY (1U)
 *   RIGHTSM_ACL_BITMASK_SUPPLIER (2U)
 *   RIGHTSM_ACL_BITMASK_DEV_ENHANCED (4U)
 *   RIGHTSM_ACL_BITMASK_PRODUCTION (8U)
 *   RIGHTSM_ACL_BITMASK_AS_ENHANCED (16U)
 *   RIGHTSM_ACL_BITMASK_AS_STANDARD (32U)
 *   RIGHTSM_ACL_BITMASK_AS_BASIC (64U)
 *   RIGHTSM_ACL_BITMASK_INT_DIAG_TEST_TOOL (128U)
 *   RIGHTSM_ACL_BITMASK_EPTI_TEST_TOOL (256U)
 * RightsM_AuthenticationModeType: Enumeration of integer in interval [0...255] with enumerators
 *   RIGHTSM_UNAUTHENTICATED (0U)
 *   RIGHTSM_AUTHENTICATED (1U)
 * RightsM_DiagnosticUserRoleType: Enumeration of integer in interval [0...255] with enumerators
 *   RIGHTSM_USERROLE_ANYBODY (0U)
 *   RIGHTSM_USERROLE_SUPPLIER (1U)
 *   RIGHTSM_USERROLE_DEV_ENHANCED (2U)
 *   RIGHTSM_USERROLE_PRODUCTION (3U)
 *   RIGHTSM_USERROLE_AS_ENHANCED (4U)
 *   RIGHTSM_USERROLE_AS_STANDARD (5U)
 *   RIGHTSM_USERROLE_AS_BASIC (6U)
 *   RIGHTSM_USERROLE_INT_DIAG_TEST_TOOL (7U)
 *   RIGHTSM_USERROLE_EPTI_TEST_TOOL (8U)
 * Ssa_KeyElementType: Enumeration of integer in interval [0...4294967295] with enumerators
 *   SSA_KE_MAC_KEY (1U)
 *   SSA_KE_MAC_PROOF (2U)
 *   SSA_KE_SIGNATURE_KEY (1U)
 *   SSA_KE_RANDOM_SEED_STATE (3U)
 *   SSA_KE_RANDOM_ALGORITHM (4U)
 *   SSA_KE_CIPHER_KEY (1U)
 *   SSA_KE_CIPHER_IV (5U)
 *   SSA_KE_CIPHER_PROOF (6U)
 *   SSA_KE_CIPHER_2NDKEY (7U)
 *   SSA_KE_KEYEXCHANGE_BASE (8U)
 *   SSA_KE_KEYEXCHANGE_PRIVKEY (9U)
 *   SSA_KE_KEYEXCHANGE_OWNPUBKEY (10U)
 *   SSA_KE_KEYEXCHANGE_SHAREDVALUE (1U)
 *   SSA_KE_KEYEXCHANGE_ALGORITHM (12U)
 *   SSA_KE_KEYDERIVATION_PASSWORD (1U)
 *   SSA_KE_KEYDERIVATION_SALT (13U)
 *   SSA_KE_KEYDERIVATION_ITERATIONS (14U)
 *   SSA_KE_KEYDERIVATION_ALGORITHM (15U)
 *   SSA_KE_KEYGENERATE_KEY (1U)
 *   SSA_KE_KEYGENERATE_SEED (16U)
 *   SSA_KE_KEYGENERATE_ALGORITHM (17U)
 *   SSA_KE_CERTIFICATE_DATA (0U)
 * Ssa_KeyStorageTaskType: Enumeration of integer in interval [0...255] with enumerators
 *   SSA_KEYSTORAGE_TASK_INITIAL (0U)
 *   SSA_KEYSTORAGE_TASK_CHECKSTATE (1U)
 *   SSA_KEYSTORAGE_TASK_CANCEL (2U)
 * Ssa_KeyStorageUseCaseType: Enumeration of integer in interval [0...255] with enumerators
 *   SSA_KEYSTORAGE_USECASE_CRYPTO (0U)
 *   SSA_KEYSTORAGE_USECASE_CERTIFICATES (1U)
 *   SSA_KEYSTORAGE_USECASE_TRUST_MODEL_CERTIFICATES (2U)
 *   SSA_KEYSTORAGE_USECASE_TRUST_MODEL_ROOT_CERTIFICATE (3U)
 *   SSA_KEYSTORAGE_USECASE_RNG_SEED_STATE (4U)
 * Ssa_OnOff_StateType: Enumeration of integer in interval [0...255] with enumerators
 *   SSA_STATE_OFF (0U)
 *   SSA_STATE_ON (1U)
 * Ssa_OpStatusType: Enumeration of integer in interval [0...255] with enumerators
 *   SSA_OPSTATUS_INITIAL (0U)
 *   SSA_OPSTATUS_CHECKSTATE (1U)
 *   SSA_OPSTATUS_CANCEL (2U)
 * Ssa_OperationModeType: Enumeration of integer in interval [0...255] with enumerators
 *   SSA_ACTIVE (0U)
 *   SSA_INACTIVE (1U)
 * Ssa_PostProductionStatusType: Enumeration of integer in interval [0...255] with enumerators
 *   SSA_POST_PRODUCTION_STATUS_DEACTIVATED (0U)
 *   SSA_POST_PRODUCTION_STATUS_IRREVERSIBLY_ACTIVATED (1U)
 *   SSA_POST_PRODUCTION_STATUS_REVERSIBLY_ACTIVATED (2U)
 * Ssa_TrustModelChainState_Type: Enumeration of integer in interval [0...255] with enumerators
 *   SSA_TRUSTMODELCHAINSTATE_INITIAL (0U)
 *   SSA_TRUSTMODELCHAINSTATE_ROOT_INJECTED (1U)
 *   SSA_TRUSTMODELCHAINSTATE_FULLY_INJECTED (2U)
 * TimeM_CompareOperatorType: Enumeration of integer in interval [0...255] with enumerators
 *   TIMEM_IS_GREATER (0U)
 *   TIMEM_IS_LESS (1U)
 *
 * Array Types:
 * ============
 * CertP_RawCertBufferType: Array with 910 element(s) of type uint8
 * Coding_VINDataType: Array with 17 element(s) of type uint8
 * Csm_DecryptDataType_AES128Decrypt: Array with 80 element(s) of type uint8
 * Csm_DecryptDataType_AES128DecryptWithPadding: Array with 1056 element(s) of type uint8
 * Csm_DecryptResultType_AES128Decrypt: Array with 80 element(s) of type uint8
 * Csm_DecryptResultType_AES128DecryptWithPadding: Array with 1056 element(s) of type uint8
 * Csm_EncryptDataType_AES128Encrypt: Array with 64 element(s) of type uint8
 * Csm_EncryptResultType_AES128Encrypt: Array with 80 element(s) of type uint8
 * Csm_KeyDataType_Ssa_AesRamKey: Array with 16 element(s) of type uint8
 * Csm_KeyDataType_Ssa_BackendCert: Array with 600 element(s) of type uint8
 * Csm_KeyDataType_Ssa_EcuCert: Array with 600 element(s) of type uint8
 * Csm_KeyDataType_Ssa_RootCert: Array with 600 element(s) of type uint8
 * Csm_KeyDataType_Ssa_SharedSecret: Array with 32 element(s) of type uint8
 * Csm_KeyDataType_Ssa_SharedSecretHash: Array with 4 element(s) of type uint8
 * Csm_KeyDataType_Ssa_SharedSecretKeyExchange: Array with 32 element(s) of type uint8
 * Csm_KeyDataType_Ssa_SigPubKey_ReplacementAuthority: Array with 32 element(s) of type uint8
 * Csm_KeyDataType_Ssa_SignatureRamKey: Array with 32 element(s) of type uint8
 * Csm_KeyDataType_Ssa_TrustModelEcuCsrPublicKey: Array with 32 element(s) of type uint8
 * Csm_KeyDataType_Ssa_TrustModelEcuLivePublicKey: Array with 32 element(s) of type uint8
 * Csm_KeyDataType_Ssa_TrustModelTempPublicKey: Array with 32 element(s) of type uint8
 * Csm_MacGenerateDataType_MacGenAesCmac: Array with 18 element(s) of type uint8
 * Csm_MacGenerateResultType_MacGenAesCmac: Array with 16 element(s) of type uint8
 * Csm_PublicValueDataType_Ssa_SharedSecretKeyExchange: Array with 32 element(s) of type uint8
 * Csm_RandomGenerateResultType_Random: Array with 32 element(s) of type uint8
 * Csm_SeedDataTypeSsa_RandomSeed: Array with 1056 element(s) of type uint8
 * Dcm_Data1002ByteType: Array with 1002 element(s) of type uint8
 * Dcm_Data1058ByteType: Array with 1058 element(s) of type uint8
 * Dcm_Data16ByteType: Array with 16 element(s) of type uint8
 * Dcm_Data18ByteType: Array with 18 element(s) of type uint8
 * Dcm_Data1ByteType: Array with 1 element(s) of type uint8
 * Dcm_Data2002ByteType: Array with 2002 element(s) of type uint8
 * Dcm_Data2004ByteType: Array with 2004 element(s) of type uint8
 * Dcm_Data20ByteType: Array with 20 element(s) of type uint8
 * Dcm_Data3006ByteType: Array with 3006 element(s) of type uint8
 * Dcm_Data30ByteType: Array with 30 element(s) of type uint8
 * Dcm_Data32ByteType: Array with 32 element(s) of type uint8
 * Dcm_Data4008ByteType: Array with 4008 element(s) of type uint8
 * Dcm_Data4092ByteType: Array with 4092 element(s) of type uint8
 * Dcm_Data4ByteType: Array with 4 element(s) of type uint8
 * Dcm_Data5ByteType: Array with 5 element(s) of type uint8
 * Dcm_Data64ByteType: Array with 64 element(s) of type uint8
 * Dcm_Data7ByteType: Array with 7 element(s) of type uint8
 * Dcm_Data80ByteType: Array with 80 element(s) of type uint8
 * KeyM_CertificateElementType_Ssa_TrustModelBackendCert_Issuer: Array with 15 element(s) of type uint8
 * KeyM_CertificateElementType_Ssa_TrustModelBackendCert_SerialNo: Array with 16 element(s) of type uint8
 * KeyM_CertificateElementType_Ssa_TrustModelBackendCert_SubjectPublicKeyInfoKey: Array with 33 element(s) of type uint8
 * KeyM_CertificateElementType_Ssa_TrustModelBackendCert_Version: Array with 1 element(s) of type uint8
 * KeyM_CertificateElementType_Ssa_TrustModelBackendCert_ext_authKeyId: Array with 20 element(s) of type uint8
 * KeyM_CertificateElementType_Ssa_TrustModelBackendCert_ext_basicConstraints: Array with 1 element(s) of type uint8
 * KeyM_CertificateElementType_Ssa_TrustModelBackendCert_ext_subKeyId: Array with 20 element(s) of type uint8
 * KeyM_CertificateElementType_Ssa_TrustModelBackendCert_subject: Array with 30 element(s) of type uint8
 * KeyM_CertificateElementType_Ssa_TrustModelBackendCert_validityNotAfter: Array with 15 element(s) of type uint8
 * KeyM_CertificateElementType_Ssa_TrustModelBackendPeerCert_SerialNo: Array with 16 element(s) of type uint8
 * KeyM_CertificateElementType_Ssa_TrustModelBackendPeerCert_Version: Array with 1 element(s) of type uint8
 * KeyM_CertificateElementType_Ssa_TrustModelBackendPeerCert_ext_authKeyId: Array with 20 element(s) of type uint8
 * KeyM_CertificateElementType_Ssa_TrustModelBackendPeerCert_ext_basicConstraints: Array with 1 element(s) of type uint8
 * KeyM_CertificateElementType_Ssa_TrustModelBackendPeerCert_ext_subKeyId: Array with 20 element(s) of type uint8
 * KeyM_CertificateElementType_Ssa_TrustModelBackendPeerCert_validityNotAfter: Array with 15 element(s) of type uint8
 * KeyM_CertificateElementType_Ssa_TrustModelEcuCert_Issuer: Array with 15 element(s) of type uint8
 * KeyM_CertificateElementType_Ssa_TrustModelEcuCert_SerialNo: Array with 16 element(s) of type uint8
 * KeyM_CertificateElementType_Ssa_TrustModelEcuCert_SubjectPublicKeyInfoKey: Array with 33 element(s) of type uint8
 * KeyM_CertificateElementType_Ssa_TrustModelEcuCert_Version: Array with 1 element(s) of type uint8
 * KeyM_CertificateElementType_Ssa_TrustModelEcuCert_ext_authKeyId: Array with 20 element(s) of type uint8
 * KeyM_CertificateElementType_Ssa_TrustModelEcuCert_ext_specialEcu: Array with 1 element(s) of type uint8
 * KeyM_CertificateElementType_Ssa_TrustModelEcuCert_ext_subKeyId: Array with 20 element(s) of type uint8
 * KeyM_CertificateElementType_Ssa_TrustModelEcuCert_ext_uniqueECUID: Array with 170 element(s) of type uint8
 * KeyM_CertificateElementType_Ssa_TrustModelEcuCert_subject: Array with 30 element(s) of type uint8
 * KeyM_CertificateElementType_Ssa_TrustModelEcuCert_validityNotAfter: Array with 15 element(s) of type uint8
 * KeyM_CertificateElementType_Ssa_TrustModelEcuPeerCert_SerialNo: Array with 16 element(s) of type uint8
 * KeyM_CertificateElementType_Ssa_TrustModelEcuPeerCert_Version: Array with 1 element(s) of type uint8
 * KeyM_CertificateElementType_Ssa_TrustModelEcuPeerCert_ext_authKeyId: Array with 20 element(s) of type uint8
 * KeyM_CertificateElementType_Ssa_TrustModelEcuPeerCert_ext_specialEcu: Array with 1 element(s) of type uint8
 * KeyM_CertificateElementType_Ssa_TrustModelEcuPeerCert_ext_subKeyId: Array with 20 element(s) of type uint8
 * KeyM_CertificateElementType_Ssa_TrustModelEcuPeerCert_validityNotAfter: Array with 15 element(s) of type uint8
 * KeyM_CertificateElementType_Ssa_TrustModelIntermediateCert_Issuer: Array with 15 element(s) of type uint8
 * KeyM_CertificateElementType_Ssa_TrustModelIntermediateCert_SerialNo: Array with 16 element(s) of type uint8
 * KeyM_CertificateElementType_Ssa_TrustModelIntermediateCert_SubjectPublicKeyInfoKey: Array with 33 element(s) of type uint8
 * KeyM_CertificateElementType_Ssa_TrustModelIntermediateCert_Version: Array with 1 element(s) of type uint8
 * KeyM_CertificateElementType_Ssa_TrustModelIntermediateCert_ext_authKeyId: Array with 20 element(s) of type uint8
 * KeyM_CertificateElementType_Ssa_TrustModelIntermediateCert_ext_basicConstraints: Array with 1 element(s) of type uint8
 * KeyM_CertificateElementType_Ssa_TrustModelIntermediateCert_ext_subKeyId: Array with 20 element(s) of type uint8
 * KeyM_CertificateElementType_Ssa_TrustModelIntermediateCert_subject: Array with 30 element(s) of type uint8
 * KeyM_CertificateElementType_Ssa_TrustModelIntermediateCert_validityNotAfter: Array with 15 element(s) of type uint8
 * KeyM_CertificateElementType_Ssa_TrustModelIntermediatePeerCert_SerialNo: Array with 16 element(s) of type uint8
 * KeyM_CertificateElementType_Ssa_TrustModelIntermediatePeerCert_Version: Array with 1 element(s) of type uint8
 * KeyM_CertificateElementType_Ssa_TrustModelIntermediatePeerCert_ext_authKeyId: Array with 20 element(s) of type uint8
 * KeyM_CertificateElementType_Ssa_TrustModelIntermediatePeerCert_ext_basicConstraints: Array with 1 element(s) of type uint8
 * KeyM_CertificateElementType_Ssa_TrustModelIntermediatePeerCert_ext_subKeyId: Array with 20 element(s) of type uint8
 * KeyM_CertificateElementType_Ssa_TrustModelIntermediatePeerCert_validityNotAfter: Array with 15 element(s) of type uint8
 * KeyM_CertificateElementType_Ssa_TrustModelRootCert_Issuer: Array with 15 element(s) of type uint8
 * KeyM_CertificateElementType_Ssa_TrustModelRootCert_SerialNo: Array with 16 element(s) of type uint8
 * KeyM_CertificateElementType_Ssa_TrustModelRootCert_SubjectPublicKeyInfoKey: Array with 33 element(s) of type uint8
 * KeyM_CertificateElementType_Ssa_TrustModelRootCert_Version: Array with 1 element(s) of type uint8
 * KeyM_CertificateElementType_Ssa_TrustModelRootCert_ext_basicConstraints: Array with 1 element(s) of type uint8
 * KeyM_CertificateElementType_Ssa_TrustModelRootCert_ext_keyUsage: Array with 2 element(s) of type uint8
 * KeyM_CertificateElementType_Ssa_TrustModelRootCert_ext_subKeyId: Array with 20 element(s) of type uint8
 * KeyM_CertificateElementType_Ssa_TrustModelRootCert_subject: Array with 30 element(s) of type uint8
 * KeyM_CertificateElementType_Ssa_TrustModelRootCert_validityNotAfter: Array with 15 element(s) of type uint8
 * KeyM_SharedSecretType: Array with 32 element(s) of type uint8
 * RightsM_SerialNumberType: Array with 16 element(s) of type uint8
 * Ssa_Data1024ByteType: Array with 1024 element(s) of type uint8
 * Ssa_Data15ByteType: Array with 15 element(s) of type uint8
 * Ssa_Data20ByteType: Array with 20 element(s) of type uint8
 * Ssa_Data2ByteType: Array with 2 element(s) of type uint8
 * Ssa_Data30ByteType: Array with 30 element(s) of type uint8
 * Ssa_Data32ByteType: Array with 32 element(s) of type uint8
 * Ssa_Data4092ByteType: Array with 4092 element(s) of type uint8
 * Ssa_Data5ByteType: Array with 5 element(s) of type uint8
 * Ssa_Data64ByteType: Array with 64 element(s) of type uint8
 * Ssa_Data7ByteType: Array with 7 element(s) of type uint8
 *
 * Record Types:
 * =============
 * CertP_BerElementType: Record with elements
 *   validContent of type boolean
 *   elemDataIdx of type uint16
 *   elemDataLength of type uint16
 * CertP_ParsedCertStructureType: Record with elements
 *   verificationResult of type CertP_VerificationResultType
 *   parsedCertLength of type uint16
 *   signedCertData of type CertP_BerElementType
 *   version of type uint8
 *   serialNumber of type CertP_BerElementType
 *   certSignatureAlgOID of type CertP_BerElementType
 *   issuer of type CertP_BerElementType
 *   validNotBefore of type CertP_TimeType
 *   validNotAfter of type CertP_TimeType
 *   subject of type CertP_BerElementType
 *   publicKey of type CertP_BerElementType
 *   subjectKeyIdentifier of type CertP_BerElementType
 *   authorityKeyIdentifier of type CertP_BerElementType
 *   keyUsage of type uint16
 *   basicConstraints of type uint8
 *   pkiRole of type CertP_PkiRoleType
 *   userRole of type RightsM_DiagnosticUserRoleType
 *   targetECU of type CertP_BerElementType
 *   targetVIN of type CertP_BerElementType
 *   nonce of type CertP_BerElementType
 *   prodQualifier of type uint8
 *   uniqueEcuId of type CertP_BerElementType
 *   service of type CertP_BerElementType
 *   holderIssuer of type CertP_BerElementType
 *   holderSerialNumber of type CertP_BerElementType
 *   signatureAlgorithmOID of type CertP_BerElementType
 *   signature of type CertP_BerElementType
 *   specialECU of type uint8
 *   targetSubjectKeyIdentifier of type CertP_BerElementType
 * CertP_TimeType: Record with elements
 *   validContent of type boolean
 *   dateTime of type TimeM_DateTimeType
 * RightsM_AuthNonceType: Record with elements
 *   data of type Ssa_Data32ByteType
 *   validated of type boolean
 * TimeM_DateTimeType: Record with elements
 *   year of type uint16
 *   month of type uint8
 *   day of type uint8
 *   hour of type uint8
 *   minute of type uint8
 *   second of type uint8
 *
 *********************************************************************************************************************/

/**********************************************************************************************************************
 *
 * APIs which are accessible from all runnable entities of the SW-C
 *
 **********************************************************************************************************************
 * Per-Instance Memory:
 * ====================
 *   Ssa_TrustModelChainState_Type *Rte_Pim_KeyMTrustModelChainOfTrustState(void)
 *
 * Calibration Parameters:
 * =======================
 *   SW-C local Calibration Parameters:
 *   ----------------------------------
 *   Ssa_TrustModelChainState_Type Rte_CData_NvM_KeyM_TrustModelChainOfTrustState_DefaultValue(void)
 *
 *********************************************************************************************************************/

#define Ssa_KeyM_START_SEC_CODE
#include "Ssa_KeyM_MemMap.h" /* PRQA S 5087 */ /* MD_MSR_MemMap */

/**********************************************************************************************************************
 *
 * Runnable Entity Name: Ssa_KeyM_Certificate_CheckTrustModelChainOfTrust
 *
 * This runnable can be invoked concurrently (reentrant implementation).
 *
 *---------------------------------------------------------------------------------------------------------------------
 *
 * Executed if at least one of the following trigger conditions occurred:
 *   - triggered by server invocation for OperationPrototype <CheckTrustModelChainOfTrust> of PortPrototype <KeyM_Certificate>
 *
 **********************************************************************************************************************
 *
 * Runnable prototype:
 * ===================
 *   Std_ReturnType Ssa_KeyM_Certificate_CheckTrustModelChainOfTrust(Ssa_TrustModelChainState_Type *state)
 *
 **********************************************************************************************************************
 *
 * Available Application Errors:
 * =============================
 *   RTE_E_KeyM_Certificate_E_NOT_OK
 *
 *********************************************************************************************************************/
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << Start of documentation area >>                  DO NOT CHANGE THIS COMMENT!
 * Symbol: Ssa_KeyM_Certificate_CheckTrustModelChainOfTrust_doc
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */

/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << End of documentation area >>                    DO NOT CHANGE THIS COMMENT!
 *********************************************************************************************************************/

FUNC(Std_ReturnType, Ssa_KeyM_CODE) Ssa_KeyM_Certificate_CheckTrustModelChainOfTrust(
  P2VAR(Ssa_TrustModelChainState_Type, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) state) /* PRQA S 0624, 3206 */ /* MD_Rte_0624, MD_Rte_3206 */
{
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << Start of runnable implementation >>             DO NOT CHANGE THIS COMMENT!
 * Symbol: Ssa_KeyM_Certificate_CheckTrustModelChainOfTrust (returns application error)
 *********************************************************************************************************************/

  Std_ReturnType retVal = RTE_E_KeyM_Certificate_E_NOT_OK;

  /* ----- Development Error Checks ------------------------------------- */
#if (SSA_DEV_ERROR_DETECT == STD_ON)
  if (state == NULL_PTR)
  {
    /* retVal already set */
  }
  else
#endif /* SSA_DEV_ERROR_DETECT == STD_ON */
  {
    /* atomic read acceess */
    *state = *Rte_Pim_KeyMTrustModelChainOfTrustState();
    retVal = RTE_E_OK;
  }

  return retVal;

/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << End of runnable implementation >>               DO NOT CHANGE THIS COMMENT!
 *********************************************************************************************************************/
}

/**********************************************************************************************************************
 *
 * Runnable Entity Name: Ssa_KeyM_Certificate_GetBackendSerialNumber
 *
 *---------------------------------------------------------------------------------------------------------------------
 *
 * Executed if at least one of the following trigger conditions occurred:
 *   - triggered by server invocation for OperationPrototype <GetBackendSerialNumber> of PortPrototype <KeyM_Certificate>
 *
 **********************************************************************************************************************
 *
 * Client/Server Interfaces:
 * =========================
 *   Server Invocation:
 *   ------------------
 *   Std_ReturnType Rte_Call_CertP_Functions_Certificate_Parse(const uint8 *rawCertData, uint16 rawCertLength, CertP_ParsedCertStructureType *parsedCert)
 *     Argument rawCertData: uint8* is of type CertP_RawCertBufferType
 *     Synchronous Server Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_CertP_Functions_E_NOT_OK
 *
 * Service Calls:
 * ==============
 *   Service Invocation:
 *   -------------------
 *   Std_ReturnType Rte_Call_Key_BackendCert_KeyElementGet(uint32 keyElementId, uint8 *keyPtr, uint32 *keyLength)
 *     Argument keyPtr: uint8* is of type Csm_KeyDataType_Ssa_BackendCert
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_CsmKeyManagement_Ssa_BackendCert_CSM_E_BUSY, RTE_E_CsmKeyManagement_Ssa_BackendCert_CSM_E_KEY_EMPTY, RTE_E_CsmKeyManagement_Ssa_BackendCert_CSM_E_KEY_NOT_AVAILABLE, RTE_E_CsmKeyManagement_Ssa_BackendCert_CSM_E_KEY_READ_FAIL, RTE_E_CsmKeyManagement_Ssa_BackendCert_CSM_E_SMALL_BUFFER, RTE_E_CsmKeyManagement_Ssa_BackendCert_E_NOT_OK
 *
 **********************************************************************************************************************
 *
 * Runnable prototype:
 * ===================
 *   Std_ReturnType Ssa_KeyM_Certificate_GetBackendSerialNumber(uint8 *serialNumber, uint16 *serialNumberLength)
 *     Argument serialNumber: uint8* is of type Ssa_Data2ByteType
 *
 **********************************************************************************************************************
 *
 * Available Application Errors:
 * =============================
 *   RTE_E_KeyM_Certificate_E_NOT_OK
 *
 *********************************************************************************************************************/
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << Start of documentation area >>                  DO NOT CHANGE THIS COMMENT!
 * Symbol: Ssa_KeyM_Certificate_GetBackendSerialNumber_doc
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 */
/*!
 * \spec
 *    requires $lengthOf(serialNumber) >= SSA_SIZEOF_BACKEND_SERIALNUMBER;
 *    requires $lengthOf(serialNumber) >= *serialNumberLength;
 * \endspec
 */
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << End of documentation area >>                    DO NOT CHANGE THIS COMMENT!
 *********************************************************************************************************************/

FUNC(Std_ReturnType, Ssa_KeyM_CODE) Ssa_KeyM_Certificate_GetBackendSerialNumber(
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) serialNumber,
  P2VAR(uint16, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) serialNumberLength) /* PRQA S 0624, 3206 */ /* MD_Rte_0624, MD_Rte_3206 */
{
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << Start of runnable implementation >>             DO NOT CHANGE THIS COMMENT!
 * Symbol: Ssa_KeyM_Certificate_GetBackendSerialNumber (returns application error)
 *********************************************************************************************************************/
  Std_ReturnType rVal = RTE_E_KeyM_Certificate_E_NOT_OK;

  /* ----- Development Error Checks ------------------------------------- */
#if (SSA_DEV_ERROR_DETECT == STD_ON)
  if ((serialNumber == NULL_PTR) || (serialNumberLength == NULL_PTR))
  {
    /* retVal already set */
  }
  else
#endif /* SSA_DEV_ERROR_DETECT == STD_ON */
  {
#if (SSA_KEEP_BUFFER_VARIABLES_STATIC == STD_OFF)
    uint8 KeyM_BackendCertBuf[SSA_SIZEOF_CERT_MAX];
#endif
    uint16 backendCertLength = SSA_SIZEOF_CERT_MAX;

    /* #10 Check input parameters for null pointers. Check if passed buffer length is large enough */
    if (*serialNumberLength < SSA_SIZEOF_BACKEND_SERIALNUMBER)
    {
      rVal = E_NOT_OK;
    }
    else
    {
      /* #20 Get parsed Backend CA certificate. */
      rVal = KeyM_GetAndParseStoredCert(CERTP_PKI_ROLE_BACKEND,
        (P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR))KeyM_BackendCertBuf,
        (P2VAR(uint16, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR))&backendCertLength,
        FALSE);
      if (rVal == E_OK)
      {
        /* the length of the backend serial number is of predefined length */
        *serialNumberLength = SSA_SIZEOF_BACKEND_SERIALNUMBER;
        rVal = KeyM_GetSerialNumberFromCert(KeyM_BackendCertBuf, &KeyM_ParsedBackendCert.serialNumber, serialNumber, *serialNumberLength);
      }
    }
  }

  return rVal;

/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << End of runnable implementation >>               DO NOT CHANGE THIS COMMENT!
 *********************************************************************************************************************/
}

/**********************************************************************************************************************
 *
 * Runnable Entity Name: Ssa_KeyM_Certificate_GetBackendSubject
 *
 *---------------------------------------------------------------------------------------------------------------------
 *
 * Executed if at least one of the following trigger conditions occurred:
 *   - triggered by server invocation for OperationPrototype <GetBackendSubject> of PortPrototype <KeyM_Certificate>
 *
 **********************************************************************************************************************
 *
 * Client/Server Interfaces:
 * =========================
 *   Server Invocation:
 *   ------------------
 *   Std_ReturnType Rte_Call_CertP_Functions_Certificate_Parse(const uint8 *rawCertData, uint16 rawCertLength, CertP_ParsedCertStructureType *parsedCert)
 *     Argument rawCertData: uint8* is of type CertP_RawCertBufferType
 *     Synchronous Server Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_CertP_Functions_E_NOT_OK
 *
 * Service Calls:
 * ==============
 *   Service Invocation:
 *   -------------------
 *   Std_ReturnType Rte_Call_Key_BackendCert_KeyElementGet(uint32 keyElementId, uint8 *keyPtr, uint32 *keyLength)
 *     Argument keyPtr: uint8* is of type Csm_KeyDataType_Ssa_BackendCert
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_CsmKeyManagement_Ssa_BackendCert_CSM_E_BUSY, RTE_E_CsmKeyManagement_Ssa_BackendCert_CSM_E_KEY_EMPTY, RTE_E_CsmKeyManagement_Ssa_BackendCert_CSM_E_KEY_NOT_AVAILABLE, RTE_E_CsmKeyManagement_Ssa_BackendCert_CSM_E_KEY_READ_FAIL, RTE_E_CsmKeyManagement_Ssa_BackendCert_CSM_E_SMALL_BUFFER, RTE_E_CsmKeyManagement_Ssa_BackendCert_E_NOT_OK
 *
 **********************************************************************************************************************
 *
 * Runnable prototype:
 * ===================
 *   Std_ReturnType Ssa_KeyM_Certificate_GetBackendSubject(uint8 *backendSubject, uint16 *dataLength)
 *     Argument backendSubject: uint8* is of type Ssa_Data30ByteType
 *
 **********************************************************************************************************************
 *
 * Available Application Errors:
 * =============================
 *   RTE_E_KeyM_Certificate_E_NOT_OK
 *
 *********************************************************************************************************************/
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << Start of documentation area >>                  DO NOT CHANGE THIS COMMENT!
 * Symbol: Ssa_KeyM_Certificate_GetBackendSubject_doc
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 */
/*!
 * \spec
 *    requires $lengthOf(backendSubject) >= sizeof(Ssa_Data30ByteType);
 * \endspec
 */
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << End of documentation area >>                    DO NOT CHANGE THIS COMMENT!
 *********************************************************************************************************************/

FUNC(Std_ReturnType, Ssa_KeyM_CODE) Ssa_KeyM_Certificate_GetBackendSubject(
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) backendSubject,
  P2VAR(uint16, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) dataLength) /* PRQA S 0624, 3206 */ /* MD_Rte_0624, MD_Rte_3206 */
{
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << Start of runnable implementation >>             DO NOT CHANGE THIS COMMENT!
 * Symbol: Ssa_KeyM_Certificate_GetBackendSubject (returns application error)
 *********************************************************************************************************************/
  Std_ReturnType rVal = RTE_E_KeyM_Certificate_E_NOT_OK;

  /* ----- Development Error Checks ------------------------------------- */
#if (SSA_DEV_ERROR_DETECT == STD_ON)
  if ((backendSubject == NULL_PTR) || (dataLength == NULL_PTR))
  {
    /* retVal already set */
  }
  else
#endif /* SSA_DEV_ERROR_DETECT == STD_ON */
  {
    uint16 byteIdx;
#if (SSA_KEEP_BUFFER_VARIABLES_STATIC == STD_OFF)
    uint8 KeyM_BackendCertBuf[SSA_SIZEOF_CERT_MAX];
#endif
    uint16 backendCertLength = SSA_SIZEOF_CERT_MAX;

    /* #10 Get parsed Backend CA certificate. */
    rVal = KeyM_GetAndParseStoredCert(CERTP_PKI_ROLE_BACKEND,
      (P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR))KeyM_BackendCertBuf,
      (P2VAR(uint16, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR))&backendCertLength,
      FALSE);

    if ((rVal == E_OK) && (KeyM_ParsedBackendCert.subject.validContent))
    {
      /* #20 Copy the subject to the output buffer, considering its length, and set the output data length. */
      for (byteIdx = 0u; byteIdx < sizeof(Ssa_Data30ByteType); byteIdx++)
      {
        if ((byteIdx < *dataLength) && (byteIdx < KeyM_ParsedBackendCert.subject.elemDataLength))
        {
          backendSubject[byteIdx] = KeyM_BackendCertBuf[KeyM_ParsedBackendCert.subject.elemDataIdx + byteIdx];
        }
        else
        {
          /* Leave for-loop. */
          break;
        }
      }
      *dataLength = byteIdx;
    }
    else
    {
      rVal = E_NOT_OK;
      *dataLength = 0u;
    }
  }

  return rVal;

/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << End of runnable implementation >>               DO NOT CHANGE THIS COMMENT!
 *********************************************************************************************************************/
}

/**********************************************************************************************************************
 *
 * Runnable Entity Name: Ssa_KeyM_Certificate_SignData1024ByteWithEcuPrivateKey
 *
 *---------------------------------------------------------------------------------------------------------------------
 *
 * Executed if at least one of the following trigger conditions occurred:
 *   - triggered by server invocation for OperationPrototype <SignData1024ByteWithEcuPrivateKey> of PortPrototype <KeyM_Certificate>
 *
 **********************************************************************************************************************
 *
 * Client/Server Interfaces:
 * =========================
 *   Server Invocation:
 *   ------------------
 *   Std_ReturnType Rte_Call_SsaCdd_Csm_SignatureGenerate(uint32 jobId, Crypto_OperationModeType operationMode, Ssa_ConstDataPtr dataBuffer, uint32 dataLength, Ssa_DataPtr resultBuffer, Ssa_LengthPtr resultLength)
 *     Synchronous Server Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_SsaCdd_CryptoInterface_E_NOT_OK
 *
 **********************************************************************************************************************
 *
 * Runnable prototype:
 * ===================
 *   Std_ReturnType Ssa_KeyM_Certificate_SignData1024ByteWithEcuPrivateKey(const uint8 *data, uint16 dataLength, uint8 *signature)
 *     Argument data: uint8* is of type Ssa_Data1024ByteType
 *     Argument signature: uint8* is of type Ssa_Data64ByteType
 *
 **********************************************************************************************************************
 *
 * Available Application Errors:
 * =============================
 *   RTE_E_KeyM_Certificate_E_NOT_OK
 *   RTE_E_KeyM_Certificate_E_PENDING
 *
 *********************************************************************************************************************/
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << Start of documentation area >>                  DO NOT CHANGE THIS COMMENT!
 * Symbol: Ssa_KeyM_Certificate_SignData1024ByteWithEcuPrivateKey_doc
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
/*!
 * \spec
 *    requires $lengthOf(signature) >= sizeof(Ssa_Data64ByteType);
 * \endspec
 */
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << End of documentation area >>                    DO NOT CHANGE THIS COMMENT!
 *********************************************************************************************************************/

FUNC(Std_ReturnType, Ssa_KeyM_CODE) Ssa_KeyM_Certificate_SignData1024ByteWithEcuPrivateKey(P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) data, uint16 dataLength, P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) signature) /* PRQA S 0624, 3206 */ /* MD_Rte_0624, MD_Rte_3206 */
{
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << Start of runnable implementation >>             DO NOT CHANGE THIS COMMENT!
 * Symbol: Ssa_KeyM_Certificate_SignData1024ByteWithEcuPrivateKey (returns application error)
 *********************************************************************************************************************/

  return Ssa_KeyM_Certificate_SignDataWithEcuPrivateKey(data, dataLength, signature);

/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << End of runnable implementation >>               DO NOT CHANGE THIS COMMENT!
 *********************************************************************************************************************/
}

/**********************************************************************************************************************
 *
 * Runnable Entity Name: Ssa_KeyM_Certificate_SignData4092ByteWithEcuPrivateKey
 *
 *---------------------------------------------------------------------------------------------------------------------
 *
 * Executed if at least one of the following trigger conditions occurred:
 *   - triggered by server invocation for OperationPrototype <SignData4092ByteWithEcuPrivateKey> of PortPrototype <KeyM_Certificate>
 *
 **********************************************************************************************************************
 *
 * Client/Server Interfaces:
 * =========================
 *   Server Invocation:
 *   ------------------
 *   Std_ReturnType Rte_Call_SsaCdd_Csm_SignatureGenerate(uint32 jobId, Crypto_OperationModeType operationMode, Ssa_ConstDataPtr dataBuffer, uint32 dataLength, Ssa_DataPtr resultBuffer, Ssa_LengthPtr resultLength)
 *     Synchronous Server Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_SsaCdd_CryptoInterface_E_NOT_OK
 *
 **********************************************************************************************************************
 *
 * Runnable prototype:
 * ===================
 *   Std_ReturnType Ssa_KeyM_Certificate_SignData4092ByteWithEcuPrivateKey(const uint8 *data, uint16 dataLength, uint8 *signature)
 *     Argument data: uint8* is of type Ssa_Data4092ByteType
 *     Argument signature: uint8* is of type Ssa_Data64ByteType
 *
 **********************************************************************************************************************
 *
 * Available Application Errors:
 * =============================
 *   RTE_E_KeyM_Certificate_E_NOT_OK
 *   RTE_E_KeyM_Certificate_E_PENDING
 *
 *********************************************************************************************************************/
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << Start of documentation area >>                  DO NOT CHANGE THIS COMMENT!
 * Symbol: Ssa_KeyM_Certificate_SignData4092ByteWithEcuPrivateKey_doc
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
/*!
 * \spec
 *    requires $lengthOf(signature) >= sizeof(Ssa_Data64ByteType);
 * \endspec
 */
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << End of documentation area >>                    DO NOT CHANGE THIS COMMENT!
 *********************************************************************************************************************/

FUNC(Std_ReturnType, Ssa_KeyM_CODE) Ssa_KeyM_Certificate_SignData4092ByteWithEcuPrivateKey(P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) data, uint16 dataLength, P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) signature) /* PRQA S 0624, 3206 */ /* MD_Rte_0624, MD_Rte_3206 */
{
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << Start of runnable implementation >>             DO NOT CHANGE THIS COMMENT!
 * Symbol: Ssa_KeyM_Certificate_SignData4092ByteWithEcuPrivateKey (returns application error)
 *********************************************************************************************************************/

  return Ssa_KeyM_Certificate_SignDataWithEcuPrivateKey(data, dataLength, signature);

/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << End of runnable implementation >>               DO NOT CHANGE THIS COMMENT!
 *********************************************************************************************************************/
}

/**********************************************************************************************************************
 *
 * Runnable Entity Name: Ssa_KeyM_Certificate_VerifyCertWithBackendCert
 *
 *---------------------------------------------------------------------------------------------------------------------
 *
 * Executed if at least one of the following trigger conditions occurred:
 *   - triggered by server invocation for OperationPrototype <VerifyCertWithBackendCert> of PortPrototype <KeyM_Certificate>
 *
 **********************************************************************************************************************
 *
 * Client/Server Interfaces:
 * =========================
 *   Server Invocation:
 *   ------------------
 *   Std_ReturnType Rte_Call_CertP_Functions_Certificate_Parse(const uint8 *rawCertData, uint16 rawCertLength, CertP_ParsedCertStructureType *parsedCert)
 *     Argument rawCertData: uint8* is of type CertP_RawCertBufferType
 *     Synchronous Server Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_CertP_Functions_E_NOT_OK
 *   Std_ReturnType Rte_Call_CertP_Functions_Certificate_Verify(const uint8 *rawCertData, CertP_ParsedCertStructureType *parsedCert, const uint8 *rawCertIssuer, const CertP_ParsedCertStructureType *parsedCertIssuer, CertP_PkiRoleType expectedPkiRole)
 *     Argument rawCertData: uint8* is of type CertP_RawCertBufferType
 *     Argument rawCertIssuer: uint8* is of type CertP_RawCertBufferType
 *     Synchronous Server Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_CertP_Functions_E_NOT_OK, RTE_E_CertP_Functions_E_PENDING
 *   Std_ReturnType Rte_Call_CertP_Functions_Certificate_Verify_Extended(const uint8 *rawCertData, CertP_ParsedCertStructureType *parsedCert, const uint8 *rawCertIssuer, const CertP_ParsedCertStructureType *parsedCertIssuer, CertP_PkiRoleType expectedPkiRole, const RightsM_AuthNonceType *expectedNonce)
 *     Argument rawCertData: uint8* is of type CertP_RawCertBufferType
 *     Argument rawCertIssuer: uint8* is of type CertP_RawCertBufferType
 *     Synchronous Server Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_CertP_Functions_E_NOT_OK, RTE_E_CertP_Functions_E_PENDING
 *
 * Service Calls:
 * ==============
 *   Service Invocation:
 *   -------------------
 *   Std_ReturnType Rte_Call_Key_BackendCert_KeyElementGet(uint32 keyElementId, uint8 *keyPtr, uint32 *keyLength)
 *     Argument keyPtr: uint8* is of type Csm_KeyDataType_Ssa_BackendCert
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_CsmKeyManagement_Ssa_BackendCert_CSM_E_BUSY, RTE_E_CsmKeyManagement_Ssa_BackendCert_CSM_E_KEY_EMPTY, RTE_E_CsmKeyManagement_Ssa_BackendCert_CSM_E_KEY_NOT_AVAILABLE, RTE_E_CsmKeyManagement_Ssa_BackendCert_CSM_E_KEY_READ_FAIL, RTE_E_CsmKeyManagement_Ssa_BackendCert_CSM_E_SMALL_BUFFER, RTE_E_CsmKeyManagement_Ssa_BackendCert_E_NOT_OK
 *   Std_ReturnType Rte_Call_Key_EcuCert_KeyElementGet(uint32 keyElementId, uint8 *keyPtr, uint32 *keyLength)
 *     Argument keyPtr: uint8* is of type Csm_KeyDataType_Ssa_EcuCert
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_CsmKeyManagement_Ssa_EcuCert_CSM_E_BUSY, RTE_E_CsmKeyManagement_Ssa_EcuCert_CSM_E_KEY_EMPTY, RTE_E_CsmKeyManagement_Ssa_EcuCert_CSM_E_KEY_NOT_AVAILABLE, RTE_E_CsmKeyManagement_Ssa_EcuCert_CSM_E_KEY_READ_FAIL, RTE_E_CsmKeyManagement_Ssa_EcuCert_CSM_E_SMALL_BUFFER, RTE_E_CsmKeyManagement_Ssa_EcuCert_E_NOT_OK
 *
 **********************************************************************************************************************
 *
 * Runnable prototype:
 * ===================
 *   Std_ReturnType Ssa_KeyM_Certificate_VerifyCertWithBackendCert(const uint8 *cert, CertP_ParsedCertStructureType *parsedCertStructure, uint16 certLength, CertP_PkiRoleType expectedPkiRole, const RightsM_AuthNonceType *expectedNonce)
 *     Argument cert: uint8* is of type CertP_RawCertBufferType
 *
 **********************************************************************************************************************
 *
 * Available Application Errors:
 * =============================
 *   RTE_E_KeyM_Certificate_E_NOT_OK
 *   RTE_E_KeyM_Certificate_E_PENDING
 *
 *********************************************************************************************************************/
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << Start of documentation area >>                  DO NOT CHANGE THIS COMMENT!
 * Symbol: Ssa_KeyM_Certificate_VerifyCertWithBackendCert_doc
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 */
/*!
 * \spec
 *    requires $lengthOf(cert) >= sizeof(CertP_RawCertBufferType);
 * \endspec
 */
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << End of documentation area >>                    DO NOT CHANGE THIS COMMENT!
 *********************************************************************************************************************/

FUNC(Std_ReturnType, Ssa_KeyM_CODE) Ssa_KeyM_Certificate_VerifyCertWithBackendCert(
  P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) cert,
  P2VAR(CertP_ParsedCertStructureType, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) parsedCertStructure,
  uint16 certLength,
  CertP_PkiRoleType expectedPkiRole,
  P2CONST(RightsM_AuthNonceType, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) expectedNonce) /* PRQA S 0624, 3206 */ /* MD_Rte_0624, MD_Rte_3206 */
{
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << Start of runnable implementation >>             DO NOT CHANGE THIS COMMENT!
 * Symbol: Ssa_KeyM_Certificate_VerifyCertWithBackendCert (returns application error)
 *********************************************************************************************************************/
  Std_ReturnType retVal = RTE_E_KeyM_Certificate_E_NOT_OK;

  /* ----- Development Error Checks ------------------------------------- */
#if (SSA_DEV_ERROR_DETECT == STD_ON)
  if ((cert == NULL_PTR)
    || (parsedCertStructure == NULL_PTR)
    || (expectedNonce == NULL_PTR))
  {
    /* retVal already set */
  }
  else
#endif /* SSA_DEV_ERROR_DETECT == STD_ON */
  {
#if (SSA_KEEP_BUFFER_VARIABLES_STATIC == STD_OFF)
    uint8 KeyM_BackendCertBuf[SSA_SIZEOF_CERT_MAX];
#endif
    uint16 backendCertLength = SSA_SIZEOF_CERT_MAX;

      retVal = RTE_E_OK;

    /* #10 Get the parsed, stored ECU certificate only if the certificate to be verified is no ECU certificate. */

    /* #20 Get parsed, stored Backend CA certificate. */
    if (KeyM_GetAndParseStoredCert(CERTP_PKI_ROLE_BACKEND,
      (P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR))KeyM_BackendCertBuf,
      (P2VAR(uint16, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR))&backendCertLength,
      FALSE) != E_OK)
    {
      /* set verification result of parsed certificate to be verified */
      parsedCertStructure->verificationResult = CERTP_VER_INVALID_CHAIN_OF_TRUST;
    }
    /* #30 Verify the passed certificate against the Backend CA certificate.
     * If the passed certificate is not an ECU certificate, verify it against the stored ECU certificate.
     * If a nonce has be passed by the caller, check the nonce of the certificate against it. */
    else
    {
      if (expectedPkiRole == CERTP_PKI_ROLE_ECU)
      {
        /* Check against RTE in buffer CertP_RawCertBufferType: 
         *   cert comes in as parameter calling Ssa_KeyM_Certificate_VerifyCertWithBackendCert, checked when called.
         *   KeyM_BackendCertBuf points always to a buffer of size SSA_SIZEOF_CERT_MAX */
        /*@ assert sizeof(cert) >= sizeof(CertP_RawCertBufferType); */ /* VCA_SSA_KEYM_LENGTH_SPECIFIED_IN_FCT_CALL */
        retVal = Rte_Call_CertP_Functions_Certificate_Verify(cert, parsedCertStructure, KeyM_BackendCertBuf, &KeyM_ParsedBackendCert, expectedPkiRole); 
      }
      else
      {
        /* Check against RTE in buffer CertP_RawCertBufferType: 
         *   cert comes in as parameter calling Ssa_KeyM_Certificate_VerifyCertWithBackendCert, checked when called.
         *   KeyM_BackendCertBuf points always to a buffer of size SSA_SIZEOF_CERT_MAX */
        /*@ assert sizeof(cert) >= sizeof(CertP_RawCertBufferType); */ /* VCA_SSA_KEYM_LENGTH_SPECIFIED_IN_FCT_CALL */
        retVal = Rte_Call_CertP_Functions_Certificate_Verify_Extended(cert, parsedCertStructure, KeyM_BackendCertBuf, &KeyM_ParsedBackendCert, expectedPkiRole, expectedNonce); 
      }

      if (retVal == RTE_E_CertP_Functions_E_PENDING)
      {
        retVal = RTE_E_KeyM_Certificate_E_PENDING;
      }
      else if (retVal != RTE_E_OK)
      {
        /* Error */
        retVal = RTE_E_KeyM_Certificate_E_NOT_OK;
      }
      else
      {
        /* OK */
        retVal = RTE_E_OK;
      }
    }
  }
  SSA_DUMMY_STATEMENT(certLength);    /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */

  return retVal;
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << End of runnable implementation >>               DO NOT CHANGE THIS COMMENT!
 *********************************************************************************************************************/
}

#if (SSA_ECU_TYPE != SSA_ECU_TYPE_VSM)

/**********************************************************************************************************************
 *
 * Runnable Entity Name: Ssa_KeyM_Com_VehicleSharedSecretNotification
 *
 *---------------------------------------------------------------------------------------------------------------------
 *
 * Executed if at least one of the following trigger conditions occurred:
 *   - triggered on DataReceivedEvent for DataElementPrototype <sharedSecret> of PortPrototype <KeyM_Com_ReceiveSharedSecret>
 *
 **********************************************************************************************************************
 *
 * Input Interfaces:
 * =================
 *   Explicit S/R API:
 *   -----------------
 *   Std_ReturnType Rte_Read_KeyM_Com_ReceiveSharedSecret_sharedSecret(uint8 *data)
 *     Argument data: uint8* is of type KeyM_SharedSecretType
 *
 * Client/Server Interfaces:
 * =========================
 *   Server Invocation:
 *   ------------------
 *   Std_ReturnType Rte_Call_RightsM_DiagnosticChannel_GetDiagnosticUserRolesBitMask(RightsM_ACL_BitMaskType *userRolesBitMask)
 *     Synchronous Server Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_RightsM_DiagnosticChannel_E_NOT_OK
 *
 * Exclusive Area Access:
 * ======================
 *   void Rte_Enter_KeyM_ExclusiveArea(void)
 *   void Rte_Exit_KeyM_ExclusiveArea(void)
 *
 *********************************************************************************************************************/
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << Start of documentation area >>                  DO NOT CHANGE THIS COMMENT!
 * Symbol: Ssa_KeyM_Com_VehicleSharedSecretNotification_doc
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << End of documentation area >>                    DO NOT CHANGE THIS COMMENT!
 *********************************************************************************************************************/

FUNC(void, Ssa_KeyM_CODE) Ssa_KeyM_Com_VehicleSharedSecretNotification(void) /* PRQA S 0624, 3206 */ /* MD_Rte_0624, MD_Rte_3206 */
{
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << Start of runnable implementation >>             DO NOT CHANGE THIS COMMENT!
 * Symbol: Ssa_KeyM_Com_VehicleSharedSecretNotification
 *********************************************************************************************************************/
  Std_ReturnType rVal;
  RightsM_ACL_BitMaskType userRolesBitMask = 0u;

  /* #10 First get the user roles bit mask since the shared secret broadcast is only accepted during an active
   *     diagnostic session with corresponding tester user role. Only the user role production is allowed. */
  rVal = Rte_Call_RightsM_DiagnosticChannel_GetDiagnosticUserRolesBitMask(&userRolesBitMask);
  if ((rVal == E_OK) && ((userRolesBitMask & RIGHTSM_ACL_BITMASK_PRODUCTION) != 0u))
  {
    uint8 sharedSecret[SSA_SIZEOF_SECRET];

    /* #20 Read the received shared secret. */
    if(Rte_Read_KeyM_Com_ReceiveSharedSecret_sharedSecret(sharedSecret) == E_OK)
    {
      /* #40 Generate and store the symmetric keys. Store also the hash of the shared secret.
       *     Request the application to store the keys permanently.
       *     Neither set nor evaluate result.
       *     Discard received secret if main loop processing of the secret is already ongoing. */

      if (KeyM_GetMainLoopStateLock() == TRUE)
      {
        Ssa_MemCpy((P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR))KeyM_CarSpecificSecret, (P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA))sharedSecret, SSA_SIZEOF_SECRET);

        KeyM_MainLoopProc.conf = KEY_MAINLOOP_PROC_CONF_COMPLETE|KEY_MAINLOOP_PROC_CONF_RESET_TICK_COUNT|KEY_MAINLOOP_PROC_CONF_BROADCAST_PROC;
        KeyM_MainLoopProc.state = KEYM_GENERATE_SYM_KEYS_STATE_HASH_SECRET;
      }
      /* #50 Clear shared secret from RAM. */
      KeyM_ClearDataBuffer(sharedSecret, SSA_SIZEOF_SECRET, SSA_SIZEOF_SECRET);
    }
  }
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << End of runnable implementation >>               DO NOT CHANGE THIS COMMENT!
 *********************************************************************************************************************/
}

#endif

#if (SSA_ENABLE_ASYNC_CSM_KEYM_ANAGEMENT_PRIMITIVES == STD_ON)

/**********************************************************************************************************************
 *
 * Runnable Entity Name: Ssa_KeyM_CsmCallbackNotification_KeyExchangeCalcPubVal
 *
 *---------------------------------------------------------------------------------------------------------------------
 *
 * Executed if at least one of the following trigger conditions occurred:
 *   - triggered by server invocation for OperationPrototype <CallbackNotification> of PortPrototype <CallbackNotification_KeyExchangeCalcPubVal>
 *
 **********************************************************************************************************************
 *
 * Runnable prototype:
 * ===================
 *   void Ssa_KeyM_CsmCallbackNotification_KeyExchangeCalcPubVal(Csm_ResultType result)
 *
 *********************************************************************************************************************/
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << Start of documentation area >>                  DO NOT CHANGE THIS COMMENT!
 * Symbol: Ssa_KeyM_CsmCallbackNotification_KeyExchangeCalcPubVal_doc
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */

/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << End of documentation area >>                    DO NOT CHANGE THIS COMMENT!
 *********************************************************************************************************************/

FUNC(void, Ssa_KeyM_CODE) Ssa_KeyM_CsmCallbackNotification_KeyExchangeCalcPubVal(Csm_ResultType result) /* PRQA S 0624, 3206 */ /* MD_Rte_0624, MD_Rte_3206 */
{
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << Start of runnable implementation >>             DO NOT CHANGE THIS COMMENT!
 * Symbol: Ssa_KeyM_CsmCallbackNotification_KeyExchangeCalcPubVal
 *********************************************************************************************************************/

  /* #10 Handle the Csm key exchange calculate public value state dependent on the callback's result only if a callback is awaited. */
  if (KeyM_CalcPubValAsyncState == SSA_ASYNC_STATE_WAIT)
  {
    if (result == E_OK)
    {
      KeyM_CalcPubValAsyncState = SSA_ASYNC_STATE_READY;
    }
    else
    {
      KeyM_CalcPubValAsyncState = SSA_ASYNC_STATE_FAILED;
    }
  }
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << End of runnable implementation >>               DO NOT CHANGE THIS COMMENT!
 *********************************************************************************************************************/
}

/**********************************************************************************************************************
 *
 * Runnable Entity Name: Ssa_KeyM_CsmCallbackNotification_KeyExchangeCalcSecret
 *
 *---------------------------------------------------------------------------------------------------------------------
 *
 * Executed if at least one of the following trigger conditions occurred:
 *   - triggered by server invocation for OperationPrototype <CallbackNotification> of PortPrototype <CallbackNotification_KeyExchangeCalcSecret>
 *
 **********************************************************************************************************************
 *
 * Runnable prototype:
 * ===================
 *   void Ssa_KeyM_CsmCallbackNotification_KeyExchangeCalcSecret(Csm_ResultType result)
 *
 *********************************************************************************************************************/
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << Start of documentation area >>                  DO NOT CHANGE THIS COMMENT!
 * Symbol: Ssa_KeyM_CsmCallbackNotification_KeyExchangeCalcSecret_doc
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */

/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << End of documentation area >>                    DO NOT CHANGE THIS COMMENT!
 *********************************************************************************************************************/

FUNC(void, Ssa_KeyM_CODE) Ssa_KeyM_CsmCallbackNotification_KeyExchangeCalcSecret(Csm_ResultType result) /* PRQA S 0624, 3206 */ /* MD_Rte_0624, MD_Rte_3206 */
{
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << Start of runnable implementation >>             DO NOT CHANGE THIS COMMENT!
 * Symbol: Ssa_KeyM_CsmCallbackNotification_KeyExchangeCalcSecret
 *********************************************************************************************************************/

  /* #10 Handle the Csm key exchange calculate secret state dependent on the callback's result only if a callback is awaited. */
  if (KeyM_CalcSecretAsyncState == SSA_ASYNC_STATE_WAIT)
  {
    if (result == E_OK)
    {
      KeyM_CalcSecretAsyncState = SSA_ASYNC_STATE_READY;
    }
    else
    {
      KeyM_CalcSecretAsyncState = SSA_ASYNC_STATE_FAILED;
    }
  }
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << End of runnable implementation >>               DO NOT CHANGE THIS COMMENT!
 *********************************************************************************************************************/
}

/**********************************************************************************************************************
 *
 * Runnable Entity Name: Ssa_KeyM_CsmCallbackNotification_KeyGenerate_TrustModelEcuCsr
 *
 *---------------------------------------------------------------------------------------------------------------------
 *
 * Executed if at least one of the following trigger conditions occurred:
 *   - triggered by server invocation for OperationPrototype <CallbackNotification> of PortPrototype <CallbackNotification_KeyGenerate_TrustModelEcuCsr>
 *
 **********************************************************************************************************************
 *
 * Runnable prototype:
 * ===================
 *   void Ssa_KeyM_CsmCallbackNotification_KeyGenerate_TrustModelEcuCsr(Csm_ResultType result)
 *
 *********************************************************************************************************************/
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << Start of documentation area >>                  DO NOT CHANGE THIS COMMENT!
 * Symbol: Ssa_KeyM_CsmCallbackNotification_KeyGenerate_TrustModelEcuCsr_doc
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << End of documentation area >>                    DO NOT CHANGE THIS COMMENT!
 *********************************************************************************************************************/

FUNC(void, Ssa_KeyM_CODE) Ssa_KeyM_CsmCallbackNotification_KeyGenerate_TrustModelEcuCsr(Csm_ResultType result) /* PRQA S 0624, 3206 */ /* MD_Rte_0624, MD_Rte_3206 */
{
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << Start of runnable implementation >>             DO NOT CHANGE THIS COMMENT!
 * Symbol: Ssa_KeyM_CsmCallbackNotification_KeyGenerate_TrustModelEcuCsr
 *********************************************************************************************************************/
# if ((SSA_DIAG_SERVICE_TRUST_MODEL_GENERATE_KEY_PAIR == STD_ON) && (SSA_GENERATE_KEY_PAIR_CUSTOM_CALLOUT == STD_OFF))
  /* Handle the Csm key generate state dependent on the callback's result only if a callback is awaited. */
  if (KeyM_GenerateTrustModelEcuCsrKeyAsyncState == SSA_ASYNC_STATE_WAIT)
  {
    if (result == E_OK)
    {
      KeyM_GenerateTrustModelEcuCsrKeyAsyncState = SSA_ASYNC_STATE_READY;
    }
    else
    {
      KeyM_GenerateTrustModelEcuCsrKeyAsyncState = SSA_ASYNC_STATE_FAILED;
    }
  }
# else
  SSA_DUMMY_STATEMENT(result);    /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */
# endif
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << End of runnable implementation >>               DO NOT CHANGE THIS COMMENT!
 *********************************************************************************************************************/
}

#endif

#if (SSA_ENABLE_ASYNC_CSM_JOB_PROCESSING == STD_ON)

/**********************************************************************************************************************
 *
 * Runnable Entity Name: Ssa_KeyM_CsmCallbackNotification_RandomGenerate
 *
 *---------------------------------------------------------------------------------------------------------------------
 *
 * Executed if at least one of the following trigger conditions occurred:
 *   - triggered by server invocation for OperationPrototype <CallbackNotification> of PortPrototype <CallbackNotification_RandomGenerate>
 *
 **********************************************************************************************************************
 *
 * Runnable prototype:
 * ===================
 *   void Ssa_KeyM_CsmCallbackNotification_RandomGenerate(Csm_ResultType result)
 *
 *********************************************************************************************************************/
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << Start of documentation area >>                  DO NOT CHANGE THIS COMMENT!
 * Symbol: Ssa_KeyM_CsmCallbackNotification_RandomGenerate_doc
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */

/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << End of documentation area >>                    DO NOT CHANGE THIS COMMENT!
 *********************************************************************************************************************/

FUNC(void, Ssa_KeyM_CODE) Ssa_KeyM_CsmCallbackNotification_RandomGenerate(Csm_ResultType result) /* PRQA S 0624, 3206 */ /* MD_Rte_0624, MD_Rte_3206 */
{
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << Start of runnable implementation >>             DO NOT CHANGE THIS COMMENT!
 * Symbol: Ssa_KeyM_CsmCallbackNotification_RandomGenerate
 *********************************************************************************************************************/

  /* #10 Handle the Csm random generate state dependent on the callback's result only if a callback is awaited. */
  if (KeyM_RandomGenerateAsyncState == SSA_ASYNC_STATE_WAIT)
  {
    if (result == E_OK)
    {
      KeyM_RandomGenerateAsyncState = SSA_ASYNC_STATE_READY;
    }
    else
    {
      KeyM_RandomGenerateAsyncState = SSA_ASYNC_STATE_FAILED;
    }
  }
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << End of runnable implementation >>               DO NOT CHANGE THIS COMMENT!
 *********************************************************************************************************************/
}

#endif

#if (SSA_ENABLE_ASYNC_CSM_KEYM_ANAGEMENT_PRIMITIVES == STD_ON)

# if (SSA_ECU_TYPE != SSA_ECU_TYPE_VSM)

/**********************************************************************************************************************
 *
 * Runnable Entity Name: Ssa_KeyM_CsmCallbackNotification_RandomSeed
 *
 *---------------------------------------------------------------------------------------------------------------------
 *
 * Executed if at least one of the following trigger conditions occurred:
 *   - triggered by server invocation for OperationPrototype <CallbackNotification> of PortPrototype <CallbackNotification_RandomSeed>
 *
 **********************************************************************************************************************
 *
 * Runnable prototype:
 * ===================
 *   void Ssa_KeyM_CsmCallbackNotification_RandomSeed(Csm_ResultType result)
 *
 *********************************************************************************************************************/
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << Start of documentation area >>                  DO NOT CHANGE THIS COMMENT!
 * Symbol: Ssa_KeyM_CsmCallbackNotification_RandomSeed_doc
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << End of documentation area >>                    DO NOT CHANGE THIS COMMENT!
 *********************************************************************************************************************/

FUNC(void, Ssa_KeyM_CODE) Ssa_KeyM_CsmCallbackNotification_RandomSeed(Csm_ResultType result) /* PRQA S 0624, 3206 */ /* MD_Rte_0624, MD_Rte_3206 */
{
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << Start of runnable implementation >>             DO NOT CHANGE THIS COMMENT!
 * Symbol: Ssa_KeyM_CsmCallbackNotification_RandomSeed
 *********************************************************************************************************************/
#  if (SSA_DIAG_SERVICE_INJECT_SEED == STD_ON)
  /* #10 Handle the Csm random seed state dependent on the callback's result only if a callback is awaited. */
  if (KeyM_RandomSeedState == SSA_ASYNC_STATE_WAIT)
  {
    if (result == E_OK)
    {
      KeyM_RandomSeedState = SSA_ASYNC_STATE_READY;
    }
    else
    {
      KeyM_RandomSeedState = SSA_ASYNC_STATE_FAILED;
    }
  }
#  else
  SSA_DUMMY_STATEMENT(result);    /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */
#  endif
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << End of runnable implementation >>               DO NOT CHANGE THIS COMMENT!
 *********************************************************************************************************************/
}
# endif

#endif

#if (SSA_ENABLE_ASYNC_CSM_JOB_PROCESSING == STD_ON)

# if (SSA_ECU_TYPE == SSA_ECU_TYPE_VSM)

/**********************************************************************************************************************
 *
 * Runnable Entity Name: Ssa_KeyM_CsmCallbackNotification_SignatureGenerate
 *
 *---------------------------------------------------------------------------------------------------------------------
 *
 * Executed if at least one of the following trigger conditions occurred:
 *   - triggered by server invocation for OperationPrototype <CallbackNotification> of PortPrototype <CallbackNotification_SignatureGenerate>
 *
 **********************************************************************************************************************
 *
 * Runnable prototype:
 * ===================
 *   void Ssa_KeyM_CsmCallbackNotification_SignatureGenerate(Csm_ResultType result)
 *
 *********************************************************************************************************************/
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << Start of documentation area >>                  DO NOT CHANGE THIS COMMENT!
 * Symbol: Ssa_KeyM_CsmCallbackNotification_SignatureGenerate_doc
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */

/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << End of documentation area >>                    DO NOT CHANGE THIS COMMENT!
 *********************************************************************************************************************/

FUNC(void, Ssa_KeyM_CODE) Ssa_KeyM_CsmCallbackNotification_SignatureGenerate(Csm_ResultType result) /* PRQA S 0624, 3206 */ /* MD_Rte_0624, MD_Rte_3206 */
{
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << Start of runnable implementation >>             DO NOT CHANGE THIS COMMENT!
 * Symbol: Ssa_KeyM_CsmCallbackNotification_SignatureGenerate
 *********************************************************************************************************************/

  /* #10 Handle the Csm signature generate state dependent on the callback's result only if a callback is awaited. */
  if (KeyM_SigGenAsyncState == SSA_ASYNC_STATE_WAIT)
  {
    if (result == E_OK)
    {
      KeyM_SigGenAsyncState = SSA_ASYNC_STATE_READY;
    }
    else
    {
      KeyM_SigGenAsyncState = SSA_ASYNC_STATE_FAILED;
    }
  }
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << End of runnable implementation >>               DO NOT CHANGE THIS COMMENT!
 *********************************************************************************************************************/
}

# endif

/**********************************************************************************************************************
 *
 * Runnable Entity Name: Ssa_KeyM_CsmCallbackNotification_SignatureGenerate_TrustModelEcuCsr
 *
 *---------------------------------------------------------------------------------------------------------------------
 *
 * Executed if at least one of the following trigger conditions occurred:
 *   - triggered by server invocation for OperationPrototype <CallbackNotification> of PortPrototype <CallbackNotification_SignatureGenerate_TrustModelEcuCsr>
 *
 **********************************************************************************************************************
 *
 * Runnable prototype:
 * ===================
 *   void Ssa_KeyM_CsmCallbackNotification_SignatureGenerate_TrustModelEcuCsr(Csm_ResultType result)
 *
 *********************************************************************************************************************/
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << Start of documentation area >>                  DO NOT CHANGE THIS COMMENT!
 * Symbol: Ssa_KeyM_CsmCallbackNotification_SignatureGenerate_TrustModelEcuCsr_doc
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */

/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << End of documentation area >>                    DO NOT CHANGE THIS COMMENT!
 *********************************************************************************************************************/

FUNC(void, Ssa_KeyM_CODE) Ssa_KeyM_CsmCallbackNotification_SignatureGenerate_TrustModelEcuCsr(Csm_ResultType result) /* PRQA S 0624, 3206 */ /* MD_Rte_0624, MD_Rte_3206 */
{
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << Start of runnable implementation >>             DO NOT CHANGE THIS COMMENT!
 * Symbol: Ssa_KeyM_CsmCallbackNotification_SignatureGenerate_TrustModelEcuCsr
 *********************************************************************************************************************/

  /* #10 Handle the Csm signature generate state dependent on the callback's result only if a callback is awaited. */
  if (KeyM_SigGenAsyncState == SSA_ASYNC_STATE_WAIT)
  {
    if (result == E_OK)
    {
      KeyM_SigGenAsyncState = SSA_ASYNC_STATE_READY;
    }
    else
    {
      KeyM_SigGenAsyncState = SSA_ASYNC_STATE_FAILED;
    }
  }

/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << End of runnable implementation >>               DO NOT CHANGE THIS COMMENT!
 *********************************************************************************************************************/
}

/**********************************************************************************************************************
 *
 * Runnable Entity Name: Ssa_KeyM_CsmCallbackNotification_SignatureGenerate_TrustModelEcuLive
 *
 *---------------------------------------------------------------------------------------------------------------------
 *
 * Executed if at least one of the following trigger conditions occurred:
 *   - triggered by server invocation for OperationPrototype <CallbackNotification> of PortPrototype <CallbackNotification_SignatureGenerate_TrustModelEcuLive>
 *
 **********************************************************************************************************************
 *
 * Runnable prototype:
 * ===================
 *   void Ssa_KeyM_CsmCallbackNotification_SignatureGenerate_TrustModelEcuLive(Csm_ResultType result)
 *
 *********************************************************************************************************************/
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << Start of documentation area >>                  DO NOT CHANGE THIS COMMENT!
 * Symbol: Ssa_KeyM_CsmCallbackNotification_SignatureGenerate_TrustModelEcuLive_doc
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */

/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << End of documentation area >>                    DO NOT CHANGE THIS COMMENT!
 *********************************************************************************************************************/

FUNC(void, Ssa_KeyM_CODE) Ssa_KeyM_CsmCallbackNotification_SignatureGenerate_TrustModelEcuLive(Csm_ResultType result) /* PRQA S 0624, 3206 */ /* MD_Rte_0624, MD_Rte_3206 */
{
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << Start of runnable implementation >>             DO NOT CHANGE THIS COMMENT!
 * Symbol: Ssa_KeyM_CsmCallbackNotification_SignatureGenerate_TrustModelEcuLive
 *********************************************************************************************************************/
  /* #10 Handle the Csm signature generate state dependent on the callback's result only if a callback is awaited. */
  if (KeyM_SigGenAsyncState == SSA_ASYNC_STATE_WAIT)
  {
    if (result == E_OK)
    {
      KeyM_SigGenAsyncState = SSA_ASYNC_STATE_READY;
    }
    else
    {
      KeyM_SigGenAsyncState = SSA_ASYNC_STATE_FAILED;
    }
  }

/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << End of runnable implementation >>               DO NOT CHANGE THIS COMMENT!
 *********************************************************************************************************************/
}

/**********************************************************************************************************************
 *
 * Runnable Entity Name: Ssa_KeyM_CsmCallbackNotification_SignatureVerify
 *
 *---------------------------------------------------------------------------------------------------------------------
 *
 * Executed if at least one of the following trigger conditions occurred:
 *   - triggered by server invocation for OperationPrototype <CallbackNotification> of PortPrototype <CallbackNotification_SignatureVerify>
 *
 **********************************************************************************************************************
 *
 * Runnable prototype:
 * ===================
 *   void Ssa_KeyM_CsmCallbackNotification_SignatureVerify(Csm_ResultType result)
 *
 *********************************************************************************************************************/
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << Start of documentation area >>                  DO NOT CHANGE THIS COMMENT!
 * Symbol: Ssa_KeyM_CsmCallbackNotification_SignatureVerify_doc
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */

/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << End of documentation area >>                    DO NOT CHANGE THIS COMMENT!
 *********************************************************************************************************************/

FUNC(void, Ssa_KeyM_CODE) Ssa_KeyM_CsmCallbackNotification_SignatureVerify(Csm_ResultType result) /* PRQA S 0624, 3206 */ /* MD_Rte_0624, MD_Rte_3206 */
{
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << Start of runnable implementation >>             DO NOT CHANGE THIS COMMENT!
 * Symbol: Ssa_KeyM_CsmCallbackNotification_SignatureVerify
 *********************************************************************************************************************/

  /* #10 Handle the Csm signature verify state dependent on the callback's result only if a callback is awaited. */
  if (KeyM_SigVerifAsyncState == SSA_ASYNC_STATE_WAIT)
  {
    if (result == E_OK)
    {
      KeyM_SigVerifAsyncState = SSA_ASYNC_STATE_READY;
    }
    else
    {
      KeyM_SigVerifAsyncState = SSA_ASYNC_STATE_FAILED;
    }
  }
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << End of runnable implementation >>               DO NOT CHANGE THIS COMMENT!
 *********************************************************************************************************************/
}

/**********************************************************************************************************************
 *
 * Runnable Entity Name: Ssa_KeyM_CsmCallbackNotification_SignatureVerify_ReplacementAuthority
 *
 *---------------------------------------------------------------------------------------------------------------------
 *
 * Executed if at least one of the following trigger conditions occurred:
 *   - triggered by server invocation for OperationPrototype <CallbackNotification> of PortPrototype <CallbackNotification_SignatureVerify_ReplacementAuthority>
 *
 **********************************************************************************************************************
 *
 * Runnable prototype:
 * ===================
 *   void Ssa_KeyM_CsmCallbackNotification_SignatureVerify_ReplacementAuthority(Csm_ResultType result)
 *
 *********************************************************************************************************************/
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << Start of documentation area >>                  DO NOT CHANGE THIS COMMENT!
 * Symbol: Ssa_KeyM_CsmCallbackNotification_SignatureVerify_ReplacementAuthority_doc
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */

/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << End of documentation area >>                    DO NOT CHANGE THIS COMMENT!
 *********************************************************************************************************************/

FUNC(void, Ssa_KeyM_CODE) Ssa_KeyM_CsmCallbackNotification_SignatureVerify_ReplacementAuthority(Csm_ResultType result) /* PRQA S 0624, 3206 */ /* MD_Rte_0624, MD_Rte_3206 */
{
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << Start of runnable implementation >>             DO NOT CHANGE THIS COMMENT!
 * Symbol: Ssa_KeyM_CsmCallbackNotification_SignatureVerify_ReplacementAuthority
 *********************************************************************************************************************/

  /* #10 Keep the callback result value, then indicate that the callback has occurred. */
  KeyM_DiagProc.ws.trustModelReplaceRootCert.csmReplacementAuthorityCallbackResult = result;
  KeyM_DiagProc.ws.trustModelReplaceRootCert.csmReplacementAuthorityCallbackOccurred = TRUE;

/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << End of runnable implementation >>               DO NOT CHANGE THIS COMMENT!
 *********************************************************************************************************************/
}

# if (SSA_ECU_TYPE != SSA_ECU_TYPE_VSM)

/**********************************************************************************************************************
 *
 * Runnable Entity Name: Ssa_KeyM_CsmCallbackNotification_SignatureVerify_TrustModelBackend
 *
 *---------------------------------------------------------------------------------------------------------------------
 *
 * Executed if at least one of the following trigger conditions occurred:
 *   - triggered by server invocation for OperationPrototype <CallbackNotification> of PortPrototype <CallbackNotification_SignatureVerify_TrustModelBackend>
 *
 **********************************************************************************************************************
 *
 * Runnable prototype:
 * ===================
 *   void Ssa_KeyM_CsmCallbackNotification_SignatureVerify_TrustModelBackend(Csm_ResultType result)
 *
 *********************************************************************************************************************/
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << Start of documentation area >>                  DO NOT CHANGE THIS COMMENT!
 * Symbol: Ssa_KeyM_CsmCallbackNotification_SignatureVerify_TrustModelBackend_doc
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */

/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << End of documentation area >>                    DO NOT CHANGE THIS COMMENT!
 *********************************************************************************************************************/

FUNC(void, Ssa_KeyM_CODE) Ssa_KeyM_CsmCallbackNotification_SignatureVerify_TrustModelBackend(Csm_ResultType result) /* PRQA S 0624, 3206 */ /* MD_Rte_0624, MD_Rte_3206 */
{
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << Start of runnable implementation >>             DO NOT CHANGE THIS COMMENT!
 * Symbol: Ssa_KeyM_CsmCallbackNotification_SignatureVerify_TrustModelBackend
 *********************************************************************************************************************/
#  if (SSA_DIAG_SERVICE_INJECT_SEED == STD_ON)

  /* #10 Handle the Csm signature verify state dependent on the callback's result only if a callback is awaited. */
  if (KeyM_SigVerifAsyncState == SSA_ASYNC_STATE_WAIT)
  {
    if (result == E_OK)
    {
      KeyM_SigVerifAsyncState = SSA_ASYNC_STATE_READY;
    }
    else
    {
      KeyM_SigVerifAsyncState = SSA_ASYNC_STATE_FAILED;
    }
  }

#  else
  SSA_DUMMY_STATEMENT(result); /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */
#  endif

/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << End of runnable implementation >>               DO NOT CHANGE THIS COMMENT!
 *********************************************************************************************************************/
}

# endif

/**********************************************************************************************************************
 *
 * Runnable Entity Name: Ssa_KeyM_CsmCallbackNotification_SignatureVerify_TrustModelTemp
 *
 *---------------------------------------------------------------------------------------------------------------------
 *
 * Executed if at least one of the following trigger conditions occurred:
 *   - triggered by server invocation for OperationPrototype <CallbackNotification> of PortPrototype <CallbackNotification_SignatureVerify_TrustModelTemp>
 *
 **********************************************************************************************************************
 *
 * Runnable prototype:
 * ===================
 *   void Ssa_KeyM_CsmCallbackNotification_SignatureVerify_TrustModelTemp(Csm_ResultType result)
 *
 *********************************************************************************************************************/
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << Start of documentation area >>                  DO NOT CHANGE THIS COMMENT!
 * Symbol: Ssa_KeyM_CsmCallbackNotification_SignatureVerify_TrustModelTemp_doc
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
/* PRQA S 3408 10 */ /* MD_SSA_DECLARED_IN_GENERATED_HEADER */
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << End of documentation area >>                    DO NOT CHANGE THIS COMMENT!
 *********************************************************************************************************************/

FUNC(void, Ssa_KeyM_CODE) Ssa_KeyM_CsmCallbackNotification_SignatureVerify_TrustModelTemp(Csm_ResultType result) /* PRQA S 0624, 3206 */ /* MD_Rte_0624, MD_Rte_3206 */
{
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << Start of runnable implementation >>             DO NOT CHANGE THIS COMMENT!
 * Symbol: Ssa_KeyM_CsmCallbackNotification_SignatureVerify_TrustModelTemp
 *********************************************************************************************************************/
  /* #10 Handle the Csm signature verify state dependent on the callback's result only if a callback is awaited. */
  if (KeyM_SigVerifAsyncState == SSA_ASYNC_STATE_WAIT)
  {
    if (result == E_OK)
    {
      KeyM_SigVerifAsyncState = SSA_ASYNC_STATE_READY;
    }
    else
    {
      KeyM_SigVerifAsyncState = SSA_ASYNC_STATE_FAILED;
    }
  }

/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << End of runnable implementation >>               DO NOT CHANGE THIS COMMENT!
 *********************************************************************************************************************/
}

#endif

/**********************************************************************************************************************
 *
 * Runnable Entity Name: Ssa_KeyM_DataServices_Backend_CA_Certificate_ConditionCheckRead
 *
 *---------------------------------------------------------------------------------------------------------------------
 *
 * Executed if at least one of the following trigger conditions occurred:
 *   - triggered by server invocation for OperationPrototype <ConditionCheckRead> of PortPrototype <DataServices_Backend_CA_Certificate_Read>
 *
 **********************************************************************************************************************
 *
 * Runnable prototype:
 * ===================
 *   Std_ReturnType Ssa_KeyM_DataServices_Backend_CA_Certificate_ConditionCheckRead(Dcm_OpStatusType OpStatus, Dcm_NegativeResponseCodeType *ErrorCode)
 *
 **********************************************************************************************************************
 *
 * Available Application Errors:
 * =============================
 *   RTE_E_DataServices_Backend_CA_Certificate_Read_DCM_E_PENDING
 *   RTE_E_DataServices_Backend_CA_Certificate_Read_E_NOT_OK
 *
 *********************************************************************************************************************/
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << Start of documentation area >>                  DO NOT CHANGE THIS COMMENT!
 * Symbol: Ssa_KeyM_DataServices_Backend_CA_Certificate_ConditionCheckRead_doc
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */

/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << End of documentation area >>                    DO NOT CHANGE THIS COMMENT!
 *********************************************************************************************************************/

FUNC(Std_ReturnType, Ssa_KeyM_CODE) Ssa_KeyM_DataServices_Backend_CA_Certificate_ConditionCheckRead(
  Dcm_OpStatusType OpStatus,
  P2VAR(Dcm_NegativeResponseCodeType, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) ErrorCode) /* PRQA S 0624, 3206 */ /* MD_Rte_0624, MD_Rte_3206 */
{
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << Start of runnable implementation >>             DO NOT CHANGE THIS COMMENT!
 * Symbol: Ssa_KeyM_DataServices_Backend_CA_Certificate_ConditionCheckRead (returns application error)
 *********************************************************************************************************************/

  Std_ReturnType retVal = RTE_E_DataServices_Backend_CA_Certificate_Read_E_NOT_OK;

 /* ----- Development Error Checks ------------------------------------- */
#if (SSA_DEV_ERROR_DETECT == STD_ON)
  if (ErrorCode == NULL_PTR)
  {
    /* retVal already set */
  }
  else
#endif /* SSA_DEV_ERROR_DETECT == STD_ON */
  {
    /* #10 Always successfully return from condition check. */
    *ErrorCode = DCM_E_POSITIVERESPONSE;
    retVal = RTE_E_OK;
  }

  SSA_DUMMY_STATEMENT(OpStatus);    /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */

  return retVal;

/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << End of runnable implementation >>               DO NOT CHANGE THIS COMMENT!
 *********************************************************************************************************************/
}

/**********************************************************************************************************************
 *
 * Runnable Entity Name: Ssa_KeyM_DataServices_Backend_CA_Certificate_Identification_SubjectKeyIdentifier_ConditionCheckRead
 *
 *---------------------------------------------------------------------------------------------------------------------
 *
 * Executed if at least one of the following trigger conditions occurred:
 *   - triggered by server invocation for OperationPrototype <ConditionCheckRead> of PortPrototype <DataServices_Backend_CA_Certificate_Identification_Read_Backend_CA_SubjectKeyIdentifier>
 *
 **********************************************************************************************************************
 *
 * Runnable prototype:
 * ===================
 *   Std_ReturnType Ssa_KeyM_DataServices_Backend_CA_Certificate_Identification_SubjectKeyIdentifier_ConditionCheckRead(Dcm_OpStatusType OpStatus, Dcm_NegativeResponseCodeType *ErrorCode)
 *
 **********************************************************************************************************************
 *
 * Available Application Errors:
 * =============================
 *   RTE_E_DataServices_Backend_CA_Certificate_Identification_Read_Backend_CA_SubjectKeyIdentifier_DCM_E_PENDING
 *   RTE_E_DataServices_Backend_CA_Certificate_Identification_Read_Backend_CA_SubjectKeyIdentifier_E_NOT_OK
 *
 *********************************************************************************************************************/
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << Start of documentation area >>                  DO NOT CHANGE THIS COMMENT!
 * Symbol: Ssa_KeyM_DataServices_Backend_CA_Certificate_Identification_SubjectKeyIdentifier_ConditionCheckRead_doc
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */

/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << End of documentation area >>                    DO NOT CHANGE THIS COMMENT!
 *********************************************************************************************************************/

FUNC(Std_ReturnType, Ssa_KeyM_CODE) Ssa_KeyM_DataServices_Backend_CA_Certificate_Identification_SubjectKeyIdentifier_ConditionCheckRead(
  Dcm_OpStatusType OpStatus,
  P2VAR(Dcm_NegativeResponseCodeType, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) ErrorCode) /* PRQA S 0624, 3206 */ /* MD_Rte_0624, MD_Rte_3206 */
{
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << Start of runnable implementation >>             DO NOT CHANGE THIS COMMENT!
 * Symbol: Ssa_KeyM_DataServices_Backend_CA_Certificate_Identification_SubjectKeyIdentifier_ConditionCheckRead (returns application error)
 *********************************************************************************************************************/
  Std_ReturnType retVal = RTE_E_DataServices_Backend_CA_Certificate_Identification_Read_Backend_CA_SubjectKeyIdentifier_E_NOT_OK;

  /* ----- Development Error Checks ------------------------------------- */
#if (SSA_DEV_ERROR_DETECT == STD_ON)
  if (ErrorCode == NULL_PTR)
  {
    /* retVal already set */
  }
  else
#endif /* SSA_DEV_ERROR_DETECT == STD_ON */
  {
    /* #10 Always successfully return from condition check. */
    *ErrorCode = DCM_E_POSITIVERESPONSE;
    retVal = RTE_E_OK;
  }

  SSA_DUMMY_STATEMENT(OpStatus);    /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */

  return retVal;

/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << End of runnable implementation >>               DO NOT CHANGE THIS COMMENT!
 *********************************************************************************************************************/
}

/**********************************************************************************************************************
 *
 * Runnable Entity Name: Ssa_KeyM_DataServices_Backend_CA_Certificate_Identification_SubjectKeyIdentifier_ReadData
 *
 *---------------------------------------------------------------------------------------------------------------------
 *
 * Executed if at least one of the following trigger conditions occurred:
 *   - triggered by server invocation for OperationPrototype <ReadData> of PortPrototype <DataServices_Backend_CA_Certificate_Identification_Read_Backend_CA_SubjectKeyIdentifier>
 *
 **********************************************************************************************************************
 *
 * Client/Server Interfaces:
 * =========================
 *   Server Invocation:
 *   ------------------
 *   Std_ReturnType Rte_Call_CertP_Functions_Certificate_Parse(const uint8 *rawCertData, uint16 rawCertLength, CertP_ParsedCertStructureType *parsedCert)
 *     Argument rawCertData: uint8* is of type CertP_RawCertBufferType
 *     Synchronous Server Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_CertP_Functions_E_NOT_OK
 *
 * Service Calls:
 * ==============
 *   Service Invocation:
 *   -------------------
 *   Std_ReturnType Rte_Call_Key_BackendCert_KeyElementGet(uint32 keyElementId, uint8 *keyPtr, uint32 *keyLength)
 *     Argument keyPtr: uint8* is of type Csm_KeyDataType_Ssa_BackendCert
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_CsmKeyManagement_Ssa_BackendCert_CSM_E_BUSY, RTE_E_CsmKeyManagement_Ssa_BackendCert_CSM_E_KEY_EMPTY, RTE_E_CsmKeyManagement_Ssa_BackendCert_CSM_E_KEY_NOT_AVAILABLE, RTE_E_CsmKeyManagement_Ssa_BackendCert_CSM_E_KEY_READ_FAIL, RTE_E_CsmKeyManagement_Ssa_BackendCert_CSM_E_SMALL_BUFFER, RTE_E_CsmKeyManagement_Ssa_BackendCert_E_NOT_OK
 *
 **********************************************************************************************************************
 *
 * Runnable prototype:
 * ===================
 *   Std_ReturnType Ssa_KeyM_DataServices_Backend_CA_Certificate_Identification_SubjectKeyIdentifier_ReadData(Dcm_OpStatusType OpStatus, uint8 *Data)
 *     Argument Data: uint8* is of type Dcm_Data20ByteType
 *
 **********************************************************************************************************************
 *
 * Available Application Errors:
 * =============================
 *   RTE_E_DataServices_Backend_CA_Certificate_Identification_Read_Backend_CA_SubjectKeyIdentifier_DCM_E_PENDING
 *   RTE_E_DataServices_Backend_CA_Certificate_Identification_Read_Backend_CA_SubjectKeyIdentifier_E_NOT_OK
 *
 *********************************************************************************************************************/
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << Start of documentation area >>                  DO NOT CHANGE THIS COMMENT!
 * Symbol: Ssa_KeyM_DataServices_Backend_CA_Certificate_Identification_SubjectKeyIdentifier_ReadData_doc
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 */
/*!
 * \spec
 *    requires $lengthOf(Data) >= sizeof(Dcm_Data20ByteType);
 * \endspec
 */
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << End of documentation area >>                    DO NOT CHANGE THIS COMMENT!
 *********************************************************************************************************************/

FUNC(Std_ReturnType, Ssa_KeyM_CODE) Ssa_KeyM_DataServices_Backend_CA_Certificate_Identification_SubjectKeyIdentifier_ReadData(
  Dcm_OpStatusType OpStatus,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) Data) /* PRQA S 0624, 3206 */ /* MD_Rte_0624, MD_Rte_3206 */
{
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << Start of runnable implementation >>             DO NOT CHANGE THIS COMMENT!
 * Symbol: Ssa_KeyM_DataServices_Backend_CA_Certificate_Identification_SubjectKeyIdentifier_ReadData (returns application error)
 *********************************************************************************************************************/
  Std_ReturnType rVal = RTE_E_DataServices_Backend_CA_Certificate_Identification_Read_Backend_CA_SubjectKeyIdentifier_E_NOT_OK;

  /* ----- Development Error Checks ------------------------------------- */
#if (SSA_DEV_ERROR_DETECT == STD_ON)
  if (Data == NULL_PTR)
  {
    /* retVal already set */
  }
  else
#endif /* SSA_DEV_ERROR_DETECT == STD_ON */
  {
#if (SSA_KEEP_BUFFER_VARIABLES_STATIC == STD_OFF)
    uint8 KeyM_BackendCertBuf[SSA_SIZEOF_CERT_MAX];
#endif
    uint16 backendCertLength = SSA_SIZEOF_CERT_MAX;

    /* #10 Get the parsed, stored Backend CA certificate. */
    rVal = KeyM_GetAndParseStoredCert(CERTP_PKI_ROLE_BACKEND,
      (P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR))KeyM_BackendCertBuf, (P2VAR(uint16, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR))&backendCertLength,
      FALSE);

    if ((rVal == E_OK)
      && (KeyM_ParsedBackendCert.subjectKeyIdentifier.validContent)
      && (KeyM_ParsedBackendCert.subjectKeyIdentifier.elemDataLength <= SSA_SIZEOF_CERT_SUBJECT_KEY_ID))
    {
      /* #20 Copy the subject key identifier to the output buffer considering its size. */
      Ssa_MemCpy(Data, (P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA))&(KeyM_BackendCertBuf[KeyM_ParsedBackendCert.subjectKeyIdentifier.elemDataIdx]), KeyM_ParsedBackendCert.subjectKeyIdentifier.elemDataLength);
    }
    else
    {
      rVal = RTE_E_DataServices_Backend_CA_Certificate_Identification_Read_Backend_CA_SubjectKeyIdentifier_E_NOT_OK;
    }
  }

  SSA_DUMMY_STATEMENT(OpStatus);    /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */

  return rVal;

/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << End of runnable implementation >>               DO NOT CHANGE THIS COMMENT!
 *********************************************************************************************************************/
}

/**********************************************************************************************************************
 *
 * Runnable Entity Name: Ssa_KeyM_DataServices_Backend_CA_Certificate_ReadData
 *
 *---------------------------------------------------------------------------------------------------------------------
 *
 * Executed if at least one of the following trigger conditions occurred:
 *   - triggered by server invocation for OperationPrototype <ReadData> of PortPrototype <DataServices_Backend_CA_Certificate_Read>
 *
 **********************************************************************************************************************
 *
 * Client/Server Interfaces:
 * =========================
 *   Server Invocation:
 *   ------------------
 *   Std_ReturnType Rte_Call_CertP_Functions_Certificate_Parse(const uint8 *rawCertData, uint16 rawCertLength, CertP_ParsedCertStructureType *parsedCert)
 *     Argument rawCertData: uint8* is of type CertP_RawCertBufferType
 *     Synchronous Server Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_CertP_Functions_E_NOT_OK
 *
 * Service Calls:
 * ==============
 *   Service Invocation:
 *   -------------------
 *   Std_ReturnType Rte_Call_Key_BackendCert_KeyElementGet(uint32 keyElementId, uint8 *keyPtr, uint32 *keyLength)
 *     Argument keyPtr: uint8* is of type Csm_KeyDataType_Ssa_BackendCert
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_CsmKeyManagement_Ssa_BackendCert_CSM_E_BUSY, RTE_E_CsmKeyManagement_Ssa_BackendCert_CSM_E_KEY_EMPTY, RTE_E_CsmKeyManagement_Ssa_BackendCert_CSM_E_KEY_NOT_AVAILABLE, RTE_E_CsmKeyManagement_Ssa_BackendCert_CSM_E_KEY_READ_FAIL, RTE_E_CsmKeyManagement_Ssa_BackendCert_CSM_E_SMALL_BUFFER, RTE_E_CsmKeyManagement_Ssa_BackendCert_E_NOT_OK
 *
 **********************************************************************************************************************
 *
 * Runnable prototype:
 * ===================
 *   Std_ReturnType Ssa_KeyM_DataServices_Backend_CA_Certificate_ReadData(Dcm_OpStatusType OpStatus, uint8 *Data)
 *     Argument Data: uint8* is of type Dcm_Data1002ByteType
 *
 **********************************************************************************************************************
 *
 * Available Application Errors:
 * =============================
 *   RTE_E_DataServices_Backend_CA_Certificate_Read_DCM_E_PENDING
 *   RTE_E_DataServices_Backend_CA_Certificate_Read_E_NOT_OK
 *
 *********************************************************************************************************************/
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << Start of documentation area >>                  DO NOT CHANGE THIS COMMENT!
 * Symbol: Ssa_KeyM_DataServices_Backend_CA_Certificate_ReadData_doc
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 */
/*!
 * \spec
 *    requires $lengthOf(Data) >= sizeof(Dcm_Data1002ByteType);
 * \endspec
 */
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << End of documentation area >>                    DO NOT CHANGE THIS COMMENT!
 *********************************************************************************************************************/

FUNC(Std_ReturnType, Ssa_KeyM_CODE) Ssa_KeyM_DataServices_Backend_CA_Certificate_ReadData(
  Dcm_OpStatusType OpStatus,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) Data) /* PRQA S 0624, 3206 */ /* MD_Rte_0624, MD_Rte_3206 */
{
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << Start of runnable implementation >>             DO NOT CHANGE THIS COMMENT!
 * Symbol: Ssa_KeyM_DataServices_Backend_CA_Certificate_ReadData (returns application error)
 *********************************************************************************************************************/
  Std_ReturnType rVal = RTE_E_DataServices_Backend_CA_Certificate_Read_E_NOT_OK;

  /* ----- Development Error Checks ------------------------------------- */
#if (SSA_DEV_ERROR_DETECT == STD_ON)
  if (Data == NULL_PTR)
  {
    /* retVal already set */
  }
  else
#endif /* SSA_DEV_ERROR_DETECT == STD_ON */
  {
    uint16 backendCertLength = SSA_SIZEOF_CERT_MAX;

    /* #10 Get the parsed, stored Backend CA certificate. */
    rVal = KeyM_GetAndParseStoredCert(CERTP_PKI_ROLE_BACKEND,
      &Data[2], (P2VAR(uint16, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR))&backendCertLength,
      FALSE);

    if (rVal == E_OK)
    {
      /* #20 Write the certificate length to the first two bytes of the output buffer. */
      Data[0] = KeyM_GetUint16HiByte(backendCertLength);
      Data[1] = KeyM_GetUint16LoByte(backendCertLength);
    }
    else
    {
      Data[0] = 0u;
      Data[1] = 0u;
      rVal = RTE_E_DataServices_Backend_CA_Certificate_Read_E_NOT_OK;
    }
  }

  SSA_DUMMY_STATEMENT(OpStatus);    /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */

  return rVal;

/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << End of runnable implementation >>               DO NOT CHANGE THIS COMMENT!
 *********************************************************************************************************************/
}

/**********************************************************************************************************************
 *
 * Runnable Entity Name: Ssa_KeyM_DataServices_Backend_CA_Certificate_ReadDataLength
 *
 *---------------------------------------------------------------------------------------------------------------------
 *
 * Executed if at least one of the following trigger conditions occurred:
 *   - triggered by server invocation for OperationPrototype <ReadDataLength> of PortPrototype <DataServices_Backend_CA_Certificate_Read>
 *
 **********************************************************************************************************************
 *
 * Client/Server Interfaces:
 * =========================
 *   Server Invocation:
 *   ------------------
 *   Std_ReturnType Rte_Call_CertP_Functions_Certificate_Parse(const uint8 *rawCertData, uint16 rawCertLength, CertP_ParsedCertStructureType *parsedCert)
 *     Argument rawCertData: uint8* is of type CertP_RawCertBufferType
 *     Synchronous Server Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_CertP_Functions_E_NOT_OK
 *
 * Service Calls:
 * ==============
 *   Service Invocation:
 *   -------------------
 *   Std_ReturnType Rte_Call_Key_BackendCert_KeyElementGet(uint32 keyElementId, uint8 *keyPtr, uint32 *keyLength)
 *     Argument keyPtr: uint8* is of type Csm_KeyDataType_Ssa_BackendCert
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_CsmKeyManagement_Ssa_BackendCert_CSM_E_BUSY, RTE_E_CsmKeyManagement_Ssa_BackendCert_CSM_E_KEY_EMPTY, RTE_E_CsmKeyManagement_Ssa_BackendCert_CSM_E_KEY_NOT_AVAILABLE, RTE_E_CsmKeyManagement_Ssa_BackendCert_CSM_E_KEY_READ_FAIL, RTE_E_CsmKeyManagement_Ssa_BackendCert_CSM_E_SMALL_BUFFER, RTE_E_CsmKeyManagement_Ssa_BackendCert_E_NOT_OK
 *
 **********************************************************************************************************************
 *
 * Runnable prototype:
 * ===================
 *   Std_ReturnType Ssa_KeyM_DataServices_Backend_CA_Certificate_ReadDataLength(Dcm_OpStatusType OpStatus, uint16 *DataLength)
 *
 **********************************************************************************************************************
 *
 * Available Application Errors:
 * =============================
 *   RTE_E_DataServices_Backend_CA_Certificate_Read_DCM_E_PENDING
 *   RTE_E_DataServices_Backend_CA_Certificate_Read_E_NOT_OK
 *
 *********************************************************************************************************************/
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << Start of documentation area >>                  DO NOT CHANGE THIS COMMENT!
 * Symbol: Ssa_KeyM_DataServices_Backend_CA_Certificate_ReadDataLength_doc
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 */

/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << End of documentation area >>                    DO NOT CHANGE THIS COMMENT!
 *********************************************************************************************************************/

FUNC(Std_ReturnType, Ssa_KeyM_CODE) Ssa_KeyM_DataServices_Backend_CA_Certificate_ReadDataLength(
  Dcm_OpStatusType OpStatus,
  P2VAR(uint16, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) DataLength) /* PRQA S 0624, 3206 */ /* MD_Rte_0624, MD_Rte_3206 */
{
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << Start of runnable implementation >>             DO NOT CHANGE THIS COMMENT!
 * Symbol: Ssa_KeyM_DataServices_Backend_CA_Certificate_ReadDataLength (returns application error)
 *********************************************************************************************************************/
  Std_ReturnType rVal = RTE_E_DataServices_Backend_CA_Certificate_Read_E_NOT_OK;

  /* ----- Development Error Checks ------------------------------------- */
#if (SSA_DEV_ERROR_DETECT == STD_ON)
  if (DataLength == NULL_PTR)
  {
    /* retVal already set */
  }
  else
#endif /* SSA_DEV_ERROR_DETECT == STD_ON */
  {
#if (SSA_KEEP_BUFFER_VARIABLES_STATIC == STD_OFF)
    uint8 KeyM_BackendCertBuf[SSA_SIZEOF_CERT_MAX];
#endif
    uint16 backendCertLength = SSA_SIZEOF_CERT_MAX;

    /* #10 Get the parsed, stored Backend CA certificate. */
    rVal = KeyM_GetAndParseStoredCert(CERTP_PKI_ROLE_BACKEND,
      (P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR))KeyM_BackendCertBuf, (P2VAR(uint16, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR))&backendCertLength,
      FALSE);

    if (rVal == E_OK)
    {
      /* #20 If the certificate is available write the length of the certificate increased by 2 for the size
       * information to the output buffer, else write 0. */
      *DataLength = backendCertLength + 2u;
    }
    else
    {
      *DataLength = 0u;
      rVal = RTE_E_DataServices_Backend_CA_Certificate_Read_E_NOT_OK;
    }
  }

  SSA_DUMMY_STATEMENT(OpStatus);    /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */

  return rVal;

/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << End of runnable implementation >>               DO NOT CHANGE THIS COMMENT!
 *********************************************************************************************************************/
}

/**********************************************************************************************************************
 *
 * Runnable Entity Name: Ssa_KeyM_DataServices_DID_018F_Secured_PDU_Data_IDs_and_Key_CMACs_ConditionCheckRead
 *
 *---------------------------------------------------------------------------------------------------------------------
 *
 * Executed if at least one of the following trigger conditions occurred:
 *   - triggered by server invocation for OperationPrototype <ConditionCheckRead> of PortPrototype <DataServices_DID_018F_Secured_PDU_Data_IDs_and_Key_CMACs>
 *
 **********************************************************************************************************************
 *
 * Runnable prototype:
 * ===================
 *   Std_ReturnType Ssa_KeyM_DataServices_DID_018F_Secured_PDU_Data_IDs_and_Key_CMACs_ConditionCheckRead(Dcm_OpStatusType OpStatus, Dcm_NegativeResponseCodeType *ErrorCode)
 *
 **********************************************************************************************************************
 *
 * Available Application Errors:
 * =============================
 *   RTE_E_DataServices_DID_018F_Secured_PDU_Data_IDs_and_Key_CMACs_DCM_E_PENDING
 *   RTE_E_DataServices_DID_018F_Secured_PDU_Data_IDs_and_Key_CMACs_E_NOT_OK
 *
 *********************************************************************************************************************/
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << Start of documentation area >>                  DO NOT CHANGE THIS COMMENT!
 * Symbol: Ssa_KeyM_DataServices_DID_018F_Secured_PDU_Data_IDs_and_Key_CMACs_ConditionCheckRead_doc
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << End of documentation area >>                    DO NOT CHANGE THIS COMMENT!
 *********************************************************************************************************************/

FUNC(Std_ReturnType, Ssa_KeyM_CODE) Ssa_KeyM_DataServices_DID_018F_Secured_PDU_Data_IDs_and_Key_CMACs_ConditionCheckRead(
  Dcm_OpStatusType OpStatus,
  P2VAR(Dcm_NegativeResponseCodeType, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) ErrorCode) /* PRQA S 0624, 3206 */ /* MD_Rte_0624, MD_Rte_3206 */
{
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << Start of runnable implementation >>             DO NOT CHANGE THIS COMMENT!
 * Symbol: Ssa_KeyM_DataServices_DID_018F_Secured_PDU_Data_IDs_and_Key_CMACs_ConditionCheckRead (returns application error)
 *********************************************************************************************************************/
  Std_ReturnType retVal = RTE_E_DataServices_DID_018F_Secured_PDU_Data_IDs_and_Key_CMACs_E_NOT_OK;

  /* ----- Development Error Checks ------------------------------------- */
#if (SSA_DEV_ERROR_DETECT == STD_ON)
  if (ErrorCode == NULL_PTR)
  {
    /* retVal already set */
  }
  else
#endif /* SSA_DEV_ERROR_DETECT == STD_ON */
  {
    /* #10 Always successfully return from condition check. */
    retVal = RTE_E_OK;
    *ErrorCode = DCM_E_POSITIVERESPONSE;
  }

  SSA_DUMMY_STATEMENT(OpStatus);    /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */

  return retVal;

/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << End of runnable implementation >>               DO NOT CHANGE THIS COMMENT!
 *********************************************************************************************************************/
}

/**********************************************************************************************************************
 *
 * Runnable Entity Name: Ssa_KeyM_DataServices_DID_018F_Secured_PDU_Data_IDs_and_Key_CMACs_ReadData
 *
 *---------------------------------------------------------------------------------------------------------------------
 *
 * Executed if at least one of the following trigger conditions occurred:
 *   - triggered by server invocation for OperationPrototype <ReadData> of PortPrototype <DataServices_DID_018F_Secured_PDU_Data_IDs_and_Key_CMACs>
 *
 **********************************************************************************************************************
 *
 * Client/Server Interfaces:
 * =========================
 *   Server Invocation:
 *   ------------------
 *   Std_ReturnType Rte_Call_SsaCdd_Keys_KeyElementCopy(uint32 keyId, uint32 keyElementId, uint32 targetKeyId, uint32 targetKeyElementId)
 *     Synchronous Server Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_SsaCdd_Csm_KeyInterface_E_BUSY, RTE_E_SsaCdd_Csm_KeyInterface_E_NOT_OK
 *   Std_ReturnType Rte_Call_SsaCdd_Keys_KeySetValid(uint32 keyId)
 *     Synchronous Server Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_SsaCdd_Csm_KeyInterface_E_BUSY, RTE_E_SsaCdd_Csm_KeyInterface_E_NOT_OK
 *
 * Service Calls:
 * ==============
 *   Service Invocation:
 *   -------------------
 *   Std_ReturnType Rte_Call_MacGen_PduKeysMac_MacGenerate(const uint8 *dataBuffer, uint32 dataLength, uint8 *macBuffer, uint32 *macLength)
 *     Argument dataBuffer: uint8* is of type Csm_MacGenerateDataType_MacGenAesCmac
 *     Argument macBuffer: uint8* is of type Csm_MacGenerateResultType_MacGenAesCmac
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_CsmMacGenerate_MacGenAesCmac_CSM_E_BUSY, RTE_E_CsmMacGenerate_MacGenAesCmac_CSM_E_KEY_EMPTY, RTE_E_CsmMacGenerate_MacGenAesCmac_CSM_E_KEY_NOT_VALID, RTE_E_CsmMacGenerate_MacGenAesCmac_CSM_E_KEY_SIZE_MISMATCH, RTE_E_CsmMacGenerate_MacGenAesCmac_CSM_E_SMALL_BUFFER, RTE_E_CsmMacGenerate_MacGenAesCmac_E_NOT_OK
 *
 **********************************************************************************************************************
 *
 * Runnable prototype:
 * ===================
 *   Std_ReturnType Ssa_KeyM_DataServices_DID_018F_Secured_PDU_Data_IDs_and_Key_CMACs_ReadData(Dcm_OpStatusType OpStatus, uint8 *Data)
 *     Argument Data: uint8* is of type Dcm_Data4092ByteType
 *
 **********************************************************************************************************************
 *
 * Available Application Errors:
 * =============================
 *   RTE_E_DataServices_DID_018F_Secured_PDU_Data_IDs_and_Key_CMACs_DCM_E_PENDING
 *   RTE_E_DataServices_DID_018F_Secured_PDU_Data_IDs_and_Key_CMACs_E_NOT_OK
 *
 *********************************************************************************************************************/
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << Start of documentation area >>                  DO NOT CHANGE THIS COMMENT!
 * Symbol: Ssa_KeyM_DataServices_DID_018F_Secured_PDU_Data_IDs_and_Key_CMACs_ReadData_doc
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
/*!
 * \spec
 *    requires $lengthOf(Data) >= sizeof(Dcm_Data4092ByteType);
 * \endspec
 */
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << End of documentation area >>                    DO NOT CHANGE THIS COMMENT!
 *********************************************************************************************************************/

FUNC(Std_ReturnType, Ssa_KeyM_CODE) Ssa_KeyM_DataServices_DID_018F_Secured_PDU_Data_IDs_and_Key_CMACs_ReadData(
  Dcm_OpStatusType OpStatus,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) Data) /* PRQA S 0624, 3206 */ /* MD_Rte_0624, MD_Rte_3206 */
{
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << Start of runnable implementation >>             DO NOT CHANGE THIS COMMENT!
 * Symbol: Ssa_KeyM_DataServices_DID_018F_Secured_PDU_Data_IDs_and_Key_CMACs_ReadData (returns application error)
 *********************************************************************************************************************/

  Std_ReturnType retVal = RTE_E_DataServices_DID_018F_Secured_PDU_Data_IDs_and_Key_CMACs_E_NOT_OK;

  /* ----- Development Error Checks ------------------------------------- */
#if (SSA_DEV_ERROR_DETECT == STD_ON)
  if (Data == NULL_PTR)
  {
    /* retVal already set */
  }
  else
#endif /* SSA_DEV_ERROR_DETECT == STD_ON */
  {
    uint16_least localPduId;
    uint8 macDataBuffer[SSA_KEYM_SIZEOF_DATA_ID + SSA_KEYM_KEY_CMAC_SIZEOF_KEY_CMAC_CONSTANT];
    uint8 macResultBuffer[SSA_KEYM_SIZEOF_CMAC];
    uint32 macResultLength;

    retVal = E_OK;

    /* #20 Concatenate the PDU Data ID and CMAC constant for CMAC calculation input.  [Data ID 2xBytes | Constant 16xBytes] */
    /* #30 Copy CMAC constant to input buffer. */
    Ssa_MemCpy((P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR))&macDataBuffer[SSA_KEYM_SIZEOF_DATA_ID], KeyM_Key_CMAC_Constant, SSA_KEYM_KEY_CMAC_SIZEOF_KEY_CMAC_CONSTANT);

    /* #40 Iterate over all configured Secured PDUs. */
    for (localPduId = 0; localPduId < Ssa_GetSizeOfDataIdInfo(); localPduId++)
    {
      if (retVal != E_OK)
      {
        /* leave the for-loop */
        break;
      }

      /* #60 Add Data ID to the input buffer. */
      macDataBuffer[0u] = KeyM_GetUint16HiByte(Ssa_GetDataIdOfDataIdInfo(localPduId));
      macDataBuffer[1u] = KeyM_GetUint16LoByte(Ssa_GetDataIdOfDataIdInfo(localPduId));

      /* #70 Copy key to temporary key for CMAC calculation. */
      retVal = Rte_Call_SsaCdd_Keys_KeyElementCopy(Ssa_GetKeyIdOfDataIdInfo(localPduId), SSA_KE_MAC_KEY, SSA_KEYM_CSM_PDU_KEYS_MAC_KEY, SSA_KE_MAC_KEY);

      if (retVal == E_OK)
      {
        /* #80 Set temporary key valid. */
        retVal = Rte_Call_SsaCdd_Keys_KeySetValid(SSA_KEYM_CSM_PDU_KEYS_MAC_KEY);
      }

      if (retVal == E_OK)
      {
        /* #90 Calculate the CMAC value from the concatenation. */
        macResultLength = SSA_KEYM_SIZEOF_CMAC;
        retVal = Rte_Call_MacGen_PduKeysMac_MacGenerate(macDataBuffer, SSA_KEYM_SIZEOF_DATA_ID + SSA_KEYM_KEY_CMAC_SIZEOF_KEY_CMAC_CONSTANT, macResultBuffer, &macResultLength);

        if ((retVal != E_OK) || (macResultLength != SSA_KEYM_SIZEOF_CMAC))
        {
          /* #100 Clear data if operation has failed. */
          retVal = RTE_E_DataServices_DID_018F_Secured_PDU_Data_IDs_and_Key_CMACs_E_NOT_OK;
          KeyM_ClearDataBuffer(Data, sizeof(Dcm_Data4092ByteType), SSA_KEYM_KEY_CMAC_SIZEOF_DATA_PRO_DATA_ID * Ssa_GetSizeOfDataIdInfo());
        }
        else
        {
          /* #200 Set all data. [Data ID 2xBytes | CMAC 4xBytes] */
          /* #210 Add Data ID to the CMAC buffer. */
          Data[(SSA_KEYM_KEY_CMAC_SIZEOF_DATA_PRO_DATA_ID*localPduId)] = KeyM_GetUint16HiByte(Ssa_GetDataIdOfDataIdInfo(localPduId));
          Data[(SSA_KEYM_KEY_CMAC_SIZEOF_DATA_PRO_DATA_ID*localPduId) + 1u] = KeyM_GetUint16LoByte(Ssa_GetDataIdOfDataIdInfo(localPduId));
          /* #220 Add the 32 least significant bit from CMAC. */
          Ssa_MemCpy(&Data[(SSA_KEYM_KEY_CMAC_SIZEOF_DATA_PRO_DATA_ID*localPduId) + SSA_KEYM_SIZEOF_DATA_ID], &macResultBuffer[SSA_KEYM_SIZEOF_CMAC - SSA_KEYM_KEY_CMAC_SIZEOF_TRUNCATED_MAC], SSA_KEYM_KEY_CMAC_SIZEOF_TRUNCATED_MAC);
        }
      }
    }
  }

  SSA_DUMMY_STATEMENT(OpStatus);    /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */

  return retVal;

/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << End of runnable implementation >>               DO NOT CHANGE THIS COMMENT!
 *********************************************************************************************************************/
}

/**********************************************************************************************************************
 *
 * Runnable Entity Name: Ssa_KeyM_DataServices_DID_018F_Secured_PDU_Data_IDs_and_Key_CMACs_ReadDataLength
 *
 *---------------------------------------------------------------------------------------------------------------------
 *
 * Executed if at least one of the following trigger conditions occurred:
 *   - triggered by server invocation for OperationPrototype <ReadDataLength> of PortPrototype <DataServices_DID_018F_Secured_PDU_Data_IDs_and_Key_CMACs>
 *
 **********************************************************************************************************************
 *
 * Runnable prototype:
 * ===================
 *   Std_ReturnType Ssa_KeyM_DataServices_DID_018F_Secured_PDU_Data_IDs_and_Key_CMACs_ReadDataLength(Dcm_OpStatusType OpStatus, uint16 *DataLength)
 *
 **********************************************************************************************************************
 *
 * Available Application Errors:
 * =============================
 *   RTE_E_DataServices_DID_018F_Secured_PDU_Data_IDs_and_Key_CMACs_DCM_E_PENDING
 *   RTE_E_DataServices_DID_018F_Secured_PDU_Data_IDs_and_Key_CMACs_E_NOT_OK
 *
 *********************************************************************************************************************/
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << Start of documentation area >>                  DO NOT CHANGE THIS COMMENT!
 * Symbol: Ssa_KeyM_DataServices_DID_018F_Secured_PDU_Data_IDs_and_Key_CMACs_ReadDataLength_doc
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */

/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << End of documentation area >>                    DO NOT CHANGE THIS COMMENT!
 *********************************************************************************************************************/

FUNC(Std_ReturnType, Ssa_KeyM_CODE) Ssa_KeyM_DataServices_DID_018F_Secured_PDU_Data_IDs_and_Key_CMACs_ReadDataLength(
  Dcm_OpStatusType OpStatus,
  P2VAR(uint16, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) DataLength) /* PRQA S 0624, 3206 */ /* MD_Rte_0624, MD_Rte_3206 */
{
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << Start of runnable implementation >>             DO NOT CHANGE THIS COMMENT!
 * Symbol: Ssa_KeyM_DataServices_DID_018F_Secured_PDU_Data_IDs_and_Key_CMACs_ReadDataLength (returns application error)
 *********************************************************************************************************************/
  Std_ReturnType retVal = RTE_E_DataServices_DID_018F_Secured_PDU_Data_IDs_and_Key_CMACs_E_NOT_OK;

  /* ----- Development Error Checks ------------------------------------- */
#if (SSA_DEV_ERROR_DETECT == STD_ON)
  if (DataLength == NULL_PTR)
  {
    /* retVal already set */
  }
  else
#endif /* SSA_DEV_ERROR_DETECT == STD_ON */
  {
    /* #10 Calculate and return data length. */
    *DataLength = SSA_KEYM_KEY_CMAC_SIZEOF_DATA_PRO_DATA_ID * Ssa_GetSizeOfDataIdInfo();
    retVal = RTE_E_OK;
  }

  SSA_DUMMY_STATEMENT(OpStatus);    /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */

  return retVal;

/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << End of runnable implementation >>               DO NOT CHANGE THIS COMMENT!
 *********************************************************************************************************************/
}

/**********************************************************************************************************************
 *
 * Runnable Entity Name: Ssa_KeyM_DataServices_DID_0191_Generated_Random_Number_ConditionCheckRead
 *
 *---------------------------------------------------------------------------------------------------------------------
 *
 * Executed if at least one of the following trigger conditions occurred:
 *   - triggered by server invocation for OperationPrototype <ConditionCheckRead> of PortPrototype <DataServices_DID_0191_Generated_Random_Number>
 *
 **********************************************************************************************************************
 *
 * Service Calls:
 * ==============
 *   Service Invocation:
 *   -------------------
 *   Std_ReturnType Rte_Call_CsmRandomGenerate_RandomGenerate(uint8 *resultBuffer, uint32 *resultLength)
 *     Argument resultBuffer: uint8* is of type Csm_RandomGenerateResultType_Random
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_CsmRandomGenerate_Random_CSM_E_BUSY, RTE_E_CsmRandomGenerate_Random_CSM_E_ENTROPY_EXHAUSTION, RTE_E_CsmRandomGenerate_Random_E_NOT_OK
 *
 **********************************************************************************************************************
 *
 * Runnable prototype:
 * ===================
 *   Std_ReturnType Ssa_KeyM_DataServices_DID_0191_Generated_Random_Number_ConditionCheckRead(Dcm_OpStatusType OpStatus, Dcm_NegativeResponseCodeType *ErrorCode)
 *
 **********************************************************************************************************************
 *
 * Available Application Errors:
 * =============================
 *   RTE_E_DataServices_DID_0191_Generated_Random_Number_DCM_E_PENDING
 *   RTE_E_DataServices_DID_0191_Generated_Random_Number_E_NOT_OK
 *
 *********************************************************************************************************************/
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << Start of documentation area >>                  DO NOT CHANGE THIS COMMENT!
 * Symbol: Ssa_KeyM_DataServices_DID_0191_Generated_Random_Number_ConditionCheckRead_doc
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */

/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << End of documentation area >>                    DO NOT CHANGE THIS COMMENT!
 *********************************************************************************************************************/

FUNC(Std_ReturnType, Ssa_KeyM_CODE) Ssa_KeyM_DataServices_DID_0191_Generated_Random_Number_ConditionCheckRead(
  Dcm_OpStatusType OpStatus,
  P2VAR(Dcm_NegativeResponseCodeType, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) ErrorCode) /* PRQA S 0624, 3206 */ /* MD_Rte_0624, MD_Rte_3206 */
{
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << Start of runnable implementation >>             DO NOT CHANGE THIS COMMENT!
 * Symbol: Ssa_KeyM_DataServices_DID_0191_Generated_Random_Number_ConditionCheckRead (returns application error)
 *********************************************************************************************************************/

  Std_ReturnType retVal = RTE_E_DataServices_DID_0191_Generated_Random_Number_E_NOT_OK;

  /* ----- Development Error Checks ------------------------------------- */
#if (SSA_DEV_ERROR_DETECT == STD_ON)
  if (ErrorCode == NULL_PTR)
  {
    /* retVal already set */
  }
  else
#endif /* SSA_DEV_ERROR_DETECT == STD_ON */
  {
    /* #10 Always return successfully from condition check. */
    *ErrorCode = DCM_E_POSITIVERESPONSE;
    retVal =  RTE_E_OK;
  }

  SSA_DUMMY_STATEMENT(OpStatus);    /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */

  return retVal;
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << End of runnable implementation >>               DO NOT CHANGE THIS COMMENT!
 *********************************************************************************************************************/
}

/**********************************************************************************************************************
 *
 * Runnable Entity Name: Ssa_KeyM_DataServices_DID_0191_Generated_Random_Number_ReadData
 *
 *---------------------------------------------------------------------------------------------------------------------
 *
 * Executed if at least one of the following trigger conditions occurred:
 *   - triggered by server invocation for OperationPrototype <ReadData> of PortPrototype <DataServices_DID_0191_Generated_Random_Number>
 *
 **********************************************************************************************************************
 *
 * Runnable prototype:
 * ===================
 *   Std_ReturnType Ssa_KeyM_DataServices_DID_0191_Generated_Random_Number_ReadData(Dcm_OpStatusType OpStatus, uint8 *Data)
 *     Argument Data: uint8* is of type Dcm_Data32ByteType
 *
 **********************************************************************************************************************
 *
 * Available Application Errors:
 * =============================
 *   RTE_E_DataServices_DID_0191_Generated_Random_Number_DCM_E_PENDING
 *   RTE_E_DataServices_DID_0191_Generated_Random_Number_E_NOT_OK
 *
 *********************************************************************************************************************/
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << Start of documentation area >>                  DO NOT CHANGE THIS COMMENT!
 * Symbol: Ssa_KeyM_DataServices_DID_0191_Generated_Random_Number_ReadData_doc
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 */
/*!
 * \spec
 *    requires $lengthOf(Data) >= sizeof(Dcm_Data32ByteType);
 *    requires $lengthOf(Data) >= SSA_SIZEOF_NONCE;
 * \endspec
 */
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << End of documentation area >>                    DO NOT CHANGE THIS COMMENT!
 *********************************************************************************************************************/

FUNC(Std_ReturnType, Ssa_KeyM_CODE) Ssa_KeyM_DataServices_DID_0191_Generated_Random_Number_ReadData(
  Dcm_OpStatusType OpStatus,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) Data) /* PRQA S 0624, 3206 */ /* MD_Rte_0624, MD_Rte_3206 */
{
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << Start of runnable implementation >>             DO NOT CHANGE THIS COMMENT!
 * Symbol: Ssa_KeyM_DataServices_DID_0191_Generated_Random_Number_ReadData (returns application error)
 *********************************************************************************************************************/

  Std_ReturnType retVal = RTE_E_DataServices_DID_0191_Generated_Random_Number_E_NOT_OK;

  /* ----- Development Error Checks ------------------------------------- */
#if (SSA_DEV_ERROR_DETECT == STD_ON)
  if (Data == NULL_PTR)
  {
    /* retVal already set */
  }
  else
#endif /* SSA_DEV_ERROR_DETECT == STD_ON */
  {
    /* #10 Check if random number generation was successful. */
    if (KeyM_DiagProc.randomNumberGeneration_Flag == SSA_KEYM_DID191_SUCCESS)
    {
      /* #20 Success, copy random number to Data. */
      Ssa_MemCpy(&Data[0], KeyM_DiagProc.buffer32Byte, SSA_SIZEOF_NONCE);
    }
    else
    {
      /* #30 Failure, do nothing. */
      /* Return positive response. Generated_Random_Number_Result has already been set
         in Ssa_KeyM_DataServices_DID_0191_Generated_Random_Number_Result_ReadData() which is
         called previously. */
    }

    retVal = RTE_E_OK;
  }

  SSA_DUMMY_STATEMENT(OpStatus);    /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */

  return retVal;

/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << End of runnable implementation >>               DO NOT CHANGE THIS COMMENT!
 *********************************************************************************************************************/
}

/**********************************************************************************************************************
 *
 * Runnable Entity Name: Ssa_KeyM_DataServices_DID_0191_Generated_Random_Number_Result_ConditionCheckRead
 *
 *---------------------------------------------------------------------------------------------------------------------
 *
 * Executed if at least one of the following trigger conditions occurred:
 *   - triggered by server invocation for OperationPrototype <ConditionCheckRead> of PortPrototype <DataServices_DID_0191_Generated_Random_Number_Result>
 *
 **********************************************************************************************************************
 *
 * Runnable prototype:
 * ===================
 *   Std_ReturnType Ssa_KeyM_DataServices_DID_0191_Generated_Random_Number_Result_ConditionCheckRead(Dcm_OpStatusType OpStatus, Dcm_NegativeResponseCodeType *ErrorCode)
 *
 **********************************************************************************************************************
 *
 * Available Application Errors:
 * =============================
 *   RTE_E_DataServices_DID_0191_Generated_Random_Number_Result_DCM_E_PENDING
 *   RTE_E_DataServices_DID_0191_Generated_Random_Number_Result_E_NOT_OK
 *
 *********************************************************************************************************************/
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << Start of documentation area >>                  DO NOT CHANGE THIS COMMENT!
 * Symbol: Ssa_KeyM_DataServices_DID_0191_Generated_Random_Number_Result_ConditionCheckRead_doc
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */

/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << End of documentation area >>                    DO NOT CHANGE THIS COMMENT!
 *********************************************************************************************************************/

FUNC(Std_ReturnType, Ssa_KeyM_CODE) Ssa_KeyM_DataServices_DID_0191_Generated_Random_Number_Result_ConditionCheckRead(
  Dcm_OpStatusType OpStatus,
  P2VAR(Dcm_NegativeResponseCodeType, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) ErrorCode) /* PRQA S 0624, 3206 */ /* MD_Rte_0624, MD_Rte_3206 */
{
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << Start of runnable implementation >>             DO NOT CHANGE THIS COMMENT!
 * Symbol: Ssa_KeyM_DataServices_DID_0191_Generated_Random_Number_Result_ConditionCheckRead (returns application error)
 *********************************************************************************************************************/
  Std_ReturnType retVal = RTE_E_DataServices_DID_0191_Generated_Random_Number_Result_E_NOT_OK;

  /* ----- Development Error Checks ------------------------------------- */
#if (SSA_DEV_ERROR_DETECT == STD_ON)
  if (ErrorCode == NULL_PTR)
  {
    /* retVal already set */
  }
  else
#endif /* SSA_DEV_ERROR_DETECT == STD_ON */
  {
    /* #10 Always return successfully from condition check. */
    *ErrorCode = DCM_E_POSITIVERESPONSE;
    retVal = RTE_E_OK;
  }
  SSA_DUMMY_STATEMENT(OpStatus);    /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */

  return retVal;

/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << End of runnable implementation >>               DO NOT CHANGE THIS COMMENT!
 *********************************************************************************************************************/
}

/**********************************************************************************************************************
 *
 * Runnable Entity Name: Ssa_KeyM_DataServices_DID_0191_Generated_Random_Number_Result_ReadData
 *
 *---------------------------------------------------------------------------------------------------------------------
 *
 * Executed if at least one of the following trigger conditions occurred:
 *   - triggered by server invocation for OperationPrototype <ReadData> of PortPrototype <DataServices_DID_0191_Generated_Random_Number_Result>
 *
 **********************************************************************************************************************
 *
 * Runnable prototype:
 * ===================
 *   Std_ReturnType Ssa_KeyM_DataServices_DID_0191_Generated_Random_Number_Result_ReadData(Dcm_OpStatusType OpStatus, uint8 *Data)
 *     Argument Data: uint8* is of type Dcm_Data1ByteType
 *
 **********************************************************************************************************************
 *
 * Available Application Errors:
 * =============================
 *   RTE_E_DataServices_DID_0191_Generated_Random_Number_Result_DCM_E_PENDING
 *   RTE_E_DataServices_DID_0191_Generated_Random_Number_Result_E_NOT_OK
 *
 *********************************************************************************************************************/
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << Start of documentation area >>                  DO NOT CHANGE THIS COMMENT!
 * Symbol: Ssa_KeyM_DataServices_DID_0191_Generated_Random_Number_Result_ReadData_doc
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 */

/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << End of documentation area >>                    DO NOT CHANGE THIS COMMENT!
 *********************************************************************************************************************/

FUNC(Std_ReturnType, Ssa_KeyM_CODE) Ssa_KeyM_DataServices_DID_0191_Generated_Random_Number_Result_ReadData(
  Dcm_OpStatusType OpStatus,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) Data) /* PRQA S 0624, 3206 */ /* MD_Rte_0624, MD_Rte_3206 */
{
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << Start of runnable implementation >>             DO NOT CHANGE THIS COMMENT!
 * Symbol: Ssa_KeyM_DataServices_DID_0191_Generated_Random_Number_Result_ReadData (returns application error)
 *********************************************************************************************************************/

  Std_ReturnType retVal = RTE_E_DataServices_DID_0191_Generated_Random_Number_Result_E_NOT_OK;

  /* ----- Development Error Checks ------------------------------------- */
#if (SSA_DEV_ERROR_DETECT == STD_ON)
  if (Data == NULL_PTR)
  {
    /* retVal already set */
  }
  else
#endif /* SSA_DEV_ERROR_DETECT == STD_ON */
  {
    retVal = RTE_E_OK;
    if ((OpStatus == DCM_INITIAL) || (OpStatus == DCM_PENDING))
    {
      /* #10 Request random number. */
      retVal = KeyM_CsmRandomGenerate(SSA_SIZEOF_NONCE, KeyM_DiagProc.buffer32Byte);

      /* #20 Check random number generation result. */
      if (retVal == SSA_E_PENDING)
      {
        retVal = RTE_E_DataServices_DID_0191_Generated_Random_Number_DCM_E_PENDING;
      }
      else
      {
        /* #30 If service is not pending, set first byte of Data to success (0x01) or failure (0x00). */
        if (retVal == E_OK)
        {
          Data[0] = SSA_KEYM_DID191_SUCCESS;
          KeyM_DiagProc.randomNumberGeneration_Flag = SSA_KEYM_DID191_SUCCESS;
        }
        else
        {
          Data[0] = SSA_KEYM_DID191_FAILURE;
          KeyM_DiagProc.randomNumberGeneration_Flag = SSA_KEYM_DID191_FAILURE;
        }
        retVal = RTE_E_OK;
      }
    }
  }

  return retVal;

/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << End of runnable implementation >>               DO NOT CHANGE THIS COMMENT!
 *********************************************************************************************************************/
}
#if (SSA_ECU_TYPE == SSA_ECU_TYPE_VSM)

/**********************************************************************************************************************
 *
 * Runnable Entity Name: Ssa_KeyM_DataServices_DID_0193_Common_Name_ConditionCheckRead
 *
 *---------------------------------------------------------------------------------------------------------------------
 *
 * Executed if at least one of the following trigger conditions occurred:
 *   - triggered by server invocation for OperationPrototype <ConditionCheckRead> of PortPrototype <DataServices_DID_0193_Common_Name>
 *
 **********************************************************************************************************************
 *
 * Runnable prototype:
 * ===================
 *   Std_ReturnType Ssa_KeyM_DataServices_DID_0193_Common_Name_ConditionCheckRead(Dcm_OpStatusType OpStatus, Dcm_NegativeResponseCodeType *ErrorCode)
 *
 **********************************************************************************************************************
 *
 * Available Application Errors:
 * =============================
 *   RTE_E_DataServices_DID_0193_Common_Name_DCM_E_PENDING
 *   RTE_E_DataServices_DID_0193_Common_Name_E_NOT_OK
 *
 *********************************************************************************************************************/
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << Start of documentation area >>                  DO NOT CHANGE THIS COMMENT!
 * Symbol: Ssa_KeyM_DataServices_DID_0193_Common_Name_ConditionCheckRead_doc
 *********************************************************************************************************************/
 /*!
 * Internal comment removed.
 *
 *
 */

/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << End of documentation area >>                    DO NOT CHANGE THIS COMMENT!
 *********************************************************************************************************************/

FUNC(Std_ReturnType, Ssa_KeyM_CODE) Ssa_KeyM_DataServices_DID_0193_Common_Name_ConditionCheckRead(
  Dcm_OpStatusType OpStatus,
  P2VAR(Dcm_NegativeResponseCodeType, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) ErrorCode) /* PRQA S 0624, 3206 */ /* MD_Rte_0624, MD_Rte_3206 */
{
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << Start of runnable implementation >>             DO NOT CHANGE THIS COMMENT!
 * Symbol: Ssa_KeyM_DataServices_DID_0193_Common_Name_ConditionCheckRead (returns application error)
 *********************************************************************************************************************/

  Std_ReturnType retVal = RTE_E_DataServices_DID_0193_Common_Name_E_NOT_OK;

  /* ----- Development Error Checks ------------------------------------- */
# if (SSA_DEV_ERROR_DETECT == STD_ON)
  if (ErrorCode == NULL_PTR)
  {
    /* retVal already set */
  }
  else
# endif /* SSA_DEV_ERROR_DETECT == STD_ON */
  {
    /* #10 Check if common name can be read. */
    if ((KeyM_ParsedEcuCert.subject.validContent) && (KeyM_ParsedEcuCert.subject.elemDataLength <= sizeof(Dcm_Data30ByteType)))
    {
      retVal = RTE_E_OK;
    }
    else
    {
      /* invalid content or data length */
      *ErrorCode = DCM_E_GENERALREJECT;
    }
  }
  SSA_DUMMY_STATEMENT(OpStatus);    /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */

  return retVal;

/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << End of runnable implementation >>               DO NOT CHANGE THIS COMMENT!
 *********************************************************************************************************************/
}

/**********************************************************************************************************************
 *
 * Runnable Entity Name: Ssa_KeyM_DataServices_DID_0193_Common_Name_ReadData
 *
 *---------------------------------------------------------------------------------------------------------------------
 *
 * Executed if at least one of the following trigger conditions occurred:
 *   - triggered by server invocation for OperationPrototype <ReadData> of PortPrototype <DataServices_DID_0193_Common_Name>
 *
 **********************************************************************************************************************
 *
 * Runnable prototype:
 * ===================
 *   Std_ReturnType Ssa_KeyM_DataServices_DID_0193_Common_Name_ReadData(Dcm_OpStatusType OpStatus, uint8 *Data)
 *     Argument Data: uint8* is of type Dcm_Data30ByteType
 *
 **********************************************************************************************************************
 *
 * Available Application Errors:
 * =============================
 *   RTE_E_DataServices_DID_0193_Common_Name_DCM_E_PENDING
 *   RTE_E_DataServices_DID_0193_Common_Name_E_NOT_OK
 *
 *********************************************************************************************************************/
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << Start of documentation area >>                  DO NOT CHANGE THIS COMMENT!
 * Symbol: Ssa_KeyM_DataServices_DID_0193_Common_Name_ReadData_doc
 *********************************************************************************************************************/
 /*!
 * Internal comment removed.
 *
 *
 *
 *
 */
/*!
 * \spec
 *    requires $lengthOf(Data) >= sizeof(Dcm_Data30ByteType);
 * \endspec
 */
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << End of documentation area >>                    DO NOT CHANGE THIS COMMENT!
 *********************************************************************************************************************/

FUNC(Std_ReturnType, Ssa_KeyM_CODE) Ssa_KeyM_DataServices_DID_0193_Common_Name_ReadData(
  Dcm_OpStatusType OpStatus,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) Data) /* PRQA S 0624, 3206 */ /* MD_Rte_0624, MD_Rte_3206 */
{
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << Start of runnable implementation >>             DO NOT CHANGE THIS COMMENT!
 * Symbol: Ssa_KeyM_DataServices_DID_0193_Common_Name_ReadData (returns application error)
 *********************************************************************************************************************/

  Std_ReturnType retVal = RTE_E_DataServices_DID_0193_Common_Name_E_NOT_OK;

  /* ----- Development Error Checks ------------------------------------- */
# if (SSA_DEV_ERROR_DETECT == STD_ON)
  if (Data == NULL_PTR)
  {
    /* retVal already set */
  }
  else
# endif /* SSA_DEV_ERROR_DETECT == STD_ON */
  {
    uint8 byteIdx;
# if (SSA_KEEP_BUFFER_VARIABLES_STATIC == STD_OFF)
    uint8 KeyM_EcuCertBuf[SSA_SIZEOF_CERT_MAX];
    uint16 ecuCertLength = SSA_SIZEOF_CERT_MAX;

    /* #5 Parse stored certificate. */
    (void)KeyM_GetAndParseStoredCert(CERTP_PKI_ROLE_ECU, (P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR))KeyM_EcuCertBuf, &ecuCertLength, FALSE);
# endif

    /* #10 Set all data elements to zero (padding). */
    for (byteIdx = 0u; byteIdx < SSA_KEYM_SIZEOF_SUBJECT; byteIdx++)
    {
      Data[byteIdx] = 0x00u;
    }

    /* #20 Copy the common name to the output buffer considering its size. */
    /* If SSA_KEEP_BUFFER_VARIABLES_STATIC == STD_ON, the certificate data is contained
     * in the global buffer KeyM_EcuCertBuf, which was parsed in
     * Ssa_KeyM_DataServices_DID_0193_SubjectKeyIdentifier_ConditionCheckRead. */

    if (KeyM_ParsedEcuCert.subject.elemDataLength <= sizeof(Dcm_Data30ByteType))
    {
      /* The length check was already done in Ssa_KeyM_DataServices_DID_0193_Common_Name_ConditionCheckRead().
       * It is repeated here to facilitate the silent analysis.
       * If the length check is violated, nothing is copied to the output buffer, and the function returns E_OK. */
      Ssa_MemCpy(Data, &KeyM_EcuCertBuf[KeyM_ParsedEcuCert.subject.elemDataIdx], KeyM_ParsedEcuCert.subject.elemDataLength);
    }

    retVal = RTE_E_OK;
  }
  SSA_DUMMY_STATEMENT(OpStatus);    /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */

  return retVal;

/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << End of runnable implementation >>               DO NOT CHANGE THIS COMMENT!
 *********************************************************************************************************************/
}

/**********************************************************************************************************************
 *
 * Runnable Entity Name: Ssa_KeyM_DataServices_DID_0193_SerialNumber_ConditionCheckRead
 *
 *---------------------------------------------------------------------------------------------------------------------
 *
 * Executed if at least one of the following trigger conditions occurred:
 *   - triggered by server invocation for OperationPrototype <ConditionCheckRead> of PortPrototype <DataServices_DID_0193_SerialNumber>
 *
 **********************************************************************************************************************
 *
 * Runnable prototype:
 * ===================
 *   Std_ReturnType Ssa_KeyM_DataServices_DID_0193_SerialNumber_ConditionCheckRead(Dcm_OpStatusType OpStatus, Dcm_NegativeResponseCodeType *ErrorCode)
 *
 **********************************************************************************************************************
 *
 * Available Application Errors:
 * =============================
 *   RTE_E_DataServices_DID_0193_SerialNumber_DCM_E_PENDING
 *   RTE_E_DataServices_DID_0193_SerialNumber_E_NOT_OK
 *
 *********************************************************************************************************************/
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << Start of documentation area >>                  DO NOT CHANGE THIS COMMENT!
 * Symbol: Ssa_KeyM_DataServices_DID_0193_SerialNumber_ConditionCheckRead_doc
 *********************************************************************************************************************/
 /*!
 * Internal comment removed.
 *
 *
 */

/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << End of documentation area >>                    DO NOT CHANGE THIS COMMENT!
 *********************************************************************************************************************/

FUNC(Std_ReturnType, Ssa_KeyM_CODE) Ssa_KeyM_DataServices_DID_0193_SerialNumber_ConditionCheckRead(
  Dcm_OpStatusType OpStatus,
  P2VAR(Dcm_NegativeResponseCodeType, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) ErrorCode) /* PRQA S 0624, 3206 */ /* MD_Rte_0624, MD_Rte_3206 */
{
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << Start of runnable implementation >>             DO NOT CHANGE THIS COMMENT!
 * Symbol: Ssa_KeyM_DataServices_DID_0193_SerialNumber_ConditionCheckRead (returns application error)
 *********************************************************************************************************************/

  Std_ReturnType retVal = RTE_E_DataServices_DID_0193_SerialNumber_E_NOT_OK;

  /* ----- Development Error Checks ------------------------------------- */
# if (SSA_DEV_ERROR_DETECT == STD_ON)
  if (ErrorCode == NULL_PTR)
  {
    /* retVal already set */
  }
  else
# endif /* SSA_DEV_ERROR_DETECT == STD_ON */
  {
    /* #10 Check if serial number can be read. */
    if ((KeyM_ParsedEcuCert.serialNumber.validContent) && (KeyM_ParsedEcuCert.serialNumber.elemDataLength <= sizeof(Dcm_Data16ByteType)))
    {
      retVal = RTE_E_OK;
    }
    else
    {
      /* invalid content or data length */
      *ErrorCode = DCM_E_GENERALREJECT;
    }
  }
  SSA_DUMMY_STATEMENT(OpStatus);    /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */

  return retVal;

/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << End of runnable implementation >>               DO NOT CHANGE THIS COMMENT!
 *********************************************************************************************************************/
}

/**********************************************************************************************************************
 *
 * Runnable Entity Name: Ssa_KeyM_DataServices_DID_0193_SerialNumber_ReadData
 *
 *---------------------------------------------------------------------------------------------------------------------
 *
 * Executed if at least one of the following trigger conditions occurred:
 *   - triggered by server invocation for OperationPrototype <ReadData> of PortPrototype <DataServices_DID_0193_SerialNumber>
 *
 **********************************************************************************************************************
 *
 * Runnable prototype:
 * ===================
 *   Std_ReturnType Ssa_KeyM_DataServices_DID_0193_SerialNumber_ReadData(Dcm_OpStatusType OpStatus, uint8 *Data)
 *     Argument Data: uint8* is of type Dcm_Data16ByteType
 *
 **********************************************************************************************************************
 *
 * Available Application Errors:
 * =============================
 *   RTE_E_DataServices_DID_0193_SerialNumber_DCM_E_PENDING
 *   RTE_E_DataServices_DID_0193_SerialNumber_E_NOT_OK
 *
 *********************************************************************************************************************/
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << Start of documentation area >>                  DO NOT CHANGE THIS COMMENT!
 * Symbol: Ssa_KeyM_DataServices_DID_0193_SerialNumber_ReadData_doc
 *********************************************************************************************************************/
 /*!
 * Internal comment removed.
 *
 *
 *
 */
/*!
 * \spec
 *    requires $lengthOf(Data) >= sizeof(Dcm_Data16ByteType);
 * \endspec
 */
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << End of documentation area >>                    DO NOT CHANGE THIS COMMENT!
 *********************************************************************************************************************/

FUNC(Std_ReturnType, Ssa_KeyM_CODE) Ssa_KeyM_DataServices_DID_0193_SerialNumber_ReadData(
  Dcm_OpStatusType OpStatus,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) Data) /* PRQA S 0624, 3206 */ /* MD_Rte_0624, MD_Rte_3206 */
{
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << Start of runnable implementation >>             DO NOT CHANGE THIS COMMENT!
 * Symbol: Ssa_KeyM_DataServices_DID_0193_SerialNumber_ReadData (returns application error)
 *********************************************************************************************************************/

  Std_ReturnType retVal = RTE_E_DataServices_DID_0193_SerialNumber_E_NOT_OK;

  /* ----- Development Error Checks ------------------------------------- */
# if (SSA_DEV_ERROR_DETECT == STD_ON)
  if (Data == NULL_PTR)
  {
    /* retVal already set */
  }
  else
# endif /* SSA_DEV_ERROR_DETECT == STD_ON */
  {
# if (SSA_KEEP_BUFFER_VARIABLES_STATIC == STD_OFF)
    uint8 KeyM_EcuCertBuf[SSA_SIZEOF_CERT_MAX];
    uint16 ecuCertLength = SSA_SIZEOF_CERT_MAX;

    /* #10 Parse stored certificate. */
    (void)KeyM_GetAndParseStoredCert(CERTP_PKI_ROLE_ECU, (P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR))KeyM_EcuCertBuf, &ecuCertLength, FALSE);
# endif

    /* #20 Copy the serial number to the output buffer considering its size. */
    /* If SSA_KEEP_BUFFER_VARIABLES_STATIC == STD_ON, the certificate data is contained
     * in the global buffer KeyM_EcuCertBuf, which was parsed in
     * Ssa_KeyM_DataServices_DID_0193_SubjectKeyIdentifier_ConditionCheckRead. */
    retVal = KeyM_GetSerialNumberFromCert(KeyM_EcuCertBuf, &KeyM_ParsedEcuCert.serialNumber, Data, SSA_SIZEOF_SERIALNUMBER);

    if (retVal == E_OK)
    {
      retVal = RTE_E_OK;
    }
    else
    {
      retVal = RTE_E_DataServices_DID_0193_SerialNumber_E_NOT_OK;
    }
  }
  SSA_DUMMY_STATEMENT(OpStatus);    /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */

  return retVal;

/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << End of runnable implementation >>               DO NOT CHANGE THIS COMMENT!
 *********************************************************************************************************************/
}

/**********************************************************************************************************************
 *
 * Runnable Entity Name: Ssa_KeyM_DataServices_DID_0193_SubjectKeyIdentifier_ConditionCheckRead
 *
 *---------------------------------------------------------------------------------------------------------------------
 *
 * Executed if at least one of the following trigger conditions occurred:
 *   - triggered by server invocation for OperationPrototype <ConditionCheckRead> of PortPrototype <DataServices_DID_0193_SubjectKeyIdentifier>
 *
 **********************************************************************************************************************
 *
 * Runnable prototype:
 * ===================
 *   Std_ReturnType Ssa_KeyM_DataServices_DID_0193_SubjectKeyIdentifier_ConditionCheckRead(Dcm_OpStatusType OpStatus, Dcm_NegativeResponseCodeType *ErrorCode)
 *
 **********************************************************************************************************************
 *
 * Available Application Errors:
 * =============================
 *   RTE_E_DataServices_DID_0193_SubjectKeyIdentifier_DCM_E_PENDING
 *   RTE_E_DataServices_DID_0193_SubjectKeyIdentifier_E_NOT_OK
 *
 *********************************************************************************************************************/
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << Start of documentation area >>                  DO NOT CHANGE THIS COMMENT!
 * Symbol: Ssa_KeyM_DataServices_DID_0193_SubjectKeyIdentifier_ConditionCheckRead_doc
 *********************************************************************************************************************/
 /*!
 * Internal comment removed.
 *
 *
 *
 */

/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << End of documentation area >>                    DO NOT CHANGE THIS COMMENT!
 *********************************************************************************************************************/

FUNC(Std_ReturnType, Ssa_KeyM_CODE) Ssa_KeyM_DataServices_DID_0193_SubjectKeyIdentifier_ConditionCheckRead(
  Dcm_OpStatusType OpStatus,
  P2VAR(Dcm_NegativeResponseCodeType, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) ErrorCode) /* PRQA S 0624, 3206 */ /* MD_Rte_0624, MD_Rte_3206 */
{
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << Start of runnable implementation >>             DO NOT CHANGE THIS COMMENT!
 * Symbol: Ssa_KeyM_DataServices_DID_0193_SubjectKeyIdentifier_ConditionCheckRead (returns application error)
 *********************************************************************************************************************/

  Std_ReturnType retVal = RTE_E_DataServices_DID_0193_SubjectKeyIdentifier_E_NOT_OK;

  /* ----- Development Error Checks ------------------------------------- */
# if (SSA_DEV_ERROR_DETECT == STD_ON)
  if (ErrorCode == NULL_PTR)
  {
    /* retVal already set */
  }
  else
# endif /* SSA_DEV_ERROR_DETECT == STD_ON */
  {
# if (SSA_KEEP_BUFFER_VARIABLES_STATIC == STD_OFF)
    uint8 KeyM_EcuCertBuf[SSA_SIZEOF_CERT_MAX];
# endif

    Std_ReturnType retValParsing;
    uint16 ecuCertLength = SSA_SIZEOF_CERT_MAX;

    /* #10 Parse stored certificate. */
    retValParsing = KeyM_GetAndParseStoredCert(CERTP_PKI_ROLE_ECU, (P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR))KeyM_EcuCertBuf, &ecuCertLength, FALSE);

    if (retValParsing == E_OK)
    {
      /* #20 Check if subject key identifier can be read. */
      if ((KeyM_ParsedEcuCert.subjectKeyIdentifier.validContent) && (KeyM_ParsedEcuCert.subjectKeyIdentifier.elemDataLength <= sizeof(Dcm_Data20ByteType)))
      {
        retVal = RTE_E_OK;
      }
      else
      {
        /* invalid content or data length */
        *ErrorCode = DCM_E_GENERALREJECT;
      }
    }
    else
    {
      /* parsing error */
      *ErrorCode = DCM_E_GENERALREJECT;
    }
  }
  SSA_DUMMY_STATEMENT(OpStatus);    /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */

  return retVal;
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << End of runnable implementation >>               DO NOT CHANGE THIS COMMENT!
 *********************************************************************************************************************/
}

/**********************************************************************************************************************
 *
 * Runnable Entity Name: Ssa_KeyM_DataServices_DID_0193_SubjectKeyIdentifier_ReadData
 *
 *---------------------------------------------------------------------------------------------------------------------
 *
 * Executed if at least one of the following trigger conditions occurred:
 *   - triggered by server invocation for OperationPrototype <ReadData> of PortPrototype <DataServices_DID_0193_SubjectKeyIdentifier>
 *
 **********************************************************************************************************************
 *
 * Runnable prototype:
 * ===================
 *   Std_ReturnType Ssa_KeyM_DataServices_DID_0193_SubjectKeyIdentifier_ReadData(Dcm_OpStatusType OpStatus, uint8 *Data)
 *     Argument Data: uint8* is of type Dcm_Data20ByteType
 *
 **********************************************************************************************************************
 *
 * Available Application Errors:
 * =============================
 *   RTE_E_DataServices_DID_0193_SubjectKeyIdentifier_DCM_E_PENDING
 *   RTE_E_DataServices_DID_0193_SubjectKeyIdentifier_E_NOT_OK
 *
 *********************************************************************************************************************/
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << Start of documentation area >>                  DO NOT CHANGE THIS COMMENT!
 * Symbol: Ssa_KeyM_DataServices_DID_0193_SubjectKeyIdentifier_ReadData_doc
 *********************************************************************************************************************/
 /*!
 * Internal comment removed.
 *
 *
 *
 */
/*!
 * \spec
 *    requires $lengthOf(Data) >= sizeof(Dcm_Data20ByteType);
 * \endspec
 */
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << End of documentation area >>                    DO NOT CHANGE THIS COMMENT!
 *********************************************************************************************************************/

FUNC(Std_ReturnType, Ssa_KeyM_CODE) Ssa_KeyM_DataServices_DID_0193_SubjectKeyIdentifier_ReadData(
  Dcm_OpStatusType OpStatus,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) Data) /* PRQA S 0624, 3206 */ /* MD_Rte_0624, MD_Rte_3206 */
{
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << Start of runnable implementation >>             DO NOT CHANGE THIS COMMENT!
 * Symbol: Ssa_KeyM_DataServices_DID_0193_SubjectKeyIdentifier_ReadData (returns application error)
 *********************************************************************************************************************/
  Std_ReturnType retVal = RTE_E_DataServices_DID_0193_SubjectKeyIdentifier_E_NOT_OK;

  /* ----- Development Error Checks ------------------------------------- */
# if (SSA_DEV_ERROR_DETECT == STD_ON)
  if (Data == NULL_PTR)
  {
    /* retVal already set */
  }
  else
# endif /* SSA_DEV_ERROR_DETECT == STD_ON */
  {
# if (SSA_KEEP_BUFFER_VARIABLES_STATIC == STD_OFF)
    uint8 KeyM_EcuCertBuf[SSA_SIZEOF_CERT_MAX];
    uint16 ecuCertLength = SSA_SIZEOF_CERT_MAX;

    /* #10 Parse stored certificate. */
    (void)KeyM_GetAndParseStoredCert(CERTP_PKI_ROLE_ECU, (P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR))KeyM_EcuCertBuf, &ecuCertLength, FALSE);
# endif

    /* #20 Copy the subject key identifier to the output buffer considering its size. */
    /* If SSA_KEEP_BUFFER_VARIABLES_STATIC == STD_ON, the certificate data is contained
     * in the global buffer KeyM_EcuCertBuf, which was parsed in
     * Ssa_KeyM_DataServices_DID_0193_SubjectKeyIdentifier_ConditionCheckRead. */

    if (KeyM_ParsedEcuCert.subjectKeyIdentifier.elemDataLength <= sizeof(Dcm_Data20ByteType))
    {
      /* The length check was already done in Ssa_KeyM_DataServices_DID_0193_SubjectKeyIdentifier_ConditionCheckRead().
       * It is repeated here to facilitate the silent analysis.
       * If the length check is violated, nothing is copied to the output buffer, and the function returns E_OK. */
      Ssa_MemCpy(Data, &KeyM_EcuCertBuf[KeyM_ParsedEcuCert.subjectKeyIdentifier.elemDataIdx], KeyM_ParsedEcuCert.subjectKeyIdentifier.elemDataLength);
    }

    retVal = RTE_E_OK;
  }
  SSA_DUMMY_STATEMENT(OpStatus);    /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */

  return retVal;

/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << End of runnable implementation >>               DO NOT CHANGE THIS COMMENT!
 *********************************************************************************************************************/
}

/**********************************************************************************************************************
 *
 * Runnable Entity Name: Ssa_KeyM_DataServices_DID_0193_SubjectPublicKeyInfo_ConditionCheckRead
 *
 *---------------------------------------------------------------------------------------------------------------------
 *
 * Executed if at least one of the following trigger conditions occurred:
 *   - triggered by server invocation for OperationPrototype <ConditionCheckRead> of PortPrototype <DataServices_DID_0193_SubjectPublicKeyInfo>
 *
 **********************************************************************************************************************
 *
 * Runnable prototype:
 * ===================
 *   Std_ReturnType Ssa_KeyM_DataServices_DID_0193_SubjectPublicKeyInfo_ConditionCheckRead(Dcm_OpStatusType OpStatus, Dcm_NegativeResponseCodeType *ErrorCode)
 *
 **********************************************************************************************************************
 *
 * Available Application Errors:
 * =============================
 *   RTE_E_DataServices_DID_0193_SubjectPublicKeyInfo_DCM_E_PENDING
 *   RTE_E_DataServices_DID_0193_SubjectPublicKeyInfo_E_NOT_OK
 *
 *********************************************************************************************************************/
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << Start of documentation area >>                  DO NOT CHANGE THIS COMMENT!
 * Symbol: Ssa_KeyM_DataServices_DID_0193_SubjectPublicKeyInfo_ConditionCheckRead_doc
 *********************************************************************************************************************/
 /*!
 * Internal comment removed.
 *
 *
 */

/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << End of documentation area >>                    DO NOT CHANGE THIS COMMENT!
 *********************************************************************************************************************/

FUNC(Std_ReturnType, Ssa_KeyM_CODE) Ssa_KeyM_DataServices_DID_0193_SubjectPublicKeyInfo_ConditionCheckRead(
  Dcm_OpStatusType OpStatus,
  P2VAR(Dcm_NegativeResponseCodeType, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) ErrorCode) /* PRQA S 0624, 3206 */ /* MD_Rte_0624, MD_Rte_3206 */
{
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << Start of runnable implementation >>             DO NOT CHANGE THIS COMMENT!
 * Symbol: Ssa_KeyM_DataServices_DID_0193_SubjectPublicKeyInfo_ConditionCheckRead (returns application error)
 *********************************************************************************************************************/

  Std_ReturnType retVal = RTE_E_DataServices_DID_0193_SubjectPublicKeyInfo_E_NOT_OK;

  /* ----- Development Error Checks ------------------------------------- */
# if (SSA_DEV_ERROR_DETECT == STD_ON)
  if (ErrorCode == NULL_PTR)
  {
    /* retVal already set */
  }
  else
# endif /* SSA_DEV_ERROR_DETECT == STD_ON */
  {
    /* #10 Check if public key can be read. */
    if ((KeyM_ParsedEcuCert.publicKey.validContent) && (KeyM_ParsedEcuCert.publicKey.elemDataLength <= sizeof(Dcm_Data32ByteType)))
    {
      retVal = RTE_E_OK;
    }
    else
    {
      /* invalid content or data length */
      *ErrorCode = DCM_E_GENERALREJECT;
    }
  }
  SSA_DUMMY_STATEMENT(OpStatus);    /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */

  return retVal;

/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << End of runnable implementation >>               DO NOT CHANGE THIS COMMENT!
 *********************************************************************************************************************/
}

/**********************************************************************************************************************
 *
 * Runnable Entity Name: Ssa_KeyM_DataServices_DID_0193_SubjectPublicKeyInfo_ReadData
 *
 *---------------------------------------------------------------------------------------------------------------------
 *
 * Executed if at least one of the following trigger conditions occurred:
 *   - triggered by server invocation for OperationPrototype <ReadData> of PortPrototype <DataServices_DID_0193_SubjectPublicKeyInfo>
 *
 **********************************************************************************************************************
 *
 * Runnable prototype:
 * ===================
 *   Std_ReturnType Ssa_KeyM_DataServices_DID_0193_SubjectPublicKeyInfo_ReadData(Dcm_OpStatusType OpStatus, uint8 *Data)
 *     Argument Data: uint8* is of type Dcm_Data32ByteType
 *
 **********************************************************************************************************************
 *
 * Available Application Errors:
 * =============================
 *   RTE_E_DataServices_DID_0193_SubjectPublicKeyInfo_DCM_E_PENDING
 *   RTE_E_DataServices_DID_0193_SubjectPublicKeyInfo_E_NOT_OK
 *
 *********************************************************************************************************************/
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << Start of documentation area >>                  DO NOT CHANGE THIS COMMENT!
 * Symbol: Ssa_KeyM_DataServices_DID_0193_SubjectPublicKeyInfo_ReadData_doc
 *********************************************************************************************************************/
 /*!
 * Internal comment removed.
 *
 *
 *
 */
/*!
 * \spec
 *    requires $lengthOf(Data) >= sizeof(Dcm_Data32ByteType);
 * \endspec
 */
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << End of documentation area >>                    DO NOT CHANGE THIS COMMENT!
 *********************************************************************************************************************/

FUNC(Std_ReturnType, Ssa_KeyM_CODE) Ssa_KeyM_DataServices_DID_0193_SubjectPublicKeyInfo_ReadData(
  Dcm_OpStatusType OpStatus,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) Data) /* PRQA S 0624, 3206 */ /* MD_Rte_0624, MD_Rte_3206 */
{
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << Start of runnable implementation >>             DO NOT CHANGE THIS COMMENT!
 * Symbol: Ssa_KeyM_DataServices_DID_0193_SubjectPublicKeyInfo_ReadData (returns application error)
 *********************************************************************************************************************/

  Std_ReturnType retVal = RTE_E_DataServices_DID_0193_SubjectPublicKeyInfo_E_NOT_OK;

 /* ----- Development Error Checks ------------------------------------- */
# if (SSA_DEV_ERROR_DETECT == STD_ON)
  if (Data == NULL_PTR)
  {
    /* retVal already set */
  }
  else
# endif /* SSA_DEV_ERROR_DETECT == STD_ON */
  {
# if (SSA_KEEP_BUFFER_VARIABLES_STATIC == STD_OFF)
    uint8 KeyM_EcuCertBuf[SSA_SIZEOF_CERT_MAX];
    uint16 ecuCertLength = SSA_SIZEOF_CERT_MAX;

    /* #10 Parse stored certificate. */
    (void)KeyM_GetAndParseStoredCert(CERTP_PKI_ROLE_ECU, (P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR))KeyM_EcuCertBuf, &ecuCertLength, FALSE);
# endif

    /* #20 Copy the public key to the output buffer considering its size. */
    /* If SSA_KEEP_BUFFER_VARIABLES_STATIC == STD_ON, the certificate data is contained
     * in the global buffer KeyM_EcuCertBuf, which was parsed in
     * Ssa_KeyM_DataServices_DID_0193_SubjectKeyIdentifier_ConditionCheckRead. */

    if (KeyM_ParsedEcuCert.publicKey.elemDataLength <= sizeof(Dcm_Data32ByteType))
    {
      /* The length check was already done in Ssa_KeyM_DataServices_DID_0193_SubjectPublicKeyInfo_ConditionCheckRead().
       * It is repeated here to facilitate the silent analysis.
       * If the length check is violated, nothing is copied to the output buffer, and the function returns E_OK. */
      Ssa_MemCpy(Data, &KeyM_EcuCertBuf[KeyM_ParsedEcuCert.publicKey.elemDataIdx], KeyM_ParsedEcuCert.publicKey.elemDataLength);
    }

    retVal = RTE_E_OK;
  }

  SSA_DUMMY_STATEMENT(OpStatus);    /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */

  return retVal;

/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << End of runnable implementation >>               DO NOT CHANGE THIS COMMENT!
 *********************************************************************************************************************/
}

/**********************************************************************************************************************
 *
 * Runnable Entity Name: Ssa_KeyM_DataServices_DID_0194_ECC_CA_Certificate_Identification_ConditionCheckRead
 *
 *---------------------------------------------------------------------------------------------------------------------
 *
 * Executed if at least one of the following trigger conditions occurred:
 *   - triggered by server invocation for OperationPrototype <ConditionCheckRead> of PortPrototype <DataServices_DID_0194_ECC_CA_Certificate_Identification>
 *
 **********************************************************************************************************************
 *
 * Runnable prototype:
 * ===================
 *   Std_ReturnType Ssa_KeyM_DataServices_DID_0194_ECC_CA_Certificate_Identification_ConditionCheckRead(Dcm_OpStatusType OpStatus, Dcm_NegativeResponseCodeType *ErrorCode)
 *
 **********************************************************************************************************************
 *
 * Available Application Errors:
 * =============================
 *   RTE_E_DataServices_DID_0194_ECC_CA_Certificate_Identification_DCM_E_PENDING
 *   RTE_E_DataServices_DID_0194_ECC_CA_Certificate_Identification_E_NOT_OK
 *
 *********************************************************************************************************************/
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << Start of documentation area >>                  DO NOT CHANGE THIS COMMENT!
 * Symbol: Ssa_KeyM_DataServices_DID_0194_ECC_CA_Certificate_Identification_ConditionCheckRead_doc
 *********************************************************************************************************************/
 /*!
 * Internal comment removed.
 *
 *
 */

/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << End of documentation area >>                    DO NOT CHANGE THIS COMMENT!
 *********************************************************************************************************************/

FUNC(Std_ReturnType, Ssa_KeyM_CODE) Ssa_KeyM_DataServices_DID_0194_ECC_CA_Certificate_Identification_ConditionCheckRead(
  Dcm_OpStatusType OpStatus,
  P2VAR(Dcm_NegativeResponseCodeType, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) ErrorCode) /* PRQA S 0624, 3206 */ /* MD_Rte_0624, MD_Rte_3206 */
{
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << Start of runnable implementation >>             DO NOT CHANGE THIS COMMENT!
 * Symbol: Ssa_KeyM_DataServices_DID_0194_ECC_CA_Certificate_Identification_ConditionCheckRead (returns application error)
 *********************************************************************************************************************/
  Std_ReturnType retVal = RTE_E_DataServices_DID_0194_ECC_CA_Certificate_Identification_E_NOT_OK;

  /* ----- Development Error Checks ------------------------------------- */
# if (SSA_DEV_ERROR_DETECT == STD_ON)
  if (ErrorCode == NULL_PTR)
  {
    /* retVal already set */
  }
  else
# endif /* SSA_DEV_ERROR_DETECT == STD_ON */
  {
    /* #10 Always return successfully from condition check. */
    *ErrorCode = DCM_E_POSITIVERESPONSE;
    retVal = RTE_E_OK;
  }
  SSA_DUMMY_STATEMENT(OpStatus);    /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */

  return retVal;

/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << End of runnable implementation >>               DO NOT CHANGE THIS COMMENT!
 *********************************************************************************************************************/
}

/**********************************************************************************************************************
 *
 * Runnable Entity Name: Ssa_KeyM_DataServices_DID_0194_ECC_CA_Certificate_Identification_ReadData
 *
 *---------------------------------------------------------------------------------------------------------------------
 *
 * Executed if at least one of the following trigger conditions occurred:
 *   - triggered by server invocation for OperationPrototype <ReadData> of PortPrototype <DataServices_DID_0194_ECC_CA_Certificate_Identification>
 *
 **********************************************************************************************************************
 *
 * Runnable prototype:
 * ===================
 *   Std_ReturnType Ssa_KeyM_DataServices_DID_0194_ECC_CA_Certificate_Identification_ReadData(Dcm_OpStatusType OpStatus, uint8 *Data)
 *     Argument Data: uint8* is of type Dcm_Data20ByteType
 *
 **********************************************************************************************************************
 *
 * Available Application Errors:
 * =============================
 *   RTE_E_DataServices_DID_0194_ECC_CA_Certificate_Identification_DCM_E_PENDING
 *   RTE_E_DataServices_DID_0194_ECC_CA_Certificate_Identification_E_NOT_OK
 *
 *********************************************************************************************************************/
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << Start of documentation area >>                  DO NOT CHANGE THIS COMMENT!
 * Symbol: Ssa_KeyM_DataServices_DID_0194_ECC_CA_Certificate_Identification_ReadData_doc
 *********************************************************************************************************************/
 /*!
 * Internal comment removed.
 *
 *
 *
 */
/*!
 * \spec
 *    requires $lengthOf(Data) >= sizeof(Dcm_Data20ByteType);
 * \endspec
 */
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << End of documentation area >>                    DO NOT CHANGE THIS COMMENT!
 *********************************************************************************************************************/

FUNC(Std_ReturnType, Ssa_KeyM_CODE) Ssa_KeyM_DataServices_DID_0194_ECC_CA_Certificate_Identification_ReadData(
  Dcm_OpStatusType OpStatus,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) Data) /* PRQA S 0624, 3206 */ /* MD_Rte_0624, MD_Rte_3206 */
{
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << Start of runnable implementation >>             DO NOT CHANGE THIS COMMENT!
 * Symbol: Ssa_KeyM_DataServices_DID_0194_ECC_CA_Certificate_Identification_ReadData (returns application error)
 *********************************************************************************************************************/

  Std_ReturnType rVal = RTE_E_DataServices_DID_0194_ECC_CA_Certificate_Identification_E_NOT_OK;

  /* ----- Development Error Checks ------------------------------------- */
# if (SSA_DEV_ERROR_DETECT == STD_ON)
  if (Data == NULL_PTR)
  {
    /* retVal already set */
  }
  else
# endif /* SSA_DEV_ERROR_DETECT == STD_ON */
  {
# if (SSA_KEEP_BUFFER_VARIABLES_STATIC == STD_OFF)
    uint8 KeyM_BackendCertBuf[SSA_SIZEOF_CERT_MAX];
# endif
    uint16 backendCertLength = SSA_SIZEOF_CERT_MAX;

    /* #10 Get the parsed, stored Backend CA certificate. */
    rVal = KeyM_GetAndParseStoredCert(CERTP_PKI_ROLE_BACKEND, (P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR))KeyM_BackendCertBuf, (P2VAR(uint16, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR))&backendCertLength, FALSE);

    if ((rVal == E_OK)
      && (KeyM_ParsedBackendCert.subjectKeyIdentifier.validContent)
      && (KeyM_ParsedBackendCert.subjectKeyIdentifier.elemDataLength <= SSA_SIZEOF_CERT_SUBJECT_KEY_ID))
    {
      /* #20 Copy the subject key identifier to the output buffer considering its size. */
      Ssa_MemCpy(Data, (P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA))&(KeyM_BackendCertBuf[KeyM_ParsedBackendCert.subjectKeyIdentifier.elemDataIdx]), KeyM_ParsedBackendCert.subjectKeyIdentifier.elemDataLength);
      rVal = RTE_E_OK;
    }
    else
    {
      rVal = RTE_E_DataServices_DID_0194_ECC_CA_Certificate_Identification_E_NOT_OK;
    }
  }
  SSA_DUMMY_STATEMENT(OpStatus);    /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */

  return rVal;

/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << End of runnable implementation >>               DO NOT CHANGE THIS COMMENT!
 *********************************************************************************************************************/
}
#endif

/**********************************************************************************************************************
 *
 * Runnable Entity Name: Ssa_KeyM_DataServices_DID_0198_Root_Replacement_Key_ConditionCheckRead
 *
 *---------------------------------------------------------------------------------------------------------------------
 *
 * Executed if at least one of the following trigger conditions occurred:
 *   - triggered by server invocation for OperationPrototype <ConditionCheckRead> of PortPrototype <DataServices_DID_0198_Root_Replacement_Key>
 *
 **********************************************************************************************************************
 *
 * Service Calls:
 * ==============
 *   Service Invocation:
 *   -------------------
 *   Std_ReturnType Rte_Call_Key_TrustModelRootReplacementKey_KeyElementGet(uint32 keyElementId, uint8 *keyPtr, uint32 *keyLength)
 *     Argument keyPtr: uint8* is of type Csm_KeyDataType_Ssa_SigPubKey_ReplacementAuthority
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_CsmKeyManagement_Ssa_SigPubKey_ReplacementAuthority_CSM_E_BUSY, RTE_E_CsmKeyManagement_Ssa_SigPubKey_ReplacementAuthority_CSM_E_KEY_EMPTY, RTE_E_CsmKeyManagement_Ssa_SigPubKey_ReplacementAuthority_CSM_E_KEY_NOT_AVAILABLE, RTE_E_CsmKeyManagement_Ssa_SigPubKey_ReplacementAuthority_CSM_E_KEY_READ_FAIL, RTE_E_CsmKeyManagement_Ssa_SigPubKey_ReplacementAuthority_CSM_E_SMALL_BUFFER, RTE_E_CsmKeyManagement_Ssa_SigPubKey_ReplacementAuthority_E_NOT_OK
 *
 **********************************************************************************************************************
 *
 * Runnable prototype:
 * ===================
 *   Std_ReturnType Ssa_KeyM_DataServices_DID_0198_Root_Replacement_Key_ConditionCheckRead(Dcm_OpStatusType OpStatus, Dcm_NegativeResponseCodeType *ErrorCode)
 *
 **********************************************************************************************************************
 *
 * Available Application Errors:
 * =============================
 *   RTE_E_DataServices_DID_0198_Root_Replacement_Key_DCM_E_PENDING
 *   RTE_E_DataServices_DID_0198_Root_Replacement_Key_E_NOT_OK
 *
 *********************************************************************************************************************/
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << Start of documentation area >>                  DO NOT CHANGE THIS COMMENT!
 * Symbol: Ssa_KeyM_DataServices_DID_0198_Root_Replacement_Key_ConditionCheckRead_doc
 *********************************************************************************************************************/
 /*!
 * Internal comment removed.
 *
 *
 */
/* PRQA S 3673 8 */ /* MD_SSA_PARAM_NOT_P2CONST */
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << End of documentation area >>                    DO NOT CHANGE THIS COMMENT!
 *********************************************************************************************************************/

FUNC(Std_ReturnType, Ssa_KeyM_CODE) Ssa_KeyM_DataServices_DID_0198_Root_Replacement_Key_ConditionCheckRead(
  Dcm_OpStatusType OpStatus,
  P2VAR(Dcm_NegativeResponseCodeType, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) ErrorCode) /* PRQA S 0624, 3206 */ /* MD_Rte_0624, MD_Rte_3206 */
{
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << Start of runnable implementation >>             DO NOT CHANGE THIS COMMENT!
 * Symbol: Ssa_KeyM_DataServices_DID_0198_Root_Replacement_Key_ConditionCheckRead (returns application error)
 *********************************************************************************************************************/
  Std_ReturnType retVal = RTE_E_DataServices_DID_0198_Root_Replacement_Key_E_NOT_OK;

  /* ----- Development Error Checks ------------------------------------- */
#if (SSA_DEV_ERROR_DETECT == STD_ON)
  if (ErrorCode == NULL_PTR)
  {
    /* retVal already set */
  }
  else
#endif /* SSA_DEV_ERROR_DETECT == STD_ON */
  {
    *ErrorCode = DCM_E_POSITIVERESPONSE;
    retVal = RTE_E_OK;
  }

  SSA_DUMMY_STATEMENT(OpStatus);    /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */

  return retVal;

/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << End of runnable implementation >>               DO NOT CHANGE THIS COMMENT!
 *********************************************************************************************************************/
}

/**********************************************************************************************************************
 *
 * Runnable Entity Name: Ssa_KeyM_DataServices_DID_0198_Root_Replacement_Key_ReadData
 *
 *---------------------------------------------------------------------------------------------------------------------
 *
 * Executed if at least one of the following trigger conditions occurred:
 *   - triggered by server invocation for OperationPrototype <ReadData> of PortPrototype <DataServices_DID_0198_Root_Replacement_Key>
 *
 **********************************************************************************************************************
 *
 * Service Calls:
 * ==============
 *   Service Invocation:
 *   -------------------
 *   Std_ReturnType Rte_Call_Key_TrustModelRootReplacementKey_KeyElementGet(uint32 keyElementId, uint8 *keyPtr, uint32 *keyLength)
 *     Argument keyPtr: uint8* is of type Csm_KeyDataType_Ssa_SigPubKey_ReplacementAuthority
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_CsmKeyManagement_Ssa_SigPubKey_ReplacementAuthority_CSM_E_BUSY, RTE_E_CsmKeyManagement_Ssa_SigPubKey_ReplacementAuthority_CSM_E_KEY_EMPTY, RTE_E_CsmKeyManagement_Ssa_SigPubKey_ReplacementAuthority_CSM_E_KEY_NOT_AVAILABLE, RTE_E_CsmKeyManagement_Ssa_SigPubKey_ReplacementAuthority_CSM_E_KEY_READ_FAIL, RTE_E_CsmKeyManagement_Ssa_SigPubKey_ReplacementAuthority_CSM_E_SMALL_BUFFER, RTE_E_CsmKeyManagement_Ssa_SigPubKey_ReplacementAuthority_E_NOT_OK
 *
 **********************************************************************************************************************
 *
 * Runnable prototype:
 * ===================
 *   Std_ReturnType Ssa_KeyM_DataServices_DID_0198_Root_Replacement_Key_ReadData(Dcm_OpStatusType OpStatus, uint8 *Data)
 *     Argument Data: uint8* is of type Dcm_Data32ByteType
 *
 **********************************************************************************************************************
 *
 * Available Application Errors:
 * =============================
 *   RTE_E_DataServices_DID_0198_Root_Replacement_Key_DCM_E_PENDING
 *   RTE_E_DataServices_DID_0198_Root_Replacement_Key_E_NOT_OK
 *
 *********************************************************************************************************************/
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << Start of documentation area >>                  DO NOT CHANGE THIS COMMENT!
 * Symbol: Ssa_KeyM_DataServices_DID_0198_Root_Replacement_Key_ReadData_doc
 *********************************************************************************************************************/
 /*!
 * Internal comment removed.
 *
 *
 */
/*!
 * \spec
 *    requires $lengthOf(Data) >= sizeof(Dcm_Data32ByteType);
 * \endspec
 */
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << End of documentation area >>                    DO NOT CHANGE THIS COMMENT!
 *********************************************************************************************************************/

FUNC(Std_ReturnType, Ssa_KeyM_CODE) Ssa_KeyM_DataServices_DID_0198_Root_Replacement_Key_ReadData(
  Dcm_OpStatusType OpStatus,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) Data) /* PRQA S 0624, 3206 */ /* MD_Rte_0624, MD_Rte_3206 */
{
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << Start of runnable implementation >>             DO NOT CHANGE THIS COMMENT!
 * Symbol: Ssa_KeyM_DataServices_DID_0198_Root_Replacement_Key_ReadData (returns application error)
 *********************************************************************************************************************/
  Std_ReturnType retVal = RTE_E_DataServices_DID_0198_Root_Replacement_Key_E_NOT_OK;

  /* ----- Development Error Checks ------------------------------------- */
#if (SSA_DEV_ERROR_DETECT == STD_ON)
  if (Data == NULL_PTR)
  {
    /* retVal already set */
  }
  else
#endif /* SSA_DEV_ERROR_DETECT == STD_ON */
  {
    uint32 DataLength = SSA_SIZEOF_PUBLICKEY;
    retVal = (Rte_Call_Key_TrustModelRootReplacementKey_KeyElementGet(SSA_KE_SIGNATURE_KEY, Data, &DataLength) == RTE_E_OK) ? RTE_E_OK : RTE_E_DataServices_DID_0198_Root_Replacement_Key_E_NOT_OK;
  }
  SSA_DUMMY_STATEMENT(OpStatus);    /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */

  return retVal;

/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << End of runnable implementation >>               DO NOT CHANGE THIS COMMENT!
 *********************************************************************************************************************/
}

#if (SSA_ECU_TYPE != SSA_ECU_TYPE_VSM)
/**********************************************************************************************************************
 *
 * Runnable Entity Name: Ssa_KeyM_DataServices_DID_0199_Certificates_ConditionCheckRead
 *
 *---------------------------------------------------------------------------------------------------------------------
 *
 * Executed if at least one of the following trigger conditions occurred:
 *   - triggered by server invocation for OperationPrototype <ConditionCheckRead> of PortPrototype <DataServices_DID_0199_Certificates>
 *
 **********************************************************************************************************************
 *
 * Client/Server Interfaces:
 * =========================
 *   Server Invocation:
 *   ------------------
 *   Std_ReturnType Rte_Call_RightsM_DiagnosticChannel_GetDiagnosticUserRole(RightsM_DiagnosticUserRoleType *userRole)
 *     Synchronous Server Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_RightsM_DiagnosticChannel_E_NOT_OK
 *   Std_ReturnType Rte_Call_RightsM_EnhancedRights_VerifySubjectKeyIdentifier(const uint8 *subjectKeyIdentifier)
 *     Argument subjectKeyIdentifier: uint8* is of type Ssa_Data20ByteType
 *     Synchronous Server Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_RightsM_EnhancedRights_E_NOT_OK
 *
 * Service Calls:
 * ==============
 *   Service Invocation:
 *   -------------------
 *   Std_ReturnType Rte_Call_KeyMCertificateElement_Ssa_TrustModelEcuCert_ext_subKeyId_CertificateElementGet(uint8 *CertificateElementData, uint32 *CertificateDataLength)
 *     Argument CertificateElementData: uint8* is of type KeyM_CertificateElementType_Ssa_TrustModelEcuCert_ext_subKeyId
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_KeyMCertificateElement_Ssa_TrustModelEcuCert_ext_subKeyId_E_NOT_OK, RTE_E_KeyMCertificateElement_Ssa_TrustModelEcuCert_ext_subKeyId_KEYM_E_KEY_CERT_EMPTY, RTE_E_KeyMCertificateElement_Ssa_TrustModelEcuCert_ext_subKeyId_KEYM_E_KEY_CERT_INVALID, RTE_E_KeyMCertificateElement_Ssa_TrustModelEcuCert_ext_subKeyId_KEYM_E_KEY_CERT_SIZE_MISMATCH, RTE_E_KeyMCertificateElement_Ssa_TrustModelEcuCert_ext_subKeyId_KEYM_E_PARAMETER_MISMATCH
 *   Std_ReturnType Rte_Call_KeyMCertificate_Ssa_TrustModelBackendCert_GetStatus(KeyM_CertificateStatusType *Status)
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_KeyMCertificate_Ssa_TrustModelBackendCert_E_NOT_OK
 *   Std_ReturnType Rte_Call_KeyMCertificate_Ssa_TrustModelEcuCert_GetStatus(KeyM_CertificateStatusType *Status)
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_KeyMCertificate_Ssa_TrustModelEcuCert_E_NOT_OK
 *   Std_ReturnType Rte_Call_KeyMCertificate_Ssa_TrustModelIntermediateCert_GetStatus(KeyM_CertificateStatusType *Status)
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_KeyMCertificate_Ssa_TrustModelIntermediateCert_E_NOT_OK
 *
 **********************************************************************************************************************
 *
 * Runnable prototype:
 * ===================
 *   Std_ReturnType Ssa_KeyM_DataServices_DID_0199_Certificates_ConditionCheckRead(Dcm_OpStatusType OpStatus, Dcm_NegativeResponseCodeType *ErrorCode)
 *
 **********************************************************************************************************************
 *
 * Available Application Errors:
 * =============================
 *   RTE_E_DataServices_DID_0199_Certificates_DCM_E_PENDING
 *   RTE_E_DataServices_DID_0199_Certificates_E_NOT_OK
 *
 *********************************************************************************************************************/
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << Start of documentation area >>                  DO NOT CHANGE THIS COMMENT!
 * Symbol: Ssa_KeyM_DataServices_DID_0199_Certificates_ConditionCheckRead_doc
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 */

/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << End of documentation area >>                    DO NOT CHANGE THIS COMMENT!
 *********************************************************************************************************************/

FUNC(Std_ReturnType, Ssa_KeyM_CODE) Ssa_KeyM_DataServices_DID_0199_Certificates_ConditionCheckRead(
  Dcm_OpStatusType OpStatus,
  P2VAR(Dcm_NegativeResponseCodeType, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) ErrorCode) /* PRQA S 0624, 3206 */ /* MD_Rte_0624, MD_Rte_3206 */
{
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << Start of runnable implementation >>             DO NOT CHANGE THIS COMMENT!
 * Symbol: Ssa_KeyM_DataServices_DID_0199_Certificates_ConditionCheckRead (returns application error)
 *********************************************************************************************************************/
  Std_ReturnType retVal = RTE_E_DataServices_DID_0199_Certificates_E_NOT_OK;

  /* ----- Development Error Checks ------------------------------------- */
# if (SSA_DEV_ERROR_DETECT == STD_ON)
  if (ErrorCode == NULL_PTR)
  {
    /* retVal already set */
  }
  else
# endif /* SSA_DEV_ERROR_DETECT == STD_ON */
  {
    /* #5 Check that access to the Trust Model Chain is granted. */
    if (*Rte_Pim_KeyMTrustModelChainOfTrustState() == SSA_TRUSTMODELCHAINSTATE_INITIAL)
    {
      *ErrorCode = DCM_E_CONDITIONSNOTCORRECT;
    }

    /* #10 Check states of all certificates. */
    else
    {
      boolean valid = KeyM_KeyM_CertificateIsReadable(SSA_TRUST_MODEL_BACKEND_CERT_ID, ErrorCode);

      if (valid == TRUE)
      {
        valid = KeyM_KeyM_CertificateIsReadable(SSA_TRUST_MODEL_INTERMEDIATE_CERT_ID, ErrorCode);
      }
      if (valid == TRUE)
      {
        valid = KeyM_KeyM_CertificateIsReadable(SSA_TRUST_MODEL_ECU_CERT_ID, ErrorCode);
      }

      if (valid == FALSE)
      {
        /* NRC and retVal already set */
      }
      else
      {
        retVal = RTE_E_OK;
      }
    }
  }
  SSA_DUMMY_STATEMENT(OpStatus);    /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */

  return retVal;
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << End of runnable implementation >>               DO NOT CHANGE THIS COMMENT!
 *********************************************************************************************************************/
}

/**********************************************************************************************************************
 *
 * Runnable Entity Name: Ssa_KeyM_DataServices_DID_0199_Certificates_ReadData
 *
 *---------------------------------------------------------------------------------------------------------------------
 *
 * Executed if at least one of the following trigger conditions occurred:
 *   - triggered by server invocation for OperationPrototype <ReadData> of PortPrototype <DataServices_DID_0199_Certificates>
 *
 **********************************************************************************************************************
 *
 * Client/Server Interfaces:
 * =========================
 *   Server Invocation:
 *   ------------------
 *   Std_ReturnType Rte_Call_SsaCdd_TrustModel_GetCertificate(KeyM_CertificateIdType CertId, Ssa_DataPtr CertData, Ssa_LengthPtr CertDataLength)
 *     Synchronous Server Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_SsaCdd_KeyM_CertInterface_E_NOT_OK, RTE_E_SsaCdd_KeyM_CertInterface_KEYM_E_KEY_CERT_EMPTY, RTE_E_SsaCdd_KeyM_CertInterface_KEYM_E_KEY_CERT_READ_FAIL, RTE_E_SsaCdd_KeyM_CertInterface_KEYM_E_KEY_CERT_SIZE_MISMATCH, RTE_E_SsaCdd_KeyM_CertInterface_KEYM_E_PARAMETER_MISMATCH
 *
 **********************************************************************************************************************
 *
 * Runnable prototype:
 * ===================
 *   Std_ReturnType Ssa_KeyM_DataServices_DID_0199_Certificates_ReadData(Dcm_OpStatusType OpStatus, uint8 *Data)
 *     Argument Data: uint8* is of type Dcm_Data3006ByteType
 *
 **********************************************************************************************************************
 *
 * Available Application Errors:
 * =============================
 *   RTE_E_DataServices_DID_0199_Certificates_DCM_E_PENDING
 *   RTE_E_DataServices_DID_0199_Certificates_E_NOT_OK
 *
 *********************************************************************************************************************/
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << Start of documentation area >>                  DO NOT CHANGE THIS COMMENT!
 * Symbol: Ssa_KeyM_DataServices_DID_0199_Certificates_ReadData_doc
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
/*!
 * \spec
 *    requires $lengthOf(Data) >= sizeof(Dcm_Data3006ByteType);
 * \endspec
 */
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << End of documentation area >>                    DO NOT CHANGE THIS COMMENT!
 *********************************************************************************************************************/

FUNC(Std_ReturnType, Ssa_KeyM_CODE) Ssa_KeyM_DataServices_DID_0199_Certificates_ReadData(
  Dcm_OpStatusType OpStatus,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) Data) /* PRQA S 0624, 3206 */ /* MD_Rte_0624, MD_Rte_3206 */
{
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << Start of runnable implementation >>             DO NOT CHANGE THIS COMMENT!
 * Symbol: Ssa_KeyM_DataServices_DID_0199_Certificates_ReadData (returns application error)
 *********************************************************************************************************************/

  Std_ReturnType retVal = RTE_E_DataServices_DID_0199_Certificates_E_NOT_OK;

  /* ----- Development Error Checks ------------------------------------- */
# if (SSA_DEV_ERROR_DETECT == STD_ON)
  if (Data == NULL_PTR)
  {
    /* retVal already set */
  }
  else
# endif /* SSA_DEV_ERROR_DETECT == STD_ON */
  {
    uint16 dataIdx = 0u;
    uint16 dataLength = sizeof(Dcm_Data3006ByteType);

    /* #10 Append all required certificates: ECU, Intermediate, Backend. */
    retVal = KeyM_KeyM_GetCertificateDataAsIteration(SSA_TRUST_MODEL_ECU_CERT_ID, &Data[dataIdx], &dataLength);
    if (retVal == E_OK)
    {
      dataIdx = dataLength;
      dataLength = (uint16)(sizeof(Dcm_Data3006ByteType) - dataIdx);
      retVal = KeyM_KeyM_GetCertificateDataAsIteration(SSA_TRUST_MODEL_INTERMEDIATE_CERT_ID, &Data[dataIdx], &dataLength);
    }

    if (retVal == E_OK)
    {
      dataIdx += dataLength;
      dataLength = (uint16)(sizeof(Dcm_Data3006ByteType) - dataIdx);
      retVal = KeyM_KeyM_GetCertificateDataAsIteration(SSA_TRUST_MODEL_BACKEND_CERT_ID, &Data[dataIdx], &dataLength);
    }

    retVal = (retVal == E_OK) ? RTE_E_OK : RTE_E_DataServices_DID_0199_Certificates_E_NOT_OK;
  }
  SSA_DUMMY_STATEMENT(OpStatus);    /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */

  return retVal;
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << End of runnable implementation >>               DO NOT CHANGE THIS COMMENT!
 *********************************************************************************************************************/
}

/**********************************************************************************************************************
 *
 * Runnable Entity Name: Ssa_KeyM_DataServices_DID_0199_Certificates_ReadDataLength
 *
 *---------------------------------------------------------------------------------------------------------------------
 *
 * Executed if at least one of the following trigger conditions occurred:
 *   - triggered by server invocation for OperationPrototype <ReadDataLength> of PortPrototype <DataServices_DID_0199_Certificates>
 *
 **********************************************************************************************************************
 *
 * Client/Server Interfaces:
 * =========================
 *   Server Invocation:
 *   ------------------
 *   Std_ReturnType Rte_Call_SsaCdd_TrustModel_GetCertificate(KeyM_CertificateIdType CertId, Ssa_DataPtr CertData, Ssa_LengthPtr CertDataLength)
 *     Synchronous Server Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_SsaCdd_KeyM_CertInterface_E_NOT_OK, RTE_E_SsaCdd_KeyM_CertInterface_KEYM_E_KEY_CERT_EMPTY, RTE_E_SsaCdd_KeyM_CertInterface_KEYM_E_KEY_CERT_READ_FAIL, RTE_E_SsaCdd_KeyM_CertInterface_KEYM_E_KEY_CERT_SIZE_MISMATCH, RTE_E_SsaCdd_KeyM_CertInterface_KEYM_E_PARAMETER_MISMATCH
 *
 **********************************************************************************************************************
 *
 * Runnable prototype:
 * ===================
 *   Std_ReturnType Ssa_KeyM_DataServices_DID_0199_Certificates_ReadDataLength(Dcm_OpStatusType OpStatus, uint16 *DataLength)
 *
 **********************************************************************************************************************
 *
 * Available Application Errors:
 * =============================
 *   RTE_E_DataServices_DID_0199_Certificates_DCM_E_PENDING
 *   RTE_E_DataServices_DID_0199_Certificates_E_NOT_OK
 *
 *********************************************************************************************************************/
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << Start of documentation area >>                  DO NOT CHANGE THIS COMMENT!
 * Symbol: Ssa_KeyM_DataServices_DID_0199_Certificates_ReadDataLength_doc
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */

/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << End of documentation area >>                    DO NOT CHANGE THIS COMMENT!
 *********************************************************************************************************************/

FUNC(Std_ReturnType, Ssa_KeyM_CODE) Ssa_KeyM_DataServices_DID_0199_Certificates_ReadDataLength(
  Dcm_OpStatusType OpStatus,
  P2VAR(uint16, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) DataLength) /* PRQA S 0624, 3206 */ /* MD_Rte_0624, MD_Rte_3206 */
{
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << Start of runnable implementation >>             DO NOT CHANGE THIS COMMENT!
 * Symbol: Ssa_KeyM_DataServices_DID_0199_Certificates_ReadDataLength (returns application error)
 *********************************************************************************************************************/
  Std_ReturnType retVal = RTE_E_DataServices_DID_0199_Certificates_E_NOT_OK;

  /* ----- Development Error Checks ------------------------------------- */
# if (SSA_DEV_ERROR_DETECT == STD_ON)
  if (DataLength == NULL_PTR)
  {
    /* retVal already set */
  }
  else
# endif /* SSA_DEV_ERROR_DETECT == STD_ON */
  {
    Dcm_Data1002ByteType buffer;
    uint16 bufferLength = sizeof(Dcm_Data1002ByteType);

    /* #10 Get summarized lengths of all certificate. */

    retVal = KeyM_KeyM_GetCertificateDataAsIteration(SSA_TRUST_MODEL_ECU_CERT_ID, buffer, &bufferLength);
    if (retVal == E_OK)
    {
      /* increase by data length needed for this certificate */
      *DataLength = bufferLength;
      bufferLength = sizeof(Dcm_Data1002ByteType);
      retVal = KeyM_KeyM_GetCertificateDataAsIteration(SSA_TRUST_MODEL_INTERMEDIATE_CERT_ID, buffer, &bufferLength);
    }

    if (retVal == E_OK)
    {
      /* increase by data length needed for this certificate */
      *DataLength += bufferLength;
      bufferLength = sizeof(Dcm_Data1002ByteType);
      retVal = KeyM_KeyM_GetCertificateDataAsIteration(SSA_TRUST_MODEL_BACKEND_CERT_ID, buffer, &bufferLength);
    }

    if (retVal == E_OK)
    {
      /* increase by data length needed for this certificate */
      *DataLength += bufferLength;
    }

    retVal = (retVal == E_OK) ? RTE_E_OK : RTE_E_DataServices_DID_0199_Certificates_E_NOT_OK;
  }
  SSA_DUMMY_STATEMENT(OpStatus);    /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */

  return retVal;
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << End of runnable implementation >>               DO NOT CHANGE THIS COMMENT!
 *********************************************************************************************************************/
}

/**********************************************************************************************************************
 *
 * Runnable Entity Name: Ssa_KeyM_DataServices_DID_0199_Data_Signature_ConditionCheckRead
 *
 *---------------------------------------------------------------------------------------------------------------------
 *
 * Executed if at least one of the following trigger conditions occurred:
 *   - triggered by server invocation for OperationPrototype <ConditionCheckRead> of PortPrototype <DataServices_DID_0199_Data_Signature>
 *
 **********************************************************************************************************************
 *
 * Runnable prototype:
 * ===================
 *   Std_ReturnType Ssa_KeyM_DataServices_DID_0199_Data_Signature_ConditionCheckRead(Dcm_OpStatusType OpStatus, Dcm_NegativeResponseCodeType *ErrorCode)
 *
 **********************************************************************************************************************
 *
 * Available Application Errors:
 * =============================
 *   RTE_E_DataServices_DID_0199_Data_Signature_DCM_E_PENDING
 *   RTE_E_DataServices_DID_0199_Data_Signature_E_NOT_OK
 *
 *********************************************************************************************************************/
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << Start of documentation area >>                  DO NOT CHANGE THIS COMMENT!
 * Symbol: Ssa_KeyM_DataServices_DID_0199_Data_Signature_ConditionCheckRead_doc
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << End of documentation area >>                    DO NOT CHANGE THIS COMMENT!
 *********************************************************************************************************************/

FUNC(Std_ReturnType, Ssa_KeyM_CODE) Ssa_KeyM_DataServices_DID_0199_Data_Signature_ConditionCheckRead(
  Dcm_OpStatusType OpStatus,
  P2VAR(Dcm_NegativeResponseCodeType, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) ErrorCode) /* PRQA S 0624, 3206 */ /* MD_Rte_0624, MD_Rte_3206 */
{
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << Start of runnable implementation >>             DO NOT CHANGE THIS COMMENT!
 * Symbol: Ssa_KeyM_DataServices_DID_0199_Data_Signature_ConditionCheckRead (returns application error)
 *********************************************************************************************************************/

  Std_ReturnType retVal = RTE_E_DataServices_DID_0199_Data_Signature_E_NOT_OK;

  /* ----- Development Error Checks ------------------------------------- */
# if (SSA_DEV_ERROR_DETECT == STD_ON)
  if (ErrorCode == NULL_PTR)
  {
    /* retVal already set */
  }
  else
# endif /* SSA_DEV_ERROR_DETECT == STD_ON */
  {
    /* #10 Return RTE_E_OK if the ECU certificate is injected. */
    if (*Rte_Pim_KeyMTrustModelChainOfTrustState() == SSA_TRUSTMODELCHAINSTATE_INITIAL)
    {
      *ErrorCode = DCM_E_CONDITIONSNOTCORRECT;
    }
    else
    {
      *ErrorCode = DCM_E_POSITIVERESPONSE;
      retVal = RTE_E_OK;
    }
  }
  SSA_DUMMY_STATEMENT(OpStatus);    /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */

  return retVal;
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << End of runnable implementation >>               DO NOT CHANGE THIS COMMENT!
 *********************************************************************************************************************/
}

/**********************************************************************************************************************
 *
 * Runnable Entity Name: Ssa_KeyM_DataServices_DID_0199_Data_Signature_ReadData
 *
 *---------------------------------------------------------------------------------------------------------------------
 *
 * Executed if at least one of the following trigger conditions occurred:
 *   - triggered by server invocation for OperationPrototype <ReadData> of PortPrototype <DataServices_DID_0199_Data_Signature>
 *
 **********************************************************************************************************************
 *
 * Client/Server Interfaces:
 * =========================
 *   Server Invocation:
 *   ------------------
 *   Std_ReturnType Rte_Call_RightsM_Nonce_Get(boolean generateNew, uint8 *nonce)
 *     Argument nonce: uint8* is of type Dcm_Data32ByteType
 *     Synchronous Server Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_RightsM_Nonce_E_INVALID, RTE_E_RightsM_Nonce_E_NOT_OK, RTE_E_RightsM_Nonce_E_PENDING
 *   Std_ReturnType Rte_Call_SsaCdd_Csm_SignatureGenerate(uint32 jobId, Crypto_OperationModeType operationMode, Ssa_ConstDataPtr dataBuffer, uint32 dataLength, Ssa_DataPtr resultBuffer, Ssa_LengthPtr resultLength)
 *     Synchronous Server Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_SsaCdd_CryptoInterface_E_NOT_OK
 *
 * Service Calls:
 * ==============
 *   Service Invocation:
 *   -------------------
 *   Std_ReturnType Rte_Call_Key_SharedSecretKeyExchange_KeyElementGet(uint32 keyElementId, uint8 *keyPtr, uint32 *keyLength)
 *     Argument keyPtr: uint8* is of type Csm_KeyDataType_Ssa_SharedSecretKeyExchange
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_CsmKeyManagement_Ssa_SharedSecretKeyExchange_CSM_E_BUSY, RTE_E_CsmKeyManagement_Ssa_SharedSecretKeyExchange_CSM_E_KEY_EMPTY, RTE_E_CsmKeyManagement_Ssa_SharedSecretKeyExchange_CSM_E_KEY_NOT_AVAILABLE, RTE_E_CsmKeyManagement_Ssa_SharedSecretKeyExchange_CSM_E_KEY_READ_FAIL, RTE_E_CsmKeyManagement_Ssa_SharedSecretKeyExchange_CSM_E_SMALL_BUFFER, RTE_E_CsmKeyManagement_Ssa_SharedSecretKeyExchange_E_NOT_OK
 *
 **********************************************************************************************************************
 *
 * Runnable prototype:
 * ===================
 *   Std_ReturnType Ssa_KeyM_DataServices_DID_0199_Data_Signature_ReadData(Dcm_OpStatusType OpStatus, uint8 *Data)
 *     Argument Data: uint8* is of type Dcm_Data64ByteType
 *
 **********************************************************************************************************************
 *
 * Available Application Errors:
 * =============================
 *   RTE_E_DataServices_DID_0199_Data_Signature_DCM_E_PENDING
 *   RTE_E_DataServices_DID_0199_Data_Signature_E_NOT_OK
 *
 *********************************************************************************************************************/
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << Start of documentation area >>                  DO NOT CHANGE THIS COMMENT!
 * Symbol: Ssa_KeyM_DataServices_DID_0199_Data_Signature_ReadData_doc
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 */
/*!
 * \spec
 *    requires $lengthOf(Data) >= sizeof(Dcm_Data64ByteType);
 * \endspec
 */
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << End of documentation area >>                    DO NOT CHANGE THIS COMMENT!
 *********************************************************************************************************************/

FUNC(Std_ReturnType, Ssa_KeyM_CODE) Ssa_KeyM_DataServices_DID_0199_Data_Signature_ReadData(
  Dcm_OpStatusType OpStatus,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) Data) /* PRQA S 0624, 3206 */ /* MD_Rte_0624, MD_Rte_3206 */
{
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << Start of runnable implementation >>             DO NOT CHANGE THIS COMMENT!
 * Symbol: Ssa_KeyM_DataServices_DID_0199_Data_Signature_ReadData (returns application error)
 *********************************************************************************************************************/

  Std_ReturnType retVal = RTE_E_DataServices_DID_0199_Data_Signature_E_NOT_OK;

  /* ----- Development Error Checks ------------------------------------- */
# if (SSA_DEV_ERROR_DETECT == STD_ON)
  if (Data == NULL_PTR)
  {
    /* retVal already set */
  }
  else
# endif /* SSA_DEV_ERROR_DETECT == STD_ON */
  {
    /* #10 Check operation status. Only "pending" and "initial" is allowed. */
    if ((OpStatus == DCM_PENDING) || (OpStatus == DCM_INITIAL))
    {
      /* #20 If the function is in state IDLE get nonce that already has been generated. A new nonce must not be generated. */
      if (KeyM_DiagProc.state == KEYM_GEN_SIG_STATE_IDLE)
      {
        retVal = Rte_Call_RightsM_Nonce_Get(FALSE, &KeyM_DiagProc.ws.ecuCertificateReadData.genSigDataBufferIn[0]);
        if (retVal != E_OK)
        {
          retVal = RTE_E_DataServices_DID_0199_Data_Signature_E_NOT_OK;
        }
        else
        {
          uint32 ePubKeyOwnLength = SSA_SIZEOF_PUBLICKEY;

          /* #30 Get own ephemeral public key that already has been calculated. */
          retVal = Rte_Call_Key_SharedSecretKeyExchange_KeyElementGet(SSA_KE_KEYEXCHANGE_OWNPUBKEY, &KeyM_DiagProc.ws.ecuCertificateReadData.genSigDataBufferIn[SSA_SIZEOF_NONCE], &ePubKeyOwnLength);
          if ((retVal != E_OK) || (ePubKeyOwnLength != SSA_SIZEOF_PUBLICKEY))
          {
            retVal = RTE_E_DataServices_DID_0199_Data_Signature_E_NOT_OK;
          }
          else
          {
            KeyM_DiagProc.state = KEYM_GEN_SIG_STATE_GENERATE;
          }
        }
      }

      /* #40 If the function is in state GENERATE start resp. check the Csm signature generation from nonce and ephemeral public key. */
      if (KeyM_DiagProc.state == KEYM_GEN_SIG_STATE_GENERATE)
      {
        retVal = KeyM_CsmSignatureGenerate(
          SSA_TRUST_MODEL_LIVE_KEY_PAIR,
          KeyM_DiagProc.ws.ecuCertificateReadData.genSigDataBufferIn,
          SSA_SIZEOF_NONCE + SSA_SIZEOF_PUBLICKEY,
          KeyM_DiagProc.ws.ecuCertificateReadData.genSigDataBufferOut
        );

        if (retVal == SSA_E_PENDING)
        {
          retVal = RTE_E_DataServices_DID_0199_Data_Signature_DCM_E_PENDING;
        }
        else if (retVal == E_OK)
        {
          /* #50 Copy the generated signature to the output buffer. */
          Ssa_MemCpy(Data, KeyM_DiagProc.ws.ecuCertificateReadData.genSigDataBufferOut, SSA_SIZEOF_SIGNATURE);
          /* Reset the function's internal state. */
          KeyM_DiagProc.state = KEYM_GEN_SIG_STATE_IDLE;
        }
        else
        {
          /* Clear output data. */
          KeyM_ClearDataBuffer(Data, sizeof(Dcm_Data64ByteType), SSA_SIZEOF_SIGNATURE);
          /* Reset the function's internal state. */
          KeyM_DiagProc.state = KEYM_GEN_SIG_STATE_IDLE;
        }
      }

      /* #60 If the service is finished clear the buffer containing sensitive data. */
      if (retVal != RTE_E_DataServices_DID_0199_Data_Signature_DCM_E_PENDING)
      {
        KeyM_ClearDataBuffer(KeyM_DiagProc.ws.ecuCertificateReadData.genSigDataBufferIn, SSA_SIZEOF_NONCE + SSA_SIZEOF_PUBLICKEY, SSA_SIZEOF_NONCE + SSA_SIZEOF_PUBLICKEY);
      }
    }
  }

  return retVal;
  /* PRQA S 6080 4 */ /* MD_MSR_STMIF */
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << End of runnable implementation >>               DO NOT CHANGE THIS COMMENT!
 *********************************************************************************************************************/
}

/**********************************************************************************************************************
 *
 * Runnable Entity Name: Ssa_KeyM_DataServices_DID_0199_Ephemeral_ECU_Public_Key_ConditionCheckRead
 *
 *---------------------------------------------------------------------------------------------------------------------
 *
 * Executed if at least one of the following trigger conditions occurred:
 *   - triggered by server invocation for OperationPrototype <ConditionCheckRead> of PortPrototype <DataServices_DID_0199_Ephemeral_ECU_Public_Key>
 *
 **********************************************************************************************************************
 *
 * Runnable prototype:
 * ===================
 *   Std_ReturnType Ssa_KeyM_DataServices_DID_0199_Ephemeral_ECU_Public_Key_ConditionCheckRead(Dcm_OpStatusType OpStatus, Dcm_NegativeResponseCodeType *ErrorCode)
 *
 **********************************************************************************************************************
 *
 * Available Application Errors:
 * =============================
 *   RTE_E_DataServices_DID_0199_Ephemeral_ECU_Public_Key_DCM_E_PENDING
 *   RTE_E_DataServices_DID_0199_Ephemeral_ECU_Public_Key_E_NOT_OK
 *
 *********************************************************************************************************************/
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << Start of documentation area >>                  DO NOT CHANGE THIS COMMENT!
 * Symbol: Ssa_KeyM_DataServices_DID_0199_Ephemeral_ECU_Public_Key_ConditionCheckRead_doc
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */

/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << End of documentation area >>                    DO NOT CHANGE THIS COMMENT!
 *********************************************************************************************************************/

FUNC(Std_ReturnType, Ssa_KeyM_CODE) Ssa_KeyM_DataServices_DID_0199_Ephemeral_ECU_Public_Key_ConditionCheckRead(
  Dcm_OpStatusType OpStatus,
  P2VAR(Dcm_NegativeResponseCodeType, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) ErrorCode) /* PRQA S 0624, 3206 */ /* MD_Rte_0624, MD_Rte_3206 */
{
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << Start of runnable implementation >>             DO NOT CHANGE THIS COMMENT!
 * Symbol: Ssa_KeyM_DataServices_DID_0199_Ephemeral_ECU_Public_Key_ConditionCheckRead (returns application error)
 *********************************************************************************************************************/

  Std_ReturnType retVal = RTE_E_DataServices_DID_0199_Ephemeral_ECU_Public_Key_E_NOT_OK;

  /* ----- Development Error Checks ------------------------------------- */
# if (SSA_DEV_ERROR_DETECT == STD_ON)
  if (ErrorCode == NULL_PTR)
  {
    /* retVal already set */
  }
  else
# endif /* SSA_DEV_ERROR_DETECT == STD_ON */
  {

    /* #10 Call callout function for preparing the key exchange as long as it returns E_PENDING. */
    switch (OpStatus)
    {
      case DCM_INITIAL:
        retVal = Rte_Call_Ssa_KeyProc_PrepareKeyExchange(SSA_OPSTATUS_INITIAL, SSA_KEYM_CSM_KEY_EXCHANGE_KEY);
        break;
      case DCM_PENDING:
        retVal = Rte_Call_Ssa_KeyProc_PrepareKeyExchange(SSA_OPSTATUS_CHECKSTATE, SSA_KEYM_CSM_KEY_EXCHANGE_KEY);
        break;
      default:
        retVal = Rte_Call_Ssa_KeyProc_PrepareKeyExchange(SSA_OPSTATUS_CANCEL, SSA_KEYM_CSM_KEY_EXCHANGE_KEY);
        break;
    }

    /* PRQA S 2880 L1 */ /* MD_SSA_UNREACHABLE_CODE */
    /* PRQA S 2995, 2996 L2 */ /* MD_SSA_BOOLEXPR_ALWAYS_TRUE_OR_ALWAYS_FALSE  */
    /* PRQA S 2991, 2992 L3 */ /* MD_SSA_CTRLEXPR_ALWAYS_TRUE_OR_ALWAYS_FALSE */
    if (retVal == RTE_E_Ssa_KeyProc_E_PENDING)
    {
      retVal = RTE_E_DataServices_DID_0199_Ephemeral_ECU_Public_Key_DCM_E_PENDING;
    }
    else if ((retVal == RTE_E_OK) || (retVal == RTE_E_UNCONNECTED))
    {
      retVal = RTE_E_OK;
      *ErrorCode = DCM_E_POSITIVERESPONSE;
    }
    else
    {
      retVal = RTE_E_DataServices_DID_0199_Ephemeral_ECU_Public_Key_E_NOT_OK;
      *ErrorCode = DCM_E_GENERALREJECT;
    }
    /* PRQA L:L3 */
    /* PRQA L:L2 */
    /* PRQA L:L1 */
  }

  return retVal;

/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << End of runnable implementation >>               DO NOT CHANGE THIS COMMENT!
 *********************************************************************************************************************/
}

/**********************************************************************************************************************
 *
 * Runnable Entity Name: Ssa_KeyM_DataServices_DID_0199_Ephemeral_ECU_Public_Key_ReadData
 *
 *---------------------------------------------------------------------------------------------------------------------
 *
 * Executed if at least one of the following trigger conditions occurred:
 *   - triggered by server invocation for OperationPrototype <ReadData> of PortPrototype <DataServices_DID_0199_Ephemeral_ECU_Public_Key>
 *
 **********************************************************************************************************************
 *
 * Client/Server Interfaces:
 * =========================
 *   Server Invocation:
 *   ------------------
 *   Std_ReturnType Rte_Call_Ssa_KeyProc_PrepareKeyExchange(Ssa_OpStatusType opStatus, uint32 keyId)
 *     Synchronous Server Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_Ssa_KeyProc_E_NOT_OK, RTE_E_Ssa_KeyProc_E_PENDING
 *
 * Service Calls:
 * ==============
 *   Service Invocation:
 *   -------------------
 *   Std_ReturnType Rte_Call_CsmJobKeyExchangeCalcPubVal_KeyExchangeCalcPubVal(uint32 key, Csm_DataPtr publicValuePtr, Csm_LengthPtr publicValueLengthPtr)
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_CsmJobKeyExchangeCalcPubVal_CSM_E_BUSY, RTE_E_CsmJobKeyExchangeCalcPubVal_CSM_E_KEY_EMPTY, RTE_E_CsmJobKeyExchangeCalcPubVal_CSM_E_SMALL_BUFFER, RTE_E_CsmJobKeyExchangeCalcPubVal_E_NOT_OK
 *   Std_ReturnType Rte_Call_Key_SharedSecretKeyExchange_KeyElementSet(uint32 keyElementId, const uint8 *keyPtr, uint32 keyLength)
 *     Argument keyPtr: uint8* is of type Csm_KeyDataType_Ssa_SharedSecretKeyExchange
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_CsmKeyManagement_Ssa_SharedSecretKeyExchange_CSM_E_BUSY, RTE_E_CsmKeyManagement_Ssa_SharedSecretKeyExchange_CSM_E_KEY_NOT_AVAILABLE, RTE_E_CsmKeyManagement_Ssa_SharedSecretKeyExchange_CSM_E_KEY_SIZE_MISMATCH, RTE_E_CsmKeyManagement_Ssa_SharedSecretKeyExchange_CSM_E_KEY_WRITE_FAIL, RTE_E_CsmKeyManagement_Ssa_SharedSecretKeyExchange_CSM_E_SMALL_BUFFER, RTE_E_CsmKeyManagement_Ssa_SharedSecretKeyExchange_E_NOT_OK
 *   Std_ReturnType Rte_Call_Key_SharedSecretKeyExchange_KeyExchangeCalcPubVal(uint8 *publicValuePtr, uint32 *publicValueLengthPtr)
 *     Argument publicValuePtr: uint8* is of type Csm_PublicValueDataType_Ssa_SharedSecretKeyExchange
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_CsmKeyManagement_Ssa_SharedSecretKeyExchange_CSM_E_BUSY, RTE_E_CsmKeyManagement_Ssa_SharedSecretKeyExchange_CSM_E_KEY_EMPTY, RTE_E_CsmKeyManagement_Ssa_SharedSecretKeyExchange_CSM_E_SMALL_BUFFER, RTE_E_CsmKeyManagement_Ssa_SharedSecretKeyExchange_E_NOT_OK
 *   Std_ReturnType Rte_Call_Key_SharedSecretKeyExchange_KeySetValid(void)
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_CsmKeyManagement_Ssa_SharedSecretKeyExchange_CSM_E_BUSY, RTE_E_CsmKeyManagement_Ssa_SharedSecretKeyExchange_E_NOT_OK
 *
 **********************************************************************************************************************
 *
 * Runnable prototype:
 * ===================
 *   Std_ReturnType Ssa_KeyM_DataServices_DID_0199_Ephemeral_ECU_Public_Key_ReadData(Dcm_OpStatusType OpStatus, uint8 *Data)
 *     Argument Data: uint8* is of type Dcm_Data32ByteType
 *
 **********************************************************************************************************************
 *
 * Available Application Errors:
 * =============================
 *   RTE_E_DataServices_DID_0199_Ephemeral_ECU_Public_Key_DCM_E_PENDING
 *   RTE_E_DataServices_DID_0199_Ephemeral_ECU_Public_Key_E_NOT_OK
 *
 *********************************************************************************************************************/
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << Start of documentation area >>                  DO NOT CHANGE THIS COMMENT!
 * Symbol: Ssa_KeyM_DataServices_DID_0199_Ephemeral_ECU_Public_Key_ReadData_doc
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
/*!
 * \spec
 *    requires $lengthOf(Data) >= sizeof(Dcm_Data32ByteType);
 * \endspec
 */
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << End of documentation area >>                    DO NOT CHANGE THIS COMMENT!
 *********************************************************************************************************************/

FUNC(Std_ReturnType, Ssa_KeyM_CODE) Ssa_KeyM_DataServices_DID_0199_Ephemeral_ECU_Public_Key_ReadData(
  Dcm_OpStatusType OpStatus,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) Data) /* PRQA S 0624, 3206 */ /* MD_Rte_0624, MD_Rte_3206 */
{
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << Start of runnable implementation >>             DO NOT CHANGE THIS COMMENT!
 * Symbol: Ssa_KeyM_DataServices_DID_0199_Ephemeral_ECU_Public_Key_ReadData (returns application error)
 *********************************************************************************************************************/

  Std_ReturnType retVal = RTE_E_DataServices_DID_0199_Ephemeral_ECU_Public_Key_E_NOT_OK;

  /* ----- Development Error Checks ------------------------------------- */
# if (SSA_DEV_ERROR_DETECT == STD_ON)
  if (Data == NULL_PTR)
  {
    /* retVal already set */
  }
  else
# endif /* SSA_DEV_ERROR_DETECT == STD_ON */
  {
    /* #10 Calculate the ephemeral public key and copy it to the output buffer. */

    if ((OpStatus == DCM_PENDING) || (OpStatus == DCM_INITIAL))
    {
      retVal = KeyM_CsmKeyExchangeCalcPubVal(Data);

      if (retVal == SSA_E_PENDING)
      {
        retVal = RTE_E_DataServices_DID_0199_Ephemeral_ECU_Public_Key_DCM_E_PENDING;
      }
      else if (retVal == E_OK)
      {
        retVal = Rte_Call_Key_SharedSecretKeyExchange_KeyElementSet(SSA_KE_KEYEXCHANGE_OWNPUBKEY, Data, SSA_SIZEOF_PUBLICKEY);
        retVal |= Rte_Call_Key_SharedSecretKeyExchange_KeySetValid();
        if (retVal != RTE_E_OK)
        {
          retVal = RTE_E_DataServices_DID_0199_Ephemeral_ECU_Public_Key_E_NOT_OK;
        }
      }
      else
      {
        retVal = RTE_E_DataServices_DID_0199_Ephemeral_ECU_Public_Key_E_NOT_OK;
      }
    }

    if (retVal == RTE_E_DataServices_DID_0199_Ephemeral_ECU_Public_Key_E_NOT_OK)
    {
      /* Clear output data. */
      KeyM_ClearDataBuffer(Data, sizeof(Dcm_Data32ByteType), SSA_SIZEOF_PUBLICKEY);
    }
  }

  return retVal;

  /* PRQA S 6080 4 */ /* MD_MSR_STMIF */
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << End of runnable implementation >>               DO NOT CHANGE THIS COMMENT!
 *********************************************************************************************************************/
}

/**********************************************************************************************************************
 *
 * Runnable Entity Name: Ssa_KeyM_DataServices_DID_0199_Nonce_ConditionCheckRead
 *
 *---------------------------------------------------------------------------------------------------------------------
 *
 * Executed if at least one of the following trigger conditions occurred:
 *   - triggered by server invocation for OperationPrototype <ConditionCheckRead> of PortPrototype <DataServices_DID_0199_Nonce>
 *
 **********************************************************************************************************************
 *
 * Client/Server Interfaces:
 * =========================
 *   Server Invocation:
 *   ------------------
 *   Std_ReturnType Rte_Call_RightsM_Nonce_Get(boolean generateNew, uint8 *nonce)
 *     Argument nonce: uint8* is of type Dcm_Data32ByteType
 *     Synchronous Server Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_RightsM_Nonce_E_INVALID, RTE_E_RightsM_Nonce_E_NOT_OK, RTE_E_RightsM_Nonce_E_PENDING
 *
 **********************************************************************************************************************
 *
 * Runnable prototype:
 * ===================
 *   Std_ReturnType Ssa_KeyM_DataServices_DID_0199_Nonce_ConditionCheckRead(Dcm_OpStatusType OpStatus, Dcm_NegativeResponseCodeType *ErrorCode)
 *
 **********************************************************************************************************************
 *
 * Available Application Errors:
 * =============================
 *   RTE_E_DataServices_DID_0199_Nonce_DCM_E_PENDING
 *   RTE_E_DataServices_DID_0199_Nonce_E_NOT_OK
 *
 *********************************************************************************************************************/
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << Start of documentation area >>                  DO NOT CHANGE THIS COMMENT!
 * Symbol: Ssa_KeyM_DataServices_DID_0199_Nonce_ConditionCheckRead_doc
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */

/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << End of documentation area >>                    DO NOT CHANGE THIS COMMENT!
 *********************************************************************************************************************/

FUNC(Std_ReturnType, Ssa_KeyM_CODE) Ssa_KeyM_DataServices_DID_0199_Nonce_ConditionCheckRead(
  Dcm_OpStatusType OpStatus,
  P2VAR(Dcm_NegativeResponseCodeType, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) ErrorCode) /* PRQA S 0624, 3206 */ /* MD_Rte_0624, MD_Rte_3206 */
{
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << Start of runnable implementation >>             DO NOT CHANGE THIS COMMENT!
 * Symbol: Ssa_KeyM_DataServices_DID_0199_Nonce_ConditionCheckRead (returns application error)
 *********************************************************************************************************************/

  Std_ReturnType retVal = RTE_E_DataServices_DID_0199_Nonce_E_NOT_OK;

  /* ----- Development Error Checks ------------------------------------- */
# if (SSA_DEV_ERROR_DETECT == STD_ON)
  if (ErrorCode == NULL_PTR)
  {
    /* retVal already set */
  }
  else
# endif /* SSA_DEV_ERROR_DETECT == STD_ON */
  {
    if ((OpStatus == DCM_INITIAL) || (OpStatus == DCM_PENDING))
    {
      /* #10 Generate a new nonce in RightsM. Set NRC "challenge calculation failed" if getting nonce is not possible. */
      retVal = Rte_Call_RightsM_Nonce_Get(TRUE, KeyM_DiagProc.buffer32Byte);

      if (retVal == RTE_E_RightsM_Nonce_E_PENDING)
      {
        retVal = RTE_E_DataServices_DID_0199_Nonce_DCM_E_PENDING;
      }
      else if (retVal != RTE_E_OK)
      {
        retVal = RTE_E_DataServices_DID_0199_Nonce_E_NOT_OK;
        *ErrorCode = KEYM_DCM_NRC_CHALLENGE_CALCULATION_FAILED;
      }
      else
      {
        /* Clear nonce. */
        KeyM_ClearDataBuffer(KeyM_DiagProc.buffer32Byte, SSA_SIZEOF_NONCE, SSA_SIZEOF_NONCE);
        retVal = RTE_E_OK;
      }
    }
    else
    {
      *ErrorCode = DCM_E_GENERALREJECT;
    }
  }

  return retVal;

/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << End of runnable implementation >>               DO NOT CHANGE THIS COMMENT!
 *********************************************************************************************************************/
}

/**********************************************************************************************************************
 *
 * Runnable Entity Name: Ssa_KeyM_DataServices_DID_0199_Nonce_ReadData
 *
 *---------------------------------------------------------------------------------------------------------------------
 *
 * Executed if at least one of the following trigger conditions occurred:
 *   - triggered by server invocation for OperationPrototype <ReadData> of PortPrototype <DataServices_DID_0199_Nonce>
 *
 **********************************************************************************************************************
 *
 * Client/Server Interfaces:
 * =========================
 *   Server Invocation:
 *   ------------------
 *   Std_ReturnType Rte_Call_RightsM_Nonce_Get(boolean generateNew, uint8 *nonce)
 *     Argument nonce: uint8* is of type Dcm_Data32ByteType
 *     Synchronous Server Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_RightsM_Nonce_E_INVALID, RTE_E_RightsM_Nonce_E_NOT_OK, RTE_E_RightsM_Nonce_E_PENDING
 *
 **********************************************************************************************************************
 *
 * Runnable prototype:
 * ===================
 *   Std_ReturnType Ssa_KeyM_DataServices_DID_0199_Nonce_ReadData(Dcm_OpStatusType OpStatus, uint8 *Data)
 *     Argument Data: uint8* is of type Dcm_Data32ByteType
 *
 **********************************************************************************************************************
 *
 * Available Application Errors:
 * =============================
 *   RTE_E_DataServices_DID_0199_Nonce_DCM_E_PENDING
 *   RTE_E_DataServices_DID_0199_Nonce_E_NOT_OK
 *
 *********************************************************************************************************************/
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << Start of documentation area >>                  DO NOT CHANGE THIS COMMENT!
 * Symbol: Ssa_KeyM_DataServices_DID_0199_Nonce_ReadData_doc
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 */
/*!
 * \spec
 *    requires $lengthOf(Data) >= sizeof(Dcm_Data32ByteType);
 * \endspec
 */
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << End of documentation area >>                    DO NOT CHANGE THIS COMMENT!
 *********************************************************************************************************************/

FUNC(Std_ReturnType, Ssa_KeyM_CODE) Ssa_KeyM_DataServices_DID_0199_Nonce_ReadData(
  Dcm_OpStatusType OpStatus,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) Data) /* PRQA S 0624, 3206 */ /* MD_Rte_0624, MD_Rte_3206 */
{
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << Start of runnable implementation >>             DO NOT CHANGE THIS COMMENT!
 * Symbol: Ssa_KeyM_DataServices_DID_0199_Nonce_ReadData (returns application error)
 *********************************************************************************************************************/

  Std_ReturnType retVal = RTE_E_DataServices_DID_0199_Nonce_E_NOT_OK;

  /* ----- Development Error Checks ------------------------------------- */
# if (SSA_DEV_ERROR_DETECT == STD_ON)
  if (Data == NULL_PTR)
  {
    /* retVal already set */
  }
  else
# endif /* SSA_DEV_ERROR_DETECT == STD_ON */
  {
    if ((OpStatus == DCM_INITIAL) || (OpStatus == DCM_PENDING))
    {
      /* #10 Get nonce from RightsM that has been already generated during condition check routine.
       *     Copy it to the output buffer. */
      retVal = Rte_Call_RightsM_Nonce_Get(FALSE, Data);

      if (retVal == RTE_E_RightsM_Nonce_E_PENDING)
      {
        retVal = RTE_E_DataServices_DID_0199_Nonce_DCM_E_PENDING;
      }
      else if (retVal == RTE_E_OK)
      {
        /* Success! We will return E_OK. */
      }
      else
      {
        /* Could not get the nonce: Clear output data. */
        KeyM_ClearDataBuffer(Data, sizeof(Dcm_Data32ByteType), SSA_SIZEOF_NONCE);
        retVal = RTE_E_DataServices_DID_0199_Nonce_E_NOT_OK;
      }
    }
  }

  return retVal;
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << End of runnable implementation >>               DO NOT CHANGE THIS COMMENT!
 *********************************************************************************************************************/
}

#endif

/**********************************************************************************************************************
 *
 * Runnable Entity Name: Ssa_KeyM_DataServices_DID_019A_Trust_model_ECU_CSR_ConditionCheckRead
 *
 *---------------------------------------------------------------------------------------------------------------------
 *
 * Executed if at least one of the following trigger conditions occurred:
 *   - triggered by server invocation for OperationPrototype <ConditionCheckRead> of PortPrototype <DataServices_DID_019A_Trust_model_ECU_CSR>
 *
 **********************************************************************************************************************
 *
 * Client/Server Interfaces:
 * =========================
 *   Server Invocation:
 *   ------------------
 *   Std_ReturnType Rte_Call_SsaCdd_Csm_SignatureGenerate(uint32 jobId, Crypto_OperationModeType operationMode, Ssa_ConstDataPtr dataBuffer, uint32 dataLength, Ssa_DataPtr resultBuffer, Ssa_LengthPtr resultLength)
 *     Synchronous Server Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_SsaCdd_CryptoInterface_E_NOT_OK
 *   Std_ReturnType Rte_Call_SsaCdd_Csm_SignatureVerify(uint32 jobId, Crypto_OperationModeType operationMode, Ssa_ConstDataPtr dataBuffer, uint32 dataLength, Ssa_ConstDataPtr compareBuffer, uint32 compareLength, Ssa_VerifyResultPtr resultBuffer)
 *     Synchronous Server Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_SsaCdd_CryptoInterface_E_NOT_OK
 *   Std_ReturnType Rte_Call_SsaCdd_TrustModel_CsrElementSet(KeyM_CertificateIdType CertId, KeyM_CertElementIdType CertElementId, KeyM_CsrEncodingType EncodingType, Ssa_ConstDataPtr ElementData, uint32 ElementDataLength)
 *     Synchronous Server Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_SsaCdd_KeyM_CertInterface_E_NOT_OK, RTE_E_SsaCdd_KeyM_CertInterface_KEYM_E_KEY_CERT_SIZE_MISMATCH, RTE_E_SsaCdd_KeyM_CertInterface_KEYM_E_PARAMETER_MISMATCH
 *   Std_ReturnType Rte_Call_SsaCdd_TrustModel_ServiceCertificate(KeyM_ServiceCertificateType Service, Ssa_ConstDataPtr CertNamePtr, uint32 CertNameLength, Ssa_ConstDataPtr RequestData, uint32 RequestDataLength, Ssa_DataPtr ResponseData, uint32 ResponseDataLength)
 *     Synchronous Server Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_SsaCdd_KeyM_CertInterface_E_NOT_OK, RTE_E_SsaCdd_KeyM_CertInterface_KEYM_E_BUSY, RTE_E_SsaCdd_KeyM_CertInterface_KEYM_E_CERT_INVALID_CHAIN_OF_TRUST, RTE_E_SsaCdd_KeyM_CertInterface_KEYM_E_KEY_CERT_EMPTY, RTE_E_SsaCdd_KeyM_CertInterface_KEYM_E_KEY_CERT_SIZE_MISMATCH, RTE_E_SsaCdd_KeyM_CertInterface_KEYM_E_PARAMETER_MISMATCH
 *   Std_ReturnType Rte_Call_Ssa_VeDocRelevantInfo_GetData(uint8 *data, uint16 *dataLength)
 *     Argument data: uint8* is of type Ssa_Data64ByteType
 *     Synchronous Server Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_Ssa_VeDocRelevantInfo_E_NOT_OK
 *
 * Service Calls:
 * ==============
 *   Service Invocation:
 *   -------------------
 *   Std_ReturnType Rte_Call_Key_TrustModelEcuCsrPrivateKey_KeySetValid(void)
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_CsmKeyManagement_Ssa_TrustModelEcuCsrPrivateKey_CSM_E_BUSY, RTE_E_CsmKeyManagement_Ssa_TrustModelEcuCsrPrivateKey_E_NOT_OK
 *   Std_ReturnType Rte_Call_Key_TrustModelEcuCsrPublicKey_KeyElementGet(uint32 keyElementId, uint8 *keyPtr, uint32 *keyLength)
 *     Argument keyPtr: uint8* is of type Csm_KeyDataType_Ssa_TrustModelEcuCsrPublicKey
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_CsmKeyManagement_Ssa_TrustModelEcuCsrPublicKey_CSM_E_BUSY, RTE_E_CsmKeyManagement_Ssa_TrustModelEcuCsrPublicKey_CSM_E_KEY_EMPTY, RTE_E_CsmKeyManagement_Ssa_TrustModelEcuCsrPublicKey_CSM_E_KEY_NOT_AVAILABLE, RTE_E_CsmKeyManagement_Ssa_TrustModelEcuCsrPublicKey_CSM_E_KEY_READ_FAIL, RTE_E_CsmKeyManagement_Ssa_TrustModelEcuCsrPublicKey_CSM_E_SMALL_BUFFER, RTE_E_CsmKeyManagement_Ssa_TrustModelEcuCsrPublicKey_E_NOT_OK
 *   Std_ReturnType Rte_Call_Key_TrustModelEcuCsrPublicKey_KeySetValid(void)
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_CsmKeyManagement_Ssa_TrustModelEcuCsrPublicKey_CSM_E_BUSY, RTE_E_CsmKeyManagement_Ssa_TrustModelEcuCsrPublicKey_E_NOT_OK
 *   Std_ReturnType Rte_Call_Key_TrustModelEcuStagingPrivateKey_KeyElementCopy(uint32 keyElementId, uint32 targetKeyId, uint32 targetKeyElementId)
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_CsmKeyManagement_Ssa_TrustModelEcuStagingPrivateKey_CSM_E_BUSY, RTE_E_CsmKeyManagement_Ssa_TrustModelEcuStagingPrivateKey_CSM_E_KEY_EMPTY, RTE_E_CsmKeyManagement_Ssa_TrustModelEcuStagingPrivateKey_CSM_E_KEY_READ_FAIL, RTE_E_CsmKeyManagement_Ssa_TrustModelEcuStagingPrivateKey_CSM_E_KEY_SIZE_MISMATCH, RTE_E_CsmKeyManagement_Ssa_TrustModelEcuStagingPrivateKey_CSM_E_KEY_WRITE_FAIL, RTE_E_CsmKeyManagement_Ssa_TrustModelEcuStagingPrivateKey_CSM_E_SMALL_BUFFER, RTE_E_CsmKeyManagement_Ssa_TrustModelEcuStagingPrivateKey_E_NOT_OK
 *   Std_ReturnType Rte_Call_Key_TrustModelEcuStagingPublicKey_KeyElementCopy(uint32 keyElementId, uint32 targetKeyId, uint32 targetKeyElementId)
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_CsmKeyManagement_Ssa_TrustModelEcuStagingPublicKey_CSM_E_BUSY, RTE_E_CsmKeyManagement_Ssa_TrustModelEcuStagingPublicKey_CSM_E_KEY_EMPTY, RTE_E_CsmKeyManagement_Ssa_TrustModelEcuStagingPublicKey_CSM_E_KEY_READ_FAIL, RTE_E_CsmKeyManagement_Ssa_TrustModelEcuStagingPublicKey_CSM_E_KEY_SIZE_MISMATCH, RTE_E_CsmKeyManagement_Ssa_TrustModelEcuStagingPublicKey_CSM_E_KEY_WRITE_FAIL, RTE_E_CsmKeyManagement_Ssa_TrustModelEcuStagingPublicKey_CSM_E_SMALL_BUFFER, RTE_E_CsmKeyManagement_Ssa_TrustModelEcuStagingPublicKey_E_NOT_OK
 *   Std_ReturnType Rte_Call_Key_TrustModelTempPublicKey_KeyElementSet(uint32 keyElementId, const uint8 *keyPtr, uint32 keyLength)
 *     Argument keyPtr: uint8* is of type Csm_KeyDataType_Ssa_TrustModelTempPublicKey
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_CsmKeyManagement_Ssa_TrustModelTempPublicKey_CSM_E_BUSY, RTE_E_CsmKeyManagement_Ssa_TrustModelTempPublicKey_CSM_E_KEY_NOT_AVAILABLE, RTE_E_CsmKeyManagement_Ssa_TrustModelTempPublicKey_CSM_E_KEY_SIZE_MISMATCH, RTE_E_CsmKeyManagement_Ssa_TrustModelTempPublicKey_CSM_E_KEY_WRITE_FAIL, RTE_E_CsmKeyManagement_Ssa_TrustModelTempPublicKey_E_NOT_OK
 *   Std_ReturnType Rte_Call_Key_TrustModelTempPublicKey_KeySetValid(void)
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_CsmKeyManagement_Ssa_TrustModelTempPublicKey_CSM_E_BUSY, RTE_E_CsmKeyManagement_Ssa_TrustModelTempPublicKey_E_NOT_OK
 *
 **********************************************************************************************************************
 *
 * Runnable prototype:
 * ===================
 *   Std_ReturnType Ssa_KeyM_DataServices_DID_019A_Trust_model_ECU_CSR_ConditionCheckRead(Dcm_OpStatusType OpStatus, Dcm_NegativeResponseCodeType *ErrorCode)
 *
 **********************************************************************************************************************
 *
 * Available Application Errors:
 * =============================
 *   RTE_E_DataServices_DID_019A_Trust_model_ECU_CSR_DCM_E_PENDING
 *   RTE_E_DataServices_DID_019A_Trust_model_ECU_CSR_E_NOT_OK
 *
 *********************************************************************************************************************/
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << Start of documentation area >>                  DO NOT CHANGE THIS COMMENT!
 * Symbol: Ssa_KeyM_DataServices_DID_019A_Trust_model_ECU_CSR_ConditionCheckRead_doc
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */

/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << End of documentation area >>                    DO NOT CHANGE THIS COMMENT!
 *********************************************************************************************************************/

FUNC(Std_ReturnType, Ssa_KeyM_CODE) Ssa_KeyM_DataServices_DID_019A_Trust_model_ECU_CSR_ConditionCheckRead(
  Dcm_OpStatusType OpStatus,
  P2VAR(Dcm_NegativeResponseCodeType, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) ErrorCode) /* PRQA S 0624, 3206 */ /* MD_Rte_0624, MD_Rte_3206 */
{
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << Start of runnable implementation >>             DO NOT CHANGE THIS COMMENT!
 * Symbol: Ssa_KeyM_DataServices_DID_019A_Trust_model_ECU_CSR_ConditionCheckRead (returns application error)
 *********************************************************************************************************************/
  Std_ReturnType retVal = RTE_E_DataServices_DID_019A_Trust_model_ECU_CSR_E_NOT_OK;

  /* ----- Development Error Checks ------------------------------------- */
#if (SSA_DEV_ERROR_DETECT == STD_ON)
  if (ErrorCode == NULL_PTR)
  {
    /* retVal already set */
  }
  else
#endif /* SSA_DEV_ERROR_DETECT == STD_ON */
  {
    Dcm_NegativeResponseCodeType errorCode = DCM_E_POSITIVERESPONSE; /* PRQA S 2981 */ /* MD_SSA_REDUNDANT_INITIALIZATION */

    /* #10 Handle the following states:
    *     SSA_KEYM_TRUST_MODEL_ECU_CSR_STATE_IDLE,
    *     SSA_KEYM_TRUST_MODEL_ECU_CSR_STATE_VERIFYING_TRUST_MODEL_PRIVATE_KEY,
    *     SSA_KEYM_TRUST_MODEL_ECU_CSR_STATE_CREATING_CSR.
    */

    retVal = RTE_E_DataServices_DID_019A_Trust_model_ECU_CSR_DCM_E_PENDING;
    switch (KeyM_DiagProc.state)
    {
      case SSA_KEYM_TRUST_MODEL_ECU_CSR_STATE_IDLE:
        KeyM_DiagProc.state = SSA_KEYM_TRUST_MODEL_ECU_CSR_STATE_VERIFYING_TRUST_MODEL_PRIVATE_KEY;
        /* Copy inital CSR keys */
        retVal = KeyM_TrustModel_CopyCsrKey();

        /* fall through */
        /* PRQA S 2003 2 */ /* MD_SSA_SWITCH_FALLTHROUGH */
        /* #20 Verify the Trust Model private key against the public key of the Trust Model ECU certificate and then init the CSR. */
      case SSA_KEYM_TRUST_MODEL_ECU_CSR_STATE_VERIFYING_TRUST_MODEL_PRIVATE_KEY:
      {
        /* Continue Processing for E_OK (from IDLE) and RTE_E_DataServices_DID_019A_Trust_model_ECU_CSR_DCM_E_PENDING (from INIT) */
        if (retVal != E_NOT_OK)
        {
          retVal = KeyM_TrustModel_VerifyPrivateKeyAndInitCsr();
        }

        if (retVal == E_OK)
        {
          /* Return pending and check for the finished CSR next time we are called */
          KeyM_DiagProc.state = SSA_KEYM_TRUST_MODEL_ECU_CSR_STATE_CREATING_CSR;
          retVal = RTE_E_DataServices_DID_019A_Trust_model_ECU_CSR_DCM_E_PENDING;
        }
        else if (retVal == SSA_E_PENDING)
        {
          /* Return pending and check again next time */
          retVal = RTE_E_DataServices_DID_019A_Trust_model_ECU_CSR_DCM_E_PENDING;
        }
        else
        {
          KeyM_DiagProc.state = SSA_KEYM_TRUST_MODEL_ECU_CSR_STATE_IDLE;
          retVal = RTE_E_DataServices_DID_019A_Trust_model_ECU_CSR_E_NOT_OK;
          errorCode = DCM_E_CONDITIONSNOTCORRECT;
        }
        break;
      }

      /* #40 Wait for response from AsrKeyM and then check the result of the requested service. */
      case SSA_KEYM_TRUST_MODEL_ECU_CSR_STATE_CREATING_CSR:
      {
        if (KeyM_DiagProc.serviceResponseCallbackOccurred)
        {
          if (KeyM_DiagProc.serviceResponseCallbackResult == KEYM_RT_OK)
          {
            /* creating CSR succeeded */
            retVal = RTE_E_OK;
          }
          else
          {
            /* handle error */
            retVal = RTE_E_DataServices_DID_019A_Trust_model_ECU_CSR_E_NOT_OK;
            errorCode = DCM_E_CONDITIONSNOTCORRECT;
          }
          KeyM_DiagProc.state = SSA_KEYM_TRUST_MODEL_ECU_CSR_STATE_IDLE;
        }
        else
        {
          /* Wait. Return value is "pending" by default. */
        }

        break;
      }

      default:
      {
        /* unknown state */
        KeyM_DiagProc.state = SSA_KEYM_TRUST_MODEL_ECU_CSR_STATE_IDLE;
        retVal = RTE_E_DataServices_DID_019A_Trust_model_ECU_CSR_E_NOT_OK;
        errorCode = DCM_E_GENERALREJECT;
        break;
      }
    }

    /* assign negative response code if execution of service failed */
    if (retVal != RTE_E_DataServices_DID_019A_Trust_model_ECU_CSR_DCM_E_PENDING)
    {
      if (retVal != RTE_E_OK)
      {
        *ErrorCode = errorCode;
      }
    }
  }
  SSA_DUMMY_STATEMENT(OpStatus);    /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */

  return retVal;
    /* PRQA S 6030 4 */ /* MD_MSR_STCYC */
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << End of runnable implementation >>               DO NOT CHANGE THIS COMMENT!
 *********************************************************************************************************************/
}

/**********************************************************************************************************************
 *
 * Runnable Entity Name: Ssa_KeyM_DataServices_DID_019A_Trust_model_ECU_CSR_ReadData
 *
 *---------------------------------------------------------------------------------------------------------------------
 *
 * Executed if at least one of the following trigger conditions occurred:
 *   - triggered by server invocation for OperationPrototype <ReadData> of PortPrototype <DataServices_DID_019A_Trust_model_ECU_CSR>
 *
 **********************************************************************************************************************
 *
 * Runnable prototype:
 * ===================
 *   Std_ReturnType Ssa_KeyM_DataServices_DID_019A_Trust_model_ECU_CSR_ReadData(Dcm_OpStatusType OpStatus, uint8 *Data)
 *     Argument Data: uint8* is of type Dcm_Data1002ByteType
 *
 **********************************************************************************************************************
 *
 * Available Application Errors:
 * =============================
 *   RTE_E_DataServices_DID_019A_Trust_model_ECU_CSR_DCM_E_PENDING
 *   RTE_E_DataServices_DID_019A_Trust_model_ECU_CSR_E_NOT_OK
 *
 *********************************************************************************************************************/
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << Start of documentation area >>                  DO NOT CHANGE THIS COMMENT!
 * Symbol: Ssa_KeyM_DataServices_DID_019A_Trust_model_ECU_CSR_ReadData_doc
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
/*!
 * \spec
 *    requires $lengthOf(Data) >= sizeof(Dcm_Data1002ByteType);
 * \endspec
 */
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << End of documentation area >>                    DO NOT CHANGE THIS COMMENT!
 *********************************************************************************************************************/

FUNC(Std_ReturnType, Ssa_KeyM_CODE) Ssa_KeyM_DataServices_DID_019A_Trust_model_ECU_CSR_ReadData(
  Dcm_OpStatusType OpStatus,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) Data) /* PRQA S 0624, 3206 */ /* MD_Rte_0624, MD_Rte_3206 */
{
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << Start of runnable implementation >>             DO NOT CHANGE THIS COMMENT!
 * Symbol: Ssa_KeyM_DataServices_DID_019A_Trust_model_ECU_CSR_ReadData (returns application error)
 *********************************************************************************************************************/

  Std_ReturnType retVal = RTE_E_DataServices_DID_019A_Trust_model_ECU_CSR_E_NOT_OK;

  /* ----- Development Error Checks ------------------------------------- */
#if (SSA_DEV_ERROR_DETECT == STD_ON)
  if (Data == NULL_PTR)
  {
    /* retVal already set */
  }
  else
#endif /* SSA_DEV_ERROR_DETECT == STD_ON */
  {
    /* #10 Copy CSR data to provided data buffer. */
    if (OpStatus != DCM_CANCEL)
    {
      KeyM_CopyDataBuffer(&Data[2u], KeyM_DiagProc.serviceResponseBuffer, KeyM_DiagProc.serviceResponseBufferLength); /* VCA_SSA_KEYM_READDATA_TRUST_MODEL_ECU_CSR */
      /* prepend length information */
      Data[0] = KeyM_GetUint16HiByte((uint16)(KeyM_DiagProc.serviceResponseBufferLength));
      Data[1] = KeyM_GetUint16LoByte((uint16)(KeyM_DiagProc.serviceResponseBufferLength));
    }
    retVal = RTE_E_OK;
  }
  return retVal;

/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << End of runnable implementation >>               DO NOT CHANGE THIS COMMENT!
 *********************************************************************************************************************/
}

/**********************************************************************************************************************
 *
 * Runnable Entity Name: Ssa_KeyM_DataServices_DID_019A_Trust_model_ECU_CSR_ReadDataLength
 *
 *---------------------------------------------------------------------------------------------------------------------
 *
 * Executed if at least one of the following trigger conditions occurred:
 *   - triggered by server invocation for OperationPrototype <ReadDataLength> of PortPrototype <DataServices_DID_019A_Trust_model_ECU_CSR>
 *
 **********************************************************************************************************************
 *
 * Runnable prototype:
 * ===================
 *   Std_ReturnType Ssa_KeyM_DataServices_DID_019A_Trust_model_ECU_CSR_ReadDataLength(Dcm_OpStatusType OpStatus, uint16 *DataLength)
 *
 **********************************************************************************************************************
 *
 * Available Application Errors:
 * =============================
 *   RTE_E_DataServices_DID_019A_Trust_model_ECU_CSR_DCM_E_PENDING
 *   RTE_E_DataServices_DID_019A_Trust_model_ECU_CSR_E_NOT_OK
 *
 *********************************************************************************************************************/
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << Start of documentation area >>                  DO NOT CHANGE THIS COMMENT!
 * Symbol: Ssa_KeyM_DataServices_DID_019A_Trust_model_ECU_CSR_ReadDataLength_doc
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */

/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << End of documentation area >>                    DO NOT CHANGE THIS COMMENT!
 *********************************************************************************************************************/

FUNC(Std_ReturnType, Ssa_KeyM_CODE) Ssa_KeyM_DataServices_DID_019A_Trust_model_ECU_CSR_ReadDataLength(
  Dcm_OpStatusType OpStatus,
  P2VAR(uint16, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) DataLength) /* PRQA S 0624, 3206 */ /* MD_Rte_0624, MD_Rte_3206 */
{
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << Start of runnable implementation >>             DO NOT CHANGE THIS COMMENT!
 * Symbol: Ssa_KeyM_DataServices_DID_019A_Trust_model_ECU_CSR_ReadDataLength (returns application error)
 *********************************************************************************************************************/

  Std_ReturnType retVal = RTE_E_DataServices_DID_019A_Trust_model_ECU_CSR_E_NOT_OK;

  /* ----- Development Error Checks ------------------------------------- */
#if (SSA_DEV_ERROR_DETECT == STD_ON)
  if (DataLength == NULL_PTR)
  {
    /* retVal already set */
  }
  else
#endif /* SSA_DEV_ERROR_DETECT == STD_ON */
  {
    /* #10 Get required CSR data length. */
    if (OpStatus != DCM_CANCEL)
    {
      /* set length of output data including 2 bytes for the length information */
      *DataLength = (uint16)(KeyM_DiagProc.serviceResponseBufferLength + 2u);
    }
    retVal = RTE_E_OK;
  }
  SSA_DUMMY_STATEMENT(OpStatus);    /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */

  return retVal;

/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << End of runnable implementation >>               DO NOT CHANGE THIS COMMENT!
 *********************************************************************************************************************/
}

/**********************************************************************************************************************
 *
 * Runnable Entity Name: Ssa_KeyM_DataServices_DID_019B_Trust_model_ECU_Certificate_ConditionCheckRead
 *
 *---------------------------------------------------------------------------------------------------------------------
 *
 * Executed if at least one of the following trigger conditions occurred:
 *   - triggered by server invocation for OperationPrototype <ConditionCheckRead> of PortPrototype <DataServices_DID_019B_Trust_model_ECU_Certificate>
 *
 **********************************************************************************************************************
 *
 * Service Calls:
 * ==============
 *   Service Invocation:
 *   -------------------
 *   Std_ReturnType Rte_Call_KeyMCertificate_Ssa_TrustModelEcuCert_GetStatus(KeyM_CertificateStatusType *Status)
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_KeyMCertificate_Ssa_TrustModelEcuCert_E_NOT_OK
 *
 **********************************************************************************************************************
 *
 * Runnable prototype:
 * ===================
 *   Std_ReturnType Ssa_KeyM_DataServices_DID_019B_Trust_model_ECU_Certificate_ConditionCheckRead(Dcm_OpStatusType OpStatus, Dcm_NegativeResponseCodeType *ErrorCode)
 *
 **********************************************************************************************************************
 *
 * Available Application Errors:
 * =============================
 *   RTE_E_DataServices_DID_019B_Trust_model_ECU_Certificate_DCM_E_PENDING
 *   RTE_E_DataServices_DID_019B_Trust_model_ECU_Certificate_E_NOT_OK
 *
 *********************************************************************************************************************/
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << Start of documentation area >>                  DO NOT CHANGE THIS COMMENT!
 * Symbol: Ssa_KeyM_DataServices_DID_019B_Trust_model_ECU_Certificate_ConditionCheckRead_doc
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 */

/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << End of documentation area >>                    DO NOT CHANGE THIS COMMENT!
 *********************************************************************************************************************/

FUNC(Std_ReturnType, Ssa_KeyM_CODE) Ssa_KeyM_DataServices_DID_019B_Trust_model_ECU_Certificate_ConditionCheckRead(
  Dcm_OpStatusType OpStatus,
  P2VAR(Dcm_NegativeResponseCodeType, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) ErrorCode) /* PRQA S 0624, 3206 */ /* MD_Rte_0624, MD_Rte_3206 */
{
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << Start of runnable implementation >>             DO NOT CHANGE THIS COMMENT!
 * Symbol: Ssa_KeyM_DataServices_DID_019B_Trust_model_ECU_Certificate_ConditionCheckRead (returns application error)
 *********************************************************************************************************************/

  Std_ReturnType retVal = RTE_E_DataServices_DID_019B_Trust_model_ECU_Certificate_E_NOT_OK;

  /* ----- Development Error Checks ------------------------------------- */
#if (SSA_DEV_ERROR_DETECT == STD_ON)
  if (ErrorCode == NULL_PTR)
  {
    /* retVal already set */
  }
  else
#endif /* SSA_DEV_ERROR_DETECT == STD_ON */
  {
    /* #10 Return RTE_E_OK if the ECU certificate is readable. */
    if (*Rte_Pim_KeyMTrustModelChainOfTrustState() == SSA_TRUSTMODELCHAINSTATE_INITIAL)
    {
      *ErrorCode = DCM_E_CONDITIONSNOTCORRECT;
    }
    else if (KeyM_KeyM_CertificateIsReadable(SSA_TRUST_MODEL_ECU_CERT_ID, ErrorCode) == FALSE)
    {
    }
    else
    {
      retVal = RTE_E_OK;
    }
  }
  SSA_DUMMY_STATEMENT(OpStatus); /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */

  return retVal;

/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << End of runnable implementation >>               DO NOT CHANGE THIS COMMENT!
 *********************************************************************************************************************/
}

/**********************************************************************************************************************
 *
 * Runnable Entity Name: Ssa_KeyM_DataServices_DID_019B_Trust_model_ECU_Certificate_ReadData
 *
 *---------------------------------------------------------------------------------------------------------------------
 *
 * Executed if at least one of the following trigger conditions occurred:
 *   - triggered by server invocation for OperationPrototype <ReadData> of PortPrototype <DataServices_DID_019B_Trust_model_ECU_Certificate>
 *
 **********************************************************************************************************************
 *
 * Client/Server Interfaces:
 * =========================
 *   Server Invocation:
 *   ------------------
 *   Std_ReturnType Rte_Call_SsaCdd_TrustModel_GetCertificate(KeyM_CertificateIdType CertId, Ssa_DataPtr CertData, Ssa_LengthPtr CertDataLength)
 *     Synchronous Server Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_SsaCdd_KeyM_CertInterface_E_NOT_OK, RTE_E_SsaCdd_KeyM_CertInterface_KEYM_E_KEY_CERT_EMPTY, RTE_E_SsaCdd_KeyM_CertInterface_KEYM_E_KEY_CERT_READ_FAIL, RTE_E_SsaCdd_KeyM_CertInterface_KEYM_E_KEY_CERT_SIZE_MISMATCH, RTE_E_SsaCdd_KeyM_CertInterface_KEYM_E_PARAMETER_MISMATCH
 *
 **********************************************************************************************************************
 *
 * Runnable prototype:
 * ===================
 *   Std_ReturnType Ssa_KeyM_DataServices_DID_019B_Trust_model_ECU_Certificate_ReadData(Dcm_OpStatusType OpStatus, uint8 *Data)
 *     Argument Data: uint8* is of type Dcm_Data1002ByteType
 *
 **********************************************************************************************************************
 *
 * Available Application Errors:
 * =============================
 *   RTE_E_DataServices_DID_019B_Trust_model_ECU_Certificate_DCM_E_PENDING
 *   RTE_E_DataServices_DID_019B_Trust_model_ECU_Certificate_E_NOT_OK
 *
 *********************************************************************************************************************/
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << Start of documentation area >>                  DO NOT CHANGE THIS COMMENT!
 * Symbol: Ssa_KeyM_DataServices_DID_019B_Trust_model_ECU_Certificate_ReadData_doc
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
/*!
 * \spec
 *    requires $lengthOf(Data) >= sizeof(Dcm_Data1002ByteType);
 * \endspec
 */
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << End of documentation area >>                    DO NOT CHANGE THIS COMMENT!
 *********************************************************************************************************************/

FUNC(Std_ReturnType, Ssa_KeyM_CODE) Ssa_KeyM_DataServices_DID_019B_Trust_model_ECU_Certificate_ReadData(
  Dcm_OpStatusType OpStatus,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) Data) /* PRQA S 0624, 3206 */ /* MD_Rte_0624, MD_Rte_3206 */
{
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << Start of runnable implementation >>             DO NOT CHANGE THIS COMMENT!
 * Symbol: Ssa_KeyM_DataServices_DID_019B_Trust_model_ECU_Certificate_ReadData (returns application error)
 *********************************************************************************************************************/
  Std_ReturnType retVal = RTE_E_DataServices_DID_019B_Trust_model_ECU_Certificate_E_NOT_OK;

  /* ----- Development Error Checks ------------------------------------- */
#if (SSA_DEV_ERROR_DETECT == STD_ON)
  if (Data == NULL_PTR)
  {
    /* retVal already set */
  }
  else
#endif /* SSA_DEV_ERROR_DETECT == STD_ON */
  {
    uint16 dataLength = sizeof(Dcm_Data1002ByteType);

    /* #10 Get required certificate data. */
    retVal = KeyM_KeyM_GetCertificateDataAsIteration(SSA_TRUST_MODEL_ECU_CERT_ID, Data, &dataLength);
    retVal = (retVal == E_OK) ? RTE_E_OK : RTE_E_DataServices_DID_019B_Trust_model_ECU_Certificate_E_NOT_OK;

  }
  SSA_DUMMY_STATEMENT(OpStatus);    /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */

  return retVal;

/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << End of runnable implementation >>               DO NOT CHANGE THIS COMMENT!
 *********************************************************************************************************************/
}

/**********************************************************************************************************************
 *
 * Runnable Entity Name: Ssa_KeyM_DataServices_DID_019B_Trust_model_ECU_Certificate_ReadDataLength
 *
 *---------------------------------------------------------------------------------------------------------------------
 *
 * Executed if at least one of the following trigger conditions occurred:
 *   - triggered by server invocation for OperationPrototype <ReadDataLength> of PortPrototype <DataServices_DID_019B_Trust_model_ECU_Certificate>
 *
 **********************************************************************************************************************
 *
 * Client/Server Interfaces:
 * =========================
 *   Server Invocation:
 *   ------------------
 *   Std_ReturnType Rte_Call_SsaCdd_TrustModel_GetCertificate(KeyM_CertificateIdType CertId, Ssa_DataPtr CertData, Ssa_LengthPtr CertDataLength)
 *     Synchronous Server Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_SsaCdd_KeyM_CertInterface_E_NOT_OK, RTE_E_SsaCdd_KeyM_CertInterface_KEYM_E_KEY_CERT_EMPTY, RTE_E_SsaCdd_KeyM_CertInterface_KEYM_E_KEY_CERT_READ_FAIL, RTE_E_SsaCdd_KeyM_CertInterface_KEYM_E_KEY_CERT_SIZE_MISMATCH, RTE_E_SsaCdd_KeyM_CertInterface_KEYM_E_PARAMETER_MISMATCH
 *
 **********************************************************************************************************************
 *
 * Runnable prototype:
 * ===================
 *   Std_ReturnType Ssa_KeyM_DataServices_DID_019B_Trust_model_ECU_Certificate_ReadDataLength(Dcm_OpStatusType OpStatus, uint16 *DataLength)
 *
 **********************************************************************************************************************
 *
 * Available Application Errors:
 * =============================
 *   RTE_E_DataServices_DID_019B_Trust_model_ECU_Certificate_DCM_E_PENDING
 *   RTE_E_DataServices_DID_019B_Trust_model_ECU_Certificate_E_NOT_OK
 *
 *********************************************************************************************************************/
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << Start of documentation area >>                  DO NOT CHANGE THIS COMMENT!
 * Symbol: Ssa_KeyM_DataServices_DID_019B_Trust_model_ECU_Certificate_ReadDataLength_doc
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */

/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << End of documentation area >>                    DO NOT CHANGE THIS COMMENT!
 *********************************************************************************************************************/

FUNC(Std_ReturnType, Ssa_KeyM_CODE) Ssa_KeyM_DataServices_DID_019B_Trust_model_ECU_Certificate_ReadDataLength(
  Dcm_OpStatusType OpStatus,
  P2VAR(uint16, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) DataLength) /* PRQA S 0624, 3206 */ /* MD_Rte_0624, MD_Rte_3206 */
{
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << Start of runnable implementation >>             DO NOT CHANGE THIS COMMENT!
 * Symbol: Ssa_KeyM_DataServices_DID_019B_Trust_model_ECU_Certificate_ReadDataLength (returns application error)
 *********************************************************************************************************************/
  Std_ReturnType retVal = RTE_E_DataServices_DID_019B_Trust_model_ECU_Certificate_E_NOT_OK;

  /* ----- Development Error Checks ------------------------------------- */
#if (SSA_DEV_ERROR_DETECT == STD_ON)
  if (DataLength == NULL_PTR)
  {
    /* retVal already set */
  }
  else
#endif /* SSA_DEV_ERROR_DETECT == STD_ON */
  {
    Dcm_Data1002ByteType buffer;
    *DataLength = sizeof(Dcm_Data1002ByteType);

    /* #10 Get required certificate data length. */
    retVal = KeyM_KeyM_GetCertificateDataAsIteration(SSA_TRUST_MODEL_ECU_CERT_ID, buffer, DataLength);
    retVal = (retVal == E_OK) ? RTE_E_OK : RTE_E_DataServices_DID_019B_Trust_model_ECU_Certificate_E_NOT_OK;

  }
  SSA_DUMMY_STATEMENT(OpStatus);    /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */

  return retVal;
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << End of runnable implementation >>               DO NOT CHANGE THIS COMMENT!
 *********************************************************************************************************************/
}

/**********************************************************************************************************************
 *
 * Runnable Entity Name: Ssa_KeyM_DataServices_DID_019C_Trust_model_Intermediate_CA_Certificate_ConditionCheckRead
 *
 *---------------------------------------------------------------------------------------------------------------------
 *
 * Executed if at least one of the following trigger conditions occurred:
 *   - triggered by server invocation for OperationPrototype <ConditionCheckRead> of PortPrototype <DataServices_DID_019C_Trust_model_Intermediate_CA_Certificate>
 *
 **********************************************************************************************************************
 *
 * Service Calls:
 * ==============
 *   Service Invocation:
 *   -------------------
 *   Std_ReturnType Rte_Call_KeyMCertificate_Ssa_TrustModelIntermediateCert_GetStatus(KeyM_CertificateStatusType *Status)
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_KeyMCertificate_Ssa_TrustModelIntermediateCert_E_NOT_OK
 *
 **********************************************************************************************************************
 *
 * Runnable prototype:
 * ===================
 *   Std_ReturnType Ssa_KeyM_DataServices_DID_019C_Trust_model_Intermediate_CA_Certificate_ConditionCheckRead(Dcm_OpStatusType OpStatus, Dcm_NegativeResponseCodeType *ErrorCode)
 *
 **********************************************************************************************************************
 *
 * Available Application Errors:
 * =============================
 *   RTE_E_DataServices_DID_019C_Trust_model_Intermediate_CA_Certificate_DCM_E_PENDING
 *   RTE_E_DataServices_DID_019C_Trust_model_Intermediate_CA_Certificate_E_NOT_OK
 *
 *********************************************************************************************************************/
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << Start of documentation area >>                  DO NOT CHANGE THIS COMMENT!
 * Symbol: Ssa_KeyM_DataServices_DID_019C_Trust_model_Intermediate_CA_Certificate_ConditionCheckRead_doc
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 */

/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << End of documentation area >>                    DO NOT CHANGE THIS COMMENT!
 *********************************************************************************************************************/

FUNC(Std_ReturnType, Ssa_KeyM_CODE) Ssa_KeyM_DataServices_DID_019C_Trust_model_Intermediate_CA_Certificate_ConditionCheckRead(
  Dcm_OpStatusType OpStatus,
  P2VAR(Dcm_NegativeResponseCodeType, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) ErrorCode) /* PRQA S 0624, 3206 */ /* MD_Rte_0624, MD_Rte_3206 */
{
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << Start of runnable implementation >>             DO NOT CHANGE THIS COMMENT!
 * Symbol: Ssa_KeyM_DataServices_DID_019C_Trust_model_Intermediate_CA_Certificate_ConditionCheckRead (returns application error)
 *********************************************************************************************************************/

  Std_ReturnType retVal = RTE_E_DataServices_DID_019C_Trust_model_Intermediate_CA_Certificate_E_NOT_OK;

  /* ----- Development Error Checks ------------------------------------- */
#if (SSA_DEV_ERROR_DETECT == STD_ON)
  if (ErrorCode == NULL_PTR)
  {
    /* retVal already set */
  }
  else
#endif /* SSA_DEV_ERROR_DETECT == STD_ON */
  {
    /* #10 Return RTE_E_OK if the intermediate certificate is readable. */
    if (*Rte_Pim_KeyMTrustModelChainOfTrustState() == SSA_TRUSTMODELCHAINSTATE_INITIAL)
    {
      *ErrorCode = DCM_E_CONDITIONSNOTCORRECT;
    }
    else if (KeyM_KeyM_CertificateIsReadable(SSA_TRUST_MODEL_INTERMEDIATE_CERT_ID, ErrorCode) == FALSE)
    {
    }
    else
    {
      retVal = RTE_E_OK;
    }
  }
  SSA_DUMMY_STATEMENT(OpStatus);    /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */

  return retVal;

/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << End of runnable implementation >>               DO NOT CHANGE THIS COMMENT!
 *********************************************************************************************************************/
}

/**********************************************************************************************************************
 *
 * Runnable Entity Name: Ssa_KeyM_DataServices_DID_019C_Trust_model_Intermediate_CA_Certificate_ReadData
 *
 *---------------------------------------------------------------------------------------------------------------------
 *
 * Executed if at least one of the following trigger conditions occurred:
 *   - triggered by server invocation for OperationPrototype <ReadData> of PortPrototype <DataServices_DID_019C_Trust_model_Intermediate_CA_Certificate>
 *
 **********************************************************************************************************************
 *
 * Client/Server Interfaces:
 * =========================
 *   Server Invocation:
 *   ------------------
 *   Std_ReturnType Rte_Call_SsaCdd_TrustModel_GetCertificate(KeyM_CertificateIdType CertId, Ssa_DataPtr CertData, Ssa_LengthPtr CertDataLength)
 *     Synchronous Server Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_SsaCdd_KeyM_CertInterface_E_NOT_OK, RTE_E_SsaCdd_KeyM_CertInterface_KEYM_E_KEY_CERT_EMPTY, RTE_E_SsaCdd_KeyM_CertInterface_KEYM_E_KEY_CERT_READ_FAIL, RTE_E_SsaCdd_KeyM_CertInterface_KEYM_E_KEY_CERT_SIZE_MISMATCH, RTE_E_SsaCdd_KeyM_CertInterface_KEYM_E_PARAMETER_MISMATCH
 *
 **********************************************************************************************************************
 *
 * Runnable prototype:
 * ===================
 *   Std_ReturnType Ssa_KeyM_DataServices_DID_019C_Trust_model_Intermediate_CA_Certificate_ReadData(Dcm_OpStatusType OpStatus, uint8 *Data)
 *     Argument Data: uint8* is of type Dcm_Data1002ByteType
 *
 **********************************************************************************************************************
 *
 * Available Application Errors:
 * =============================
 *   RTE_E_DataServices_DID_019C_Trust_model_Intermediate_CA_Certificate_DCM_E_PENDING
 *   RTE_E_DataServices_DID_019C_Trust_model_Intermediate_CA_Certificate_E_NOT_OK
 *
 *********************************************************************************************************************/
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << Start of documentation area >>                  DO NOT CHANGE THIS COMMENT!
 * Symbol: Ssa_KeyM_DataServices_DID_019C_Trust_model_Intermediate_CA_Certificate_ReadData_doc
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
/*!
 * \spec
 *    requires $lengthOf(Data) >= sizeof(Dcm_Data1002ByteType);
 * \endspec
 */
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << End of documentation area >>                    DO NOT CHANGE THIS COMMENT!
 *********************************************************************************************************************/

FUNC(Std_ReturnType, Ssa_KeyM_CODE) Ssa_KeyM_DataServices_DID_019C_Trust_model_Intermediate_CA_Certificate_ReadData(
  Dcm_OpStatusType OpStatus,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) Data) /* PRQA S 0624, 3206 */ /* MD_Rte_0624, MD_Rte_3206 */
{
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << Start of runnable implementation >>             DO NOT CHANGE THIS COMMENT!
 * Symbol: Ssa_KeyM_DataServices_DID_019C_Trust_model_Intermediate_CA_Certificate_ReadData (returns application error)
 *********************************************************************************************************************/
  Std_ReturnType retVal = RTE_E_DataServices_DID_019C_Trust_model_Intermediate_CA_Certificate_E_NOT_OK;

  /* ----- Development Error Checks ------------------------------------- */
#if (SSA_DEV_ERROR_DETECT == STD_ON)
  if (Data == NULL_PTR)
  {
    /* retVal already set */
  }
  else
#endif /* SSA_DEV_ERROR_DETECT == STD_ON */
  {

    uint16 dataLength = sizeof(Dcm_Data1002ByteType);

    /* #10 Get required certificate data. */
    retVal = KeyM_KeyM_GetCertificateDataAsIteration(SSA_TRUST_MODEL_INTERMEDIATE_CERT_ID, Data, &dataLength);
    retVal = (retVal == E_OK) ? RTE_E_OK : RTE_E_DataServices_DID_019C_Trust_model_Intermediate_CA_Certificate_E_NOT_OK;
  }
  SSA_DUMMY_STATEMENT(OpStatus);    /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */

  return retVal;

/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << End of runnable implementation >>               DO NOT CHANGE THIS COMMENT!
 *********************************************************************************************************************/
}

/**********************************************************************************************************************
 *
 * Runnable Entity Name: Ssa_KeyM_DataServices_DID_019C_Trust_model_Intermediate_CA_Certificate_ReadDataLength
 *
 *---------------------------------------------------------------------------------------------------------------------
 *
 * Executed if at least one of the following trigger conditions occurred:
 *   - triggered by server invocation for OperationPrototype <ReadDataLength> of PortPrototype <DataServices_DID_019C_Trust_model_Intermediate_CA_Certificate>
 *
 **********************************************************************************************************************
 *
 * Client/Server Interfaces:
 * =========================
 *   Server Invocation:
 *   ------------------
 *   Std_ReturnType Rte_Call_SsaCdd_TrustModel_GetCertificate(KeyM_CertificateIdType CertId, Ssa_DataPtr CertData, Ssa_LengthPtr CertDataLength)
 *     Synchronous Server Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_SsaCdd_KeyM_CertInterface_E_NOT_OK, RTE_E_SsaCdd_KeyM_CertInterface_KEYM_E_KEY_CERT_EMPTY, RTE_E_SsaCdd_KeyM_CertInterface_KEYM_E_KEY_CERT_READ_FAIL, RTE_E_SsaCdd_KeyM_CertInterface_KEYM_E_KEY_CERT_SIZE_MISMATCH, RTE_E_SsaCdd_KeyM_CertInterface_KEYM_E_PARAMETER_MISMATCH
 *
 **********************************************************************************************************************
 *
 * Runnable prototype:
 * ===================
 *   Std_ReturnType Ssa_KeyM_DataServices_DID_019C_Trust_model_Intermediate_CA_Certificate_ReadDataLength(Dcm_OpStatusType OpStatus, uint16 *DataLength)
 *
 **********************************************************************************************************************
 *
 * Available Application Errors:
 * =============================
 *   RTE_E_DataServices_DID_019C_Trust_model_Intermediate_CA_Certificate_DCM_E_PENDING
 *   RTE_E_DataServices_DID_019C_Trust_model_Intermediate_CA_Certificate_E_NOT_OK
 *
 *********************************************************************************************************************/
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << Start of documentation area >>                  DO NOT CHANGE THIS COMMENT!
 * Symbol: Ssa_KeyM_DataServices_DID_019C_Trust_model_Intermediate_CA_Certificate_ReadDataLength_doc
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */

/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << End of documentation area >>                    DO NOT CHANGE THIS COMMENT!
 *********************************************************************************************************************/

FUNC(Std_ReturnType, Ssa_KeyM_CODE) Ssa_KeyM_DataServices_DID_019C_Trust_model_Intermediate_CA_Certificate_ReadDataLength(
  Dcm_OpStatusType OpStatus,
  P2VAR(uint16, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) DataLength) /* PRQA S 0624, 3206 */ /* MD_Rte_0624, MD_Rte_3206 */
{
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << Start of runnable implementation >>             DO NOT CHANGE THIS COMMENT!
 * Symbol: Ssa_KeyM_DataServices_DID_019C_Trust_model_Intermediate_CA_Certificate_ReadDataLength (returns application error)
 *********************************************************************************************************************/
  Std_ReturnType retVal = RTE_E_DataServices_DID_019C_Trust_model_Intermediate_CA_Certificate_E_NOT_OK;

  /* ----- Development Error Checks ------------------------------------- */
#if (SSA_DEV_ERROR_DETECT == STD_ON)
  if (DataLength == NULL_PTR)
  {
    /* retVal already set */
  }
  else
#endif /* SSA_DEV_ERROR_DETECT == STD_ON */
  {
    Dcm_Data1002ByteType buffer;
    *DataLength = sizeof(Dcm_Data1002ByteType);

    /* #10 Get required certificate data length. */
    retVal = KeyM_KeyM_GetCertificateDataAsIteration(SSA_TRUST_MODEL_INTERMEDIATE_CERT_ID, buffer, DataLength);
    retVal = (retVal == E_OK) ? RTE_E_OK : RTE_E_DataServices_DID_019C_Trust_model_Intermediate_CA_Certificate_E_NOT_OK;
  }
  SSA_DUMMY_STATEMENT(OpStatus);    /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */

  return retVal;
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << End of runnable implementation >>               DO NOT CHANGE THIS COMMENT!
 *********************************************************************************************************************/
}

/**********************************************************************************************************************
 *
 * Runnable Entity Name: Ssa_KeyM_DataServices_DID_019D_Trust_model_Backend_CA_certificate_ConditionCheckRead
 *
 *---------------------------------------------------------------------------------------------------------------------
 *
 * Executed if at least one of the following trigger conditions occurred:
 *   - triggered by server invocation for OperationPrototype <ConditionCheckRead> of PortPrototype <DataServices_DID_019D_Trust_model_Backend_CA_certificate>
 *
 **********************************************************************************************************************
 *
 * Service Calls:
 * ==============
 *   Service Invocation:
 *   -------------------
 *   Std_ReturnType Rte_Call_KeyMCertificate_Ssa_TrustModelBackendCert_GetStatus(KeyM_CertificateStatusType *Status)
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_KeyMCertificate_Ssa_TrustModelBackendCert_E_NOT_OK
 *
 **********************************************************************************************************************
 *
 * Runnable prototype:
 * ===================
 *   Std_ReturnType Ssa_KeyM_DataServices_DID_019D_Trust_model_Backend_CA_certificate_ConditionCheckRead(Dcm_OpStatusType OpStatus, Dcm_NegativeResponseCodeType *ErrorCode)
 *
 **********************************************************************************************************************
 *
 * Available Application Errors:
 * =============================
 *   RTE_E_DataServices_DID_019D_Trust_model_Backend_CA_certificate_DCM_E_PENDING
 *   RTE_E_DataServices_DID_019D_Trust_model_Backend_CA_certificate_E_NOT_OK
 *
 *********************************************************************************************************************/
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << Start of documentation area >>                  DO NOT CHANGE THIS COMMENT!
 * Symbol: Ssa_KeyM_DataServices_DID_019D_Trust_model_Backend_CA_certificate_ConditionCheckRead_doc
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 */

/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << End of documentation area >>                    DO NOT CHANGE THIS COMMENT!
 *********************************************************************************************************************/

FUNC(Std_ReturnType, Ssa_KeyM_CODE) Ssa_KeyM_DataServices_DID_019D_Trust_model_Backend_CA_certificate_ConditionCheckRead(
  Dcm_OpStatusType OpStatus,
  P2VAR(Dcm_NegativeResponseCodeType, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) ErrorCode) /* PRQA S 0624, 3206 */ /* MD_Rte_0624, MD_Rte_3206 */
{
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << Start of runnable implementation >>             DO NOT CHANGE THIS COMMENT!
 * Symbol: Ssa_KeyM_DataServices_DID_019D_Trust_model_Backend_CA_certificate_ConditionCheckRead (returns application error)
 *********************************************************************************************************************/

  Std_ReturnType retVal = RTE_E_DataServices_DID_019D_Trust_model_Backend_CA_certificate_E_NOT_OK;

  /* ----- Development Error Checks ------------------------------------- */
#if (SSA_DEV_ERROR_DETECT == STD_ON)
  if (ErrorCode == NULL_PTR)
  {
    /* retVal already set */
  }
  else
#endif /* SSA_DEV_ERROR_DETECT == STD_ON */
  {
    /* #10 Return RTE_E_OK if the backend certificate is readable. */
    if (*Rte_Pim_KeyMTrustModelChainOfTrustState() == SSA_TRUSTMODELCHAINSTATE_INITIAL)
    {
      *ErrorCode = DCM_E_CONDITIONSNOTCORRECT;
    }
    else if (KeyM_KeyM_CertificateIsReadable(SSA_TRUST_MODEL_BACKEND_CERT_ID, ErrorCode) == FALSE)
    {
    }
    else
    {
      retVal = RTE_E_OK;
    }
  }
  SSA_DUMMY_STATEMENT(OpStatus);    /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */

  return retVal;

/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << End of runnable implementation >>               DO NOT CHANGE THIS COMMENT!
 *********************************************************************************************************************/
}

/**********************************************************************************************************************
 *
 * Runnable Entity Name: Ssa_KeyM_DataServices_DID_019D_Trust_model_Backend_CA_certificate_ReadData
 *
 *---------------------------------------------------------------------------------------------------------------------
 *
 * Executed if at least one of the following trigger conditions occurred:
 *   - triggered by server invocation for OperationPrototype <ReadData> of PortPrototype <DataServices_DID_019D_Trust_model_Backend_CA_certificate>
 *
 **********************************************************************************************************************
 *
 * Client/Server Interfaces:
 * =========================
 *   Server Invocation:
 *   ------------------
 *   Std_ReturnType Rte_Call_SsaCdd_TrustModel_GetCertificate(KeyM_CertificateIdType CertId, Ssa_DataPtr CertData, Ssa_LengthPtr CertDataLength)
 *     Synchronous Server Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_SsaCdd_KeyM_CertInterface_E_NOT_OK, RTE_E_SsaCdd_KeyM_CertInterface_KEYM_E_KEY_CERT_EMPTY, RTE_E_SsaCdd_KeyM_CertInterface_KEYM_E_KEY_CERT_READ_FAIL, RTE_E_SsaCdd_KeyM_CertInterface_KEYM_E_KEY_CERT_SIZE_MISMATCH, RTE_E_SsaCdd_KeyM_CertInterface_KEYM_E_PARAMETER_MISMATCH
 *
 **********************************************************************************************************************
 *
 * Runnable prototype:
 * ===================
 *   Std_ReturnType Ssa_KeyM_DataServices_DID_019D_Trust_model_Backend_CA_certificate_ReadData(Dcm_OpStatusType OpStatus, uint8 *Data)
 *     Argument Data: uint8* is of type Dcm_Data1002ByteType
 *
 **********************************************************************************************************************
 *
 * Available Application Errors:
 * =============================
 *   RTE_E_DataServices_DID_019D_Trust_model_Backend_CA_certificate_DCM_E_PENDING
 *   RTE_E_DataServices_DID_019D_Trust_model_Backend_CA_certificate_E_NOT_OK
 *
 *********************************************************************************************************************/
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << Start of documentation area >>                  DO NOT CHANGE THIS COMMENT!
 * Symbol: Ssa_KeyM_DataServices_DID_019D_Trust_model_Backend_CA_certificate_ReadData_doc
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
/*!
 * \spec
 *    requires $lengthOf(Data) >= sizeof(Dcm_Data1002ByteType);
 * \endspec
 */
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << End of documentation area >>                    DO NOT CHANGE THIS COMMENT!
 *********************************************************************************************************************/

FUNC(Std_ReturnType, Ssa_KeyM_CODE) Ssa_KeyM_DataServices_DID_019D_Trust_model_Backend_CA_certificate_ReadData(
  Dcm_OpStatusType OpStatus,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) Data) /* PRQA S 0624, 3206 */ /* MD_Rte_0624, MD_Rte_3206 */
{
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << Start of runnable implementation >>             DO NOT CHANGE THIS COMMENT!
 * Symbol: Ssa_KeyM_DataServices_DID_019D_Trust_model_Backend_CA_certificate_ReadData (returns application error)
 *********************************************************************************************************************/

  Std_ReturnType retVal = RTE_E_DataServices_DID_019D_Trust_model_Backend_CA_certificate_E_NOT_OK;

  /* ----- Development Error Checks ------------------------------------- */
#if (SSA_DEV_ERROR_DETECT == STD_ON)
  if (Data == NULL_PTR)
  {
    /* retVal already set */
  }
  else
#endif /* SSA_DEV_ERROR_DETECT == STD_ON */
  {

    uint16 dataLength = sizeof(Dcm_Data1002ByteType);

    /* #10 Get required certificate data. */
    retVal = KeyM_KeyM_GetCertificateDataAsIteration(SSA_TRUST_MODEL_BACKEND_CERT_ID, Data, &dataLength);
    retVal = (retVal == E_OK) ? RTE_E_OK : RTE_E_DataServices_DID_019D_Trust_model_Backend_CA_certificate_E_NOT_OK;
  }
  SSA_DUMMY_STATEMENT(OpStatus);    /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */

  return retVal;

/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << End of runnable implementation >>               DO NOT CHANGE THIS COMMENT!
 *********************************************************************************************************************/
}

/**********************************************************************************************************************
 *
 * Runnable Entity Name: Ssa_KeyM_DataServices_DID_019D_Trust_model_Backend_CA_certificate_ReadDataLength
 *
 *---------------------------------------------------------------------------------------------------------------------
 *
 * Executed if at least one of the following trigger conditions occurred:
 *   - triggered by server invocation for OperationPrototype <ReadDataLength> of PortPrototype <DataServices_DID_019D_Trust_model_Backend_CA_certificate>
 *
 **********************************************************************************************************************
 *
 * Client/Server Interfaces:
 * =========================
 *   Server Invocation:
 *   ------------------
 *   Std_ReturnType Rte_Call_SsaCdd_TrustModel_GetCertificate(KeyM_CertificateIdType CertId, Ssa_DataPtr CertData, Ssa_LengthPtr CertDataLength)
 *     Synchronous Server Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_SsaCdd_KeyM_CertInterface_E_NOT_OK, RTE_E_SsaCdd_KeyM_CertInterface_KEYM_E_KEY_CERT_EMPTY, RTE_E_SsaCdd_KeyM_CertInterface_KEYM_E_KEY_CERT_READ_FAIL, RTE_E_SsaCdd_KeyM_CertInterface_KEYM_E_KEY_CERT_SIZE_MISMATCH, RTE_E_SsaCdd_KeyM_CertInterface_KEYM_E_PARAMETER_MISMATCH
 *
 **********************************************************************************************************************
 *
 * Runnable prototype:
 * ===================
 *   Std_ReturnType Ssa_KeyM_DataServices_DID_019D_Trust_model_Backend_CA_certificate_ReadDataLength(Dcm_OpStatusType OpStatus, uint16 *DataLength)
 *
 **********************************************************************************************************************
 *
 * Available Application Errors:
 * =============================
 *   RTE_E_DataServices_DID_019D_Trust_model_Backend_CA_certificate_DCM_E_PENDING
 *   RTE_E_DataServices_DID_019D_Trust_model_Backend_CA_certificate_E_NOT_OK
 *
 *********************************************************************************************************************/
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << Start of documentation area >>                  DO NOT CHANGE THIS COMMENT!
 * Symbol: Ssa_KeyM_DataServices_DID_019D_Trust_model_Backend_CA_certificate_ReadDataLength_doc
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */

/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << End of documentation area >>                    DO NOT CHANGE THIS COMMENT!
 *********************************************************************************************************************/

FUNC(Std_ReturnType, Ssa_KeyM_CODE) Ssa_KeyM_DataServices_DID_019D_Trust_model_Backend_CA_certificate_ReadDataLength(
  Dcm_OpStatusType OpStatus,
  P2VAR(uint16, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) DataLength) /* PRQA S 0624, 3206 */ /* MD_Rte_0624, MD_Rte_3206 */
{
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << Start of runnable implementation >>             DO NOT CHANGE THIS COMMENT!
 * Symbol: Ssa_KeyM_DataServices_DID_019D_Trust_model_Backend_CA_certificate_ReadDataLength (returns application error)
 *********************************************************************************************************************/
  Std_ReturnType retVal = RTE_E_DataServices_DID_019D_Trust_model_Backend_CA_certificate_E_NOT_OK;

  /* ----- Development Error Checks ------------------------------------- */
#if (SSA_DEV_ERROR_DETECT == STD_ON)
  if (DataLength == NULL_PTR)
  {
    /* retVal already set */
  }
  else
#endif /* SSA_DEV_ERROR_DETECT == STD_ON */
  {
    Dcm_Data1002ByteType buffer;
    *DataLength = sizeof(Dcm_Data1002ByteType);

    /* #10 Get required certificate data length. */
    retVal = KeyM_KeyM_GetCertificateDataAsIteration(SSA_TRUST_MODEL_BACKEND_CERT_ID, buffer, DataLength);
    retVal = (retVal == E_OK) ? RTE_E_OK : RTE_E_DataServices_DID_019D_Trust_model_Backend_CA_certificate_E_NOT_OK;
  }

  SSA_DUMMY_STATEMENT(OpStatus);    /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */

  return retVal;

/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << End of runnable implementation >>               DO NOT CHANGE THIS COMMENT!
 *********************************************************************************************************************/
}

/**********************************************************************************************************************
 *
 * Runnable Entity Name: Ssa_KeyM_DataServices_DID_019E_Trust_model_Root_CA_certificate_ConditionCheckRead
 *
 *---------------------------------------------------------------------------------------------------------------------
 *
 * Executed if at least one of the following trigger conditions occurred:
 *   - triggered by server invocation for OperationPrototype <ConditionCheckRead> of PortPrototype <DataServices_DID_019E_Trust_model_Root_CA_certificate>
 *
 **********************************************************************************************************************
 *
 * Service Calls:
 * ==============
 *   Service Invocation:
 *   -------------------
 *   Std_ReturnType Rte_Call_KeyMCertificate_Ssa_TrustModelRootCert_GetStatus(KeyM_CertificateStatusType *Status)
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_KeyMCertificate_Ssa_TrustModelRootCert_E_NOT_OK
 *
 **********************************************************************************************************************
 *
 * Runnable prototype:
 * ===================
 *   Std_ReturnType Ssa_KeyM_DataServices_DID_019E_Trust_model_Root_CA_certificate_ConditionCheckRead(Dcm_OpStatusType OpStatus, Dcm_NegativeResponseCodeType *ErrorCode)
 *
 **********************************************************************************************************************
 *
 * Available Application Errors:
 * =============================
 *   RTE_E_DataServices_DID_019E_Trust_model_Root_CA_certificate_DCM_E_PENDING
 *   RTE_E_DataServices_DID_019E_Trust_model_Root_CA_certificate_E_NOT_OK
 *
 *********************************************************************************************************************/
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << Start of documentation area >>                  DO NOT CHANGE THIS COMMENT!
 * Symbol: Ssa_KeyM_DataServices_DID_019E_Trust_model_Root_CA_certificate_ConditionCheckRead_doc
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */

/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << End of documentation area >>                    DO NOT CHANGE THIS COMMENT!
 *********************************************************************************************************************/

FUNC(Std_ReturnType, Ssa_KeyM_CODE) Ssa_KeyM_DataServices_DID_019E_Trust_model_Root_CA_certificate_ConditionCheckRead(
  Dcm_OpStatusType OpStatus,
  P2VAR(Dcm_NegativeResponseCodeType, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) ErrorCode) /* PRQA S 0624, 3206 */ /* MD_Rte_0624, MD_Rte_3206 */
{
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << Start of runnable implementation >>             DO NOT CHANGE THIS COMMENT!
 * Symbol: Ssa_KeyM_DataServices_DID_019E_Trust_model_Root_CA_certificate_ConditionCheckRead (returns application error)
 *********************************************************************************************************************/

  Std_ReturnType retVal = RTE_E_DataServices_DID_019E_Trust_model_Root_CA_certificate_E_NOT_OK;

  /* ----- Development Error Checks ------------------------------------- */
#if (SSA_DEV_ERROR_DETECT == STD_ON)
  if (ErrorCode == NULL_PTR)
  {
    /* retVal already set */
  }
  else
#endif /* SSA_DEV_ERROR_DETECT == STD_ON */
  {
    /* #10 Return RTE_E_OK if the root certificate is readable. */
    boolean readable = KeyM_KeyM_CertificateIsReadable(SSA_TRUST_MODEL_ROOT_CERT_ID, ErrorCode);
    retVal = readable ? RTE_E_OK : RTE_E_DataServices_DID_019E_Trust_model_Root_CA_certificate_E_NOT_OK;
  }
  SSA_DUMMY_STATEMENT(OpStatus);    /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */

  return retVal;

/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << End of runnable implementation >>               DO NOT CHANGE THIS COMMENT!
 *********************************************************************************************************************/
}

/**********************************************************************************************************************
 *
 * Runnable Entity Name: Ssa_KeyM_DataServices_DID_019E_Trust_model_Root_CA_certificate_ReadData
 *
 *---------------------------------------------------------------------------------------------------------------------
 *
 * Executed if at least one of the following trigger conditions occurred:
 *   - triggered by server invocation for OperationPrototype <ReadData> of PortPrototype <DataServices_DID_019E_Trust_model_Root_CA_certificate>
 *
 **********************************************************************************************************************
 *
 * Client/Server Interfaces:
 * =========================
 *   Server Invocation:
 *   ------------------
 *   Std_ReturnType Rte_Call_SsaCdd_TrustModel_GetCertificate(KeyM_CertificateIdType CertId, Ssa_DataPtr CertData, Ssa_LengthPtr CertDataLength)
 *     Synchronous Server Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_SsaCdd_KeyM_CertInterface_E_NOT_OK, RTE_E_SsaCdd_KeyM_CertInterface_KEYM_E_KEY_CERT_EMPTY, RTE_E_SsaCdd_KeyM_CertInterface_KEYM_E_KEY_CERT_READ_FAIL, RTE_E_SsaCdd_KeyM_CertInterface_KEYM_E_KEY_CERT_SIZE_MISMATCH, RTE_E_SsaCdd_KeyM_CertInterface_KEYM_E_PARAMETER_MISMATCH
 *
 **********************************************************************************************************************
 *
 * Runnable prototype:
 * ===================
 *   Std_ReturnType Ssa_KeyM_DataServices_DID_019E_Trust_model_Root_CA_certificate_ReadData(Dcm_OpStatusType OpStatus, uint8 *Data)
 *     Argument Data: uint8* is of type Dcm_Data1002ByteType
 *
 **********************************************************************************************************************
 *
 * Available Application Errors:
 * =============================
 *   RTE_E_DataServices_DID_019E_Trust_model_Root_CA_certificate_DCM_E_PENDING
 *   RTE_E_DataServices_DID_019E_Trust_model_Root_CA_certificate_E_NOT_OK
 *
 *********************************************************************************************************************/
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << Start of documentation area >>                  DO NOT CHANGE THIS COMMENT!
 * Symbol: Ssa_KeyM_DataServices_DID_019E_Trust_model_Root_CA_certificate_ReadData_doc
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
/*!
 * \spec
 *    requires $lengthOf(Data) >= sizeof(Dcm_Data1002ByteType);
 * \endspec
 */
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << End of documentation area >>                    DO NOT CHANGE THIS COMMENT!
 *********************************************************************************************************************/

FUNC(Std_ReturnType, Ssa_KeyM_CODE) Ssa_KeyM_DataServices_DID_019E_Trust_model_Root_CA_certificate_ReadData(
  Dcm_OpStatusType OpStatus,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) Data) /* PRQA S 0624, 3206 */ /* MD_Rte_0624, MD_Rte_3206 */
{
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << Start of runnable implementation >>             DO NOT CHANGE THIS COMMENT!
 * Symbol: Ssa_KeyM_DataServices_DID_019E_Trust_model_Root_CA_certificate_ReadData (returns application error)
 *********************************************************************************************************************/

  Std_ReturnType retVal = RTE_E_DataServices_DID_019E_Trust_model_Root_CA_certificate_E_NOT_OK;

  /* ----- Development Error Checks ------------------------------------- */
#if (SSA_DEV_ERROR_DETECT == STD_ON)
  if (Data == NULL_PTR)
  {
    /* retVal already set */
  }
  else
#endif /* SSA_DEV_ERROR_DETECT == STD_ON */
  {

    uint16 dataLength = sizeof(Dcm_Data1002ByteType);

    /* #10 Get required certificate data. */
    retVal = KeyM_KeyM_GetCertificateDataAsIteration(SSA_TRUST_MODEL_ROOT_CERT_ID, Data, &dataLength);
    retVal = (retVal == E_OK) ? RTE_E_OK : RTE_E_DataServices_DID_019E_Trust_model_Root_CA_certificate_E_NOT_OK;
  }
  SSA_DUMMY_STATEMENT(OpStatus);    /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */
  return retVal;

/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << End of runnable implementation >>               DO NOT CHANGE THIS COMMENT!
 *********************************************************************************************************************/
}

/**********************************************************************************************************************
 *
 * Runnable Entity Name: Ssa_KeyM_DataServices_DID_019E_Trust_model_Root_CA_certificate_ReadDataLength
 *
 *---------------------------------------------------------------------------------------------------------------------
 *
 * Executed if at least one of the following trigger conditions occurred:
 *   - triggered by server invocation for OperationPrototype <ReadDataLength> of PortPrototype <DataServices_DID_019E_Trust_model_Root_CA_certificate>
 *
 **********************************************************************************************************************
 *
 * Client/Server Interfaces:
 * =========================
 *   Server Invocation:
 *   ------------------
 *   Std_ReturnType Rte_Call_SsaCdd_TrustModel_GetCertificate(KeyM_CertificateIdType CertId, Ssa_DataPtr CertData, Ssa_LengthPtr CertDataLength)
 *     Synchronous Server Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_SsaCdd_KeyM_CertInterface_E_NOT_OK, RTE_E_SsaCdd_KeyM_CertInterface_KEYM_E_KEY_CERT_EMPTY, RTE_E_SsaCdd_KeyM_CertInterface_KEYM_E_KEY_CERT_READ_FAIL, RTE_E_SsaCdd_KeyM_CertInterface_KEYM_E_KEY_CERT_SIZE_MISMATCH, RTE_E_SsaCdd_KeyM_CertInterface_KEYM_E_PARAMETER_MISMATCH
 *
 **********************************************************************************************************************
 *
 * Runnable prototype:
 * ===================
 *   Std_ReturnType Ssa_KeyM_DataServices_DID_019E_Trust_model_Root_CA_certificate_ReadDataLength(Dcm_OpStatusType OpStatus, uint16 *DataLength)
 *
 **********************************************************************************************************************
 *
 * Available Application Errors:
 * =============================
 *   RTE_E_DataServices_DID_019E_Trust_model_Root_CA_certificate_DCM_E_PENDING
 *   RTE_E_DataServices_DID_019E_Trust_model_Root_CA_certificate_E_NOT_OK
 *
 *********************************************************************************************************************/
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << Start of documentation area >>                  DO NOT CHANGE THIS COMMENT!
 * Symbol: Ssa_KeyM_DataServices_DID_019E_Trust_model_Root_CA_certificate_ReadDataLength_doc
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */

/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << End of documentation area >>                    DO NOT CHANGE THIS COMMENT!
 *********************************************************************************************************************/

FUNC(Std_ReturnType, Ssa_KeyM_CODE) Ssa_KeyM_DataServices_DID_019E_Trust_model_Root_CA_certificate_ReadDataLength(
  Dcm_OpStatusType OpStatus,
  P2VAR(uint16, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) DataLength) /* PRQA S 0624, 3206 */ /* MD_Rte_0624, MD_Rte_3206 */
{
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << Start of runnable implementation >>             DO NOT CHANGE THIS COMMENT!
 * Symbol: Ssa_KeyM_DataServices_DID_019E_Trust_model_Root_CA_certificate_ReadDataLength (returns application error)
 *********************************************************************************************************************/
  Std_ReturnType retVal = RTE_E_DataServices_DID_019E_Trust_model_Root_CA_certificate_E_NOT_OK;

  /* ----- Development Error Checks ------------------------------------- */
#if (SSA_DEV_ERROR_DETECT == STD_ON)
  if (DataLength == NULL_PTR)
  {
    /* retVal already set */
  }
  else
#endif /* SSA_DEV_ERROR_DETECT == STD_ON */
  {
    Dcm_Data1002ByteType buffer;
    *DataLength = sizeof(Dcm_Data1002ByteType);

    /* #10 Get required certificate data length. */
    retVal = KeyM_KeyM_GetCertificateDataAsIteration(SSA_TRUST_MODEL_ROOT_CERT_ID, buffer, DataLength);
    retVal = (retVal == E_OK) ? RTE_E_OK : RTE_E_DataServices_DID_019E_Trust_model_Root_CA_certificate_E_NOT_OK;
  }
  SSA_DUMMY_STATEMENT(OpStatus);    /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */
  return retVal;

/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << End of runnable implementation >>               DO NOT CHANGE THIS COMMENT!
 *********************************************************************************************************************/
}

/**********************************************************************************************************************
 *
 * Runnable Entity Name: Ssa_KeyM_DataServices_DID_019F_Trust_model_certificates_ConditionCheckRead
 *
 *---------------------------------------------------------------------------------------------------------------------
 *
 * Executed if at least one of the following trigger conditions occurred:
 *   - triggered by server invocation for OperationPrototype <ConditionCheckRead> of PortPrototype <DataServices_DID_019F_Trust_model_certificates>
 *
 **********************************************************************************************************************
 *
 * Service Calls:
 * ==============
 *   Service Invocation:
 *   -------------------
 *   Std_ReturnType Rte_Call_KeyMCertificate_Ssa_TrustModelBackendCert_GetStatus(KeyM_CertificateStatusType *Status)
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_KeyMCertificate_Ssa_TrustModelBackendCert_E_NOT_OK
 *   Std_ReturnType Rte_Call_KeyMCertificate_Ssa_TrustModelEcuCert_GetStatus(KeyM_CertificateStatusType *Status)
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_KeyMCertificate_Ssa_TrustModelEcuCert_E_NOT_OK
 *   Std_ReturnType Rte_Call_KeyMCertificate_Ssa_TrustModelIntermediateCert_GetStatus(KeyM_CertificateStatusType *Status)
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_KeyMCertificate_Ssa_TrustModelIntermediateCert_E_NOT_OK
 *   Std_ReturnType Rte_Call_KeyMCertificate_Ssa_TrustModelRootCert_GetStatus(KeyM_CertificateStatusType *Status)
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_KeyMCertificate_Ssa_TrustModelRootCert_E_NOT_OK
 *
 **********************************************************************************************************************
 *
 * Runnable prototype:
 * ===================
 *   Std_ReturnType Ssa_KeyM_DataServices_DID_019F_Trust_model_certificates_ConditionCheckRead(Dcm_OpStatusType OpStatus, Dcm_NegativeResponseCodeType *ErrorCode)
 *
 **********************************************************************************************************************
 *
 * Available Application Errors:
 * =============================
 *   RTE_E_DataServices_DID_019F_Trust_model_certificates_DCM_E_PENDING
 *   RTE_E_DataServices_DID_019F_Trust_model_certificates_E_NOT_OK
 *
 *********************************************************************************************************************/
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << Start of documentation area >>                  DO NOT CHANGE THIS COMMENT!
 * Symbol: Ssa_KeyM_DataServices_DID_019F_Trust_model_certificates_ConditionCheckRead_doc
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 */

/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << End of documentation area >>                    DO NOT CHANGE THIS COMMENT!
 *********************************************************************************************************************/

FUNC(Std_ReturnType, Ssa_KeyM_CODE) Ssa_KeyM_DataServices_DID_019F_Trust_model_certificates_ConditionCheckRead(
  Dcm_OpStatusType OpStatus,
  P2VAR(Dcm_NegativeResponseCodeType, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) ErrorCode) /* PRQA S 0624, 3206 */ /* MD_Rte_0624, MD_Rte_3206 */
{
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << Start of runnable implementation >>             DO NOT CHANGE THIS COMMENT!
 * Symbol: Ssa_KeyM_DataServices_DID_019F_Trust_model_certificates_ConditionCheckRead (returns application error)
 *********************************************************************************************************************/
  Std_ReturnType retVal = RTE_E_DataServices_DID_019F_Trust_model_certificates_E_NOT_OK;

  /* ----- Development Error Checks ------------------------------------- */
#if (SSA_DEV_ERROR_DETECT == STD_ON)
  if (ErrorCode == NULL_PTR)
  {
    /* retVal already set */
  }
  else
#endif /* SSA_DEV_ERROR_DETECT == STD_ON */
  {
    /* #10 Append all required certificate states: ECU, Intermediate, Backend, Root. */
    if (*Rte_Pim_KeyMTrustModelChainOfTrustState() == SSA_TRUSTMODELCHAINSTATE_INITIAL)
    {
      *ErrorCode = DCM_E_CONDITIONSNOTCORRECT;
    }
    else if (KeyM_KeyM_CertificateIsReadable(SSA_TRUST_MODEL_ECU_CERT_ID, ErrorCode) == FALSE)
    {
    }
    else if (KeyM_KeyM_CertificateIsReadable(SSA_TRUST_MODEL_INTERMEDIATE_CERT_ID, ErrorCode) == FALSE)
    {
    }
    else if (KeyM_KeyM_CertificateIsReadable(SSA_TRUST_MODEL_BACKEND_CERT_ID, ErrorCode) == FALSE)
    {
    }
    else if (KeyM_KeyM_CertificateIsReadable(SSA_TRUST_MODEL_ROOT_CERT_ID, ErrorCode) == FALSE)
    {
    }
    else
    {
      retVal = RTE_E_OK;
    }
  }
  SSA_DUMMY_STATEMENT(OpStatus);    /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */

  return retVal;

  /* PRQA S 6080 4 */ /* MD_MSR_STMIF */
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << End of runnable implementation >>               DO NOT CHANGE THIS COMMENT!
 *********************************************************************************************************************/
}

/**********************************************************************************************************************
 *
 * Runnable Entity Name: Ssa_KeyM_DataServices_DID_019F_Trust_model_certificates_ReadData
 *
 *---------------------------------------------------------------------------------------------------------------------
 *
 * Executed if at least one of the following trigger conditions occurred:
 *   - triggered by server invocation for OperationPrototype <ReadData> of PortPrototype <DataServices_DID_019F_Trust_model_certificates>
 *
 **********************************************************************************************************************
 *
 * Client/Server Interfaces:
 * =========================
 *   Server Invocation:
 *   ------------------
 *   Std_ReturnType Rte_Call_SsaCdd_TrustModel_GetCertificate(KeyM_CertificateIdType CertId, Ssa_DataPtr CertData, Ssa_LengthPtr CertDataLength)
 *     Synchronous Server Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_SsaCdd_KeyM_CertInterface_E_NOT_OK, RTE_E_SsaCdd_KeyM_CertInterface_KEYM_E_KEY_CERT_EMPTY, RTE_E_SsaCdd_KeyM_CertInterface_KEYM_E_KEY_CERT_READ_FAIL, RTE_E_SsaCdd_KeyM_CertInterface_KEYM_E_KEY_CERT_SIZE_MISMATCH, RTE_E_SsaCdd_KeyM_CertInterface_KEYM_E_PARAMETER_MISMATCH
 *
 **********************************************************************************************************************
 *
 * Runnable prototype:
 * ===================
 *   Std_ReturnType Ssa_KeyM_DataServices_DID_019F_Trust_model_certificates_ReadData(Dcm_OpStatusType OpStatus, uint8 *Data)
 *     Argument Data: uint8* is of type Dcm_Data4008ByteType
 *
 **********************************************************************************************************************
 *
 * Available Application Errors:
 * =============================
 *   RTE_E_DataServices_DID_019F_Trust_model_certificates_DCM_E_PENDING
 *   RTE_E_DataServices_DID_019F_Trust_model_certificates_E_NOT_OK
 *
 *********************************************************************************************************************/
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << Start of documentation area >>                  DO NOT CHANGE THIS COMMENT!
 * Symbol: Ssa_KeyM_DataServices_DID_019F_Trust_model_certificates_ReadData_doc
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
/*!
 * \spec
 *    requires $lengthOf(Data) >= sizeof(Dcm_Data4008ByteType);
 * \endspec
 */
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << End of documentation area >>                    DO NOT CHANGE THIS COMMENT!
 *********************************************************************************************************************/

FUNC(Std_ReturnType, Ssa_KeyM_CODE) Ssa_KeyM_DataServices_DID_019F_Trust_model_certificates_ReadData(
  Dcm_OpStatusType OpStatus,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) Data) /* PRQA S 0624, 3206 */ /* MD_Rte_0624, MD_Rte_3206 */
{
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << Start of runnable implementation >>             DO NOT CHANGE THIS COMMENT!
 * Symbol: Ssa_KeyM_DataServices_DID_019F_Trust_model_certificates_ReadData (returns application error)
 *********************************************************************************************************************/

  Std_ReturnType retVal = RTE_E_DataServices_DID_019F_Trust_model_certificates_E_NOT_OK;

  /* ----- Development Error Checks ------------------------------------- */
#if (SSA_DEV_ERROR_DETECT == STD_ON)
  if (Data == NULL_PTR)
  {
    /* retVal already set */
  }
  else
#endif /* SSA_DEV_ERROR_DETECT == STD_ON */
  {
    uint16 dataIdx = 0u;
    uint16 dataLength = sizeof(Dcm_Data4008ByteType);

    /* #10 Append all required certificates: ECU, Intermediate, Backend, Root. */
    retVal = KeyM_KeyM_GetCertificateDataAsIteration(SSA_TRUST_MODEL_ECU_CERT_ID, &Data[dataIdx], &dataLength);
    if (retVal == E_OK)
    {
      dataIdx = dataLength;
      dataLength = (uint16)(sizeof(Dcm_Data4008ByteType) - dataIdx);
      retVal = KeyM_KeyM_GetCertificateDataAsIteration(SSA_TRUST_MODEL_INTERMEDIATE_CERT_ID, &Data[dataIdx], &dataLength);
    }

    if (retVal == E_OK)
    {
      dataIdx += dataLength;
      dataLength = (uint16)(sizeof(Dcm_Data4008ByteType) - dataIdx);
      retVal = KeyM_KeyM_GetCertificateDataAsIteration(SSA_TRUST_MODEL_BACKEND_CERT_ID, &Data[dataIdx], &dataLength);
    }

    if (retVal == E_OK)
    {
      dataIdx += dataLength;
      dataLength = (uint16)(sizeof(Dcm_Data4008ByteType) - dataIdx);
      retVal = KeyM_KeyM_GetCertificateDataAsIteration(SSA_TRUST_MODEL_ROOT_CERT_ID, &Data[dataIdx], &dataLength);
    }

    retVal = (retVal == E_OK) ? RTE_E_OK : RTE_E_DataServices_DID_019F_Trust_model_certificates_E_NOT_OK;
  }
  SSA_DUMMY_STATEMENT(OpStatus);    /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */

  return retVal;
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << End of runnable implementation >>               DO NOT CHANGE THIS COMMENT!
 *********************************************************************************************************************/
}

/**********************************************************************************************************************
 *
 * Runnable Entity Name: Ssa_KeyM_DataServices_DID_019F_Trust_model_certificates_ReadDataLength
 *
 *---------------------------------------------------------------------------------------------------------------------
 *
 * Executed if at least one of the following trigger conditions occurred:
 *   - triggered by server invocation for OperationPrototype <ReadDataLength> of PortPrototype <DataServices_DID_019F_Trust_model_certificates>
 *
 **********************************************************************************************************************
 *
 * Client/Server Interfaces:
 * =========================
 *   Server Invocation:
 *   ------------------
 *   Std_ReturnType Rte_Call_SsaCdd_TrustModel_GetCertificate(KeyM_CertificateIdType CertId, Ssa_DataPtr CertData, Ssa_LengthPtr CertDataLength)
 *     Synchronous Server Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_SsaCdd_KeyM_CertInterface_E_NOT_OK, RTE_E_SsaCdd_KeyM_CertInterface_KEYM_E_KEY_CERT_EMPTY, RTE_E_SsaCdd_KeyM_CertInterface_KEYM_E_KEY_CERT_READ_FAIL, RTE_E_SsaCdd_KeyM_CertInterface_KEYM_E_KEY_CERT_SIZE_MISMATCH, RTE_E_SsaCdd_KeyM_CertInterface_KEYM_E_PARAMETER_MISMATCH
 *
 **********************************************************************************************************************
 *
 * Runnable prototype:
 * ===================
 *   Std_ReturnType Ssa_KeyM_DataServices_DID_019F_Trust_model_certificates_ReadDataLength(Dcm_OpStatusType OpStatus, uint16 *DataLength)
 *
 **********************************************************************************************************************
 *
 * Available Application Errors:
 * =============================
 *   RTE_E_DataServices_DID_019F_Trust_model_certificates_DCM_E_PENDING
 *   RTE_E_DataServices_DID_019F_Trust_model_certificates_E_NOT_OK
 *
 *********************************************************************************************************************/
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << Start of documentation area >>                  DO NOT CHANGE THIS COMMENT!
 * Symbol: Ssa_KeyM_DataServices_DID_019F_Trust_model_certificates_ReadDataLength_doc
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */

/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << End of documentation area >>                    DO NOT CHANGE THIS COMMENT!
 *********************************************************************************************************************/

FUNC(Std_ReturnType, Ssa_KeyM_CODE) Ssa_KeyM_DataServices_DID_019F_Trust_model_certificates_ReadDataLength(
  Dcm_OpStatusType OpStatus,
  P2VAR(uint16, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) DataLength) /* PRQA S 0624, 3206 */ /* MD_Rte_0624, MD_Rte_3206 */
{
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << Start of runnable implementation >>             DO NOT CHANGE THIS COMMENT!
 * Symbol: Ssa_KeyM_DataServices_DID_019F_Trust_model_certificates_ReadDataLength (returns application error)
 *********************************************************************************************************************/
  Std_ReturnType retVal = RTE_E_DataServices_DID_019F_Trust_model_certificates_E_NOT_OK;

  /* ----- Development Error Checks ------------------------------------- */
#if (SSA_DEV_ERROR_DETECT == STD_ON)
  if (DataLength == NULL_PTR)
  {
    /* retVal already set */
  }
  else
#endif /* SSA_DEV_ERROR_DETECT == STD_ON */
  {
    Dcm_Data1002ByteType buffer;
    uint16 bufferLength = sizeof(Dcm_Data1002ByteType);

    /* #10 Append all required certificate lengths: ECU, Intermediate, Backend, Root. */

    retVal = KeyM_KeyM_GetCertificateDataAsIteration(SSA_TRUST_MODEL_ECU_CERT_ID, buffer, &bufferLength);
    if (retVal == E_OK)
    {
      /* increase by data length needed for this certificate */
      *DataLength = bufferLength;
      bufferLength = sizeof(Dcm_Data1002ByteType);
      retVal = KeyM_KeyM_GetCertificateDataAsIteration(SSA_TRUST_MODEL_INTERMEDIATE_CERT_ID, buffer, &bufferLength);
    }

    if (retVal == E_OK)
    {
      /* increase by data length needed for this certificate */
      *DataLength += bufferLength;
      bufferLength = sizeof(Dcm_Data1002ByteType);
      retVal = KeyM_KeyM_GetCertificateDataAsIteration(SSA_TRUST_MODEL_BACKEND_CERT_ID, buffer, &bufferLength);
    }

    if (retVal == E_OK)
    {
      /* increase by data length needed for this certificate */
      *DataLength += bufferLength;
      bufferLength = sizeof(Dcm_Data1002ByteType);
      retVal = KeyM_KeyM_GetCertificateDataAsIteration(SSA_TRUST_MODEL_ROOT_CERT_ID, buffer, &bufferLength);
    }

    if (retVal == E_OK)
    {
      /* increase by data length needed for this certificate */
      *DataLength += bufferLength;
    }

    retVal = (retVal == E_OK) ? RTE_E_OK : RTE_E_DataServices_DID_019F_Trust_model_certificates_E_NOT_OK;
  }
  SSA_DUMMY_STATEMENT(OpStatus);    /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */

  return retVal;
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << End of runnable implementation >>               DO NOT CHANGE THIS COMMENT!
 *********************************************************************************************************************/
}

#if (SSA_ECU_TYPE == SSA_ECU_TYPE_VSM)

/**********************************************************************************************************************
 *
 * Runnable Entity Name: Ssa_KeyM_DataServices_ECU_Certificate_Read_Data_Signature_ConditionCheckRead
 *
 *---------------------------------------------------------------------------------------------------------------------
 *
 * Executed if at least one of the following trigger conditions occurred:
 *   - triggered by server invocation for OperationPrototype <ConditionCheckRead> of PortPrototype <DataServices_ECU_Certificate_Read_Data_Signature>
 *
 **********************************************************************************************************************
 *
 * Runnable prototype:
 * ===================
 *   Std_ReturnType Ssa_KeyM_DataServices_ECU_Certificate_Read_Data_Signature_ConditionCheckRead(Dcm_OpStatusType OpStatus, Dcm_NegativeResponseCodeType *ErrorCode)
 *
 **********************************************************************************************************************
 *
 * Available Application Errors:
 * =============================
 *   RTE_E_DataServices_ECU_Certificate_Read_Data_Signature_DCM_E_PENDING
 *   RTE_E_DataServices_ECU_Certificate_Read_Data_Signature_E_NOT_OK
 *
 *********************************************************************************************************************/
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << Start of documentation area >>                  DO NOT CHANGE THIS COMMENT!
 * Symbol: Ssa_KeyM_DataServices_ECU_Certificate_Read_Data_Signature_ConditionCheckRead_doc
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */

/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << End of documentation area >>                    DO NOT CHANGE THIS COMMENT!
 *********************************************************************************************************************/

FUNC(Std_ReturnType, Ssa_KeyM_CODE) Ssa_KeyM_DataServices_ECU_Certificate_Read_Data_Signature_ConditionCheckRead(
  Dcm_OpStatusType OpStatus,
  P2VAR(Dcm_NegativeResponseCodeType, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) ErrorCode) /* PRQA S 0624, 3206 */ /* MD_Rte_0624, MD_Rte_3206 */
{
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << Start of runnable implementation >>             DO NOT CHANGE THIS COMMENT!
 * Symbol: Ssa_KeyM_DataServices_ECU_Certificate_Read_Data_Signature_ConditionCheckRead (returns application error)
 *********************************************************************************************************************/

  Std_ReturnType retVal = RTE_E_DataServices_ECU_Certificate_Read_Data_Signature_E_NOT_OK;

  /* ----- Development Error Checks ------------------------------------- */
# if (SSA_DEV_ERROR_DETECT == STD_ON)
  if (ErrorCode == NULL_PTR)
  {
    /* retVal already set */
  }
  else
# endif /* SSA_DEV_ERROR_DETECT == STD_ON */
  {

    /* #10 Always successfully return from condition check. */
    *ErrorCode = DCM_E_POSITIVERESPONSE;
    retVal = RTE_E_OK;
  }
  SSA_DUMMY_STATEMENT(OpStatus);    /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */
  return retVal;

/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << End of runnable implementation >>               DO NOT CHANGE THIS COMMENT!
 *********************************************************************************************************************/
}

/**********************************************************************************************************************
 *
 * Runnable Entity Name: Ssa_KeyM_DataServices_ECU_Certificate_Read_Data_Signature_ReadData
 *
 *---------------------------------------------------------------------------------------------------------------------
 *
 * Executed if at least one of the following trigger conditions occurred:
 *   - triggered by server invocation for OperationPrototype <ReadData> of PortPrototype <DataServices_ECU_Certificate_Read_Data_Signature>
 *
 **********************************************************************************************************************
 *
 * Client/Server Interfaces:
 * =========================
 *   Server Invocation:
 *   ------------------
 *   Std_ReturnType Rte_Call_RightsM_Nonce_Get(boolean generateNew, uint8 *nonce)
 *     Argument nonce: uint8* is of type Dcm_Data32ByteType
 *     Synchronous Server Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_RightsM_Nonce_E_INVALID, RTE_E_RightsM_Nonce_E_NOT_OK, RTE_E_RightsM_Nonce_E_PENDING
 *   Std_ReturnType Rte_Call_SsaCdd_Csm_SignatureGenerate(uint32 jobId, Crypto_OperationModeType operationMode, Ssa_ConstDataPtr dataBuffer, uint32 dataLength, Ssa_DataPtr resultBuffer, Ssa_LengthPtr resultLength)
 *     Synchronous Server Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_SsaCdd_CryptoInterface_E_NOT_OK
 *
 * Service Calls:
 * ==============
 *   Service Invocation:
 *   -------------------
 *   Std_ReturnType Rte_Call_Key_SharedSecretKeyExchange_KeyElementGet(uint32 keyElementId, uint8 *keyPtr, uint32 *keyLength)
 *     Argument keyPtr: uint8* is of type Csm_KeyDataType_Ssa_SharedSecretKeyExchange
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_CsmKeyManagement_Ssa_SharedSecretKeyExchange_CSM_E_BUSY, RTE_E_CsmKeyManagement_Ssa_SharedSecretKeyExchange_CSM_E_KEY_EMPTY, RTE_E_CsmKeyManagement_Ssa_SharedSecretKeyExchange_CSM_E_KEY_NOT_AVAILABLE, RTE_E_CsmKeyManagement_Ssa_SharedSecretKeyExchange_CSM_E_KEY_READ_FAIL, RTE_E_CsmKeyManagement_Ssa_SharedSecretKeyExchange_CSM_E_SMALL_BUFFER, RTE_E_CsmKeyManagement_Ssa_SharedSecretKeyExchange_E_NOT_OK
 *
 **********************************************************************************************************************
 *
 * Runnable prototype:
 * ===================
 *   Std_ReturnType Ssa_KeyM_DataServices_ECU_Certificate_Read_Data_Signature_ReadData(Dcm_OpStatusType OpStatus, uint8 *Data)
 *     Argument Data: uint8* is of type Dcm_Data64ByteType
 *
 **********************************************************************************************************************
 *
 * Available Application Errors:
 * =============================
 *   RTE_E_DataServices_ECU_Certificate_Read_Data_Signature_DCM_E_PENDING
 *   RTE_E_DataServices_ECU_Certificate_Read_Data_Signature_E_NOT_OK
 *
 *********************************************************************************************************************/
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << Start of documentation area >>                  DO NOT CHANGE THIS COMMENT!
 * Symbol: Ssa_KeyM_DataServices_ECU_Certificate_Read_Data_Signature_ReadData_doc
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 */
/*!
 * \spec
 *    requires $lengthOf(Data) >= sizeof(Dcm_Data64ByteType);
 * \endspec
 */
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << End of documentation area >>                    DO NOT CHANGE THIS COMMENT!
 *********************************************************************************************************************/

FUNC(Std_ReturnType, Ssa_KeyM_CODE) Ssa_KeyM_DataServices_ECU_Certificate_Read_Data_Signature_ReadData(
  Dcm_OpStatusType OpStatus,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) Data) /* PRQA S 0624, 3206 */ /* MD_Rte_0624, MD_Rte_3206 */
{
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << Start of runnable implementation >>             DO NOT CHANGE THIS COMMENT!
 * Symbol: Ssa_KeyM_DataServices_ECU_Certificate_Read_Data_Signature_ReadData (returns application error)
 *********************************************************************************************************************/

  Std_ReturnType retVal = RTE_E_DataServices_ECU_Certificate_Read_Data_Signature_E_NOT_OK;

  /* ----- Development Error Checks ------------------------------------- */
# if (SSA_DEV_ERROR_DETECT == STD_ON)
  if (Data == NULL_PTR)
  {
    /* retVal already set */
  }
  else
# endif /* SSA_DEV_ERROR_DETECT == STD_ON */
  {
    /* #10 Check operation status. Only "pending" and "initial" is allowed. */
    if ((OpStatus == DCM_PENDING) || (OpStatus == DCM_INITIAL))
    {
      /* #20 If the function is in state IDLE get nonce that already has been generated. A new nonce must not be generated. */
      if (KeyM_DiagProc.state == KEYM_GEN_SIG_STATE_IDLE)
      {
        retVal = Rte_Call_RightsM_Nonce_Get(FALSE, &KeyM_DiagProc.ws.ecuCertificateReadData.genSigDataBufferIn[0]);
        if (retVal != E_OK)
        {
          retVal = RTE_E_DataServices_ECU_Certificate_Read_Data_Signature_E_NOT_OK;
        }
        else
        {
          uint32 ePubKeyOwnLength = SSA_SIZEOF_PUBLICKEY;

          /* #30 Get own ephemeral public key that already has been calculated. */
          retVal = Rte_Call_Key_SharedSecretKeyExchange_KeyElementGet(SSA_KE_KEYEXCHANGE_OWNPUBKEY, &KeyM_DiagProc.ws.ecuCertificateReadData.genSigDataBufferIn[SSA_SIZEOF_NONCE], &ePubKeyOwnLength);
          if ((retVal != E_OK) || (ePubKeyOwnLength != SSA_SIZEOF_PUBLICKEY))
          {
            retVal = RTE_E_DataServices_ECU_Certificate_Read_Data_Signature_E_NOT_OK;
          }
          else
          {
            KeyM_DiagProc.state = KEYM_GEN_SIG_STATE_GENERATE;
          }
        }
      }

      /* #40 If the function is in state GENERATE start resp. check the Csm signature generation from nonce and ephemeral public key. */
      if (KeyM_DiagProc.state == KEYM_GEN_SIG_STATE_GENERATE)
      {
        retVal = KeyM_CsmSignatureGenerate(
          SSA_DIAGNOSTIC_KEY_PAIR,
          KeyM_DiagProc.ws.ecuCertificateReadData.genSigDataBufferIn,
          SSA_SIZEOF_NONCE + SSA_SIZEOF_PUBLICKEY,
          KeyM_DiagProc.ws.ecuCertificateReadData.genSigDataBufferOut
        );

        if (retVal == SSA_E_PENDING)
        {
          retVal = RTE_E_DataServices_ECU_Certificate_Read_Data_Signature_DCM_E_PENDING;
        }
        else if (retVal == E_OK)
        {
          /* #50 Copy the generated signature to the output buffer. */
          Ssa_MemCpy(Data, KeyM_DiagProc.ws.ecuCertificateReadData.genSigDataBufferOut, SSA_SIZEOF_SIGNATURE);
          /* Reset the function's internal state. */
          KeyM_DiagProc.state = KEYM_GEN_SIG_STATE_IDLE;
        }
        else
        {
          /* Clear output data. */
          KeyM_ClearDataBuffer(Data, sizeof(Dcm_Data64ByteType), SSA_SIZEOF_SIGNATURE);
          /* Reset the function's internal state. */
          KeyM_DiagProc.state = KEYM_GEN_SIG_STATE_IDLE;
        }
      }

      /* #60 If the service is finished clear the buffer containing sensitive data. */
      if (retVal != RTE_E_DataServices_ECU_Certificate_Read_Data_Signature_DCM_E_PENDING)
      {
        KeyM_ClearDataBuffer(KeyM_DiagProc.ws.ecuCertificateReadData.genSigDataBufferIn, SSA_SIZEOF_NONCE + SSA_SIZEOF_PUBLICKEY, SSA_SIZEOF_NONCE + SSA_SIZEOF_PUBLICKEY);
      }
    }
  }

  return retVal;

  /* PRQA S 6080 4 */ /* MD_MSR_STMIF */
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << End of runnable implementation >>               DO NOT CHANGE THIS COMMENT!
 *********************************************************************************************************************/
}

/**********************************************************************************************************************
 *
 * Runnable Entity Name: Ssa_KeyM_DataServices_ECU_Certificate_Read_ECU_Certificate_ConditionCheckRead
 *
 *---------------------------------------------------------------------------------------------------------------------
 *
 * Executed if at least one of the following trigger conditions occurred:
 *   - triggered by server invocation for OperationPrototype <ConditionCheckRead> of PortPrototype <DataServices_ECU_Certificate_Read_ECU_Certificate>
 *
 **********************************************************************************************************************
 *
 * Runnable prototype:
 * ===================
 *   Std_ReturnType Ssa_KeyM_DataServices_ECU_Certificate_Read_ECU_Certificate_ConditionCheckRead(Dcm_OpStatusType OpStatus, Dcm_NegativeResponseCodeType *ErrorCode)
 *
 **********************************************************************************************************************
 *
 * Available Application Errors:
 * =============================
 *   RTE_E_DataServices_ECU_Certificate_Read_ECU_Certificate_DCM_E_PENDING
 *   RTE_E_DataServices_ECU_Certificate_Read_ECU_Certificate_E_NOT_OK
 *
 *********************************************************************************************************************/
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << Start of documentation area >>                  DO NOT CHANGE THIS COMMENT!
 * Symbol: Ssa_KeyM_DataServices_ECU_Certificate_Read_ECU_Certificate_ConditionCheckRead_doc
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */

/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << End of documentation area >>                    DO NOT CHANGE THIS COMMENT!
 *********************************************************************************************************************/

FUNC(Std_ReturnType, Ssa_KeyM_CODE) Ssa_KeyM_DataServices_ECU_Certificate_Read_ECU_Certificate_ConditionCheckRead(
  Dcm_OpStatusType OpStatus,
  P2VAR(Dcm_NegativeResponseCodeType, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) ErrorCode) /* PRQA S 0624, 3206 */ /* MD_Rte_0624, MD_Rte_3206 */
{
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << Start of runnable implementation >>             DO NOT CHANGE THIS COMMENT!
 * Symbol: Ssa_KeyM_DataServices_ECU_Certificate_Read_ECU_Certificate_ConditionCheckRead (returns application error)
 *********************************************************************************************************************/

  Std_ReturnType retVal = RTE_E_DataServices_ECU_Certificate_Read_ECU_Certificate_E_NOT_OK;

  /* ----- Development Error Checks ------------------------------------- */
# if (SSA_DEV_ERROR_DETECT == STD_ON)
  if (ErrorCode == NULL_PTR)
  {
    /* retVal already set */
  }
  else
# endif /* SSA_DEV_ERROR_DETECT == STD_ON */
  {
    /* #10 Always successfully return from condition check. */
    *ErrorCode = DCM_E_POSITIVERESPONSE;
    retVal = RTE_E_OK;
  }
  SSA_DUMMY_STATEMENT(OpStatus);    /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */

  return retVal;

/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << End of runnable implementation >>               DO NOT CHANGE THIS COMMENT!
 *********************************************************************************************************************/
}

/**********************************************************************************************************************
 *
 * Runnable Entity Name: Ssa_KeyM_DataServices_ECU_Certificate_Read_ECU_Certificate_ReadData
 *
 *---------------------------------------------------------------------------------------------------------------------
 *
 * Executed if at least one of the following trigger conditions occurred:
 *   - triggered by server invocation for OperationPrototype <ReadData> of PortPrototype <DataServices_ECU_Certificate_Read_ECU_Certificate>
 *
 **********************************************************************************************************************
 *
 * Client/Server Interfaces:
 * =========================
 *   Server Invocation:
 *   ------------------
 *   Std_ReturnType Rte_Call_CertP_Functions_Certificate_Parse(const uint8 *rawCertData, uint16 rawCertLength, CertP_ParsedCertStructureType *parsedCert)
 *     Argument rawCertData: uint8* is of type CertP_RawCertBufferType
 *     Synchronous Server Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_CertP_Functions_E_NOT_OK
 *
 * Service Calls:
 * ==============
 *   Service Invocation:
 *   -------------------
 *   Std_ReturnType Rte_Call_Key_EcuCert_KeyElementGet(uint32 keyElementId, uint8 *keyPtr, uint32 *keyLength)
 *     Argument keyPtr: uint8* is of type Csm_KeyDataType_Ssa_EcuCert
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_CsmKeyManagement_Ssa_EcuCert_CSM_E_BUSY, RTE_E_CsmKeyManagement_Ssa_EcuCert_CSM_E_KEY_EMPTY, RTE_E_CsmKeyManagement_Ssa_EcuCert_CSM_E_KEY_NOT_AVAILABLE, RTE_E_CsmKeyManagement_Ssa_EcuCert_CSM_E_KEY_READ_FAIL, RTE_E_CsmKeyManagement_Ssa_EcuCert_CSM_E_SMALL_BUFFER, RTE_E_CsmKeyManagement_Ssa_EcuCert_E_NOT_OK
 *
 **********************************************************************************************************************
 *
 * Runnable prototype:
 * ===================
 *   Std_ReturnType Ssa_KeyM_DataServices_ECU_Certificate_Read_ECU_Certificate_ReadData(Dcm_OpStatusType OpStatus, uint8 *Data)
 *     Argument Data: uint8* is of type Dcm_Data1002ByteType
 *
 **********************************************************************************************************************
 *
 * Available Application Errors:
 * =============================
 *   RTE_E_DataServices_ECU_Certificate_Read_ECU_Certificate_DCM_E_PENDING
 *   RTE_E_DataServices_ECU_Certificate_Read_ECU_Certificate_E_NOT_OK
 *
 *********************************************************************************************************************/
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << Start of documentation area >>                  DO NOT CHANGE THIS COMMENT!
 * Symbol: Ssa_KeyM_DataServices_ECU_Certificate_Read_ECU_Certificate_ReadData_doc
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
/*!
 * \spec
 *    requires $lengthOf(Data) >= sizeof(Dcm_Data1002ByteType);
 * \endspec
 */
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << End of documentation area >>                    DO NOT CHANGE THIS COMMENT!
 *********************************************************************************************************************/

FUNC(Std_ReturnType, Ssa_KeyM_CODE) Ssa_KeyM_DataServices_ECU_Certificate_Read_ECU_Certificate_ReadData(
  Dcm_OpStatusType OpStatus,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) Data) /* PRQA S 0624, 3206 */ /* MD_Rte_0624, MD_Rte_3206 */
{
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << Start of runnable implementation >>             DO NOT CHANGE THIS COMMENT!
 * Symbol: Ssa_KeyM_DataServices_ECU_Certificate_Read_ECU_Certificate_ReadData (returns application error)
 *********************************************************************************************************************/

  Std_ReturnType rVal = RTE_E_DataServices_ECU_Certificate_Read_ECU_Certificate_E_NOT_OK;

  /* ----- Development Error Checks ------------------------------------- */
# if (SSA_DEV_ERROR_DETECT == STD_ON)
  if (Data == NULL_PTR)
  {
    /* retVal already set */
  }
  else
# endif /* SSA_DEV_ERROR_DETECT == STD_ON */
  {
    uint16 certLength = SSA_SIZEOF_CERT_MAX;

    /* #10 Get the stored, parsed ECU certificate and copy the certificate data to the output buffer. */
    rVal = KeyM_GetAndParseStoredCert(CERTP_PKI_ROLE_ECU, &Data[2], (P2VAR(uint16, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR))&certLength, FALSE);

    if (rVal == E_OK)
    {
      Data[0] = KeyM_GetUint16HiByte(certLength);
      Data[1] = KeyM_GetUint16LoByte(certLength);
    }
    else
    {
      Data[0] = 0u;
      Data[1] = 0u;
      rVal = RTE_E_DataServices_ECU_Certificate_Read_ECU_Certificate_E_NOT_OK;
    }
  }
  SSA_DUMMY_STATEMENT(OpStatus);    /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */

  return rVal;

/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << End of runnable implementation >>               DO NOT CHANGE THIS COMMENT!
 *********************************************************************************************************************/
}

/**********************************************************************************************************************
 *
 * Runnable Entity Name: Ssa_KeyM_DataServices_ECU_Certificate_Read_ECU_Certificate_ReadDataLength
 *
 *---------------------------------------------------------------------------------------------------------------------
 *
 * Executed if at least one of the following trigger conditions occurred:
 *   - triggered by server invocation for OperationPrototype <ReadDataLength> of PortPrototype <DataServices_ECU_Certificate_Read_ECU_Certificate>
 *
 **********************************************************************************************************************
 *
 * Client/Server Interfaces:
 * =========================
 *   Server Invocation:
 *   ------------------
 *   Std_ReturnType Rte_Call_CertP_Functions_Certificate_Parse(const uint8 *rawCertData, uint16 rawCertLength, CertP_ParsedCertStructureType *parsedCert)
 *     Argument rawCertData: uint8* is of type CertP_RawCertBufferType
 *     Synchronous Server Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_CertP_Functions_E_NOT_OK
 *
 * Service Calls:
 * ==============
 *   Service Invocation:
 *   -------------------
 *   Std_ReturnType Rte_Call_Key_EcuCert_KeyElementGet(uint32 keyElementId, uint8 *keyPtr, uint32 *keyLength)
 *     Argument keyPtr: uint8* is of type Csm_KeyDataType_Ssa_EcuCert
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_CsmKeyManagement_Ssa_EcuCert_CSM_E_BUSY, RTE_E_CsmKeyManagement_Ssa_EcuCert_CSM_E_KEY_EMPTY, RTE_E_CsmKeyManagement_Ssa_EcuCert_CSM_E_KEY_NOT_AVAILABLE, RTE_E_CsmKeyManagement_Ssa_EcuCert_CSM_E_KEY_READ_FAIL, RTE_E_CsmKeyManagement_Ssa_EcuCert_CSM_E_SMALL_BUFFER, RTE_E_CsmKeyManagement_Ssa_EcuCert_E_NOT_OK
 *
 **********************************************************************************************************************
 *
 * Runnable prototype:
 * ===================
 *   Std_ReturnType Ssa_KeyM_DataServices_ECU_Certificate_Read_ECU_Certificate_ReadDataLength(Dcm_OpStatusType OpStatus, uint16 *DataLength)
 *
 **********************************************************************************************************************
 *
 * Available Application Errors:
 * =============================
 *   RTE_E_DataServices_ECU_Certificate_Read_ECU_Certificate_DCM_E_PENDING
 *   RTE_E_DataServices_ECU_Certificate_Read_ECU_Certificate_E_NOT_OK
 *
 *********************************************************************************************************************/
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << Start of documentation area >>                  DO NOT CHANGE THIS COMMENT!
 * Symbol: Ssa_KeyM_DataServices_ECU_Certificate_Read_ECU_Certificate_ReadDataLength_doc
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 */

/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << End of documentation area >>                    DO NOT CHANGE THIS COMMENT!
 *********************************************************************************************************************/

FUNC(Std_ReturnType, Ssa_KeyM_CODE) Ssa_KeyM_DataServices_ECU_Certificate_Read_ECU_Certificate_ReadDataLength(
  Dcm_OpStatusType OpStatus,
  P2VAR(uint16, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) DataLength) /* PRQA S 0624, 3206 */ /* MD_Rte_0624, MD_Rte_3206 */
{
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << Start of runnable implementation >>             DO NOT CHANGE THIS COMMENT!
 * Symbol: Ssa_KeyM_DataServices_ECU_Certificate_Read_ECU_Certificate_ReadDataLength (returns application error)
 *********************************************************************************************************************/
  Std_ReturnType rVal = RTE_E_DataServices_ECU_Certificate_Read_ECU_Certificate_E_NOT_OK;

  /* ----- Development Error Checks ------------------------------------- */
# if (SSA_DEV_ERROR_DETECT == STD_ON)
  if (DataLength == NULL_PTR)
  {
    /* retVal already set */
  }
  else
# endif /* SSA_DEV_ERROR_DETECT == STD_ON */
  {
# if (SSA_KEEP_BUFFER_VARIABLES_STATIC == STD_OFF)
    uint8 KeyM_EcuCertBuf[SSA_SIZEOF_CERT_MAX];
# endif
    uint16 ecuCertLength = SSA_SIZEOF_CERT_MAX;

    /* #10 Get the stored, parsed ECU certificate. */
    rVal = KeyM_GetAndParseStoredCert(CERTP_PKI_ROLE_ECU, (P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR))KeyM_EcuCertBuf, (P2VAR(uint16, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR))&ecuCertLength, FALSE);

    if (rVal == E_OK)
    {
      /* #20 Write the length of the ECU certificate increased by 2 (length information) to the output buffer. */
      *DataLength = ecuCertLength + 2u;
    }
    else
    {
      *DataLength = 0u;
      rVal = RTE_E_DataServices_ECU_Certificate_Read_ECU_Certificate_E_NOT_OK;
    }
  }
  SSA_DUMMY_STATEMENT(OpStatus);    /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */

  return rVal;

/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << End of runnable implementation >>               DO NOT CHANGE THIS COMMENT!
 *********************************************************************************************************************/
}

/**********************************************************************************************************************
 *
 * Runnable Entity Name: Ssa_KeyM_DataServices_ECU_Certificate_Read_Ephemeral_ECU_Public_Key_ConditionCheckRead
 *
 *---------------------------------------------------------------------------------------------------------------------
 *
 * Executed if at least one of the following trigger conditions occurred:
 *   - triggered by server invocation for OperationPrototype <ConditionCheckRead> of PortPrototype <DataServices_ECU_Certificate_Read_Ephemeral_ECU_Public_Key>
 *
 **********************************************************************************************************************
 *
 * Runnable prototype:
 * ===================
 *   Std_ReturnType Ssa_KeyM_DataServices_ECU_Certificate_Read_Ephemeral_ECU_Public_Key_ConditionCheckRead(Dcm_OpStatusType OpStatus, Dcm_NegativeResponseCodeType *ErrorCode)
 *
 **********************************************************************************************************************
 *
 * Available Application Errors:
 * =============================
 *   RTE_E_DataServices_ECU_Certificate_Read_Ephemeral_ECU_Public_Key_DCM_E_PENDING
 *   RTE_E_DataServices_ECU_Certificate_Read_Ephemeral_ECU_Public_Key_E_NOT_OK
 *
 *********************************************************************************************************************/
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << Start of documentation area >>                  DO NOT CHANGE THIS COMMENT!
 * Symbol: Ssa_KeyM_DataServices_ECU_Certificate_Read_Ephemeral_ECU_Public_Key_ConditionCheckRead_doc
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */

/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << End of documentation area >>                    DO NOT CHANGE THIS COMMENT!
 *********************************************************************************************************************/

FUNC(Std_ReturnType, Ssa_KeyM_CODE) Ssa_KeyM_DataServices_ECU_Certificate_Read_Ephemeral_ECU_Public_Key_ConditionCheckRead(
  Dcm_OpStatusType OpStatus,
  P2VAR(Dcm_NegativeResponseCodeType, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) ErrorCode) /* PRQA S 0624, 3206 */ /* MD_Rte_0624, MD_Rte_3206 */
{
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << Start of runnable implementation >>             DO NOT CHANGE THIS COMMENT!
 * Symbol: Ssa_KeyM_DataServices_ECU_Certificate_Read_Ephemeral_ECU_Public_Key_ConditionCheckRead (returns application error)
 *********************************************************************************************************************/
  Std_ReturnType retVal = RTE_E_DataServices_ECU_Certificate_Read_Ephemeral_ECU_Public_Key_E_NOT_OK;

  /* ----- Development Error Checks ------------------------------------- */
# if (SSA_DEV_ERROR_DETECT == STD_ON)
  if (ErrorCode == NULL_PTR)
  {
    /* retVal already set */
  }
  else
# endif /* SSA_DEV_ERROR_DETECT == STD_ON */
  {
    /* #10 Call callout function for preparing the key exchange as long as it returns E_PENDING. */
    switch (OpStatus)
    {
      case DCM_INITIAL:
        retVal = Rte_Call_Ssa_KeyProc_PrepareKeyExchange(SSA_OPSTATUS_INITIAL, SSA_KEYM_CSM_KEY_EXCHANGE_KEY);
        break;
      case DCM_PENDING:
        retVal = Rte_Call_Ssa_KeyProc_PrepareKeyExchange(SSA_OPSTATUS_CHECKSTATE, SSA_KEYM_CSM_KEY_EXCHANGE_KEY);
        break;
      default:
        retVal = Rte_Call_Ssa_KeyProc_PrepareKeyExchange(SSA_OPSTATUS_CANCEL, SSA_KEYM_CSM_KEY_EXCHANGE_KEY);
        break;
    }

    /* PRQA S 2880 L1 */ /* MD_SSA_UNREACHABLE_CODE */
    /* PRQA S 2995, 2996 L2 */ /* MD_SSA_BOOLEXPR_ALWAYS_TRUE_OR_ALWAYS_FALSE  */
    /* PRQA S 2991, 2992 L3 */ /* MD_SSA_CTRLEXPR_ALWAYS_TRUE_OR_ALWAYS_FALSE */
    if (retVal == RTE_E_Ssa_KeyProc_E_PENDING)
    {
      retVal = RTE_E_DataServices_ECU_Certificate_Read_Ephemeral_ECU_Public_Key_DCM_E_PENDING;
    }
    else if ((retVal == RTE_E_OK) || (retVal == RTE_E_UNCONNECTED))
    {
      retVal = RTE_E_OK;
      *ErrorCode = DCM_E_POSITIVERESPONSE;
    }
    else
    {
      retVal = RTE_E_DataServices_ECU_Certificate_Read_Ephemeral_ECU_Public_Key_E_NOT_OK;
      *ErrorCode = DCM_E_GENERALREJECT;
    }
    /* PRQA L:L3 */
    /* PRQA L:L2 */
    /* PRQA L:L1 */
  }
  return retVal;

/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << End of runnable implementation >>               DO NOT CHANGE THIS COMMENT!
 *********************************************************************************************************************/
}

/**********************************************************************************************************************
 *
 * Runnable Entity Name: Ssa_KeyM_DataServices_ECU_Certificate_Read_Ephemeral_ECU_Public_Key_ReadData
 *
 *---------------------------------------------------------------------------------------------------------------------
 *
 * Executed if at least one of the following trigger conditions occurred:
 *   - triggered by server invocation for OperationPrototype <ReadData> of PortPrototype <DataServices_ECU_Certificate_Read_Ephemeral_ECU_Public_Key>
 *
 **********************************************************************************************************************
 *
 * Client/Server Interfaces:
 * =========================
 *   Server Invocation:
 *   ------------------
 *   Std_ReturnType Rte_Call_Ssa_KeyProc_PrepareKeyExchange(Ssa_OpStatusType opStatus, uint32 keyId)
 *     Synchronous Server Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_Ssa_KeyProc_E_NOT_OK, RTE_E_Ssa_KeyProc_E_PENDING
 *
 * Service Calls:
 * ==============
 *   Service Invocation:
 *   -------------------
 *   Std_ReturnType Rte_Call_CsmJobKeyExchangeCalcPubVal_KeyExchangeCalcPubVal(uint32 key, Csm_DataPtr publicValuePtr, Csm_LengthPtr publicValueLengthPtr)
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_CsmJobKeyExchangeCalcPubVal_CSM_E_BUSY, RTE_E_CsmJobKeyExchangeCalcPubVal_CSM_E_KEY_EMPTY, RTE_E_CsmJobKeyExchangeCalcPubVal_CSM_E_SMALL_BUFFER, RTE_E_CsmJobKeyExchangeCalcPubVal_E_NOT_OK
 *   Std_ReturnType Rte_Call_Key_SharedSecretKeyExchange_KeyElementSet(uint32 keyElementId, const uint8 *keyPtr, uint32 keyLength)
 *     Argument keyPtr: uint8* is of type Csm_KeyDataType_Ssa_SharedSecretKeyExchange
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_CsmKeyManagement_Ssa_SharedSecretKeyExchange_CSM_E_BUSY, RTE_E_CsmKeyManagement_Ssa_SharedSecretKeyExchange_CSM_E_KEY_NOT_AVAILABLE, RTE_E_CsmKeyManagement_Ssa_SharedSecretKeyExchange_CSM_E_KEY_SIZE_MISMATCH, RTE_E_CsmKeyManagement_Ssa_SharedSecretKeyExchange_CSM_E_KEY_WRITE_FAIL, RTE_E_CsmKeyManagement_Ssa_SharedSecretKeyExchange_CSM_E_SMALL_BUFFER, RTE_E_CsmKeyManagement_Ssa_SharedSecretKeyExchange_E_NOT_OK
 *   Std_ReturnType Rte_Call_Key_SharedSecretKeyExchange_KeyExchangeCalcPubVal(uint8 *publicValuePtr, uint32 *publicValueLengthPtr)
 *     Argument publicValuePtr: uint8* is of type Csm_PublicValueDataType_Ssa_SharedSecretKeyExchange
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_CsmKeyManagement_Ssa_SharedSecretKeyExchange_CSM_E_BUSY, RTE_E_CsmKeyManagement_Ssa_SharedSecretKeyExchange_CSM_E_KEY_EMPTY, RTE_E_CsmKeyManagement_Ssa_SharedSecretKeyExchange_CSM_E_SMALL_BUFFER, RTE_E_CsmKeyManagement_Ssa_SharedSecretKeyExchange_E_NOT_OK
 *   Std_ReturnType Rte_Call_Key_SharedSecretKeyExchange_KeySetValid(void)
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_CsmKeyManagement_Ssa_SharedSecretKeyExchange_CSM_E_BUSY, RTE_E_CsmKeyManagement_Ssa_SharedSecretKeyExchange_E_NOT_OK
 *
 **********************************************************************************************************************
 *
 * Runnable prototype:
 * ===================
 *   Std_ReturnType Ssa_KeyM_DataServices_ECU_Certificate_Read_Ephemeral_ECU_Public_Key_ReadData(Dcm_OpStatusType OpStatus, uint8 *Data)
 *     Argument Data: uint8* is of type Dcm_Data32ByteType
 *
 **********************************************************************************************************************
 *
 * Available Application Errors:
 * =============================
 *   RTE_E_DataServices_ECU_Certificate_Read_Ephemeral_ECU_Public_Key_DCM_E_PENDING
 *   RTE_E_DataServices_ECU_Certificate_Read_Ephemeral_ECU_Public_Key_E_NOT_OK
 *
 *********************************************************************************************************************/
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << Start of documentation area >>                  DO NOT CHANGE THIS COMMENT!
 * Symbol: Ssa_KeyM_DataServices_ECU_Certificate_Read_Ephemeral_ECU_Public_Key_ReadData_doc
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
/*!
 * \spec
 *    requires $lengthOf(Data) >= sizeof(Dcm_Data32ByteType);
 * \endspec
 */
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << End of documentation area >>                    DO NOT CHANGE THIS COMMENT!
 *********************************************************************************************************************/

FUNC(Std_ReturnType, Ssa_KeyM_CODE) Ssa_KeyM_DataServices_ECU_Certificate_Read_Ephemeral_ECU_Public_Key_ReadData(
  Dcm_OpStatusType OpStatus,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) Data) /* PRQA S 0624, 3206 */ /* MD_Rte_0624, MD_Rte_3206 */
{
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << Start of runnable implementation >>             DO NOT CHANGE THIS COMMENT!
 * Symbol: Ssa_KeyM_DataServices_ECU_Certificate_Read_Ephemeral_ECU_Public_Key_ReadData (returns application error)
 *********************************************************************************************************************/

  Std_ReturnType retVal = RTE_E_DataServices_ECU_Certificate_Read_Ephemeral_ECU_Public_Key_E_NOT_OK;

  /* ----- Development Error Checks ------------------------------------- */
# if (SSA_DEV_ERROR_DETECT == STD_ON)
  if (Data == NULL_PTR)
  {
    /* retVal already set */
  }
  else
# endif /* SSA_DEV_ERROR_DETECT == STD_ON */
  {
    /* #10 Calculate the ephemeral public key and copy it to the output buffer. */

    if ((OpStatus == DCM_PENDING) || (OpStatus == DCM_INITIAL))
    {
      retVal = KeyM_CsmKeyExchangeCalcPubVal(Data);

      if (retVal == SSA_E_PENDING)
      {
        retVal = RTE_E_DataServices_ECU_Certificate_Read_Ephemeral_ECU_Public_Key_DCM_E_PENDING;
      }
      else if (retVal == E_OK)
      {
        retVal = Rte_Call_Key_SharedSecretKeyExchange_KeyElementSet(SSA_KE_KEYEXCHANGE_OWNPUBKEY, Data, SSA_SIZEOF_PUBLICKEY);
        retVal |= Rte_Call_Key_SharedSecretKeyExchange_KeySetValid();
        if (retVal != RTE_E_OK)
        {
          retVal = RTE_E_DataServices_ECU_Certificate_Read_Ephemeral_ECU_Public_Key_E_NOT_OK;
        }
      }
      else
      {
        retVal = RTE_E_DataServices_ECU_Certificate_Read_Ephemeral_ECU_Public_Key_E_NOT_OK;
      }
    }

    if (retVal == RTE_E_DataServices_ECU_Certificate_Read_Ephemeral_ECU_Public_Key_E_NOT_OK)
    {
      /* Clear output data. */
      KeyM_ClearDataBuffer(Data, sizeof(Dcm_Data32ByteType), SSA_SIZEOF_PUBLICKEY);
    }
  }
  return retVal;
  /* PRQA S 6080 4 */ /* MD_MSR_STMIF */
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << End of runnable implementation >>               DO NOT CHANGE THIS COMMENT!
 *********************************************************************************************************************/
}

/**********************************************************************************************************************
 *
 * Runnable Entity Name: Ssa_KeyM_DataServices_ECU_Certificate_Read_Nonce_ConditionCheckRead
 *
 *---------------------------------------------------------------------------------------------------------------------
 *
 * Executed if at least one of the following trigger conditions occurred:
 *   - triggered by server invocation for OperationPrototype <ConditionCheckRead> of PortPrototype <DataServices_ECU_Certificate_Read_Nonce>
 *
 **********************************************************************************************************************
 *
 * Client/Server Interfaces:
 * =========================
 *   Server Invocation:
 *   ------------------
 *   Std_ReturnType Rte_Call_RightsM_Nonce_Get(boolean generateNew, uint8 *nonce)
 *     Argument nonce: uint8* is of type Dcm_Data32ByteType
 *     Synchronous Server Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_RightsM_Nonce_E_INVALID, RTE_E_RightsM_Nonce_E_NOT_OK, RTE_E_RightsM_Nonce_E_PENDING
 *
 **********************************************************************************************************************
 *
 * Runnable prototype:
 * ===================
 *   Std_ReturnType Ssa_KeyM_DataServices_ECU_Certificate_Read_Nonce_ConditionCheckRead(Dcm_OpStatusType OpStatus, Dcm_NegativeResponseCodeType *ErrorCode)
 *
 **********************************************************************************************************************
 *
 * Available Application Errors:
 * =============================
 *   RTE_E_DataServices_ECU_Certificate_Read_Nonce_DCM_E_PENDING
 *   RTE_E_DataServices_ECU_Certificate_Read_Nonce_E_NOT_OK
 *
 *********************************************************************************************************************/
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << Start of documentation area >>                  DO NOT CHANGE THIS COMMENT!
 * Symbol: Ssa_KeyM_DataServices_ECU_Certificate_Read_Nonce_ConditionCheckRead_doc
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */

/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << End of documentation area >>                    DO NOT CHANGE THIS COMMENT!
 *********************************************************************************************************************/

FUNC(Std_ReturnType, Ssa_KeyM_CODE) Ssa_KeyM_DataServices_ECU_Certificate_Read_Nonce_ConditionCheckRead(
  Dcm_OpStatusType OpStatus,
  P2VAR(Dcm_NegativeResponseCodeType, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) ErrorCode) /* PRQA S 0624, 3206 */ /* MD_Rte_0624, MD_Rte_3206 */
{
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << Start of runnable implementation >>             DO NOT CHANGE THIS COMMENT!
 * Symbol: Ssa_KeyM_DataServices_ECU_Certificate_Read_Nonce_ConditionCheckRead (returns application error)
 *********************************************************************************************************************/

  Std_ReturnType retVal = RTE_E_DataServices_ECU_Certificate_Read_Nonce_E_NOT_OK;

  /* ----- Development Error Checks ------------------------------------- */
# if (SSA_DEV_ERROR_DETECT == STD_ON)
  if (ErrorCode == NULL_PTR)
  {
    /* retVal already set */
  }
  else
# endif /* SSA_DEV_ERROR_DETECT == STD_ON */
  {
    if ((OpStatus == DCM_INITIAL) || (OpStatus == DCM_PENDING))
    {
      /* #10 Generate a new nonce in RightsM. Set NRC "challenge calculation failed" if getting nonce is not possible. */
      retVal = Rte_Call_RightsM_Nonce_Get(TRUE, KeyM_DiagProc.buffer32Byte);

      if (retVal == RTE_E_RightsM_Nonce_E_PENDING)
      {
        retVal = RTE_E_DataServices_ECU_Certificate_Read_Nonce_DCM_E_PENDING;
      }
      else if (retVal != RTE_E_OK)
      {
        retVal = RTE_E_DataServices_ECU_Certificate_Read_Nonce_E_NOT_OK;
        *ErrorCode = KEYM_DCM_NRC_CHALLENGE_CALCULATION_FAILED;
      }
      else
      {
        /* Clear nonce. If needed, get it from RightsM. */
        KeyM_ClearDataBuffer(KeyM_DiagProc.buffer32Byte, SSA_SIZEOF_NONCE, SSA_SIZEOF_NONCE);
        retVal = RTE_E_OK;
      }
    }
    else
    {
      *ErrorCode = DCM_E_GENERALREJECT;
    }
  }
  return retVal;

/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << End of runnable implementation >>               DO NOT CHANGE THIS COMMENT!
 *********************************************************************************************************************/
}

/**********************************************************************************************************************
 *
 * Runnable Entity Name: Ssa_KeyM_DataServices_ECU_Certificate_Read_Nonce_ReadData
 *
 *---------------------------------------------------------------------------------------------------------------------
 *
 * Executed if at least one of the following trigger conditions occurred:
 *   - triggered by server invocation for OperationPrototype <ReadData> of PortPrototype <DataServices_ECU_Certificate_Read_Nonce>
 *
 **********************************************************************************************************************
 *
 * Client/Server Interfaces:
 * =========================
 *   Server Invocation:
 *   ------------------
 *   Std_ReturnType Rte_Call_RightsM_Nonce_Get(boolean generateNew, uint8 *nonce)
 *     Argument nonce: uint8* is of type Dcm_Data32ByteType
 *     Synchronous Server Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_RightsM_Nonce_E_INVALID, RTE_E_RightsM_Nonce_E_NOT_OK, RTE_E_RightsM_Nonce_E_PENDING
 *
 **********************************************************************************************************************
 *
 * Runnable prototype:
 * ===================
 *   Std_ReturnType Ssa_KeyM_DataServices_ECU_Certificate_Read_Nonce_ReadData(Dcm_OpStatusType OpStatus, uint8 *Data)
 *     Argument Data: uint8* is of type Dcm_Data32ByteType
 *
 **********************************************************************************************************************
 *
 * Available Application Errors:
 * =============================
 *   RTE_E_DataServices_ECU_Certificate_Read_Nonce_DCM_E_PENDING
 *   RTE_E_DataServices_ECU_Certificate_Read_Nonce_E_NOT_OK
 *
 *********************************************************************************************************************/
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << Start of documentation area >>                  DO NOT CHANGE THIS COMMENT!
 * Symbol: Ssa_KeyM_DataServices_ECU_Certificate_Read_Nonce_ReadData_doc
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 */
/*!
 * \spec
 *    requires $lengthOf(Data) >= sizeof(Dcm_Data32ByteType);
 * \endspec
 */
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << End of documentation area >>                    DO NOT CHANGE THIS COMMENT!
 *********************************************************************************************************************/

FUNC(Std_ReturnType, Ssa_KeyM_CODE) Ssa_KeyM_DataServices_ECU_Certificate_Read_Nonce_ReadData(
  Dcm_OpStatusType OpStatus,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) Data) /* PRQA S 0624, 3206 */ /* MD_Rte_0624, MD_Rte_3206 */
{
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << Start of runnable implementation >>             DO NOT CHANGE THIS COMMENT!
 * Symbol: Ssa_KeyM_DataServices_ECU_Certificate_Read_Nonce_ReadData (returns application error)
 *********************************************************************************************************************/

  Std_ReturnType retVal = RTE_E_DataServices_ECU_Certificate_Read_Nonce_E_NOT_OK;

  /* ----- Development Error Checks ------------------------------------- */
# if (SSA_DEV_ERROR_DETECT == STD_ON)
  if (Data == NULL_PTR)
  {
    /* retVal already set */
  }
  else
# endif /* SSA_DEV_ERROR_DETECT == STD_ON */
  {
    if ((OpStatus == DCM_INITIAL) || (OpStatus == DCM_PENDING))
    {
      /* #10 Get nonce from RightsM that has been already generated during condition check routine.
       *     Copy it to the output buffer. */
      retVal = Rte_Call_RightsM_Nonce_Get(FALSE, Data);

      if (retVal == RTE_E_RightsM_Nonce_E_PENDING)
      {
        retVal = RTE_E_DataServices_ECU_Certificate_Read_Nonce_DCM_E_PENDING;
      }
      else if (retVal != RTE_E_OK)
      {
        /* Clear output data. */
        KeyM_ClearDataBuffer(Data, sizeof(Dcm_Data32ByteType), SSA_SIZEOF_NONCE);
        retVal = RTE_E_DataServices_ECU_Certificate_Read_Nonce_E_NOT_OK;
      }
      else
      {
        retVal = RTE_E_OK;
      }
    }
  }
  return retVal;

/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << End of runnable implementation >>               DO NOT CHANGE THIS COMMENT!
 *********************************************************************************************************************/
}

#endif

/**********************************************************************************************************************
 *
 * Runnable Entity Name: Ssa_KeyM_DataServices_Root_CA_Certificate_Read_ConditionCheckRead
 *
 *---------------------------------------------------------------------------------------------------------------------
 *
 * Executed if at least one of the following trigger conditions occurred:
 *   - triggered by server invocation for OperationPrototype <ConditionCheckRead> of PortPrototype <DataServices_Root_CA_Certificate_Read>
 *
 **********************************************************************************************************************
 *
 * Runnable prototype:
 * ===================
 *   Std_ReturnType Ssa_KeyM_DataServices_Root_CA_Certificate_Read_ConditionCheckRead(Dcm_OpStatusType OpStatus, Dcm_NegativeResponseCodeType *ErrorCode)
 *
 **********************************************************************************************************************
 *
 * Available Application Errors:
 * =============================
 *   RTE_E_DataServices_Root_CA_Certificate_Read_DCM_E_PENDING
 *   RTE_E_DataServices_Root_CA_Certificate_Read_E_NOT_OK
 *
 *********************************************************************************************************************/
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << Start of documentation area >>                  DO NOT CHANGE THIS COMMENT!
 * Symbol: Ssa_KeyM_DataServices_Root_CA_Certificate_Read_ConditionCheckRead_doc
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */

/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << End of documentation area >>                    DO NOT CHANGE THIS COMMENT!
 *********************************************************************************************************************/

FUNC(Std_ReturnType, Ssa_KeyM_CODE) Ssa_KeyM_DataServices_Root_CA_Certificate_Read_ConditionCheckRead(
  Dcm_OpStatusType OpStatus,
  P2VAR(Dcm_NegativeResponseCodeType, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) ErrorCode) /* PRQA S 0624, 3206 */ /* MD_Rte_0624, MD_Rte_3206 */
{
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << Start of runnable implementation >>             DO NOT CHANGE THIS COMMENT!
 * Symbol: Ssa_KeyM_DataServices_Root_CA_Certificate_Read_ConditionCheckRead (returns application error)
 *********************************************************************************************************************/

  Std_ReturnType retVal = RTE_E_DataServices_Root_CA_Certificate_Read_E_NOT_OK;

  /* ----- Development Error Checks ------------------------------------- */
#if (SSA_DEV_ERROR_DETECT == STD_ON)
  if (ErrorCode == NULL_PTR)
  {
    /* retVal already set */
  }
  else
#endif /* SSA_DEV_ERROR_DETECT == STD_ON */
  {
    /* #10 Always successfully return from condition check. */
    *ErrorCode = DCM_E_POSITIVERESPONSE;
    retVal = RTE_E_OK;
  }
  SSA_DUMMY_STATEMENT(OpStatus);    /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */
  return retVal;

/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << End of runnable implementation >>               DO NOT CHANGE THIS COMMENT!
 *********************************************************************************************************************/
}

/**********************************************************************************************************************
 *
 * Runnable Entity Name: Ssa_KeyM_DataServices_Root_CA_Certificate_Read_ReadData
 *
 *---------------------------------------------------------------------------------------------------------------------
 *
 * Executed if at least one of the following trigger conditions occurred:
 *   - triggered by server invocation for OperationPrototype <ReadData> of PortPrototype <DataServices_Root_CA_Certificate_Read>
 *
 **********************************************************************************************************************
 *
 * Client/Server Interfaces:
 * =========================
 *   Server Invocation:
 *   ------------------
 *   Std_ReturnType Rte_Call_CertP_Functions_Certificate_Parse(const uint8 *rawCertData, uint16 rawCertLength, CertP_ParsedCertStructureType *parsedCert)
 *     Argument rawCertData: uint8* is of type CertP_RawCertBufferType
 *     Synchronous Server Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_CertP_Functions_E_NOT_OK
 *
 * Service Calls:
 * ==============
 *   Service Invocation:
 *   -------------------
 *   Std_ReturnType Rte_Call_Key_RootCert_KeyElementGet(uint32 keyElementId, uint8 *keyPtr, uint32 *keyLength)
 *     Argument keyPtr: uint8* is of type Csm_KeyDataType_Ssa_RootCert
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_CsmKeyManagement_Ssa_RootCert_CSM_E_BUSY, RTE_E_CsmKeyManagement_Ssa_RootCert_CSM_E_KEY_EMPTY, RTE_E_CsmKeyManagement_Ssa_RootCert_CSM_E_KEY_NOT_AVAILABLE, RTE_E_CsmKeyManagement_Ssa_RootCert_CSM_E_KEY_READ_FAIL, RTE_E_CsmKeyManagement_Ssa_RootCert_CSM_E_SMALL_BUFFER, RTE_E_CsmKeyManagement_Ssa_RootCert_E_NOT_OK
 *
 **********************************************************************************************************************
 *
 * Runnable prototype:
 * ===================
 *   Std_ReturnType Ssa_KeyM_DataServices_Root_CA_Certificate_Read_ReadData(Dcm_OpStatusType OpStatus, uint8 *Data)
 *     Argument Data: uint8* is of type Dcm_Data1002ByteType
 *
 **********************************************************************************************************************
 *
 * Available Application Errors:
 * =============================
 *   RTE_E_DataServices_Root_CA_Certificate_Read_DCM_E_PENDING
 *   RTE_E_DataServices_Root_CA_Certificate_Read_E_NOT_OK
 *
 *********************************************************************************************************************/
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << Start of documentation area >>                  DO NOT CHANGE THIS COMMENT!
 * Symbol: Ssa_KeyM_DataServices_Root_CA_Certificate_Read_ReadData_doc
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 */
/*!
 * \spec
 *    requires $lengthOf(Data) >= sizeof(Dcm_Data1002ByteType);
 * \endspec
 */
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << End of documentation area >>                    DO NOT CHANGE THIS COMMENT!
 *********************************************************************************************************************/

FUNC(Std_ReturnType, Ssa_KeyM_CODE) Ssa_KeyM_DataServices_Root_CA_Certificate_Read_ReadData(
  Dcm_OpStatusType OpStatus,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) Data) /* PRQA S 0624, 3206 */ /* MD_Rte_0624, MD_Rte_3206 */
{
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << Start of runnable implementation >>             DO NOT CHANGE THIS COMMENT!
 * Symbol: Ssa_KeyM_DataServices_Root_CA_Certificate_Read_ReadData (returns application error)
 *********************************************************************************************************************/
  Std_ReturnType rVal = RTE_E_DataServices_Root_CA_Certificate_Read_E_NOT_OK;

  /* ----- Development Error Checks ------------------------------------- */
#if (SSA_DEV_ERROR_DETECT == STD_ON)
  if (Data == NULL_PTR)
  {
    /* retVal already set */
  }
  else
#endif /* SSA_DEV_ERROR_DETECT == STD_ON */
  {
    uint16 certLength = SSA_SIZEOF_CERT_MAX;

    /* #10 Get parsed, stored Root CA certificate. */
    rVal = KeyM_GetAndParseStoredCert(CERTP_PKI_ROLE_ROOT,
      &Data[2], (P2VAR(uint16, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR))&certLength,
      FALSE);

    if (rVal == E_OK)
    {
      /* #20 Write the certificate length to the first two bytes of the output buffer and append then the certificate
       * data. */
      Data[0] = KeyM_GetUint16HiByte(certLength);
      Data[1] = KeyM_GetUint16LoByte(certLength);
    }
    else
    {
      Data[0] = 0u;
      Data[1] = 0u;
      rVal = RTE_E_DataServices_Root_CA_Certificate_Read_E_NOT_OK;
    }
  }
  SSA_DUMMY_STATEMENT(OpStatus);    /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */

  return rVal;

/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << End of runnable implementation >>               DO NOT CHANGE THIS COMMENT!
 *********************************************************************************************************************/
}

/**********************************************************************************************************************
 *
 * Runnable Entity Name: Ssa_KeyM_DataServices_Root_CA_Certificate_Read_ReadDataLength
 *
 *---------------------------------------------------------------------------------------------------------------------
 *
 * Executed if at least one of the following trigger conditions occurred:
 *   - triggered by server invocation for OperationPrototype <ReadDataLength> of PortPrototype <DataServices_Root_CA_Certificate_Read>
 *
 **********************************************************************************************************************
 *
 * Client/Server Interfaces:
 * =========================
 *   Server Invocation:
 *   ------------------
 *   Std_ReturnType Rte_Call_CertP_Functions_Certificate_Parse(const uint8 *rawCertData, uint16 rawCertLength, CertP_ParsedCertStructureType *parsedCert)
 *     Argument rawCertData: uint8* is of type CertP_RawCertBufferType
 *     Synchronous Server Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_CertP_Functions_E_NOT_OK
 *
 * Service Calls:
 * ==============
 *   Service Invocation:
 *   -------------------
 *   Std_ReturnType Rte_Call_Key_RootCert_KeyElementGet(uint32 keyElementId, uint8 *keyPtr, uint32 *keyLength)
 *     Argument keyPtr: uint8* is of type Csm_KeyDataType_Ssa_RootCert
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_CsmKeyManagement_Ssa_RootCert_CSM_E_BUSY, RTE_E_CsmKeyManagement_Ssa_RootCert_CSM_E_KEY_EMPTY, RTE_E_CsmKeyManagement_Ssa_RootCert_CSM_E_KEY_NOT_AVAILABLE, RTE_E_CsmKeyManagement_Ssa_RootCert_CSM_E_KEY_READ_FAIL, RTE_E_CsmKeyManagement_Ssa_RootCert_CSM_E_SMALL_BUFFER, RTE_E_CsmKeyManagement_Ssa_RootCert_E_NOT_OK
 *
 **********************************************************************************************************************
 *
 * Runnable prototype:
 * ===================
 *   Std_ReturnType Ssa_KeyM_DataServices_Root_CA_Certificate_Read_ReadDataLength(Dcm_OpStatusType OpStatus, uint16 *DataLength)
 *
 **********************************************************************************************************************
 *
 * Available Application Errors:
 * =============================
 *   RTE_E_DataServices_Root_CA_Certificate_Read_DCM_E_PENDING
 *   RTE_E_DataServices_Root_CA_Certificate_Read_E_NOT_OK
 *
 *********************************************************************************************************************/
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << Start of documentation area >>                  DO NOT CHANGE THIS COMMENT!
 * Symbol: Ssa_KeyM_DataServices_Root_CA_Certificate_Read_ReadDataLength_doc
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 */

/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << End of documentation area >>                    DO NOT CHANGE THIS COMMENT!
 *********************************************************************************************************************/

FUNC(Std_ReturnType, Ssa_KeyM_CODE) Ssa_KeyM_DataServices_Root_CA_Certificate_Read_ReadDataLength(
  Dcm_OpStatusType OpStatus,
  P2VAR(uint16, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) DataLength) /* PRQA S 0624, 3206 */ /* MD_Rte_0624, MD_Rte_3206 */
{
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << Start of runnable implementation >>             DO NOT CHANGE THIS COMMENT!
 * Symbol: Ssa_KeyM_DataServices_Root_CA_Certificate_Read_ReadDataLength (returns application error)
 *********************************************************************************************************************/
  Std_ReturnType rVal = RTE_E_DataServices_Root_CA_Certificate_Read_E_NOT_OK;

  /* ----- Development Error Checks ------------------------------------- */
#if (SSA_DEV_ERROR_DETECT == STD_ON)
  if (DataLength == NULL_PTR)
  {
    /* retVal already set */
  }
  else
#endif /* SSA_DEV_ERROR_DETECT == STD_ON */
  {
#if (SSA_KEEP_BUFFER_VARIABLES_STATIC == STD_OFF)
    uint8 KeyM_RootCertBuf[SSA_SIZEOF_CERT_MAX];
#endif
    uint16 rootCertLength = SSA_SIZEOF_CERT_MAX;

    /* #10 Get parsed, stored Root CA certificate. */
    rVal = KeyM_GetAndParseStoredCert(CERTP_PKI_ROLE_ROOT,
      (P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR))KeyM_RootCertBuf, (P2VAR(uint16, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR))&rootCertLength,
      FALSE);

    if (rVal == E_OK)
    {
      /* #20 Write the length of the certificate increased by 2 for the length information to the output buffer. */
      *DataLength = rootCertLength + 2u;
    }
    else
    {
      *DataLength = 0u;
      rVal = RTE_E_DataServices_Root_CA_Certificate_Read_E_NOT_OK;
    }
  }
  SSA_DUMMY_STATEMENT(OpStatus);    /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */

  return rVal;

/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << End of runnable implementation >>               DO NOT CHANGE THIS COMMENT!
 *********************************************************************************************************************/
}

/**********************************************************************************************************************
 *
 * Runnable Entity Name: Ssa_KeyM_DataServices_SecOC_PDU_Data_IDs_and_Key_Checksum_ConditionCheckRead
 *
 *---------------------------------------------------------------------------------------------------------------------
 *
 * Executed if at least one of the following trigger conditions occurred:
 *   - triggered by server invocation for OperationPrototype <ConditionCheckRead> of PortPrototype <DataServices_SecOC_PDU_Data_IDs_and_Key_Checksum_Read_Secured_PDU_Data_IDs_and_Key_Checksum>
 *
 **********************************************************************************************************************
 *
 * Runnable prototype:
 * ===================
 *   Std_ReturnType Ssa_KeyM_DataServices_SecOC_PDU_Data_IDs_and_Key_Checksum_ConditionCheckRead(Dcm_OpStatusType OpStatus, Dcm_NegativeResponseCodeType *ErrorCode)
 *
 **********************************************************************************************************************
 *
 * Available Application Errors:
 * =============================
 *   RTE_E_DataServices_SecOC_PDU_Data_IDs_and_Key_Checksum_Read_Secured_PDU_Data_IDs_and_Key_Checksum_DCM_E_PENDING
 *   RTE_E_DataServices_SecOC_PDU_Data_IDs_and_Key_Checksum_Read_Secured_PDU_Data_IDs_and_Key_Checksum_E_NOT_OK
 *
 *********************************************************************************************************************/
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << Start of documentation area >>                  DO NOT CHANGE THIS COMMENT!
 * Symbol: Ssa_KeyM_DataServices_SecOC_PDU_Data_IDs_and_Key_Checksum_ConditionCheckRead_doc
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */

/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << End of documentation area >>                    DO NOT CHANGE THIS COMMENT!
 *********************************************************************************************************************/

FUNC(Std_ReturnType, Ssa_KeyM_CODE) Ssa_KeyM_DataServices_SecOC_PDU_Data_IDs_and_Key_Checksum_ConditionCheckRead(
  Dcm_OpStatusType OpStatus,
  P2VAR(Dcm_NegativeResponseCodeType, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) ErrorCode) /* PRQA S 0624, 3206 */ /* MD_Rte_0624, MD_Rte_3206 */
{
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << Start of runnable implementation >>             DO NOT CHANGE THIS COMMENT!
 * Symbol: Ssa_KeyM_DataServices_SecOC_PDU_Data_IDs_and_Key_Checksum_ConditionCheckRead (returns application error)
 *********************************************************************************************************************/

  Std_ReturnType retVal = RTE_E_DataServices_SecOC_PDU_Data_IDs_and_Key_Checksum_Read_Secured_PDU_Data_IDs_and_Key_Checksum_E_NOT_OK;

  /* ----- Development Error Checks ------------------------------------- */
#if (SSA_DEV_ERROR_DETECT == STD_ON)
  if (ErrorCode == NULL_PTR)
  {
    /* retVal already set */
  }
  else
#endif /* SSA_DEV_ERROR_DETECT == STD_ON */
  {

    /* #10 Always successfully return from condition check. */
    *ErrorCode = DCM_E_POSITIVERESPONSE;
    retVal = RTE_E_OK;
  }
  SSA_DUMMY_STATEMENT(OpStatus);    /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */

  return retVal;

/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << End of runnable implementation >>               DO NOT CHANGE THIS COMMENT!
 *********************************************************************************************************************/
}

/**********************************************************************************************************************
 *
 * Runnable Entity Name: Ssa_KeyM_DataServices_SecOC_PDU_Data_IDs_and_Key_Checksum_ReadData
 *
 *---------------------------------------------------------------------------------------------------------------------
 *
 * Executed if at least one of the following trigger conditions occurred:
 *   - triggered by server invocation for OperationPrototype <ReadData> of PortPrototype <DataServices_SecOC_PDU_Data_IDs_and_Key_Checksum_Read_Secured_PDU_Data_IDs_and_Key_Checksum>
 *
 **********************************************************************************************************************
 *
 * Client/Server Interfaces:
 * =========================
 *   Server Invocation:
 *   ------------------
 *   Std_ReturnType Rte_Call_SsaCdd_Keys_KeyElementGet(uint32 keyId, uint32 keyElementId, Ssa_DataPtr keyPtr, Ssa_LengthPtr keyLengthPtr)
 *     Synchronous Server Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_SsaCdd_Csm_KeyInterface_E_BUSY, RTE_E_SsaCdd_Csm_KeyInterface_E_NOT_OK
 *
 **********************************************************************************************************************
 *
 * Runnable prototype:
 * ===================
 *   Std_ReturnType Ssa_KeyM_DataServices_SecOC_PDU_Data_IDs_and_Key_Checksum_ReadData(Dcm_OpStatusType OpStatus, uint8 *Data)
 *     Argument Data: uint8* is of type Dcm_Data4092ByteType
 *
 **********************************************************************************************************************
 *
 * Available Application Errors:
 * =============================
 *   RTE_E_DataServices_SecOC_PDU_Data_IDs_and_Key_Checksum_Read_Secured_PDU_Data_IDs_and_Key_Checksum_DCM_E_PENDING
 *   RTE_E_DataServices_SecOC_PDU_Data_IDs_and_Key_Checksum_Read_Secured_PDU_Data_IDs_and_Key_Checksum_E_NOT_OK
 *
 *********************************************************************************************************************/
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << Start of documentation area >>                  DO NOT CHANGE THIS COMMENT!
 * Symbol: Ssa_KeyM_DataServices_SecOC_PDU_Data_IDs_and_Key_Checksum_ReadData_doc
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 */
/*!
 * \spec
 *    requires $lengthOf(Data) >= sizeof(Dcm_Data4092ByteType);
 * \endspec
 */
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << End of documentation area >>                    DO NOT CHANGE THIS COMMENT!
 *********************************************************************************************************************/

FUNC(Std_ReturnType, Ssa_KeyM_CODE) Ssa_KeyM_DataServices_SecOC_PDU_Data_IDs_and_Key_Checksum_ReadData(
  Dcm_OpStatusType OpStatus,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) Data) /* PRQA S 0624, 3206 */ /* MD_Rte_0624, MD_Rte_3206 */
{
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << Start of runnable implementation >>             DO NOT CHANGE THIS COMMENT!
 * Symbol: Ssa_KeyM_DataServices_SecOC_PDU_Data_IDs_and_Key_Checksum_ReadData (returns application error)
 *********************************************************************************************************************/

  Std_ReturnType retVal = RTE_E_DataServices_SecOC_PDU_Data_IDs_and_Key_Checksum_Read_Secured_PDU_Data_IDs_and_Key_Checksum_E_NOT_OK;

  /* ----- Development Error Checks ------------------------------------- */
#if (SSA_DEV_ERROR_DETECT == STD_ON)
  if (Data == NULL_PTR)
  {
    /* retVal already set */
  }
  else
#endif /* SSA_DEV_ERROR_DETECT == STD_ON */
  {
    uint16 localPduId;
    uint16 byteIdx = 0u;
    uint32 lengthChecksum;

    /* #10 Iterate over all configured secured PDUs. */
    for (localPduId = 0u; localPduId < Ssa_GetSizeOfDataIdInfo(); localPduId++)
    {
      /* #20 Write two bytes DataId to the output buffer. */
      Data[byteIdx] = KeyM_GetUint16HiByte(Ssa_GetDataIdOfDataIdInfo(localPduId)); /* VCA_SSA_KEYM_READDATA_SECOC_PDU_DATA_IDS_AND_KEY_CHECKSUM */
      Data[byteIdx + 1u] = KeyM_GetUint16LoByte(Ssa_GetDataIdOfDataIdInfo(localPduId)); /* VCA_SSA_KEYM_READDATA_SECOC_PDU_DATA_IDS_AND_KEY_CHECKSUM */
      lengthChecksum = SSA_SIZEOF_KEY_CHECKSUM;
      /* #30 Get the key checksum (hash value) and copy it to the output buffer. */
      if (Rte_Call_SsaCdd_Keys_KeyElementGet(Ssa_GetKeyIdOfDataIdInfo(localPduId), SSA_KE_MAC_PROOF, &(Data[byteIdx + 2u]), &lengthChecksum) != E_OK) /* VCA_SSA_KEYM_READDATA_SECOC_PDU_DATA_IDS_AND_KEY_CHECKSUM */
      {
        /* #40 if a hash value can't be read - use a default value to indicate a false hash value. */
        KeyM_ClearDataBuffer(&Data[byteIdx + 2u], SSA_SIZEOF_KEY_CHECKSUM, SSA_SIZEOF_KEY_CHECKSUM); /* VCA_SSA_KEYM_READDATA_SECOC_PDU_DATA_IDS_AND_KEY_CHECKSUM */
      }
      byteIdx += 2u + SSA_SIZEOF_KEY_CHECKSUM;
    }
    retVal = RTE_E_OK;
  }
  SSA_DUMMY_STATEMENT(OpStatus);    /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */

  return retVal;

/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << End of runnable implementation >>               DO NOT CHANGE THIS COMMENT!
 *********************************************************************************************************************/
}

/**********************************************************************************************************************
 *
 * Runnable Entity Name: Ssa_KeyM_DataServices_SecOC_PDU_Data_IDs_and_Key_Checksum_ReadDataLength
 *
 *---------------------------------------------------------------------------------------------------------------------
 *
 * Executed if at least one of the following trigger conditions occurred:
 *   - triggered by server invocation for OperationPrototype <ReadDataLength> of PortPrototype <DataServices_SecOC_PDU_Data_IDs_and_Key_Checksum_Read_Secured_PDU_Data_IDs_and_Key_Checksum>
 *
 **********************************************************************************************************************
 *
 * Runnable prototype:
 * ===================
 *   Std_ReturnType Ssa_KeyM_DataServices_SecOC_PDU_Data_IDs_and_Key_Checksum_ReadDataLength(Dcm_OpStatusType OpStatus, uint16 *DataLength)
 *
 **********************************************************************************************************************
 *
 * Available Application Errors:
 * =============================
 *   RTE_E_DataServices_SecOC_PDU_Data_IDs_and_Key_Checksum_Read_Secured_PDU_Data_IDs_and_Key_Checksum_DCM_E_PENDING
 *   RTE_E_DataServices_SecOC_PDU_Data_IDs_and_Key_Checksum_Read_Secured_PDU_Data_IDs_and_Key_Checksum_E_NOT_OK
 *
 *********************************************************************************************************************/
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << Start of documentation area >>                  DO NOT CHANGE THIS COMMENT!
 * Symbol: Ssa_KeyM_DataServices_SecOC_PDU_Data_IDs_and_Key_Checksum_ReadDataLength_doc
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */

/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << End of documentation area >>                    DO NOT CHANGE THIS COMMENT!
 *********************************************************************************************************************/

FUNC(Std_ReturnType, Ssa_KeyM_CODE) Ssa_KeyM_DataServices_SecOC_PDU_Data_IDs_and_Key_Checksum_ReadDataLength(
  Dcm_OpStatusType OpStatus,
  P2VAR(uint16, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) DataLength) /* PRQA S 0624, 3206 */ /* MD_Rte_0624, MD_Rte_3206 */
{
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << Start of runnable implementation >>             DO NOT CHANGE THIS COMMENT!
 * Symbol: Ssa_KeyM_DataServices_SecOC_PDU_Data_IDs_and_Key_Checksum_ReadDataLength (returns application error)
 *********************************************************************************************************************/

  Std_ReturnType retVal = RTE_E_DataServices_SecOC_PDU_Data_IDs_and_Key_Checksum_Read_Secured_PDU_Data_IDs_and_Key_Checksum_E_NOT_OK;

  /* ----- Development Error Checks ------------------------------------- */
#if (SSA_DEV_ERROR_DETECT == STD_ON)
  if (DataLength == NULL_PTR)
  {
    /* retVal already set */
  }
  else
#endif /* SSA_DEV_ERROR_DETECT == STD_ON */
  {
    /* #10 Calculate the size (number_of_PDUs * (size_DataId + size_Checksum)) and write it to the output buffer. */
    *DataLength = Ssa_GetSizeOfDataIdInfo() * (2u + SSA_SIZEOF_KEY_CHECKSUM);
    retVal = RTE_E_OK;
  }
  SSA_DUMMY_STATEMENT(OpStatus);    /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */

  return retVal;

/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << End of runnable implementation >>               DO NOT CHANGE THIS COMMENT!
 *********************************************************************************************************************/
}

/**********************************************************************************************************************
 *
 * Runnable Entity Name: Ssa_KeyM_DataServices_SecOC_Vehicle_Shared_Secret_Hash_ConditionCheckRead
 *
 *---------------------------------------------------------------------------------------------------------------------
 *
 * Executed if at least one of the following trigger conditions occurred:
 *   - triggered by server invocation for OperationPrototype <ConditionCheckRead> of PortPrototype <DataServices_SecOC_Vehicle_Shared_Secret_Hash_Read_SecOC_Vehicle_Shared_Secret_Hash>
 *
 **********************************************************************************************************************
 *
 * Runnable prototype:
 * ===================
 *   Std_ReturnType Ssa_KeyM_DataServices_SecOC_Vehicle_Shared_Secret_Hash_ConditionCheckRead(Dcm_OpStatusType OpStatus, Dcm_NegativeResponseCodeType *ErrorCode)
 *
 **********************************************************************************************************************
 *
 * Available Application Errors:
 * =============================
 *   RTE_E_DataServices_SecOC_Vehicle_Shared_Secret_Hash_Read_SecOC_Vehicle_Shared_Secret_Hash_DCM_E_PENDING
 *   RTE_E_DataServices_SecOC_Vehicle_Shared_Secret_Hash_Read_SecOC_Vehicle_Shared_Secret_Hash_E_NOT_OK
 *
 *********************************************************************************************************************/
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << Start of documentation area >>                  DO NOT CHANGE THIS COMMENT!
 * Symbol: Ssa_KeyM_DataServices_SecOC_Vehicle_Shared_Secret_Hash_ConditionCheckRead_doc
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */

/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << End of documentation area >>                    DO NOT CHANGE THIS COMMENT!
 *********************************************************************************************************************/

FUNC(Std_ReturnType, Ssa_KeyM_CODE) Ssa_KeyM_DataServices_SecOC_Vehicle_Shared_Secret_Hash_ConditionCheckRead(
  Dcm_OpStatusType OpStatus,
  P2VAR(Dcm_NegativeResponseCodeType, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) ErrorCode) /* PRQA S 0624, 3206 */ /* MD_Rte_0624, MD_Rte_3206 */
{
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << Start of runnable implementation >>             DO NOT CHANGE THIS COMMENT!
 * Symbol: Ssa_KeyM_DataServices_SecOC_Vehicle_Shared_Secret_Hash_ConditionCheckRead (returns application error)
 *********************************************************************************************************************/
  Std_ReturnType retVal = RTE_E_DataServices_SecOC_Vehicle_Shared_Secret_Hash_Read_SecOC_Vehicle_Shared_Secret_Hash_E_NOT_OK;

  /* ----- Development Error Checks ------------------------------------- */
#if (SSA_DEV_ERROR_DETECT == STD_ON)
  if (ErrorCode == NULL_PTR)
  {
    /* retVal already set */
  }
  else
#endif /* SSA_DEV_ERROR_DETECT == STD_ON */
  {
    retVal = RTE_E_DataServices_SecOC_Vehicle_Shared_Secret_Hash_Read_SecOC_Vehicle_Shared_Secret_Hash_DCM_E_PENDING;

    if (KeyM_MainLoopProc.state == KEYM_GENERATE_SYM_KEYS_STATE_IDLE)
    {
      retVal = RTE_E_OK;
    }

    /* #10 Always successfully return from condition check. */
    *ErrorCode = DCM_E_POSITIVERESPONSE;
  }
  SSA_DUMMY_STATEMENT(OpStatus);    /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */

  return retVal;

/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << End of runnable implementation >>               DO NOT CHANGE THIS COMMENT!
 *********************************************************************************************************************/
}

/**********************************************************************************************************************
 *
 * Runnable Entity Name: Ssa_KeyM_DataServices_SecOC_Vehicle_Shared_Secret_Hash_ReadData
 *
 *---------------------------------------------------------------------------------------------------------------------
 *
 * Executed if at least one of the following trigger conditions occurred:
 *   - triggered by server invocation for OperationPrototype <ReadData> of PortPrototype <DataServices_SecOC_Vehicle_Shared_Secret_Hash_Read_SecOC_Vehicle_Shared_Secret_Hash>
 *
 **********************************************************************************************************************
 *
 * Service Calls:
 * ==============
 *   Service Invocation:
 *   -------------------
 *   Std_ReturnType Rte_Call_Key_SharedSecretHash_KeyElementGet(uint32 keyElementId, uint8 *keyPtr, uint32 *keyLength)
 *     Argument keyPtr: uint8* is of type Csm_KeyDataType_Ssa_SharedSecretHash
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_CsmKeyManagement_Ssa_SharedSecretHash_CSM_E_BUSY, RTE_E_CsmKeyManagement_Ssa_SharedSecretHash_CSM_E_KEY_EMPTY, RTE_E_CsmKeyManagement_Ssa_SharedSecretHash_CSM_E_KEY_NOT_AVAILABLE, RTE_E_CsmKeyManagement_Ssa_SharedSecretHash_CSM_E_KEY_READ_FAIL, RTE_E_CsmKeyManagement_Ssa_SharedSecretHash_CSM_E_SMALL_BUFFER, RTE_E_CsmKeyManagement_Ssa_SharedSecretHash_E_NOT_OK
 *
 **********************************************************************************************************************
 *
 * Runnable prototype:
 * ===================
 *   Std_ReturnType Ssa_KeyM_DataServices_SecOC_Vehicle_Shared_Secret_Hash_ReadData(Dcm_OpStatusType OpStatus, uint8 *Data)
 *     Argument Data: uint8* is of type Dcm_Data4ByteType
 *
 **********************************************************************************************************************
 *
 * Available Application Errors:
 * =============================
 *   RTE_E_DataServices_SecOC_Vehicle_Shared_Secret_Hash_Read_SecOC_Vehicle_Shared_Secret_Hash_DCM_E_PENDING
 *   RTE_E_DataServices_SecOC_Vehicle_Shared_Secret_Hash_Read_SecOC_Vehicle_Shared_Secret_Hash_E_NOT_OK
 *
 *********************************************************************************************************************/
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << Start of documentation area >>                  DO NOT CHANGE THIS COMMENT!
 * Symbol: Ssa_KeyM_DataServices_SecOC_Vehicle_Shared_Secret_Hash_ReadData_doc
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 */
/*!
 * \spec
 *    requires $lengthOf(Data) >= sizeof(Dcm_Data4ByteType);
 * \endspec
 */
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << End of documentation area >>                    DO NOT CHANGE THIS COMMENT!
 *********************************************************************************************************************/

FUNC(Std_ReturnType, Ssa_KeyM_CODE) Ssa_KeyM_DataServices_SecOC_Vehicle_Shared_Secret_Hash_ReadData(
  Dcm_OpStatusType OpStatus,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) Data) /* PRQA S 0624, 3206 */ /* MD_Rte_0624, MD_Rte_3206 */
{
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << Start of runnable implementation >>             DO NOT CHANGE THIS COMMENT!
 * Symbol: Ssa_KeyM_DataServices_SecOC_Vehicle_Shared_Secret_Hash_ReadData (returns application error)
 *********************************************************************************************************************/

  Std_ReturnType retVal = RTE_E_DataServices_SecOC_Vehicle_Shared_Secret_Hash_Read_SecOC_Vehicle_Shared_Secret_Hash_E_NOT_OK;

  /* ----- Development Error Checks ------------------------------------- */
#if (SSA_DEV_ERROR_DETECT == STD_ON)
  if (Data == NULL_PTR)
  {
    /* retVal already set */
  }
  else
#endif /* SSA_DEV_ERROR_DETECT == STD_ON */
  {
    uint32 secretHashLength = SSA_SIZEOF_SECRETHASH;

    /* #10 Get the hash of the car-specific secret and write it to the output buffer. */
    if (Rte_Call_Key_SharedSecretHash_KeyElementGet(SSA_KE_MAC_PROOF, Data, &secretHashLength) != E_OK)
    {
      /* #20 If the hash value can't be read - use a default value to indicate a false hash value. */
      uint16 byteIdx;
      for (byteIdx = 0u; byteIdx < SSA_SIZEOF_SECRETHASH; byteIdx++)
      {
        Data[byteIdx] = 0x00u;
      }
    }
    retVal = RTE_E_OK;
  }
  SSA_DUMMY_STATEMENT(OpStatus);    /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */

  return retVal;
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << End of runnable implementation >>               DO NOT CHANGE THIS COMMENT!
 *********************************************************************************************************************/
}

/**********************************************************************************************************************
 *
 * Runnable Entity Name: Ssa_KeyM_Init
 *
 *---------------------------------------------------------------------------------------------------------------------
 *
 * Executed once after the RTE is started
 *
 **********************************************************************************************************************
 *
 * Service Calls:
 * ==============
 *   Service Invocation:
 *   -------------------
 *   Std_ReturnType Rte_Call_Key_SharedSecret_KeyElementSet(uint32 keyElementId, const uint8 *keyPtr, uint32 keyLength)
 *     Argument keyPtr: uint8* is of type Csm_KeyDataType_Ssa_SharedSecret
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_CsmKeyManagement_Ssa_SharedSecret_CSM_E_BUSY, RTE_E_CsmKeyManagement_Ssa_SharedSecret_CSM_E_KEY_NOT_AVAILABLE, RTE_E_CsmKeyManagement_Ssa_SharedSecret_CSM_E_KEY_SIZE_MISMATCH, RTE_E_CsmKeyManagement_Ssa_SharedSecret_CSM_E_KEY_WRITE_FAIL, RTE_E_CsmKeyManagement_Ssa_SharedSecret_CSM_E_SMALL_BUFFER, RTE_E_CsmKeyManagement_Ssa_SharedSecret_E_NOT_OK
 *   Std_ReturnType Rte_Call_Key_SharedSecret_KeySetValid(void)
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_CsmKeyManagement_Ssa_SharedSecret_CSM_E_BUSY, RTE_E_CsmKeyManagement_Ssa_SharedSecret_E_NOT_OK
 *   Std_ReturnType Rte_Call_Key_SharedSecretHash_KeyElementGet(uint32 keyElementId, uint8 *keyPtr, uint32 *keyLength)
 *     Argument keyPtr: uint8* is of type Csm_KeyDataType_Ssa_SharedSecretHash
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_CsmKeyManagement_Ssa_SharedSecretHash_CSM_E_BUSY, RTE_E_CsmKeyManagement_Ssa_SharedSecretHash_CSM_E_KEY_EMPTY, RTE_E_CsmKeyManagement_Ssa_SharedSecretHash_CSM_E_KEY_NOT_AVAILABLE, RTE_E_CsmKeyManagement_Ssa_SharedSecretHash_CSM_E_KEY_READ_FAIL, RTE_E_CsmKeyManagement_Ssa_SharedSecretHash_CSM_E_SMALL_BUFFER, RTE_E_CsmKeyManagement_Ssa_SharedSecretHash_E_NOT_OK
 *   Std_ReturnType Rte_Call_Key_TrustModelEcuCsrPrivateKey_KeySetValid(void)
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_CsmKeyManagement_Ssa_TrustModelEcuCsrPrivateKey_CSM_E_BUSY, RTE_E_CsmKeyManagement_Ssa_TrustModelEcuCsrPrivateKey_E_NOT_OK
 *   Std_ReturnType Rte_Call_Key_TrustModelEcuCsrPublicKey_KeySetValid(void)
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_CsmKeyManagement_Ssa_TrustModelEcuCsrPublicKey_CSM_E_BUSY, RTE_E_CsmKeyManagement_Ssa_TrustModelEcuCsrPublicKey_E_NOT_OK
 *   Std_ReturnType Rte_Call_Key_TrustModelEcuStagingPrivateKey_KeyElementCopy(uint32 keyElementId, uint32 targetKeyId, uint32 targetKeyElementId)
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_CsmKeyManagement_Ssa_TrustModelEcuStagingPrivateKey_CSM_E_BUSY, RTE_E_CsmKeyManagement_Ssa_TrustModelEcuStagingPrivateKey_CSM_E_KEY_EMPTY, RTE_E_CsmKeyManagement_Ssa_TrustModelEcuStagingPrivateKey_CSM_E_KEY_READ_FAIL, RTE_E_CsmKeyManagement_Ssa_TrustModelEcuStagingPrivateKey_CSM_E_KEY_SIZE_MISMATCH, RTE_E_CsmKeyManagement_Ssa_TrustModelEcuStagingPrivateKey_CSM_E_KEY_WRITE_FAIL, RTE_E_CsmKeyManagement_Ssa_TrustModelEcuStagingPrivateKey_CSM_E_SMALL_BUFFER, RTE_E_CsmKeyManagement_Ssa_TrustModelEcuStagingPrivateKey_E_NOT_OK
 *   Std_ReturnType Rte_Call_Key_TrustModelEcuStagingPublicKey_KeyElementCopy(uint32 keyElementId, uint32 targetKeyId, uint32 targetKeyElementId)
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_CsmKeyManagement_Ssa_TrustModelEcuStagingPublicKey_CSM_E_BUSY, RTE_E_CsmKeyManagement_Ssa_TrustModelEcuStagingPublicKey_CSM_E_KEY_EMPTY, RTE_E_CsmKeyManagement_Ssa_TrustModelEcuStagingPublicKey_CSM_E_KEY_READ_FAIL, RTE_E_CsmKeyManagement_Ssa_TrustModelEcuStagingPublicKey_CSM_E_KEY_SIZE_MISMATCH, RTE_E_CsmKeyManagement_Ssa_TrustModelEcuStagingPublicKey_CSM_E_KEY_WRITE_FAIL, RTE_E_CsmKeyManagement_Ssa_TrustModelEcuStagingPublicKey_CSM_E_SMALL_BUFFER, RTE_E_CsmKeyManagement_Ssa_TrustModelEcuStagingPublicKey_E_NOT_OK
 *
 *********************************************************************************************************************/
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << Start of documentation area >>                  DO NOT CHANGE THIS COMMENT!
 * Symbol: Ssa_KeyM_Init_doc
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */

/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << End of documentation area >>                    DO NOT CHANGE THIS COMMENT!
 *********************************************************************************************************************/

FUNC(void, Ssa_KeyM_CODE) Ssa_KeyM_Init(void) /* PRQA S 0624, 3206 */ /* MD_Rte_0624, MD_Rte_3206 */
{
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << Start of runnable implementation >>             DO NOT CHANGE THIS COMMENT!
 * Symbol: Ssa_KeyM_Init
 *********************************************************************************************************************/
  Std_ReturnType retVal;
  uint32 keyElementLength = SSA_SIZEOF_SECRETHASH;
  uint8 hashData[SSA_SIZEOF_SECRETHASH];

  /* Reset verification results of diagnostic chain certificates. */
  KeyM_ParsedRootCert.verificationResult = CERTP_VER_NOT_PARSED;
  KeyM_ParsedBackendCert.verificationResult = CERTP_VER_NOT_PARSED;
#if (SSA_ECU_TYPE == SSA_ECU_TYPE_VSM)
  KeyM_ParsedEcuCert.verificationResult = CERTP_VER_NOT_PARSED;
#endif

  /* Reset states related to asynchronous job handling. */
  KeyM_SigGenAsyncState = SSA_ASYNC_STATE_IDLE;
  KeyM_SigVerifAsyncState = SSA_ASYNC_STATE_IDLE;
  KeyM_CalcPubValAsyncState = SSA_ASYNC_STATE_IDLE;
  KeyM_CalcSecretAsyncState = SSA_ASYNC_STATE_IDLE;
#if ((SSA_DIAG_SERVICE_TRUST_MODEL_GENERATE_KEY_PAIR == STD_ON) && (SSA_GENERATE_KEY_PAIR_CUSTOM_CALLOUT == STD_OFF))
  KeyM_GenerateTrustModelEcuCsrKeyAsyncState = SSA_ASYNC_STATE_IDLE;
#endif
  KeyM_VerifyPubKeyState = KEYM_VERIFY_CERTPUBLICKEY_WITH_ECUPRIVATEKEY_STATE_IDLE_GENERATE_SIGNATURE;
  KeyM_KeyExchangeCalcSymmetricKeyState = KEYM_KEYEXCHANGECALCSYMKEY_STATE_IDLE;
  KeyM_RandomGenerateAsyncState = SSA_ASYNC_STATE_IDLE;
#if (SSA_KEEP_BUFFER_VARIABLES_STATIC == STD_ON)
  KeyM_SignatureOutLength = 0;
  KeyM_CsmVerificationResult = CRYPTO_E_VER_NOT_OK;
#endif

  /* Reset parts of workspace for replace certificates. */
  KeyM_DiagProc.ws.replaceCerts.certReplacement = KEYM_REPLACE_NO_CERT;
  KeyM_DiagProc.ws.replaceCerts.receivedParsedEcuCert.verificationResult = CERTP_VER_NOT_PARSED;
  KeyM_DiagProc.ws.replaceCerts.receivedParsedBackendCaCert.verificationResult = CERTP_VER_NOT_PARSED;
  KeyM_DiagProc.ws.replaceCerts.receivedParsedRootCaCert.verificationResult = CERTP_VER_NOT_PARSED;
  KeyM_DiagProc.ws.replaceCerts.receivedParsedBackendCaOrRootCaLinkCert.verificationResult = CERTP_VER_NOT_PARSED;
  KeyM_DiagProc.ws.replaceCerts.isDevelopCertReplaced = FALSE;

  /* Reset states related to main loop processing. */
  KeyM_MainLoopProc.numGenSymKeys = 0u;
  KeyM_MainLoopProc.counterWaitBeforeGenerate = SSA_KEYM_NUMBER_WAIT_CYCLES_BEFORE_KEY_GENERATION;
  KeyM_MainLoopProc.counterRetry = SSA_KEYM_NUMBER_RETRIES_KEY_GENERATION;
  KeyM_MainLoopProc.state = KEYM_GENERATE_SYM_KEYS_STATE_IDLE;

  /* Reset states related to diagnostic services. */
  KeyM_DiagProc.state = 0u;
  KeyM_DiagProc.verifyCertState = KEYM_SECRET_DISTRIB_VERIFY_ECUCERT_STATE_IDLE;
  KeyM_DiagProc.replaceCertificatesReplaceRootAndLowerState = KEYM_REPLACE_CERT_REPLACE_ROOT_AND_LOWER_CERT_STATE_IDLE;
  KeyM_DiagProc.replaceCertificatesReplaceBackendAndLowerState = KEYM_REPLACE_CERT_REPLACE_BACKEND_AND_LOWER_CERT_STATE_IDLE;
#if (SSA_ECU_TYPE == SSA_ECU_TYPE_VSM)
  KeyM_DiagProc.replaceCertificatesReplaceEcuState = KEYM_REPLACE_CERT_REPLACE_ECUCERT_STATE_IDLE;
  KeyM_DiagProc.replaceCertificatesVerifyEcuState = KEYM_REPLACE_CERT_VERIFY_ECUCERT_STATE_IDLE;
#else
# if (SSA_DIAG_SERVICE_INJECT_SEED == STD_ON)
  KeyM_RandomSeedState = SSA_ASYNC_STATE_IDLE;
# endif
#endif

  KeyM_DiagProc.randomNumberGeneration_Flag = SSA_KEYM_DID191_FAILURE;
  KeyM_DiagProc.serviceResponseBufferLength = SSA_MAX_SIZE_KEYM_SERVICE_CERTIFICATE_RESPONSE;
  KeyM_DiagProc.serviceResponseCallbackOccurred = FALSE;
  KeyM_DiagProc.serviceResponseCallbackResult = E_NOT_OK;
  KeyM_DiagProc.certificateVerifyCallbackOccurred = FALSE;
  KeyM_DiagProc.certificateVerifyCallbackResult = E_NOT_OK;

  KeyM_lastCsrCreationReturnedBusy = FALSE;

  /* #10 Check if there is a stored shared secret hash. This serves as indicator if there
   *     are valid SecOc keys, i.e. if they have been derived from secret already */
  retVal = Rte_Call_Key_SharedSecretHash_KeyElementGet(SSA_KE_MAC_PROOF, hashData, &keyElementLength);
  if(retVal != RTE_E_OK)
  {
    /* #30 No keys have been derived yet. So this is the first start-up. Derive keys from standard secret. */
#if (SSA_ECU_TYPE == SSA_ECU_TYPE_VSM)
    /* #40 If ECU type is VSM store the standard shared secret. */
    keyElementLength = SSA_SIZEOF_SECRET;
    retVal = Rte_Call_Key_SharedSecret_KeyElementSet(SSA_KE_MAC_KEY, KeyM_StandardSharedSecret, keyElementLength);
    retVal |= Rte_Call_Key_SharedSecret_KeySetValid();
    if (retVal == RTE_E_OK)
#endif
    {
      Ssa_MemCpy((P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR))KeyM_CarSpecificSecret, (P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA))KeyM_StandardSharedSecret, SSA_SIZEOF_SECRET);

      KeyM_MainLoopProc.conf = KEY_MAINLOOP_PROC_CONF_COMPLETE;
      KeyM_MainLoopProc.result = E_OK;
      KeyM_MainLoopProc.state = KEYM_GENERATE_SYM_KEYS_STATE_HASH_SECRET;
    }
  }

  /* Set Private and Public CSR Key */
  (void)KeyM_TrustModel_CopyCsrKey();

  /* Ensure type sizes once for the KeyM submodule which calls RTE APIs expecting these data types:
   * Ssa_Data64ByteType must be an array with 64 element(s) of type uint8
   * Coding_VINDataType must be an array with 17 element(s) of type uint8
   * Dcm_Data32ByteType must be an array with 32 element(s) of type uint8
   * Ssa_Data7ByteType must be an array with 7 element(s) of type uint8
   * Ssa_Data5ByteType must be an array with 5 element(s) of type uint8
   * Csm_MacGenerateResultType_MacGenAesCmac must be an array with 16 element(s) of type uint8
   * Csm_KeyDataType_Ssa_SharedSecretKeyExchange must be an array with 32 element(s) of type uint8
   * Csm_KeyDataType_Ssa_SharedSecretHash must be an array with 4 element(s) of type uint8
   * Csm_RandomGenerateResultType_Random must be an array with 32 element(s) of type uint8
   * Csm_PublicValueDataType_Ssa_SharedSecretKeyExchange must be an array with 32 element(s) of type uint8
   * Csm_KeyDataType_Ssa_BackendCert must be an array with <= 910 element(s) of type uint8
   * Csm_KeyDataType_Ssa_RootCert must be an array with <= 910 element(s) of type uint8
   * Csm_KeyDataType_Ssa_TrustModelEcuCsrPublicKey must be an array with 32 element(s) of type uint8
   * Csm_KeyDataType_Ssa_TrustModelEcuLivePublicKey must be an array with 32 element(s) of type uint8
   * Csm_KeyDataType_Ssa_TrustModelTempPublicKey must be an array with 32 element(s) of type uint8
   * Csm_KeyDataType_Ssa_SigPubKey_ReplacementAuthority must be an array with 32 element(s) of type uint8
   * KeyM_SharedSecretType must be an array with 32 element(s) of type uint8
   * KeyM_CertificateElementType_Ssa_TrustModelEcuCert_SerialNo must be an array with 16 element(s) of type uint8
   * KeyM_CertificateElementType_Ssa_TrustModelBackendPeerCert_SerialNo must be an array with 16 element(s) of type uint8
   * KeyM_CertificateElementType_Ssa_TrustModelIntermediatePeerCert_SerialNo must be an array with 16 element(s) of type uint8
   * KeyM_CertificateElementType_Ssa_TrustModelEcuPeerCert_SerialNo must be an array with 16 element(s) of type uint8
   * KeyM_CertificateElementType_Ssa_TrustModelRootCert_SerialNo must be an array with 16 element(s) of type uint8
   * KeyM_CertificateElementType_Ssa_TrustModelBackendCert_SerialNo must be an array with 16 element(s) of type uint8
   * KeyM_CertificateElementType_Ssa_TrustModelIntermediateCert_SerialNo must be an array with 16 element(s) of type uint8
   * KeyM_CertificateElementType_Ssa_TrustModelEcuCert_ext_subKeyId must be an array with 20 element(s) of type uint8
   * KeyM_CertificateElementType_Ssa_TrustModelEcuCert_ext_uniqueECUID must be an array with 170 element(s) of type uint8
   * KeyM_CertificateElementType_Ssa_TrustModelEcuPeerCert_ext_subKeyId must be an array with 20 element(s) of type uint8
   * KeyM_CertificateElementType_Ssa_TrustModelRootCert_ext_subKeyId must be an array with 20 element(s) of type uint8
   * KeyM_CertificateElementType_Ssa_TrustModelBackendCert_ext_authKeyId must be an array with 20 element(s) of type uint8
   * KeyM_CertificateElementType_Ssa_TrustModelBackendCert_ext_basicConstraints must be an array with 1 element(s) of type uint8
   * KeyM_CertificateElementType_Ssa_TrustModelBackendCert_ext_subKeyId must be an array with 20 element(s) of type uint8
   * KeyM_CertificateElementType_Ssa_TrustModelBackendCert_Issuer must be an array with 15 element(s) of type uint8
   * KeyM_CertificateElementType_Ssa_TrustModelBackendCert_subject must be an array with 30 element(s) of type uint8
   * KeyM_CertificateElementType_Ssa_TrustModelBackendCert_SubjectPublicKeyInfoKey must be an array with 33 element(s) of type uint8
   * KeyM_CertificateElementType_Ssa_TrustModelBackendCert_validityNotAfter must be an array with 15 element(s) of type uint8
   * KeyM_CertificateElementType_Ssa_TrustModelBackendCert_Version must be an array with 1 element(s) of type uint8
   * KeyM_CertificateElementType_Ssa_TrustModelBackendPeerCert_ext_authKeyId must be an array with 20 element(s) of type uint8
   * KeyM_CertificateElementType_Ssa_TrustModelBackendPeerCert_ext_basicConstraints must be an array with 1 element(s) of type uint8
   * KeyM_CertificateElementType_Ssa_TrustModelBackendPeerCert_ext_subKeyId must be an array with 20 element(s) of type uint8
   * KeyM_CertificateElementType_Ssa_TrustModelBackendPeerCert_validityNotAfter must be an array with 15 element(s) of type uint8
   * KeyM_CertificateElementType_Ssa_TrustModelBackendPeerCert_Version must be an array with 1 element(s) of type uint8
   * KeyM_CertificateElementType_Ssa_TrustModelEcuCert_ext_authKeyId must be an array with 20 element(s) of type uint8
   * KeyM_CertificateElementType_Ssa_TrustModelEcuCert_ext_specialEcu must be an array with 1 element(s) of type uint8
   * KeyM_CertificateElementType_Ssa_TrustModelEcuCert_Issuer must be an array with 15 element(s) of type uint8
   * KeyM_CertificateElementType_Ssa_TrustModelEcuCert_subject must be an array with 30 element(s) of type uint8
   * KeyM_CertificateElementType_Ssa_TrustModelEcuCert_SubjectPublicKeyInfoKey must be an array with 33 element(s) of type uint8
   * KeyM_CertificateElementType_Ssa_TrustModelEcuCert_validityNotAfter must be an array with 15 element(s) of type uint8
   * KeyM_CertificateElementType_Ssa_TrustModelEcuCert_Version must be an array with 1 element(s) of type uint8
   * KeyM_CertificateElementType_Ssa_TrustModelEcuPeerCert_ext_authKeyId must be an array with 20 element(s) of type uint8
   * KeyM_CertificateElementType_Ssa_TrustModelEcuPeerCert_ext_specialEcu must be an array with 1 element(s) of type uint8
   * KeyM_CertificateElementType_Ssa_TrustModelEcuPeerCert_validityNotAfter must be an array with 15 element(s) of type uint8
   * KeyM_CertificateElementType_Ssa_TrustModelEcuPeerCert_Version must be an array with 1 element(s) of type uint8
   * KeyM_CertificateElementType_Ssa_TrustModelIntermediateCert_ext_authKeyId must be an array with 20 element(s) of type uint8
   * KeyM_CertificateElementType_Ssa_TrustModelIntermediateCert_ext_basicConstraints must be an array with 1 element(s) of type uint8
   * KeyM_CertificateElementType_Ssa_TrustModelIntermediateCert_ext_subKeyId must be an array with 20 element(s) of type uint8
   * KeyM_CertificateElementType_Ssa_TrustModelIntermediateCert_Issuer must be an array with 15 element(s) of type uint8
   * KeyM_CertificateElementType_Ssa_TrustModelIntermediateCert_subject must be an array with 30 element(s) of type uint8
   * KeyM_CertificateElementType_Ssa_TrustModelIntermediateCert_SubjectPublicKeyInfoKey must be an array with 33 element(s) of type uint8
   * KeyM_CertificateElementType_Ssa_TrustModelIntermediateCert_validityNotAfter must be an array with 15 element(s) of type uint8
   * KeyM_CertificateElementType_Ssa_TrustModelIntermediateCert_Version must be an array with 1 element(s) of type uint8
   * KeyM_CertificateElementType_Ssa_TrustModelIntermediatePeerCert_ext_authKeyId must be an array with 20 element(s) of type uint8
   * KeyM_CertificateElementType_Ssa_TrustModelIntermediatePeerCert_ext_basicConstraints must be an array with 1 element(s) of type uint8
   * KeyM_CertificateElementType_Ssa_TrustModelIntermediatePeerCert_ext_subKeyId must be an array with 20 element(s) of type uint8
   * KeyM_CertificateElementType_Ssa_TrustModelIntermediatePeerCert_validityNotAfter must be an array with 15 element(s) of type uint8
   * KeyM_CertificateElementType_Ssa_TrustModelIntermediatePeerCert_Version must be an array with 1 element(s) of type uint8
   * KeyM_CertificateElementType_Ssa_TrustModelRootCert_ext_basicConstraints must be an array with 1 element(s) of type uint8
   * KeyM_CertificateElementType_Ssa_TrustModelRootCert_ext_keyUsage must be an array with 2 element(s) of type uint8
   * KeyM_CertificateElementType_Ssa_TrustModelRootCert_Issuer must be an array with 15 element(s) of type uint8
   * KeyM_CertificateElementType_Ssa_TrustModelRootCert_subject must be an array with 30 element(s) of type uint8
   * KeyM_CertificateElementType_Ssa_TrustModelRootCert_SubjectPublicKeyInfoKey must be an array with 33 element(s) of type uint8
   * KeyM_CertificateElementType_Ssa_TrustModelRootCert_validityNotAfter must be an array with 15 element(s) of type uint8
   * KeyM_CertificateElementType_Ssa_TrustModelRootCert_Version must be an array with 1 element(s) of type uint8 */
  /* if ECU TYPE is VSM:
   * Csm_KeyDataType_Ssa_SharedSecret must be an array with 32 element(s) of type uint8
   * Csm_EncryptResultType_AES128Encrypt must be an array with 80 element(s) of type uint8
   * Csm_KeyDataType_Ssa_EcuCert must be an array with <= 910 element(s) of type uint8 */
  /* if ECU TYPE is != VSM:
   * Csm_DecryptResultType_AES128Decrypt must be an array with 80 element(s) of type uint8
   * Csm_DecryptResultType_AES128DecryptWithPadding must be an array with 1056 element(s) of type uint8 */


  /*@ assert sizeof(Ssa_Data64ByteType) == 64; */
  /*@ assert sizeof(Coding_VINDataType) == 17; */
  /*@ assert sizeof(Dcm_Data32ByteType) == 32; */
  /*@ assert sizeof(Ssa_Data7ByteType) == 7; */
  /*@ assert sizeof(Ssa_Data5ByteType) == 5; */
  /*@ assert sizeof(Csm_MacGenerateResultType_MacGenAesCmac) == 16; */
  /*@ assert sizeof(Csm_KeyDataType_Ssa_SharedSecretKeyExchange) == 32; */
  /*@ assert sizeof(Csm_KeyDataType_Ssa_SharedSecretHash) == 4; */
  /*@ assert sizeof(Csm_RandomGenerateResultType_Random) == 32; */
  /*@ assert sizeof(Csm_PublicValueDataType_Ssa_SharedSecretKeyExchange) == 32; */
  /*@ assert sizeof(Csm_KeyDataType_Ssa_BackendCert) <= 910; */
  /*@ assert sizeof(Csm_KeyDataType_Ssa_RootCert) <= 910; */
  /*@ assert sizeof(Csm_KeyDataType_Ssa_TrustModelEcuCsrPublicKey) == 32; */
  /*@ assert sizeof(Csm_KeyDataType_Ssa_TrustModelEcuLivePublicKey) == 32; */
  /*@ assert sizeof(Csm_KeyDataType_Ssa_TrustModelTempPublicKey) == 32; */
  /*@ assert sizeof(Csm_KeyDataType_Ssa_SigPubKey_ReplacementAuthority) == 32; */
  /*@ assert sizeof(KeyM_SharedSecretType) == 32; */
  /*@ assert sizeof(KeyM_CertificateElementType_Ssa_TrustModelEcuCert_SerialNo) == 16; */
  /*@ assert sizeof(KeyM_CertificateElementType_Ssa_TrustModelBackendPeerCert_SerialNo) == 16; */
  /*@ assert sizeof(KeyM_CertificateElementType_Ssa_TrustModelIntermediatePeerCert_SerialNo) == 16; */
  /*@ assert sizeof(KeyM_CertificateElementType_Ssa_TrustModelEcuPeerCert_SerialNo) == 16; */
  /*@ assert sizeof(KeyM_CertificateElementType_Ssa_TrustModelRootCert_SerialNo) == 16; */
  /*@ assert sizeof(KeyM_CertificateElementType_Ssa_TrustModelBackendCert_SerialNo) == 16; */
  /*@ assert sizeof(KeyM_CertificateElementType_Ssa_TrustModelIntermediateCert_SerialNo) == 16; */
  /*@ assert sizeof(KeyM_CertificateElementType_Ssa_TrustModelEcuCert_ext_subKeyId) == 20; */
  /*@ assert sizeof(KeyM_CertificateElementType_Ssa_TrustModelEcuCert_ext_uniqueECUID) == 170; */
  /*@ assert sizeof(KeyM_CertificateElementType_Ssa_TrustModelEcuPeerCert_ext_subKeyId) == 20; */
  /*@ assert sizeof(KeyM_CertificateElementType_Ssa_TrustModelRootCert_ext_subKeyId) == 20; */
  /*@ assert sizeof(KeyM_CertificateElementType_Ssa_TrustModelBackendCert_ext_authKeyId) == 20; */
  /*@ assert sizeof(KeyM_CertificateElementType_Ssa_TrustModelBackendCert_ext_basicConstraints) == 1; */
  /*@ assert sizeof(KeyM_CertificateElementType_Ssa_TrustModelBackendCert_ext_subKeyId) == 20; */
  /*@ assert sizeof(KeyM_CertificateElementType_Ssa_TrustModelBackendCert_Issuer) == 15; */
  /*@ assert sizeof(KeyM_CertificateElementType_Ssa_TrustModelBackendCert_subject) == 30; */
  /*@ assert sizeof(KeyM_CertificateElementType_Ssa_TrustModelBackendCert_SubjectPublicKeyInfoKey) == 33; */
  /*@ assert sizeof(KeyM_CertificateElementType_Ssa_TrustModelBackendCert_validityNotAfter) == 15; */
  /*@ assert sizeof(KeyM_CertificateElementType_Ssa_TrustModelBackendCert_Version) == 1; */
  /*@ assert sizeof(KeyM_CertificateElementType_Ssa_TrustModelBackendPeerCert_ext_authKeyId) == 20; */
  /*@ assert sizeof(KeyM_CertificateElementType_Ssa_TrustModelBackendPeerCert_ext_basicConstraints) == 1; */
  /*@ assert sizeof(KeyM_CertificateElementType_Ssa_TrustModelBackendPeerCert_ext_subKeyId) == 20; */
  /*@ assert sizeof(KeyM_CertificateElementType_Ssa_TrustModelBackendPeerCert_validityNotAfter) == 15; */
  /*@ assert sizeof(KeyM_CertificateElementType_Ssa_TrustModelBackendPeerCert_Version) == 1; */
  /*@ assert sizeof(KeyM_CertificateElementType_Ssa_TrustModelEcuCert_ext_authKeyId) == 20; */
  /*@ assert sizeof(KeyM_CertificateElementType_Ssa_TrustModelEcuCert_ext_specialEcu) == 1; */
  /*@ assert sizeof(KeyM_CertificateElementType_Ssa_TrustModelEcuCert_Issuer) == 15; */
  /*@ assert sizeof(KeyM_CertificateElementType_Ssa_TrustModelEcuCert_subject) == 30; */
  /*@ assert sizeof(KeyM_CertificateElementType_Ssa_TrustModelEcuCert_SubjectPublicKeyInfoKey) == 33; */
  /*@ assert sizeof(KeyM_CertificateElementType_Ssa_TrustModelEcuCert_validityNotAfter) == 15; */
  /*@ assert sizeof(KeyM_CertificateElementType_Ssa_TrustModelEcuCert_Version) == 1; */
  /*@ assert sizeof(KeyM_CertificateElementType_Ssa_TrustModelEcuPeerCert_ext_authKeyId) == 20; */
  /*@ assert sizeof(KeyM_CertificateElementType_Ssa_TrustModelEcuPeerCert_ext_specialEcu) == 1; */
  /*@ assert sizeof(KeyM_CertificateElementType_Ssa_TrustModelEcuPeerCert_validityNotAfter) == 15; */
  /*@ assert sizeof(KeyM_CertificateElementType_Ssa_TrustModelEcuPeerCert_Version) == 1; */
  /*@ assert sizeof(KeyM_CertificateElementType_Ssa_TrustModelIntermediateCert_ext_authKeyId) == 20; */
  /*@ assert sizeof(KeyM_CertificateElementType_Ssa_TrustModelIntermediateCert_ext_basicConstraints) == 1; */
  /*@ assert sizeof(KeyM_CertificateElementType_Ssa_TrustModelIntermediateCert_ext_subKeyId) == 20; */
  /*@ assert sizeof(KeyM_CertificateElementType_Ssa_TrustModelIntermediateCert_Issuer) == 15; */
  /*@ assert sizeof(KeyM_CertificateElementType_Ssa_TrustModelIntermediateCert_subject) == 30; */
  /*@ assert sizeof(KeyM_CertificateElementType_Ssa_TrustModelIntermediateCert_SubjectPublicKeyInfoKey) == 33; */
  /*@ assert sizeof(KeyM_CertificateElementType_Ssa_TrustModelIntermediateCert_validityNotAfter) == 15; */
  /*@ assert sizeof(KeyM_CertificateElementType_Ssa_TrustModelIntermediateCert_Version) == 1; */
  /*@ assert sizeof(KeyM_CertificateElementType_Ssa_TrustModelIntermediatePeerCert_ext_authKeyId) == 20; */
  /*@ assert sizeof(KeyM_CertificateElementType_Ssa_TrustModelIntermediatePeerCert_ext_basicConstraints) == 1; */
  /*@ assert sizeof(KeyM_CertificateElementType_Ssa_TrustModelIntermediatePeerCert_ext_subKeyId) == 20; */
  /*@ assert sizeof(KeyM_CertificateElementType_Ssa_TrustModelIntermediatePeerCert_validityNotAfter) == 15; */
  /*@ assert sizeof(KeyM_CertificateElementType_Ssa_TrustModelIntermediatePeerCert_Version) == 1; */
  /*@ assert sizeof(KeyM_CertificateElementType_Ssa_TrustModelRootCert_ext_basicConstraints) == 1; */
  /*@ assert sizeof(KeyM_CertificateElementType_Ssa_TrustModelRootCert_ext_keyUsage) == 2; */
  /*@ assert sizeof(KeyM_CertificateElementType_Ssa_TrustModelRootCert_Issuer) == 15; */
  /*@ assert sizeof(KeyM_CertificateElementType_Ssa_TrustModelRootCert_subject) == 30; */
  /*@ assert sizeof(KeyM_CertificateElementType_Ssa_TrustModelRootCert_SubjectPublicKeyInfoKey) == 33; */
  /*@ assert sizeof(KeyM_CertificateElementType_Ssa_TrustModelRootCert_validityNotAfter) == 15; */
  /*@ assert sizeof(KeyM_CertificateElementType_Ssa_TrustModelRootCert_Version) == 1; */
#if (SSA_ECU_TYPE == SSA_ECU_TYPE_VSM)
  /*@ assert sizeof(Csm_KeyDataType_Ssa_SharedSecret) == 32; */
  /*@ assert sizeof(Csm_EncryptResultType_AES128Encrypt) == 80; */
  /*@ assert sizeof(Csm_KeyDataType_Ssa_EcuCert) <= 910; */
#else
  /*@ assert sizeof(Csm_DecryptResultType_AES128Decrypt) == 80; */
  /*@ assert sizeof(Csm_DecryptResultType_AES128DecryptWithPadding) == 1056; */
#endif

/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << End of runnable implementation >>               DO NOT CHANGE THIS COMMENT!
 *********************************************************************************************************************/
}

/**********************************************************************************************************************
 *
 * Runnable Entity Name: Ssa_KeyM_KeyMCertificateVerifyCallback_TrustModelBackend
 *
 *---------------------------------------------------------------------------------------------------------------------
 *
 * Executed if at least one of the following trigger conditions occurred:
 *   - triggered by server invocation for OperationPrototype <CertificateVerifyCallbackNotification> of PortPrototype <CertificateNotification_TrustModelBackend>
 *
 **********************************************************************************************************************
 *
 * Runnable prototype:
 * ===================
 *   void Ssa_KeyM_KeyMCertificateVerifyCallback_TrustModelBackend(KeyM_CertificateStatusType Result)
 *
 *********************************************************************************************************************/
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << Start of documentation area >>                  DO NOT CHANGE THIS COMMENT!
 * Symbol: Ssa_KeyM_KeyMCertificateVerifyCallback_TrustModelBackend_doc
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */

/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << End of documentation area >>                    DO NOT CHANGE THIS COMMENT!
 *********************************************************************************************************************/

FUNC(void, Ssa_KeyM_CODE) Ssa_KeyM_KeyMCertificateVerifyCallback_TrustModelBackend(KeyM_CertificateStatusType Result) /* PRQA S 0624, 3206 */ /* MD_Rte_0624, MD_Rte_3206 */
{
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << Start of runnable implementation >>             DO NOT CHANGE THIS COMMENT!
 * Symbol: Ssa_KeyM_KeyMCertificateVerifyCallback_TrustModelBackend
 *********************************************************************************************************************/
  /* discard if result indicates no error */
  if (Result != KEYM_RT_OK)
  {
    /* Handle callback parameters. */
    KeyM_DiagProc.certificateVerifyCallbackResult = Result;
    KeyM_DiagProc.certificateVerifyCallbackOccurred = TRUE;
  }
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << End of runnable implementation >>               DO NOT CHANGE THIS COMMENT!
 *********************************************************************************************************************/
}

/**********************************************************************************************************************
 *
 * Runnable Entity Name: Ssa_KeyM_KeyMCertificateVerifyCallback_TrustModelBackendPeer
 *
 *---------------------------------------------------------------------------------------------------------------------
 *
 * Executed if at least one of the following trigger conditions occurred:
 *   - triggered by server invocation for OperationPrototype <CertificateVerifyCallbackNotification> of PortPrototype <CertificateNotification_TrustModelBackendPeer>
 *
 **********************************************************************************************************************
 *
 * Runnable prototype:
 * ===================
 *   void Ssa_KeyM_KeyMCertificateVerifyCallback_TrustModelBackendPeer(KeyM_CertificateStatusType Result)
 *
 *********************************************************************************************************************/
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << Start of documentation area >>                  DO NOT CHANGE THIS COMMENT!
 * Symbol: Ssa_KeyM_KeyMCertificateVerifyCallback_TrustModelBackendPeer_doc
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */

/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << End of documentation area >>                    DO NOT CHANGE THIS COMMENT!
 *********************************************************************************************************************/

FUNC(void, Ssa_KeyM_CODE) Ssa_KeyM_KeyMCertificateVerifyCallback_TrustModelBackendPeer(KeyM_CertificateStatusType Result) /* PRQA S 0624, 3206 */ /* MD_Rte_0624, MD_Rte_3206 */
{
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << Start of runnable implementation >>             DO NOT CHANGE THIS COMMENT!
 * Symbol: Ssa_KeyM_KeyMCertificateVerifyCallback_TrustModelBackendPeer
 *********************************************************************************************************************/
  /* discard if result indicates no error */
  if (Result != KEYM_RT_OK)
  {
    /* Handle callback parameters. */
    KeyM_DiagProc.certificateVerifyCallbackResult = Result;
    KeyM_DiagProc.certificateVerifyCallbackOccurred = TRUE;
  }
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << End of runnable implementation >>               DO NOT CHANGE THIS COMMENT!
 *********************************************************************************************************************/
}

/**********************************************************************************************************************
 *
 * Runnable Entity Name: Ssa_KeyM_KeyMCertificateVerifyCallback_TrustModelEcu
 *
 *---------------------------------------------------------------------------------------------------------------------
 *
 * Executed if at least one of the following trigger conditions occurred:
 *   - triggered by server invocation for OperationPrototype <CertificateVerifyCallbackNotification> of PortPrototype <CertificateNotification_TrustModelEcu>
 *
 **********************************************************************************************************************
 *
 * Runnable prototype:
 * ===================
 *   void Ssa_KeyM_KeyMCertificateVerifyCallback_TrustModelEcu(KeyM_CertificateStatusType Result)
 *
 *********************************************************************************************************************/
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << Start of documentation area >>                  DO NOT CHANGE THIS COMMENT!
 * Symbol: Ssa_KeyM_KeyMCertificateVerifyCallback_TrustModelEcu_doc
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */

/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << End of documentation area >>                    DO NOT CHANGE THIS COMMENT!
 *********************************************************************************************************************/

FUNC(void, Ssa_KeyM_CODE) Ssa_KeyM_KeyMCertificateVerifyCallback_TrustModelEcu(KeyM_CertificateStatusType Result) /* PRQA S 0624, 3206 */ /* MD_Rte_0624, MD_Rte_3206 */
{
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << Start of runnable implementation >>             DO NOT CHANGE THIS COMMENT!
 * Symbol: Ssa_KeyM_KeyMCertificateVerifyCallback_TrustModelEcu
 *********************************************************************************************************************/
  /* #10 Handle callback parameters. */
  KeyM_DiagProc.certificateVerifyCallbackResult = Result;
  KeyM_DiagProc.certificateVerifyCallbackOccurred = TRUE;
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << End of runnable implementation >>               DO NOT CHANGE THIS COMMENT!
 *********************************************************************************************************************/
}

/**********************************************************************************************************************
 *
 * Runnable Entity Name: Ssa_KeyM_KeyMCertificateVerifyCallback_TrustModelEcuCsr
 *
 *---------------------------------------------------------------------------------------------------------------------
 *
 * Executed if at least one of the following trigger conditions occurred:
 *   - triggered by server invocation for OperationPrototype <CertificateVerifyCallbackNotification> of PortPrototype <CertificateNotification_TrustModelEcuCsr>
 *
 **********************************************************************************************************************
 *
 * Runnable prototype:
 * ===================
 *   void Ssa_KeyM_KeyMCertificateVerifyCallback_TrustModelEcuCsr(KeyM_CertificateStatusType Result)
 *
 *********************************************************************************************************************/
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << Start of documentation area >>                  DO NOT CHANGE THIS COMMENT!
 * Symbol: Ssa_KeyM_KeyMCertificateVerifyCallback_TrustModelEcuCsr_doc
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */

/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << End of documentation area >>                    DO NOT CHANGE THIS COMMENT!
 *********************************************************************************************************************/

FUNC(void, Ssa_KeyM_CODE) Ssa_KeyM_KeyMCertificateVerifyCallback_TrustModelEcuCsr(KeyM_CertificateStatusType Result) /* PRQA S 0624, 3206 */ /* MD_Rte_0624, MD_Rte_3206 */
{
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << Start of runnable implementation >>             DO NOT CHANGE THIS COMMENT!
 * Symbol: Ssa_KeyM_KeyMCertificateVerifyCallback_TrustModelEcuCsr
 *********************************************************************************************************************/
  /* discard always */
  SSA_DUMMY_STATEMENT(Result);    /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << End of runnable implementation >>               DO NOT CHANGE THIS COMMENT!
 *********************************************************************************************************************/
}

/**********************************************************************************************************************
 *
 * Runnable Entity Name: Ssa_KeyM_KeyMCertificateVerifyCallback_TrustModelEcuPeer
 *
 *---------------------------------------------------------------------------------------------------------------------
 *
 * Executed if at least one of the following trigger conditions occurred:
 *   - triggered by server invocation for OperationPrototype <CertificateVerifyCallbackNotification> of PortPrototype <CertificateNotification_TrustModelEcuPeer>
 *
 **********************************************************************************************************************
 *
 * Runnable prototype:
 * ===================
 *   void Ssa_KeyM_KeyMCertificateVerifyCallback_TrustModelEcuPeer(KeyM_CertificateStatusType Result)
 *
 *********************************************************************************************************************/
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << Start of documentation area >>                  DO NOT CHANGE THIS COMMENT!
 * Symbol: Ssa_KeyM_KeyMCertificateVerifyCallback_TrustModelEcuPeer_doc
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */

/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << End of documentation area >>                    DO NOT CHANGE THIS COMMENT!
 *********************************************************************************************************************/

FUNC(void, Ssa_KeyM_CODE) Ssa_KeyM_KeyMCertificateVerifyCallback_TrustModelEcuPeer(KeyM_CertificateStatusType Result) /* PRQA S 0624, 3206 */ /* MD_Rte_0624, MD_Rte_3206 */
{
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << Start of runnable implementation >>             DO NOT CHANGE THIS COMMENT!
 * Symbol: Ssa_KeyM_KeyMCertificateVerifyCallback_TrustModelEcuPeer
 *********************************************************************************************************************/
  /* #10 Handle callback parameters. */
  KeyM_DiagProc.certificateVerifyCallbackResult = Result;
  KeyM_DiagProc.certificateVerifyCallbackOccurred = TRUE;
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << End of runnable implementation >>               DO NOT CHANGE THIS COMMENT!
 *********************************************************************************************************************/
}

/**********************************************************************************************************************
 *
 * Runnable Entity Name: Ssa_KeyM_KeyMCertificateVerifyCallback_TrustModelIntermediate
 *
 *---------------------------------------------------------------------------------------------------------------------
 *
 * Executed if at least one of the following trigger conditions occurred:
 *   - triggered by server invocation for OperationPrototype <CertificateVerifyCallbackNotification> of PortPrototype <CertificateNotification_TrustModelIntermediate>
 *
 **********************************************************************************************************************
 *
 * Runnable prototype:
 * ===================
 *   void Ssa_KeyM_KeyMCertificateVerifyCallback_TrustModelIntermediate(KeyM_CertificateStatusType Result)
 *
 *********************************************************************************************************************/
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << Start of documentation area >>                  DO NOT CHANGE THIS COMMENT!
 * Symbol: Ssa_KeyM_KeyMCertificateVerifyCallback_TrustModelIntermediate_doc
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */

/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << End of documentation area >>                    DO NOT CHANGE THIS COMMENT!
 *********************************************************************************************************************/

FUNC(void, Ssa_KeyM_CODE) Ssa_KeyM_KeyMCertificateVerifyCallback_TrustModelIntermediate(KeyM_CertificateStatusType Result) /* PRQA S 0624, 3206 */ /* MD_Rte_0624, MD_Rte_3206 */
{
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << Start of runnable implementation >>             DO NOT CHANGE THIS COMMENT!
 * Symbol: Ssa_KeyM_KeyMCertificateVerifyCallback_TrustModelIntermediate
 *********************************************************************************************************************/
  /* discard if result indicates no error */
  if (Result != KEYM_RT_OK)
  {
    /* Handle callback parameters. */
    KeyM_DiagProc.certificateVerifyCallbackResult = Result;
    KeyM_DiagProc.certificateVerifyCallbackOccurred = TRUE;
  }
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << End of runnable implementation >>               DO NOT CHANGE THIS COMMENT!
 *********************************************************************************************************************/
}

/**********************************************************************************************************************
 *
 * Runnable Entity Name: Ssa_KeyM_KeyMCertificateVerifyCallback_TrustModelIntermediatePeer
 *
 *---------------------------------------------------------------------------------------------------------------------
 *
 * Executed if at least one of the following trigger conditions occurred:
 *   - triggered by server invocation for OperationPrototype <CertificateVerifyCallbackNotification> of PortPrototype <CertificateNotification_TrustModelIntermediatePeer>
 *
 **********************************************************************************************************************
 *
 * Runnable prototype:
 * ===================
 *   void Ssa_KeyM_KeyMCertificateVerifyCallback_TrustModelIntermediatePeer(KeyM_CertificateStatusType Result)
 *
 *********************************************************************************************************************/
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << Start of documentation area >>                  DO NOT CHANGE THIS COMMENT!
 * Symbol: Ssa_KeyM_KeyMCertificateVerifyCallback_TrustModelIntermediatePeer_doc
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */

/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << End of documentation area >>                    DO NOT CHANGE THIS COMMENT!
 *********************************************************************************************************************/

FUNC(void, Ssa_KeyM_CODE) Ssa_KeyM_KeyMCertificateVerifyCallback_TrustModelIntermediatePeer(KeyM_CertificateStatusType Result) /* PRQA S 0624, 3206 */ /* MD_Rte_0624, MD_Rte_3206 */
{
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << Start of runnable implementation >>             DO NOT CHANGE THIS COMMENT!
 * Symbol: Ssa_KeyM_KeyMCertificateVerifyCallback_TrustModelIntermediatePeer
 *********************************************************************************************************************/
  /* discard if result indicates no error */
  if (Result != KEYM_RT_OK)
  {
    /* Handle callback parameters. */
    KeyM_DiagProc.certificateVerifyCallbackResult = Result;
    KeyM_DiagProc.certificateVerifyCallbackOccurred = TRUE;
  }
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << End of runnable implementation >>               DO NOT CHANGE THIS COMMENT!
 *********************************************************************************************************************/
}

/**********************************************************************************************************************
 *
 * Runnable Entity Name: Ssa_KeyM_KeyMCertificateVerifyCallback_TrustModelRoot
 *
 *---------------------------------------------------------------------------------------------------------------------
 *
 * Executed if at least one of the following trigger conditions occurred:
 *   - triggered by server invocation for OperationPrototype <CertificateVerifyCallbackNotification> of PortPrototype <CertificateNotification_TrustModelRoot>
 *
 **********************************************************************************************************************
 *
 * Runnable prototype:
 * ===================
 *   void Ssa_KeyM_KeyMCertificateVerifyCallback_TrustModelRoot(KeyM_CertificateStatusType Result)
 *
 *********************************************************************************************************************/
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << Start of documentation area >>                  DO NOT CHANGE THIS COMMENT!
 * Symbol: Ssa_KeyM_KeyMCertificateVerifyCallback_TrustModelRoot_doc
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */

/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << End of documentation area >>                    DO NOT CHANGE THIS COMMENT!
 *********************************************************************************************************************/

FUNC(void, Ssa_KeyM_CODE) Ssa_KeyM_KeyMCertificateVerifyCallback_TrustModelRoot(KeyM_CertificateStatusType Result) /* PRQA S 0624, 3206 */ /* MD_Rte_0624, MD_Rte_3206 */
{
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << Start of runnable implementation >>             DO NOT CHANGE THIS COMMENT!
 * Symbol: Ssa_KeyM_KeyMCertificateVerifyCallback_TrustModelRoot
 *********************************************************************************************************************/
  /* discard always */
  SSA_DUMMY_STATEMENT(Result);    /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << End of runnable implementation >>               DO NOT CHANGE THIS COMMENT!
 *********************************************************************************************************************/
}

/**********************************************************************************************************************
 *
 * Runnable Entity Name: Ssa_KeyM_KeyMServiceCertificateCallback_TrustModelBackend
 *
 *---------------------------------------------------------------------------------------------------------------------
 *
 * Executed if at least one of the following trigger conditions occurred:
 *   - triggered by server invocation for OperationPrototype <ServiceCertificateCallbackNotification> of PortPrototype <CertificateNotification_TrustModelBackend>
 *
 **********************************************************************************************************************
 *
 * Runnable prototype:
 * ===================
 *   void Ssa_KeyM_KeyMServiceCertificateCallback_TrustModelBackend(KeyM_ResultType Result, uint16 ResponseDataLength, KeyM_const_CryptoKeyDataType ResponseData)
 *
 *********************************************************************************************************************/
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << Start of documentation area >>                  DO NOT CHANGE THIS COMMENT!
 * Symbol: Ssa_KeyM_KeyMServiceCertificateCallback_TrustModelBackend_doc
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */

/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << End of documentation area >>                    DO NOT CHANGE THIS COMMENT!
 *********************************************************************************************************************/

FUNC(void, Ssa_KeyM_CODE) Ssa_KeyM_KeyMServiceCertificateCallback_TrustModelBackend(KeyM_ResultType Result, uint16 ResponseDataLength, KeyM_const_CryptoKeyDataType ResponseData) /* PRQA S 0624, 3206 */ /* MD_Rte_0624, MD_Rte_3206 */
{
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << Start of runnable implementation >>             DO NOT CHANGE THIS COMMENT!
 * Symbol: Ssa_KeyM_KeyMServiceCertificateCallback_TrustModelBackend
 *********************************************************************************************************************/
  /* #10 Handle callback parameters. */
  KeyM_DiagProc.serviceResponseCallbackResult = Result;
  KeyM_DiagProc.serviceResponseCallbackOccurred = TRUE;
  KeyM_DiagProc.serviceResponseBufferLength = ResponseDataLength;
  SSA_DUMMY_STATEMENT_CONST(ResponseData);   /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << End of runnable implementation >>               DO NOT CHANGE THIS COMMENT!
 *********************************************************************************************************************/
}

/**********************************************************************************************************************
 *
 * Runnable Entity Name: Ssa_KeyM_KeyMServiceCertificateCallback_TrustModelBackendPeer
 *
 *---------------------------------------------------------------------------------------------------------------------
 *
 * Executed if at least one of the following trigger conditions occurred:
 *   - triggered by server invocation for OperationPrototype <ServiceCertificateCallbackNotification> of PortPrototype <CertificateNotification_TrustModelBackendPeer>
 *
 **********************************************************************************************************************
 *
 * Runnable prototype:
 * ===================
 *   void Ssa_KeyM_KeyMServiceCertificateCallback_TrustModelBackendPeer(KeyM_ResultType Result, uint16 ResponseDataLength, KeyM_const_CryptoKeyDataType ResponseData)
 *
 *********************************************************************************************************************/
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << Start of documentation area >>                  DO NOT CHANGE THIS COMMENT!
 * Symbol: Ssa_KeyM_KeyMServiceCertificateCallback_TrustModelBackendPeer_doc
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << End of documentation area >>                    DO NOT CHANGE THIS COMMENT!
 *********************************************************************************************************************/

FUNC(void, Ssa_KeyM_CODE) Ssa_KeyM_KeyMServiceCertificateCallback_TrustModelBackendPeer(KeyM_ResultType Result, uint16 ResponseDataLength, KeyM_const_CryptoKeyDataType ResponseData) /* PRQA S 0624, 3206 */ /* MD_Rte_0624, MD_Rte_3206 */
{
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << Start of runnable implementation >>             DO NOT CHANGE THIS COMMENT!
 * Symbol: Ssa_KeyM_KeyMServiceCertificateCallback_TrustModelBackendPeer
 *********************************************************************************************************************/
  /* discard always */
  SSA_DUMMY_STATEMENT(Result);    /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */
  SSA_DUMMY_STATEMENT(ResponseDataLength);    /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */
  SSA_DUMMY_STATEMENT_CONST(ResponseData);    /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << End of runnable implementation >>               DO NOT CHANGE THIS COMMENT!
 *********************************************************************************************************************/
}

/**********************************************************************************************************************
 *
 * Runnable Entity Name: Ssa_KeyM_KeyMServiceCertificateCallback_TrustModelEcu
 *
 *---------------------------------------------------------------------------------------------------------------------
 *
 * Executed if at least one of the following trigger conditions occurred:
 *   - triggered by server invocation for OperationPrototype <ServiceCertificateCallbackNotification> of PortPrototype <CertificateNotification_TrustModelEcu>
 *
 **********************************************************************************************************************
 *
 * Runnable prototype:
 * ===================
 *   void Ssa_KeyM_KeyMServiceCertificateCallback_TrustModelEcu(KeyM_ResultType Result, uint16 ResponseDataLength, KeyM_const_CryptoKeyDataType ResponseData)
 *
 *********************************************************************************************************************/
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << Start of documentation area >>                  DO NOT CHANGE THIS COMMENT!
 * Symbol: Ssa_KeyM_KeyMServiceCertificateCallback_TrustModelEcu_doc
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << End of documentation area >>                    DO NOT CHANGE THIS COMMENT!
 *********************************************************************************************************************/

FUNC(void, Ssa_KeyM_CODE) Ssa_KeyM_KeyMServiceCertificateCallback_TrustModelEcu(KeyM_ResultType Result, uint16 ResponseDataLength, KeyM_const_CryptoKeyDataType ResponseData) /* PRQA S 0624, 3206 */ /* MD_Rte_0624, MD_Rte_3206 */
{
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << Start of runnable implementation >>             DO NOT CHANGE THIS COMMENT!
 * Symbol: Ssa_KeyM_KeyMServiceCertificateCallback_TrustModelEcu
 *********************************************************************************************************************/
  /* discard always */
  SSA_DUMMY_STATEMENT(Result);    /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */
  SSA_DUMMY_STATEMENT(ResponseDataLength);    /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */
  SSA_DUMMY_STATEMENT_CONST(ResponseData);    /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << End of runnable implementation >>               DO NOT CHANGE THIS COMMENT!
 *********************************************************************************************************************/
}

/**********************************************************************************************************************
 *
 * Runnable Entity Name: Ssa_KeyM_KeyMServiceCertificateCallback_TrustModelEcuCsr
 *
 *---------------------------------------------------------------------------------------------------------------------
 *
 * Executed if at least one of the following trigger conditions occurred:
 *   - triggered by server invocation for OperationPrototype <ServiceCertificateCallbackNotification> of PortPrototype <CertificateNotification_TrustModelEcuCsr>
 *
 **********************************************************************************************************************
 *
 * Runnable prototype:
 * ===================
 *   void Ssa_KeyM_KeyMServiceCertificateCallback_TrustModelEcuCsr(KeyM_ResultType Result, uint16 ResponseDataLength, KeyM_const_CryptoKeyDataType ResponseData)
 *
 *********************************************************************************************************************/
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << Start of documentation area >>                  DO NOT CHANGE THIS COMMENT!
 * Symbol: Ssa_KeyM_KeyMServiceCertificateCallback_TrustModelEcuCsr_doc
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << End of documentation area >>                    DO NOT CHANGE THIS COMMENT!
 *********************************************************************************************************************/

FUNC(void, Ssa_KeyM_CODE) Ssa_KeyM_KeyMServiceCertificateCallback_TrustModelEcuCsr(KeyM_ResultType Result, uint16 ResponseDataLength, KeyM_const_CryptoKeyDataType ResponseData) /* PRQA S 0624, 3206 */ /* MD_Rte_0624, MD_Rte_3206 */
{
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << Start of runnable implementation >>             DO NOT CHANGE THIS COMMENT!
 * Symbol: Ssa_KeyM_KeyMServiceCertificateCallback_TrustModelEcuCsr
 *********************************************************************************************************************/
  /* #10 Handle callback parameters. */
  KeyM_DiagProc.serviceResponseCallbackResult = Result;
  KeyM_DiagProc.serviceResponseCallbackOccurred = TRUE;
  KeyM_DiagProc.serviceResponseBufferLength = ResponseDataLength;
  SSA_DUMMY_STATEMENT_CONST(ResponseData);   /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << End of runnable implementation >>               DO NOT CHANGE THIS COMMENT!
 *********************************************************************************************************************/
}

/**********************************************************************************************************************
 *
 * Runnable Entity Name: Ssa_KeyM_KeyMServiceCertificateCallback_TrustModelEcuPeer
 *
 *---------------------------------------------------------------------------------------------------------------------
 *
 * Executed if at least one of the following trigger conditions occurred:
 *   - triggered by server invocation for OperationPrototype <ServiceCertificateCallbackNotification> of PortPrototype <CertificateNotification_TrustModelEcuPeer>
 *
 **********************************************************************************************************************
 *
 * Runnable prototype:
 * ===================
 *   void Ssa_KeyM_KeyMServiceCertificateCallback_TrustModelEcuPeer(KeyM_ResultType Result, uint16 ResponseDataLength, KeyM_const_CryptoKeyDataType ResponseData)
 *
 *********************************************************************************************************************/
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << Start of documentation area >>                  DO NOT CHANGE THIS COMMENT!
 * Symbol: Ssa_KeyM_KeyMServiceCertificateCallback_TrustModelEcuPeer_doc
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << End of documentation area >>                    DO NOT CHANGE THIS COMMENT!
 *********************************************************************************************************************/

FUNC(void, Ssa_KeyM_CODE) Ssa_KeyM_KeyMServiceCertificateCallback_TrustModelEcuPeer(KeyM_ResultType Result, uint16 ResponseDataLength, KeyM_const_CryptoKeyDataType ResponseData) /* PRQA S 0624, 3206 */ /* MD_Rte_0624, MD_Rte_3206 */
{
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << Start of runnable implementation >>             DO NOT CHANGE THIS COMMENT!
 * Symbol: Ssa_KeyM_KeyMServiceCertificateCallback_TrustModelEcuPeer
 *********************************************************************************************************************/
  /* discard always */
  SSA_DUMMY_STATEMENT(Result);    /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */
  SSA_DUMMY_STATEMENT(ResponseDataLength);    /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */
  SSA_DUMMY_STATEMENT_CONST(ResponseData);    /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << End of runnable implementation >>               DO NOT CHANGE THIS COMMENT!
 *********************************************************************************************************************/
}

/**********************************************************************************************************************
 *
 * Runnable Entity Name: Ssa_KeyM_KeyMServiceCertificateCallback_TrustModelIntermediate
 *
 *---------------------------------------------------------------------------------------------------------------------
 *
 * Executed if at least one of the following trigger conditions occurred:
 *   - triggered by server invocation for OperationPrototype <ServiceCertificateCallbackNotification> of PortPrototype <CertificateNotification_TrustModelIntermediate>
 *
 **********************************************************************************************************************
 *
 * Runnable prototype:
 * ===================
 *   void Ssa_KeyM_KeyMServiceCertificateCallback_TrustModelIntermediate(KeyM_ResultType Result, uint16 ResponseDataLength, KeyM_const_CryptoKeyDataType ResponseData)
 *
 *********************************************************************************************************************/
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << Start of documentation area >>                  DO NOT CHANGE THIS COMMENT!
 * Symbol: Ssa_KeyM_KeyMServiceCertificateCallback_TrustModelIntermediate_doc
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << End of documentation area >>                    DO NOT CHANGE THIS COMMENT!
 *********************************************************************************************************************/

FUNC(void, Ssa_KeyM_CODE) Ssa_KeyM_KeyMServiceCertificateCallback_TrustModelIntermediate(KeyM_ResultType Result, uint16 ResponseDataLength, KeyM_const_CryptoKeyDataType ResponseData) /* PRQA S 0624, 3206 */ /* MD_Rte_0624, MD_Rte_3206 */
{
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << Start of runnable implementation >>             DO NOT CHANGE THIS COMMENT!
 * Symbol: Ssa_KeyM_KeyMServiceCertificateCallback_TrustModelIntermediate
 *********************************************************************************************************************/
  /* #10 Handle callback parameters. */
  KeyM_DiagProc.serviceResponseCallbackResult = Result;
  KeyM_DiagProc.serviceResponseCallbackOccurred = TRUE;
  KeyM_DiagProc.serviceResponseBufferLength = ResponseDataLength;
  SSA_DUMMY_STATEMENT_CONST(ResponseData);   /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << End of runnable implementation >>               DO NOT CHANGE THIS COMMENT!
 *********************************************************************************************************************/
}

/**********************************************************************************************************************
 *
 * Runnable Entity Name: Ssa_KeyM_KeyMServiceCertificateCallback_TrustModelIntermediatePeer
 *
 *---------------------------------------------------------------------------------------------------------------------
 *
 * Executed if at least one of the following trigger conditions occurred:
 *   - triggered by server invocation for OperationPrototype <ServiceCertificateCallbackNotification> of PortPrototype <CertificateNotification_TrustModelIntermediatePeer>
 *
 **********************************************************************************************************************
 *
 * Runnable prototype:
 * ===================
 *   void Ssa_KeyM_KeyMServiceCertificateCallback_TrustModelIntermediatePeer(KeyM_ResultType Result, uint16 ResponseDataLength, KeyM_const_CryptoKeyDataType ResponseData)
 *
 *********************************************************************************************************************/
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << Start of documentation area >>                  DO NOT CHANGE THIS COMMENT!
 * Symbol: Ssa_KeyM_KeyMServiceCertificateCallback_TrustModelIntermediatePeer_doc
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << End of documentation area >>                    DO NOT CHANGE THIS COMMENT!
 *********************************************************************************************************************/

FUNC(void, Ssa_KeyM_CODE) Ssa_KeyM_KeyMServiceCertificateCallback_TrustModelIntermediatePeer(KeyM_ResultType Result, uint16 ResponseDataLength, KeyM_const_CryptoKeyDataType ResponseData) /* PRQA S 0624, 3206 */ /* MD_Rte_0624, MD_Rte_3206 */
{
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << Start of runnable implementation >>             DO NOT CHANGE THIS COMMENT!
 * Symbol: Ssa_KeyM_KeyMServiceCertificateCallback_TrustModelIntermediatePeer
 *********************************************************************************************************************/
  /* discard always */
  SSA_DUMMY_STATEMENT(Result);    /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */
  SSA_DUMMY_STATEMENT(ResponseDataLength);    /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */
  SSA_DUMMY_STATEMENT_CONST(ResponseData);    /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << End of runnable implementation >>               DO NOT CHANGE THIS COMMENT!
 *********************************************************************************************************************/
}

/**********************************************************************************************************************
 *
 * Runnable Entity Name: Ssa_KeyM_KeyMServiceCertificateCallback_TrustModelRoot
 *
 *---------------------------------------------------------------------------------------------------------------------
 *
 * Executed if at least one of the following trigger conditions occurred:
 *   - triggered by server invocation for OperationPrototype <ServiceCertificateCallbackNotification> of PortPrototype <CertificateNotification_TrustModelRoot>
 *
 **********************************************************************************************************************
 *
 * Runnable prototype:
 * ===================
 *   void Ssa_KeyM_KeyMServiceCertificateCallback_TrustModelRoot(KeyM_ResultType Result, uint16 ResponseDataLength, KeyM_const_CryptoKeyDataType ResponseData)
 *
 *********************************************************************************************************************/
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << Start of documentation area >>                  DO NOT CHANGE THIS COMMENT!
 * Symbol: Ssa_KeyM_KeyMServiceCertificateCallback_TrustModelRoot_doc
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << End of documentation area >>                    DO NOT CHANGE THIS COMMENT!
 *********************************************************************************************************************/

FUNC(void, Ssa_KeyM_CODE) Ssa_KeyM_KeyMServiceCertificateCallback_TrustModelRoot(KeyM_ResultType Result, uint16 ResponseDataLength, KeyM_const_CryptoKeyDataType ResponseData) /* PRQA S 0624, 3206 */ /* MD_Rte_0624, MD_Rte_3206 */
{
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << Start of runnable implementation >>             DO NOT CHANGE THIS COMMENT!
 * Symbol: Ssa_KeyM_KeyMServiceCertificateCallback_TrustModelRoot
 *********************************************************************************************************************/
  /* #10 Handle callback parameters. */
  KeyM_DiagProc.serviceResponseCallbackResult = Result;
  KeyM_DiagProc.serviceResponseCallbackOccurred = TRUE;
  KeyM_DiagProc.serviceResponseBufferLength = ResponseDataLength;
  SSA_DUMMY_STATEMENT_CONST(ResponseData);   /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << End of runnable implementation >>               DO NOT CHANGE THIS COMMENT!
 *********************************************************************************************************************/
}

/**********************************************************************************************************************
 *
 * Runnable Entity Name: Ssa_KeyM_MainFunction
 *
 *---------------------------------------------------------------------------------------------------------------------
 *
 * Executed if at least one of the following trigger conditions occurred:
 *   - triggered on TimingEvent every 10ms
 *
 **********************************************************************************************************************
 *
 * Mode Interfaces:
 * ================
 *   Std_ReturnType Rte_Switch_Ssa_MacKeyGeneration_State_State(Ssa_OnOff_StateType mode)
 *   Modes of Rte_ModeType_Ssa_MacKeyGeneration_State:
 *   - RTE_MODE_Ssa_MacKeyGeneration_State_SSA_MAC_KEY_GEN_STATE_OFF
 *   - RTE_MODE_Ssa_MacKeyGeneration_State_SSA_MAC_KEY_GEN_STATE_ON
 *   - RTE_TRANSITION_Ssa_MacKeyGeneration_State
 *
 * Client/Server Interfaces:
 * =========================
 *   Server Invocation:
 *   ------------------
 *   Std_ReturnType Rte_Call_Coding_VIN_Get(uint8 *vin)
 *     Argument vin: uint8* is of type Coding_VINDataType
 *     Synchronous Server Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_Coding_VIN_E_NOT_OK
 *   Std_ReturnType Rte_Call_SsaCdd_Csm_Hash(uint32 jobId, Crypto_OperationModeType operationMode, Ssa_ConstDataPtr dataBuffer, uint32 dataLength, Ssa_DataPtr resultBuffer, Ssa_LengthPtr resultLength)
 *     Synchronous Server Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_SsaCdd_CryptoInterface_E_NOT_OK
 *   Std_ReturnType Rte_Call_SsaCdd_Keys_KeyElementSet(uint32 keyId, uint32 keyElementId, Ssa_ConstDataPtr keyPtr, uint32 keyLength)
 *     Synchronous Server Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_SsaCdd_Csm_KeyInterface_E_BUSY, RTE_E_SsaCdd_Csm_KeyInterface_E_NOT_OK
 *   Std_ReturnType Rte_Call_SsaCdd_Keys_KeySetValid(uint32 keyId)
 *     Synchronous Server Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_SsaCdd_Csm_KeyInterface_E_BUSY, RTE_E_SsaCdd_Csm_KeyInterface_E_NOT_OK
 *   Std_ReturnType Rte_Call_Ssa_KeyStorage_StorePermanently(Ssa_KeyStorageUseCaseType keyStorageUseCase, Ssa_KeyStorageTaskType keyStorageTask)
 *     Synchronous Server Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_Ssa_KeyStorage_E_NOT_OK, RTE_E_Ssa_KeyStorage_E_PENDING
 *   Std_ReturnType Rte_Call_TimeM_TimeRawData_ResetLocalTickCount(void)
 *     Synchronous Server Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_TimeM_TimeRawData_E_NOT_OK
 *
 * Service Calls:
 * ==============
 *   Service Invocation:
 *   -------------------
 *   Std_ReturnType Rte_Call_Key_EcuCert_KeyElementGet(uint32 keyElementId, uint8 *keyPtr, uint32 *keyLength)
 *     Argument keyPtr: uint8* is of type Csm_KeyDataType_Ssa_EcuCert
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_CsmKeyManagement_Ssa_EcuCert_CSM_E_BUSY, RTE_E_CsmKeyManagement_Ssa_EcuCert_CSM_E_KEY_EMPTY, RTE_E_CsmKeyManagement_Ssa_EcuCert_CSM_E_KEY_NOT_AVAILABLE, RTE_E_CsmKeyManagement_Ssa_EcuCert_CSM_E_KEY_READ_FAIL, RTE_E_CsmKeyManagement_Ssa_EcuCert_CSM_E_SMALL_BUFFER, RTE_E_CsmKeyManagement_Ssa_EcuCert_E_NOT_OK
 *   Std_ReturnType Rte_Call_Key_SharedSecretHash_KeyElementSet(uint32 keyElementId, const uint8 *keyPtr, uint32 keyLength)
 *     Argument keyPtr: uint8* is of type Csm_KeyDataType_Ssa_SharedSecretHash
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_CsmKeyManagement_Ssa_SharedSecretHash_CSM_E_BUSY, RTE_E_CsmKeyManagement_Ssa_SharedSecretHash_CSM_E_KEY_NOT_AVAILABLE, RTE_E_CsmKeyManagement_Ssa_SharedSecretHash_CSM_E_KEY_SIZE_MISMATCH, RTE_E_CsmKeyManagement_Ssa_SharedSecretHash_CSM_E_KEY_WRITE_FAIL, RTE_E_CsmKeyManagement_Ssa_SharedSecretHash_CSM_E_SMALL_BUFFER, RTE_E_CsmKeyManagement_Ssa_SharedSecretHash_E_NOT_OK
 *   Std_ReturnType Rte_Call_Key_SharedSecretHash_KeySetValid(void)
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_CsmKeyManagement_Ssa_SharedSecretHash_CSM_E_BUSY, RTE_E_CsmKeyManagement_Ssa_SharedSecretHash_E_NOT_OK
 *
 *********************************************************************************************************************/
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << Start of documentation area >>                  DO NOT CHANGE THIS COMMENT!
 * Symbol: Ssa_KeyM_MainFunction_doc
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << End of documentation area >>                    DO NOT CHANGE THIS COMMENT!
 *********************************************************************************************************************/

FUNC(void, Ssa_KeyM_CODE) Ssa_KeyM_MainFunction(void) /* PRQA S 0624, 3206 */ /* MD_Rte_0624, MD_Rte_3206 */
{
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << Start of runnable implementation >>             DO NOT CHANGE THIS COMMENT!
 * Symbol: Ssa_KeyM_MainFunction
 *********************************************************************************************************************/

  /* #10 Handle the mainloop states only if not in state IDLE and not locked. */
  if (KeyM_MainLoopProc.state > KEYM_GENERATE_SYM_KEYS_STATE_LOCKED)
  {
    Std_ReturnType retVal;

    if (KeyM_MainLoopProc.state == KEYM_GENERATE_SYM_KEYS_STATE_HASH_SECRET)
    {
      retVal = KeyM_StoreSecretHash(KeyM_CarSpecificSecret);

      /* #35 If succeeded change to the next processing step depending on the configuration of the mainloop processing.
       *     Clear secret if key generation does not follow. */
      if (retVal != E_OK)
      {
        /* write result buffer only if mainloop processing has not been triggered by CSS broadcast reception */
        if ((KeyM_MainLoopProc.conf&KEY_MAINLOOP_PROC_CONF_BROADCAST_PROC) == 0u)
        {
          KeyM_MainLoopProc.result = E_NOT_OK;
        }
        /* reset state */
        KeyM_MainLoopProc.state = KEYM_GENERATE_SYM_KEYS_STATE_IDLE;
      }
      else if ((KeyM_MainLoopProc.conf&KEY_MAINLOOP_PROC_CONF_NO_KEY_DERIVATION) == KEY_MAINLOOP_PROC_CONF_NO_KEY_DERIVATION)
      {
        /* set next state mainloop processing is finished */
        KeyM_MainLoopProc.state = KEYM_GENERATE_SYM_KEYS_STATE_IDLE;
        /* Clear shared secret from RAM. */
        KeyM_ClearDataBuffer(KeyM_CarSpecificSecret, SSA_SIZEOF_SECRET, SSA_SIZEOF_SECRET);
      }
      else
      {
        /* set next state */
        KeyM_MainLoopProc.state = KEYM_GENERATE_SYM_KEYS_STATE_LOOP_OVER_IDS;
      }
    }
    /* #40 In state KEYM_GENERATE_SYM_KEYS_STATE_LOOP_OVER_IDS generate and store the symmetric SecOc keys in portions until
     *     all keys are generated. Clear secret if key generation is finished.
     *     Before generation is started notify application of the start of the key generation
     *     and wait for the configured number of main function cycles.
     *     When generation is finished notify of the end of key generation in any case. */
    else if (KeyM_MainLoopProc.state == KEYM_GENERATE_SYM_KEYS_STATE_LOOP_OVER_IDS)
    {
      /* notify that generation starts (is now ON) */
      if (KeyM_MainLoopProc.counterWaitBeforeGenerate == SSA_KEYM_NUMBER_WAIT_CYCLES_BEFORE_KEY_GENERATION)
      {
        (void)Rte_Switch_Ssa_KeyM_Ssa_MacKeyGeneration_State_State(RTE_MODE_Ssa_MacKeyGeneration_State_SSA_MAC_KEY_GEN_STATE_ON);
        KeyM_MainLoopProc.counterRetry = SSA_KEYM_NUMBER_RETRIES_KEY_GENERATION;
      }
      /* proceed with key generation after waiting */
      if (KeyM_MainLoopProc.counterWaitBeforeGenerate > 0u)
      {
        KeyM_MainLoopProc.counterWaitBeforeGenerate--;
      }
      else
      {
        retVal = KeyM_GenerateAndStoreSecOcKeys();
        if (retVal == E_OK)
        {
#if ((SSA_KEYM_NUMBER_RETRIES_KEY_GENERATION > 0) || (SSA_KEYM_NUMBER_KEYS_GENERATED_IN_MAIN <= Ssa_GetSizeOfDataIdInfo()))
          /* For configurations with SSA_KEYM_NUMBER_RETRIES_KEY_GENERATION==0 and SSA_KEYM_NUMBER_KEYS_GENERATED_IN_MAIN e.g. set to max value 65535
             the following condition will never become false, so the if statement is not necessary. */
          if (KeyM_MainLoopProc.numGenSymKeys == Ssa_GetSizeOfDataIdInfo())
#endif
          {
            /* notify that generation has stopped (is now OFF) */
            (void)Rte_Switch_Ssa_KeyM_Ssa_MacKeyGeneration_State_State(RTE_MODE_Ssa_MacKeyGeneration_State_SSA_MAC_KEY_GEN_STATE_OFF);

            /* set next state not before all keys have been generate, else remain in current state */
            KeyM_MainLoopProc.numGenSymKeys = 0u;
            KeyM_MainLoopProc.counterWaitBeforeGenerate = SSA_KEYM_NUMBER_WAIT_CYCLES_BEFORE_KEY_GENERATION;
            KeyM_MainLoopProc.state = KEYM_GENERATE_SYM_KEYS_STATE_STORE_INIT;
            /* Clear shared secret from RAM. */
            KeyM_ClearDataBuffer(KeyM_CarSpecificSecret, SSA_SIZEOF_SECRET, SSA_SIZEOF_SECRET);
          }
        }
        else
        {

          /* notify that generation has stopped (is now OFF) */
          (void)Rte_Switch_Ssa_KeyM_Ssa_MacKeyGeneration_State_State(RTE_MODE_Ssa_MacKeyGeneration_State_SSA_MAC_KEY_GEN_STATE_OFF);
          /* reset state */
          KeyM_MainLoopProc.result = E_NOT_OK;
          KeyM_MainLoopProc.numGenSymKeys = 0u;
          KeyM_MainLoopProc.counterWaitBeforeGenerate = SSA_KEYM_NUMBER_WAIT_CYCLES_BEFORE_KEY_GENERATION;
          KeyM_MainLoopProc.state = KEYM_GENERATE_SYM_KEYS_STATE_IDLE;
          /* Clear shared secret from RAM. */
          KeyM_ClearDataBuffer(KeyM_CarSpecificSecret, SSA_SIZEOF_SECRET, SSA_SIZEOF_SECRET);
        }
      }
    }
    /* #100 In the remaining states start and check the permanent storing of the new crypto keys. */
    else
    {
      retVal = Rte_Call_Ssa_KeyStorage_StorePermanently(SSA_KEYSTORAGE_USECASE_CRYPTO,
        (KeyM_MainLoopProc.state == KEYM_GENERATE_SYM_KEYS_STATE_STORE_INIT) ? SSA_KEYSTORAGE_TASK_INITIAL : SSA_KEYSTORAGE_TASK_CHECKSTATE);
      if (retVal == RTE_E_Ssa_KeyStorage_E_PENDING)
      {
        KeyM_MainLoopProc.state = KEYM_GENERATE_SYM_KEYS_STATE_STORE_PENDING;
      }
      else
      {
        /* #110 Reset local tick-count if requested. */
        if ((retVal == RTE_E_OK) && ((KeyM_MainLoopProc.conf&KEY_MAINLOOP_PROC_CONF_RESET_TICK_COUNT) == KEY_MAINLOOP_PROC_CONF_RESET_TICK_COUNT))
        {
          (void)Rte_Call_TimeM_TimeRawData_ResetLocalTickCount();
        }
        /* write result buffer only if mainloop processing has not been triggered by CSS broadcast reception */
        if ((KeyM_MainLoopProc.conf&KEY_MAINLOOP_PROC_CONF_BROADCAST_PROC) == 0u)
        {
          KeyM_MainLoopProc.result = (retVal == RTE_E_OK) ? E_OK : E_NOT_OK;
        }
        /* reset state */
        KeyM_MainLoopProc.state = KEYM_GENERATE_SYM_KEYS_STATE_IDLE;
      }
    }
  }
  /* PRQA S 6030, 6080 4 */ /* MD_MSR_STCYC, MD_MSR_STMIF */
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << End of runnable implementation >>               DO NOT CHANGE THIS COMMENT!
 *********************************************************************************************************************/
}

/**********************************************************************************************************************
 *
 * Runnable Entity Name: Ssa_KeyM_RoutineServices_Get_Certificate_Entry_Start
 *
 *---------------------------------------------------------------------------------------------------------------------
 *
 * Executed if at least one of the following trigger conditions occurred:
 *   - triggered by server invocation for OperationPrototype <Start> of PortPrototype <RoutineServices_Get_Certificate_Entry>
 *
 **********************************************************************************************************************
 *
 * Client/Server Interfaces:
 * =========================
 *   Server Invocation:
 *   ------------------
 *   Std_ReturnType Rte_Call_CertP_Functions_AttributeCertificate_Parse(const uint8 *rawCertData, uint16 rawCertLength, CertP_ParsedCertStructureType *parsedCert)
 *     Argument rawCertData: uint8* is of type CertP_RawCertBufferType
 *     Synchronous Server Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_CertP_Functions_E_NOT_OK
 *   Std_ReturnType Rte_Call_CertP_Functions_Certificate_Parse(const uint8 *rawCertData, uint16 rawCertLength, CertP_ParsedCertStructureType *parsedCert)
 *     Argument rawCertData: uint8* is of type CertP_RawCertBufferType
 *     Synchronous Server Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_CertP_Functions_E_NOT_OK
 *
 * Service Calls:
 * ==============
 *   Service Invocation:
 *   -------------------
 *   Std_ReturnType Rte_Call_KeyMCertificateElement_Ssa_TrustModelBackendCert_Issuer_CertificateElementGet(uint8 *CertificateElementData, uint32 *CertificateDataLength)
 *     Argument CertificateElementData: uint8* is of type KeyM_CertificateElementType_Ssa_TrustModelBackendCert_Issuer
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_KeyMCertificateElement_Ssa_TrustModelBackendCert_Issuer_E_NOT_OK, RTE_E_KeyMCertificateElement_Ssa_TrustModelBackendCert_Issuer_KEYM_E_KEY_CERT_EMPTY, RTE_E_KeyMCertificateElement_Ssa_TrustModelBackendCert_Issuer_KEYM_E_KEY_CERT_INVALID, RTE_E_KeyMCertificateElement_Ssa_TrustModelBackendCert_Issuer_KEYM_E_KEY_CERT_SIZE_MISMATCH, RTE_E_KeyMCertificateElement_Ssa_TrustModelBackendCert_Issuer_KEYM_E_PARAMETER_MISMATCH
 *   Std_ReturnType Rte_Call_KeyMCertificateElement_Ssa_TrustModelBackendCert_SerialNo_CertificateElementGet(uint8 *CertificateElementData, uint32 *CertificateDataLength)
 *     Argument CertificateElementData: uint8* is of type KeyM_CertificateElementType_Ssa_TrustModelBackendCert_SerialNo
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_KeyMCertificateElement_Ssa_TrustModelBackendCert_SerialNo_E_NOT_OK, RTE_E_KeyMCertificateElement_Ssa_TrustModelBackendCert_SerialNo_KEYM_E_KEY_CERT_EMPTY, RTE_E_KeyMCertificateElement_Ssa_TrustModelBackendCert_SerialNo_KEYM_E_KEY_CERT_INVALID, RTE_E_KeyMCertificateElement_Ssa_TrustModelBackendCert_SerialNo_KEYM_E_KEY_CERT_SIZE_MISMATCH, RTE_E_KeyMCertificateElement_Ssa_TrustModelBackendCert_SerialNo_KEYM_E_PARAMETER_MISMATCH
 *   Std_ReturnType Rte_Call_KeyMCertificateElement_Ssa_TrustModelBackendCert_SubjectPublicKeyInfoKey_CertificateElementGet(uint8 *CertificateElementData, uint32 *CertificateDataLength)
 *     Argument CertificateElementData: uint8* is of type KeyM_CertificateElementType_Ssa_TrustModelBackendCert_SubjectPublicKeyInfoKey
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_KeyMCertificateElement_Ssa_TrustModelBackendCert_SubjectPublicKeyInfoKey_E_NOT_OK, RTE_E_KeyMCertificateElement_Ssa_TrustModelBackendCert_SubjectPublicKeyInfoKey_KEYM_E_KEY_CERT_EMPTY, RTE_E_KeyMCertificateElement_Ssa_TrustModelBackendCert_SubjectPublicKeyInfoKey_KEYM_E_KEY_CERT_INVALID, RTE_E_KeyMCertificateElement_Ssa_TrustModelBackendCert_SubjectPublicKeyInfoKey_KEYM_E_KEY_CERT_SIZE_MISMATCH, RTE_E_KeyMCertificateElement_Ssa_TrustModelBackendCert_SubjectPublicKeyInfoKey_KEYM_E_PARAMETER_MISMATCH
 *   Std_ReturnType Rte_Call_KeyMCertificateElement_Ssa_TrustModelBackendCert_ext_authKeyId_CertificateElementGet(uint8 *CertificateElementData, uint32 *CertificateDataLength)
 *     Argument CertificateElementData: uint8* is of type KeyM_CertificateElementType_Ssa_TrustModelBackendCert_ext_authKeyId
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_KeyMCertificateElement_Ssa_TrustModelBackendCert_ext_authKeyId_E_NOT_OK, RTE_E_KeyMCertificateElement_Ssa_TrustModelBackendCert_ext_authKeyId_KEYM_E_KEY_CERT_EMPTY, RTE_E_KeyMCertificateElement_Ssa_TrustModelBackendCert_ext_authKeyId_KEYM_E_KEY_CERT_INVALID, RTE_E_KeyMCertificateElement_Ssa_TrustModelBackendCert_ext_authKeyId_KEYM_E_KEY_CERT_SIZE_MISMATCH, RTE_E_KeyMCertificateElement_Ssa_TrustModelBackendCert_ext_authKeyId_KEYM_E_PARAMETER_MISMATCH
 *   Std_ReturnType Rte_Call_KeyMCertificateElement_Ssa_TrustModelBackendCert_ext_subKeyId_CertificateElementGet(uint8 *CertificateElementData, uint32 *CertificateDataLength)
 *     Argument CertificateElementData: uint8* is of type KeyM_CertificateElementType_Ssa_TrustModelBackendCert_ext_subKeyId
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_KeyMCertificateElement_Ssa_TrustModelBackendCert_ext_subKeyId_E_NOT_OK, RTE_E_KeyMCertificateElement_Ssa_TrustModelBackendCert_ext_subKeyId_KEYM_E_KEY_CERT_EMPTY, RTE_E_KeyMCertificateElement_Ssa_TrustModelBackendCert_ext_subKeyId_KEYM_E_KEY_CERT_INVALID, RTE_E_KeyMCertificateElement_Ssa_TrustModelBackendCert_ext_subKeyId_KEYM_E_KEY_CERT_SIZE_MISMATCH, RTE_E_KeyMCertificateElement_Ssa_TrustModelBackendCert_ext_subKeyId_KEYM_E_PARAMETER_MISMATCH
 *   Std_ReturnType Rte_Call_KeyMCertificateElement_Ssa_TrustModelBackendCert_subject_CertificateElementGet(uint8 *CertificateElementData, uint32 *CertificateDataLength)
 *     Argument CertificateElementData: uint8* is of type KeyM_CertificateElementType_Ssa_TrustModelBackendCert_subject
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_KeyMCertificateElement_Ssa_TrustModelBackendCert_subject_E_NOT_OK, RTE_E_KeyMCertificateElement_Ssa_TrustModelBackendCert_subject_KEYM_E_KEY_CERT_EMPTY, RTE_E_KeyMCertificateElement_Ssa_TrustModelBackendCert_subject_KEYM_E_KEY_CERT_INVALID, RTE_E_KeyMCertificateElement_Ssa_TrustModelBackendCert_subject_KEYM_E_KEY_CERT_SIZE_MISMATCH, RTE_E_KeyMCertificateElement_Ssa_TrustModelBackendCert_subject_KEYM_E_PARAMETER_MISMATCH
 *   Std_ReturnType Rte_Call_KeyMCertificateElement_Ssa_TrustModelEcuCert_Issuer_CertificateElementGet(uint8 *CertificateElementData, uint32 *CertificateDataLength)
 *     Argument CertificateElementData: uint8* is of type KeyM_CertificateElementType_Ssa_TrustModelEcuCert_Issuer
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_KeyMCertificateElement_Ssa_TrustModelEcuCert_Issuer_E_NOT_OK, RTE_E_KeyMCertificateElement_Ssa_TrustModelEcuCert_Issuer_KEYM_E_KEY_CERT_EMPTY, RTE_E_KeyMCertificateElement_Ssa_TrustModelEcuCert_Issuer_KEYM_E_KEY_CERT_INVALID, RTE_E_KeyMCertificateElement_Ssa_TrustModelEcuCert_Issuer_KEYM_E_KEY_CERT_SIZE_MISMATCH, RTE_E_KeyMCertificateElement_Ssa_TrustModelEcuCert_Issuer_KEYM_E_PARAMETER_MISMATCH
 *   Std_ReturnType Rte_Call_KeyMCertificateElement_Ssa_TrustModelEcuCert_SerialNo_CertificateElementGet(uint8 *CertificateElementData, uint32 *CertificateDataLength)
 *     Argument CertificateElementData: uint8* is of type KeyM_CertificateElementType_Ssa_TrustModelEcuCert_SerialNo
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_KeyMCertificateElement_Ssa_TrustModelEcuCert_SerialNo_E_NOT_OK, RTE_E_KeyMCertificateElement_Ssa_TrustModelEcuCert_SerialNo_KEYM_E_KEY_CERT_EMPTY, RTE_E_KeyMCertificateElement_Ssa_TrustModelEcuCert_SerialNo_KEYM_E_KEY_CERT_INVALID, RTE_E_KeyMCertificateElement_Ssa_TrustModelEcuCert_SerialNo_KEYM_E_KEY_CERT_SIZE_MISMATCH, RTE_E_KeyMCertificateElement_Ssa_TrustModelEcuCert_SerialNo_KEYM_E_PARAMETER_MISMATCH
 *   Std_ReturnType Rte_Call_KeyMCertificateElement_Ssa_TrustModelEcuCert_SubjectPublicKeyInfoKey_CertificateElementGet(uint8 *CertificateElementData, uint32 *CertificateDataLength)
 *     Argument CertificateElementData: uint8* is of type KeyM_CertificateElementType_Ssa_TrustModelEcuCert_SubjectPublicKeyInfoKey
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_KeyMCertificateElement_Ssa_TrustModelEcuCert_SubjectPublicKeyInfoKey_E_NOT_OK, RTE_E_KeyMCertificateElement_Ssa_TrustModelEcuCert_SubjectPublicKeyInfoKey_KEYM_E_KEY_CERT_EMPTY, RTE_E_KeyMCertificateElement_Ssa_TrustModelEcuCert_SubjectPublicKeyInfoKey_KEYM_E_KEY_CERT_INVALID, RTE_E_KeyMCertificateElement_Ssa_TrustModelEcuCert_SubjectPublicKeyInfoKey_KEYM_E_KEY_CERT_SIZE_MISMATCH, RTE_E_KeyMCertificateElement_Ssa_TrustModelEcuCert_SubjectPublicKeyInfoKey_KEYM_E_PARAMETER_MISMATCH
 *   Std_ReturnType Rte_Call_KeyMCertificateElement_Ssa_TrustModelEcuCert_ext_authKeyId_CertificateElementGet(uint8 *CertificateElementData, uint32 *CertificateDataLength)
 *     Argument CertificateElementData: uint8* is of type KeyM_CertificateElementType_Ssa_TrustModelEcuCert_ext_authKeyId
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_KeyMCertificateElement_Ssa_TrustModelEcuCert_ext_authKeyId_E_NOT_OK, RTE_E_KeyMCertificateElement_Ssa_TrustModelEcuCert_ext_authKeyId_KEYM_E_KEY_CERT_EMPTY, RTE_E_KeyMCertificateElement_Ssa_TrustModelEcuCert_ext_authKeyId_KEYM_E_KEY_CERT_INVALID, RTE_E_KeyMCertificateElement_Ssa_TrustModelEcuCert_ext_authKeyId_KEYM_E_KEY_CERT_SIZE_MISMATCH, RTE_E_KeyMCertificateElement_Ssa_TrustModelEcuCert_ext_authKeyId_KEYM_E_PARAMETER_MISMATCH
 *   Std_ReturnType Rte_Call_KeyMCertificateElement_Ssa_TrustModelEcuCert_ext_specialEcu_CertificateElementGet(uint8 *CertificateElementData, uint32 *CertificateDataLength)
 *     Argument CertificateElementData: uint8* is of type KeyM_CertificateElementType_Ssa_TrustModelEcuCert_ext_specialEcu
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_KeyMCertificateElement_Ssa_TrustModelEcuCert_ext_specialEcu_E_NOT_OK, RTE_E_KeyMCertificateElement_Ssa_TrustModelEcuCert_ext_specialEcu_KEYM_E_KEY_CERT_EMPTY, RTE_E_KeyMCertificateElement_Ssa_TrustModelEcuCert_ext_specialEcu_KEYM_E_KEY_CERT_INVALID, RTE_E_KeyMCertificateElement_Ssa_TrustModelEcuCert_ext_specialEcu_KEYM_E_KEY_CERT_SIZE_MISMATCH, RTE_E_KeyMCertificateElement_Ssa_TrustModelEcuCert_ext_specialEcu_KEYM_E_PARAMETER_MISMATCH
 *   Std_ReturnType Rte_Call_KeyMCertificateElement_Ssa_TrustModelEcuCert_ext_subKeyId_CertificateElementGet(uint8 *CertificateElementData, uint32 *CertificateDataLength)
 *     Argument CertificateElementData: uint8* is of type KeyM_CertificateElementType_Ssa_TrustModelEcuCert_ext_subKeyId
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_KeyMCertificateElement_Ssa_TrustModelEcuCert_ext_subKeyId_E_NOT_OK, RTE_E_KeyMCertificateElement_Ssa_TrustModelEcuCert_ext_subKeyId_KEYM_E_KEY_CERT_EMPTY, RTE_E_KeyMCertificateElement_Ssa_TrustModelEcuCert_ext_subKeyId_KEYM_E_KEY_CERT_INVALID, RTE_E_KeyMCertificateElement_Ssa_TrustModelEcuCert_ext_subKeyId_KEYM_E_KEY_CERT_SIZE_MISMATCH, RTE_E_KeyMCertificateElement_Ssa_TrustModelEcuCert_ext_subKeyId_KEYM_E_PARAMETER_MISMATCH
 *   Std_ReturnType Rte_Call_KeyMCertificateElement_Ssa_TrustModelEcuCert_ext_uniqueECUID_CertificateElementGet(uint8 *CertificateElementData, uint32 *CertificateDataLength)
 *     Argument CertificateElementData: uint8* is of type KeyM_CertificateElementType_Ssa_TrustModelEcuCert_ext_uniqueECUID
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_KeyMCertificateElement_Ssa_TrustModelEcuCert_ext_uniqueECUID_E_NOT_OK, RTE_E_KeyMCertificateElement_Ssa_TrustModelEcuCert_ext_uniqueECUID_KEYM_E_KEY_CERT_EMPTY, RTE_E_KeyMCertificateElement_Ssa_TrustModelEcuCert_ext_uniqueECUID_KEYM_E_KEY_CERT_INVALID, RTE_E_KeyMCertificateElement_Ssa_TrustModelEcuCert_ext_uniqueECUID_KEYM_E_KEY_CERT_SIZE_MISMATCH, RTE_E_KeyMCertificateElement_Ssa_TrustModelEcuCert_ext_uniqueECUID_KEYM_E_PARAMETER_MISMATCH
 *   Std_ReturnType Rte_Call_KeyMCertificateElement_Ssa_TrustModelEcuCert_subject_CertificateElementGet(uint8 *CertificateElementData, uint32 *CertificateDataLength)
 *     Argument CertificateElementData: uint8* is of type KeyM_CertificateElementType_Ssa_TrustModelEcuCert_subject
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_KeyMCertificateElement_Ssa_TrustModelEcuCert_subject_E_NOT_OK, RTE_E_KeyMCertificateElement_Ssa_TrustModelEcuCert_subject_KEYM_E_KEY_CERT_EMPTY, RTE_E_KeyMCertificateElement_Ssa_TrustModelEcuCert_subject_KEYM_E_KEY_CERT_INVALID, RTE_E_KeyMCertificateElement_Ssa_TrustModelEcuCert_subject_KEYM_E_KEY_CERT_SIZE_MISMATCH, RTE_E_KeyMCertificateElement_Ssa_TrustModelEcuCert_subject_KEYM_E_PARAMETER_MISMATCH
 *   Std_ReturnType Rte_Call_KeyMCertificateElement_Ssa_TrustModelIntermediateCert_Issuer_CertificateElementGet(uint8 *CertificateElementData, uint32 *CertificateDataLength)
 *     Argument CertificateElementData: uint8* is of type KeyM_CertificateElementType_Ssa_TrustModelIntermediateCert_Issuer
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_KeyMCertificateElement_Ssa_TrustModelIntermediateCert_Issuer_E_NOT_OK, RTE_E_KeyMCertificateElement_Ssa_TrustModelIntermediateCert_Issuer_KEYM_E_KEY_CERT_EMPTY, RTE_E_KeyMCertificateElement_Ssa_TrustModelIntermediateCert_Issuer_KEYM_E_KEY_CERT_INVALID, RTE_E_KeyMCertificateElement_Ssa_TrustModelIntermediateCert_Issuer_KEYM_E_KEY_CERT_SIZE_MISMATCH, RTE_E_KeyMCertificateElement_Ssa_TrustModelIntermediateCert_Issuer_KEYM_E_PARAMETER_MISMATCH
 *   Std_ReturnType Rte_Call_KeyMCertificateElement_Ssa_TrustModelIntermediateCert_SerialNo_CertificateElementGet(uint8 *CertificateElementData, uint32 *CertificateDataLength)
 *     Argument CertificateElementData: uint8* is of type KeyM_CertificateElementType_Ssa_TrustModelIntermediateCert_SerialNo
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_KeyMCertificateElement_Ssa_TrustModelIntermediateCert_SerialNo_E_NOT_OK, RTE_E_KeyMCertificateElement_Ssa_TrustModelIntermediateCert_SerialNo_KEYM_E_KEY_CERT_EMPTY, RTE_E_KeyMCertificateElement_Ssa_TrustModelIntermediateCert_SerialNo_KEYM_E_KEY_CERT_INVALID, RTE_E_KeyMCertificateElement_Ssa_TrustModelIntermediateCert_SerialNo_KEYM_E_KEY_CERT_SIZE_MISMATCH, RTE_E_KeyMCertificateElement_Ssa_TrustModelIntermediateCert_SerialNo_KEYM_E_PARAMETER_MISMATCH
 *   Std_ReturnType Rte_Call_KeyMCertificateElement_Ssa_TrustModelIntermediateCert_SubjectPublicKeyInfoKey_CertificateElementGet(uint8 *CertificateElementData, uint32 *CertificateDataLength)
 *     Argument CertificateElementData: uint8* is of type KeyM_CertificateElementType_Ssa_TrustModelIntermediateCert_SubjectPublicKeyInfoKey
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_KeyMCertificateElement_Ssa_TrustModelIntermediateCert_SubjectPublicKeyInfoKey_E_NOT_OK, RTE_E_KeyMCertificateElement_Ssa_TrustModelIntermediateCert_SubjectPublicKeyInfoKey_KEYM_E_KEY_CERT_EMPTY, RTE_E_KeyMCertificateElement_Ssa_TrustModelIntermediateCert_SubjectPublicKeyInfoKey_KEYM_E_KEY_CERT_INVALID, RTE_E_KeyMCertificateElement_Ssa_TrustModelIntermediateCert_SubjectPublicKeyInfoKey_KEYM_E_KEY_CERT_SIZE_MISMATCH, RTE_E_KeyMCertificateElement_Ssa_TrustModelIntermediateCert_SubjectPublicKeyInfoKey_KEYM_E_PARAMETER_MISMATCH
 *   Std_ReturnType Rte_Call_KeyMCertificateElement_Ssa_TrustModelIntermediateCert_ext_authKeyId_CertificateElementGet(uint8 *CertificateElementData, uint32 *CertificateDataLength)
 *     Argument CertificateElementData: uint8* is of type KeyM_CertificateElementType_Ssa_TrustModelIntermediateCert_ext_authKeyId
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_KeyMCertificateElement_Ssa_TrustModelIntermediateCert_ext_authKeyId_E_NOT_OK, RTE_E_KeyMCertificateElement_Ssa_TrustModelIntermediateCert_ext_authKeyId_KEYM_E_KEY_CERT_EMPTY, RTE_E_KeyMCertificateElement_Ssa_TrustModelIntermediateCert_ext_authKeyId_KEYM_E_KEY_CERT_INVALID, RTE_E_KeyMCertificateElement_Ssa_TrustModelIntermediateCert_ext_authKeyId_KEYM_E_KEY_CERT_SIZE_MISMATCH, RTE_E_KeyMCertificateElement_Ssa_TrustModelIntermediateCert_ext_authKeyId_KEYM_E_PARAMETER_MISMATCH
 *   Std_ReturnType Rte_Call_KeyMCertificateElement_Ssa_TrustModelIntermediateCert_ext_subKeyId_CertificateElementGet(uint8 *CertificateElementData, uint32 *CertificateDataLength)
 *     Argument CertificateElementData: uint8* is of type KeyM_CertificateElementType_Ssa_TrustModelIntermediateCert_ext_subKeyId
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_KeyMCertificateElement_Ssa_TrustModelIntermediateCert_ext_subKeyId_E_NOT_OK, RTE_E_KeyMCertificateElement_Ssa_TrustModelIntermediateCert_ext_subKeyId_KEYM_E_KEY_CERT_EMPTY, RTE_E_KeyMCertificateElement_Ssa_TrustModelIntermediateCert_ext_subKeyId_KEYM_E_KEY_CERT_INVALID, RTE_E_KeyMCertificateElement_Ssa_TrustModelIntermediateCert_ext_subKeyId_KEYM_E_KEY_CERT_SIZE_MISMATCH, RTE_E_KeyMCertificateElement_Ssa_TrustModelIntermediateCert_ext_subKeyId_KEYM_E_PARAMETER_MISMATCH
 *   Std_ReturnType Rte_Call_KeyMCertificateElement_Ssa_TrustModelIntermediateCert_subject_CertificateElementGet(uint8 *CertificateElementData, uint32 *CertificateDataLength)
 *     Argument CertificateElementData: uint8* is of type KeyM_CertificateElementType_Ssa_TrustModelIntermediateCert_subject
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_KeyMCertificateElement_Ssa_TrustModelIntermediateCert_subject_E_NOT_OK, RTE_E_KeyMCertificateElement_Ssa_TrustModelIntermediateCert_subject_KEYM_E_KEY_CERT_EMPTY, RTE_E_KeyMCertificateElement_Ssa_TrustModelIntermediateCert_subject_KEYM_E_KEY_CERT_INVALID, RTE_E_KeyMCertificateElement_Ssa_TrustModelIntermediateCert_subject_KEYM_E_KEY_CERT_SIZE_MISMATCH, RTE_E_KeyMCertificateElement_Ssa_TrustModelIntermediateCert_subject_KEYM_E_PARAMETER_MISMATCH
 *   Std_ReturnType Rte_Call_KeyMCertificateElement_Ssa_TrustModelRootCert_Issuer_CertificateElementGet(uint8 *CertificateElementData, uint32 *CertificateDataLength)
 *     Argument CertificateElementData: uint8* is of type KeyM_CertificateElementType_Ssa_TrustModelRootCert_Issuer
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_KeyMCertificateElement_Ssa_TrustModelRootCert_Issuer_E_NOT_OK, RTE_E_KeyMCertificateElement_Ssa_TrustModelRootCert_Issuer_KEYM_E_KEY_CERT_EMPTY, RTE_E_KeyMCertificateElement_Ssa_TrustModelRootCert_Issuer_KEYM_E_KEY_CERT_INVALID, RTE_E_KeyMCertificateElement_Ssa_TrustModelRootCert_Issuer_KEYM_E_KEY_CERT_SIZE_MISMATCH, RTE_E_KeyMCertificateElement_Ssa_TrustModelRootCert_Issuer_KEYM_E_PARAMETER_MISMATCH
 *   Std_ReturnType Rte_Call_KeyMCertificateElement_Ssa_TrustModelRootCert_SerialNo_CertificateElementGet(uint8 *CertificateElementData, uint32 *CertificateDataLength)
 *     Argument CertificateElementData: uint8* is of type KeyM_CertificateElementType_Ssa_TrustModelRootCert_SerialNo
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_KeyMCertificateElement_Ssa_TrustModelRootCert_SerialNo_E_NOT_OK, RTE_E_KeyMCertificateElement_Ssa_TrustModelRootCert_SerialNo_KEYM_E_KEY_CERT_EMPTY, RTE_E_KeyMCertificateElement_Ssa_TrustModelRootCert_SerialNo_KEYM_E_KEY_CERT_INVALID, RTE_E_KeyMCertificateElement_Ssa_TrustModelRootCert_SerialNo_KEYM_E_KEY_CERT_SIZE_MISMATCH, RTE_E_KeyMCertificateElement_Ssa_TrustModelRootCert_SerialNo_KEYM_E_PARAMETER_MISMATCH
 *   Std_ReturnType Rte_Call_KeyMCertificateElement_Ssa_TrustModelRootCert_SubjectPublicKeyInfoKey_CertificateElementGet(uint8 *CertificateElementData, uint32 *CertificateDataLength)
 *     Argument CertificateElementData: uint8* is of type KeyM_CertificateElementType_Ssa_TrustModelRootCert_SubjectPublicKeyInfoKey
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_KeyMCertificateElement_Ssa_TrustModelRootCert_SubjectPublicKeyInfoKey_E_NOT_OK, RTE_E_KeyMCertificateElement_Ssa_TrustModelRootCert_SubjectPublicKeyInfoKey_KEYM_E_KEY_CERT_EMPTY, RTE_E_KeyMCertificateElement_Ssa_TrustModelRootCert_SubjectPublicKeyInfoKey_KEYM_E_KEY_CERT_INVALID, RTE_E_KeyMCertificateElement_Ssa_TrustModelRootCert_SubjectPublicKeyInfoKey_KEYM_E_KEY_CERT_SIZE_MISMATCH, RTE_E_KeyMCertificateElement_Ssa_TrustModelRootCert_SubjectPublicKeyInfoKey_KEYM_E_PARAMETER_MISMATCH
 *   Std_ReturnType Rte_Call_KeyMCertificateElement_Ssa_TrustModelRootCert_ext_keyUsage_CertificateElementGet(uint8 *CertificateElementData, uint32 *CertificateDataLength)
 *     Argument CertificateElementData: uint8* is of type KeyM_CertificateElementType_Ssa_TrustModelRootCert_ext_keyUsage
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_KeyMCertificateElement_Ssa_TrustModelRootCert_ext_keyUsage_E_NOT_OK, RTE_E_KeyMCertificateElement_Ssa_TrustModelRootCert_ext_keyUsage_KEYM_E_KEY_CERT_EMPTY, RTE_E_KeyMCertificateElement_Ssa_TrustModelRootCert_ext_keyUsage_KEYM_E_KEY_CERT_INVALID, RTE_E_KeyMCertificateElement_Ssa_TrustModelRootCert_ext_keyUsage_KEYM_E_KEY_CERT_SIZE_MISMATCH, RTE_E_KeyMCertificateElement_Ssa_TrustModelRootCert_ext_keyUsage_KEYM_E_PARAMETER_MISMATCH
 *   Std_ReturnType Rte_Call_KeyMCertificateElement_Ssa_TrustModelRootCert_ext_subKeyId_CertificateElementGet(uint8 *CertificateElementData, uint32 *CertificateDataLength)
 *     Argument CertificateElementData: uint8* is of type KeyM_CertificateElementType_Ssa_TrustModelRootCert_ext_subKeyId
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_KeyMCertificateElement_Ssa_TrustModelRootCert_ext_subKeyId_E_NOT_OK, RTE_E_KeyMCertificateElement_Ssa_TrustModelRootCert_ext_subKeyId_KEYM_E_KEY_CERT_EMPTY, RTE_E_KeyMCertificateElement_Ssa_TrustModelRootCert_ext_subKeyId_KEYM_E_KEY_CERT_INVALID, RTE_E_KeyMCertificateElement_Ssa_TrustModelRootCert_ext_subKeyId_KEYM_E_KEY_CERT_SIZE_MISMATCH, RTE_E_KeyMCertificateElement_Ssa_TrustModelRootCert_ext_subKeyId_KEYM_E_PARAMETER_MISMATCH
 *   Std_ReturnType Rte_Call_KeyMCertificateElement_Ssa_TrustModelRootCert_subject_CertificateElementGet(uint8 *CertificateElementData, uint32 *CertificateDataLength)
 *     Argument CertificateElementData: uint8* is of type KeyM_CertificateElementType_Ssa_TrustModelRootCert_subject
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_KeyMCertificateElement_Ssa_TrustModelRootCert_subject_E_NOT_OK, RTE_E_KeyMCertificateElement_Ssa_TrustModelRootCert_subject_KEYM_E_KEY_CERT_EMPTY, RTE_E_KeyMCertificateElement_Ssa_TrustModelRootCert_subject_KEYM_E_KEY_CERT_INVALID, RTE_E_KeyMCertificateElement_Ssa_TrustModelRootCert_subject_KEYM_E_KEY_CERT_SIZE_MISMATCH, RTE_E_KeyMCertificateElement_Ssa_TrustModelRootCert_subject_KEYM_E_PARAMETER_MISMATCH
 *
 **********************************************************************************************************************
 *
 * Runnable prototype:
 * ===================
 *   Std_ReturnType Ssa_KeyM_RoutineServices_Get_Certificate_Entry_Start(uint8 Certificate_Identification_In, uint8 In_Certificate_Entry_In, Dcm_OpStatusType OpStatus, uint8 *routineInfo_Out, uint8 *Verification_Result_Out, uint8 *Certificate_identification_Out, uint8 *Out_Certificate_Entry_Out, uint8 *Certificate_Content_Out, uint16 *DataLength, Dcm_NegativeResponseCodeType *ErrorCode)
 *     Argument Certificate_Content_Out: uint8* is of type Dcm_Data64ByteType
 *
 **********************************************************************************************************************
 *
 * Available Application Errors:
 * =============================
 *   RTE_E_RoutineServices_Get_Certificate_Entry_DCM_E_FORCE_RCRRP
 *   RTE_E_RoutineServices_Get_Certificate_Entry_DCM_E_PENDING
 *   RTE_E_RoutineServices_Get_Certificate_Entry_E_NOT_OK
 *
 *********************************************************************************************************************/
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << Start of documentation area >>                  DO NOT CHANGE THIS COMMENT!
 * Symbol: Ssa_KeyM_RoutineServices_Get_Certificate_Entry_Start_doc
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 */
/*!
 * \spec
 *    requires $lengthOf(Certificate_Content_Out) >= sizeof(Dcm_Data64ByteType);
 * \endspec
 */
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << End of documentation area >>                    DO NOT CHANGE THIS COMMENT!
 *********************************************************************************************************************/

FUNC(Std_ReturnType, Ssa_KeyM_CODE) Ssa_KeyM_RoutineServices_Get_Certificate_Entry_Start(
  uint8 Certificate_Identification_In,
  uint8 In_Certificate_Entry_In,
  Dcm_OpStatusType OpStatus,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) routineInfo_Out,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) Verification_Result_Out,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) Certificate_identification_Out,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) Out_Certificate_Entry_Out,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) Certificate_Content_Out,
  P2VAR(uint16, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) DataLength,
  P2VAR(Dcm_NegativeResponseCodeType, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) ErrorCode) /* PRQA S 0624, 3206 */ /* MD_Rte_0624, MD_Rte_3206 */
{
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << Start of runnable implementation >>             DO NOT CHANGE THIS COMMENT!
 * Symbol: Ssa_KeyM_RoutineServices_Get_Certificate_Entry_Start (returns application error)
 *********************************************************************************************************************/
  Std_ReturnType retVal = RTE_E_RoutineServices_Get_Certificate_Entry_E_NOT_OK;

  /* ----- Development Error Checks ------------------------------------- */
#if (SSA_DEV_ERROR_DETECT == STD_ON)
  if ((routineInfo_Out == NULL_PTR)
    || (Verification_Result_Out == NULL_PTR)
    || (Certificate_identification_Out == NULL_PTR)
    || (Out_Certificate_Entry_Out == NULL_PTR)
    || (Certificate_Content_Out == NULL_PTR)
    || (DataLength == NULL_PTR)
    || (ErrorCode == NULL_PTR))
  {
    /* retVal already set */
  }
  else
#endif /* SSA_DEV_ERROR_DETECT == STD_ON */
  {
    *routineInfo_Out = SSA_ROUTINE_INFO_SUCCESFULLY_COMPLETED;
    *Certificate_identification_Out = Certificate_Identification_In;
    *Out_Certificate_Entry_Out = In_Certificate_Entry_In;
    *DataLength = 0u;

    if (!KeyM_GetCertEntry_IsIdValid(SSA_KEYM_CERT_ENTRY_ENTRY_ID_INVALID, SSA_KEYM_CERT_ENTRY_ENTRY_ID_NUM, In_Certificate_Entry_In))
    {
      /* not supported entry */
      *ErrorCode = DCM_E_REQUESTOUTOFRANGE;
    }
    else if (!KeyM_GetCertEntry_IsIdValid(SSA_KEYM_CERT_ENTRY_CERT_ID_INVALID, SSA_KEYM_CERT_ENTRY_CERT_ID_NUM, Certificate_Identification_In))
    {
      /* not supported certificate */
      *ErrorCode = DCM_E_REQUESTOUTOFRANGE;
    }
    /* Diagnostic chain */
    else if (Certificate_Identification_In <= SSA_KEYM_CERT_ENTRY_CERT_ID_ECU_CA_CERT)
    {
      KeyM_GetCertEntry_DiagnosticChain(Certificate_Identification_In,
        In_Certificate_Entry_In,
        Verification_Result_Out,
        Certificate_Content_Out,
        DataLength);
      retVal = RTE_E_OK;
    }
    /* Trust Model */
    else if (Certificate_Identification_In <= SSA_KEYM_CERT_ENTRY_CERT_ID_TRUSTMODEL_ECU_CA_CERT)
    {
      /*@ assert Certificate_Identification_In > SSA_KEYM_CERT_ENTRY_CERT_ID_ECU_CA_CERT && Certificate_Identification_In <= SSA_KEYM_CERT_ENTRY_CERT_ID_TRUSTMODEL_ECU_CA_CERT; */
      /*@ assert In_Certificate_Entry_In > SSA_KEYM_CERT_ENTRY_ENTRY_ID_INVALID && In_Certificate_Entry_In <= SSA_KEYM_CERT_ENTRY_ENTRY_ID_NUM; */ /* VCA_SSA_KEYM_RANGE_CHECK */
      retVal = KeyM_GetCertEntry_TrustModel(Certificate_Identification_In,
        In_Certificate_Entry_In,
        Verification_Result_Out,
        Certificate_Content_Out,
        DataLength,
        ErrorCode);
    }
    /* PQC */
    else
    {
      *Verification_Result_Out = SSA_VER_RES_GET_CERTIFICATE_ENTRY_CERTIFICATE_NOT_FOUND;
      retVal = RTE_E_OK;
    }
  }
  SSA_DUMMY_STATEMENT(OpStatus);    /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */

  return retVal;

  /* PRQA S 6060, 6080 4 */ /* MD_SSA_STPAR, MD_MSR_STMIF */
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << End of runnable implementation >>               DO NOT CHANGE THIS COMMENT!
 *********************************************************************************************************************/
}

#if (SSA_ECU_TYPE != SSA_ECU_TYPE_VSM)

/**********************************************************************************************************************
 *
 * Runnable Entity Name: Ssa_KeyM_RoutineServices_Inject_Seed
 *
 *---------------------------------------------------------------------------------------------------------------------
 *
 * Executed if at least one of the following trigger conditions occurred:
 *   - triggered by server invocation for OperationPrototype <Start> of PortPrototype <RoutineServices_Inject_Seed>
 *
 **********************************************************************************************************************
 *
 * Client/Server Interfaces:
 * =========================
 *   Server Invocation:
 *   ------------------
 *   Std_ReturnType Rte_Call_RightsM_Nonce_Destroy(void)
 *     Synchronous Server Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_RightsM_Nonce_E_NOT_OK, RTE_E_RightsM_Nonce_E_PENDING
 *   Std_ReturnType Rte_Call_RightsM_Nonce_Get(boolean generateNew, uint8 *nonce)
 *     Argument nonce: uint8* is of type Dcm_Data32ByteType
 *     Synchronous Server Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_RightsM_Nonce_E_INVALID, RTE_E_RightsM_Nonce_E_NOT_OK, RTE_E_RightsM_Nonce_E_PENDING
 *   Std_ReturnType Rte_Call_SecLog_SuccessfulDiagServiceExecutionEvent_InjectSeed_SuccessfulDiagServiceExecution(uint8 additionalInfo)
 *     Synchronous Server Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_SecLog_SuccessfulDiagServiceExecutionEvent_E_NOT_OK
 *   Std_ReturnType Rte_Call_SsaCdd_Csm_SignatureVerify(uint32 jobId, Crypto_OperationModeType operationMode, Ssa_ConstDataPtr dataBuffer, uint32 dataLength, Ssa_ConstDataPtr compareBuffer, uint32 compareLength, Ssa_VerifyResultPtr resultBuffer)
 *     Synchronous Server Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_SsaCdd_CryptoInterface_E_NOT_OK
 *   Std_ReturnType Rte_Call_Ssa_KeyProc_PrepareKeyExchange(Ssa_OpStatusType opStatus, uint32 keyId)
 *     Synchronous Server Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_Ssa_KeyProc_E_NOT_OK, RTE_E_Ssa_KeyProc_E_PENDING
 *   Std_ReturnType Rte_Call_Ssa_KeyStorage_StorePermanently(Ssa_KeyStorageUseCaseType keyStorageUseCase, Ssa_KeyStorageTaskType keyStorageTask)
 *     Synchronous Server Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_Ssa_KeyStorage_E_NOT_OK, RTE_E_Ssa_KeyStorage_E_PENDING
 *
 * Service Calls:
 * ==============
 *   Service Invocation:
 *   -------------------
 *   Std_ReturnType Rte_Call_CsmJobKeyExchangeCalcSecret_KeyExchangeCalcSecret(uint32 key, Csm_const_DataPtr partnerPublicValuePtr, uint32 partnerPublicValueLength)
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_CsmJobKeyExchangeCalcSecret_CSM_E_BUSY, RTE_E_CsmJobKeyExchangeCalcSecret_CSM_E_KEY_EMPTY, RTE_E_CsmJobKeyExchangeCalcSecret_CSM_E_SMALL_BUFFER, RTE_E_CsmJobKeyExchangeCalcSecret_E_NOT_OK
 *   Std_ReturnType Rte_Call_CsmJobRandomSeed_RandomSeed(uint32 key, Csm_const_DataPtr seedPtr, uint32 seedLength)
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_CsmJobRandomSeed_CSM_E_BUSY, RTE_E_CsmJobRandomSeed_E_NOT_OK
 *   Std_ReturnType Rte_Call_CsmSymAES128DecryptWithPadding_Decrypt(const uint8 *dataBuffer, uint32 dataLength, uint8 *resultBuffer, uint32 *resultLength)
 *     Argument dataBuffer: uint8* is of type Csm_DecryptDataType_AES128DecryptWithPadding
 *     Argument resultBuffer: uint8* is of type Csm_DecryptResultType_AES128DecryptWithPadding
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_CsmDecrypt_AES128DecryptWithPadding_CSM_E_BUSY, RTE_E_CsmDecrypt_AES128DecryptWithPadding_CSM_E_KEY_EMPTY, RTE_E_CsmDecrypt_AES128DecryptWithPadding_CSM_E_KEY_NOT_VALID, RTE_E_CsmDecrypt_AES128DecryptWithPadding_CSM_E_KEY_SIZE_MISMATCH, RTE_E_CsmDecrypt_AES128DecryptWithPadding_CSM_E_SMALL_BUFFER, RTE_E_CsmDecrypt_AES128DecryptWithPadding_E_NOT_OK
 *   Std_ReturnType Rte_Call_Key_AesRamKey_KeyElementSet(uint32 keyElementId, const uint8 *keyPtr, uint32 keyLength)
 *     Argument keyPtr: uint8* is of type Csm_KeyDataType_Ssa_AesRamKey
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_CsmKeyManagement_Ssa_AesRamKey_CSM_E_BUSY, RTE_E_CsmKeyManagement_Ssa_AesRamKey_CSM_E_KEY_NOT_AVAILABLE, RTE_E_CsmKeyManagement_Ssa_AesRamKey_CSM_E_KEY_SIZE_MISMATCH, RTE_E_CsmKeyManagement_Ssa_AesRamKey_CSM_E_KEY_WRITE_FAIL, RTE_E_CsmKeyManagement_Ssa_AesRamKey_CSM_E_SMALL_BUFFER, RTE_E_CsmKeyManagement_Ssa_AesRamKey_E_NOT_OK
 *   Std_ReturnType Rte_Call_Key_AesRamKey_KeySetValid(void)
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_CsmKeyManagement_Ssa_AesRamKey_CSM_E_BUSY, RTE_E_CsmKeyManagement_Ssa_AesRamKey_E_NOT_OK
 *   Std_ReturnType Rte_Call_Key_RandomSeed_KeySetValid(void)
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_CsmKeyManagement_Ssa_RandomSeed_CSM_E_BUSY, RTE_E_CsmKeyManagement_Ssa_RandomSeed_E_NOT_OK
 *   Std_ReturnType Rte_Call_Key_RandomSeed_RandomSeed(const uint8 *seedPtr, uint32 seedLength)
 *     Argument seedPtr: uint8* is of type Csm_SeedDataTypeSsa_RandomSeed
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_CsmKeyManagement_Ssa_RandomSeed_CSM_E_BUSY, RTE_E_CsmKeyManagement_Ssa_RandomSeed_E_NOT_OK
 *   Std_ReturnType Rte_Call_Key_SharedSecretKeyExchange_KeyElementGet(uint32 keyElementId, uint8 *keyPtr, uint32 *keyLength)
 *     Argument keyPtr: uint8* is of type Csm_KeyDataType_Ssa_SharedSecretKeyExchange
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_CsmKeyManagement_Ssa_SharedSecretKeyExchange_CSM_E_BUSY, RTE_E_CsmKeyManagement_Ssa_SharedSecretKeyExchange_CSM_E_KEY_EMPTY, RTE_E_CsmKeyManagement_Ssa_SharedSecretKeyExchange_CSM_E_KEY_NOT_AVAILABLE, RTE_E_CsmKeyManagement_Ssa_SharedSecretKeyExchange_CSM_E_KEY_READ_FAIL, RTE_E_CsmKeyManagement_Ssa_SharedSecretKeyExchange_CSM_E_SMALL_BUFFER, RTE_E_CsmKeyManagement_Ssa_SharedSecretKeyExchange_E_NOT_OK
 *   Std_ReturnType Rte_Call_Key_SharedSecretKeyExchange_KeyExchangeCalcSecret(const uint8 *partnerPublicValuePtr, uint32 partnerPublicValueLength)
 *     Argument partnerPublicValuePtr: uint8* is of type Csm_PublicValueDataType_Ssa_SharedSecretKeyExchange
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_CsmKeyManagement_Ssa_SharedSecretKeyExchange_CSM_E_BUSY, RTE_E_CsmKeyManagement_Ssa_SharedSecretKeyExchange_CSM_E_KEY_EMPTY, RTE_E_CsmKeyManagement_Ssa_SharedSecretKeyExchange_CSM_E_SMALL_BUFFER, RTE_E_CsmKeyManagement_Ssa_SharedSecretKeyExchange_E_NOT_OK
 *   Std_ReturnType Rte_Call_Key_SharedSecretKeyExchange_KeySetValid(void)
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_CsmKeyManagement_Ssa_SharedSecretKeyExchange_CSM_E_BUSY, RTE_E_CsmKeyManagement_Ssa_SharedSecretKeyExchange_E_NOT_OK
 *
 **********************************************************************************************************************
 *
 * Runnable prototype:
 * ===================
 *   Std_ReturnType Ssa_KeyM_RoutineServices_Inject_Seed(const uint8 *Ephemeral_Backend_Public_Key_In, const uint8 *Data_Signature_In, const uint8 *Encrypted_Seed_In, Dcm_OpStatusType OpStatus, uint8 *routineInfo_Out, uint8 *Verification_Result_Out, uint16 DataLength, Dcm_NegativeResponseCodeType *ErrorCode)
 *     Argument Ephemeral_Backend_Public_Key_In: uint8* is of type Dcm_Data32ByteType
 *     Argument Data_Signature_In: uint8* is of type Dcm_Data64ByteType
 *     Argument Encrypted_Seed_In: uint8* is of type Dcm_Data1058ByteType
 *
 **********************************************************************************************************************
 *
 * Available Application Errors:
 * =============================
 *   RTE_E_RoutineServices_Inject_Seed_DCM_E_FORCE_RCRRP
 *   RTE_E_RoutineServices_Inject_Seed_DCM_E_PENDING
 *   RTE_E_RoutineServices_Inject_Seed_E_NOT_OK
 *
 *********************************************************************************************************************/
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << Start of documentation area >>                  DO NOT CHANGE THIS COMMENT!
 * Symbol: Ssa_KeyM_RoutineServices_Inject_Seed_doc
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
/* PRQA S 3673 20 */ /* MD_SSA_PARAM_NOT_P2CONST */
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << End of documentation area >>                    DO NOT CHANGE THIS COMMENT!
 *********************************************************************************************************************/

FUNC(Std_ReturnType, Ssa_KeyM_CODE) Ssa_KeyM_RoutineServices_Inject_Seed(
  P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) Ephemeral_Backend_Public_Key_In,
  P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) Data_Signature_In,
  P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) Encrypted_Seed_In,
  Dcm_OpStatusType OpStatus,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) routineInfo_Out,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) Verification_Result_Out,
  uint16 DataLength,
  P2VAR(Dcm_NegativeResponseCodeType, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) ErrorCode) /* PRQA S 0624, 3206 */ /* MD_Rte_0624, MD_Rte_3206 */
{
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << Start of runnable implementation >>             DO NOT CHANGE THIS COMMENT!
 * Symbol: Ssa_KeyM_RoutineServices_Inject_Seed (returns application error)
 *********************************************************************************************************************/

  Std_ReturnType retVal = RTE_E_RoutineServices_Inject_Seed_E_NOT_OK;

  /* ----- Development Error Checks ------------------------------------- */
# if (SSA_DEV_ERROR_DETECT == STD_ON)
  if ((Ephemeral_Backend_Public_Key_In == NULL_PTR)
    || (Data_Signature_In == NULL_PTR)
    || (Encrypted_Seed_In == NULL_PTR)
    || (routineInfo_Out == NULL_PTR)
    || (Verification_Result_Out == NULL_PTR)
    || (ErrorCode == NULL_PTR))
  {
    /* retVal already set */
  }
  else
# endif /* SSA_DEV_ERROR_DETECT == STD_ON */
  {
# if (SSA_DIAG_SERVICE_INJECT_SEED == STD_ON)

    if (OpStatus == DCM_CANCEL)
    {
      /* back to idle state */
      KeyM_DiagProc.state = SSA_KEYM_ROUTINE_INJECT_SEED_STATE_IDLE;
      retVal = RTE_E_OK;
    }
    else if (!KeyM_IsInjectSeedStateValid())
    {
      KeyM_DiagProc.ws.injectSeed.errorCode = DCM_E_GENERALREJECT;
      /* back to idle state */
      KeyM_DiagProc.state = SSA_KEYM_ROUTINE_INJECT_SEED_STATE_IDLE;
    }
    else
    {
      if (OpStatus == DCM_INITIAL)
      {
        KeyM_DiagProc.ws.injectSeed.seedLength = 0u;
        /* Initialize verification result with any result != 0. */
        KeyM_DiagProc.ws.injectSeed.verificationResult = SSA_VER_RES_INJECT_SEED_INVALID_NONCE;
        KeyM_DiagProc.ws.injectSeed.errorCode = DCM_E_GENERALREJECT;
      }

      /* Handle the states defined for asynchronous handling of routine Inject_Seed. */
      retVal = KeyM_Inject_Seed_State_Handler[KeyM_DiagProc.state](
        Ephemeral_Backend_Public_Key_In,
        Data_Signature_In,
        Encrypted_Seed_In,
        DataLength);
    }

    /* Set verification result and error code depending on the return value. */
    if (retVal != RTE_E_RoutineServices_Inject_Seed_DCM_E_PENDING)
    {
      /* Clear temporary buffer containing among other things the decrypted seed. */
      KeyM_ClearDataBuffer(KeyM_DiagProc.ws.injectSeed.dataBuffer, SSA_KEYM_INJECT_SEED_DATA_BUFFER_SIZE, SSA_KEYM_INJECT_SEED_DATA_BUFFER_SIZE);

      *routineInfo_Out = SSA_ROUTINE_INFO_SUCCESFULLY_COMPLETED;

      /* check for positive or negative response and set either verification result or NRC */
      if (retVal == RTE_E_OK)
      {
        *Verification_Result_Out = KeyM_DiagProc.ws.injectSeed.verificationResult;

        (void)Rte_Call_SecLog_SuccessfulDiagServiceExecutionEvent_InjectSeed_SuccessfulDiagServiceExecution(*Verification_Result_Out);
      }
      else
      {
        *ErrorCode = KeyM_DiagProc.ws.injectSeed.errorCode;
      }

      /* back to idle state */
      KeyM_DiagProc.state = SSA_KEYM_ROUTINE_INJECT_SEED_STATE_IDLE;
    }

# else
    SSA_DUMMY_STATEMENT(OpStatus);   /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */
    SSA_DUMMY_STATEMENT(Ephemeral_Backend_Public_Key_In);   /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */
    SSA_DUMMY_STATEMENT(Data_Signature_In);   /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */
    SSA_DUMMY_STATEMENT(Encrypted_Seed_In);   /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */
    SSA_DUMMY_STATEMENT(Verification_Result_Out);   /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */
    SSA_DUMMY_STATEMENT(DataLength);   /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */
    *routineInfo_Out = SSA_ROUTINE_INFO_SUCCESFULLY_COMPLETED;
    *ErrorCode = DCM_E_REQUESTOUTOFRANGE;
# endif
  }

  return retVal;

  /* PRQA S 6060 4 */ /* MD_SSA_STPAR */
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << End of runnable implementation >>               DO NOT CHANGE THIS COMMENT!
 *********************************************************************************************************************/
}

#endif

/**********************************************************************************************************************
 *
 * Runnable Entity Name: Ssa_KeyM_RoutineServices_Replace_Certificates
 *
 *---------------------------------------------------------------------------------------------------------------------
 *
 * Executed if at least one of the following trigger conditions occurred:
 *   - triggered by server invocation for OperationPrototype <Start> of PortPrototype <RoutineServices_Routine_Replace_Certificates>
 *
 **********************************************************************************************************************
 *
 * Output Interfaces:
 * ==================
 *   Explicit S/R API:
 *   -----------------
 *   Std_ReturnType Rte_Write_KeyM_ReplaceRootCertificate_isProductive(boolean data)
 *
 * Client/Server Interfaces:
 * =========================
 *   Server Invocation:
 *   ------------------
 *   Std_ReturnType Rte_Call_CertP_Functions_Certificate_Compare(const uint8 *rawCertData1, const CertP_ParsedCertStructureType *parsedCert1, CertP_PkiRoleType pkiRole1, const uint8 *rawCertData2, const CertP_ParsedCertStructureType *parsedCert2, CertP_PkiRoleType pkiRole2, boolean *isEqual)
 *     Argument rawCertData1: uint8* is of type CertP_RawCertBufferType
 *     Argument rawCertData2: uint8* is of type CertP_RawCertBufferType
 *     Synchronous Server Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_CertP_Functions_E_NOT_OK
 *   Std_ReturnType Rte_Call_CertP_Functions_Certificate_Parse(const uint8 *rawCertData, uint16 rawCertLength, CertP_ParsedCertStructureType *parsedCert)
 *     Argument rawCertData: uint8* is of type CertP_RawCertBufferType
 *     Synchronous Server Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_CertP_Functions_E_NOT_OK
 *   Std_ReturnType Rte_Call_CertP_Functions_Certificate_Verify(const uint8 *rawCertData, CertP_ParsedCertStructureType *parsedCert, const uint8 *rawCertIssuer, const CertP_ParsedCertStructureType *parsedCertIssuer, CertP_PkiRoleType expectedPkiRole)
 *     Argument rawCertData: uint8* is of type CertP_RawCertBufferType
 *     Argument rawCertIssuer: uint8* is of type CertP_RawCertBufferType
 *     Synchronous Server Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_CertP_Functions_E_NOT_OK, RTE_E_CertP_Functions_E_PENDING
 *   Std_ReturnType Rte_Call_SecLog_SuccessfulDiagServiceExecutionEvent_ReplaceCert_SuccessfulDiagServiceExecution(uint8 additionalInfo)
 *     Synchronous Server Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_SecLog_SuccessfulDiagServiceExecutionEvent_E_NOT_OK
 *   Std_ReturnType Rte_Call_SsaCdd_Csm_SignatureGenerate(uint32 jobId, Crypto_OperationModeType operationMode, Ssa_ConstDataPtr dataBuffer, uint32 dataLength, Ssa_DataPtr resultBuffer, Ssa_LengthPtr resultLength)
 *     Synchronous Server Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_SsaCdd_CryptoInterface_E_NOT_OK
 *   Std_ReturnType Rte_Call_SsaCdd_Csm_SignatureVerify(uint32 jobId, Crypto_OperationModeType operationMode, Ssa_ConstDataPtr dataBuffer, uint32 dataLength, Ssa_ConstDataPtr compareBuffer, uint32 compareLength, Ssa_VerifyResultPtr resultBuffer)
 *     Synchronous Server Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_SsaCdd_CryptoInterface_E_NOT_OK
 *   Std_ReturnType Rte_Call_SsaCdd_Keys_KeyElementSet(uint32 keyId, uint32 keyElementId, Ssa_ConstDataPtr keyPtr, uint32 keyLength)
 *     Synchronous Server Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_SsaCdd_Csm_KeyInterface_E_BUSY, RTE_E_SsaCdd_Csm_KeyInterface_E_NOT_OK
 *   Std_ReturnType Rte_Call_SsaCdd_Keys_KeySetValid(uint32 keyId)
 *     Synchronous Server Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_SsaCdd_Csm_KeyInterface_E_BUSY, RTE_E_SsaCdd_Csm_KeyInterface_E_NOT_OK
 *   Std_ReturnType Rte_Call_Ssa_KeyStorage_StorePermanently(Ssa_KeyStorageUseCaseType keyStorageUseCase, Ssa_KeyStorageTaskType keyStorageTask)
 *     Synchronous Server Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_Ssa_KeyStorage_E_NOT_OK, RTE_E_Ssa_KeyStorage_E_PENDING
 *
 * Service Calls:
 * ==============
 *   Service Invocation:
 *   -------------------
 *   Std_ReturnType Rte_Call_Key_BackendCert_KeyElementGet(uint32 keyElementId, uint8 *keyPtr, uint32 *keyLength)
 *     Argument keyPtr: uint8* is of type Csm_KeyDataType_Ssa_BackendCert
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_CsmKeyManagement_Ssa_BackendCert_CSM_E_BUSY, RTE_E_CsmKeyManagement_Ssa_BackendCert_CSM_E_KEY_EMPTY, RTE_E_CsmKeyManagement_Ssa_BackendCert_CSM_E_KEY_NOT_AVAILABLE, RTE_E_CsmKeyManagement_Ssa_BackendCert_CSM_E_KEY_READ_FAIL, RTE_E_CsmKeyManagement_Ssa_BackendCert_CSM_E_SMALL_BUFFER, RTE_E_CsmKeyManagement_Ssa_BackendCert_E_NOT_OK
 *   Std_ReturnType Rte_Call_Key_EcuCert_KeyElementGet(uint32 keyElementId, uint8 *keyPtr, uint32 *keyLength)
 *     Argument keyPtr: uint8* is of type Csm_KeyDataType_Ssa_EcuCert
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_CsmKeyManagement_Ssa_EcuCert_CSM_E_BUSY, RTE_E_CsmKeyManagement_Ssa_EcuCert_CSM_E_KEY_EMPTY, RTE_E_CsmKeyManagement_Ssa_EcuCert_CSM_E_KEY_NOT_AVAILABLE, RTE_E_CsmKeyManagement_Ssa_EcuCert_CSM_E_KEY_READ_FAIL, RTE_E_CsmKeyManagement_Ssa_EcuCert_CSM_E_SMALL_BUFFER, RTE_E_CsmKeyManagement_Ssa_EcuCert_E_NOT_OK
 *   Std_ReturnType Rte_Call_Key_RootCert_KeyElementGet(uint32 keyElementId, uint8 *keyPtr, uint32 *keyLength)
 *     Argument keyPtr: uint8* is of type Csm_KeyDataType_Ssa_RootCert
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_CsmKeyManagement_Ssa_RootCert_CSM_E_BUSY, RTE_E_CsmKeyManagement_Ssa_RootCert_CSM_E_KEY_EMPTY, RTE_E_CsmKeyManagement_Ssa_RootCert_CSM_E_KEY_NOT_AVAILABLE, RTE_E_CsmKeyManagement_Ssa_RootCert_CSM_E_KEY_READ_FAIL, RTE_E_CsmKeyManagement_Ssa_RootCert_CSM_E_SMALL_BUFFER, RTE_E_CsmKeyManagement_Ssa_RootCert_E_NOT_OK
 *   Std_ReturnType Rte_Call_Key_SignatureRamKey_KeyElementSet(uint32 keyElementId, const uint8 *keyPtr, uint32 keyLength)
 *     Argument keyPtr: uint8* is of type Csm_KeyDataType_Ssa_SignatureRamKey
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_CsmKeyManagement_Ssa_SignatureRamKey_CSM_E_BUSY, RTE_E_CsmKeyManagement_Ssa_SignatureRamKey_CSM_E_KEY_NOT_AVAILABLE, RTE_E_CsmKeyManagement_Ssa_SignatureRamKey_CSM_E_KEY_SIZE_MISMATCH, RTE_E_CsmKeyManagement_Ssa_SignatureRamKey_CSM_E_KEY_WRITE_FAIL, RTE_E_CsmKeyManagement_Ssa_SignatureRamKey_CSM_E_SMALL_BUFFER, RTE_E_CsmKeyManagement_Ssa_SignatureRamKey_E_NOT_OK
 *   Std_ReturnType Rte_Call_Key_SignatureRamKey_KeySetValid(void)
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_CsmKeyManagement_Ssa_SignatureRamKey_CSM_E_BUSY, RTE_E_CsmKeyManagement_Ssa_SignatureRamKey_E_NOT_OK
 *
 **********************************************************************************************************************
 *
 * Runnable prototype:
 * ===================
 *   Std_ReturnType Ssa_KeyM_RoutineServices_Replace_Certificates(const uint8 *Certificates, Dcm_OpStatusType OpStatus, uint8 *routineInfo, uint8 *Verification_Result, uint16 DataLength, Dcm_NegativeResponseCodeType *ErrorCode)
 *     Argument Certificates: uint8* is of type Dcm_Data4008ByteType
 *
 **********************************************************************************************************************
 *
 * Available Application Errors:
 * =============================
 *   RTE_E_RoutineServices_Routine_Replace_Certificates_DCM_E_FORCE_RCRRP
 *   RTE_E_RoutineServices_Routine_Replace_Certificates_DCM_E_PENDING
 *   RTE_E_RoutineServices_Routine_Replace_Certificates_E_NOT_OK
 *
 *********************************************************************************************************************/
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << Start of documentation area >>                  DO NOT CHANGE THIS COMMENT!
 * Symbol: Ssa_KeyM_RoutineServices_Replace_Certificates_doc
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */

/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << End of documentation area >>                    DO NOT CHANGE THIS COMMENT!
 *********************************************************************************************************************/

FUNC(Std_ReturnType, Ssa_KeyM_CODE) Ssa_KeyM_RoutineServices_Replace_Certificates(
  P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) Certificates,
  Dcm_OpStatusType OpStatus,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) routineInfo,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) Verification_Result,
  uint16 DataLength,
  P2VAR(Dcm_NegativeResponseCodeType, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) ErrorCode) /* PRQA S 0624, 3206 */ /* MD_Rte_0624, MD_Rte_3206 */
{
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << Start of runnable implementation >>             DO NOT CHANGE THIS COMMENT!
 * Symbol: Ssa_KeyM_RoutineServices_Replace_Certificates (returns application error)
 *********************************************************************************************************************/

  Std_ReturnType retVal = RTE_E_RoutineServices_Routine_Replace_Certificates_E_NOT_OK;
  Std_ReturnType tmpRetVal = E_OK; /* Used for handling the control flow within the for-loop. */

  /* ----- Development Error Checks ------------------------------------- */
#if (SSA_DEV_ERROR_DETECT == STD_ON)
  if ((Certificates == NULL_PTR)
    || (routineInfo == NULL_PTR)
    || (Verification_Result == NULL_PTR)
    || (ErrorCode == NULL_PTR))
  {
    /* retVal already set */
  }
  else
#endif /* SSA_DEV_ERROR_DETECT == STD_ON */
  {
    /* Set default verification result. */
    uint8 verResult = CERTP_VER_NOT_PARSED;
    /* Any error code different from DCM_E_POSITIVERESPONSE causes a negative return. */
    Dcm_NegativeResponseCodeType errCode = DCM_E_POSITIVERESPONSE;
    uint8 stateCounter = 0u;

    if (OpStatus == DCM_CANCEL)
    {
      retVal = RTE_E_RoutineServices_Routine_Replace_Certificates_E_NOT_OK;
      errCode = DCM_E_GENERALREJECT;

      /* do not process anything within the subsequent for-loop */
      tmpRetVal = E_NOT_OK;
    }

    /* The members of KeyM_DiagProc.ws.replaceCerts are already initialized in Ssa_KeyM_Init(). */

    for (stateCounter = 0u; stateCounter < SSA_KEYM_REPLACE_CERT_UPPER_BOUNDARY; stateCounter++)
    {
      if (tmpRetVal == E_OK)
      {
        switch (KeyM_DiagProc.state)
        {
          /* ********** Extract certificates *********** */
          case KEYM_REPLACE_CERT_STATE_IDLE:
          {
            /* #30 Extract the certificates. */
            KeyM_DiagProc.ws.replaceCerts.certReplacement = KeyM_Replace_Certificate_Extract_Certificates(Certificates, DataLength, &KeyM_DiagProc.ws.replaceCerts.cert, &errCode);

            /* Check if the verification result has been changed from default. */
            if (errCode != DCM_E_POSITIVERESPONSE)
            {
              /* Error while extracting certificates. */
              retVal = RTE_E_RoutineServices_Routine_Replace_Certificates_E_NOT_OK;
              KeyM_DiagProc.state = KEYM_REPLACE_CERT_STATE_IDLE;
              /* Stop processing the for-loop. */
              tmpRetVal = E_NOT_OK;
            }
            else
            {
              /* Change state */
              KeyM_DiagProc.state = KEYM_REPLACE_CERT_STATE_REPLACE;
            }
            break;
          }

          /* ********** Verifying received certificates *********** */
          case KEYM_REPLACE_CERT_STATE_REPLACE:
          {
            /* #40 Depending on the extracted certificates replace either
            *   ECU Certificate(Only VSM),
            *   Backend CA Certificate and ECU Certificate(Only VSM) or
            *   Root CA Certificate, Backend CA Certificate and ECU Certificate(Only VSM). */

            /*@ assert &KeyM_DiagProc.ws.replaceCerts.cert != NULL_PTR; */
            retVal = KeyM_Replace_Certificate_VerifyAndReplaceReceivedCertificates(
              KeyM_DiagProc.ws.replaceCerts.certReplacement, &KeyM_DiagProc.ws.replaceCerts.cert, &verResult, &errCode);

            tmpRetVal = KeyM_Replace_Certificate_StateHandler_VerifyAndReplace(verResult, &retVal, &KeyM_DiagProc.state);

            if (tmpRetVal == E_OK)
            {
              /* proceed to next state in for-loop. */
              KeyM_DiagProc.state = KEYM_REPLACE_CERT_STATE_STORE_INIT;
            }
            /* else tmpRetVal = E_NOT_OK and the for-loop is not processed any further. */
            break;
          }

          /* ********** Storing permanently *********** */
          case KEYM_REPLACE_CERT_STATE_STORE_INIT:
            /* Fall through */
          case KEYM_REPLACE_CERT_STATE_STORE_PENDING:
          {
            tmpRetVal = E_NOT_OK; /* Stop processing the for-loop. */

            retVal = Rte_Call_Ssa_KeyStorage_StorePermanently(
              SSA_KEYSTORAGE_USECASE_CERTIFICATES,
              (KeyM_DiagProc.state == KEYM_REPLACE_CERT_STATE_STORE_INIT) ? SSA_KEYSTORAGE_TASK_INITIAL : SSA_KEYSTORAGE_TASK_CHECKSTATE);

            if (retVal == RTE_E_Ssa_KeyStorage_E_PENDING)
            {
              KeyM_DiagProc.state = KEYM_REPLACE_CERT_STATE_STORE_PENDING;
              retVal = RTE_E_RoutineServices_Routine_Replace_Certificates_DCM_E_PENDING;
            }
            else if (retVal == E_OK)
            {
              verResult = KEYM_VER_RES_CERT_VERIFIED_AND_REPLACED;
              KeyM_DiagProc.state = KEYM_REPLACE_CERT_STATE_IDLE;
            }
            else
            {
              retVal = RTE_E_RoutineServices_Routine_Replace_Certificates_E_NOT_OK;
              errCode = DCM_E_GENERALREJECT;
              KeyM_DiagProc.state = KEYM_REPLACE_CERT_STATE_IDLE;
            }
            break;
          }

          default:
          {
            retVal = RTE_E_RoutineServices_Routine_Replace_Certificates_E_NOT_OK;
            errCode = DCM_E_GENERALREJECT;
            KeyM_DiagProc.state = KEYM_REPLACE_CERT_STATE_IDLE;
            /* Stop processing the for-loop. */
            tmpRetVal = E_NOT_OK;
            break;
          }
        }
      }
      else
      {
        /* leave for-loop */
        break;
      }
    }

    /* #100 Check that the service is finished. */
    if (retVal != RTE_E_RoutineServices_Routine_Replace_Certificates_DCM_E_PENDING)
    {
      *routineInfo = SSA_ROUTINE_INFO_SUCCESFULLY_COMPLETED;
      if (retVal == E_OK)
      {
        /* Set positive response code */
        *Verification_Result = verResult;
        *ErrorCode = DCM_E_POSITIVERESPONSE;

        /* #110 Write the security log for event "successful diagnostic service execution"
        * for use case "Replace Certificates" and set the verification result as additional info. */
        (void)Rte_Call_SecLog_SuccessfulDiagServiceExecutionEvent_ReplaceCert_SuccessfulDiagServiceExecution(*Verification_Result);
      }
      else
      {
        /* Set negative response code */
        *ErrorCode = errCode;
      }
    }
  }

  return retVal;
  /* PRQA S 6030, 6060, 6080 4 */ /* MD_MSR_STCYC, MD_SSA_STPAR, MD_MSR_STMIF */
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << End of runnable implementation >>               DO NOT CHANGE THIS COMMENT!
 *********************************************************************************************************************/
}

/**********************************************************************************************************************
 *
 * Runnable Entity Name: Ssa_KeyM_RoutineServices_Replace_Trust_model_Certificates
 *
 *---------------------------------------------------------------------------------------------------------------------
 *
 * Executed if at least one of the following trigger conditions occurred:
 *   - triggered by server invocation for OperationPrototype <Start> of PortPrototype <RoutineServices_Replace_Trust_model_Certificates>
 *
 **********************************************************************************************************************
 *
 * Client/Server Interfaces:
 * =========================
 *   Server Invocation:
 *   ------------------
 *   Std_ReturnType Rte_Call_CertP_Functions_ParseTime(const uint8 *data, uint16 dataLength, TimeM_DateTimeType *dateTime)
 *     Argument data: uint8* is of type Ssa_Data15ByteType
 *     Synchronous Server Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_CertP_Functions_E_NOT_OK
 *   Std_ReturnType Rte_Call_SecLog_FailedCertVerificationEvent_FailedCertificateVerification(CertP_PkiRoleType pkiRole, CertP_VerificationResultType validationResult)
 *     Synchronous Server Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_SecLog_FailedCertVerificationEvent_E_NOT_OK
 *   Std_ReturnType Rte_Call_SecLog_SuccessfulCertVerificationEvent_SuccessfulCertificateVerification(const uint8 *certId, CertP_PkiRoleType pkiRole)
 *     Argument certId: uint8* is of type RightsM_SerialNumberType
 *     Synchronous Server Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_SecLog_SuccessfulCertVerificationEvent_E_NOT_OK
 *   Std_ReturnType Rte_Call_SecLog_SuccessfulDiagServiceExecutionEvent_ReplaceTrustModelCert_SuccessfulDiagServiceExecution(uint8 additionalInfo)
 *     Synchronous Server Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_SecLog_SuccessfulDiagServiceExecutionEvent_E_NOT_OK
 *   Std_ReturnType Rte_Call_SsaCdd_Csm_SignatureGenerate(uint32 jobId, Crypto_OperationModeType operationMode, Ssa_ConstDataPtr dataBuffer, uint32 dataLength, Ssa_DataPtr resultBuffer, Ssa_LengthPtr resultLength)
 *     Synchronous Server Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_SsaCdd_CryptoInterface_E_NOT_OK
 *   Std_ReturnType Rte_Call_SsaCdd_Csm_SignatureVerify(uint32 jobId, Crypto_OperationModeType operationMode, Ssa_ConstDataPtr dataBuffer, uint32 dataLength, Ssa_ConstDataPtr compareBuffer, uint32 compareLength, Ssa_VerifyResultPtr resultBuffer)
 *     Synchronous Server Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_SsaCdd_CryptoInterface_E_NOT_OK
 *   Std_ReturnType Rte_Call_SsaCdd_TrustModel_GetCertificate(KeyM_CertificateIdType CertId, Ssa_DataPtr CertData, Ssa_LengthPtr CertDataLength)
 *     Synchronous Server Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_SsaCdd_KeyM_CertInterface_E_NOT_OK, RTE_E_SsaCdd_KeyM_CertInterface_KEYM_E_KEY_CERT_EMPTY, RTE_E_SsaCdd_KeyM_CertInterface_KEYM_E_KEY_CERT_READ_FAIL, RTE_E_SsaCdd_KeyM_CertInterface_KEYM_E_KEY_CERT_SIZE_MISMATCH, RTE_E_SsaCdd_KeyM_CertInterface_KEYM_E_PARAMETER_MISMATCH
 *   Std_ReturnType Rte_Call_SsaCdd_TrustModel_ServiceCertificate(KeyM_ServiceCertificateType Service, Ssa_ConstDataPtr CertNamePtr, uint32 CertNameLength, Ssa_ConstDataPtr RequestData, uint32 RequestDataLength, Ssa_DataPtr ResponseData, uint32 ResponseDataLength)
 *     Synchronous Server Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_SsaCdd_KeyM_CertInterface_E_NOT_OK, RTE_E_SsaCdd_KeyM_CertInterface_KEYM_E_BUSY, RTE_E_SsaCdd_KeyM_CertInterface_KEYM_E_CERT_INVALID_CHAIN_OF_TRUST, RTE_E_SsaCdd_KeyM_CertInterface_KEYM_E_KEY_CERT_EMPTY, RTE_E_SsaCdd_KeyM_CertInterface_KEYM_E_KEY_CERT_SIZE_MISMATCH, RTE_E_SsaCdd_KeyM_CertInterface_KEYM_E_PARAMETER_MISMATCH
 *   Std_ReturnType Rte_Call_SsaCdd_TrustModel_SetCertificate(KeyM_CertificateIdType CertId, Ssa_DataPtr CertData, uint32 CertDataLength)
 *     Synchronous Server Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_SsaCdd_KeyM_CertInterface_E_NOT_OK, RTE_E_SsaCdd_KeyM_CertInterface_KEYM_E_KEY_CERT_SIZE_MISMATCH, RTE_E_SsaCdd_KeyM_CertInterface_KEYM_E_PARAMETER_MISMATCH
 *   Std_ReturnType Rte_Call_Ssa_KeyStorage_StorePermanently(Ssa_KeyStorageUseCaseType keyStorageUseCase, Ssa_KeyStorageTaskType keyStorageTask)
 *     Synchronous Server Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_Ssa_KeyStorage_E_NOT_OK, RTE_E_Ssa_KeyStorage_E_PENDING
 *   Std_ReturnType Rte_Call_TimeM_RealTime_Compare(const TimeM_DateTimeType *t1, TimeM_CompareOperatorType compareOp, const TimeM_DateTimeType *t2, boolean *result)
 *     Synchronous Server Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_TimeM_RealTime_E_NOT_OK
 *   Std_ReturnType Rte_Call_TimeM_RealTime_Get(TimeM_DateTimeType *realTime)
 *     Synchronous Server Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_TimeM_RealTime_E_NOT_OK
 *
 * Service Calls:
 * ==============
 *   Service Invocation:
 *   -------------------
 *   Std_ReturnType Rte_Call_KeyMCertificateElement_Ssa_TrustModelBackendCert_Issuer_CertificateElementGet(uint8 *CertificateElementData, uint32 *CertificateDataLength)
 *     Argument CertificateElementData: uint8* is of type KeyM_CertificateElementType_Ssa_TrustModelBackendCert_Issuer
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_KeyMCertificateElement_Ssa_TrustModelBackendCert_Issuer_E_NOT_OK, RTE_E_KeyMCertificateElement_Ssa_TrustModelBackendCert_Issuer_KEYM_E_KEY_CERT_EMPTY, RTE_E_KeyMCertificateElement_Ssa_TrustModelBackendCert_Issuer_KEYM_E_KEY_CERT_INVALID, RTE_E_KeyMCertificateElement_Ssa_TrustModelBackendCert_Issuer_KEYM_E_KEY_CERT_SIZE_MISMATCH, RTE_E_KeyMCertificateElement_Ssa_TrustModelBackendCert_Issuer_KEYM_E_PARAMETER_MISMATCH
 *   Std_ReturnType Rte_Call_KeyMCertificateElement_Ssa_TrustModelBackendCert_SerialNo_CertificateElementGet(uint8 *CertificateElementData, uint32 *CertificateDataLength)
 *     Argument CertificateElementData: uint8* is of type KeyM_CertificateElementType_Ssa_TrustModelBackendCert_SerialNo
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_KeyMCertificateElement_Ssa_TrustModelBackendCert_SerialNo_E_NOT_OK, RTE_E_KeyMCertificateElement_Ssa_TrustModelBackendCert_SerialNo_KEYM_E_KEY_CERT_EMPTY, RTE_E_KeyMCertificateElement_Ssa_TrustModelBackendCert_SerialNo_KEYM_E_KEY_CERT_INVALID, RTE_E_KeyMCertificateElement_Ssa_TrustModelBackendCert_SerialNo_KEYM_E_KEY_CERT_SIZE_MISMATCH, RTE_E_KeyMCertificateElement_Ssa_TrustModelBackendCert_SerialNo_KEYM_E_PARAMETER_MISMATCH
 *   Std_ReturnType Rte_Call_KeyMCertificateElement_Ssa_TrustModelBackendCert_SubjectPublicKeyInfoKey_CertificateElementGet(uint8 *CertificateElementData, uint32 *CertificateDataLength)
 *     Argument CertificateElementData: uint8* is of type KeyM_CertificateElementType_Ssa_TrustModelBackendCert_SubjectPublicKeyInfoKey
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_KeyMCertificateElement_Ssa_TrustModelBackendCert_SubjectPublicKeyInfoKey_E_NOT_OK, RTE_E_KeyMCertificateElement_Ssa_TrustModelBackendCert_SubjectPublicKeyInfoKey_KEYM_E_KEY_CERT_EMPTY, RTE_E_KeyMCertificateElement_Ssa_TrustModelBackendCert_SubjectPublicKeyInfoKey_KEYM_E_KEY_CERT_INVALID, RTE_E_KeyMCertificateElement_Ssa_TrustModelBackendCert_SubjectPublicKeyInfoKey_KEYM_E_KEY_CERT_SIZE_MISMATCH, RTE_E_KeyMCertificateElement_Ssa_TrustModelBackendCert_SubjectPublicKeyInfoKey_KEYM_E_PARAMETER_MISMATCH
 *   Std_ReturnType Rte_Call_KeyMCertificateElement_Ssa_TrustModelBackendCert_Version_CertificateElementGet(uint8 *CertificateElementData, uint32 *CertificateDataLength)
 *     Argument CertificateElementData: uint8* is of type KeyM_CertificateElementType_Ssa_TrustModelBackendCert_Version
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_KeyMCertificateElement_Ssa_TrustModelBackendCert_Version_E_NOT_OK, RTE_E_KeyMCertificateElement_Ssa_TrustModelBackendCert_Version_KEYM_E_KEY_CERT_EMPTY, RTE_E_KeyMCertificateElement_Ssa_TrustModelBackendCert_Version_KEYM_E_KEY_CERT_INVALID, RTE_E_KeyMCertificateElement_Ssa_TrustModelBackendCert_Version_KEYM_E_KEY_CERT_SIZE_MISMATCH, RTE_E_KeyMCertificateElement_Ssa_TrustModelBackendCert_Version_KEYM_E_PARAMETER_MISMATCH
 *   Std_ReturnType Rte_Call_KeyMCertificateElement_Ssa_TrustModelBackendCert_ext_authKeyId_CertificateElementGet(uint8 *CertificateElementData, uint32 *CertificateDataLength)
 *     Argument CertificateElementData: uint8* is of type KeyM_CertificateElementType_Ssa_TrustModelBackendCert_ext_authKeyId
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_KeyMCertificateElement_Ssa_TrustModelBackendCert_ext_authKeyId_E_NOT_OK, RTE_E_KeyMCertificateElement_Ssa_TrustModelBackendCert_ext_authKeyId_KEYM_E_KEY_CERT_EMPTY, RTE_E_KeyMCertificateElement_Ssa_TrustModelBackendCert_ext_authKeyId_KEYM_E_KEY_CERT_INVALID, RTE_E_KeyMCertificateElement_Ssa_TrustModelBackendCert_ext_authKeyId_KEYM_E_KEY_CERT_SIZE_MISMATCH, RTE_E_KeyMCertificateElement_Ssa_TrustModelBackendCert_ext_authKeyId_KEYM_E_PARAMETER_MISMATCH
 *   Std_ReturnType Rte_Call_KeyMCertificateElement_Ssa_TrustModelBackendCert_ext_basicConstraints_CertificateElementGet(uint8 *CertificateElementData, uint32 *CertificateDataLength)
 *     Argument CertificateElementData: uint8* is of type KeyM_CertificateElementType_Ssa_TrustModelBackendCert_ext_basicConstraints
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_KeyMCertificateElement_Ssa_TrustModelBackendCert_ext_basicConstraints_E_NOT_OK, RTE_E_KeyMCertificateElement_Ssa_TrustModelBackendCert_ext_basicConstraints_KEYM_E_KEY_CERT_EMPTY, RTE_E_KeyMCertificateElement_Ssa_TrustModelBackendCert_ext_basicConstraints_KEYM_E_KEY_CERT_INVALID, RTE_E_KeyMCertificateElement_Ssa_TrustModelBackendCert_ext_basicConstraints_KEYM_E_KEY_CERT_SIZE_MISMATCH, RTE_E_KeyMCertificateElement_Ssa_TrustModelBackendCert_ext_basicConstraints_KEYM_E_PARAMETER_MISMATCH
 *   Std_ReturnType Rte_Call_KeyMCertificateElement_Ssa_TrustModelBackendCert_ext_subKeyId_CertificateElementGet(uint8 *CertificateElementData, uint32 *CertificateDataLength)
 *     Argument CertificateElementData: uint8* is of type KeyM_CertificateElementType_Ssa_TrustModelBackendCert_ext_subKeyId
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_KeyMCertificateElement_Ssa_TrustModelBackendCert_ext_subKeyId_E_NOT_OK, RTE_E_KeyMCertificateElement_Ssa_TrustModelBackendCert_ext_subKeyId_KEYM_E_KEY_CERT_EMPTY, RTE_E_KeyMCertificateElement_Ssa_TrustModelBackendCert_ext_subKeyId_KEYM_E_KEY_CERT_INVALID, RTE_E_KeyMCertificateElement_Ssa_TrustModelBackendCert_ext_subKeyId_KEYM_E_KEY_CERT_SIZE_MISMATCH, RTE_E_KeyMCertificateElement_Ssa_TrustModelBackendCert_ext_subKeyId_KEYM_E_PARAMETER_MISMATCH
 *   Std_ReturnType Rte_Call_KeyMCertificateElement_Ssa_TrustModelBackendCert_subject_CertificateElementGet(uint8 *CertificateElementData, uint32 *CertificateDataLength)
 *     Argument CertificateElementData: uint8* is of type KeyM_CertificateElementType_Ssa_TrustModelBackendCert_subject
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_KeyMCertificateElement_Ssa_TrustModelBackendCert_subject_E_NOT_OK, RTE_E_KeyMCertificateElement_Ssa_TrustModelBackendCert_subject_KEYM_E_KEY_CERT_EMPTY, RTE_E_KeyMCertificateElement_Ssa_TrustModelBackendCert_subject_KEYM_E_KEY_CERT_INVALID, RTE_E_KeyMCertificateElement_Ssa_TrustModelBackendCert_subject_KEYM_E_KEY_CERT_SIZE_MISMATCH, RTE_E_KeyMCertificateElement_Ssa_TrustModelBackendCert_subject_KEYM_E_PARAMETER_MISMATCH
 *   Std_ReturnType Rte_Call_KeyMCertificateElement_Ssa_TrustModelBackendCert_validityNotAfter_CertificateElementGet(uint8 *CertificateElementData, uint32 *CertificateDataLength)
 *     Argument CertificateElementData: uint8* is of type KeyM_CertificateElementType_Ssa_TrustModelBackendCert_validityNotAfter
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_KeyMCertificateElement_Ssa_TrustModelBackendCert_validityNotAfter_E_NOT_OK, RTE_E_KeyMCertificateElement_Ssa_TrustModelBackendCert_validityNotAfter_KEYM_E_KEY_CERT_EMPTY, RTE_E_KeyMCertificateElement_Ssa_TrustModelBackendCert_validityNotAfter_KEYM_E_KEY_CERT_INVALID, RTE_E_KeyMCertificateElement_Ssa_TrustModelBackendCert_validityNotAfter_KEYM_E_KEY_CERT_SIZE_MISMATCH, RTE_E_KeyMCertificateElement_Ssa_TrustModelBackendCert_validityNotAfter_KEYM_E_PARAMETER_MISMATCH
 *   Std_ReturnType Rte_Call_KeyMCertificateElement_Ssa_TrustModelEcuCert_Issuer_CertificateElementGet(uint8 *CertificateElementData, uint32 *CertificateDataLength)
 *     Argument CertificateElementData: uint8* is of type KeyM_CertificateElementType_Ssa_TrustModelEcuCert_Issuer
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_KeyMCertificateElement_Ssa_TrustModelEcuCert_Issuer_E_NOT_OK, RTE_E_KeyMCertificateElement_Ssa_TrustModelEcuCert_Issuer_KEYM_E_KEY_CERT_EMPTY, RTE_E_KeyMCertificateElement_Ssa_TrustModelEcuCert_Issuer_KEYM_E_KEY_CERT_INVALID, RTE_E_KeyMCertificateElement_Ssa_TrustModelEcuCert_Issuer_KEYM_E_KEY_CERT_SIZE_MISMATCH, RTE_E_KeyMCertificateElement_Ssa_TrustModelEcuCert_Issuer_KEYM_E_PARAMETER_MISMATCH
 *   Std_ReturnType Rte_Call_KeyMCertificateElement_Ssa_TrustModelEcuCert_SerialNo_CertificateElementGet(uint8 *CertificateElementData, uint32 *CertificateDataLength)
 *     Argument CertificateElementData: uint8* is of type KeyM_CertificateElementType_Ssa_TrustModelEcuCert_SerialNo
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_KeyMCertificateElement_Ssa_TrustModelEcuCert_SerialNo_E_NOT_OK, RTE_E_KeyMCertificateElement_Ssa_TrustModelEcuCert_SerialNo_KEYM_E_KEY_CERT_EMPTY, RTE_E_KeyMCertificateElement_Ssa_TrustModelEcuCert_SerialNo_KEYM_E_KEY_CERT_INVALID, RTE_E_KeyMCertificateElement_Ssa_TrustModelEcuCert_SerialNo_KEYM_E_KEY_CERT_SIZE_MISMATCH, RTE_E_KeyMCertificateElement_Ssa_TrustModelEcuCert_SerialNo_KEYM_E_PARAMETER_MISMATCH
 *   Std_ReturnType Rte_Call_KeyMCertificateElement_Ssa_TrustModelEcuCert_SubjectPublicKeyInfoKey_CertificateElementGet(uint8 *CertificateElementData, uint32 *CertificateDataLength)
 *     Argument CertificateElementData: uint8* is of type KeyM_CertificateElementType_Ssa_TrustModelEcuCert_SubjectPublicKeyInfoKey
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_KeyMCertificateElement_Ssa_TrustModelEcuCert_SubjectPublicKeyInfoKey_E_NOT_OK, RTE_E_KeyMCertificateElement_Ssa_TrustModelEcuCert_SubjectPublicKeyInfoKey_KEYM_E_KEY_CERT_EMPTY, RTE_E_KeyMCertificateElement_Ssa_TrustModelEcuCert_SubjectPublicKeyInfoKey_KEYM_E_KEY_CERT_INVALID, RTE_E_KeyMCertificateElement_Ssa_TrustModelEcuCert_SubjectPublicKeyInfoKey_KEYM_E_KEY_CERT_SIZE_MISMATCH, RTE_E_KeyMCertificateElement_Ssa_TrustModelEcuCert_SubjectPublicKeyInfoKey_KEYM_E_PARAMETER_MISMATCH
 *   Std_ReturnType Rte_Call_KeyMCertificateElement_Ssa_TrustModelEcuCert_Version_CertificateElementGet(uint8 *CertificateElementData, uint32 *CertificateDataLength)
 *     Argument CertificateElementData: uint8* is of type KeyM_CertificateElementType_Ssa_TrustModelEcuCert_Version
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_KeyMCertificateElement_Ssa_TrustModelEcuCert_Version_E_NOT_OK, RTE_E_KeyMCertificateElement_Ssa_TrustModelEcuCert_Version_KEYM_E_KEY_CERT_EMPTY, RTE_E_KeyMCertificateElement_Ssa_TrustModelEcuCert_Version_KEYM_E_KEY_CERT_INVALID, RTE_E_KeyMCertificateElement_Ssa_TrustModelEcuCert_Version_KEYM_E_KEY_CERT_SIZE_MISMATCH, RTE_E_KeyMCertificateElement_Ssa_TrustModelEcuCert_Version_KEYM_E_PARAMETER_MISMATCH
 *   Std_ReturnType Rte_Call_KeyMCertificateElement_Ssa_TrustModelEcuCert_ext_authKeyId_CertificateElementGet(uint8 *CertificateElementData, uint32 *CertificateDataLength)
 *     Argument CertificateElementData: uint8* is of type KeyM_CertificateElementType_Ssa_TrustModelEcuCert_ext_authKeyId
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_KeyMCertificateElement_Ssa_TrustModelEcuCert_ext_authKeyId_E_NOT_OK, RTE_E_KeyMCertificateElement_Ssa_TrustModelEcuCert_ext_authKeyId_KEYM_E_KEY_CERT_EMPTY, RTE_E_KeyMCertificateElement_Ssa_TrustModelEcuCert_ext_authKeyId_KEYM_E_KEY_CERT_INVALID, RTE_E_KeyMCertificateElement_Ssa_TrustModelEcuCert_ext_authKeyId_KEYM_E_KEY_CERT_SIZE_MISMATCH, RTE_E_KeyMCertificateElement_Ssa_TrustModelEcuCert_ext_authKeyId_KEYM_E_PARAMETER_MISMATCH
 *   Std_ReturnType Rte_Call_KeyMCertificateElement_Ssa_TrustModelEcuCert_ext_specialEcu_CertificateElementGet(uint8 *CertificateElementData, uint32 *CertificateDataLength)
 *     Argument CertificateElementData: uint8* is of type KeyM_CertificateElementType_Ssa_TrustModelEcuCert_ext_specialEcu
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_KeyMCertificateElement_Ssa_TrustModelEcuCert_ext_specialEcu_E_NOT_OK, RTE_E_KeyMCertificateElement_Ssa_TrustModelEcuCert_ext_specialEcu_KEYM_E_KEY_CERT_EMPTY, RTE_E_KeyMCertificateElement_Ssa_TrustModelEcuCert_ext_specialEcu_KEYM_E_KEY_CERT_INVALID, RTE_E_KeyMCertificateElement_Ssa_TrustModelEcuCert_ext_specialEcu_KEYM_E_KEY_CERT_SIZE_MISMATCH, RTE_E_KeyMCertificateElement_Ssa_TrustModelEcuCert_ext_specialEcu_KEYM_E_PARAMETER_MISMATCH
 *   Std_ReturnType Rte_Call_KeyMCertificateElement_Ssa_TrustModelEcuCert_ext_subKeyId_CertificateElementGet(uint8 *CertificateElementData, uint32 *CertificateDataLength)
 *     Argument CertificateElementData: uint8* is of type KeyM_CertificateElementType_Ssa_TrustModelEcuCert_ext_subKeyId
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_KeyMCertificateElement_Ssa_TrustModelEcuCert_ext_subKeyId_E_NOT_OK, RTE_E_KeyMCertificateElement_Ssa_TrustModelEcuCert_ext_subKeyId_KEYM_E_KEY_CERT_EMPTY, RTE_E_KeyMCertificateElement_Ssa_TrustModelEcuCert_ext_subKeyId_KEYM_E_KEY_CERT_INVALID, RTE_E_KeyMCertificateElement_Ssa_TrustModelEcuCert_ext_subKeyId_KEYM_E_KEY_CERT_SIZE_MISMATCH, RTE_E_KeyMCertificateElement_Ssa_TrustModelEcuCert_ext_subKeyId_KEYM_E_PARAMETER_MISMATCH
 *   Std_ReturnType Rte_Call_KeyMCertificateElement_Ssa_TrustModelEcuCert_ext_uniqueECUID_CertificateElementGet(uint8 *CertificateElementData, uint32 *CertificateDataLength)
 *     Argument CertificateElementData: uint8* is of type KeyM_CertificateElementType_Ssa_TrustModelEcuCert_ext_uniqueECUID
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_KeyMCertificateElement_Ssa_TrustModelEcuCert_ext_uniqueECUID_E_NOT_OK, RTE_E_KeyMCertificateElement_Ssa_TrustModelEcuCert_ext_uniqueECUID_KEYM_E_KEY_CERT_EMPTY, RTE_E_KeyMCertificateElement_Ssa_TrustModelEcuCert_ext_uniqueECUID_KEYM_E_KEY_CERT_INVALID, RTE_E_KeyMCertificateElement_Ssa_TrustModelEcuCert_ext_uniqueECUID_KEYM_E_KEY_CERT_SIZE_MISMATCH, RTE_E_KeyMCertificateElement_Ssa_TrustModelEcuCert_ext_uniqueECUID_KEYM_E_PARAMETER_MISMATCH
 *   Std_ReturnType Rte_Call_KeyMCertificateElement_Ssa_TrustModelEcuCert_subject_CertificateElementGet(uint8 *CertificateElementData, uint32 *CertificateDataLength)
 *     Argument CertificateElementData: uint8* is of type KeyM_CertificateElementType_Ssa_TrustModelEcuCert_subject
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_KeyMCertificateElement_Ssa_TrustModelEcuCert_subject_E_NOT_OK, RTE_E_KeyMCertificateElement_Ssa_TrustModelEcuCert_subject_KEYM_E_KEY_CERT_EMPTY, RTE_E_KeyMCertificateElement_Ssa_TrustModelEcuCert_subject_KEYM_E_KEY_CERT_INVALID, RTE_E_KeyMCertificateElement_Ssa_TrustModelEcuCert_subject_KEYM_E_KEY_CERT_SIZE_MISMATCH, RTE_E_KeyMCertificateElement_Ssa_TrustModelEcuCert_subject_KEYM_E_PARAMETER_MISMATCH
 *   Std_ReturnType Rte_Call_KeyMCertificateElement_Ssa_TrustModelEcuCert_validityNotAfter_CertificateElementGet(uint8 *CertificateElementData, uint32 *CertificateDataLength)
 *     Argument CertificateElementData: uint8* is of type KeyM_CertificateElementType_Ssa_TrustModelEcuCert_validityNotAfter
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_KeyMCertificateElement_Ssa_TrustModelEcuCert_validityNotAfter_E_NOT_OK, RTE_E_KeyMCertificateElement_Ssa_TrustModelEcuCert_validityNotAfter_KEYM_E_KEY_CERT_EMPTY, RTE_E_KeyMCertificateElement_Ssa_TrustModelEcuCert_validityNotAfter_KEYM_E_KEY_CERT_INVALID, RTE_E_KeyMCertificateElement_Ssa_TrustModelEcuCert_validityNotAfter_KEYM_E_KEY_CERT_SIZE_MISMATCH, RTE_E_KeyMCertificateElement_Ssa_TrustModelEcuCert_validityNotAfter_KEYM_E_PARAMETER_MISMATCH
 *   Std_ReturnType Rte_Call_KeyMCertificateElement_Ssa_TrustModelIntermediateCert_Issuer_CertificateElementGet(uint8 *CertificateElementData, uint32 *CertificateDataLength)
 *     Argument CertificateElementData: uint8* is of type KeyM_CertificateElementType_Ssa_TrustModelIntermediateCert_Issuer
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_KeyMCertificateElement_Ssa_TrustModelIntermediateCert_Issuer_E_NOT_OK, RTE_E_KeyMCertificateElement_Ssa_TrustModelIntermediateCert_Issuer_KEYM_E_KEY_CERT_EMPTY, RTE_E_KeyMCertificateElement_Ssa_TrustModelIntermediateCert_Issuer_KEYM_E_KEY_CERT_INVALID, RTE_E_KeyMCertificateElement_Ssa_TrustModelIntermediateCert_Issuer_KEYM_E_KEY_CERT_SIZE_MISMATCH, RTE_E_KeyMCertificateElement_Ssa_TrustModelIntermediateCert_Issuer_KEYM_E_PARAMETER_MISMATCH
 *   Std_ReturnType Rte_Call_KeyMCertificateElement_Ssa_TrustModelIntermediateCert_SerialNo_CertificateElementGet(uint8 *CertificateElementData, uint32 *CertificateDataLength)
 *     Argument CertificateElementData: uint8* is of type KeyM_CertificateElementType_Ssa_TrustModelIntermediateCert_SerialNo
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_KeyMCertificateElement_Ssa_TrustModelIntermediateCert_SerialNo_E_NOT_OK, RTE_E_KeyMCertificateElement_Ssa_TrustModelIntermediateCert_SerialNo_KEYM_E_KEY_CERT_EMPTY, RTE_E_KeyMCertificateElement_Ssa_TrustModelIntermediateCert_SerialNo_KEYM_E_KEY_CERT_INVALID, RTE_E_KeyMCertificateElement_Ssa_TrustModelIntermediateCert_SerialNo_KEYM_E_KEY_CERT_SIZE_MISMATCH, RTE_E_KeyMCertificateElement_Ssa_TrustModelIntermediateCert_SerialNo_KEYM_E_PARAMETER_MISMATCH
 *   Std_ReturnType Rte_Call_KeyMCertificateElement_Ssa_TrustModelIntermediateCert_SubjectPublicKeyInfoKey_CertificateElementGet(uint8 *CertificateElementData, uint32 *CertificateDataLength)
 *     Argument CertificateElementData: uint8* is of type KeyM_CertificateElementType_Ssa_TrustModelIntermediateCert_SubjectPublicKeyInfoKey
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_KeyMCertificateElement_Ssa_TrustModelIntermediateCert_SubjectPublicKeyInfoKey_E_NOT_OK, RTE_E_KeyMCertificateElement_Ssa_TrustModelIntermediateCert_SubjectPublicKeyInfoKey_KEYM_E_KEY_CERT_EMPTY, RTE_E_KeyMCertificateElement_Ssa_TrustModelIntermediateCert_SubjectPublicKeyInfoKey_KEYM_E_KEY_CERT_INVALID, RTE_E_KeyMCertificateElement_Ssa_TrustModelIntermediateCert_SubjectPublicKeyInfoKey_KEYM_E_KEY_CERT_SIZE_MISMATCH, RTE_E_KeyMCertificateElement_Ssa_TrustModelIntermediateCert_SubjectPublicKeyInfoKey_KEYM_E_PARAMETER_MISMATCH
 *   Std_ReturnType Rte_Call_KeyMCertificateElement_Ssa_TrustModelIntermediateCert_Version_CertificateElementGet(uint8 *CertificateElementData, uint32 *CertificateDataLength)
 *     Argument CertificateElementData: uint8* is of type KeyM_CertificateElementType_Ssa_TrustModelIntermediateCert_Version
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_KeyMCertificateElement_Ssa_TrustModelIntermediateCert_Version_E_NOT_OK, RTE_E_KeyMCertificateElement_Ssa_TrustModelIntermediateCert_Version_KEYM_E_KEY_CERT_EMPTY, RTE_E_KeyMCertificateElement_Ssa_TrustModelIntermediateCert_Version_KEYM_E_KEY_CERT_INVALID, RTE_E_KeyMCertificateElement_Ssa_TrustModelIntermediateCert_Version_KEYM_E_KEY_CERT_SIZE_MISMATCH, RTE_E_KeyMCertificateElement_Ssa_TrustModelIntermediateCert_Version_KEYM_E_PARAMETER_MISMATCH
 *   Std_ReturnType Rte_Call_KeyMCertificateElement_Ssa_TrustModelIntermediateCert_ext_authKeyId_CertificateElementGet(uint8 *CertificateElementData, uint32 *CertificateDataLength)
 *     Argument CertificateElementData: uint8* is of type KeyM_CertificateElementType_Ssa_TrustModelIntermediateCert_ext_authKeyId
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_KeyMCertificateElement_Ssa_TrustModelIntermediateCert_ext_authKeyId_E_NOT_OK, RTE_E_KeyMCertificateElement_Ssa_TrustModelIntermediateCert_ext_authKeyId_KEYM_E_KEY_CERT_EMPTY, RTE_E_KeyMCertificateElement_Ssa_TrustModelIntermediateCert_ext_authKeyId_KEYM_E_KEY_CERT_INVALID, RTE_E_KeyMCertificateElement_Ssa_TrustModelIntermediateCert_ext_authKeyId_KEYM_E_KEY_CERT_SIZE_MISMATCH, RTE_E_KeyMCertificateElement_Ssa_TrustModelIntermediateCert_ext_authKeyId_KEYM_E_PARAMETER_MISMATCH
 *   Std_ReturnType Rte_Call_KeyMCertificateElement_Ssa_TrustModelIntermediateCert_ext_basicConstraints_CertificateElementGet(uint8 *CertificateElementData, uint32 *CertificateDataLength)
 *     Argument CertificateElementData: uint8* is of type KeyM_CertificateElementType_Ssa_TrustModelIntermediateCert_ext_basicConstraints
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_KeyMCertificateElement_Ssa_TrustModelIntermediateCert_ext_basicConstraints_E_NOT_OK, RTE_E_KeyMCertificateElement_Ssa_TrustModelIntermediateCert_ext_basicConstraints_KEYM_E_KEY_CERT_EMPTY, RTE_E_KeyMCertificateElement_Ssa_TrustModelIntermediateCert_ext_basicConstraints_KEYM_E_KEY_CERT_INVALID, RTE_E_KeyMCertificateElement_Ssa_TrustModelIntermediateCert_ext_basicConstraints_KEYM_E_KEY_CERT_SIZE_MISMATCH, RTE_E_KeyMCertificateElement_Ssa_TrustModelIntermediateCert_ext_basicConstraints_KEYM_E_PARAMETER_MISMATCH
 *   Std_ReturnType Rte_Call_KeyMCertificateElement_Ssa_TrustModelIntermediateCert_ext_subKeyId_CertificateElementGet(uint8 *CertificateElementData, uint32 *CertificateDataLength)
 *     Argument CertificateElementData: uint8* is of type KeyM_CertificateElementType_Ssa_TrustModelIntermediateCert_ext_subKeyId
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_KeyMCertificateElement_Ssa_TrustModelIntermediateCert_ext_subKeyId_E_NOT_OK, RTE_E_KeyMCertificateElement_Ssa_TrustModelIntermediateCert_ext_subKeyId_KEYM_E_KEY_CERT_EMPTY, RTE_E_KeyMCertificateElement_Ssa_TrustModelIntermediateCert_ext_subKeyId_KEYM_E_KEY_CERT_INVALID, RTE_E_KeyMCertificateElement_Ssa_TrustModelIntermediateCert_ext_subKeyId_KEYM_E_KEY_CERT_SIZE_MISMATCH, RTE_E_KeyMCertificateElement_Ssa_TrustModelIntermediateCert_ext_subKeyId_KEYM_E_PARAMETER_MISMATCH
 *   Std_ReturnType Rte_Call_KeyMCertificateElement_Ssa_TrustModelIntermediateCert_subject_CertificateElementGet(uint8 *CertificateElementData, uint32 *CertificateDataLength)
 *     Argument CertificateElementData: uint8* is of type KeyM_CertificateElementType_Ssa_TrustModelIntermediateCert_subject
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_KeyMCertificateElement_Ssa_TrustModelIntermediateCert_subject_E_NOT_OK, RTE_E_KeyMCertificateElement_Ssa_TrustModelIntermediateCert_subject_KEYM_E_KEY_CERT_EMPTY, RTE_E_KeyMCertificateElement_Ssa_TrustModelIntermediateCert_subject_KEYM_E_KEY_CERT_INVALID, RTE_E_KeyMCertificateElement_Ssa_TrustModelIntermediateCert_subject_KEYM_E_KEY_CERT_SIZE_MISMATCH, RTE_E_KeyMCertificateElement_Ssa_TrustModelIntermediateCert_subject_KEYM_E_PARAMETER_MISMATCH
 *   Std_ReturnType Rte_Call_KeyMCertificateElement_Ssa_TrustModelIntermediateCert_validityNotAfter_CertificateElementGet(uint8 *CertificateElementData, uint32 *CertificateDataLength)
 *     Argument CertificateElementData: uint8* is of type KeyM_CertificateElementType_Ssa_TrustModelIntermediateCert_validityNotAfter
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_KeyMCertificateElement_Ssa_TrustModelIntermediateCert_validityNotAfter_E_NOT_OK, RTE_E_KeyMCertificateElement_Ssa_TrustModelIntermediateCert_validityNotAfter_KEYM_E_KEY_CERT_EMPTY, RTE_E_KeyMCertificateElement_Ssa_TrustModelIntermediateCert_validityNotAfter_KEYM_E_KEY_CERT_INVALID, RTE_E_KeyMCertificateElement_Ssa_TrustModelIntermediateCert_validityNotAfter_KEYM_E_KEY_CERT_SIZE_MISMATCH, RTE_E_KeyMCertificateElement_Ssa_TrustModelIntermediateCert_validityNotAfter_KEYM_E_PARAMETER_MISMATCH
 *   Std_ReturnType Rte_Call_KeyMCertificateElement_Ssa_TrustModelRootCert_Issuer_CertificateElementGet(uint8 *CertificateElementData, uint32 *CertificateDataLength)
 *     Argument CertificateElementData: uint8* is of type KeyM_CertificateElementType_Ssa_TrustModelRootCert_Issuer
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_KeyMCertificateElement_Ssa_TrustModelRootCert_Issuer_E_NOT_OK, RTE_E_KeyMCertificateElement_Ssa_TrustModelRootCert_Issuer_KEYM_E_KEY_CERT_EMPTY, RTE_E_KeyMCertificateElement_Ssa_TrustModelRootCert_Issuer_KEYM_E_KEY_CERT_INVALID, RTE_E_KeyMCertificateElement_Ssa_TrustModelRootCert_Issuer_KEYM_E_KEY_CERT_SIZE_MISMATCH, RTE_E_KeyMCertificateElement_Ssa_TrustModelRootCert_Issuer_KEYM_E_PARAMETER_MISMATCH
 *   Std_ReturnType Rte_Call_KeyMCertificateElement_Ssa_TrustModelRootCert_SerialNo_CertificateElementGet(uint8 *CertificateElementData, uint32 *CertificateDataLength)
 *     Argument CertificateElementData: uint8* is of type KeyM_CertificateElementType_Ssa_TrustModelRootCert_SerialNo
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_KeyMCertificateElement_Ssa_TrustModelRootCert_SerialNo_E_NOT_OK, RTE_E_KeyMCertificateElement_Ssa_TrustModelRootCert_SerialNo_KEYM_E_KEY_CERT_EMPTY, RTE_E_KeyMCertificateElement_Ssa_TrustModelRootCert_SerialNo_KEYM_E_KEY_CERT_INVALID, RTE_E_KeyMCertificateElement_Ssa_TrustModelRootCert_SerialNo_KEYM_E_KEY_CERT_SIZE_MISMATCH, RTE_E_KeyMCertificateElement_Ssa_TrustModelRootCert_SerialNo_KEYM_E_PARAMETER_MISMATCH
 *   Std_ReturnType Rte_Call_KeyMCertificateElement_Ssa_TrustModelRootCert_SubjectPublicKeyInfoKey_CertificateElementGet(uint8 *CertificateElementData, uint32 *CertificateDataLength)
 *     Argument CertificateElementData: uint8* is of type KeyM_CertificateElementType_Ssa_TrustModelRootCert_SubjectPublicKeyInfoKey
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_KeyMCertificateElement_Ssa_TrustModelRootCert_SubjectPublicKeyInfoKey_E_NOT_OK, RTE_E_KeyMCertificateElement_Ssa_TrustModelRootCert_SubjectPublicKeyInfoKey_KEYM_E_KEY_CERT_EMPTY, RTE_E_KeyMCertificateElement_Ssa_TrustModelRootCert_SubjectPublicKeyInfoKey_KEYM_E_KEY_CERT_INVALID, RTE_E_KeyMCertificateElement_Ssa_TrustModelRootCert_SubjectPublicKeyInfoKey_KEYM_E_KEY_CERT_SIZE_MISMATCH, RTE_E_KeyMCertificateElement_Ssa_TrustModelRootCert_SubjectPublicKeyInfoKey_KEYM_E_PARAMETER_MISMATCH
 *   Std_ReturnType Rte_Call_KeyMCertificateElement_Ssa_TrustModelRootCert_Version_CertificateElementGet(uint8 *CertificateElementData, uint32 *CertificateDataLength)
 *     Argument CertificateElementData: uint8* is of type KeyM_CertificateElementType_Ssa_TrustModelRootCert_Version
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_KeyMCertificateElement_Ssa_TrustModelRootCert_Version_E_NOT_OK, RTE_E_KeyMCertificateElement_Ssa_TrustModelRootCert_Version_KEYM_E_KEY_CERT_EMPTY, RTE_E_KeyMCertificateElement_Ssa_TrustModelRootCert_Version_KEYM_E_KEY_CERT_INVALID, RTE_E_KeyMCertificateElement_Ssa_TrustModelRootCert_Version_KEYM_E_KEY_CERT_SIZE_MISMATCH, RTE_E_KeyMCertificateElement_Ssa_TrustModelRootCert_Version_KEYM_E_PARAMETER_MISMATCH
 *   Std_ReturnType Rte_Call_KeyMCertificateElement_Ssa_TrustModelRootCert_ext_basicConstraints_CertificateElementGet(uint8 *CertificateElementData, uint32 *CertificateDataLength)
 *     Argument CertificateElementData: uint8* is of type KeyM_CertificateElementType_Ssa_TrustModelRootCert_ext_basicConstraints
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_KeyMCertificateElement_Ssa_TrustModelRootCert_ext_basicConstraints_E_NOT_OK, RTE_E_KeyMCertificateElement_Ssa_TrustModelRootCert_ext_basicConstraints_KEYM_E_KEY_CERT_EMPTY, RTE_E_KeyMCertificateElement_Ssa_TrustModelRootCert_ext_basicConstraints_KEYM_E_KEY_CERT_INVALID, RTE_E_KeyMCertificateElement_Ssa_TrustModelRootCert_ext_basicConstraints_KEYM_E_KEY_CERT_SIZE_MISMATCH, RTE_E_KeyMCertificateElement_Ssa_TrustModelRootCert_ext_basicConstraints_KEYM_E_PARAMETER_MISMATCH
 *   Std_ReturnType Rte_Call_KeyMCertificateElement_Ssa_TrustModelRootCert_ext_keyUsage_CertificateElementGet(uint8 *CertificateElementData, uint32 *CertificateDataLength)
 *     Argument CertificateElementData: uint8* is of type KeyM_CertificateElementType_Ssa_TrustModelRootCert_ext_keyUsage
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_KeyMCertificateElement_Ssa_TrustModelRootCert_ext_keyUsage_E_NOT_OK, RTE_E_KeyMCertificateElement_Ssa_TrustModelRootCert_ext_keyUsage_KEYM_E_KEY_CERT_EMPTY, RTE_E_KeyMCertificateElement_Ssa_TrustModelRootCert_ext_keyUsage_KEYM_E_KEY_CERT_INVALID, RTE_E_KeyMCertificateElement_Ssa_TrustModelRootCert_ext_keyUsage_KEYM_E_KEY_CERT_SIZE_MISMATCH, RTE_E_KeyMCertificateElement_Ssa_TrustModelRootCert_ext_keyUsage_KEYM_E_PARAMETER_MISMATCH
 *   Std_ReturnType Rte_Call_KeyMCertificateElement_Ssa_TrustModelRootCert_ext_subKeyId_CertificateElementGet(uint8 *CertificateElementData, uint32 *CertificateDataLength)
 *     Argument CertificateElementData: uint8* is of type KeyM_CertificateElementType_Ssa_TrustModelRootCert_ext_subKeyId
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_KeyMCertificateElement_Ssa_TrustModelRootCert_ext_subKeyId_E_NOT_OK, RTE_E_KeyMCertificateElement_Ssa_TrustModelRootCert_ext_subKeyId_KEYM_E_KEY_CERT_EMPTY, RTE_E_KeyMCertificateElement_Ssa_TrustModelRootCert_ext_subKeyId_KEYM_E_KEY_CERT_INVALID, RTE_E_KeyMCertificateElement_Ssa_TrustModelRootCert_ext_subKeyId_KEYM_E_KEY_CERT_SIZE_MISMATCH, RTE_E_KeyMCertificateElement_Ssa_TrustModelRootCert_ext_subKeyId_KEYM_E_PARAMETER_MISMATCH
 *   Std_ReturnType Rte_Call_KeyMCertificateElement_Ssa_TrustModelRootCert_subject_CertificateElementGet(uint8 *CertificateElementData, uint32 *CertificateDataLength)
 *     Argument CertificateElementData: uint8* is of type KeyM_CertificateElementType_Ssa_TrustModelRootCert_subject
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_KeyMCertificateElement_Ssa_TrustModelRootCert_subject_E_NOT_OK, RTE_E_KeyMCertificateElement_Ssa_TrustModelRootCert_subject_KEYM_E_KEY_CERT_EMPTY, RTE_E_KeyMCertificateElement_Ssa_TrustModelRootCert_subject_KEYM_E_KEY_CERT_INVALID, RTE_E_KeyMCertificateElement_Ssa_TrustModelRootCert_subject_KEYM_E_KEY_CERT_SIZE_MISMATCH, RTE_E_KeyMCertificateElement_Ssa_TrustModelRootCert_subject_KEYM_E_PARAMETER_MISMATCH
 *   Std_ReturnType Rte_Call_KeyMCertificateElement_Ssa_TrustModelRootCert_validityNotAfter_CertificateElementGet(uint8 *CertificateElementData, uint32 *CertificateDataLength)
 *     Argument CertificateElementData: uint8* is of type KeyM_CertificateElementType_Ssa_TrustModelRootCert_validityNotAfter
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_KeyMCertificateElement_Ssa_TrustModelRootCert_validityNotAfter_E_NOT_OK, RTE_E_KeyMCertificateElement_Ssa_TrustModelRootCert_validityNotAfter_KEYM_E_KEY_CERT_EMPTY, RTE_E_KeyMCertificateElement_Ssa_TrustModelRootCert_validityNotAfter_KEYM_E_KEY_CERT_INVALID, RTE_E_KeyMCertificateElement_Ssa_TrustModelRootCert_validityNotAfter_KEYM_E_KEY_CERT_SIZE_MISMATCH, RTE_E_KeyMCertificateElement_Ssa_TrustModelRootCert_validityNotAfter_KEYM_E_PARAMETER_MISMATCH
 *   Std_ReturnType Rte_Call_KeyMCertificate_Ssa_TrustModelBackendCert_GetStatus(KeyM_CertificateStatusType *Status)
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_KeyMCertificate_Ssa_TrustModelBackendCert_E_NOT_OK
 *   Std_ReturnType Rte_Call_KeyMCertificate_Ssa_TrustModelEcuCert_GetStatus(KeyM_CertificateStatusType *Status)
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_KeyMCertificate_Ssa_TrustModelEcuCert_E_NOT_OK
 *   Std_ReturnType Rte_Call_KeyMCertificate_Ssa_TrustModelEcuCert_VerifyCertificate(void)
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_KeyMCertificate_Ssa_TrustModelEcuCert_E_NOT_OK, RTE_E_KeyMCertificate_Ssa_TrustModelEcuCert_KEYM_E_BUSY, RTE_E_KeyMCertificate_Ssa_TrustModelEcuCert_KEYM_E_CERT_INVALID_CHAIN_OF_TRUST, RTE_E_KeyMCertificate_Ssa_TrustModelEcuCert_KEYM_E_KEY_CERT_EMPTY, RTE_E_KeyMCertificate_Ssa_TrustModelEcuCert_KEYM_E_KEY_CERT_SIZE_MISMATCH, RTE_E_KeyMCertificate_Ssa_TrustModelEcuCert_KEYM_E_PARAMETER_MISMATCH
 *   Std_ReturnType Rte_Call_KeyMCertificate_Ssa_TrustModelIntermediateCert_GetStatus(KeyM_CertificateStatusType *Status)
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_KeyMCertificate_Ssa_TrustModelIntermediateCert_E_NOT_OK
 *   Std_ReturnType Rte_Call_KeyMCertificate_Ssa_TrustModelRootCert_GetStatus(KeyM_CertificateStatusType *Status)
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_KeyMCertificate_Ssa_TrustModelRootCert_E_NOT_OK
 *   Std_ReturnType Rte_Call_Key_TrustModelEcuCsrPrivateKey_KeyElementCopy(uint32 keyElementId, uint32 targetKeyId, uint32 targetKeyElementId)
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_CsmKeyManagement_Ssa_TrustModelEcuCsrPrivateKey_CSM_E_BUSY, RTE_E_CsmKeyManagement_Ssa_TrustModelEcuCsrPrivateKey_CSM_E_KEY_EMPTY, RTE_E_CsmKeyManagement_Ssa_TrustModelEcuCsrPrivateKey_CSM_E_KEY_READ_FAIL, RTE_E_CsmKeyManagement_Ssa_TrustModelEcuCsrPrivateKey_CSM_E_KEY_SIZE_MISMATCH, RTE_E_CsmKeyManagement_Ssa_TrustModelEcuCsrPrivateKey_CSM_E_KEY_WRITE_FAIL, RTE_E_CsmKeyManagement_Ssa_TrustModelEcuCsrPrivateKey_CSM_E_SMALL_BUFFER, RTE_E_CsmKeyManagement_Ssa_TrustModelEcuCsrPrivateKey_E_NOT_OK
 *   Std_ReturnType Rte_Call_Key_TrustModelEcuCsrPublicKey_KeyElementCopy(uint32 keyElementId, uint32 targetKeyId, uint32 targetKeyElementId)
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_CsmKeyManagement_Ssa_TrustModelEcuCsrPublicKey_CSM_E_BUSY, RTE_E_CsmKeyManagement_Ssa_TrustModelEcuCsrPublicKey_CSM_E_KEY_EMPTY, RTE_E_CsmKeyManagement_Ssa_TrustModelEcuCsrPublicKey_CSM_E_KEY_READ_FAIL, RTE_E_CsmKeyManagement_Ssa_TrustModelEcuCsrPublicKey_CSM_E_KEY_SIZE_MISMATCH, RTE_E_CsmKeyManagement_Ssa_TrustModelEcuCsrPublicKey_CSM_E_KEY_WRITE_FAIL, RTE_E_CsmKeyManagement_Ssa_TrustModelEcuCsrPublicKey_CSM_E_SMALL_BUFFER, RTE_E_CsmKeyManagement_Ssa_TrustModelEcuCsrPublicKey_E_NOT_OK
 *   Std_ReturnType Rte_Call_Key_TrustModelEcuLivePrivateKey_KeySetValid(void)
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_CsmKeyManagement_Ssa_TrustModelEcuLivePrivateKey_CSM_E_BUSY, RTE_E_CsmKeyManagement_Ssa_TrustModelEcuLivePrivateKey_E_NOT_OK
 *   Std_ReturnType Rte_Call_Key_TrustModelEcuLivePublicKey_KeyElementGet(uint32 keyElementId, uint8 *keyPtr, uint32 *keyLength)
 *     Argument keyPtr: uint8* is of type Csm_KeyDataType_Ssa_TrustModelEcuLivePublicKey
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_CsmKeyManagement_Ssa_TrustModelEcuLivePublicKey_CSM_E_BUSY, RTE_E_CsmKeyManagement_Ssa_TrustModelEcuLivePublicKey_CSM_E_KEY_EMPTY, RTE_E_CsmKeyManagement_Ssa_TrustModelEcuLivePublicKey_CSM_E_KEY_NOT_AVAILABLE, RTE_E_CsmKeyManagement_Ssa_TrustModelEcuLivePublicKey_CSM_E_KEY_READ_FAIL, RTE_E_CsmKeyManagement_Ssa_TrustModelEcuLivePublicKey_CSM_E_SMALL_BUFFER, RTE_E_CsmKeyManagement_Ssa_TrustModelEcuLivePublicKey_E_NOT_OK
 *   Std_ReturnType Rte_Call_Key_TrustModelEcuStagingPrivateKey_KeyElementCopy(uint32 keyElementId, uint32 targetKeyId, uint32 targetKeyElementId)
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_CsmKeyManagement_Ssa_TrustModelEcuStagingPrivateKey_CSM_E_BUSY, RTE_E_CsmKeyManagement_Ssa_TrustModelEcuStagingPrivateKey_CSM_E_KEY_EMPTY, RTE_E_CsmKeyManagement_Ssa_TrustModelEcuStagingPrivateKey_CSM_E_KEY_READ_FAIL, RTE_E_CsmKeyManagement_Ssa_TrustModelEcuStagingPrivateKey_CSM_E_KEY_SIZE_MISMATCH, RTE_E_CsmKeyManagement_Ssa_TrustModelEcuStagingPrivateKey_CSM_E_KEY_WRITE_FAIL, RTE_E_CsmKeyManagement_Ssa_TrustModelEcuStagingPrivateKey_CSM_E_SMALL_BUFFER, RTE_E_CsmKeyManagement_Ssa_TrustModelEcuStagingPrivateKey_E_NOT_OK
 *   Std_ReturnType Rte_Call_Key_TrustModelEcuStagingPrivateKey_KeySetValid(void)
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_CsmKeyManagement_Ssa_TrustModelEcuStagingPrivateKey_CSM_E_BUSY, RTE_E_CsmKeyManagement_Ssa_TrustModelEcuStagingPrivateKey_E_NOT_OK
 *   Std_ReturnType Rte_Call_Key_TrustModelEcuStagingPublicKey_KeySetValid(void)
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_CsmKeyManagement_Ssa_TrustModelEcuStagingPublicKey_CSM_E_BUSY, RTE_E_CsmKeyManagement_Ssa_TrustModelEcuStagingPublicKey_E_NOT_OK
 *   Std_ReturnType Rte_Call_Key_TrustModelTempPublicKey_KeyElementSet(uint32 keyElementId, const uint8 *keyPtr, uint32 keyLength)
 *     Argument keyPtr: uint8* is of type Csm_KeyDataType_Ssa_TrustModelTempPublicKey
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_CsmKeyManagement_Ssa_TrustModelTempPublicKey_CSM_E_BUSY, RTE_E_CsmKeyManagement_Ssa_TrustModelTempPublicKey_CSM_E_KEY_NOT_AVAILABLE, RTE_E_CsmKeyManagement_Ssa_TrustModelTempPublicKey_CSM_E_KEY_SIZE_MISMATCH, RTE_E_CsmKeyManagement_Ssa_TrustModelTempPublicKey_CSM_E_KEY_WRITE_FAIL, RTE_E_CsmKeyManagement_Ssa_TrustModelTempPublicKey_E_NOT_OK
 *   Std_ReturnType Rte_Call_Key_TrustModelTempPublicKey_KeySetValid(void)
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_CsmKeyManagement_Ssa_TrustModelTempPublicKey_CSM_E_BUSY, RTE_E_CsmKeyManagement_Ssa_TrustModelTempPublicKey_E_NOT_OK
 *   Std_ReturnType Rte_Call_NvMService_KeyM_TrustModelChainOfTrustState_GetErrorStatus(NvM_RequestResultType *ErrorStatus)
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_NvMService_AC2_SRBS_E_NOT_OK
 *   Std_ReturnType Rte_Call_NvMService_KeyM_TrustModelChainOfTrustState_WriteBlock(dtRef_const_VOID SrcPtr)
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_NvMService_AC2_SRBS_E_NOT_OK
 *
 **********************************************************************************************************************
 *
 * Runnable prototype:
 * ===================
 *   Std_ReturnType Ssa_KeyM_RoutineServices_Replace_Trust_model_Certificates(const uint8 *Trust_Certificates_In, Dcm_OpStatusType OpStatus, uint8 *routineInfo_Out, uint8 *Verification_Result_Out, uint16 DataLength, Dcm_NegativeResponseCodeType *ErrorCode)
 *     Argument Trust_Certificates_In: uint8* is of type Dcm_Data3006ByteType
 *
 **********************************************************************************************************************
 *
 * Available Application Errors:
 * =============================
 *   RTE_E_RoutineServices_Replace_Trust_model_Certificates_DCM_E_FORCE_RCRRP
 *   RTE_E_RoutineServices_Replace_Trust_model_Certificates_DCM_E_PENDING
 *   RTE_E_RoutineServices_Replace_Trust_model_Certificates_E_NOT_OK
 *
 *********************************************************************************************************************/
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << Start of documentation area >>                  DO NOT CHANGE THIS COMMENT!
 * Symbol: Ssa_KeyM_RoutineServices_Replace_Trust_model_Certificates_doc
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */

/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << End of documentation area >>                    DO NOT CHANGE THIS COMMENT!
 *********************************************************************************************************************/

FUNC(Std_ReturnType, Ssa_KeyM_CODE) Ssa_KeyM_RoutineServices_Replace_Trust_model_Certificates(
  P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) Trust_Certificates_In,
  Dcm_OpStatusType OpStatus,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) routineInfo_Out,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) Verification_Result_Out,
  uint16 DataLength,
  P2VAR(Dcm_NegativeResponseCodeType, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) ErrorCode) /* PRQA S 0624, 3206 */ /* MD_Rte_0624, MD_Rte_3206 */
{
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << Start of runnable implementation >>             DO NOT CHANGE THIS COMMENT!
 * Symbol: Ssa_KeyM_RoutineServices_Replace_Trust_model_Certificates (returns application error)
 *********************************************************************************************************************/
  Std_ReturnType retVal = RTE_E_RoutineServices_Replace_Trust_model_Certificates_E_NOT_OK;

  /* ----- Development Error Checks ------------------------------------- */
#if (SSA_DEV_ERROR_DETECT == STD_ON)
  if ((Trust_Certificates_In == NULL_PTR)
    || (routineInfo_Out == NULL_PTR)
    || (Verification_Result_Out == NULL_PTR)
    || (ErrorCode == NULL_PTR))
  {
    /* retVal already set */
  }
  else
#endif /* SSA_DEV_ERROR_DETECT == STD_ON */
  {

    Dcm_NegativeResponseCodeType errorCode = DCM_E_POSITIVERESPONSE;
    uint8 verificationResult = SSA_VER_RES_TRUST_MODEL_REPLACE_CERTS_CERTIFICATES_VERIFIED_AND_REPLACED;

    /* #10 Replace the Trust Model Backend CA, Intermediate CA and ECU certificate using AsrKeyM.
     *     Go to idle state if service is canceled by DCM.
     *     Proceed only if state is valid. */
    if (OpStatus == DCM_CANCEL)
    {
      /* back to idle state */
      KeyM_DiagProc.state = SSA_KEYM_REPLACE_TRUST_MODEL_CERTS_STATE_IDLE;
      retVal = RTE_E_OK;
      /* use default verification result */
    }
    else if (!KeyM_IsReplaceTrustModelCertsStateValid())
    {
      /* back to idle state */
      KeyM_DiagProc.state = SSA_KEYM_REPLACE_TRUST_MODEL_CERTS_STATE_IDLE;
      errorCode = DCM_E_GENERALREJECT;
    }
    else
    {
      /* #20 If it is the initial call of this routine keep the currently stored certificates for the case
       *     that they have to be restored. */
      if (OpStatus == DCM_INITIAL)
      {
        /* Initialize flags, indices and length values for this routine. */
        KeyM_DiagProc.ws.trustModelReplaceCerts.certLength_ecu = 0u;
        KeyM_DiagProc.ws.trustModelReplaceCerts.certLength_intermediate = 0u;
        KeyM_DiagProc.ws.trustModelReplaceCerts.certLength_backend = 0u;
        KeyM_DiagProc.ws.trustModelReplaceCerts.certIdx_ecu = 0u;
        KeyM_DiagProc.ws.trustModelReplaceCerts.certIdx_intermediate = 0u;
        KeyM_DiagProc.ws.trustModelReplaceCerts.certIdx_backend = 0u;
        KeyM_DiagProc.ws.trustModelReplaceCerts.certLength_ecu_backup = 0u;
        KeyM_DiagProc.ws.trustModelReplaceCerts.certLength_intermediate_backup = 0u;
        KeyM_DiagProc.ws.trustModelReplaceCerts.certLength_backend_backup = 0u;
        KeyM_DiagProc.ws.trustModelReplaceCerts.certIdx_ecu_backup = 0u;
        KeyM_DiagProc.ws.trustModelReplaceCerts.certIdx_intermediate_backup = 0u;
        KeyM_DiagProc.ws.trustModelReplaceCerts.certIdx_backend_backup = 0u;

        /* Initialize verification result with any result != 0. */
        KeyM_DiagProc.ws.trustModelReplaceCerts.verifResultBeforeRollback = SSA_VER_RES_TRUST_MODEL_REPLACE_CERTS_BACKEND_CERTIFICATE_VERIFICATION_FAILED_INVALID_TIME_PERIOD;

        /* KeyM_DiagProc.ws.trustModelReplaceCerts.rollbackState is initialized in KeyM_KeepCurrentCertificates(). */
        KeyM_DiagProc.ws.trustModelReplaceCerts.certificateStatusBackend= KEYM_CERTIFICATE_NOT_AVAILABLE;
        KeyM_DiagProc.ws.trustModelReplaceCerts.certificateStatusIntermediate= KEYM_CERTIFICATE_NOT_AVAILABLE;
        KeyM_DiagProc.ws.trustModelReplaceCerts.certificateStatusEcu= KEYM_CERTIFICATE_NOT_AVAILABLE;
        KeyM_DiagProc.ws.trustModelReplaceCerts.dataLengthBackup = 0u;

        KeyM_KeepCurrentCertificates();
      }

      /* #30 Handle the following states:
       *     SSA_KEYM_REPLACE_TRUST_MODEL_CERTS_STATE_IDLE,
       *     SSA_KEYM_REPLACE_TRUST_MODEL_CERTS_STATE_REQUESTING_SERVICE_CERT_BACKEND,
       *     SSA_KEYM_REPLACE_TRUST_MODEL_CERTS_STATE_AWAITING_VERIFICATION_RESULT_BACKEND_CERT,
       *     SSA_KEYM_REPLACE_TRUST_MODEL_CERTS_STATE_AWAITING_VERIFICATION_RESULT_INTERMEDIATE_CERT,
       *     SSA_KEYM_REPLACE_TRUST_MODEL_CERTS_STATE_AWAITING_PARSING_RESULT_ECU_CERT,
       *     SSA_KEYM_REPLACE_TRUST_MODEL_CERTS_STATE_REQUESTING_FOR_VERIFICATION_ECU_CERT,
       *     SSA_KEYM_REPLACE_TRUST_MODEL_CERTS_STATE_AWAITING_VERIFICATION_RESULT_ECU_CERT,
       *     SSA_KEYM_REPLACE_TRUST_MODEL_CERTS_STATE_VERIFY_TRUST_MODEL_PRIVATE_KEY,
       *     SSA_KEYM_REPLACE_TRUST_MODEL_CERTS_STATE_STORE_INIT,
       *     SSA_KEYM_REPLACE_TRUST_MODEL_CERTS_STATE_STORE_PENDING,
       *     SSA_KEYM_REPLACE_TRUST_MODEL_CERTS_STATE_NVM_WRITE,
       *     SSA_KEYM_REPLACE_TRUST_MODEL_CERTS_STATE_NVM_WAIT.
       *     For rolling back the certificate data use also these state handler functions.
       */
      retVal = KeyM_Replace_Trust_Model_Certificates_State_Handler[KeyM_DiagProc.state](
        (KeyM_DiagProc.ws.trustModelReplaceCerts.rollbackState == SSA_KEYM_ROLLBACK_ONGOING) ? KeyM_DiagProc.ws.trustModelReplaceCerts.trustCertificatesBackup : Trust_Certificates_In,
        OpStatus,
        routineInfo_Out,
        &verificationResult,
        (KeyM_DiagProc.ws.trustModelReplaceCerts.rollbackState == SSA_KEYM_ROLLBACK_ONGOING) ? KeyM_DiagProc.ws.trustModelReplaceCerts.dataLengthBackup : DataLength,
        &errorCode);
    }

    /* #40 Set verification result and error code depending on the return value.
     *     After successful rollback stop the routine without storing the certificate data
           which are supposed to be unchanged in NVM. */
    if (retVal != RTE_E_RoutineServices_Replace_Trust_model_Certificates_DCM_E_PENDING)
    {
      *routineInfo_Out = SSA_ROUTINE_INFO_SUCCESFULLY_COMPLETED;

      /* #50 Check for positive or negative response and set either verification result or NRC. */
      if (retVal == RTE_E_OK)
      {
        /* #60 If the verification failed for any reason keep the verification result and trigger a rollback of the
         *     certificate data. */
        if ((verificationResult != SSA_VER_RES_TRUST_MODEL_REPLACE_CERTS_CERTIFICATES_VERIFIED_AND_REPLACED)
          && (KeyM_DiagProc.ws.trustModelReplaceCerts.rollbackState == SSA_KEYM_ROLLBACK_POSSIBLE))
        {
          /* keep verification result and trigger rollback */
          KeyM_DiagProc.ws.trustModelReplaceCerts.verifResultBeforeRollback = verificationResult;
          KeyM_DiagProc.ws.trustModelReplaceCerts.rollbackState = SSA_KEYM_ROLLBACK_ONGOING;

          retVal = RTE_E_RoutineServices_Replace_Trust_model_Certificates_DCM_E_PENDING;
        }
        else if (KeyM_DiagProc.ws.trustModelReplaceCerts.rollbackState == SSA_KEYM_ROLLBACK_ONGOING)
        {
          /* the rollback trust model could not be verified, this shouldn't happen */
          KeyM_DiagProc.ws.trustModelReplaceCerts.rollbackState = SSA_KEYM_NO_ROLLBACK;
          KeyM_DestroyTrustModelEcuCert();

          retVal = RTE_E_OK;
          *Verification_Result_Out = KeyM_DiagProc.ws.trustModelReplaceCerts.verifResultBeforeRollback;
        }
        else
        {
          if (verificationResult != SSA_VER_RES_TRUST_MODEL_REPLACE_CERTS_CERTIFICATES_VERIFIED_AND_REPLACED)
          {
            /*
             * The new certificate chain is invalid but a rollback was not possible:
             * Destroy the trust model to indicate that it is invalid.
             */
            KeyM_DestroyTrustModelEcuCert();
          }

          *Verification_Result_Out = verificationResult;
          (void)Rte_Call_SecLog_SuccessfulDiagServiceExecutionEvent_ReplaceTrustModelCert_SuccessfulDiagServiceExecution(verificationResult);
        }
      }
      else
      {
        /* set error code */
        *ErrorCode = errorCode;
      }
    }
    else
    {
      if (KeyM_DiagProc.state == SSA_KEYM_REPLACE_TRUST_MODEL_CERTS_STATE_STORE_INIT)
      {
        if (KeyM_DiagProc.ws.trustModelReplaceCerts.rollbackState == SSA_KEYM_ROLLBACK_ONGOING)
        {
          /* Successful rollback */
          retVal = RTE_E_OK;
          KeyM_DiagProc.state = SSA_KEYM_REPLACE_TRUST_MODEL_CERTS_STATE_IDLE;
          /* used kept verification result as returned verification result */
          *Verification_Result_Out = KeyM_DiagProc.ws.trustModelReplaceCerts.verifResultBeforeRollback;
          KeyM_DiagProc.ws.trustModelReplaceCerts.rollbackState = SSA_KEYM_NO_ROLLBACK;
        }
      }
    }
  }
  return retVal;
  /* PRQA S 6030, 6060, 6080 4 */ /* MD_MSR_STCYC, MD_SSA_STPAR, MD_MSR_STMIF */
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << End of runnable implementation >>               DO NOT CHANGE THIS COMMENT!
 *********************************************************************************************************************/
}

/**********************************************************************************************************************
 *
 * Runnable Entity Name: Ssa_KeyM_RoutineServices_Replace_Trust_model_Root_Certificate
 *
 *---------------------------------------------------------------------------------------------------------------------
 *
 * Executed if at least one of the following trigger conditions occurred:
 *   - triggered by server invocation for OperationPrototype <Start> of PortPrototype <RoutineServices_Replace_Trust_model_Root_Certificate>
 *
 **********************************************************************************************************************
 *
 * Client/Server Interfaces:
 * =========================
 *   Server Invocation:
 *   ------------------
 *   Std_ReturnType Rte_Call_CertP_Functions_Certificate_Parse(const uint8 *rawCertData, uint16 rawCertLength, CertP_ParsedCertStructureType *parsedCert)
 *     Argument rawCertData: uint8* is of type CertP_RawCertBufferType
 *     Synchronous Server Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_CertP_Functions_E_NOT_OK
 *   Std_ReturnType Rte_Call_CertP_Functions_ParseTime(const uint8 *data, uint16 dataLength, TimeM_DateTimeType *dateTime)
 *     Argument data: uint8* is of type Ssa_Data15ByteType
 *     Synchronous Server Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_CertP_Functions_E_NOT_OK
 *   Std_ReturnType Rte_Call_RC_Enhance_Access_Rights_Start(const uint8 *Enhanced_Rights_Certificate, Dcm_OpStatusType OpStatus, uint8 *routineInfo, uint8 *Verification_Result, uint16 DataLength, Dcm_NegativeResponseCodeType *ErrorCode)
 *     Argument Enhanced_Rights_Certificate: uint8* is of type Dcm_Data2002ByteType
 *     Synchronous Server Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_RoutineServices_Routine_Enhance_Access_Rights_DCM_E_FORCE_RCRRP, RTE_E_RoutineServices_Routine_Enhance_Access_Rights_DCM_E_PENDING, RTE_E_RoutineServices_Routine_Enhance_Access_Rights_E_NOT_OK
 *   Std_ReturnType Rte_Call_SecLog_FailedCertVerificationEvent_FailedCertificateVerification(CertP_PkiRoleType pkiRole, CertP_VerificationResultType validationResult)
 *     Synchronous Server Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_SecLog_FailedCertVerificationEvent_E_NOT_OK
 *   Std_ReturnType Rte_Call_SecLog_SuccessfulCertVerificationEvent_SuccessfulCertificateVerification(const uint8 *certId, CertP_PkiRoleType pkiRole)
 *     Argument certId: uint8* is of type RightsM_SerialNumberType
 *     Synchronous Server Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_SecLog_SuccessfulCertVerificationEvent_E_NOT_OK
 *   Std_ReturnType Rte_Call_SecLog_SuccessfulDiagServiceExecutionEvent_ReplaceTrustModeRootCert_SuccessfulDiagServiceExecution(uint8 additionalInfo)
 *     Synchronous Server Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_SecLog_SuccessfulDiagServiceExecutionEvent_E_NOT_OK
 *   Std_ReturnType Rte_Call_SsaCdd_Csm_SignatureVerify(uint32 jobId, Crypto_OperationModeType operationMode, Ssa_ConstDataPtr dataBuffer, uint32 dataLength, Ssa_ConstDataPtr compareBuffer, uint32 compareLength, Ssa_VerifyResultPtr resultBuffer)
 *     Synchronous Server Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_SsaCdd_CryptoInterface_E_NOT_OK
 *   Std_ReturnType Rte_Call_SsaCdd_TrustModel_ServiceCertificate(KeyM_ServiceCertificateType Service, Ssa_ConstDataPtr CertNamePtr, uint32 CertNameLength, Ssa_ConstDataPtr RequestData, uint32 RequestDataLength, Ssa_DataPtr ResponseData, uint32 ResponseDataLength)
 *     Synchronous Server Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_SsaCdd_KeyM_CertInterface_E_NOT_OK, RTE_E_SsaCdd_KeyM_CertInterface_KEYM_E_BUSY, RTE_E_SsaCdd_KeyM_CertInterface_KEYM_E_CERT_INVALID_CHAIN_OF_TRUST, RTE_E_SsaCdd_KeyM_CertInterface_KEYM_E_KEY_CERT_EMPTY, RTE_E_SsaCdd_KeyM_CertInterface_KEYM_E_KEY_CERT_SIZE_MISMATCH, RTE_E_SsaCdd_KeyM_CertInterface_KEYM_E_PARAMETER_MISMATCH
 *   Std_ReturnType Rte_Call_Ssa_KeyStorage_StorePermanently(Ssa_KeyStorageUseCaseType keyStorageUseCase, Ssa_KeyStorageTaskType keyStorageTask)
 *     Synchronous Server Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_Ssa_KeyStorage_E_NOT_OK, RTE_E_Ssa_KeyStorage_E_PENDING
 *   Std_ReturnType Rte_Call_TimeM_RealTime_Compare(const TimeM_DateTimeType *t1, TimeM_CompareOperatorType compareOp, const TimeM_DateTimeType *t2, boolean *result)
 *     Synchronous Server Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_TimeM_RealTime_E_NOT_OK
 *   Std_ReturnType Rte_Call_TimeM_RealTime_Get(TimeM_DateTimeType *realTime)
 *     Synchronous Server Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_TimeM_RealTime_E_NOT_OK
 *
 * Service Calls:
 * ==============
 *   Service Invocation:
 *   -------------------
 *   Std_ReturnType Rte_Call_KeyMCertificateElement_Ssa_TrustModelRootCert_Issuer_CertificateElementGet(uint8 *CertificateElementData, uint32 *CertificateDataLength)
 *     Argument CertificateElementData: uint8* is of type KeyM_CertificateElementType_Ssa_TrustModelRootCert_Issuer
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_KeyMCertificateElement_Ssa_TrustModelRootCert_Issuer_E_NOT_OK, RTE_E_KeyMCertificateElement_Ssa_TrustModelRootCert_Issuer_KEYM_E_KEY_CERT_EMPTY, RTE_E_KeyMCertificateElement_Ssa_TrustModelRootCert_Issuer_KEYM_E_KEY_CERT_INVALID, RTE_E_KeyMCertificateElement_Ssa_TrustModelRootCert_Issuer_KEYM_E_KEY_CERT_SIZE_MISMATCH, RTE_E_KeyMCertificateElement_Ssa_TrustModelRootCert_Issuer_KEYM_E_PARAMETER_MISMATCH
 *   Std_ReturnType Rte_Call_KeyMCertificateElement_Ssa_TrustModelRootCert_SerialNo_CertificateElementGet(uint8 *CertificateElementData, uint32 *CertificateDataLength)
 *     Argument CertificateElementData: uint8* is of type KeyM_CertificateElementType_Ssa_TrustModelRootCert_SerialNo
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_KeyMCertificateElement_Ssa_TrustModelRootCert_SerialNo_E_NOT_OK, RTE_E_KeyMCertificateElement_Ssa_TrustModelRootCert_SerialNo_KEYM_E_KEY_CERT_EMPTY, RTE_E_KeyMCertificateElement_Ssa_TrustModelRootCert_SerialNo_KEYM_E_KEY_CERT_INVALID, RTE_E_KeyMCertificateElement_Ssa_TrustModelRootCert_SerialNo_KEYM_E_KEY_CERT_SIZE_MISMATCH, RTE_E_KeyMCertificateElement_Ssa_TrustModelRootCert_SerialNo_KEYM_E_PARAMETER_MISMATCH
 *   Std_ReturnType Rte_Call_KeyMCertificateElement_Ssa_TrustModelRootCert_SubjectPublicKeyInfoKey_CertificateElementGet(uint8 *CertificateElementData, uint32 *CertificateDataLength)
 *     Argument CertificateElementData: uint8* is of type KeyM_CertificateElementType_Ssa_TrustModelRootCert_SubjectPublicKeyInfoKey
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_KeyMCertificateElement_Ssa_TrustModelRootCert_SubjectPublicKeyInfoKey_E_NOT_OK, RTE_E_KeyMCertificateElement_Ssa_TrustModelRootCert_SubjectPublicKeyInfoKey_KEYM_E_KEY_CERT_EMPTY, RTE_E_KeyMCertificateElement_Ssa_TrustModelRootCert_SubjectPublicKeyInfoKey_KEYM_E_KEY_CERT_INVALID, RTE_E_KeyMCertificateElement_Ssa_TrustModelRootCert_SubjectPublicKeyInfoKey_KEYM_E_KEY_CERT_SIZE_MISMATCH, RTE_E_KeyMCertificateElement_Ssa_TrustModelRootCert_SubjectPublicKeyInfoKey_KEYM_E_PARAMETER_MISMATCH
 *   Std_ReturnType Rte_Call_KeyMCertificateElement_Ssa_TrustModelRootCert_Version_CertificateElementGet(uint8 *CertificateElementData, uint32 *CertificateDataLength)
 *     Argument CertificateElementData: uint8* is of type KeyM_CertificateElementType_Ssa_TrustModelRootCert_Version
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_KeyMCertificateElement_Ssa_TrustModelRootCert_Version_E_NOT_OK, RTE_E_KeyMCertificateElement_Ssa_TrustModelRootCert_Version_KEYM_E_KEY_CERT_EMPTY, RTE_E_KeyMCertificateElement_Ssa_TrustModelRootCert_Version_KEYM_E_KEY_CERT_INVALID, RTE_E_KeyMCertificateElement_Ssa_TrustModelRootCert_Version_KEYM_E_KEY_CERT_SIZE_MISMATCH, RTE_E_KeyMCertificateElement_Ssa_TrustModelRootCert_Version_KEYM_E_PARAMETER_MISMATCH
 *   Std_ReturnType Rte_Call_KeyMCertificateElement_Ssa_TrustModelRootCert_ext_basicConstraints_CertificateElementGet(uint8 *CertificateElementData, uint32 *CertificateDataLength)
 *     Argument CertificateElementData: uint8* is of type KeyM_CertificateElementType_Ssa_TrustModelRootCert_ext_basicConstraints
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_KeyMCertificateElement_Ssa_TrustModelRootCert_ext_basicConstraints_E_NOT_OK, RTE_E_KeyMCertificateElement_Ssa_TrustModelRootCert_ext_basicConstraints_KEYM_E_KEY_CERT_EMPTY, RTE_E_KeyMCertificateElement_Ssa_TrustModelRootCert_ext_basicConstraints_KEYM_E_KEY_CERT_INVALID, RTE_E_KeyMCertificateElement_Ssa_TrustModelRootCert_ext_basicConstraints_KEYM_E_KEY_CERT_SIZE_MISMATCH, RTE_E_KeyMCertificateElement_Ssa_TrustModelRootCert_ext_basicConstraints_KEYM_E_PARAMETER_MISMATCH
 *   Std_ReturnType Rte_Call_KeyMCertificateElement_Ssa_TrustModelRootCert_ext_keyUsage_CertificateElementGet(uint8 *CertificateElementData, uint32 *CertificateDataLength)
 *     Argument CertificateElementData: uint8* is of type KeyM_CertificateElementType_Ssa_TrustModelRootCert_ext_keyUsage
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_KeyMCertificateElement_Ssa_TrustModelRootCert_ext_keyUsage_E_NOT_OK, RTE_E_KeyMCertificateElement_Ssa_TrustModelRootCert_ext_keyUsage_KEYM_E_KEY_CERT_EMPTY, RTE_E_KeyMCertificateElement_Ssa_TrustModelRootCert_ext_keyUsage_KEYM_E_KEY_CERT_INVALID, RTE_E_KeyMCertificateElement_Ssa_TrustModelRootCert_ext_keyUsage_KEYM_E_KEY_CERT_SIZE_MISMATCH, RTE_E_KeyMCertificateElement_Ssa_TrustModelRootCert_ext_keyUsage_KEYM_E_PARAMETER_MISMATCH
 *   Std_ReturnType Rte_Call_KeyMCertificateElement_Ssa_TrustModelRootCert_ext_subKeyId_CertificateElementGet(uint8 *CertificateElementData, uint32 *CertificateDataLength)
 *     Argument CertificateElementData: uint8* is of type KeyM_CertificateElementType_Ssa_TrustModelRootCert_ext_subKeyId
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_KeyMCertificateElement_Ssa_TrustModelRootCert_ext_subKeyId_E_NOT_OK, RTE_E_KeyMCertificateElement_Ssa_TrustModelRootCert_ext_subKeyId_KEYM_E_KEY_CERT_EMPTY, RTE_E_KeyMCertificateElement_Ssa_TrustModelRootCert_ext_subKeyId_KEYM_E_KEY_CERT_INVALID, RTE_E_KeyMCertificateElement_Ssa_TrustModelRootCert_ext_subKeyId_KEYM_E_KEY_CERT_SIZE_MISMATCH, RTE_E_KeyMCertificateElement_Ssa_TrustModelRootCert_ext_subKeyId_KEYM_E_PARAMETER_MISMATCH
 *   Std_ReturnType Rte_Call_KeyMCertificateElement_Ssa_TrustModelRootCert_subject_CertificateElementGet(uint8 *CertificateElementData, uint32 *CertificateDataLength)
 *     Argument CertificateElementData: uint8* is of type KeyM_CertificateElementType_Ssa_TrustModelRootCert_subject
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_KeyMCertificateElement_Ssa_TrustModelRootCert_subject_E_NOT_OK, RTE_E_KeyMCertificateElement_Ssa_TrustModelRootCert_subject_KEYM_E_KEY_CERT_EMPTY, RTE_E_KeyMCertificateElement_Ssa_TrustModelRootCert_subject_KEYM_E_KEY_CERT_INVALID, RTE_E_KeyMCertificateElement_Ssa_TrustModelRootCert_subject_KEYM_E_KEY_CERT_SIZE_MISMATCH, RTE_E_KeyMCertificateElement_Ssa_TrustModelRootCert_subject_KEYM_E_PARAMETER_MISMATCH
 *   Std_ReturnType Rte_Call_KeyMCertificateElement_Ssa_TrustModelRootCert_validityNotAfter_CertificateElementGet(uint8 *CertificateElementData, uint32 *CertificateDataLength)
 *     Argument CertificateElementData: uint8* is of type KeyM_CertificateElementType_Ssa_TrustModelRootCert_validityNotAfter
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_KeyMCertificateElement_Ssa_TrustModelRootCert_validityNotAfter_E_NOT_OK, RTE_E_KeyMCertificateElement_Ssa_TrustModelRootCert_validityNotAfter_KEYM_E_KEY_CERT_EMPTY, RTE_E_KeyMCertificateElement_Ssa_TrustModelRootCert_validityNotAfter_KEYM_E_KEY_CERT_INVALID, RTE_E_KeyMCertificateElement_Ssa_TrustModelRootCert_validityNotAfter_KEYM_E_KEY_CERT_SIZE_MISMATCH, RTE_E_KeyMCertificateElement_Ssa_TrustModelRootCert_validityNotAfter_KEYM_E_PARAMETER_MISMATCH
 *   Std_ReturnType Rte_Call_KeyMCertificate_Ssa_TrustModelRootCert_GetStatus(KeyM_CertificateStatusType *Status)
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_KeyMCertificate_Ssa_TrustModelRootCert_E_NOT_OK
 *   Std_ReturnType Rte_Call_Key_BackendCert_KeyElementGet(uint32 keyElementId, uint8 *keyPtr, uint32 *keyLength)
 *     Argument keyPtr: uint8* is of type Csm_KeyDataType_Ssa_BackendCert
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_CsmKeyManagement_Ssa_BackendCert_CSM_E_BUSY, RTE_E_CsmKeyManagement_Ssa_BackendCert_CSM_E_KEY_EMPTY, RTE_E_CsmKeyManagement_Ssa_BackendCert_CSM_E_KEY_NOT_AVAILABLE, RTE_E_CsmKeyManagement_Ssa_BackendCert_CSM_E_KEY_READ_FAIL, RTE_E_CsmKeyManagement_Ssa_BackendCert_CSM_E_SMALL_BUFFER, RTE_E_CsmKeyManagement_Ssa_BackendCert_E_NOT_OK
 *   Std_ReturnType Rte_Call_Key_EcuCert_KeyElementGet(uint32 keyElementId, uint8 *keyPtr, uint32 *keyLength)
 *     Argument keyPtr: uint8* is of type Csm_KeyDataType_Ssa_EcuCert
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_CsmKeyManagement_Ssa_EcuCert_CSM_E_BUSY, RTE_E_CsmKeyManagement_Ssa_EcuCert_CSM_E_KEY_EMPTY, RTE_E_CsmKeyManagement_Ssa_EcuCert_CSM_E_KEY_NOT_AVAILABLE, RTE_E_CsmKeyManagement_Ssa_EcuCert_CSM_E_KEY_READ_FAIL, RTE_E_CsmKeyManagement_Ssa_EcuCert_CSM_E_SMALL_BUFFER, RTE_E_CsmKeyManagement_Ssa_EcuCert_E_NOT_OK
 *   Std_ReturnType Rte_Call_Key_RootCert_KeyElementGet(uint32 keyElementId, uint8 *keyPtr, uint32 *keyLength)
 *     Argument keyPtr: uint8* is of type Csm_KeyDataType_Ssa_RootCert
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_CsmKeyManagement_Ssa_RootCert_CSM_E_BUSY, RTE_E_CsmKeyManagement_Ssa_RootCert_CSM_E_KEY_EMPTY, RTE_E_CsmKeyManagement_Ssa_RootCert_CSM_E_KEY_NOT_AVAILABLE, RTE_E_CsmKeyManagement_Ssa_RootCert_CSM_E_KEY_READ_FAIL, RTE_E_CsmKeyManagement_Ssa_RootCert_CSM_E_SMALL_BUFFER, RTE_E_CsmKeyManagement_Ssa_RootCert_E_NOT_OK
 *   Std_ReturnType Rte_Call_Key_SignatureRamKey_KeyElementSet(uint32 keyElementId, const uint8 *keyPtr, uint32 keyLength)
 *     Argument keyPtr: uint8* is of type Csm_KeyDataType_Ssa_SignatureRamKey
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_CsmKeyManagement_Ssa_SignatureRamKey_CSM_E_BUSY, RTE_E_CsmKeyManagement_Ssa_SignatureRamKey_CSM_E_KEY_NOT_AVAILABLE, RTE_E_CsmKeyManagement_Ssa_SignatureRamKey_CSM_E_KEY_SIZE_MISMATCH, RTE_E_CsmKeyManagement_Ssa_SignatureRamKey_CSM_E_KEY_WRITE_FAIL, RTE_E_CsmKeyManagement_Ssa_SignatureRamKey_CSM_E_SMALL_BUFFER, RTE_E_CsmKeyManagement_Ssa_SignatureRamKey_E_NOT_OK
 *   Std_ReturnType Rte_Call_Key_SignatureRamKey_KeySetValid(void)
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_CsmKeyManagement_Ssa_SignatureRamKey_CSM_E_BUSY, RTE_E_CsmKeyManagement_Ssa_SignatureRamKey_E_NOT_OK
 *   Std_ReturnType Rte_Call_NvMService_KeyM_TrustModelChainOfTrustState_GetErrorStatus(NvM_RequestResultType *ErrorStatus)
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_NvMService_AC2_SRBS_E_NOT_OK
 *   Std_ReturnType Rte_Call_NvMService_KeyM_TrustModelChainOfTrustState_WriteBlock(dtRef_const_VOID SrcPtr)
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_NvMService_AC2_SRBS_E_NOT_OK
 *
 **********************************************************************************************************************
 *
 * Runnable prototype:
 * ===================
 *   Std_ReturnType Ssa_KeyM_RoutineServices_Replace_Trust_model_Root_Certificate(const uint8 *signature_new_Root_In, const uint8 *signature_In, const uint8 *Certificates_In, Dcm_OpStatusType OpStatus, uint8 *routineInfo_Out, uint8 *Verification_Result_Out, uint16 DataLength, Dcm_NegativeResponseCodeType *ErrorCode)
 *     Argument signature_new_Root_In: uint8* is of type Dcm_Data64ByteType
 *     Argument signature_In: uint8* is of type Dcm_Data64ByteType
 *     Argument Certificates_In: uint8* is of type Dcm_Data2004ByteType
 *
 **********************************************************************************************************************
 *
 * Available Application Errors:
 * =============================
 *   RTE_E_RoutineServices_Replace_Trust_model_Root_Certificate_DCM_E_FORCE_RCRRP
 *   RTE_E_RoutineServices_Replace_Trust_model_Root_Certificate_DCM_E_PENDING
 *   RTE_E_RoutineServices_Replace_Trust_model_Root_Certificate_E_NOT_OK
 *
 *********************************************************************************************************************/
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << Start of documentation area >>                  DO NOT CHANGE THIS COMMENT!
 * Symbol: Ssa_KeyM_RoutineServices_Replace_Trust_model_Root_Certificate_doc
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
/*!
 * \spec
 *    requires $lengthOf(Certificates_In) >= sizeof(Dcm_Data2004ByteType);
 *    requires DataLength <= sizeof(Dcm_Data2004ByteType);
 * \endspec
 */
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << End of documentation area >>                    DO NOT CHANGE THIS COMMENT!
 *********************************************************************************************************************/

FUNC(Std_ReturnType, Ssa_KeyM_CODE) Ssa_KeyM_RoutineServices_Replace_Trust_model_Root_Certificate(
  P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) signature_new_Root_In,
  P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) signature_In,
  P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) Certificates_In,
  Dcm_OpStatusType OpStatus,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) routineInfo_Out,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) Verification_Result_Out,
  uint16 DataLength,
  P2VAR(Dcm_NegativeResponseCodeType, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) ErrorCode) /* PRQA S 0624, 3206 */ /* MD_Rte_0624, MD_Rte_3206 */
{
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << Start of runnable implementation >>             DO NOT CHANGE THIS COMMENT!
 * Symbol: Ssa_KeyM_RoutineServices_Replace_Trust_model_Root_Certificate (returns application error)
 *********************************************************************************************************************/
  Std_ReturnType retVal = RTE_E_RoutineServices_Replace_Trust_model_Root_Certificate_E_NOT_OK;

  /* ----- Development Error Checks ------------------------------------- */
#if (SSA_DEV_ERROR_DETECT == STD_ON)
  if ((signature_new_Root_In == NULL_PTR)
    || (signature_In == NULL_PTR)
    || (Certificates_In == NULL_PTR)
    || (routineInfo_Out == NULL_PTR)
    || (Verification_Result_Out == NULL_PTR)
    || (ErrorCode == NULL_PTR))
  {
    /* retVal already set */
  }
  else
#endif /* SSA_DEV_ERROR_DETECT == STD_ON */
  {
    Dcm_NegativeResponseCodeType errorCode = DCM_E_POSITIVERESPONSE;
    uint8 verificationResult = SSA_VER_RES_TRUST_MODEL_REPLACE_ROOT_CERT_CERTIFICATE_VERIFICATION_FAILED_INVALID_CHAIN_OF_TRUST;

    /* #10 Replace the passed Trust Model Root certificates using AsrKeyM.
     *     Go to idle state if service is canceled by DCM.
     *     Proceed only if state is valid. */

    if (OpStatus == DCM_CANCEL)
    {
      /* back to idle state */
      KeyM_DiagProc.state = SSA_KEYM_REPLACE_TRUST_MODEL_CERTS_STATE_IDLE;
      retVal = RTE_E_OK;
      /* use default verification result */
    }
    else if (!KeyM_IsReplaceTrustModelRootCertStateValid())
    {
      /* back to idle state */
      KeyM_DiagProc.state = SSA_KEYM_REPLACE_TRUST_MODEL_CERTS_STATE_IDLE;
      errorCode = DCM_E_GENERALREJECT;
    }
    else
    {
      if (OpStatus == DCM_INITIAL)
      {
        /* Initialize flags, indices and length values for this routine. */
        KeyM_DiagProc.ws.trustModelReplaceRootCert.certLength_enh= 0u;
        KeyM_DiagProc.ws.trustModelReplaceRootCert.certLength_newroot= 0u;
        KeyM_DiagProc.ws.trustModelReplaceRootCert.certIdx_enh= 0u;
        KeyM_DiagProc.ws.trustModelReplaceRootCert.certIdx_newroot= 0u;

        KeyM_DiagProc.ws.trustModelReplaceRootCert.isRollback = FALSE;
        /* Initialize verification result with any result != 0. */
        KeyM_DiagProc.ws.trustModelReplaceRootCert.verifResultBeforeRollback = SSA_VER_RES_TRUST_MODEL_REPLACE_ROOT_CERT_CERTIFICATE_VERIFICATION_FAILED_INVALID_TIME_PERIOD;

        KeyM_DiagProc.ws.trustModelReplaceRootCert.csmSignatureVerifyCallbackResult = E_NOT_OK;
        KeyM_DiagProc.ws.trustModelReplaceRootCert.csmSignatureVerifyCallbackOccurred = FALSE;
        KeyM_DiagProc.ws.trustModelReplaceRootCert.csmReplacementAuthorityCryptoVerifyResult = CRYPTO_E_VER_NOT_OK;
        KeyM_DiagProc.ws.trustModelReplaceRootCert.csmReplacementAuthorityCallbackResult = E_NOT_OK;
        KeyM_DiagProc.ws.trustModelReplaceRootCert.csmReplacementAuthorityCallbackOccurred = FALSE;
      }

      /* #20 Handle the following states:
       *     SSA_KEYM_REPLACE_TRUST_MODEL_ROOT_CERT_STATE_IDLE,
       *     SSA_KEYM_REPLACE_TRUST_MODEL_ROOT_CERT_STATE_VERIFYING_REPLACEMENT_PACKAGE_SUBKEYID,
       *     SSA_KEYM_REPLACE_TRUST_MODEL_ROOT_CERT_STATE_STARTING_VERIFICATION_SIGNATURE_NEW_ROOT,
       *     SSA_KEYM_REPLACE_TRUST_MODEL_ROOT_CERT_STATE_AWAITING_VERIF_RESULT_SIGNATURE_NEW_ROOT,
       *     SSA_KEYM_REPLACE_TRUST_MODEL_ROOT_CERT_STATE_AWAITING_VERIF_RESULT_NEW_ROOT_CERT,
       *     SSA_KEYM_REPLACE_TRUST_MODEL_ROOT_CERT_STATE_ROLLING_BACK_CERTIFICATE_DATA,
       *     SSA_KEYM_REPLACE_TRUST_MODEL_ROOT_CERT_STATE_STORE_INIT,
       *     SSA_KEYM_REPLACE_TRUST_MODEL_ROOT_CERT_STATE_STORE_PENDING,
       *     SSA_KEYM_REPLACE_TRUST_MODEL_ROOT_CERT_STATE_NVM_WRITE,
       *     SSA_KEYM_REPLACE_TRUST_MODEL_ROOT_CERT_STATE_NVM_WAIT.
       */
      /*@ assert $lengthOf(Certificates_In) >= sizeof(Dcm_Data2004ByteType); */ /* VCA_SSA_KEYM_LENGTH_SPECIFIED_IN_FCT_CALL */
      /*@ assert DataLength <= sizeof(Dcm_Data2004ByteType); */
      /* The following justification justifies the calls to 
       * - KeyM_ReplaceTrustModelRootCert_HandleStateIdleAndVerifyingEnhanceCert, and
       * - KeyM_ReplaceTrustModelRootCert_HandleStateVerifyingSignatureNewRoot. 
       * Justifiying the calls to functions which handle the other states is not necessary, but cannot be avoided. */

      retVal = KeyM_Replace_Trust_model_Root_Certificate_State_Handler[KeyM_DiagProc.state]( /* VCA_SSA_KEYM_LENGTH_SPECIFIED_IN_FCT_CALL */
        signature_new_Root_In,
        signature_In,
        Certificates_In,
        OpStatus,
        routineInfo_Out,
        &verificationResult,
        DataLength,
        &errorCode);
    }

    /* #30 Set verification result and error code depending on the return value. */
    if (retVal != RTE_E_RoutineServices_Replace_Trust_model_Root_Certificate_DCM_E_PENDING)
    {
      *routineInfo_Out = SSA_ROUTINE_INFO_SUCCESFULLY_COMPLETED;
      /* check for positive or negative response and set either verification result or NRC */
      if (retVal == RTE_E_OK)
      {
        *Verification_Result_Out = verificationResult;
        (void)Rte_Call_SecLog_SuccessfulDiagServiceExecutionEvent_ReplaceTrustModeRootCert_SuccessfulDiagServiceExecution(verificationResult);
      }
      else
      {
        *ErrorCode = errorCode;
      }
    }
  }

  return retVal;
  /* PRQA S 6060 4 */ /* MD_SSA_STPAR */
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << End of runnable implementation >>               DO NOT CHANGE THIS COMMENT!
 *********************************************************************************************************************/
}

/**********************************************************************************************************************
 *
 * Runnable Entity Name: Ssa_KeyM_RoutineServices_Routine_Certificate_Self_Check
 *
 *---------------------------------------------------------------------------------------------------------------------
 *
 * Executed if at least one of the following trigger conditions occurred:
 *   - triggered by server invocation for OperationPrototype <Start> of PortPrototype <RoutineServices_Routine_Certificate_Self_Check>
 *
 **********************************************************************************************************************
 *
 * Client/Server Interfaces:
 * =========================
 *   Server Invocation:
 *   ------------------
 *   Std_ReturnType Rte_Call_CertP_Functions_Certificate_Parse(const uint8 *rawCertData, uint16 rawCertLength, CertP_ParsedCertStructureType *parsedCert)
 *     Argument rawCertData: uint8* is of type CertP_RawCertBufferType
 *     Synchronous Server Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_CertP_Functions_E_NOT_OK
 *   Std_ReturnType Rte_Call_CertP_Functions_Certificate_Verify(const uint8 *rawCertData, CertP_ParsedCertStructureType *parsedCert, const uint8 *rawCertIssuer, const CertP_ParsedCertStructureType *parsedCertIssuer, CertP_PkiRoleType expectedPkiRole)
 *     Argument rawCertData: uint8* is of type CertP_RawCertBufferType
 *     Argument rawCertIssuer: uint8* is of type CertP_RawCertBufferType
 *     Synchronous Server Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_CertP_Functions_E_NOT_OK, RTE_E_CertP_Functions_E_PENDING
 *   Std_ReturnType Rte_Call_CertP_Functions_ParseTime(const uint8 *data, uint16 dataLength, TimeM_DateTimeType *dateTime)
 *     Argument data: uint8* is of type Ssa_Data15ByteType
 *     Synchronous Server Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_CertP_Functions_E_NOT_OK
 *   Std_ReturnType Rte_Call_SecLog_FailedCertVerificationEvent_FailedCertificateVerification(CertP_PkiRoleType pkiRole, CertP_VerificationResultType validationResult)
 *     Synchronous Server Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_SecLog_FailedCertVerificationEvent_E_NOT_OK
 *   Std_ReturnType Rte_Call_SecLog_SuccessfulCertVerificationEvent_SuccessfulCertificateVerification(const uint8 *certId, CertP_PkiRoleType pkiRole)
 *     Argument certId: uint8* is of type RightsM_SerialNumberType
 *     Synchronous Server Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_SecLog_SuccessfulCertVerificationEvent_E_NOT_OK
 *   Std_ReturnType Rte_Call_SsaCdd_Csm_SignatureGenerate(uint32 jobId, Crypto_OperationModeType operationMode, Ssa_ConstDataPtr dataBuffer, uint32 dataLength, Ssa_DataPtr resultBuffer, Ssa_LengthPtr resultLength)
 *     Synchronous Server Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_SsaCdd_CryptoInterface_E_NOT_OK
 *   Std_ReturnType Rte_Call_SsaCdd_Csm_SignatureVerify(uint32 jobId, Crypto_OperationModeType operationMode, Ssa_ConstDataPtr dataBuffer, uint32 dataLength, Ssa_ConstDataPtr compareBuffer, uint32 compareLength, Ssa_VerifyResultPtr resultBuffer)
 *     Synchronous Server Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_SsaCdd_CryptoInterface_E_NOT_OK
 *   Std_ReturnType Rte_Call_SsaCdd_TrustModel_CsrElementSet(KeyM_CertificateIdType CertId, KeyM_CertElementIdType CertElementId, KeyM_CsrEncodingType EncodingType, Ssa_ConstDataPtr ElementData, uint32 ElementDataLength)
 *     Synchronous Server Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_SsaCdd_KeyM_CertInterface_E_NOT_OK, RTE_E_SsaCdd_KeyM_CertInterface_KEYM_E_KEY_CERT_SIZE_MISMATCH, RTE_E_SsaCdd_KeyM_CertInterface_KEYM_E_PARAMETER_MISMATCH
 *   Std_ReturnType Rte_Call_SsaCdd_TrustModel_GetCertificate(KeyM_CertificateIdType CertId, Ssa_DataPtr CertData, Ssa_LengthPtr CertDataLength)
 *     Synchronous Server Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_SsaCdd_KeyM_CertInterface_E_NOT_OK, RTE_E_SsaCdd_KeyM_CertInterface_KEYM_E_KEY_CERT_EMPTY, RTE_E_SsaCdd_KeyM_CertInterface_KEYM_E_KEY_CERT_READ_FAIL, RTE_E_SsaCdd_KeyM_CertInterface_KEYM_E_KEY_CERT_SIZE_MISMATCH, RTE_E_SsaCdd_KeyM_CertInterface_KEYM_E_PARAMETER_MISMATCH
 *   Std_ReturnType Rte_Call_SsaCdd_TrustModel_SetCertificate(KeyM_CertificateIdType CertId, Ssa_DataPtr CertData, uint32 CertDataLength)
 *     Synchronous Server Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_SsaCdd_KeyM_CertInterface_E_NOT_OK, RTE_E_SsaCdd_KeyM_CertInterface_KEYM_E_KEY_CERT_SIZE_MISMATCH, RTE_E_SsaCdd_KeyM_CertInterface_KEYM_E_PARAMETER_MISMATCH
 *   Std_ReturnType Rte_Call_TimeM_RealTime_Compare(const TimeM_DateTimeType *t1, TimeM_CompareOperatorType compareOp, const TimeM_DateTimeType *t2, boolean *result)
 *     Synchronous Server Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_TimeM_RealTime_E_NOT_OK
 *   Std_ReturnType Rte_Call_TimeM_RealTime_Get(TimeM_DateTimeType *realTime)
 *     Synchronous Server Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_TimeM_RealTime_E_NOT_OK
 *
 * Service Calls:
 * ==============
 *   Service Invocation:
 *   -------------------
 *   Std_ReturnType Rte_Call_KeyMCertificateElement_Ssa_TrustModelBackendCert_Issuer_CertificateElementGet(uint8 *CertificateElementData, uint32 *CertificateDataLength)
 *     Argument CertificateElementData: uint8* is of type KeyM_CertificateElementType_Ssa_TrustModelBackendCert_Issuer
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_KeyMCertificateElement_Ssa_TrustModelBackendCert_Issuer_E_NOT_OK, RTE_E_KeyMCertificateElement_Ssa_TrustModelBackendCert_Issuer_KEYM_E_KEY_CERT_EMPTY, RTE_E_KeyMCertificateElement_Ssa_TrustModelBackendCert_Issuer_KEYM_E_KEY_CERT_INVALID, RTE_E_KeyMCertificateElement_Ssa_TrustModelBackendCert_Issuer_KEYM_E_KEY_CERT_SIZE_MISMATCH, RTE_E_KeyMCertificateElement_Ssa_TrustModelBackendCert_Issuer_KEYM_E_PARAMETER_MISMATCH
 *   Std_ReturnType Rte_Call_KeyMCertificateElement_Ssa_TrustModelBackendCert_SerialNo_CertificateElementGet(uint8 *CertificateElementData, uint32 *CertificateDataLength)
 *     Argument CertificateElementData: uint8* is of type KeyM_CertificateElementType_Ssa_TrustModelBackendCert_SerialNo
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_KeyMCertificateElement_Ssa_TrustModelBackendCert_SerialNo_E_NOT_OK, RTE_E_KeyMCertificateElement_Ssa_TrustModelBackendCert_SerialNo_KEYM_E_KEY_CERT_EMPTY, RTE_E_KeyMCertificateElement_Ssa_TrustModelBackendCert_SerialNo_KEYM_E_KEY_CERT_INVALID, RTE_E_KeyMCertificateElement_Ssa_TrustModelBackendCert_SerialNo_KEYM_E_KEY_CERT_SIZE_MISMATCH, RTE_E_KeyMCertificateElement_Ssa_TrustModelBackendCert_SerialNo_KEYM_E_PARAMETER_MISMATCH
 *   Std_ReturnType Rte_Call_KeyMCertificateElement_Ssa_TrustModelBackendCert_SubjectPublicKeyInfoKey_CertificateElementGet(uint8 *CertificateElementData, uint32 *CertificateDataLength)
 *     Argument CertificateElementData: uint8* is of type KeyM_CertificateElementType_Ssa_TrustModelBackendCert_SubjectPublicKeyInfoKey
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_KeyMCertificateElement_Ssa_TrustModelBackendCert_SubjectPublicKeyInfoKey_E_NOT_OK, RTE_E_KeyMCertificateElement_Ssa_TrustModelBackendCert_SubjectPublicKeyInfoKey_KEYM_E_KEY_CERT_EMPTY, RTE_E_KeyMCertificateElement_Ssa_TrustModelBackendCert_SubjectPublicKeyInfoKey_KEYM_E_KEY_CERT_INVALID, RTE_E_KeyMCertificateElement_Ssa_TrustModelBackendCert_SubjectPublicKeyInfoKey_KEYM_E_KEY_CERT_SIZE_MISMATCH, RTE_E_KeyMCertificateElement_Ssa_TrustModelBackendCert_SubjectPublicKeyInfoKey_KEYM_E_PARAMETER_MISMATCH
 *   Std_ReturnType Rte_Call_KeyMCertificateElement_Ssa_TrustModelBackendCert_Version_CertificateElementGet(uint8 *CertificateElementData, uint32 *CertificateDataLength)
 *     Argument CertificateElementData: uint8* is of type KeyM_CertificateElementType_Ssa_TrustModelBackendCert_Version
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_KeyMCertificateElement_Ssa_TrustModelBackendCert_Version_E_NOT_OK, RTE_E_KeyMCertificateElement_Ssa_TrustModelBackendCert_Version_KEYM_E_KEY_CERT_EMPTY, RTE_E_KeyMCertificateElement_Ssa_TrustModelBackendCert_Version_KEYM_E_KEY_CERT_INVALID, RTE_E_KeyMCertificateElement_Ssa_TrustModelBackendCert_Version_KEYM_E_KEY_CERT_SIZE_MISMATCH, RTE_E_KeyMCertificateElement_Ssa_TrustModelBackendCert_Version_KEYM_E_PARAMETER_MISMATCH
 *   Std_ReturnType Rte_Call_KeyMCertificateElement_Ssa_TrustModelBackendCert_ext_authKeyId_CertificateElementGet(uint8 *CertificateElementData, uint32 *CertificateDataLength)
 *     Argument CertificateElementData: uint8* is of type KeyM_CertificateElementType_Ssa_TrustModelBackendCert_ext_authKeyId
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_KeyMCertificateElement_Ssa_TrustModelBackendCert_ext_authKeyId_E_NOT_OK, RTE_E_KeyMCertificateElement_Ssa_TrustModelBackendCert_ext_authKeyId_KEYM_E_KEY_CERT_EMPTY, RTE_E_KeyMCertificateElement_Ssa_TrustModelBackendCert_ext_authKeyId_KEYM_E_KEY_CERT_INVALID, RTE_E_KeyMCertificateElement_Ssa_TrustModelBackendCert_ext_authKeyId_KEYM_E_KEY_CERT_SIZE_MISMATCH, RTE_E_KeyMCertificateElement_Ssa_TrustModelBackendCert_ext_authKeyId_KEYM_E_PARAMETER_MISMATCH
 *   Std_ReturnType Rte_Call_KeyMCertificateElement_Ssa_TrustModelBackendCert_ext_basicConstraints_CertificateElementGet(uint8 *CertificateElementData, uint32 *CertificateDataLength)
 *     Argument CertificateElementData: uint8* is of type KeyM_CertificateElementType_Ssa_TrustModelBackendCert_ext_basicConstraints
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_KeyMCertificateElement_Ssa_TrustModelBackendCert_ext_basicConstraints_E_NOT_OK, RTE_E_KeyMCertificateElement_Ssa_TrustModelBackendCert_ext_basicConstraints_KEYM_E_KEY_CERT_EMPTY, RTE_E_KeyMCertificateElement_Ssa_TrustModelBackendCert_ext_basicConstraints_KEYM_E_KEY_CERT_INVALID, RTE_E_KeyMCertificateElement_Ssa_TrustModelBackendCert_ext_basicConstraints_KEYM_E_KEY_CERT_SIZE_MISMATCH, RTE_E_KeyMCertificateElement_Ssa_TrustModelBackendCert_ext_basicConstraints_KEYM_E_PARAMETER_MISMATCH
 *   Std_ReturnType Rte_Call_KeyMCertificateElement_Ssa_TrustModelBackendCert_ext_subKeyId_CertificateElementGet(uint8 *CertificateElementData, uint32 *CertificateDataLength)
 *     Argument CertificateElementData: uint8* is of type KeyM_CertificateElementType_Ssa_TrustModelBackendCert_ext_subKeyId
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_KeyMCertificateElement_Ssa_TrustModelBackendCert_ext_subKeyId_E_NOT_OK, RTE_E_KeyMCertificateElement_Ssa_TrustModelBackendCert_ext_subKeyId_KEYM_E_KEY_CERT_EMPTY, RTE_E_KeyMCertificateElement_Ssa_TrustModelBackendCert_ext_subKeyId_KEYM_E_KEY_CERT_INVALID, RTE_E_KeyMCertificateElement_Ssa_TrustModelBackendCert_ext_subKeyId_KEYM_E_KEY_CERT_SIZE_MISMATCH, RTE_E_KeyMCertificateElement_Ssa_TrustModelBackendCert_ext_subKeyId_KEYM_E_PARAMETER_MISMATCH
 *   Std_ReturnType Rte_Call_KeyMCertificateElement_Ssa_TrustModelBackendCert_subject_CertificateElementGet(uint8 *CertificateElementData, uint32 *CertificateDataLength)
 *     Argument CertificateElementData: uint8* is of type KeyM_CertificateElementType_Ssa_TrustModelBackendCert_subject
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_KeyMCertificateElement_Ssa_TrustModelBackendCert_subject_E_NOT_OK, RTE_E_KeyMCertificateElement_Ssa_TrustModelBackendCert_subject_KEYM_E_KEY_CERT_EMPTY, RTE_E_KeyMCertificateElement_Ssa_TrustModelBackendCert_subject_KEYM_E_KEY_CERT_INVALID, RTE_E_KeyMCertificateElement_Ssa_TrustModelBackendCert_subject_KEYM_E_KEY_CERT_SIZE_MISMATCH, RTE_E_KeyMCertificateElement_Ssa_TrustModelBackendCert_subject_KEYM_E_PARAMETER_MISMATCH
 *   Std_ReturnType Rte_Call_KeyMCertificateElement_Ssa_TrustModelBackendCert_validityNotAfter_CertificateElementGet(uint8 *CertificateElementData, uint32 *CertificateDataLength)
 *     Argument CertificateElementData: uint8* is of type KeyM_CertificateElementType_Ssa_TrustModelBackendCert_validityNotAfter
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_KeyMCertificateElement_Ssa_TrustModelBackendCert_validityNotAfter_E_NOT_OK, RTE_E_KeyMCertificateElement_Ssa_TrustModelBackendCert_validityNotAfter_KEYM_E_KEY_CERT_EMPTY, RTE_E_KeyMCertificateElement_Ssa_TrustModelBackendCert_validityNotAfter_KEYM_E_KEY_CERT_INVALID, RTE_E_KeyMCertificateElement_Ssa_TrustModelBackendCert_validityNotAfter_KEYM_E_KEY_CERT_SIZE_MISMATCH, RTE_E_KeyMCertificateElement_Ssa_TrustModelBackendCert_validityNotAfter_KEYM_E_PARAMETER_MISMATCH
 *   Std_ReturnType Rte_Call_KeyMCertificateElement_Ssa_TrustModelEcuCert_Issuer_CertificateElementGet(uint8 *CertificateElementData, uint32 *CertificateDataLength)
 *     Argument CertificateElementData: uint8* is of type KeyM_CertificateElementType_Ssa_TrustModelEcuCert_Issuer
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_KeyMCertificateElement_Ssa_TrustModelEcuCert_Issuer_E_NOT_OK, RTE_E_KeyMCertificateElement_Ssa_TrustModelEcuCert_Issuer_KEYM_E_KEY_CERT_EMPTY, RTE_E_KeyMCertificateElement_Ssa_TrustModelEcuCert_Issuer_KEYM_E_KEY_CERT_INVALID, RTE_E_KeyMCertificateElement_Ssa_TrustModelEcuCert_Issuer_KEYM_E_KEY_CERT_SIZE_MISMATCH, RTE_E_KeyMCertificateElement_Ssa_TrustModelEcuCert_Issuer_KEYM_E_PARAMETER_MISMATCH
 *   Std_ReturnType Rte_Call_KeyMCertificateElement_Ssa_TrustModelEcuCert_SerialNo_CertificateElementGet(uint8 *CertificateElementData, uint32 *CertificateDataLength)
 *     Argument CertificateElementData: uint8* is of type KeyM_CertificateElementType_Ssa_TrustModelEcuCert_SerialNo
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_KeyMCertificateElement_Ssa_TrustModelEcuCert_SerialNo_E_NOT_OK, RTE_E_KeyMCertificateElement_Ssa_TrustModelEcuCert_SerialNo_KEYM_E_KEY_CERT_EMPTY, RTE_E_KeyMCertificateElement_Ssa_TrustModelEcuCert_SerialNo_KEYM_E_KEY_CERT_INVALID, RTE_E_KeyMCertificateElement_Ssa_TrustModelEcuCert_SerialNo_KEYM_E_KEY_CERT_SIZE_MISMATCH, RTE_E_KeyMCertificateElement_Ssa_TrustModelEcuCert_SerialNo_KEYM_E_PARAMETER_MISMATCH
 *   Std_ReturnType Rte_Call_KeyMCertificateElement_Ssa_TrustModelEcuCert_SubjectPublicKeyInfoKey_CertificateElementGet(uint8 *CertificateElementData, uint32 *CertificateDataLength)
 *     Argument CertificateElementData: uint8* is of type KeyM_CertificateElementType_Ssa_TrustModelEcuCert_SubjectPublicKeyInfoKey
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_KeyMCertificateElement_Ssa_TrustModelEcuCert_SubjectPublicKeyInfoKey_E_NOT_OK, RTE_E_KeyMCertificateElement_Ssa_TrustModelEcuCert_SubjectPublicKeyInfoKey_KEYM_E_KEY_CERT_EMPTY, RTE_E_KeyMCertificateElement_Ssa_TrustModelEcuCert_SubjectPublicKeyInfoKey_KEYM_E_KEY_CERT_INVALID, RTE_E_KeyMCertificateElement_Ssa_TrustModelEcuCert_SubjectPublicKeyInfoKey_KEYM_E_KEY_CERT_SIZE_MISMATCH, RTE_E_KeyMCertificateElement_Ssa_TrustModelEcuCert_SubjectPublicKeyInfoKey_KEYM_E_PARAMETER_MISMATCH
 *   Std_ReturnType Rte_Call_KeyMCertificateElement_Ssa_TrustModelEcuCert_Version_CertificateElementGet(uint8 *CertificateElementData, uint32 *CertificateDataLength)
 *     Argument CertificateElementData: uint8* is of type KeyM_CertificateElementType_Ssa_TrustModelEcuCert_Version
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_KeyMCertificateElement_Ssa_TrustModelEcuCert_Version_E_NOT_OK, RTE_E_KeyMCertificateElement_Ssa_TrustModelEcuCert_Version_KEYM_E_KEY_CERT_EMPTY, RTE_E_KeyMCertificateElement_Ssa_TrustModelEcuCert_Version_KEYM_E_KEY_CERT_INVALID, RTE_E_KeyMCertificateElement_Ssa_TrustModelEcuCert_Version_KEYM_E_KEY_CERT_SIZE_MISMATCH, RTE_E_KeyMCertificateElement_Ssa_TrustModelEcuCert_Version_KEYM_E_PARAMETER_MISMATCH
 *   Std_ReturnType Rte_Call_KeyMCertificateElement_Ssa_TrustModelEcuCert_ext_authKeyId_CertificateElementGet(uint8 *CertificateElementData, uint32 *CertificateDataLength)
 *     Argument CertificateElementData: uint8* is of type KeyM_CertificateElementType_Ssa_TrustModelEcuCert_ext_authKeyId
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_KeyMCertificateElement_Ssa_TrustModelEcuCert_ext_authKeyId_E_NOT_OK, RTE_E_KeyMCertificateElement_Ssa_TrustModelEcuCert_ext_authKeyId_KEYM_E_KEY_CERT_EMPTY, RTE_E_KeyMCertificateElement_Ssa_TrustModelEcuCert_ext_authKeyId_KEYM_E_KEY_CERT_INVALID, RTE_E_KeyMCertificateElement_Ssa_TrustModelEcuCert_ext_authKeyId_KEYM_E_KEY_CERT_SIZE_MISMATCH, RTE_E_KeyMCertificateElement_Ssa_TrustModelEcuCert_ext_authKeyId_KEYM_E_PARAMETER_MISMATCH
 *   Std_ReturnType Rte_Call_KeyMCertificateElement_Ssa_TrustModelEcuCert_ext_specialEcu_CertificateElementGet(uint8 *CertificateElementData, uint32 *CertificateDataLength)
 *     Argument CertificateElementData: uint8* is of type KeyM_CertificateElementType_Ssa_TrustModelEcuCert_ext_specialEcu
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_KeyMCertificateElement_Ssa_TrustModelEcuCert_ext_specialEcu_E_NOT_OK, RTE_E_KeyMCertificateElement_Ssa_TrustModelEcuCert_ext_specialEcu_KEYM_E_KEY_CERT_EMPTY, RTE_E_KeyMCertificateElement_Ssa_TrustModelEcuCert_ext_specialEcu_KEYM_E_KEY_CERT_INVALID, RTE_E_KeyMCertificateElement_Ssa_TrustModelEcuCert_ext_specialEcu_KEYM_E_KEY_CERT_SIZE_MISMATCH, RTE_E_KeyMCertificateElement_Ssa_TrustModelEcuCert_ext_specialEcu_KEYM_E_PARAMETER_MISMATCH
 *   Std_ReturnType Rte_Call_KeyMCertificateElement_Ssa_TrustModelEcuCert_ext_subKeyId_CertificateElementGet(uint8 *CertificateElementData, uint32 *CertificateDataLength)
 *     Argument CertificateElementData: uint8* is of type KeyM_CertificateElementType_Ssa_TrustModelEcuCert_ext_subKeyId
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_KeyMCertificateElement_Ssa_TrustModelEcuCert_ext_subKeyId_E_NOT_OK, RTE_E_KeyMCertificateElement_Ssa_TrustModelEcuCert_ext_subKeyId_KEYM_E_KEY_CERT_EMPTY, RTE_E_KeyMCertificateElement_Ssa_TrustModelEcuCert_ext_subKeyId_KEYM_E_KEY_CERT_INVALID, RTE_E_KeyMCertificateElement_Ssa_TrustModelEcuCert_ext_subKeyId_KEYM_E_KEY_CERT_SIZE_MISMATCH, RTE_E_KeyMCertificateElement_Ssa_TrustModelEcuCert_ext_subKeyId_KEYM_E_PARAMETER_MISMATCH
 *   Std_ReturnType Rte_Call_KeyMCertificateElement_Ssa_TrustModelEcuCert_ext_uniqueECUID_CertificateElementGet(uint8 *CertificateElementData, uint32 *CertificateDataLength)
 *     Argument CertificateElementData: uint8* is of type KeyM_CertificateElementType_Ssa_TrustModelEcuCert_ext_uniqueECUID
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_KeyMCertificateElement_Ssa_TrustModelEcuCert_ext_uniqueECUID_E_NOT_OK, RTE_E_KeyMCertificateElement_Ssa_TrustModelEcuCert_ext_uniqueECUID_KEYM_E_KEY_CERT_EMPTY, RTE_E_KeyMCertificateElement_Ssa_TrustModelEcuCert_ext_uniqueECUID_KEYM_E_KEY_CERT_INVALID, RTE_E_KeyMCertificateElement_Ssa_TrustModelEcuCert_ext_uniqueECUID_KEYM_E_KEY_CERT_SIZE_MISMATCH, RTE_E_KeyMCertificateElement_Ssa_TrustModelEcuCert_ext_uniqueECUID_KEYM_E_PARAMETER_MISMATCH
 *   Std_ReturnType Rte_Call_KeyMCertificateElement_Ssa_TrustModelEcuCert_subject_CertificateElementGet(uint8 *CertificateElementData, uint32 *CertificateDataLength)
 *     Argument CertificateElementData: uint8* is of type KeyM_CertificateElementType_Ssa_TrustModelEcuCert_subject
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_KeyMCertificateElement_Ssa_TrustModelEcuCert_subject_E_NOT_OK, RTE_E_KeyMCertificateElement_Ssa_TrustModelEcuCert_subject_KEYM_E_KEY_CERT_EMPTY, RTE_E_KeyMCertificateElement_Ssa_TrustModelEcuCert_subject_KEYM_E_KEY_CERT_INVALID, RTE_E_KeyMCertificateElement_Ssa_TrustModelEcuCert_subject_KEYM_E_KEY_CERT_SIZE_MISMATCH, RTE_E_KeyMCertificateElement_Ssa_TrustModelEcuCert_subject_KEYM_E_PARAMETER_MISMATCH
 *   Std_ReturnType Rte_Call_KeyMCertificateElement_Ssa_TrustModelEcuCert_validityNotAfter_CertificateElementGet(uint8 *CertificateElementData, uint32 *CertificateDataLength)
 *     Argument CertificateElementData: uint8* is of type KeyM_CertificateElementType_Ssa_TrustModelEcuCert_validityNotAfter
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_KeyMCertificateElement_Ssa_TrustModelEcuCert_validityNotAfter_E_NOT_OK, RTE_E_KeyMCertificateElement_Ssa_TrustModelEcuCert_validityNotAfter_KEYM_E_KEY_CERT_EMPTY, RTE_E_KeyMCertificateElement_Ssa_TrustModelEcuCert_validityNotAfter_KEYM_E_KEY_CERT_INVALID, RTE_E_KeyMCertificateElement_Ssa_TrustModelEcuCert_validityNotAfter_KEYM_E_KEY_CERT_SIZE_MISMATCH, RTE_E_KeyMCertificateElement_Ssa_TrustModelEcuCert_validityNotAfter_KEYM_E_PARAMETER_MISMATCH
 *   Std_ReturnType Rte_Call_KeyMCertificateElement_Ssa_TrustModelIntermediateCert_Issuer_CertificateElementGet(uint8 *CertificateElementData, uint32 *CertificateDataLength)
 *     Argument CertificateElementData: uint8* is of type KeyM_CertificateElementType_Ssa_TrustModelIntermediateCert_Issuer
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_KeyMCertificateElement_Ssa_TrustModelIntermediateCert_Issuer_E_NOT_OK, RTE_E_KeyMCertificateElement_Ssa_TrustModelIntermediateCert_Issuer_KEYM_E_KEY_CERT_EMPTY, RTE_E_KeyMCertificateElement_Ssa_TrustModelIntermediateCert_Issuer_KEYM_E_KEY_CERT_INVALID, RTE_E_KeyMCertificateElement_Ssa_TrustModelIntermediateCert_Issuer_KEYM_E_KEY_CERT_SIZE_MISMATCH, RTE_E_KeyMCertificateElement_Ssa_TrustModelIntermediateCert_Issuer_KEYM_E_PARAMETER_MISMATCH
 *   Std_ReturnType Rte_Call_KeyMCertificateElement_Ssa_TrustModelIntermediateCert_SerialNo_CertificateElementGet(uint8 *CertificateElementData, uint32 *CertificateDataLength)
 *     Argument CertificateElementData: uint8* is of type KeyM_CertificateElementType_Ssa_TrustModelIntermediateCert_SerialNo
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_KeyMCertificateElement_Ssa_TrustModelIntermediateCert_SerialNo_E_NOT_OK, RTE_E_KeyMCertificateElement_Ssa_TrustModelIntermediateCert_SerialNo_KEYM_E_KEY_CERT_EMPTY, RTE_E_KeyMCertificateElement_Ssa_TrustModelIntermediateCert_SerialNo_KEYM_E_KEY_CERT_INVALID, RTE_E_KeyMCertificateElement_Ssa_TrustModelIntermediateCert_SerialNo_KEYM_E_KEY_CERT_SIZE_MISMATCH, RTE_E_KeyMCertificateElement_Ssa_TrustModelIntermediateCert_SerialNo_KEYM_E_PARAMETER_MISMATCH
 *   Std_ReturnType Rte_Call_KeyMCertificateElement_Ssa_TrustModelIntermediateCert_SubjectPublicKeyInfoKey_CertificateElementGet(uint8 *CertificateElementData, uint32 *CertificateDataLength)
 *     Argument CertificateElementData: uint8* is of type KeyM_CertificateElementType_Ssa_TrustModelIntermediateCert_SubjectPublicKeyInfoKey
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_KeyMCertificateElement_Ssa_TrustModelIntermediateCert_SubjectPublicKeyInfoKey_E_NOT_OK, RTE_E_KeyMCertificateElement_Ssa_TrustModelIntermediateCert_SubjectPublicKeyInfoKey_KEYM_E_KEY_CERT_EMPTY, RTE_E_KeyMCertificateElement_Ssa_TrustModelIntermediateCert_SubjectPublicKeyInfoKey_KEYM_E_KEY_CERT_INVALID, RTE_E_KeyMCertificateElement_Ssa_TrustModelIntermediateCert_SubjectPublicKeyInfoKey_KEYM_E_KEY_CERT_SIZE_MISMATCH, RTE_E_KeyMCertificateElement_Ssa_TrustModelIntermediateCert_SubjectPublicKeyInfoKey_KEYM_E_PARAMETER_MISMATCH
 *   Std_ReturnType Rte_Call_KeyMCertificateElement_Ssa_TrustModelIntermediateCert_Version_CertificateElementGet(uint8 *CertificateElementData, uint32 *CertificateDataLength)
 *     Argument CertificateElementData: uint8* is of type KeyM_CertificateElementType_Ssa_TrustModelIntermediateCert_Version
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_KeyMCertificateElement_Ssa_TrustModelIntermediateCert_Version_E_NOT_OK, RTE_E_KeyMCertificateElement_Ssa_TrustModelIntermediateCert_Version_KEYM_E_KEY_CERT_EMPTY, RTE_E_KeyMCertificateElement_Ssa_TrustModelIntermediateCert_Version_KEYM_E_KEY_CERT_INVALID, RTE_E_KeyMCertificateElement_Ssa_TrustModelIntermediateCert_Version_KEYM_E_KEY_CERT_SIZE_MISMATCH, RTE_E_KeyMCertificateElement_Ssa_TrustModelIntermediateCert_Version_KEYM_E_PARAMETER_MISMATCH
 *   Std_ReturnType Rte_Call_KeyMCertificateElement_Ssa_TrustModelIntermediateCert_ext_authKeyId_CertificateElementGet(uint8 *CertificateElementData, uint32 *CertificateDataLength)
 *     Argument CertificateElementData: uint8* is of type KeyM_CertificateElementType_Ssa_TrustModelIntermediateCert_ext_authKeyId
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_KeyMCertificateElement_Ssa_TrustModelIntermediateCert_ext_authKeyId_E_NOT_OK, RTE_E_KeyMCertificateElement_Ssa_TrustModelIntermediateCert_ext_authKeyId_KEYM_E_KEY_CERT_EMPTY, RTE_E_KeyMCertificateElement_Ssa_TrustModelIntermediateCert_ext_authKeyId_KEYM_E_KEY_CERT_INVALID, RTE_E_KeyMCertificateElement_Ssa_TrustModelIntermediateCert_ext_authKeyId_KEYM_E_KEY_CERT_SIZE_MISMATCH, RTE_E_KeyMCertificateElement_Ssa_TrustModelIntermediateCert_ext_authKeyId_KEYM_E_PARAMETER_MISMATCH
 *   Std_ReturnType Rte_Call_KeyMCertificateElement_Ssa_TrustModelIntermediateCert_ext_basicConstraints_CertificateElementGet(uint8 *CertificateElementData, uint32 *CertificateDataLength)
 *     Argument CertificateElementData: uint8* is of type KeyM_CertificateElementType_Ssa_TrustModelIntermediateCert_ext_basicConstraints
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_KeyMCertificateElement_Ssa_TrustModelIntermediateCert_ext_basicConstraints_E_NOT_OK, RTE_E_KeyMCertificateElement_Ssa_TrustModelIntermediateCert_ext_basicConstraints_KEYM_E_KEY_CERT_EMPTY, RTE_E_KeyMCertificateElement_Ssa_TrustModelIntermediateCert_ext_basicConstraints_KEYM_E_KEY_CERT_INVALID, RTE_E_KeyMCertificateElement_Ssa_TrustModelIntermediateCert_ext_basicConstraints_KEYM_E_KEY_CERT_SIZE_MISMATCH, RTE_E_KeyMCertificateElement_Ssa_TrustModelIntermediateCert_ext_basicConstraints_KEYM_E_PARAMETER_MISMATCH
 *   Std_ReturnType Rte_Call_KeyMCertificateElement_Ssa_TrustModelIntermediateCert_ext_subKeyId_CertificateElementGet(uint8 *CertificateElementData, uint32 *CertificateDataLength)
 *     Argument CertificateElementData: uint8* is of type KeyM_CertificateElementType_Ssa_TrustModelIntermediateCert_ext_subKeyId
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_KeyMCertificateElement_Ssa_TrustModelIntermediateCert_ext_subKeyId_E_NOT_OK, RTE_E_KeyMCertificateElement_Ssa_TrustModelIntermediateCert_ext_subKeyId_KEYM_E_KEY_CERT_EMPTY, RTE_E_KeyMCertificateElement_Ssa_TrustModelIntermediateCert_ext_subKeyId_KEYM_E_KEY_CERT_INVALID, RTE_E_KeyMCertificateElement_Ssa_TrustModelIntermediateCert_ext_subKeyId_KEYM_E_KEY_CERT_SIZE_MISMATCH, RTE_E_KeyMCertificateElement_Ssa_TrustModelIntermediateCert_ext_subKeyId_KEYM_E_PARAMETER_MISMATCH
 *   Std_ReturnType Rte_Call_KeyMCertificateElement_Ssa_TrustModelIntermediateCert_subject_CertificateElementGet(uint8 *CertificateElementData, uint32 *CertificateDataLength)
 *     Argument CertificateElementData: uint8* is of type KeyM_CertificateElementType_Ssa_TrustModelIntermediateCert_subject
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_KeyMCertificateElement_Ssa_TrustModelIntermediateCert_subject_E_NOT_OK, RTE_E_KeyMCertificateElement_Ssa_TrustModelIntermediateCert_subject_KEYM_E_KEY_CERT_EMPTY, RTE_E_KeyMCertificateElement_Ssa_TrustModelIntermediateCert_subject_KEYM_E_KEY_CERT_INVALID, RTE_E_KeyMCertificateElement_Ssa_TrustModelIntermediateCert_subject_KEYM_E_KEY_CERT_SIZE_MISMATCH, RTE_E_KeyMCertificateElement_Ssa_TrustModelIntermediateCert_subject_KEYM_E_PARAMETER_MISMATCH
 *   Std_ReturnType Rte_Call_KeyMCertificateElement_Ssa_TrustModelIntermediateCert_validityNotAfter_CertificateElementGet(uint8 *CertificateElementData, uint32 *CertificateDataLength)
 *     Argument CertificateElementData: uint8* is of type KeyM_CertificateElementType_Ssa_TrustModelIntermediateCert_validityNotAfter
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_KeyMCertificateElement_Ssa_TrustModelIntermediateCert_validityNotAfter_E_NOT_OK, RTE_E_KeyMCertificateElement_Ssa_TrustModelIntermediateCert_validityNotAfter_KEYM_E_KEY_CERT_EMPTY, RTE_E_KeyMCertificateElement_Ssa_TrustModelIntermediateCert_validityNotAfter_KEYM_E_KEY_CERT_INVALID, RTE_E_KeyMCertificateElement_Ssa_TrustModelIntermediateCert_validityNotAfter_KEYM_E_KEY_CERT_SIZE_MISMATCH, RTE_E_KeyMCertificateElement_Ssa_TrustModelIntermediateCert_validityNotAfter_KEYM_E_PARAMETER_MISMATCH
 *   Std_ReturnType Rte_Call_KeyMCertificateElement_Ssa_TrustModelRootCert_Issuer_CertificateElementGet(uint8 *CertificateElementData, uint32 *CertificateDataLength)
 *     Argument CertificateElementData: uint8* is of type KeyM_CertificateElementType_Ssa_TrustModelRootCert_Issuer
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_KeyMCertificateElement_Ssa_TrustModelRootCert_Issuer_E_NOT_OK, RTE_E_KeyMCertificateElement_Ssa_TrustModelRootCert_Issuer_KEYM_E_KEY_CERT_EMPTY, RTE_E_KeyMCertificateElement_Ssa_TrustModelRootCert_Issuer_KEYM_E_KEY_CERT_INVALID, RTE_E_KeyMCertificateElement_Ssa_TrustModelRootCert_Issuer_KEYM_E_KEY_CERT_SIZE_MISMATCH, RTE_E_KeyMCertificateElement_Ssa_TrustModelRootCert_Issuer_KEYM_E_PARAMETER_MISMATCH
 *   Std_ReturnType Rte_Call_KeyMCertificateElement_Ssa_TrustModelRootCert_SerialNo_CertificateElementGet(uint8 *CertificateElementData, uint32 *CertificateDataLength)
 *     Argument CertificateElementData: uint8* is of type KeyM_CertificateElementType_Ssa_TrustModelRootCert_SerialNo
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_KeyMCertificateElement_Ssa_TrustModelRootCert_SerialNo_E_NOT_OK, RTE_E_KeyMCertificateElement_Ssa_TrustModelRootCert_SerialNo_KEYM_E_KEY_CERT_EMPTY, RTE_E_KeyMCertificateElement_Ssa_TrustModelRootCert_SerialNo_KEYM_E_KEY_CERT_INVALID, RTE_E_KeyMCertificateElement_Ssa_TrustModelRootCert_SerialNo_KEYM_E_KEY_CERT_SIZE_MISMATCH, RTE_E_KeyMCertificateElement_Ssa_TrustModelRootCert_SerialNo_KEYM_E_PARAMETER_MISMATCH
 *   Std_ReturnType Rte_Call_KeyMCertificateElement_Ssa_TrustModelRootCert_SubjectPublicKeyInfoKey_CertificateElementGet(uint8 *CertificateElementData, uint32 *CertificateDataLength)
 *     Argument CertificateElementData: uint8* is of type KeyM_CertificateElementType_Ssa_TrustModelRootCert_SubjectPublicKeyInfoKey
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_KeyMCertificateElement_Ssa_TrustModelRootCert_SubjectPublicKeyInfoKey_E_NOT_OK, RTE_E_KeyMCertificateElement_Ssa_TrustModelRootCert_SubjectPublicKeyInfoKey_KEYM_E_KEY_CERT_EMPTY, RTE_E_KeyMCertificateElement_Ssa_TrustModelRootCert_SubjectPublicKeyInfoKey_KEYM_E_KEY_CERT_INVALID, RTE_E_KeyMCertificateElement_Ssa_TrustModelRootCert_SubjectPublicKeyInfoKey_KEYM_E_KEY_CERT_SIZE_MISMATCH, RTE_E_KeyMCertificateElement_Ssa_TrustModelRootCert_SubjectPublicKeyInfoKey_KEYM_E_PARAMETER_MISMATCH
 *   Std_ReturnType Rte_Call_KeyMCertificateElement_Ssa_TrustModelRootCert_Version_CertificateElementGet(uint8 *CertificateElementData, uint32 *CertificateDataLength)
 *     Argument CertificateElementData: uint8* is of type KeyM_CertificateElementType_Ssa_TrustModelRootCert_Version
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_KeyMCertificateElement_Ssa_TrustModelRootCert_Version_E_NOT_OK, RTE_E_KeyMCertificateElement_Ssa_TrustModelRootCert_Version_KEYM_E_KEY_CERT_EMPTY, RTE_E_KeyMCertificateElement_Ssa_TrustModelRootCert_Version_KEYM_E_KEY_CERT_INVALID, RTE_E_KeyMCertificateElement_Ssa_TrustModelRootCert_Version_KEYM_E_KEY_CERT_SIZE_MISMATCH, RTE_E_KeyMCertificateElement_Ssa_TrustModelRootCert_Version_KEYM_E_PARAMETER_MISMATCH
 *   Std_ReturnType Rte_Call_KeyMCertificateElement_Ssa_TrustModelRootCert_ext_basicConstraints_CertificateElementGet(uint8 *CertificateElementData, uint32 *CertificateDataLength)
 *     Argument CertificateElementData: uint8* is of type KeyM_CertificateElementType_Ssa_TrustModelRootCert_ext_basicConstraints
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_KeyMCertificateElement_Ssa_TrustModelRootCert_ext_basicConstraints_E_NOT_OK, RTE_E_KeyMCertificateElement_Ssa_TrustModelRootCert_ext_basicConstraints_KEYM_E_KEY_CERT_EMPTY, RTE_E_KeyMCertificateElement_Ssa_TrustModelRootCert_ext_basicConstraints_KEYM_E_KEY_CERT_INVALID, RTE_E_KeyMCertificateElement_Ssa_TrustModelRootCert_ext_basicConstraints_KEYM_E_KEY_CERT_SIZE_MISMATCH, RTE_E_KeyMCertificateElement_Ssa_TrustModelRootCert_ext_basicConstraints_KEYM_E_PARAMETER_MISMATCH
 *   Std_ReturnType Rte_Call_KeyMCertificateElement_Ssa_TrustModelRootCert_ext_keyUsage_CertificateElementGet(uint8 *CertificateElementData, uint32 *CertificateDataLength)
 *     Argument CertificateElementData: uint8* is of type KeyM_CertificateElementType_Ssa_TrustModelRootCert_ext_keyUsage
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_KeyMCertificateElement_Ssa_TrustModelRootCert_ext_keyUsage_E_NOT_OK, RTE_E_KeyMCertificateElement_Ssa_TrustModelRootCert_ext_keyUsage_KEYM_E_KEY_CERT_EMPTY, RTE_E_KeyMCertificateElement_Ssa_TrustModelRootCert_ext_keyUsage_KEYM_E_KEY_CERT_INVALID, RTE_E_KeyMCertificateElement_Ssa_TrustModelRootCert_ext_keyUsage_KEYM_E_KEY_CERT_SIZE_MISMATCH, RTE_E_KeyMCertificateElement_Ssa_TrustModelRootCert_ext_keyUsage_KEYM_E_PARAMETER_MISMATCH
 *   Std_ReturnType Rte_Call_KeyMCertificateElement_Ssa_TrustModelRootCert_ext_subKeyId_CertificateElementGet(uint8 *CertificateElementData, uint32 *CertificateDataLength)
 *     Argument CertificateElementData: uint8* is of type KeyM_CertificateElementType_Ssa_TrustModelRootCert_ext_subKeyId
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_KeyMCertificateElement_Ssa_TrustModelRootCert_ext_subKeyId_E_NOT_OK, RTE_E_KeyMCertificateElement_Ssa_TrustModelRootCert_ext_subKeyId_KEYM_E_KEY_CERT_EMPTY, RTE_E_KeyMCertificateElement_Ssa_TrustModelRootCert_ext_subKeyId_KEYM_E_KEY_CERT_INVALID, RTE_E_KeyMCertificateElement_Ssa_TrustModelRootCert_ext_subKeyId_KEYM_E_KEY_CERT_SIZE_MISMATCH, RTE_E_KeyMCertificateElement_Ssa_TrustModelRootCert_ext_subKeyId_KEYM_E_PARAMETER_MISMATCH
 *   Std_ReturnType Rte_Call_KeyMCertificateElement_Ssa_TrustModelRootCert_subject_CertificateElementGet(uint8 *CertificateElementData, uint32 *CertificateDataLength)
 *     Argument CertificateElementData: uint8* is of type KeyM_CertificateElementType_Ssa_TrustModelRootCert_subject
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_KeyMCertificateElement_Ssa_TrustModelRootCert_subject_E_NOT_OK, RTE_E_KeyMCertificateElement_Ssa_TrustModelRootCert_subject_KEYM_E_KEY_CERT_EMPTY, RTE_E_KeyMCertificateElement_Ssa_TrustModelRootCert_subject_KEYM_E_KEY_CERT_INVALID, RTE_E_KeyMCertificateElement_Ssa_TrustModelRootCert_subject_KEYM_E_KEY_CERT_SIZE_MISMATCH, RTE_E_KeyMCertificateElement_Ssa_TrustModelRootCert_subject_KEYM_E_PARAMETER_MISMATCH
 *   Std_ReturnType Rte_Call_KeyMCertificateElement_Ssa_TrustModelRootCert_validityNotAfter_CertificateElementGet(uint8 *CertificateElementData, uint32 *CertificateDataLength)
 *     Argument CertificateElementData: uint8* is of type KeyM_CertificateElementType_Ssa_TrustModelRootCert_validityNotAfter
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_KeyMCertificateElement_Ssa_TrustModelRootCert_validityNotAfter_E_NOT_OK, RTE_E_KeyMCertificateElement_Ssa_TrustModelRootCert_validityNotAfter_KEYM_E_KEY_CERT_EMPTY, RTE_E_KeyMCertificateElement_Ssa_TrustModelRootCert_validityNotAfter_KEYM_E_KEY_CERT_INVALID, RTE_E_KeyMCertificateElement_Ssa_TrustModelRootCert_validityNotAfter_KEYM_E_KEY_CERT_SIZE_MISMATCH, RTE_E_KeyMCertificateElement_Ssa_TrustModelRootCert_validityNotAfter_KEYM_E_PARAMETER_MISMATCH
 *   Std_ReturnType Rte_Call_KeyMCertificate_Ssa_TrustModelBackendCert_GetStatus(KeyM_CertificateStatusType *Status)
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_KeyMCertificate_Ssa_TrustModelBackendCert_E_NOT_OK
 *   Std_ReturnType Rte_Call_KeyMCertificate_Ssa_TrustModelEcuCert_GetStatus(KeyM_CertificateStatusType *Status)
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_KeyMCertificate_Ssa_TrustModelEcuCert_E_NOT_OK
 *   Std_ReturnType Rte_Call_KeyMCertificate_Ssa_TrustModelIntermediateCert_GetStatus(KeyM_CertificateStatusType *Status)
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_KeyMCertificate_Ssa_TrustModelIntermediateCert_E_NOT_OK
 *   Std_ReturnType Rte_Call_KeyMCertificate_Ssa_TrustModelRootCert_GetStatus(KeyM_CertificateStatusType *Status)
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_KeyMCertificate_Ssa_TrustModelRootCert_E_NOT_OK
 *   Std_ReturnType Rte_Call_Key_BackendCert_KeyElementGet(uint32 keyElementId, uint8 *keyPtr, uint32 *keyLength)
 *     Argument keyPtr: uint8* is of type Csm_KeyDataType_Ssa_BackendCert
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_CsmKeyManagement_Ssa_BackendCert_CSM_E_BUSY, RTE_E_CsmKeyManagement_Ssa_BackendCert_CSM_E_KEY_EMPTY, RTE_E_CsmKeyManagement_Ssa_BackendCert_CSM_E_KEY_NOT_AVAILABLE, RTE_E_CsmKeyManagement_Ssa_BackendCert_CSM_E_KEY_READ_FAIL, RTE_E_CsmKeyManagement_Ssa_BackendCert_CSM_E_SMALL_BUFFER, RTE_E_CsmKeyManagement_Ssa_BackendCert_E_NOT_OK
 *   Std_ReturnType Rte_Call_Key_EcuCert_KeyElementGet(uint32 keyElementId, uint8 *keyPtr, uint32 *keyLength)
 *     Argument keyPtr: uint8* is of type Csm_KeyDataType_Ssa_EcuCert
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_CsmKeyManagement_Ssa_EcuCert_CSM_E_BUSY, RTE_E_CsmKeyManagement_Ssa_EcuCert_CSM_E_KEY_EMPTY, RTE_E_CsmKeyManagement_Ssa_EcuCert_CSM_E_KEY_NOT_AVAILABLE, RTE_E_CsmKeyManagement_Ssa_EcuCert_CSM_E_KEY_READ_FAIL, RTE_E_CsmKeyManagement_Ssa_EcuCert_CSM_E_SMALL_BUFFER, RTE_E_CsmKeyManagement_Ssa_EcuCert_E_NOT_OK
 *   Std_ReturnType Rte_Call_Key_RootCert_KeyElementGet(uint32 keyElementId, uint8 *keyPtr, uint32 *keyLength)
 *     Argument keyPtr: uint8* is of type Csm_KeyDataType_Ssa_RootCert
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_CsmKeyManagement_Ssa_RootCert_CSM_E_BUSY, RTE_E_CsmKeyManagement_Ssa_RootCert_CSM_E_KEY_EMPTY, RTE_E_CsmKeyManagement_Ssa_RootCert_CSM_E_KEY_NOT_AVAILABLE, RTE_E_CsmKeyManagement_Ssa_RootCert_CSM_E_KEY_READ_FAIL, RTE_E_CsmKeyManagement_Ssa_RootCert_CSM_E_SMALL_BUFFER, RTE_E_CsmKeyManagement_Ssa_RootCert_E_NOT_OK
 *   Std_ReturnType Rte_Call_Key_SignatureRamKey_KeyElementSet(uint32 keyElementId, const uint8 *keyPtr, uint32 keyLength)
 *     Argument keyPtr: uint8* is of type Csm_KeyDataType_Ssa_SignatureRamKey
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_CsmKeyManagement_Ssa_SignatureRamKey_CSM_E_BUSY, RTE_E_CsmKeyManagement_Ssa_SignatureRamKey_CSM_E_KEY_NOT_AVAILABLE, RTE_E_CsmKeyManagement_Ssa_SignatureRamKey_CSM_E_KEY_SIZE_MISMATCH, RTE_E_CsmKeyManagement_Ssa_SignatureRamKey_CSM_E_KEY_WRITE_FAIL, RTE_E_CsmKeyManagement_Ssa_SignatureRamKey_CSM_E_SMALL_BUFFER, RTE_E_CsmKeyManagement_Ssa_SignatureRamKey_E_NOT_OK
 *   Std_ReturnType Rte_Call_Key_SignatureRamKey_KeySetValid(void)
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_CsmKeyManagement_Ssa_SignatureRamKey_CSM_E_BUSY, RTE_E_CsmKeyManagement_Ssa_SignatureRamKey_E_NOT_OK
 *   Std_ReturnType Rte_Call_Key_TrustModelTempPublicKey_KeyElementGet(uint32 keyElementId, uint8 *keyPtr, uint32 *keyLength)
 *     Argument keyPtr: uint8* is of type Csm_KeyDataType_Ssa_TrustModelTempPublicKey
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_CsmKeyManagement_Ssa_TrustModelTempPublicKey_CSM_E_BUSY, RTE_E_CsmKeyManagement_Ssa_TrustModelTempPublicKey_CSM_E_KEY_EMPTY, RTE_E_CsmKeyManagement_Ssa_TrustModelTempPublicKey_CSM_E_KEY_NOT_AVAILABLE, RTE_E_CsmKeyManagement_Ssa_TrustModelTempPublicKey_CSM_E_KEY_READ_FAIL, RTE_E_CsmKeyManagement_Ssa_TrustModelTempPublicKey_CSM_E_SMALL_BUFFER, RTE_E_CsmKeyManagement_Ssa_TrustModelTempPublicKey_E_NOT_OK
 *   Std_ReturnType Rte_Call_Key_TrustModelTempPublicKey_KeyElementSet(uint32 keyElementId, const uint8 *keyPtr, uint32 keyLength)
 *     Argument keyPtr: uint8* is of type Csm_KeyDataType_Ssa_TrustModelTempPublicKey
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_CsmKeyManagement_Ssa_TrustModelTempPublicKey_CSM_E_BUSY, RTE_E_CsmKeyManagement_Ssa_TrustModelTempPublicKey_CSM_E_KEY_NOT_AVAILABLE, RTE_E_CsmKeyManagement_Ssa_TrustModelTempPublicKey_CSM_E_KEY_SIZE_MISMATCH, RTE_E_CsmKeyManagement_Ssa_TrustModelTempPublicKey_CSM_E_KEY_WRITE_FAIL, RTE_E_CsmKeyManagement_Ssa_TrustModelTempPublicKey_E_NOT_OK
 *   Std_ReturnType Rte_Call_Key_TrustModelTempPublicKey_KeySetValid(void)
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_CsmKeyManagement_Ssa_TrustModelTempPublicKey_CSM_E_BUSY, RTE_E_CsmKeyManagement_Ssa_TrustModelTempPublicKey_E_NOT_OK
 *
 **********************************************************************************************************************
 *
 * Runnable prototype:
 * ===================
 *   Std_ReturnType Ssa_KeyM_RoutineServices_Routine_Certificate_Self_Check(Dcm_OpStatusType OpStatus, uint8 *routineInfo, uint8 *Verification_Result, uint16 *DataLength, Dcm_NegativeResponseCodeType *ErrorCode)
 *     Argument Verification_Result: uint8* is of type Dcm_Data18ByteType
 *
 **********************************************************************************************************************
 *
 * Available Application Errors:
 * =============================
 *   RTE_E_RoutineServices_Routine_Certificate_Self_Check_DCM_E_FORCE_RCRRP
 *   RTE_E_RoutineServices_Routine_Certificate_Self_Check_DCM_E_PENDING
 *   RTE_E_RoutineServices_Routine_Certificate_Self_Check_E_NOT_OK
 *
 *********************************************************************************************************************/
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << Start of documentation area >>                  DO NOT CHANGE THIS COMMENT!
 * Symbol: Ssa_KeyM_RoutineServices_Routine_Certificate_Self_Check_doc
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 */
/*!
 * \spec
 *    requires $lengthOf(Verification_Result) >= sizeof(Dcm_Data18ByteType);
 * \endspec
 */
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << End of documentation area >>                    DO NOT CHANGE THIS COMMENT!
 *********************************************************************************************************************/

FUNC(Std_ReturnType, Ssa_KeyM_CODE) Ssa_KeyM_RoutineServices_Routine_Certificate_Self_Check(
  Dcm_OpStatusType OpStatus,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) routineInfo,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) Verification_Result,
  P2VAR(uint16, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) DataLength,
  P2VAR(Dcm_NegativeResponseCodeType, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) ErrorCode) /* PRQA S 0624, 3206 */ /* MD_Rte_0624, MD_Rte_3206 */
{
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << Start of runnable implementation >>             DO NOT CHANGE THIS COMMENT!
 * Symbol: Ssa_KeyM_RoutineServices_Routine_Certificate_Self_Check (returns application error)
 *********************************************************************************************************************/

  Std_ReturnType retVal = RTE_E_RoutineServices_Routine_Certificate_Self_Check_E_NOT_OK;

  /* ----- Development Error Checks ------------------------------------- */
#if (SSA_DEV_ERROR_DETECT == STD_ON)
  if ((routineInfo == NULL_PTR)
    || (Verification_Result == NULL_PTR)
    || (DataLength == NULL_PTR)
    || (ErrorCode == NULL_PTR))
  {
    /* retVal already set */
  }
  else
#endif /* SSA_DEV_ERROR_DETECT == STD_ON */
  {
#if (SSA_ENABLE_ASYNC_CSM_JOB_PROCESSING == STD_ON)
    Std_ReturnType retVal_DiagChain = RTE_E_RoutineServices_Routine_Certificate_Self_Check_E_NOT_OK;
#endif
    Std_ReturnType retVal_TrustModelChain = RTE_E_RoutineServices_Routine_Certificate_Self_Check_E_NOT_OK;

    /* #10 Return immediately if OpStatus == DCM_CANCEL. */
    if (OpStatus == DCM_CANCEL)
    {
      retVal = RTE_E_OK;
      KeyM_DiagProc.state = KEYM_CERTIFICATE_SELFCHECK_STATE_IDLE;
    }
    else
    {
#if (SSA_ENABLE_ASYNC_CSM_JOB_PROCESSING == STD_ON)
      /* #20 Check the Diagnostic Chain. */
      if ((KeyM_DiagProc.state == KEYM_CERTIFICATE_SELFCHECK_STATE_IDLE) || (((KeyM_DiagProc.state) & (KEYM_CERTIFICATE_SELFCHECK_STATE_DIAGCHAIN)) == KEYM_CERTIFICATE_SELFCHECK_STATE_DIAGCHAIN))
      {
        retVal_DiagChain = KeyM_SelfCheck_DiagnosticChain();
      }
      /* #30 Check the ECU ID Chain. */
      if (((KeyM_DiagProc.state) & (KEYM_CERTIFICATE_SELFCHECK_STATE_ECUIDCHAIN)) == KEYM_CERTIFICATE_SELFCHECK_STATE_ECUIDCHAIN)
      {
        retVal_TrustModelChain = KeyM_SelfCheck_UniqueEcuIdChain();
      }
      /* Check if the service has finished. */
      if ((retVal_DiagChain == RTE_E_RoutineServices_Routine_Certificate_Self_Check_DCM_E_PENDING) || (retVal_TrustModelChain == RTE_E_RoutineServices_Routine_Certificate_Self_Check_DCM_E_PENDING))
#else
      if (KeyM_DiagProc.state == KEYM_CERTIFICATE_SELFCHECK_STATE_IDLE)
      {
        /* #20 Check the Diagnostic Chain. */
        /* If processing of async jobs is disabled, the return value of checking the diagnostic chain is not required.
         * KeyM_DiagProc.ws.certSelfCheck.verResultLen is initialized in KeyM_SelfCheck_DiagnosticChain(). */
        (void)KeyM_SelfCheck_DiagnosticChain();
      }
      /* #30 Check the ECU ID Chain. */
      retVal_TrustModelChain = KeyM_SelfCheck_UniqueEcuIdChain();
      /* Check if the service has finished. */
      if (retVal_TrustModelChain == RTE_E_RoutineServices_Routine_Certificate_Self_Check_DCM_E_PENDING)
#endif
      {
        retVal = RTE_E_RoutineServices_Routine_Certificate_Self_Check_DCM_E_PENDING;
      }
      else
      {
        *routineInfo = SSA_ROUTINE_INFO_SUCCESFULLY_COMPLETED;
        KeyM_DiagProc.state = KEYM_CERTIFICATE_SELFCHECK_STATE_IDLE;
        if (retVal_TrustModelChain == RTE_E_OK)
        {
          retVal = RTE_E_OK;
          if (KeyM_DiagProc.ws.certSelfCheck.verResultLen == 0u)
          {
            /* Both chains could be verified. */
            Verification_Result[0] = SSA_VER_RES_CERTSELFCHECK_VERIFICATION_SUCCESSFUL;
            *DataLength = 1u;
            /* Set positive response code */
            *ErrorCode = DCM_E_POSITIVERESPONSE;
          }
          else
          {
            /* Verification failure, set verification result. */
            /* Copy the whole verification result buffer of fixed length in order to not write out of bounds. */
            KeyM_CopyDataBuffer(Verification_Result, KeyM_DiagProc.ws.certSelfCheck.verResult, SSA_KEYM_SELFCHECK_SIZEOF_VERIFICATION_RESULT);
            *DataLength = KeyM_DiagProc.ws.certSelfCheck.verResultLen;
            /* Set positive response code */
            *ErrorCode = DCM_E_POSITIVERESPONSE;
          }
        }
        else
        {
          retVal = E_NOT_OK;
          /* Set negative response code */
          *ErrorCode = DCM_E_GENERALREJECT;
        }
      }
    }
  }

  return retVal;

  /* PRQA S 6030, 6080 4 */ /* MD_MSR_STCYC, MD_MSR_STMIF */
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << End of runnable implementation >>               DO NOT CHANGE THIS COMMENT!
 *********************************************************************************************************************/
}

#if (SSA_ECU_TYPE == SSA_ECU_TYPE_VSM)

/**********************************************************************************************************************
 *
 * Runnable Entity Name: Ssa_KeyM_RoutineServices_Routine_SecOC_ECU_Shared_Secret_Encryption
 *
 *---------------------------------------------------------------------------------------------------------------------
 *
 * Executed if at least one of the following trigger conditions occurred:
 *   - triggered by server invocation for OperationPrototype <Start> of PortPrototype <RoutineServices_Routine_SecOC_ECU_Shared_Secret_Encryption>
 *
 **********************************************************************************************************************
 *
 * Client/Server Interfaces:
 * =========================
 *   Server Invocation:
 *   ------------------
 *   Std_ReturnType Rte_Call_CertP_Functions_Certificate_Parse(const uint8 *rawCertData, uint16 rawCertLength, CertP_ParsedCertStructureType *parsedCert)
 *     Argument rawCertData: uint8* is of type CertP_RawCertBufferType
 *     Synchronous Server Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_CertP_Functions_E_NOT_OK
 *   Std_ReturnType Rte_Call_CertP_Functions_Certificate_Verify(const uint8 *rawCertData, CertP_ParsedCertStructureType *parsedCert, const uint8 *rawCertIssuer, const CertP_ParsedCertStructureType *parsedCertIssuer, CertP_PkiRoleType expectedPkiRole)
 *     Argument rawCertData: uint8* is of type CertP_RawCertBufferType
 *     Argument rawCertIssuer: uint8* is of type CertP_RawCertBufferType
 *     Synchronous Server Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_CertP_Functions_E_NOT_OK, RTE_E_CertP_Functions_E_PENDING
 *   Std_ReturnType Rte_Call_RightsM_DiagnosticChannel_GetDiagnosticUserRole(RightsM_DiagnosticUserRoleType *userRole)
 *     Synchronous Server Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_RightsM_DiagnosticChannel_E_NOT_OK
 *   Std_ReturnType Rte_Call_RightsM_DiagnosticChannel_GetPostProductionStatus(Ssa_PostProductionStatusType *status)
 *     Synchronous Server Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_RightsM_DiagnosticChannel_E_NOT_OK
 *   Std_ReturnType Rte_Call_RightsM_EnhancedRights_VerifySubjectKeyIdentifier(const uint8 *subjectKeyIdentifier)
 *     Argument subjectKeyIdentifier: uint8* is of type Ssa_Data20ByteType
 *     Synchronous Server Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_RightsM_EnhancedRights_E_NOT_OK
 *   Std_ReturnType Rte_Call_SecLog_SuccessfulDiagServiceExecutionEvent_EcuSharedSecretEncryption_SuccessfulDiagServiceExecution(uint8 additionalInfo)
 *     Synchronous Server Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_SecLog_SuccessfulDiagServiceExecutionEvent_E_NOT_OK
 *   Std_ReturnType Rte_Call_SsaCdd_Csm_Hash(uint32 jobId, Crypto_OperationModeType operationMode, Ssa_ConstDataPtr dataBuffer, uint32 dataLength, Ssa_DataPtr resultBuffer, Ssa_LengthPtr resultLength)
 *     Synchronous Server Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_SsaCdd_CryptoInterface_E_NOT_OK
 *   Std_ReturnType Rte_Call_SsaCdd_Csm_SignatureGenerate(uint32 jobId, Crypto_OperationModeType operationMode, Ssa_ConstDataPtr dataBuffer, uint32 dataLength, Ssa_DataPtr resultBuffer, Ssa_LengthPtr resultLength)
 *     Synchronous Server Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_SsaCdd_CryptoInterface_E_NOT_OK
 *   Std_ReturnType Rte_Call_SsaCdd_Csm_SignatureVerify(uint32 jobId, Crypto_OperationModeType operationMode, Ssa_ConstDataPtr dataBuffer, uint32 dataLength, Ssa_ConstDataPtr compareBuffer, uint32 compareLength, Ssa_VerifyResultPtr resultBuffer)
 *     Synchronous Server Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_SsaCdd_CryptoInterface_E_NOT_OK
 *   Std_ReturnType Rte_Call_Ssa_KeyProc_PrepareKeyExchange(Ssa_OpStatusType opStatus, uint32 keyId)
 *     Synchronous Server Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_Ssa_KeyProc_E_NOT_OK, RTE_E_Ssa_KeyProc_E_PENDING
 *   Std_ReturnType Rte_Call_TimeM_RealTime_Compare(const TimeM_DateTimeType *t1, TimeM_CompareOperatorType compareOp, const TimeM_DateTimeType *t2, boolean *result)
 *     Synchronous Server Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_TimeM_RealTime_E_NOT_OK
 *   Std_ReturnType Rte_Call_TimeM_RealTime_Get(TimeM_DateTimeType *realTime)
 *     Synchronous Server Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_TimeM_RealTime_E_NOT_OK
 *   Std_ReturnType Rte_Call_TimeM_TimeRawData_Get(uint8 *dateTimeOffset, uint8 *tickCountOffset, uint8 *tickCount)
 *     Argument dateTimeOffset: uint8* is of type Ssa_Data7ByteType
 *     Argument tickCountOffset: uint8* is of type Ssa_Data5ByteType
 *     Argument tickCount: uint8* is of type Ssa_Data5ByteType
 *     Synchronous Server Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_TimeM_TimeRawData_E_NOT_OK
 *
 * Service Calls:
 * ==============
 *   Service Invocation:
 *   -------------------
 *   Std_ReturnType Rte_Call_CsmJobKeyExchangeCalcPubVal_KeyExchangeCalcPubVal(uint32 key, Csm_DataPtr publicValuePtr, Csm_LengthPtr publicValueLengthPtr)
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_CsmJobKeyExchangeCalcPubVal_CSM_E_BUSY, RTE_E_CsmJobKeyExchangeCalcPubVal_CSM_E_KEY_EMPTY, RTE_E_CsmJobKeyExchangeCalcPubVal_CSM_E_SMALL_BUFFER, RTE_E_CsmJobKeyExchangeCalcPubVal_E_NOT_OK
 *   Std_ReturnType Rte_Call_CsmJobKeyExchangeCalcSecret_KeyExchangeCalcSecret(uint32 key, Csm_const_DataPtr partnerPublicValuePtr, uint32 partnerPublicValueLength)
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_CsmJobKeyExchangeCalcSecret_CSM_E_BUSY, RTE_E_CsmJobKeyExchangeCalcSecret_CSM_E_KEY_EMPTY, RTE_E_CsmJobKeyExchangeCalcSecret_CSM_E_SMALL_BUFFER, RTE_E_CsmJobKeyExchangeCalcSecret_E_NOT_OK
 *   Std_ReturnType Rte_Call_CsmRandomGenerate_RandomGenerate(uint8 *resultBuffer, uint32 *resultLength)
 *     Argument resultBuffer: uint8* is of type Csm_RandomGenerateResultType_Random
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_CsmRandomGenerate_Random_CSM_E_BUSY, RTE_E_CsmRandomGenerate_Random_CSM_E_ENTROPY_EXHAUSTION, RTE_E_CsmRandomGenerate_Random_E_NOT_OK
 *   Std_ReturnType Rte_Call_CsmSymAES128Encrypt_Encrypt(const uint8 *dataBuffer, uint32 dataLength, uint8 *resultBuffer, uint32 *resultLength)
 *     Argument dataBuffer: uint8* is of type Csm_EncryptDataType_AES128Encrypt
 *     Argument resultBuffer: uint8* is of type Csm_EncryptResultType_AES128Encrypt
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_CsmEncrypt_AES128Encrypt_CSM_E_BUSY, RTE_E_CsmEncrypt_AES128Encrypt_CSM_E_KEY_EMPTY, RTE_E_CsmEncrypt_AES128Encrypt_CSM_E_KEY_NOT_VALID, RTE_E_CsmEncrypt_AES128Encrypt_CSM_E_KEY_SIZE_MISMATCH, RTE_E_CsmEncrypt_AES128Encrypt_CSM_E_SMALL_BUFFER, RTE_E_CsmEncrypt_AES128Encrypt_E_NOT_OK
 *   Std_ReturnType Rte_Call_Key_AesRamKey_KeyElementSet(uint32 keyElementId, const uint8 *keyPtr, uint32 keyLength)
 *     Argument keyPtr: uint8* is of type Csm_KeyDataType_Ssa_AesRamKey
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_CsmKeyManagement_Ssa_AesRamKey_CSM_E_BUSY, RTE_E_CsmKeyManagement_Ssa_AesRamKey_CSM_E_KEY_NOT_AVAILABLE, RTE_E_CsmKeyManagement_Ssa_AesRamKey_CSM_E_KEY_SIZE_MISMATCH, RTE_E_CsmKeyManagement_Ssa_AesRamKey_CSM_E_KEY_WRITE_FAIL, RTE_E_CsmKeyManagement_Ssa_AesRamKey_CSM_E_SMALL_BUFFER, RTE_E_CsmKeyManagement_Ssa_AesRamKey_E_NOT_OK
 *   Std_ReturnType Rte_Call_Key_AesRamKey_KeySetValid(void)
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_CsmKeyManagement_Ssa_AesRamKey_CSM_E_BUSY, RTE_E_CsmKeyManagement_Ssa_AesRamKey_E_NOT_OK
 *   Std_ReturnType Rte_Call_Key_BackendCert_KeyElementGet(uint32 keyElementId, uint8 *keyPtr, uint32 *keyLength)
 *     Argument keyPtr: uint8* is of type Csm_KeyDataType_Ssa_BackendCert
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_CsmKeyManagement_Ssa_BackendCert_CSM_E_BUSY, RTE_E_CsmKeyManagement_Ssa_BackendCert_CSM_E_KEY_EMPTY, RTE_E_CsmKeyManagement_Ssa_BackendCert_CSM_E_KEY_NOT_AVAILABLE, RTE_E_CsmKeyManagement_Ssa_BackendCert_CSM_E_KEY_READ_FAIL, RTE_E_CsmKeyManagement_Ssa_BackendCert_CSM_E_SMALL_BUFFER, RTE_E_CsmKeyManagement_Ssa_BackendCert_E_NOT_OK
 *   Std_ReturnType Rte_Call_Key_EcuCert_KeyElementGet(uint32 keyElementId, uint8 *keyPtr, uint32 *keyLength)
 *     Argument keyPtr: uint8* is of type Csm_KeyDataType_Ssa_EcuCert
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_CsmKeyManagement_Ssa_EcuCert_CSM_E_BUSY, RTE_E_CsmKeyManagement_Ssa_EcuCert_CSM_E_KEY_EMPTY, RTE_E_CsmKeyManagement_Ssa_EcuCert_CSM_E_KEY_NOT_AVAILABLE, RTE_E_CsmKeyManagement_Ssa_EcuCert_CSM_E_KEY_READ_FAIL, RTE_E_CsmKeyManagement_Ssa_EcuCert_CSM_E_SMALL_BUFFER, RTE_E_CsmKeyManagement_Ssa_EcuCert_E_NOT_OK
 *   Std_ReturnType Rte_Call_Key_SharedSecret_KeyElementGet(uint32 keyElementId, uint8 *keyPtr, uint32 *keyLength)
 *     Argument keyPtr: uint8* is of type Csm_KeyDataType_Ssa_SharedSecret
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_CsmKeyManagement_Ssa_SharedSecret_CSM_E_BUSY, RTE_E_CsmKeyManagement_Ssa_SharedSecret_CSM_E_KEY_EMPTY, RTE_E_CsmKeyManagement_Ssa_SharedSecret_CSM_E_KEY_NOT_AVAILABLE, RTE_E_CsmKeyManagement_Ssa_SharedSecret_CSM_E_KEY_READ_FAIL, RTE_E_CsmKeyManagement_Ssa_SharedSecret_CSM_E_SMALL_BUFFER, RTE_E_CsmKeyManagement_Ssa_SharedSecret_E_NOT_OK
 *   Std_ReturnType Rte_Call_Key_SharedSecret_KeyElementSet(uint32 keyElementId, const uint8 *keyPtr, uint32 keyLength)
 *     Argument keyPtr: uint8* is of type Csm_KeyDataType_Ssa_SharedSecret
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_CsmKeyManagement_Ssa_SharedSecret_CSM_E_BUSY, RTE_E_CsmKeyManagement_Ssa_SharedSecret_CSM_E_KEY_NOT_AVAILABLE, RTE_E_CsmKeyManagement_Ssa_SharedSecret_CSM_E_KEY_SIZE_MISMATCH, RTE_E_CsmKeyManagement_Ssa_SharedSecret_CSM_E_KEY_WRITE_FAIL, RTE_E_CsmKeyManagement_Ssa_SharedSecret_CSM_E_SMALL_BUFFER, RTE_E_CsmKeyManagement_Ssa_SharedSecret_E_NOT_OK
 *   Std_ReturnType Rte_Call_Key_SharedSecret_KeySetValid(void)
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_CsmKeyManagement_Ssa_SharedSecret_CSM_E_BUSY, RTE_E_CsmKeyManagement_Ssa_SharedSecret_E_NOT_OK
 *   Std_ReturnType Rte_Call_Key_SharedSecretKeyExchange_KeyElementGet(uint32 keyElementId, uint8 *keyPtr, uint32 *keyLength)
 *     Argument keyPtr: uint8* is of type Csm_KeyDataType_Ssa_SharedSecretKeyExchange
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_CsmKeyManagement_Ssa_SharedSecretKeyExchange_CSM_E_BUSY, RTE_E_CsmKeyManagement_Ssa_SharedSecretKeyExchange_CSM_E_KEY_EMPTY, RTE_E_CsmKeyManagement_Ssa_SharedSecretKeyExchange_CSM_E_KEY_NOT_AVAILABLE, RTE_E_CsmKeyManagement_Ssa_SharedSecretKeyExchange_CSM_E_KEY_READ_FAIL, RTE_E_CsmKeyManagement_Ssa_SharedSecretKeyExchange_CSM_E_SMALL_BUFFER, RTE_E_CsmKeyManagement_Ssa_SharedSecretKeyExchange_E_NOT_OK
 *   Std_ReturnType Rte_Call_Key_SharedSecretKeyExchange_KeyElementSet(uint32 keyElementId, const uint8 *keyPtr, uint32 keyLength)
 *     Argument keyPtr: uint8* is of type Csm_KeyDataType_Ssa_SharedSecretKeyExchange
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_CsmKeyManagement_Ssa_SharedSecretKeyExchange_CSM_E_BUSY, RTE_E_CsmKeyManagement_Ssa_SharedSecretKeyExchange_CSM_E_KEY_NOT_AVAILABLE, RTE_E_CsmKeyManagement_Ssa_SharedSecretKeyExchange_CSM_E_KEY_SIZE_MISMATCH, RTE_E_CsmKeyManagement_Ssa_SharedSecretKeyExchange_CSM_E_KEY_WRITE_FAIL, RTE_E_CsmKeyManagement_Ssa_SharedSecretKeyExchange_CSM_E_SMALL_BUFFER, RTE_E_CsmKeyManagement_Ssa_SharedSecretKeyExchange_E_NOT_OK
 *   Std_ReturnType Rte_Call_Key_SharedSecretKeyExchange_KeyExchangeCalcPubVal(uint8 *publicValuePtr, uint32 *publicValueLengthPtr)
 *     Argument publicValuePtr: uint8* is of type Csm_PublicValueDataType_Ssa_SharedSecretKeyExchange
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_CsmKeyManagement_Ssa_SharedSecretKeyExchange_CSM_E_BUSY, RTE_E_CsmKeyManagement_Ssa_SharedSecretKeyExchange_CSM_E_KEY_EMPTY, RTE_E_CsmKeyManagement_Ssa_SharedSecretKeyExchange_CSM_E_SMALL_BUFFER, RTE_E_CsmKeyManagement_Ssa_SharedSecretKeyExchange_E_NOT_OK
 *   Std_ReturnType Rte_Call_Key_SharedSecretKeyExchange_KeyExchangeCalcSecret(const uint8 *partnerPublicValuePtr, uint32 partnerPublicValueLength)
 *     Argument partnerPublicValuePtr: uint8* is of type Csm_PublicValueDataType_Ssa_SharedSecretKeyExchange
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_CsmKeyManagement_Ssa_SharedSecretKeyExchange_CSM_E_BUSY, RTE_E_CsmKeyManagement_Ssa_SharedSecretKeyExchange_CSM_E_KEY_EMPTY, RTE_E_CsmKeyManagement_Ssa_SharedSecretKeyExchange_CSM_E_SMALL_BUFFER, RTE_E_CsmKeyManagement_Ssa_SharedSecretKeyExchange_E_NOT_OK
 *   Std_ReturnType Rte_Call_Key_SharedSecretKeyExchange_KeySetValid(void)
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_CsmKeyManagement_Ssa_SharedSecretKeyExchange_CSM_E_BUSY, RTE_E_CsmKeyManagement_Ssa_SharedSecretKeyExchange_E_NOT_OK
 *   Std_ReturnType Rte_Call_Key_SignatureRamKey_KeyElementSet(uint32 keyElementId, const uint8 *keyPtr, uint32 keyLength)
 *     Argument keyPtr: uint8* is of type Csm_KeyDataType_Ssa_SignatureRamKey
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_CsmKeyManagement_Ssa_SignatureRamKey_CSM_E_BUSY, RTE_E_CsmKeyManagement_Ssa_SignatureRamKey_CSM_E_KEY_NOT_AVAILABLE, RTE_E_CsmKeyManagement_Ssa_SignatureRamKey_CSM_E_KEY_SIZE_MISMATCH, RTE_E_CsmKeyManagement_Ssa_SignatureRamKey_CSM_E_KEY_WRITE_FAIL, RTE_E_CsmKeyManagement_Ssa_SignatureRamKey_CSM_E_SMALL_BUFFER, RTE_E_CsmKeyManagement_Ssa_SignatureRamKey_E_NOT_OK
 *   Std_ReturnType Rte_Call_Key_SignatureRamKey_KeySetValid(void)
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_CsmKeyManagement_Ssa_SignatureRamKey_CSM_E_BUSY, RTE_E_CsmKeyManagement_Ssa_SignatureRamKey_E_NOT_OK
 *
 * Exclusive Area Access:
 * ======================
 *   void Rte_Enter_KeyM_ExclusiveArea(void)
 *   void Rte_Exit_KeyM_ExclusiveArea(void)
 *
 **********************************************************************************************************************
 *
 * Runnable prototype:
 * ===================
 *   Std_ReturnType Ssa_KeyM_RoutineServices_Routine_SecOC_ECU_Shared_Secret_Encryption(const uint8 *Nonce, const uint8 *Ephemeral_ECU_Public_Key, const uint8 *Data_Signature_In, const uint8 *Target_ECU_Certificate, Dcm_OpStatusType OpStatus, uint8 *routineInfo, uint8 *Verification_Result, uint8 *Date_and_Time, uint8 *Tick_Count, uint8 *Tick_Count_Offset, uint8 *Encrypted_Nonce_and_Shared_Secret, uint8 *Ephemeral_VSM_Public_Key, uint8 *Data_Signature_Out, uint8 *VSM_s_ECU_Certificate, uint16 *DataLength, Dcm_NegativeResponseCodeType *ErrorCode)
 *     Argument Nonce: uint8* is of type Dcm_Data32ByteType
 *     Argument Ephemeral_ECU_Public_Key: uint8* is of type Dcm_Data32ByteType
 *     Argument Data_Signature_In: uint8* is of type Dcm_Data64ByteType
 *     Argument Target_ECU_Certificate: uint8* is of type Dcm_Data1002ByteType
 *     Argument Date_and_Time: uint8* is of type Dcm_Data7ByteType
 *     Argument Tick_Count: uint8* is of type Dcm_Data5ByteType
 *     Argument Tick_Count_Offset: uint8* is of type Dcm_Data5ByteType
 *     Argument Encrypted_Nonce_and_Shared_Secret: uint8* is of type Dcm_Data80ByteType
 *     Argument Ephemeral_VSM_Public_Key: uint8* is of type Dcm_Data32ByteType
 *     Argument Data_Signature_Out: uint8* is of type Dcm_Data64ByteType
 *     Argument VSM_s_ECU_Certificate: uint8* is of type Dcm_Data1002ByteType
 *
 **********************************************************************************************************************
 *
 * Available Application Errors:
 * =============================
 *   RTE_E_RoutineServices_Routine_SecOC_ECU_Shared_Secret_Encryption_DCM_E_FORCE_RCRRP
 *   RTE_E_RoutineServices_Routine_SecOC_ECU_Shared_Secret_Encryption_DCM_E_PENDING
 *   RTE_E_RoutineServices_Routine_SecOC_ECU_Shared_Secret_Encryption_E_NOT_OK
 *
 *********************************************************************************************************************/
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << Start of documentation area >>                  DO NOT CHANGE THIS COMMENT!
 * Symbol: Ssa_KeyM_RoutineServices_Routine_SecOC_ECU_Shared_Secret_Encryption_doc
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
/*!
 * \spec
 *    requires $lengthOf(Date_and_Time) >= sizeof(Dcm_Data7ByteType);
 *    requires $lengthOf(Tick_Count) >= sizeof(Dcm_Data5ByteType);
 *    requires $lengthOf(Tick_Count_Offset) >= sizeof(Dcm_Data5ByteType);
 *    requires $lengthOf(Encrypted_Nonce_and_Shared_Secret) >= sizeof(Dcm_Data80ByteType);
 *    requires $lengthOf(Ephemeral_VSM_Public_Key) >= sizeof(Dcm_Data32ByteType);
 *    requires $lengthOf(Data_Signature_Out) >= sizeof(Dcm_Data64ByteType);
 *    requires $lengthOf(VSM_s_ECU_Certificate) >= sizeof(Dcm_Data1002ByteType);
 * \endspec
 */
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << End of documentation area >>                    DO NOT CHANGE THIS COMMENT!
 *********************************************************************************************************************/

FUNC(Std_ReturnType, Ssa_KeyM_CODE) Ssa_KeyM_RoutineServices_Routine_SecOC_ECU_Shared_Secret_Encryption(
  P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) Nonce,
  P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) Ephemeral_ECU_Public_Key,
  P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) Data_Signature_In,
  P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) Target_ECU_Certificate,
  Dcm_OpStatusType OpStatus,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) routineInfo,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) Verification_Result,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) Date_and_Time,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) Tick_Count,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) Tick_Count_Offset,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) Encrypted_Nonce_and_Shared_Secret,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) Ephemeral_VSM_Public_Key,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) Data_Signature_Out,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) VSM_s_ECU_Certificate,
  P2VAR(uint16, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) DataLength,
  P2VAR(Dcm_NegativeResponseCodeType, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) ErrorCode) /* PRQA S 0624, 3206 */ /* MD_Rte_0624, MD_Rte_3206 */
{
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << Start of runnable implementation >>             DO NOT CHANGE THIS COMMENT!
 * Symbol: Ssa_KeyM_RoutineServices_Routine_SecOC_ECU_Shared_Secret_Encryption (returns application error)
 *********************************************************************************************************************/
  Std_ReturnType retVal = RTE_E_RoutineServices_Routine_SecOC_ECU_Shared_Secret_Encryption_E_NOT_OK;

  /* ----- Development Error Checks ------------------------------------- */
# if (SSA_DEV_ERROR_DETECT == STD_ON)
  if ((Nonce == NULL_PTR)
    || (Ephemeral_ECU_Public_Key == NULL_PTR)
    || (Data_Signature_In == NULL_PTR)
    || (Target_ECU_Certificate == NULL_PTR)
    || (routineInfo == NULL_PTR)
    || (Verification_Result == NULL_PTR)
    || (Date_and_Time == NULL_PTR)
    || (Tick_Count == NULL_PTR)
    || (Tick_Count_Offset == NULL_PTR)
    || (Encrypted_Nonce_and_Shared_Secret == NULL_PTR)
    || (Ephemeral_VSM_Public_Key == NULL_PTR)
    || (Data_Signature_Out == NULL_PTR)
    || (VSM_s_ECU_Certificate == NULL_PTR)
    || (DataLength == NULL_PTR)
    || (ErrorCode == NULL_PTR))
  {
    /* retVal already set */
  }
  else
# endif /* SSA_DEV_ERROR_DETECT == STD_ON */
  {
    /* #10 Process the encryption of the car-specific secret and do not allow the usage of the standard shared secret. */
    retVal = KeyM_EncryptSharedSecret(
      SSA_DIAGNOSTIC_KEY_PAIR,
      Nonce,
      Ephemeral_ECU_Public_Key,
      Data_Signature_In,
      Target_ECU_Certificate,
      OpStatus,
      routineInfo,
      Verification_Result,
      Date_and_Time,
      Tick_Count,
      Tick_Count_Offset,
      Encrypted_Nonce_and_Shared_Secret,
      Ephemeral_VSM_Public_Key,
      Data_Signature_Out,
      VSM_s_ECU_Certificate,
      DataLength,
      ErrorCode,
      FALSE);

    /* Map return value. */
    switch (retVal)
    {
      case SSA_E_PENDING:
        retVal = RTE_E_RoutineServices_Trust_Model_SecOC_ECU_Shared_Secret_Encryption_DCM_E_PENDING;
        break;
      case E_OK:
        retVal = RTE_E_OK;
        break;
      default:
        retVal = RTE_E_RoutineServices_Trust_Model_SecOC_ECU_Shared_Secret_Encryption_E_NOT_OK;
        break;
    }
  }

  return retVal;
  /* PRQA S 6060 4 */ /* MD_SSA_STPAR */
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << End of runnable implementation >>               DO NOT CHANGE THIS COMMENT!
 *********************************************************************************************************************/
}

#endif

#if (SSA_ECU_TYPE == SSA_ECU_TYPE_VSM)

/**********************************************************************************************************************
 *
 * Runnable Entity Name: Ssa_KeyM_RoutineServices_Routine_SecOC_ECU_TickCount_Synchronization
 *
 *---------------------------------------------------------------------------------------------------------------------
 *
 * Executed if at least one of the following trigger conditions occurred:
 *   - triggered by server invocation for OperationPrototype <Start> of PortPrototype <RoutineServices_Routine_SecOC_ECU_TickCount_Synchronization>
 *
 **********************************************************************************************************************
 *
 * Client/Server Interfaces:
 * =========================
 *   Server Invocation:
 *   ------------------
 *   Std_ReturnType Rte_Call_CertP_Functions_Certificate_Parse(const uint8 *rawCertData, uint16 rawCertLength, CertP_ParsedCertStructureType *parsedCert)
 *     Argument rawCertData: uint8* is of type CertP_RawCertBufferType
 *     Synchronous Server Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_CertP_Functions_E_NOT_OK
 *   Std_ReturnType Rte_Call_CertP_Functions_Certificate_Verify(const uint8 *rawCertData, CertP_ParsedCertStructureType *parsedCert, const uint8 *rawCertIssuer, const CertP_ParsedCertStructureType *parsedCertIssuer, CertP_PkiRoleType expectedPkiRole)
 *     Argument rawCertData: uint8* is of type CertP_RawCertBufferType
 *     Argument rawCertIssuer: uint8* is of type CertP_RawCertBufferType
 *     Synchronous Server Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_CertP_Functions_E_NOT_OK, RTE_E_CertP_Functions_E_PENDING
 *   Std_ReturnType Rte_Call_RightsM_DiagnosticChannel_GetDiagnosticUserRole(RightsM_DiagnosticUserRoleType *userRole)
 *     Synchronous Server Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_RightsM_DiagnosticChannel_E_NOT_OK
 *   Std_ReturnType Rte_Call_RightsM_DiagnosticChannel_GetPostProductionStatus(Ssa_PostProductionStatusType *status)
 *     Synchronous Server Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_RightsM_DiagnosticChannel_E_NOT_OK
 *   Std_ReturnType Rte_Call_RightsM_EnhancedRights_VerifySubjectKeyIdentifier(const uint8 *subjectKeyIdentifier)
 *     Argument subjectKeyIdentifier: uint8* is of type Ssa_Data20ByteType
 *     Synchronous Server Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_RightsM_EnhancedRights_E_NOT_OK
 *   Std_ReturnType Rte_Call_SecLog_SuccessfulDiagServiceExecutionEvent_EcuSharedSecretEncryption_SuccessfulDiagServiceExecution(uint8 additionalInfo)
 *     Synchronous Server Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_SecLog_SuccessfulDiagServiceExecutionEvent_E_NOT_OK
 *   Std_ReturnType Rte_Call_SsaCdd_Csm_Hash(uint32 jobId, Crypto_OperationModeType operationMode, Ssa_ConstDataPtr dataBuffer, uint32 dataLength, Ssa_DataPtr resultBuffer, Ssa_LengthPtr resultLength)
 *     Synchronous Server Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_SsaCdd_CryptoInterface_E_NOT_OK
 *   Std_ReturnType Rte_Call_SsaCdd_Csm_SignatureGenerate(uint32 jobId, Crypto_OperationModeType operationMode, Ssa_ConstDataPtr dataBuffer, uint32 dataLength, Ssa_DataPtr resultBuffer, Ssa_LengthPtr resultLength)
 *     Synchronous Server Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_SsaCdd_CryptoInterface_E_NOT_OK
 *   Std_ReturnType Rte_Call_SsaCdd_Csm_SignatureVerify(uint32 jobId, Crypto_OperationModeType operationMode, Ssa_ConstDataPtr dataBuffer, uint32 dataLength, Ssa_ConstDataPtr compareBuffer, uint32 compareLength, Ssa_VerifyResultPtr resultBuffer)
 *     Synchronous Server Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_SsaCdd_CryptoInterface_E_NOT_OK
 *   Std_ReturnType Rte_Call_Ssa_KeyProc_PrepareKeyExchange(Ssa_OpStatusType opStatus, uint32 keyId)
 *     Synchronous Server Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_Ssa_KeyProc_E_NOT_OK, RTE_E_Ssa_KeyProc_E_PENDING
 *   Std_ReturnType Rte_Call_Ssa_KeyStorage_StorePermanently(Ssa_KeyStorageUseCaseType keyStorageUseCase, Ssa_KeyStorageTaskType keyStorageTask)
 *     Synchronous Server Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_Ssa_KeyStorage_E_NOT_OK, RTE_E_Ssa_KeyStorage_E_PENDING
 *   Std_ReturnType Rte_Call_TimeM_RealTime_Compare(const TimeM_DateTimeType *t1, TimeM_CompareOperatorType compareOp, const TimeM_DateTimeType *t2, boolean *result)
 *     Synchronous Server Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_TimeM_RealTime_E_NOT_OK
 *   Std_ReturnType Rte_Call_TimeM_RealTime_Get(TimeM_DateTimeType *realTime)
 *     Synchronous Server Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_TimeM_RealTime_E_NOT_OK
 *   Std_ReturnType Rte_Call_TimeM_TimeRawData_Get(uint8 *dateTimeOffset, uint8 *tickCountOffset, uint8 *tickCount)
 *     Argument dateTimeOffset: uint8* is of type Ssa_Data7ByteType
 *     Argument tickCountOffset: uint8* is of type Ssa_Data5ByteType
 *     Argument tickCount: uint8* is of type Ssa_Data5ByteType
 *     Synchronous Server Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_TimeM_TimeRawData_E_NOT_OK
 *
 * Service Calls:
 * ==============
 *   Service Invocation:
 *   -------------------
 *   Std_ReturnType Rte_Call_CsmJobKeyExchangeCalcPubVal_KeyExchangeCalcPubVal(uint32 key, Csm_DataPtr publicValuePtr, Csm_LengthPtr publicValueLengthPtr)
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_CsmJobKeyExchangeCalcPubVal_CSM_E_BUSY, RTE_E_CsmJobKeyExchangeCalcPubVal_CSM_E_KEY_EMPTY, RTE_E_CsmJobKeyExchangeCalcPubVal_CSM_E_SMALL_BUFFER, RTE_E_CsmJobKeyExchangeCalcPubVal_E_NOT_OK
 *   Std_ReturnType Rte_Call_CsmJobKeyExchangeCalcSecret_KeyExchangeCalcSecret(uint32 key, Csm_const_DataPtr partnerPublicValuePtr, uint32 partnerPublicValueLength)
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_CsmJobKeyExchangeCalcSecret_CSM_E_BUSY, RTE_E_CsmJobKeyExchangeCalcSecret_CSM_E_KEY_EMPTY, RTE_E_CsmJobKeyExchangeCalcSecret_CSM_E_SMALL_BUFFER, RTE_E_CsmJobKeyExchangeCalcSecret_E_NOT_OK
 *   Std_ReturnType Rte_Call_CsmSymAES128Encrypt_Encrypt(const uint8 *dataBuffer, uint32 dataLength, uint8 *resultBuffer, uint32 *resultLength)
 *     Argument dataBuffer: uint8* is of type Csm_EncryptDataType_AES128Encrypt
 *     Argument resultBuffer: uint8* is of type Csm_EncryptResultType_AES128Encrypt
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_CsmEncrypt_AES128Encrypt_CSM_E_BUSY, RTE_E_CsmEncrypt_AES128Encrypt_CSM_E_KEY_EMPTY, RTE_E_CsmEncrypt_AES128Encrypt_CSM_E_KEY_NOT_VALID, RTE_E_CsmEncrypt_AES128Encrypt_CSM_E_KEY_SIZE_MISMATCH, RTE_E_CsmEncrypt_AES128Encrypt_CSM_E_SMALL_BUFFER, RTE_E_CsmEncrypt_AES128Encrypt_E_NOT_OK
 *   Std_ReturnType Rte_Call_Key_AesRamKey_KeyElementSet(uint32 keyElementId, const uint8 *keyPtr, uint32 keyLength)
 *     Argument keyPtr: uint8* is of type Csm_KeyDataType_Ssa_AesRamKey
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_CsmKeyManagement_Ssa_AesRamKey_CSM_E_BUSY, RTE_E_CsmKeyManagement_Ssa_AesRamKey_CSM_E_KEY_NOT_AVAILABLE, RTE_E_CsmKeyManagement_Ssa_AesRamKey_CSM_E_KEY_SIZE_MISMATCH, RTE_E_CsmKeyManagement_Ssa_AesRamKey_CSM_E_KEY_WRITE_FAIL, RTE_E_CsmKeyManagement_Ssa_AesRamKey_CSM_E_SMALL_BUFFER, RTE_E_CsmKeyManagement_Ssa_AesRamKey_E_NOT_OK
 *   Std_ReturnType Rte_Call_Key_AesRamKey_KeySetValid(void)
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_CsmKeyManagement_Ssa_AesRamKey_CSM_E_BUSY, RTE_E_CsmKeyManagement_Ssa_AesRamKey_E_NOT_OK
 *   Std_ReturnType Rte_Call_Key_BackendCert_KeyElementGet(uint32 keyElementId, uint8 *keyPtr, uint32 *keyLength)
 *     Argument keyPtr: uint8* is of type Csm_KeyDataType_Ssa_BackendCert
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_CsmKeyManagement_Ssa_BackendCert_CSM_E_BUSY, RTE_E_CsmKeyManagement_Ssa_BackendCert_CSM_E_KEY_EMPTY, RTE_E_CsmKeyManagement_Ssa_BackendCert_CSM_E_KEY_NOT_AVAILABLE, RTE_E_CsmKeyManagement_Ssa_BackendCert_CSM_E_KEY_READ_FAIL, RTE_E_CsmKeyManagement_Ssa_BackendCert_CSM_E_SMALL_BUFFER, RTE_E_CsmKeyManagement_Ssa_BackendCert_E_NOT_OK
 *   Std_ReturnType Rte_Call_Key_EcuCert_KeyElementGet(uint32 keyElementId, uint8 *keyPtr, uint32 *keyLength)
 *     Argument keyPtr: uint8* is of type Csm_KeyDataType_Ssa_EcuCert
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_CsmKeyManagement_Ssa_EcuCert_CSM_E_BUSY, RTE_E_CsmKeyManagement_Ssa_EcuCert_CSM_E_KEY_EMPTY, RTE_E_CsmKeyManagement_Ssa_EcuCert_CSM_E_KEY_NOT_AVAILABLE, RTE_E_CsmKeyManagement_Ssa_EcuCert_CSM_E_KEY_READ_FAIL, RTE_E_CsmKeyManagement_Ssa_EcuCert_CSM_E_SMALL_BUFFER, RTE_E_CsmKeyManagement_Ssa_EcuCert_E_NOT_OK
 *   Std_ReturnType Rte_Call_Key_SharedSecret_KeyElementGet(uint32 keyElementId, uint8 *keyPtr, uint32 *keyLength)
 *     Argument keyPtr: uint8* is of type Csm_KeyDataType_Ssa_SharedSecret
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_CsmKeyManagement_Ssa_SharedSecret_CSM_E_BUSY, RTE_E_CsmKeyManagement_Ssa_SharedSecret_CSM_E_KEY_EMPTY, RTE_E_CsmKeyManagement_Ssa_SharedSecret_CSM_E_KEY_NOT_AVAILABLE, RTE_E_CsmKeyManagement_Ssa_SharedSecret_CSM_E_KEY_READ_FAIL, RTE_E_CsmKeyManagement_Ssa_SharedSecret_CSM_E_SMALL_BUFFER, RTE_E_CsmKeyManagement_Ssa_SharedSecret_E_NOT_OK
 *   Std_ReturnType Rte_Call_Key_SharedSecretKeyExchange_KeyElementGet(uint32 keyElementId, uint8 *keyPtr, uint32 *keyLength)
 *     Argument keyPtr: uint8* is of type Csm_KeyDataType_Ssa_SharedSecretKeyExchange
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_CsmKeyManagement_Ssa_SharedSecretKeyExchange_CSM_E_BUSY, RTE_E_CsmKeyManagement_Ssa_SharedSecretKeyExchange_CSM_E_KEY_EMPTY, RTE_E_CsmKeyManagement_Ssa_SharedSecretKeyExchange_CSM_E_KEY_NOT_AVAILABLE, RTE_E_CsmKeyManagement_Ssa_SharedSecretKeyExchange_CSM_E_KEY_READ_FAIL, RTE_E_CsmKeyManagement_Ssa_SharedSecretKeyExchange_CSM_E_SMALL_BUFFER, RTE_E_CsmKeyManagement_Ssa_SharedSecretKeyExchange_E_NOT_OK
 *   Std_ReturnType Rte_Call_Key_SharedSecretKeyExchange_KeyElementSet(uint32 keyElementId, const uint8 *keyPtr, uint32 keyLength)
 *     Argument keyPtr: uint8* is of type Csm_KeyDataType_Ssa_SharedSecretKeyExchange
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_CsmKeyManagement_Ssa_SharedSecretKeyExchange_CSM_E_BUSY, RTE_E_CsmKeyManagement_Ssa_SharedSecretKeyExchange_CSM_E_KEY_NOT_AVAILABLE, RTE_E_CsmKeyManagement_Ssa_SharedSecretKeyExchange_CSM_E_KEY_SIZE_MISMATCH, RTE_E_CsmKeyManagement_Ssa_SharedSecretKeyExchange_CSM_E_KEY_WRITE_FAIL, RTE_E_CsmKeyManagement_Ssa_SharedSecretKeyExchange_CSM_E_SMALL_BUFFER, RTE_E_CsmKeyManagement_Ssa_SharedSecretKeyExchange_E_NOT_OK
 *   Std_ReturnType Rte_Call_Key_SharedSecretKeyExchange_KeyExchangeCalcPubVal(uint8 *publicValuePtr, uint32 *publicValueLengthPtr)
 *     Argument publicValuePtr: uint8* is of type Csm_PublicValueDataType_Ssa_SharedSecretKeyExchange
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_CsmKeyManagement_Ssa_SharedSecretKeyExchange_CSM_E_BUSY, RTE_E_CsmKeyManagement_Ssa_SharedSecretKeyExchange_CSM_E_KEY_EMPTY, RTE_E_CsmKeyManagement_Ssa_SharedSecretKeyExchange_CSM_E_SMALL_BUFFER, RTE_E_CsmKeyManagement_Ssa_SharedSecretKeyExchange_E_NOT_OK
 *   Std_ReturnType Rte_Call_Key_SharedSecretKeyExchange_KeyExchangeCalcSecret(const uint8 *partnerPublicValuePtr, uint32 partnerPublicValueLength)
 *     Argument partnerPublicValuePtr: uint8* is of type Csm_PublicValueDataType_Ssa_SharedSecretKeyExchange
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_CsmKeyManagement_Ssa_SharedSecretKeyExchange_CSM_E_BUSY, RTE_E_CsmKeyManagement_Ssa_SharedSecretKeyExchange_CSM_E_KEY_EMPTY, RTE_E_CsmKeyManagement_Ssa_SharedSecretKeyExchange_CSM_E_SMALL_BUFFER, RTE_E_CsmKeyManagement_Ssa_SharedSecretKeyExchange_E_NOT_OK
 *   Std_ReturnType Rte_Call_Key_SharedSecretKeyExchange_KeySetValid(void)
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_CsmKeyManagement_Ssa_SharedSecretKeyExchange_CSM_E_BUSY, RTE_E_CsmKeyManagement_Ssa_SharedSecretKeyExchange_E_NOT_OK
 *   Std_ReturnType Rte_Call_Key_SignatureRamKey_KeyElementSet(uint32 keyElementId, const uint8 *keyPtr, uint32 keyLength)
 *     Argument keyPtr: uint8* is of type Csm_KeyDataType_Ssa_SignatureRamKey
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_CsmKeyManagement_Ssa_SignatureRamKey_CSM_E_BUSY, RTE_E_CsmKeyManagement_Ssa_SignatureRamKey_CSM_E_KEY_NOT_AVAILABLE, RTE_E_CsmKeyManagement_Ssa_SignatureRamKey_CSM_E_KEY_SIZE_MISMATCH, RTE_E_CsmKeyManagement_Ssa_SignatureRamKey_CSM_E_KEY_WRITE_FAIL, RTE_E_CsmKeyManagement_Ssa_SignatureRamKey_CSM_E_SMALL_BUFFER, RTE_E_CsmKeyManagement_Ssa_SignatureRamKey_E_NOT_OK
 *   Std_ReturnType Rte_Call_Key_SignatureRamKey_KeySetValid(void)
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_CsmKeyManagement_Ssa_SignatureRamKey_CSM_E_BUSY, RTE_E_CsmKeyManagement_Ssa_SignatureRamKey_E_NOT_OK
 *
 **********************************************************************************************************************
 *
 * Runnable prototype:
 * ===================
 *   Std_ReturnType Ssa_KeyM_RoutineServices_Routine_SecOC_ECU_TickCount_Synchronization(const uint8 *Nonce, const uint8 *Ephemeral_ECU_Public_Key, const uint8 *Data_Signature_In, const uint8 *Target_ECU_Certificate, Dcm_OpStatusType OpStatus, uint8 *routineInfo, uint8 *Verification_Result, uint8 *Date_and_Time, uint8 *Tick_Count, uint8 *Tick_Count_Offset, uint8 *Encrypted_Nonce_and_Shared_Secret, uint8 *Ephemeral_VSM_Public_Key, uint8 *Data_Signature_Out, uint8 *VSM_s_ECU_Certificate, uint16 *DataLength, Dcm_NegativeResponseCodeType *ErrorCode)
 *     Argument Nonce: uint8* is of type Dcm_Data32ByteType
 *     Argument Ephemeral_ECU_Public_Key: uint8* is of type Dcm_Data32ByteType
 *     Argument Data_Signature_In: uint8* is of type Dcm_Data64ByteType
 *     Argument Target_ECU_Certificate: uint8* is of type Dcm_Data1002ByteType
 *     Argument Date_and_Time: uint8* is of type Dcm_Data7ByteType
 *     Argument Tick_Count: uint8* is of type Dcm_Data5ByteType
 *     Argument Tick_Count_Offset: uint8* is of type Dcm_Data5ByteType
 *     Argument Encrypted_Nonce_and_Shared_Secret: uint8* is of type Dcm_Data80ByteType
 *     Argument Ephemeral_VSM_Public_Key: uint8* is of type Dcm_Data32ByteType
 *     Argument Data_Signature_Out: uint8* is of type Dcm_Data64ByteType
 *     Argument VSM_s_ECU_Certificate: uint8* is of type Dcm_Data1002ByteType
 *
 **********************************************************************************************************************
 *
 * Available Application Errors:
 * =============================
 *   RTE_E_RoutineServices_Routine_SecOC_ECU_TickCount_Synchronization_DCM_E_FORCE_RCRRP
 *   RTE_E_RoutineServices_Routine_SecOC_ECU_TickCount_Synchronization_DCM_E_PENDING
 *   RTE_E_RoutineServices_Routine_SecOC_ECU_TickCount_Synchronization_E_NOT_OK
 *
 *********************************************************************************************************************/
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << Start of documentation area >>                  DO NOT CHANGE THIS COMMENT!
 * Symbol: Ssa_KeyM_RoutineServices_Routine_SecOC_ECU_TickCount_Synchronization_doc
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
/*!
 * \spec
 *    requires $lengthOf(Date_and_Time) >= sizeof(Dcm_Data7ByteType);
 *    requires $lengthOf(Tick_Count) >= sizeof(Dcm_Data5ByteType);
 *    requires $lengthOf(Tick_Count_Offset) >= sizeof(Dcm_Data5ByteType);
 *    requires $lengthOf(Encrypted_Nonce_and_Shared_Secret) >= sizeof(Dcm_Data80ByteType);
 *    requires $lengthOf(Ephemeral_VSM_Public_Key) >= sizeof(Dcm_Data32ByteType);
 *    requires $lengthOf(Data_Signature_Out) >= sizeof(Dcm_Data64ByteType);
 *    requires $lengthOf(VSM_s_ECU_Certificate) >= sizeof(Dcm_Data1002ByteType);
 * \endspec
 */
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << End of documentation area >>                    DO NOT CHANGE THIS COMMENT!
 *********************************************************************************************************************/

FUNC(Std_ReturnType, Ssa_KeyM_CODE) Ssa_KeyM_RoutineServices_Routine_SecOC_ECU_TickCount_Synchronization(
  P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) Nonce,
  P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) Ephemeral_ECU_Public_Key,
  P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) Data_Signature_In,
  P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) Target_ECU_Certificate,
  Dcm_OpStatusType OpStatus,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) routineInfo,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) Verification_Result,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) Date_and_Time,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) Tick_Count,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) Tick_Count_Offset,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) Encrypted_Nonce_and_Shared_Secret,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) Ephemeral_VSM_Public_Key,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) Data_Signature_Out,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) VSM_s_ECU_Certificate,
  P2VAR(uint16, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) DataLength,
  P2VAR(Dcm_NegativeResponseCodeType, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) ErrorCode) /* PRQA S 0624, 3206 */ /* MD_Rte_0624, MD_Rte_3206 */
{
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << Start of runnable implementation >>             DO NOT CHANGE THIS COMMENT!
 * Symbol: Ssa_KeyM_RoutineServices_Routine_SecOC_ECU_TickCount_Synchronization (returns application error)
 *********************************************************************************************************************/
  Std_ReturnType retVal = RTE_E_RoutineServices_Routine_SecOC_ECU_TickCount_Synchronization_E_NOT_OK;

  /* ----- Development Error Checks ------------------------------------- */
# if (SSA_DEV_ERROR_DETECT == STD_ON)
  if ((Nonce == NULL_PTR)
    || (Ephemeral_ECU_Public_Key == NULL_PTR)
    || (Data_Signature_In == NULL_PTR)
    || (Target_ECU_Certificate == NULL_PTR)
    || (routineInfo == NULL_PTR)
    || (Verification_Result == NULL_PTR)
    || (Date_and_Time == NULL_PTR)
    || (Tick_Count == NULL_PTR)
    || (Tick_Count_Offset == NULL_PTR)
    || (Encrypted_Nonce_and_Shared_Secret == NULL_PTR)
    || (Ephemeral_VSM_Public_Key == NULL_PTR)
    || (Data_Signature_Out == NULL_PTR)
    || (VSM_s_ECU_Certificate == NULL_PTR)
    || (DataLength == NULL_PTR)
    || (ErrorCode == NULL_PTR))
  {
    /* retVal already set */
  }
  else
# endif /* SSA_DEV_ERROR_DETECT == STD_ON */
  {
    /* #10 Process the encryption of the car-specific secret and do allow the usage of the standard shared secret. */
    retVal = KeyM_EncryptSharedSecret(
      SSA_DIAGNOSTIC_KEY_PAIR,
      Nonce,
      Ephemeral_ECU_Public_Key,
      Data_Signature_In,
      Target_ECU_Certificate,
      OpStatus,
      routineInfo,
      Verification_Result,
      Date_and_Time,
      Tick_Count,
      Tick_Count_Offset,
      Encrypted_Nonce_and_Shared_Secret,
      Ephemeral_VSM_Public_Key,
      Data_Signature_Out,
      VSM_s_ECU_Certificate,
      DataLength,
      ErrorCode,
      TRUE);

    /* Map return value. */
    switch (retVal)
    {
      case SSA_E_PENDING:
        retVal = RTE_E_RoutineServices_Trust_Model_SecOC_ECU_Shared_Secret_Encryption_DCM_E_PENDING;
        break;
      case E_OK:
        retVal = RTE_E_OK;
        break;
      default:
        retVal = RTE_E_RoutineServices_Trust_Model_SecOC_ECU_Shared_Secret_Encryption_E_NOT_OK;
        break;
    }
  }

  return retVal;
  /* PRQA S 6060 4 */ /* MD_SSA_STPAR */
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << End of runnable implementation >>               DO NOT CHANGE THIS COMMENT!
 *********************************************************************************************************************/
}

#endif

#if (SSA_ECU_TYPE == SSA_ECU_TYPE_VSM)

/**********************************************************************************************************************
 *
 * Runnable Entity Name: Ssa_KeyM_RoutineServices_Routine_SecOC_VSM_Derive_Symmetric_Keys
 *
 *---------------------------------------------------------------------------------------------------------------------
 *
 * Executed if at least one of the following trigger conditions occurred:
 *   - triggered by server invocation for OperationPrototype <Start> of PortPrototype <RoutineServices_Routine_SecOC_VSM_Derive_Symmetric_Keys>
 *
 **********************************************************************************************************************
 *
 * Client/Server Interfaces:
 * =========================
 *   Server Invocation:
 *   ------------------
 *   Std_ReturnType Rte_Call_SecLog_SuccessfulDiagServiceExecutionEvent_VsmDeriveSymmetricKeys_SuccessfulDiagServiceExecution(uint8 additionalInfo)
 *     Synchronous Server Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_SecLog_SuccessfulDiagServiceExecutionEvent_E_NOT_OK
 *
 * Service Calls:
 * ==============
 *   Service Invocation:
 *   -------------------
 *   Std_ReturnType Rte_Call_Key_SharedSecret_KeyElementGet(uint32 keyElementId, uint8 *keyPtr, uint32 *keyLength)
 *     Argument keyPtr: uint8* is of type Csm_KeyDataType_Ssa_SharedSecret
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_CsmKeyManagement_Ssa_SharedSecret_CSM_E_BUSY, RTE_E_CsmKeyManagement_Ssa_SharedSecret_CSM_E_KEY_EMPTY, RTE_E_CsmKeyManagement_Ssa_SharedSecret_CSM_E_KEY_NOT_AVAILABLE, RTE_E_CsmKeyManagement_Ssa_SharedSecret_CSM_E_KEY_READ_FAIL, RTE_E_CsmKeyManagement_Ssa_SharedSecret_CSM_E_SMALL_BUFFER, RTE_E_CsmKeyManagement_Ssa_SharedSecret_E_NOT_OK
 *
 * Exclusive Area Access:
 * ======================
 *   void Rte_Enter_KeyM_ExclusiveArea(void)
 *   void Rte_Exit_KeyM_ExclusiveArea(void)
 *
 **********************************************************************************************************************
 *
 * Runnable prototype:
 * ===================
 *   Std_ReturnType Ssa_KeyM_RoutineServices_Routine_SecOC_VSM_Derive_Symmetric_Keys(Dcm_OpStatusType OpStatus, uint8 *routineInfo, Dcm_NegativeResponseCodeType *ErrorCode)
 *
 **********************************************************************************************************************
 *
 * Available Application Errors:
 * =============================
 *   RTE_E_RoutineServices_Routine_SecOC_VSM_Derive_Symmetric_Keys_DCM_E_FORCE_RCRRP
 *   RTE_E_RoutineServices_Routine_SecOC_VSM_Derive_Symmetric_Keys_DCM_E_PENDING
 *   RTE_E_RoutineServices_Routine_SecOC_VSM_Derive_Symmetric_Keys_E_NOT_OK
 *
 *********************************************************************************************************************/
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << Start of documentation area >>                  DO NOT CHANGE THIS COMMENT!
 * Symbol: Ssa_KeyM_RoutineServices_Routine_SecOC_VSM_Derive_Symmetric_Keys_doc
 *********************************************************************************************************************/
 /*!
  * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
  */
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << End of documentation area >>                    DO NOT CHANGE THIS COMMENT!
 *********************************************************************************************************************/

FUNC(Std_ReturnType, Ssa_KeyM_CODE) Ssa_KeyM_RoutineServices_Routine_SecOC_VSM_Derive_Symmetric_Keys(
  Dcm_OpStatusType OpStatus,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) routineInfo,
  P2VAR(Dcm_NegativeResponseCodeType, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) ErrorCode) /* PRQA S 0624, 3206 */ /* MD_Rte_0624, MD_Rte_3206 */
{
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << Start of runnable implementation >>             DO NOT CHANGE THIS COMMENT!
 * Symbol: Ssa_KeyM_RoutineServices_Routine_SecOC_VSM_Derive_Symmetric_Keys (returns application error)
 *********************************************************************************************************************/
  Std_ReturnType retVal = RTE_E_RoutineServices_Routine_SecOC_VSM_Derive_Symmetric_Keys_E_NOT_OK;

  /* ----- Development Error Checks ------------------------------------- */
# if (SSA_DEV_ERROR_DETECT == STD_ON)
  if ((routineInfo == NULL_PTR) || (ErrorCode == NULL_PTR))
  {
    /* retVal already set */
  }
  else
# endif /* SSA_DEV_ERROR_DETECT == STD_ON */
  {
    retVal = RTE_E_RoutineServices_Routine_SecOC_VSM_Derive_Symmetric_Keys_DCM_E_PENDING;
    /* #10 Handle the following states:
     * KEYM_ROUTINE_SECOC_VSM_DERIVE_SYM_KEYS_STATE_IDLE,
     * KEYM_ROUTINE_SECOC_VSM_DERIVE_SYM_KEYS_STATE_INIT and
     * KEYM_ROUTINE_SECOC_VSM_DERIVE_SYM_KEYS_STATE_WAIT. */

     /* #20 Operation status must be "initial" or "pending". */
    if ((OpStatus == DCM_PENDING) || (OpStatus == DCM_INITIAL))
    {
      /* #30 In state "idle" get the stored, car specific secret and change to state "init" afterwards. */
      if (KeyM_DiagProc.state == KEYM_ROUTINE_SECOC_VSM_DERIVE_SYM_KEYS_STATE_IDLE)
      {
        uint32 sharedSecretLength = SSA_SIZEOF_SECRET;

        retVal = Rte_Call_Key_SharedSecret_KeyElementGet(SSA_KE_MAC_KEY, KeyM_CarSpecificSecret, &sharedSecretLength);
        if ((retVal != E_OK) || (sharedSecretLength != SSA_SIZEOF_SECRET))
        {
          retVal = RTE_E_RoutineServices_Routine_SecOC_VSM_Derive_Symmetric_Keys_E_NOT_OK;
        }
        else
        {
          retVal = RTE_E_RoutineServices_Routine_SecOC_VSM_Derive_Symmetric_Keys_DCM_E_PENDING;
          KeyM_DiagProc.state = KEYM_ROUTINE_SECOC_VSM_DERIVE_SYM_KEYS_STATE_INIT;
        }
      }
      /* #40 Else, in state "init" initialize the main loop processing used for derivation of the SecOc keys
       * and change to "wait". */
      else if (KeyM_DiagProc.state == KEYM_ROUTINE_SECOC_VSM_DERIVE_SYM_KEYS_STATE_INIT)
      {
        if (KeyM_GetMainLoopStateLock() == TRUE)
        {
          KeyM_MainLoopProc.conf = KEY_MAINLOOP_PROC_CONF_COMPLETE;
          KeyM_MainLoopProc.result = E_OK;
          KeyM_MainLoopProc.state = KEYM_GENERATE_SYM_KEYS_STATE_LOOP_OVER_IDS;

          KeyM_DiagProc.state = KEYM_ROUTINE_SECOC_VSM_DERIVE_SYM_KEYS_STATE_WAIT;
        }
      }
      /* #50 Else (state must be "wait") waiting for the main loop processing getting finished. When finished
       * and check its result and change to state "idle". */
      else
      {
        if (KeyM_IsMainloopStateIdle())
        {
          retVal = (KeyM_MainLoopProc.result == E_OK) ? RTE_E_OK : RTE_E_RoutineServices_Routine_SecOC_VSM_Derive_Symmetric_Keys_E_NOT_OK;
          KeyM_DiagProc.state = KEYM_ROUTINE_SECOC_VSM_DERIVE_SYM_KEYS_STATE_IDLE;
        }
      }
    }

    /* #60 Check that the service is finished. */
    if (retVal != RTE_E_RoutineServices_Routine_SecOC_VSM_Derive_Symmetric_Keys_DCM_E_PENDING)
    {
      *routineInfo = SSA_ROUTINE_INFO_SUCCESFULLY_COMPLETED;
      if (retVal == E_OK)
      {
        /* #70 If no error occurred write the security log for event
         * "successful diagnostic service execution" for use case "SecOC VSM Derive Symmetric Keys"
         * with additional information 0xFF. */
        (void)Rte_Call_SecLog_SuccessfulDiagServiceExecutionEvent_VsmDeriveSymmetricKeys_SuccessfulDiagServiceExecution((uint8)0xFFu);

        /* Set positive response code */
        *ErrorCode = DCM_E_POSITIVERESPONSE;
      }
      else
      {
        /* Set negative response code */
        *ErrorCode = DCM_E_GENERALREJECT;
      }
    }
  }

  return retVal;
  /* PRQA S 6030, 6080 4 */ /* MD_MSR_STCYC, MD_MSR_STMIF */
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << End of runnable implementation >>               DO NOT CHANGE THIS COMMENT!
 *********************************************************************************************************************/
}

#endif

#if (SSA_ECU_TYPE == SSA_ECU_TYPE_VSM)

/**********************************************************************************************************************
 *
 * Runnable Entity Name: Ssa_KeyM_RoutineServices_Routine_SecOC_VSM_Renew_Shared_Secret
 *
 *---------------------------------------------------------------------------------------------------------------------
 *
 * Executed if at least one of the following trigger conditions occurred:
 *   - triggered by server invocation for OperationPrototype <Start> of PortPrototype <RoutineServices_Routine_SecOC_VSM_Renew_Shared_Secret>
 *
 **********************************************************************************************************************
 *
 * Client/Server Interfaces:
 * =========================
 *   Server Invocation:
 *   ------------------
 *   Std_ReturnType Rte_Call_SecLog_SuccessfulDiagServiceExecutionEvent_VsmRenewSharedSecret_SuccessfulDiagServiceExecution(uint8 additionalInfo)
 *     Synchronous Server Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_SecLog_SuccessfulDiagServiceExecutionEvent_E_NOT_OK
 *
 * Service Calls:
 * ==============
 *   Service Invocation:
 *   -------------------
 *   Std_ReturnType Rte_Call_CsmRandomGenerate_RandomGenerate(uint8 *resultBuffer, uint32 *resultLength)
 *     Argument resultBuffer: uint8* is of type Csm_RandomGenerateResultType_Random
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_CsmRandomGenerate_Random_CSM_E_BUSY, RTE_E_CsmRandomGenerate_Random_CSM_E_ENTROPY_EXHAUSTION, RTE_E_CsmRandomGenerate_Random_E_NOT_OK
 *   Std_ReturnType Rte_Call_Key_SharedSecret_KeyElementSet(uint32 keyElementId, const uint8 *keyPtr, uint32 keyLength)
 *     Argument keyPtr: uint8* is of type Csm_KeyDataType_Ssa_SharedSecret
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_CsmKeyManagement_Ssa_SharedSecret_CSM_E_BUSY, RTE_E_CsmKeyManagement_Ssa_SharedSecret_CSM_E_KEY_NOT_AVAILABLE, RTE_E_CsmKeyManagement_Ssa_SharedSecret_CSM_E_KEY_SIZE_MISMATCH, RTE_E_CsmKeyManagement_Ssa_SharedSecret_CSM_E_KEY_WRITE_FAIL, RTE_E_CsmKeyManagement_Ssa_SharedSecret_CSM_E_SMALL_BUFFER, RTE_E_CsmKeyManagement_Ssa_SharedSecret_E_NOT_OK
 *   Std_ReturnType Rte_Call_Key_SharedSecret_KeySetValid(void)
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_CsmKeyManagement_Ssa_SharedSecret_CSM_E_BUSY, RTE_E_CsmKeyManagement_Ssa_SharedSecret_E_NOT_OK
 *
 * Exclusive Area Access:
 * ======================
 *   void Rte_Enter_KeyM_ExclusiveArea(void)
 *   void Rte_Exit_KeyM_ExclusiveArea(void)
 *
 **********************************************************************************************************************
 *
 * Runnable prototype:
 * ===================
 *   Std_ReturnType Ssa_KeyM_RoutineServices_Routine_SecOC_VSM_Renew_Shared_Secret(Dcm_OpStatusType OpStatus, uint8 *routineInfo, Dcm_NegativeResponseCodeType *ErrorCode)
 *
 **********************************************************************************************************************
 *
 * Available Application Errors:
 * =============================
 *   RTE_E_RoutineServices_Routine_SecOC_VSM_Renew_Shared_Secret_DCM_E_FORCE_RCRRP
 *   RTE_E_RoutineServices_Routine_SecOC_VSM_Renew_Shared_Secret_DCM_E_PENDING
 *   RTE_E_RoutineServices_Routine_SecOC_VSM_Renew_Shared_Secret_E_NOT_OK
 *
 *********************************************************************************************************************/
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << Start of documentation area >>                  DO NOT CHANGE THIS COMMENT!
 * Symbol: Ssa_KeyM_RoutineServices_Routine_SecOC_VSM_Renew_Shared_Secret_doc
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << End of documentation area >>                    DO NOT CHANGE THIS COMMENT!
 *********************************************************************************************************************/

FUNC(Std_ReturnType, Ssa_KeyM_CODE) Ssa_KeyM_RoutineServices_Routine_SecOC_VSM_Renew_Shared_Secret(
  Dcm_OpStatusType OpStatus,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) routineInfo,
  P2VAR(Dcm_NegativeResponseCodeType, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) ErrorCode) /* PRQA S 0624, 3206 */ /* MD_Rte_0624, MD_Rte_3206 */
{
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << Start of runnable implementation >>             DO NOT CHANGE THIS COMMENT!
 * Symbol: Ssa_KeyM_RoutineServices_Routine_SecOC_VSM_Renew_Shared_Secret (returns application error)
 *********************************************************************************************************************/

  Std_ReturnType retVal = RTE_E_RoutineServices_Routine_SecOC_VSM_Renew_Shared_Secret_E_NOT_OK;

  /* ----- Development Error Checks ------------------------------------- */
# if (SSA_DEV_ERROR_DETECT == STD_ON)
  if ((routineInfo == NULL_PTR) || (ErrorCode == NULL_PTR))
  {
    /* retVal already set */
  }
  else
# endif /* SSA_DEV_ERROR_DETECT == STD_ON */
  {
    retVal = RTE_E_RoutineServices_Routine_SecOC_VSM_Renew_Shared_Secret_DCM_E_PENDING;

    /* #10 Handle the following states:
     * KEYM_ROUTINE_SECOC_VSM_RENEW_SHARED_SECRET_STATE_IDLE,
     * KEYM_ROUTINE_SECOC_VSM_RENEW_SHARED_SECRET_STATE_INIT and
     * KEYM_ROUTINE_SECOC_VSM_RENEW_SHARED_SECRET_STATE_WAIT. */

     /* #20 Operation status must be "initial" or "pending". */
    if ((OpStatus == DCM_PENDING) || (OpStatus == DCM_INITIAL))
    {
      /* #30 In state "idle" generate a new car-specific secret. */
      if (KeyM_DiagProc.state == KEYM_ROUTINE_SECOC_VSM_RENEW_SHARED_SECRET_STATE_IDLE)
      {
        /* #40 Generate random data for the new car-specific secret. */
        retVal = KeyM_CsmRandomGenerate(
          SSA_SIZEOF_SECRET, KeyM_CarSpecificSecret);

        if (retVal == SSA_E_PENDING)
        {
          /* remain in current state */
          retVal = RTE_E_RoutineServices_Routine_SecOC_VSM_Renew_Shared_Secret_DCM_E_PENDING;
        }
        else if (retVal != E_OK)
        {
          retVal = RTE_E_RoutineServices_Routine_SecOC_VSM_Renew_Shared_Secret_E_NOT_OK;
        }
        else
        {
          /* #50 Store the generated secret Its hash will be set in the following state. Not until then
           *     both elements are supposed to be stored during execution of callout function StorePermanently. */
          retVal = Rte_Call_Key_SharedSecret_KeyElementSet(SSA_KE_MAC_KEY, KeyM_CarSpecificSecret, SSA_SIZEOF_SECRET);
          retVal |= Rte_Call_Key_SharedSecret_KeySetValid();
          if (retVal == RTE_E_OK)
          {
            /* #60 Change to state "init". */
            KeyM_DiagProc.state = KEYM_ROUTINE_SECOC_VSM_RENEW_SHARED_SECRET_STATE_INIT;
            retVal = RTE_E_RoutineServices_Routine_SecOC_VSM_Renew_Shared_Secret_DCM_E_PENDING;
          }
          else
          {
            /* remain in current state */
            retVal = RTE_E_RoutineServices_Routine_SecOC_VSM_Renew_Shared_Secret_E_NOT_OK;
          }
        }
      }
      /* #70 Else, in state "init" initialize the main loop processing used for instantiating the random number generator
       * and for hashing and storing the car-specific secret. Then change to state "wait". */
      else if (KeyM_DiagProc.state == KEYM_ROUTINE_SECOC_VSM_RENEW_SHARED_SECRET_STATE_INIT)
      {
        if (KeyM_GetMainLoopStateLock() == TRUE)
        {
          KeyM_MainLoopProc.conf = KEY_MAINLOOP_PROC_CONF_COMPLETE | KEY_MAINLOOP_PROC_CONF_NO_KEY_DERIVATION;
          KeyM_MainLoopProc.result = E_OK;
          KeyM_MainLoopProc.state = KEYM_GENERATE_SYM_KEYS_STATE_HASH_SECRET;
          KeyM_DiagProc.state = KEYM_ROUTINE_SECOC_VSM_RENEW_SHARED_SECRET_STATE_WAIT;
        }
      }
      /* #80 Else (state must be "wait") waiting for the main loop processing getting finished. When finished
       * and check its result and change to state "idle". */
      else
      {
        if (KeyM_IsMainloopStateIdle())
        {
          retVal = (KeyM_MainLoopProc.result == E_OK) ? RTE_E_OK : RTE_E_RoutineServices_Routine_SecOC_VSM_Derive_Symmetric_Keys_E_NOT_OK;
          KeyM_DiagProc.state = KEYM_ROUTINE_SECOC_VSM_RENEW_SHARED_SECRET_STATE_IDLE;
        }
      }
    }

    /* #90 Check that the service is finished. */
    if (retVal != RTE_E_RoutineServices_Routine_SecOC_VSM_Renew_Shared_Secret_DCM_E_PENDING)
    {
      if (retVal != RTE_E_OK)
      {
        *ErrorCode = DCM_E_GENERALREJECT;
        retVal = RTE_E_RoutineServices_Routine_SecOC_VSM_Renew_Shared_Secret_E_NOT_OK;
      }
      else
      {
        *ErrorCode = DCM_E_POSITIVERESPONSE;
        /* #100 If no error occurred write the security log for event
         * "successful diagnostic service execution" for use case "SecOC VSM Renew Shared Secret"
         * with additional information 0xFF. */
        (void)Rte_Call_SecLog_SuccessfulDiagServiceExecutionEvent_VsmRenewSharedSecret_SuccessfulDiagServiceExecution((uint8)0xFFu);
      }
      *routineInfo = SSA_ROUTINE_INFO_SUCCESFULLY_COMPLETED;
    }
  }

  return retVal;
  /* PRQA S 6030, 6080 4 */ /* MD_MSR_STCYC, MD_MSR_STMIF */
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << End of runnable implementation >>               DO NOT CHANGE THIS COMMENT!
 *********************************************************************************************************************/
}

#endif

#if (SSA_ECU_TYPE == SSA_ECU_TYPE_VSM)

/**********************************************************************************************************************
 *
 * Runnable Entity Name: Ssa_KeyM_RoutineServices_Routine_SecOC_Vehicle_Shared_Secret_Distribution
 *
 *---------------------------------------------------------------------------------------------------------------------
 *
 * Executed if at least one of the following trigger conditions occurred:
 *   - triggered by server invocation for OperationPrototype <Start> of PortPrototype <RoutineServices_Routine_SecOC_Vehicle_Shared_Secret_Distribution>
 *
 **********************************************************************************************************************
 *
 * Output Interfaces:
 * ==================
 *   Explicit S/R API:
 *   -----------------
 *   Std_ReturnType Rte_Write_KeyM_Com_SendSharedSecret_sharedSecret(const uint8 *data)
 *     Argument data: uint8* is of type KeyM_SharedSecretType
 *
 * Client/Server Interfaces:
 * =========================
 *   Server Invocation:
 *   ------------------
 *   Std_ReturnType Rte_Call_RightsM_DiagnosticChannel_GetPostProductionStatus(Ssa_PostProductionStatusType *status)
 *     Synchronous Server Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_RightsM_DiagnosticChannel_E_NOT_OK
 *   Std_ReturnType Rte_Call_SecLog_SuccessfulDiagServiceExecutionEvent_VehicleSharedSecretDistribution_SuccessfulDiagServiceExecution(uint8 additionalInfo)
 *     Synchronous Server Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_SecLog_SuccessfulDiagServiceExecutionEvent_E_NOT_OK
 *   Std_ReturnType Rte_Call_TimeM_RealTime_Compare(const TimeM_DateTimeType *t1, TimeM_CompareOperatorType compareOp, const TimeM_DateTimeType *t2, boolean *result)
 *     Synchronous Server Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_TimeM_RealTime_E_NOT_OK
 *   Std_ReturnType Rte_Call_TimeM_RealTime_Get(TimeM_DateTimeType *realTime)
 *     Synchronous Server Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_TimeM_RealTime_E_NOT_OK
 *
 * Service Calls:
 * ==============
 *   Service Invocation:
 *   -------------------
 *   Std_ReturnType Rte_Call_Key_SharedSecret_KeyElementGet(uint32 keyElementId, uint8 *keyPtr, uint32 *keyLength)
 *     Argument keyPtr: uint8* is of type Csm_KeyDataType_Ssa_SharedSecret
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_CsmKeyManagement_Ssa_SharedSecret_CSM_E_BUSY, RTE_E_CsmKeyManagement_Ssa_SharedSecret_CSM_E_KEY_EMPTY, RTE_E_CsmKeyManagement_Ssa_SharedSecret_CSM_E_KEY_NOT_AVAILABLE, RTE_E_CsmKeyManagement_Ssa_SharedSecret_CSM_E_KEY_READ_FAIL, RTE_E_CsmKeyManagement_Ssa_SharedSecret_CSM_E_SMALL_BUFFER, RTE_E_CsmKeyManagement_Ssa_SharedSecret_E_NOT_OK
 *
 **********************************************************************************************************************
 *
 * Runnable prototype:
 * ===================
 *   Std_ReturnType Ssa_KeyM_RoutineServices_Routine_SecOC_Vehicle_Shared_Secret_Distribution(Dcm_OpStatusType OpStatus, uint8 *routineInfo, Dcm_NegativeResponseCodeType *ErrorCode)
 *
 **********************************************************************************************************************
 *
 * Available Application Errors:
 * =============================
 *   RTE_E_RoutineServices_Routine_SecOC_Vehicle_Shared_Secret_Distribution_DCM_E_FORCE_RCRRP
 *   RTE_E_RoutineServices_Routine_SecOC_Vehicle_Shared_Secret_Distribution_DCM_E_PENDING
 *   RTE_E_RoutineServices_Routine_SecOC_Vehicle_Shared_Secret_Distribution_E_NOT_OK
 *
 *********************************************************************************************************************/
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << Start of documentation area >>                  DO NOT CHANGE THIS COMMENT!
 * Symbol: Ssa_KeyM_RoutineServices_Routine_SecOC_Vehicle_Shared_Secret_Distribution_doc
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << End of documentation area >>                    DO NOT CHANGE THIS COMMENT!
 *********************************************************************************************************************/

FUNC(Std_ReturnType, Ssa_KeyM_CODE) Ssa_KeyM_RoutineServices_Routine_SecOC_Vehicle_Shared_Secret_Distribution(
  Dcm_OpStatusType OpStatus,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) routineInfo,
  P2VAR(Dcm_NegativeResponseCodeType, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) ErrorCode) /* PRQA S 0624, 3206 */ /* MD_Rte_0624, MD_Rte_3206 */
{
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << Start of runnable implementation >>             DO NOT CHANGE THIS COMMENT!
 * Symbol: Ssa_KeyM_RoutineServices_Routine_SecOC_Vehicle_Shared_Secret_Distribution (returns application error)
 *********************************************************************************************************************/
  Std_ReturnType retVal = RTE_E_RoutineServices_Routine_SecOC_Vehicle_Shared_Secret_Distribution_E_NOT_OK;

  /* ----- Development Error Checks ------------------------------------- */
# if (SSA_DEV_ERROR_DETECT == STD_ON)
  if ((routineInfo == NULL_PTR) || (ErrorCode == NULL_PTR))
  {
    /* retVal already set */
  }
  else
# endif /* SSA_DEV_ERROR_DETECT == STD_ON */
  {
    Ssa_PostProductionStatusType postProductionStatus = SSA_POST_PRODUCTION_STATUS_DEACTIVATED;

    retVal = Rte_Call_RightsM_DiagnosticChannel_GetPostProductionStatus(&postProductionStatus);

    /* #5 Check whether post production status is active */
    if ((retVal != RTE_E_OK) || (postProductionStatus != SSA_POST_PRODUCTION_STATUS_DEACTIVATED))
    {
      retVal = RTE_E_RoutineServices_Routine_SecOC_Vehicle_Shared_Secret_Distribution_E_NOT_OK;
      *ErrorCode = DCM_E_CONDITIONSNOTCORRECT;
    }
    else
    {
      uint8 sharedSecret[SSA_SIZEOF_SECRET];
      uint32 sharedSecretLength = SSA_SIZEOF_SECRET;

      /* #10 Load the stored car-specific secret. */
      retVal = Rte_Call_Key_SharedSecret_KeyElementGet(SSA_KE_MAC_KEY, sharedSecret, &sharedSecretLength);

      if ((retVal == E_OK) && (sharedSecretLength == SSA_SIZEOF_SECRET))
      {
        /* #20 Broadcast the secret. */
        retVal = Rte_Write_KeyM_Com_SendSharedSecret_sharedSecret(sharedSecret);
      }

      /* #30 Clear secret from RAM in any case. */
      KeyM_ClearDataBuffer(sharedSecret, SSA_SIZEOF_SECRET, SSA_SIZEOF_SECRET);

      /* #40 Set negative response code. */
      if (retVal != E_OK)
      {
        retVal = RTE_E_RoutineServices_Routine_SecOC_Vehicle_Shared_Secret_Distribution_E_NOT_OK;
        *ErrorCode = DCM_E_GENERALREJECT;
      }
      else
      {
        *ErrorCode = DCM_E_POSITIVERESPONSE;
        /* #45 If the service is finished and no error occurred write the security log for event
         *     "successful diagnostic service execution" for use case "SecOC Vehicle Shared Secret Distribution"
         *     with additional information 0xFF. */
        (void)Rte_Call_SecLog_SuccessfulDiagServiceExecutionEvent_VehicleSharedSecretDistribution_SuccessfulDiagServiceExecution((uint8)0xFFu);
      }
    }

    *routineInfo = SSA_ROUTINE_INFO_SUCCESFULLY_COMPLETED;
  }
  SSA_DUMMY_STATEMENT(OpStatus);    /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */

  return retVal;
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << End of runnable implementation >>               DO NOT CHANGE THIS COMMENT!
 *********************************************************************************************************************/
}

#endif

/**********************************************************************************************************************
 *
 * Runnable Entity Name: Ssa_KeyM_RoutineServices_Trust_Model_Generate_Key_Pair
 *
 *---------------------------------------------------------------------------------------------------------------------
 *
 * Executed if at least one of the following trigger conditions occurred:
 *   - triggered by server invocation for OperationPrototype <Start> of PortPrototype <RoutineServices_Trust_Model_Generate_Key_Pair>
 *
 **********************************************************************************************************************
 *
 * Client/Server Interfaces:
 * =========================
 *   Server Invocation:
 *   ------------------
 *   Std_ReturnType Rte_Call_SecLog_SuccessfulDiagServiceExecutionEvent_TrustModelGenerateKeyPair_SuccessfulDiagServiceExecution(uint8 additionalInfo)
 *     Synchronous Server Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_SecLog_SuccessfulDiagServiceExecutionEvent_E_NOT_OK
 *   Std_ReturnType Rte_Call_SsaCdd_Csm_SignatureGenerate(uint32 jobId, Crypto_OperationModeType operationMode, Ssa_ConstDataPtr dataBuffer, uint32 dataLength, Ssa_DataPtr resultBuffer, Ssa_LengthPtr resultLength)
 *     Synchronous Server Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_SsaCdd_CryptoInterface_E_NOT_OK
 *   Std_ReturnType Rte_Call_SsaCdd_Csm_SignatureVerify(uint32 jobId, Crypto_OperationModeType operationMode, Ssa_ConstDataPtr dataBuffer, uint32 dataLength, Ssa_ConstDataPtr compareBuffer, uint32 compareLength, Ssa_VerifyResultPtr resultBuffer)
 *     Synchronous Server Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_SsaCdd_CryptoInterface_E_NOT_OK
 *   Std_ReturnType Rte_Call_SsaCdd_TrustModel_CsrElementSet(KeyM_CertificateIdType CertId, KeyM_CertElementIdType CertElementId, KeyM_CsrEncodingType EncodingType, Ssa_ConstDataPtr ElementData, uint32 ElementDataLength)
 *     Synchronous Server Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_SsaCdd_KeyM_CertInterface_E_NOT_OK, RTE_E_SsaCdd_KeyM_CertInterface_KEYM_E_KEY_CERT_SIZE_MISMATCH, RTE_E_SsaCdd_KeyM_CertInterface_KEYM_E_PARAMETER_MISMATCH
 *   Std_ReturnType Rte_Call_SsaCdd_TrustModel_ServiceCertificate(KeyM_ServiceCertificateType Service, Ssa_ConstDataPtr CertNamePtr, uint32 CertNameLength, Ssa_ConstDataPtr RequestData, uint32 RequestDataLength, Ssa_DataPtr ResponseData, uint32 ResponseDataLength)
 *     Synchronous Server Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_SsaCdd_KeyM_CertInterface_E_NOT_OK, RTE_E_SsaCdd_KeyM_CertInterface_KEYM_E_BUSY, RTE_E_SsaCdd_KeyM_CertInterface_KEYM_E_CERT_INVALID_CHAIN_OF_TRUST, RTE_E_SsaCdd_KeyM_CertInterface_KEYM_E_KEY_CERT_EMPTY, RTE_E_SsaCdd_KeyM_CertInterface_KEYM_E_KEY_CERT_SIZE_MISMATCH, RTE_E_SsaCdd_KeyM_CertInterface_KEYM_E_PARAMETER_MISMATCH
 *   Std_ReturnType Rte_Call_Ssa_KeyProc_GenerateKeyPair(uint32 privateKeyId, uint32 publicKeyId)
 *     Synchronous Server Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_Ssa_KeyProc_E_NOT_OK, RTE_E_Ssa_KeyProc_E_PENDING
 *   Std_ReturnType Rte_Call_Ssa_VeDocRelevantInfo_GetData(uint8 *data, uint16 *dataLength)
 *     Argument data: uint8* is of type Ssa_Data64ByteType
 *     Synchronous Server Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_Ssa_VeDocRelevantInfo_E_NOT_OK
 *
 * Service Calls:
 * ==============
 *   Service Invocation:
 *   -------------------
 *   Std_ReturnType Rte_Call_CsmJobKeyGenerate_TrustModelEcuCsr_KeyGenerate(uint32 key)
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_CsmJobKeyGenerate_CSM_E_BUSY, RTE_E_CsmJobKeyGenerate_CSM_E_KEY_EMPTY, RTE_E_CsmJobKeyGenerate_E_NOT_OK
 *   Std_ReturnType Rte_Call_Key_TrustModelEcuCsrPrivateKey_KeyElementCopy(uint32 keyElementId, uint32 targetKeyId, uint32 targetKeyElementId)
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_CsmKeyManagement_Ssa_TrustModelEcuCsrPrivateKey_CSM_E_BUSY, RTE_E_CsmKeyManagement_Ssa_TrustModelEcuCsrPrivateKey_CSM_E_KEY_EMPTY, RTE_E_CsmKeyManagement_Ssa_TrustModelEcuCsrPrivateKey_CSM_E_KEY_READ_FAIL, RTE_E_CsmKeyManagement_Ssa_TrustModelEcuCsrPrivateKey_CSM_E_KEY_SIZE_MISMATCH, RTE_E_CsmKeyManagement_Ssa_TrustModelEcuCsrPrivateKey_CSM_E_KEY_WRITE_FAIL, RTE_E_CsmKeyManagement_Ssa_TrustModelEcuCsrPrivateKey_CSM_E_SMALL_BUFFER, RTE_E_CsmKeyManagement_Ssa_TrustModelEcuCsrPrivateKey_E_NOT_OK
 *   Std_ReturnType Rte_Call_Key_TrustModelEcuCsrPrivateKey_KeyGenerate(void)
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_CsmKeyManagement_Ssa_TrustModelEcuCsrPrivateKey_CSM_E_BUSY, RTE_E_CsmKeyManagement_Ssa_TrustModelEcuCsrPrivateKey_CSM_E_KEY_EMPTY, RTE_E_CsmKeyManagement_Ssa_TrustModelEcuCsrPrivateKey_E_NOT_OK
 *   Std_ReturnType Rte_Call_Key_TrustModelEcuCsrPrivateKey_KeySetValid(void)
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_CsmKeyManagement_Ssa_TrustModelEcuCsrPrivateKey_CSM_E_BUSY, RTE_E_CsmKeyManagement_Ssa_TrustModelEcuCsrPrivateKey_E_NOT_OK
 *   Std_ReturnType Rte_Call_Key_TrustModelEcuCsrPublicKey_KeyElementGet(uint32 keyElementId, uint8 *keyPtr, uint32 *keyLength)
 *     Argument keyPtr: uint8* is of type Csm_KeyDataType_Ssa_TrustModelEcuCsrPublicKey
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_CsmKeyManagement_Ssa_TrustModelEcuCsrPublicKey_CSM_E_BUSY, RTE_E_CsmKeyManagement_Ssa_TrustModelEcuCsrPublicKey_CSM_E_KEY_EMPTY, RTE_E_CsmKeyManagement_Ssa_TrustModelEcuCsrPublicKey_CSM_E_KEY_NOT_AVAILABLE, RTE_E_CsmKeyManagement_Ssa_TrustModelEcuCsrPublicKey_CSM_E_KEY_READ_FAIL, RTE_E_CsmKeyManagement_Ssa_TrustModelEcuCsrPublicKey_CSM_E_SMALL_BUFFER, RTE_E_CsmKeyManagement_Ssa_TrustModelEcuCsrPublicKey_E_NOT_OK
 *   Std_ReturnType Rte_Call_Key_TrustModelEcuCsrPublicKey_KeySetValid(void)
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_CsmKeyManagement_Ssa_TrustModelEcuCsrPublicKey_CSM_E_BUSY, RTE_E_CsmKeyManagement_Ssa_TrustModelEcuCsrPublicKey_E_NOT_OK
 *   Std_ReturnType Rte_Call_Key_TrustModelTempPublicKey_KeyElementSet(uint32 keyElementId, const uint8 *keyPtr, uint32 keyLength)
 *     Argument keyPtr: uint8* is of type Csm_KeyDataType_Ssa_TrustModelTempPublicKey
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_CsmKeyManagement_Ssa_TrustModelTempPublicKey_CSM_E_BUSY, RTE_E_CsmKeyManagement_Ssa_TrustModelTempPublicKey_CSM_E_KEY_NOT_AVAILABLE, RTE_E_CsmKeyManagement_Ssa_TrustModelTempPublicKey_CSM_E_KEY_SIZE_MISMATCH, RTE_E_CsmKeyManagement_Ssa_TrustModelTempPublicKey_CSM_E_KEY_WRITE_FAIL, RTE_E_CsmKeyManagement_Ssa_TrustModelTempPublicKey_E_NOT_OK
 *   Std_ReturnType Rte_Call_Key_TrustModelTempPublicKey_KeySetValid(void)
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_CsmKeyManagement_Ssa_TrustModelTempPublicKey_CSM_E_BUSY, RTE_E_CsmKeyManagement_Ssa_TrustModelTempPublicKey_E_NOT_OK
 *
 **********************************************************************************************************************
 *
 * Runnable prototype:
 * ===================
 *   Std_ReturnType Ssa_KeyM_RoutineServices_Trust_Model_Generate_Key_Pair(Dcm_OpStatusType OpStatus, uint8 *routineInfo_Out, uint8 *Verification_Result_Out, uint8 *CSR_Signature_Out, uint8 *Trust_Model_ECU_CSR_Out, uint16 *DataLength, Dcm_NegativeResponseCodeType *ErrorCode)
 *     Argument CSR_Signature_Out: uint8* is of type Dcm_Data64ByteType
 *     Argument Trust_Model_ECU_CSR_Out: uint8* is of type Dcm_Data1002ByteType
 *
 **********************************************************************************************************************
 *
 * Available Application Errors:
 * =============================
 *   RTE_E_RoutineServices_Trust_Model_Generate_Key_Pair_DCM_E_FORCE_RCRRP
 *   RTE_E_RoutineServices_Trust_Model_Generate_Key_Pair_DCM_E_PENDING
 *   RTE_E_RoutineServices_Trust_Model_Generate_Key_Pair_E_NOT_OK
 *
 *********************************************************************************************************************/
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << Start of documentation area >>                  DO NOT CHANGE THIS COMMENT!
 * Symbol: Ssa_KeyM_RoutineServices_Trust_Model_Generate_Key_Pair_doc
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *

 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
/*!
 * \spec
 *    requires $lengthOf(CSR_Signature_Out) >= sizeof(Dcm_Data64ByteType);
 *    requires $lengthOf(Trust_Model_ECU_CSR_Out) >= sizeof(Dcm_Data1002ByteType);
 * \endspec
 */
/* PRQA S 3673 15 */ /* MD_SSA_PARAM_NOT_P2CONST */
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << End of documentation area >>                    DO NOT CHANGE THIS COMMENT!
 *********************************************************************************************************************/

FUNC(Std_ReturnType, Ssa_KeyM_CODE) Ssa_KeyM_RoutineServices_Trust_Model_Generate_Key_Pair(
  Dcm_OpStatusType OpStatus,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) routineInfo_Out,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) Verification_Result_Out,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) CSR_Signature_Out,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) Trust_Model_ECU_CSR_Out,
  P2VAR(uint16, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) DataLength,
  P2VAR(Dcm_NegativeResponseCodeType, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) ErrorCode) /* PRQA S 0624, 3206 */ /* MD_Rte_0624, MD_Rte_3206 */
{
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << Start of runnable implementation >>             DO NOT CHANGE THIS COMMENT!
 * Symbol: Ssa_KeyM_RoutineServices_Trust_Model_Generate_Key_Pair (returns application error)
 *********************************************************************************************************************/

  Std_ReturnType retVal = RTE_E_RoutineServices_Trust_Model_Generate_Key_Pair_E_NOT_OK;

  /* ----- Development Error Checks ------------------------------------- */
#if (SSA_DEV_ERROR_DETECT == STD_ON)
  if ((routineInfo_Out == NULL_PTR)
    || (Verification_Result_Out == NULL_PTR)
    || (CSR_Signature_Out == NULL_PTR)
    || (Trust_Model_ECU_CSR_Out == NULL_PTR)
    || (DataLength == NULL_PTR)
    || (ErrorCode == NULL_PTR))
  {
    /* retVal already set */
  }
  else
#endif /* SSA_DEV_ERROR_DETECT == STD_ON */
  {

#if (SSA_DIAG_SERVICE_TRUST_MODEL_GENERATE_KEY_PAIR == STD_OFF)
    *ErrorCode = DCM_E_REQUESTOUTOFRANGE;
    SSA_DUMMY_STATEMENT(OpStatus);   /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */
    SSA_DUMMY_STATEMENT(routineInfo_Out);   /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */
    SSA_DUMMY_STATEMENT(Verification_Result_Out);   /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */
    SSA_DUMMY_STATEMENT(CSR_Signature_Out);   /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */
    SSA_DUMMY_STATEMENT(Trust_Model_ECU_CSR_Out);   /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */
    SSA_DUMMY_STATEMENT(DataLength);   /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */
#else

    if (OpStatus == DCM_CANCEL)
    {
      KeyM_DiagProc.state = SSA_KEYM_TRUST_MODEL_GENERATE_KEY_PAIR_STATE_IDLE;
      retVal = RTE_E_OK;
    }
    else if (!KeyM_IsTrustModelGenerateKeyPairStateValid())
    {
      KeyM_DiagProc.state = SSA_KEYM_TRUST_MODEL_GENERATE_KEY_PAIR_STATE_IDLE;
      *ErrorCode = DCM_E_GENERALREJECT;
    }
    else
    {
      /*@ assert sizeof(Dcm_Data64ByteType) == SSA_SIZEOF_SIGNATURE; */
      /*@ assert  $lengthOf(CSR_Signature_Out) >= sizeof(Dcm_Data64ByteType); */ /* VCA_SSA_KEYM_LENGTH_SPECIFIED_IN_FCT_CALL */
      /*@ assert  $lengthOf(Trust_Model_ECU_CSR_Out) >= sizeof(Dcm_Data1002ByteType); */ /* VCA_SSA_KEYM_LENGTH_SPECIFIED_IN_FCT_CALL */
      retVal = KeyM_Trust_Model_Generate_Key_Pair_State_Handler[KeyM_DiagProc.state](
        Verification_Result_Out, CSR_Signature_Out, Trust_Model_ECU_CSR_Out, DataLength);

      if (retVal == SSA_E_PENDING)
      {
        /* Return pending and check again next time */
        retVal = RTE_E_RoutineServices_Trust_Model_Generate_Key_Pair_DCM_E_PENDING;
      }
      else
      {
        KeyM_DiagProc.state = SSA_KEYM_TRUST_MODEL_GENERATE_KEY_PAIR_STATE_IDLE;

        if (retVal == E_OK)
        {
          *routineInfo_Out = SSA_ROUTINE_INFO_SUCCESFULLY_COMPLETED;

          (void)Rte_Call_SecLog_SuccessfulDiagServiceExecutionEvent_TrustModelGenerateKeyPair_SuccessfulDiagServiceExecution(*Verification_Result_Out);
          retVal = RTE_E_OK;
        }
        else
        {
          *ErrorCode = DCM_E_CONDITIONSNOTCORRECT;
          retVal = RTE_E_RoutineServices_Trust_Model_Generate_Key_Pair_E_NOT_OK;
        }
      }
    }
#endif
  }

  return retVal;

/* PRQA S 6060, 6080 4 */ /* MD_SSA_STPAR, MD_MSR_STMIF */
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << End of runnable implementation >>               DO NOT CHANGE THIS COMMENT!
 *********************************************************************************************************************/
}

#if (SSA_ECU_TYPE != SSA_ECU_TYPE_VSM)

/**********************************************************************************************************************
 *
 * Runnable Entity Name: Ssa_KeyM_RoutineServices_Trust_Model_SecOC_ECU_Shared_Secret_Distribution
 *
 *---------------------------------------------------------------------------------------------------------------------
 *
 * Executed if at least one of the following trigger conditions occurred:
 *   - triggered by server invocation for OperationPrototype <Start> of PortPrototype <RoutineServices_Trust_Model_SecOC_ECU_Shared_Secret_Distribution>
 *
 **********************************************************************************************************************
 *
 * Client/Server Interfaces:
 * =========================
 *   Server Invocation:
 *   ------------------
 *   Std_ReturnType Rte_Call_CertP_Functions_ParseTime(const uint8 *data, uint16 dataLength, TimeM_DateTimeType *dateTime)
 *     Argument data: uint8* is of type Ssa_Data15ByteType
 *     Synchronous Server Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_CertP_Functions_E_NOT_OK
 *   Std_ReturnType Rte_Call_RightsM_DiagnosticChannel_GetDiagnosticUserRole(RightsM_DiagnosticUserRoleType *userRole)
 *     Synchronous Server Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_RightsM_DiagnosticChannel_E_NOT_OK
 *   Std_ReturnType Rte_Call_RightsM_DiagnosticChannel_GetPostProductionStatus(Ssa_PostProductionStatusType *status)
 *     Synchronous Server Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_RightsM_DiagnosticChannel_E_NOT_OK
 *   Std_ReturnType Rte_Call_RightsM_EnhancedRights_VerifySubjectKeyIdentifier(const uint8 *subjectKeyIdentifier)
 *     Argument subjectKeyIdentifier: uint8* is of type Ssa_Data20ByteType
 *     Synchronous Server Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_RightsM_EnhancedRights_E_NOT_OK
 *   Std_ReturnType Rte_Call_RightsM_Nonce_Destroy(void)
 *     Synchronous Server Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_RightsM_Nonce_E_NOT_OK, RTE_E_RightsM_Nonce_E_PENDING
 *   Std_ReturnType Rte_Call_RightsM_Nonce_Get(boolean generateNew, uint8 *nonce)
 *     Argument nonce: uint8* is of type Dcm_Data32ByteType
 *     Synchronous Server Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_RightsM_Nonce_E_INVALID, RTE_E_RightsM_Nonce_E_NOT_OK, RTE_E_RightsM_Nonce_E_PENDING
 *   Std_ReturnType Rte_Call_SecLog_FailedCertVerificationEvent_FailedCertificateVerification(CertP_PkiRoleType pkiRole, CertP_VerificationResultType validationResult)
 *     Synchronous Server Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_SecLog_FailedCertVerificationEvent_E_NOT_OK
 *   Std_ReturnType Rte_Call_SecLog_SuccessfulCertVerificationEvent_SuccessfulCertificateVerification(const uint8 *certId, CertP_PkiRoleType pkiRole)
 *     Argument certId: uint8* is of type RightsM_SerialNumberType
 *     Synchronous Server Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_SecLog_SuccessfulCertVerificationEvent_E_NOT_OK
 *   Std_ReturnType Rte_Call_SecLog_SuccessfulDiagServiceExecutionEvent_TrustModelEcuSharedSecretDistribution_SuccessfulDiagServiceExecution(uint8 additionalInfo)
 *     Synchronous Server Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_SecLog_SuccessfulDiagServiceExecutionEvent_E_NOT_OK
 *   Std_ReturnType Rte_Call_SsaCdd_Csm_Hash(uint32 jobId, Crypto_OperationModeType operationMode, Ssa_ConstDataPtr dataBuffer, uint32 dataLength, Ssa_DataPtr resultBuffer, Ssa_LengthPtr resultLength)
 *     Synchronous Server Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_SsaCdd_CryptoInterface_E_NOT_OK
 *   Std_ReturnType Rte_Call_SsaCdd_Csm_SignatureGenerate(uint32 jobId, Crypto_OperationModeType operationMode, Ssa_ConstDataPtr dataBuffer, uint32 dataLength, Ssa_DataPtr resultBuffer, Ssa_LengthPtr resultLength)
 *     Synchronous Server Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_SsaCdd_CryptoInterface_E_NOT_OK
 *   Std_ReturnType Rte_Call_SsaCdd_Csm_SignatureVerify(uint32 jobId, Crypto_OperationModeType operationMode, Ssa_ConstDataPtr dataBuffer, uint32 dataLength, Ssa_ConstDataPtr compareBuffer, uint32 compareLength, Ssa_VerifyResultPtr resultBuffer)
 *     Synchronous Server Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_SsaCdd_CryptoInterface_E_NOT_OK
 *   Std_ReturnType Rte_Call_SsaCdd_TrustModel_SetCertificate(KeyM_CertificateIdType CertId, Ssa_DataPtr CertData, uint32 CertDataLength)
 *     Synchronous Server Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_SsaCdd_KeyM_CertInterface_E_NOT_OK, RTE_E_SsaCdd_KeyM_CertInterface_KEYM_E_KEY_CERT_SIZE_MISMATCH, RTE_E_SsaCdd_KeyM_CertInterface_KEYM_E_PARAMETER_MISMATCH
 *   Std_ReturnType Rte_Call_TimeM_TimeRawData_Set(const uint8 *dateTimeOffset, const uint8 *tickCountOffset, const uint8 *tickCount)
 *     Argument dateTimeOffset: uint8* is of type Ssa_Data7ByteType
 *     Argument tickCountOffset: uint8* is of type Ssa_Data5ByteType
 *     Argument tickCount: uint8* is of type Ssa_Data5ByteType
 *     Synchronous Server Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_TimeM_TimeRawData_E_NOT_OK
 *
 * Service Calls:
 * ==============
 *   Service Invocation:
 *   -------------------
 *   Std_ReturnType Rte_Call_CsmJobKeyExchangeCalcSecret_KeyExchangeCalcSecret(uint32 key, Csm_const_DataPtr partnerPublicValuePtr, uint32 partnerPublicValueLength)
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_CsmJobKeyExchangeCalcSecret_CSM_E_BUSY, RTE_E_CsmJobKeyExchangeCalcSecret_CSM_E_KEY_EMPTY, RTE_E_CsmJobKeyExchangeCalcSecret_CSM_E_SMALL_BUFFER, RTE_E_CsmJobKeyExchangeCalcSecret_E_NOT_OK
 *   Std_ReturnType Rte_Call_CsmSymAES128Decrypt_Decrypt(const uint8 *dataBuffer, uint32 dataLength, uint8 *resultBuffer, uint32 *resultLength)
 *     Argument dataBuffer: uint8* is of type Csm_DecryptDataType_AES128Decrypt
 *     Argument resultBuffer: uint8* is of type Csm_DecryptResultType_AES128Decrypt
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_CsmDecrypt_AES128Decrypt_CSM_E_BUSY, RTE_E_CsmDecrypt_AES128Decrypt_CSM_E_KEY_EMPTY, RTE_E_CsmDecrypt_AES128Decrypt_CSM_E_KEY_NOT_VALID, RTE_E_CsmDecrypt_AES128Decrypt_CSM_E_KEY_SIZE_MISMATCH, RTE_E_CsmDecrypt_AES128Decrypt_CSM_E_SMALL_BUFFER, RTE_E_CsmDecrypt_AES128Decrypt_E_NOT_OK
 *   Std_ReturnType Rte_Call_KeyMCertificateElement_Ssa_TrustModelBackendPeerCert_SerialNo_CertificateElementGet(uint8 *CertificateElementData, uint32 *CertificateDataLength)
 *     Argument CertificateElementData: uint8* is of type KeyM_CertificateElementType_Ssa_TrustModelBackendPeerCert_SerialNo
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_KeyMCertificateElement_Ssa_TrustModelBackendPeerCert_SerialNo_E_NOT_OK, RTE_E_KeyMCertificateElement_Ssa_TrustModelBackendPeerCert_SerialNo_KEYM_E_KEY_CERT_EMPTY, RTE_E_KeyMCertificateElement_Ssa_TrustModelBackendPeerCert_SerialNo_KEYM_E_KEY_CERT_INVALID, RTE_E_KeyMCertificateElement_Ssa_TrustModelBackendPeerCert_SerialNo_KEYM_E_KEY_CERT_SIZE_MISMATCH, RTE_E_KeyMCertificateElement_Ssa_TrustModelBackendPeerCert_SerialNo_KEYM_E_PARAMETER_MISMATCH
 *   Std_ReturnType Rte_Call_KeyMCertificateElement_Ssa_TrustModelBackendPeerCert_Version_CertificateElementGet(uint8 *CertificateElementData, uint32 *CertificateDataLength)
 *     Argument CertificateElementData: uint8* is of type KeyM_CertificateElementType_Ssa_TrustModelBackendPeerCert_Version
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_KeyMCertificateElement_Ssa_TrustModelBackendPeerCert_Version_E_NOT_OK, RTE_E_KeyMCertificateElement_Ssa_TrustModelBackendPeerCert_Version_KEYM_E_KEY_CERT_EMPTY, RTE_E_KeyMCertificateElement_Ssa_TrustModelBackendPeerCert_Version_KEYM_E_KEY_CERT_INVALID, RTE_E_KeyMCertificateElement_Ssa_TrustModelBackendPeerCert_Version_KEYM_E_KEY_CERT_SIZE_MISMATCH, RTE_E_KeyMCertificateElement_Ssa_TrustModelBackendPeerCert_Version_KEYM_E_PARAMETER_MISMATCH
 *   Std_ReturnType Rte_Call_KeyMCertificateElement_Ssa_TrustModelBackendPeerCert_ext_authKeyId_CertificateElementGet(uint8 *CertificateElementData, uint32 *CertificateDataLength)
 *     Argument CertificateElementData: uint8* is of type KeyM_CertificateElementType_Ssa_TrustModelBackendPeerCert_ext_authKeyId
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_KeyMCertificateElement_Ssa_TrustModelBackendPeerCert_ext_authKeyId_E_NOT_OK, RTE_E_KeyMCertificateElement_Ssa_TrustModelBackendPeerCert_ext_authKeyId_KEYM_E_KEY_CERT_EMPTY, RTE_E_KeyMCertificateElement_Ssa_TrustModelBackendPeerCert_ext_authKeyId_KEYM_E_KEY_CERT_INVALID, RTE_E_KeyMCertificateElement_Ssa_TrustModelBackendPeerCert_ext_authKeyId_KEYM_E_KEY_CERT_SIZE_MISMATCH, RTE_E_KeyMCertificateElement_Ssa_TrustModelBackendPeerCert_ext_authKeyId_KEYM_E_PARAMETER_MISMATCH
 *   Std_ReturnType Rte_Call_KeyMCertificateElement_Ssa_TrustModelBackendPeerCert_ext_basicConstraints_CertificateElementGet(uint8 *CertificateElementData, uint32 *CertificateDataLength)
 *     Argument CertificateElementData: uint8* is of type KeyM_CertificateElementType_Ssa_TrustModelBackendPeerCert_ext_basicConstraints
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_KeyMCertificateElement_Ssa_TrustModelBackendPeerCert_ext_basicConstraints_E_NOT_OK, RTE_E_KeyMCertificateElement_Ssa_TrustModelBackendPeerCert_ext_basicConstraints_KEYM_E_KEY_CERT_EMPTY, RTE_E_KeyMCertificateElement_Ssa_TrustModelBackendPeerCert_ext_basicConstraints_KEYM_E_KEY_CERT_INVALID, RTE_E_KeyMCertificateElement_Ssa_TrustModelBackendPeerCert_ext_basicConstraints_KEYM_E_KEY_CERT_SIZE_MISMATCH, RTE_E_KeyMCertificateElement_Ssa_TrustModelBackendPeerCert_ext_basicConstraints_KEYM_E_PARAMETER_MISMATCH
 *   Std_ReturnType Rte_Call_KeyMCertificateElement_Ssa_TrustModelBackendPeerCert_ext_subKeyId_CertificateElementGet(uint8 *CertificateElementData, uint32 *CertificateDataLength)
 *     Argument CertificateElementData: uint8* is of type KeyM_CertificateElementType_Ssa_TrustModelBackendPeerCert_ext_subKeyId
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_KeyMCertificateElement_Ssa_TrustModelBackendPeerCert_ext_subKeyId_E_NOT_OK, RTE_E_KeyMCertificateElement_Ssa_TrustModelBackendPeerCert_ext_subKeyId_KEYM_E_KEY_CERT_EMPTY, RTE_E_KeyMCertificateElement_Ssa_TrustModelBackendPeerCert_ext_subKeyId_KEYM_E_KEY_CERT_INVALID, RTE_E_KeyMCertificateElement_Ssa_TrustModelBackendPeerCert_ext_subKeyId_KEYM_E_KEY_CERT_SIZE_MISMATCH, RTE_E_KeyMCertificateElement_Ssa_TrustModelBackendPeerCert_ext_subKeyId_KEYM_E_PARAMETER_MISMATCH
 *   Std_ReturnType Rte_Call_KeyMCertificateElement_Ssa_TrustModelBackendPeerCert_validityNotAfter_CertificateElementGet(uint8 *CertificateElementData, uint32 *CertificateDataLength)
 *     Argument CertificateElementData: uint8* is of type KeyM_CertificateElementType_Ssa_TrustModelBackendPeerCert_validityNotAfter
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_KeyMCertificateElement_Ssa_TrustModelBackendPeerCert_validityNotAfter_E_NOT_OK, RTE_E_KeyMCertificateElement_Ssa_TrustModelBackendPeerCert_validityNotAfter_KEYM_E_KEY_CERT_EMPTY, RTE_E_KeyMCertificateElement_Ssa_TrustModelBackendPeerCert_validityNotAfter_KEYM_E_KEY_CERT_INVALID, RTE_E_KeyMCertificateElement_Ssa_TrustModelBackendPeerCert_validityNotAfter_KEYM_E_KEY_CERT_SIZE_MISMATCH, RTE_E_KeyMCertificateElement_Ssa_TrustModelBackendPeerCert_validityNotAfter_KEYM_E_PARAMETER_MISMATCH
 *   Std_ReturnType Rte_Call_KeyMCertificateElement_Ssa_TrustModelEcuPeerCert_SerialNo_CertificateElementGet(uint8 *CertificateElementData, uint32 *CertificateDataLength)
 *     Argument CertificateElementData: uint8* is of type KeyM_CertificateElementType_Ssa_TrustModelEcuPeerCert_SerialNo
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_KeyMCertificateElement_Ssa_TrustModelEcuPeerCert_SerialNo_E_NOT_OK, RTE_E_KeyMCertificateElement_Ssa_TrustModelEcuPeerCert_SerialNo_KEYM_E_KEY_CERT_EMPTY, RTE_E_KeyMCertificateElement_Ssa_TrustModelEcuPeerCert_SerialNo_KEYM_E_KEY_CERT_INVALID, RTE_E_KeyMCertificateElement_Ssa_TrustModelEcuPeerCert_SerialNo_KEYM_E_KEY_CERT_SIZE_MISMATCH, RTE_E_KeyMCertificateElement_Ssa_TrustModelEcuPeerCert_SerialNo_KEYM_E_PARAMETER_MISMATCH
 *   Std_ReturnType Rte_Call_KeyMCertificateElement_Ssa_TrustModelEcuPeerCert_Version_CertificateElementGet(uint8 *CertificateElementData, uint32 *CertificateDataLength)
 *     Argument CertificateElementData: uint8* is of type KeyM_CertificateElementType_Ssa_TrustModelEcuPeerCert_Version
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_KeyMCertificateElement_Ssa_TrustModelEcuPeerCert_Version_E_NOT_OK, RTE_E_KeyMCertificateElement_Ssa_TrustModelEcuPeerCert_Version_KEYM_E_KEY_CERT_EMPTY, RTE_E_KeyMCertificateElement_Ssa_TrustModelEcuPeerCert_Version_KEYM_E_KEY_CERT_INVALID, RTE_E_KeyMCertificateElement_Ssa_TrustModelEcuPeerCert_Version_KEYM_E_KEY_CERT_SIZE_MISMATCH, RTE_E_KeyMCertificateElement_Ssa_TrustModelEcuPeerCert_Version_KEYM_E_PARAMETER_MISMATCH
 *   Std_ReturnType Rte_Call_KeyMCertificateElement_Ssa_TrustModelEcuPeerCert_ext_authKeyId_CertificateElementGet(uint8 *CertificateElementData, uint32 *CertificateDataLength)
 *     Argument CertificateElementData: uint8* is of type KeyM_CertificateElementType_Ssa_TrustModelEcuPeerCert_ext_authKeyId
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_KeyMCertificateElement_Ssa_TrustModelEcuPeerCert_ext_authKeyId_E_NOT_OK, RTE_E_KeyMCertificateElement_Ssa_TrustModelEcuPeerCert_ext_authKeyId_KEYM_E_KEY_CERT_EMPTY, RTE_E_KeyMCertificateElement_Ssa_TrustModelEcuPeerCert_ext_authKeyId_KEYM_E_KEY_CERT_INVALID, RTE_E_KeyMCertificateElement_Ssa_TrustModelEcuPeerCert_ext_authKeyId_KEYM_E_KEY_CERT_SIZE_MISMATCH, RTE_E_KeyMCertificateElement_Ssa_TrustModelEcuPeerCert_ext_authKeyId_KEYM_E_PARAMETER_MISMATCH
 *   Std_ReturnType Rte_Call_KeyMCertificateElement_Ssa_TrustModelEcuPeerCert_ext_specialEcu_CertificateElementGet(uint8 *CertificateElementData, uint32 *CertificateDataLength)
 *     Argument CertificateElementData: uint8* is of type KeyM_CertificateElementType_Ssa_TrustModelEcuPeerCert_ext_specialEcu
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_KeyMCertificateElement_Ssa_TrustModelEcuPeerCert_ext_specialEcu_E_NOT_OK, RTE_E_KeyMCertificateElement_Ssa_TrustModelEcuPeerCert_ext_specialEcu_KEYM_E_KEY_CERT_EMPTY, RTE_E_KeyMCertificateElement_Ssa_TrustModelEcuPeerCert_ext_specialEcu_KEYM_E_KEY_CERT_INVALID, RTE_E_KeyMCertificateElement_Ssa_TrustModelEcuPeerCert_ext_specialEcu_KEYM_E_KEY_CERT_SIZE_MISMATCH, RTE_E_KeyMCertificateElement_Ssa_TrustModelEcuPeerCert_ext_specialEcu_KEYM_E_PARAMETER_MISMATCH
 *   Std_ReturnType Rte_Call_KeyMCertificateElement_Ssa_TrustModelEcuPeerCert_ext_subKeyId_CertificateElementGet(uint8 *CertificateElementData, uint32 *CertificateDataLength)
 *     Argument CertificateElementData: uint8* is of type KeyM_CertificateElementType_Ssa_TrustModelEcuPeerCert_ext_subKeyId
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_KeyMCertificateElement_Ssa_TrustModelEcuPeerCert_ext_subKeyId_E_NOT_OK, RTE_E_KeyMCertificateElement_Ssa_TrustModelEcuPeerCert_ext_subKeyId_KEYM_E_KEY_CERT_EMPTY, RTE_E_KeyMCertificateElement_Ssa_TrustModelEcuPeerCert_ext_subKeyId_KEYM_E_KEY_CERT_INVALID, RTE_E_KeyMCertificateElement_Ssa_TrustModelEcuPeerCert_ext_subKeyId_KEYM_E_KEY_CERT_SIZE_MISMATCH, RTE_E_KeyMCertificateElement_Ssa_TrustModelEcuPeerCert_ext_subKeyId_KEYM_E_PARAMETER_MISMATCH
 *   Std_ReturnType Rte_Call_KeyMCertificateElement_Ssa_TrustModelEcuPeerCert_validityNotAfter_CertificateElementGet(uint8 *CertificateElementData, uint32 *CertificateDataLength)
 *     Argument CertificateElementData: uint8* is of type KeyM_CertificateElementType_Ssa_TrustModelEcuPeerCert_validityNotAfter
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_KeyMCertificateElement_Ssa_TrustModelEcuPeerCert_validityNotAfter_E_NOT_OK, RTE_E_KeyMCertificateElement_Ssa_TrustModelEcuPeerCert_validityNotAfter_KEYM_E_KEY_CERT_EMPTY, RTE_E_KeyMCertificateElement_Ssa_TrustModelEcuPeerCert_validityNotAfter_KEYM_E_KEY_CERT_INVALID, RTE_E_KeyMCertificateElement_Ssa_TrustModelEcuPeerCert_validityNotAfter_KEYM_E_KEY_CERT_SIZE_MISMATCH, RTE_E_KeyMCertificateElement_Ssa_TrustModelEcuPeerCert_validityNotAfter_KEYM_E_PARAMETER_MISMATCH
 *   Std_ReturnType Rte_Call_KeyMCertificateElement_Ssa_TrustModelIntermediatePeerCert_SerialNo_CertificateElementGet(uint8 *CertificateElementData, uint32 *CertificateDataLength)
 *     Argument CertificateElementData: uint8* is of type KeyM_CertificateElementType_Ssa_TrustModelIntermediatePeerCert_SerialNo
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_KeyMCertificateElement_Ssa_TrustModelIntermediatePeerCert_SerialNo_E_NOT_OK, RTE_E_KeyMCertificateElement_Ssa_TrustModelIntermediatePeerCert_SerialNo_KEYM_E_KEY_CERT_EMPTY, RTE_E_KeyMCertificateElement_Ssa_TrustModelIntermediatePeerCert_SerialNo_KEYM_E_KEY_CERT_INVALID, RTE_E_KeyMCertificateElement_Ssa_TrustModelIntermediatePeerCert_SerialNo_KEYM_E_KEY_CERT_SIZE_MISMATCH, RTE_E_KeyMCertificateElement_Ssa_TrustModelIntermediatePeerCert_SerialNo_KEYM_E_PARAMETER_MISMATCH
 *   Std_ReturnType Rte_Call_KeyMCertificateElement_Ssa_TrustModelIntermediatePeerCert_Version_CertificateElementGet(uint8 *CertificateElementData, uint32 *CertificateDataLength)
 *     Argument CertificateElementData: uint8* is of type KeyM_CertificateElementType_Ssa_TrustModelIntermediatePeerCert_Version
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_KeyMCertificateElement_Ssa_TrustModelIntermediatePeerCert_Version_E_NOT_OK, RTE_E_KeyMCertificateElement_Ssa_TrustModelIntermediatePeerCert_Version_KEYM_E_KEY_CERT_EMPTY, RTE_E_KeyMCertificateElement_Ssa_TrustModelIntermediatePeerCert_Version_KEYM_E_KEY_CERT_INVALID, RTE_E_KeyMCertificateElement_Ssa_TrustModelIntermediatePeerCert_Version_KEYM_E_KEY_CERT_SIZE_MISMATCH, RTE_E_KeyMCertificateElement_Ssa_TrustModelIntermediatePeerCert_Version_KEYM_E_PARAMETER_MISMATCH
 *   Std_ReturnType Rte_Call_KeyMCertificateElement_Ssa_TrustModelIntermediatePeerCert_ext_authKeyId_CertificateElementGet(uint8 *CertificateElementData, uint32 *CertificateDataLength)
 *     Argument CertificateElementData: uint8* is of type KeyM_CertificateElementType_Ssa_TrustModelIntermediatePeerCert_ext_authKeyId
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_KeyMCertificateElement_Ssa_TrustModelIntermediatePeerCert_ext_authKeyId_E_NOT_OK, RTE_E_KeyMCertificateElement_Ssa_TrustModelIntermediatePeerCert_ext_authKeyId_KEYM_E_KEY_CERT_EMPTY, RTE_E_KeyMCertificateElement_Ssa_TrustModelIntermediatePeerCert_ext_authKeyId_KEYM_E_KEY_CERT_INVALID, RTE_E_KeyMCertificateElement_Ssa_TrustModelIntermediatePeerCert_ext_authKeyId_KEYM_E_KEY_CERT_SIZE_MISMATCH, RTE_E_KeyMCertificateElement_Ssa_TrustModelIntermediatePeerCert_ext_authKeyId_KEYM_E_PARAMETER_MISMATCH
 *   Std_ReturnType Rte_Call_KeyMCertificateElement_Ssa_TrustModelIntermediatePeerCert_ext_basicConstraints_CertificateElementGet(uint8 *CertificateElementData, uint32 *CertificateDataLength)
 *     Argument CertificateElementData: uint8* is of type KeyM_CertificateElementType_Ssa_TrustModelIntermediatePeerCert_ext_basicConstraints
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_KeyMCertificateElement_Ssa_TrustModelIntermediatePeerCert_ext_basicConstraints_E_NOT_OK, RTE_E_KeyMCertificateElement_Ssa_TrustModelIntermediatePeerCert_ext_basicConstraints_KEYM_E_KEY_CERT_EMPTY, RTE_E_KeyMCertificateElement_Ssa_TrustModelIntermediatePeerCert_ext_basicConstraints_KEYM_E_KEY_CERT_INVALID, RTE_E_KeyMCertificateElement_Ssa_TrustModelIntermediatePeerCert_ext_basicConstraints_KEYM_E_KEY_CERT_SIZE_MISMATCH, RTE_E_KeyMCertificateElement_Ssa_TrustModelIntermediatePeerCert_ext_basicConstraints_KEYM_E_PARAMETER_MISMATCH
 *   Std_ReturnType Rte_Call_KeyMCertificateElement_Ssa_TrustModelIntermediatePeerCert_ext_subKeyId_CertificateElementGet(uint8 *CertificateElementData, uint32 *CertificateDataLength)
 *     Argument CertificateElementData: uint8* is of type KeyM_CertificateElementType_Ssa_TrustModelIntermediatePeerCert_ext_subKeyId
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_KeyMCertificateElement_Ssa_TrustModelIntermediatePeerCert_ext_subKeyId_E_NOT_OK, RTE_E_KeyMCertificateElement_Ssa_TrustModelIntermediatePeerCert_ext_subKeyId_KEYM_E_KEY_CERT_EMPTY, RTE_E_KeyMCertificateElement_Ssa_TrustModelIntermediatePeerCert_ext_subKeyId_KEYM_E_KEY_CERT_INVALID, RTE_E_KeyMCertificateElement_Ssa_TrustModelIntermediatePeerCert_ext_subKeyId_KEYM_E_KEY_CERT_SIZE_MISMATCH, RTE_E_KeyMCertificateElement_Ssa_TrustModelIntermediatePeerCert_ext_subKeyId_KEYM_E_PARAMETER_MISMATCH
 *   Std_ReturnType Rte_Call_KeyMCertificateElement_Ssa_TrustModelIntermediatePeerCert_validityNotAfter_CertificateElementGet(uint8 *CertificateElementData, uint32 *CertificateDataLength)
 *     Argument CertificateElementData: uint8* is of type KeyM_CertificateElementType_Ssa_TrustModelIntermediatePeerCert_validityNotAfter
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_KeyMCertificateElement_Ssa_TrustModelIntermediatePeerCert_validityNotAfter_E_NOT_OK, RTE_E_KeyMCertificateElement_Ssa_TrustModelIntermediatePeerCert_validityNotAfter_KEYM_E_KEY_CERT_EMPTY, RTE_E_KeyMCertificateElement_Ssa_TrustModelIntermediatePeerCert_validityNotAfter_KEYM_E_KEY_CERT_INVALID, RTE_E_KeyMCertificateElement_Ssa_TrustModelIntermediatePeerCert_validityNotAfter_KEYM_E_KEY_CERT_SIZE_MISMATCH, RTE_E_KeyMCertificateElement_Ssa_TrustModelIntermediatePeerCert_validityNotAfter_KEYM_E_PARAMETER_MISMATCH
 *   Std_ReturnType Rte_Call_KeyMCertificateElement_Ssa_TrustModelRootCert_Issuer_CertificateElementGet(uint8 *CertificateElementData, uint32 *CertificateDataLength)
 *     Argument CertificateElementData: uint8* is of type KeyM_CertificateElementType_Ssa_TrustModelRootCert_Issuer
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_KeyMCertificateElement_Ssa_TrustModelRootCert_Issuer_E_NOT_OK, RTE_E_KeyMCertificateElement_Ssa_TrustModelRootCert_Issuer_KEYM_E_KEY_CERT_EMPTY, RTE_E_KeyMCertificateElement_Ssa_TrustModelRootCert_Issuer_KEYM_E_KEY_CERT_INVALID, RTE_E_KeyMCertificateElement_Ssa_TrustModelRootCert_Issuer_KEYM_E_KEY_CERT_SIZE_MISMATCH, RTE_E_KeyMCertificateElement_Ssa_TrustModelRootCert_Issuer_KEYM_E_PARAMETER_MISMATCH
 *   Std_ReturnType Rte_Call_KeyMCertificateElement_Ssa_TrustModelRootCert_SerialNo_CertificateElementGet(uint8 *CertificateElementData, uint32 *CertificateDataLength)
 *     Argument CertificateElementData: uint8* is of type KeyM_CertificateElementType_Ssa_TrustModelRootCert_SerialNo
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_KeyMCertificateElement_Ssa_TrustModelRootCert_SerialNo_E_NOT_OK, RTE_E_KeyMCertificateElement_Ssa_TrustModelRootCert_SerialNo_KEYM_E_KEY_CERT_EMPTY, RTE_E_KeyMCertificateElement_Ssa_TrustModelRootCert_SerialNo_KEYM_E_KEY_CERT_INVALID, RTE_E_KeyMCertificateElement_Ssa_TrustModelRootCert_SerialNo_KEYM_E_KEY_CERT_SIZE_MISMATCH, RTE_E_KeyMCertificateElement_Ssa_TrustModelRootCert_SerialNo_KEYM_E_PARAMETER_MISMATCH
 *   Std_ReturnType Rte_Call_KeyMCertificateElement_Ssa_TrustModelRootCert_SubjectPublicKeyInfoKey_CertificateElementGet(uint8 *CertificateElementData, uint32 *CertificateDataLength)
 *     Argument CertificateElementData: uint8* is of type KeyM_CertificateElementType_Ssa_TrustModelRootCert_SubjectPublicKeyInfoKey
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_KeyMCertificateElement_Ssa_TrustModelRootCert_SubjectPublicKeyInfoKey_E_NOT_OK, RTE_E_KeyMCertificateElement_Ssa_TrustModelRootCert_SubjectPublicKeyInfoKey_KEYM_E_KEY_CERT_EMPTY, RTE_E_KeyMCertificateElement_Ssa_TrustModelRootCert_SubjectPublicKeyInfoKey_KEYM_E_KEY_CERT_INVALID, RTE_E_KeyMCertificateElement_Ssa_TrustModelRootCert_SubjectPublicKeyInfoKey_KEYM_E_KEY_CERT_SIZE_MISMATCH, RTE_E_KeyMCertificateElement_Ssa_TrustModelRootCert_SubjectPublicKeyInfoKey_KEYM_E_PARAMETER_MISMATCH
 *   Std_ReturnType Rte_Call_KeyMCertificateElement_Ssa_TrustModelRootCert_Version_CertificateElementGet(uint8 *CertificateElementData, uint32 *CertificateDataLength)
 *     Argument CertificateElementData: uint8* is of type KeyM_CertificateElementType_Ssa_TrustModelRootCert_Version
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_KeyMCertificateElement_Ssa_TrustModelRootCert_Version_E_NOT_OK, RTE_E_KeyMCertificateElement_Ssa_TrustModelRootCert_Version_KEYM_E_KEY_CERT_EMPTY, RTE_E_KeyMCertificateElement_Ssa_TrustModelRootCert_Version_KEYM_E_KEY_CERT_INVALID, RTE_E_KeyMCertificateElement_Ssa_TrustModelRootCert_Version_KEYM_E_KEY_CERT_SIZE_MISMATCH, RTE_E_KeyMCertificateElement_Ssa_TrustModelRootCert_Version_KEYM_E_PARAMETER_MISMATCH
 *   Std_ReturnType Rte_Call_KeyMCertificateElement_Ssa_TrustModelRootCert_ext_basicConstraints_CertificateElementGet(uint8 *CertificateElementData, uint32 *CertificateDataLength)
 *     Argument CertificateElementData: uint8* is of type KeyM_CertificateElementType_Ssa_TrustModelRootCert_ext_basicConstraints
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_KeyMCertificateElement_Ssa_TrustModelRootCert_ext_basicConstraints_E_NOT_OK, RTE_E_KeyMCertificateElement_Ssa_TrustModelRootCert_ext_basicConstraints_KEYM_E_KEY_CERT_EMPTY, RTE_E_KeyMCertificateElement_Ssa_TrustModelRootCert_ext_basicConstraints_KEYM_E_KEY_CERT_INVALID, RTE_E_KeyMCertificateElement_Ssa_TrustModelRootCert_ext_basicConstraints_KEYM_E_KEY_CERT_SIZE_MISMATCH, RTE_E_KeyMCertificateElement_Ssa_TrustModelRootCert_ext_basicConstraints_KEYM_E_PARAMETER_MISMATCH
 *   Std_ReturnType Rte_Call_KeyMCertificateElement_Ssa_TrustModelRootCert_ext_keyUsage_CertificateElementGet(uint8 *CertificateElementData, uint32 *CertificateDataLength)
 *     Argument CertificateElementData: uint8* is of type KeyM_CertificateElementType_Ssa_TrustModelRootCert_ext_keyUsage
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_KeyMCertificateElement_Ssa_TrustModelRootCert_ext_keyUsage_E_NOT_OK, RTE_E_KeyMCertificateElement_Ssa_TrustModelRootCert_ext_keyUsage_KEYM_E_KEY_CERT_EMPTY, RTE_E_KeyMCertificateElement_Ssa_TrustModelRootCert_ext_keyUsage_KEYM_E_KEY_CERT_INVALID, RTE_E_KeyMCertificateElement_Ssa_TrustModelRootCert_ext_keyUsage_KEYM_E_KEY_CERT_SIZE_MISMATCH, RTE_E_KeyMCertificateElement_Ssa_TrustModelRootCert_ext_keyUsage_KEYM_E_PARAMETER_MISMATCH
 *   Std_ReturnType Rte_Call_KeyMCertificateElement_Ssa_TrustModelRootCert_ext_subKeyId_CertificateElementGet(uint8 *CertificateElementData, uint32 *CertificateDataLength)
 *     Argument CertificateElementData: uint8* is of type KeyM_CertificateElementType_Ssa_TrustModelRootCert_ext_subKeyId
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_KeyMCertificateElement_Ssa_TrustModelRootCert_ext_subKeyId_E_NOT_OK, RTE_E_KeyMCertificateElement_Ssa_TrustModelRootCert_ext_subKeyId_KEYM_E_KEY_CERT_EMPTY, RTE_E_KeyMCertificateElement_Ssa_TrustModelRootCert_ext_subKeyId_KEYM_E_KEY_CERT_INVALID, RTE_E_KeyMCertificateElement_Ssa_TrustModelRootCert_ext_subKeyId_KEYM_E_KEY_CERT_SIZE_MISMATCH, RTE_E_KeyMCertificateElement_Ssa_TrustModelRootCert_ext_subKeyId_KEYM_E_PARAMETER_MISMATCH
 *   Std_ReturnType Rte_Call_KeyMCertificateElement_Ssa_TrustModelRootCert_subject_CertificateElementGet(uint8 *CertificateElementData, uint32 *CertificateDataLength)
 *     Argument CertificateElementData: uint8* is of type KeyM_CertificateElementType_Ssa_TrustModelRootCert_subject
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_KeyMCertificateElement_Ssa_TrustModelRootCert_subject_E_NOT_OK, RTE_E_KeyMCertificateElement_Ssa_TrustModelRootCert_subject_KEYM_E_KEY_CERT_EMPTY, RTE_E_KeyMCertificateElement_Ssa_TrustModelRootCert_subject_KEYM_E_KEY_CERT_INVALID, RTE_E_KeyMCertificateElement_Ssa_TrustModelRootCert_subject_KEYM_E_KEY_CERT_SIZE_MISMATCH, RTE_E_KeyMCertificateElement_Ssa_TrustModelRootCert_subject_KEYM_E_PARAMETER_MISMATCH
 *   Std_ReturnType Rte_Call_KeyMCertificateElement_Ssa_TrustModelRootCert_validityNotAfter_CertificateElementGet(uint8 *CertificateElementData, uint32 *CertificateDataLength)
 *     Argument CertificateElementData: uint8* is of type KeyM_CertificateElementType_Ssa_TrustModelRootCert_validityNotAfter
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_KeyMCertificateElement_Ssa_TrustModelRootCert_validityNotAfter_E_NOT_OK, RTE_E_KeyMCertificateElement_Ssa_TrustModelRootCert_validityNotAfter_KEYM_E_KEY_CERT_EMPTY, RTE_E_KeyMCertificateElement_Ssa_TrustModelRootCert_validityNotAfter_KEYM_E_KEY_CERT_INVALID, RTE_E_KeyMCertificateElement_Ssa_TrustModelRootCert_validityNotAfter_KEYM_E_KEY_CERT_SIZE_MISMATCH, RTE_E_KeyMCertificateElement_Ssa_TrustModelRootCert_validityNotAfter_KEYM_E_PARAMETER_MISMATCH
 *   Std_ReturnType Rte_Call_KeyMCertificate_Ssa_TrustModelBackendPeerCert_GetStatus(KeyM_CertificateStatusType *Status)
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_KeyMCertificate_Ssa_TrustModelBackendPeerCert_E_NOT_OK
 *   Std_ReturnType Rte_Call_KeyMCertificate_Ssa_TrustModelEcuPeerCert_GetStatus(KeyM_CertificateStatusType *Status)
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_KeyMCertificate_Ssa_TrustModelEcuPeerCert_E_NOT_OK
 *   Std_ReturnType Rte_Call_KeyMCertificate_Ssa_TrustModelEcuPeerCert_VerifyCertificate(void)
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_KeyMCertificate_Ssa_TrustModelEcuPeerCert_E_NOT_OK, RTE_E_KeyMCertificate_Ssa_TrustModelEcuPeerCert_KEYM_E_BUSY, RTE_E_KeyMCertificate_Ssa_TrustModelEcuPeerCert_KEYM_E_CERT_INVALID_CHAIN_OF_TRUST, RTE_E_KeyMCertificate_Ssa_TrustModelEcuPeerCert_KEYM_E_KEY_CERT_EMPTY, RTE_E_KeyMCertificate_Ssa_TrustModelEcuPeerCert_KEYM_E_KEY_CERT_SIZE_MISMATCH, RTE_E_KeyMCertificate_Ssa_TrustModelEcuPeerCert_KEYM_E_PARAMETER_MISMATCH
 *   Std_ReturnType Rte_Call_KeyMCertificate_Ssa_TrustModelIntermediatePeerCert_GetStatus(KeyM_CertificateStatusType *Status)
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_KeyMCertificate_Ssa_TrustModelIntermediatePeerCert_E_NOT_OK
 *   Std_ReturnType Rte_Call_Key_AesRamKey_KeyElementSet(uint32 keyElementId, const uint8 *keyPtr, uint32 keyLength)
 *     Argument keyPtr: uint8* is of type Csm_KeyDataType_Ssa_AesRamKey
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_CsmKeyManagement_Ssa_AesRamKey_CSM_E_BUSY, RTE_E_CsmKeyManagement_Ssa_AesRamKey_CSM_E_KEY_NOT_AVAILABLE, RTE_E_CsmKeyManagement_Ssa_AesRamKey_CSM_E_KEY_SIZE_MISMATCH, RTE_E_CsmKeyManagement_Ssa_AesRamKey_CSM_E_KEY_WRITE_FAIL, RTE_E_CsmKeyManagement_Ssa_AesRamKey_CSM_E_SMALL_BUFFER, RTE_E_CsmKeyManagement_Ssa_AesRamKey_E_NOT_OK
 *   Std_ReturnType Rte_Call_Key_AesRamKey_KeySetValid(void)
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_CsmKeyManagement_Ssa_AesRamKey_CSM_E_BUSY, RTE_E_CsmKeyManagement_Ssa_AesRamKey_E_NOT_OK
 *   Std_ReturnType Rte_Call_Key_SharedSecretKeyExchange_KeyElementGet(uint32 keyElementId, uint8 *keyPtr, uint32 *keyLength)
 *     Argument keyPtr: uint8* is of type Csm_KeyDataType_Ssa_SharedSecretKeyExchange
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_CsmKeyManagement_Ssa_SharedSecretKeyExchange_CSM_E_BUSY, RTE_E_CsmKeyManagement_Ssa_SharedSecretKeyExchange_CSM_E_KEY_EMPTY, RTE_E_CsmKeyManagement_Ssa_SharedSecretKeyExchange_CSM_E_KEY_NOT_AVAILABLE, RTE_E_CsmKeyManagement_Ssa_SharedSecretKeyExchange_CSM_E_KEY_READ_FAIL, RTE_E_CsmKeyManagement_Ssa_SharedSecretKeyExchange_CSM_E_SMALL_BUFFER, RTE_E_CsmKeyManagement_Ssa_SharedSecretKeyExchange_E_NOT_OK
 *   Std_ReturnType Rte_Call_Key_SharedSecretKeyExchange_KeyElementSet(uint32 keyElementId, const uint8 *keyPtr, uint32 keyLength)
 *     Argument keyPtr: uint8* is of type Csm_KeyDataType_Ssa_SharedSecretKeyExchange
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_CsmKeyManagement_Ssa_SharedSecretKeyExchange_CSM_E_BUSY, RTE_E_CsmKeyManagement_Ssa_SharedSecretKeyExchange_CSM_E_KEY_NOT_AVAILABLE, RTE_E_CsmKeyManagement_Ssa_SharedSecretKeyExchange_CSM_E_KEY_SIZE_MISMATCH, RTE_E_CsmKeyManagement_Ssa_SharedSecretKeyExchange_CSM_E_KEY_WRITE_FAIL, RTE_E_CsmKeyManagement_Ssa_SharedSecretKeyExchange_CSM_E_SMALL_BUFFER, RTE_E_CsmKeyManagement_Ssa_SharedSecretKeyExchange_E_NOT_OK
 *   Std_ReturnType Rte_Call_Key_SharedSecretKeyExchange_KeyExchangeCalcSecret(const uint8 *partnerPublicValuePtr, uint32 partnerPublicValueLength)
 *     Argument partnerPublicValuePtr: uint8* is of type Csm_PublicValueDataType_Ssa_SharedSecretKeyExchange
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_CsmKeyManagement_Ssa_SharedSecretKeyExchange_CSM_E_BUSY, RTE_E_CsmKeyManagement_Ssa_SharedSecretKeyExchange_CSM_E_KEY_EMPTY, RTE_E_CsmKeyManagement_Ssa_SharedSecretKeyExchange_CSM_E_SMALL_BUFFER, RTE_E_CsmKeyManagement_Ssa_SharedSecretKeyExchange_E_NOT_OK
 *   Std_ReturnType Rte_Call_Key_SharedSecretKeyExchange_KeySetValid(void)
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_CsmKeyManagement_Ssa_SharedSecretKeyExchange_CSM_E_BUSY, RTE_E_CsmKeyManagement_Ssa_SharedSecretKeyExchange_E_NOT_OK
 *   Std_ReturnType Rte_Call_Key_SignatureRamKey_KeyElementSet(uint32 keyElementId, const uint8 *keyPtr, uint32 keyLength)
 *     Argument keyPtr: uint8* is of type Csm_KeyDataType_Ssa_SignatureRamKey
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_CsmKeyManagement_Ssa_SignatureRamKey_CSM_E_BUSY, RTE_E_CsmKeyManagement_Ssa_SignatureRamKey_CSM_E_KEY_NOT_AVAILABLE, RTE_E_CsmKeyManagement_Ssa_SignatureRamKey_CSM_E_KEY_SIZE_MISMATCH, RTE_E_CsmKeyManagement_Ssa_SignatureRamKey_CSM_E_KEY_WRITE_FAIL, RTE_E_CsmKeyManagement_Ssa_SignatureRamKey_CSM_E_SMALL_BUFFER, RTE_E_CsmKeyManagement_Ssa_SignatureRamKey_E_NOT_OK
 *   Std_ReturnType Rte_Call_Key_SignatureRamKey_KeySetValid(void)
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_CsmKeyManagement_Ssa_SignatureRamKey_CSM_E_BUSY, RTE_E_CsmKeyManagement_Ssa_SignatureRamKey_E_NOT_OK
 *
 * Exclusive Area Access:
 * ======================
 *   void Rte_Enter_KeyM_ExclusiveArea(void)
 *   void Rte_Exit_KeyM_ExclusiveArea(void)
 *
 **********************************************************************************************************************
 *
 * Runnable prototype:
 * ===================
 *   Std_ReturnType Ssa_KeyM_RoutineServices_Trust_Model_SecOC_ECU_Shared_Secret_Distribution(const uint8 *Date_and_Time_In, const uint8 *Tick_Count_In, const uint8 *Tick_Count_Offset_In, const uint8 *Encrypted_Nonce_and_Shared_Secret_In, const uint8 *Ephemeral_VSM_Public_Key_In, const uint8 *Data_Signature_In, const uint8 *Certificates_In, Dcm_OpStatusType OpStatus, uint8 *routineInfo_Out, uint8 *Verification_Result_Out, uint16 DataLength, Dcm_NegativeResponseCodeType *ErrorCode)
 *     Argument Date_and_Time_In: uint8* is of type Dcm_Data7ByteType
 *     Argument Tick_Count_In: uint8* is of type Dcm_Data5ByteType
 *     Argument Tick_Count_Offset_In: uint8* is of type Dcm_Data5ByteType
 *     Argument Encrypted_Nonce_and_Shared_Secret_In: uint8* is of type Dcm_Data80ByteType
 *     Argument Ephemeral_VSM_Public_Key_In: uint8* is of type Dcm_Data32ByteType
 *     Argument Data_Signature_In: uint8* is of type Dcm_Data64ByteType
 *     Argument Certificates_In: uint8* is of type Dcm_Data3006ByteType
 *
 **********************************************************************************************************************
 *
 * Available Application Errors:
 * =============================
 *   RTE_E_RoutineServices_Trust_Model_SecOC_ECU_Shared_Secret_Distribution_DCM_E_FORCE_RCRRP
 *   RTE_E_RoutineServices_Trust_Model_SecOC_ECU_Shared_Secret_Distribution_DCM_E_PENDING
 *   RTE_E_RoutineServices_Trust_Model_SecOC_ECU_Shared_Secret_Distribution_E_NOT_OK
 *
 *********************************************************************************************************************/
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << Start of documentation area >>                  DO NOT CHANGE THIS COMMENT!
 * Symbol: Ssa_KeyM_RoutineServices_Trust_Model_SecOC_ECU_Shared_Secret_Distribution_doc
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << End of documentation area >>                    DO NOT CHANGE THIS COMMENT!
 *********************************************************************************************************************/

FUNC(Std_ReturnType, Ssa_KeyM_CODE) Ssa_KeyM_RoutineServices_Trust_Model_SecOC_ECU_Shared_Secret_Distribution(
  P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) Date_and_Time_In,
  P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) Tick_Count_In,
  P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) Tick_Count_Offset_In,
  P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) Encrypted_Nonce_and_Shared_Secret_In,
  P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) Ephemeral_VSM_Public_Key_In,
  P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) Data_Signature_In,
  P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) Certificates_In,
  Dcm_OpStatusType OpStatus,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) routineInfo_Out,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) Verification_Result_Out,
  uint16 DataLength,
  P2VAR(Dcm_NegativeResponseCodeType, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) ErrorCode) /* PRQA S 0624, 3206 */ /* MD_Rte_0624, MD_Rte_3206 */
{
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << Start of runnable implementation >>             DO NOT CHANGE THIS COMMENT!
 * Symbol: Ssa_KeyM_RoutineServices_Trust_Model_SecOC_ECU_Shared_Secret_Distribution (returns application error)
 *********************************************************************************************************************/

  Std_ReturnType retVal = RTE_E_RoutineServices_Trust_Model_SecOC_ECU_Shared_Secret_Distribution_E_NOT_OK;

  /* ----- Development Error Checks ------------------------------------- */
# if (SSA_DEV_ERROR_DETECT == STD_ON)
  if ((Date_and_Time_In == NULL_PTR)
    || (Tick_Count_In == NULL_PTR)
    || (Tick_Count_Offset_In == NULL_PTR)
    || (Encrypted_Nonce_and_Shared_Secret_In == NULL_PTR)
    || (Ephemeral_VSM_Public_Key_In == NULL_PTR)
    || (Data_Signature_In == NULL_PTR)
    || (Certificates_In == NULL_PTR)
    || (routineInfo_Out == NULL_PTR)
    || (Verification_Result_Out == NULL_PTR)
    || (ErrorCode == NULL_PTR))
  {
    /* retVal already set */
  }
  else
# endif /* SSA_DEV_ERROR_DETECT == STD_ON */
  {
    /* #10 Generate the SecOC keys after decryption of the distributed, encrypted car-specific secret
     *     and adopt the provided time information.
     *     Go to idle state if service is canceled by DCM.
     *     Proceed only if state is valid. */

    if (OpStatus == DCM_CANCEL)
    {
      /* back to idle state */
      KeyM_DiagProc.state = KEYM_ROUTINE_SECOC_ECU_SHARED_SECRET_DIST_STATE_IDLE;
      retVal = RTE_E_OK;
      /* use default verification result */
    }
    else if (!KeyM_IsSecOcEcuSharedSecretDistStateValid())
    {
      /* back to idle state */
      KeyM_DiagProc.state = KEYM_ROUTINE_SECOC_ECU_SHARED_SECRET_DIST_STATE_IDLE;
      KeyM_DiagProc.ws.trustModelCommissioning.errorCode = DCM_E_GENERALREJECT;
    }
    else
    {
      if (OpStatus == DCM_INITIAL)
      {
        /* Initialize flags, indices and length values for this routine. */
        KeyM_DiagProc.ws.trustModelCommissioning.KeyM_RoutineCtrlDataLengthOut = 0u;
        /* Initialize verification result with any result != 0. */
        KeyM_DiagProc.ws.trustModelCommissioning.verificationResult = SSA_VER_RES_TRUST_MODEL_SECOC_CSS_ENCRYPT_ECU_CERTIFICATE_VERIFICATION_FAILED_INVALID_TIME_PERIOD;
        KeyM_DiagProc.ws.trustModelCommissioning.errorCode = DCM_E_GENERALREJECT;
      }

      /* #20 Handle the following states:
       *     KEYM_ROUTINE_SECOC_ECU_SHARED_SECRET_DIST_STATE_IDLE,             (verify certificates, get nonce stored on ECU)
       *     KEYM_ROUTINE_SECOC_ECU_SHARED_SECRET_DIST_STATE_VERIFY_SIGNATURE,
       *     KEYM_ROUTINE_SECOC_ECU_SHARED_SECRET_DIST_STATE_KEYEXCHANGE_DECRYPT,
       *     KEYM_ROUTINE_SECOC_ECU_SHARED_SECRET_DIST_STATE_DERIVE_SECOC_KEYS,
       *     KEYM_ROUTINE_SECOC_ECU_SHARED_SECRET_DIST_STATE_WAIT_AND_SET_NEW_TIME,
       *     KEYM_ROUTINE_SECOC_ECU_SHARED_SECRET_DIST_STATE_DESTROY_NONCE. */
      retVal = KeyM_Shared_Secret_Distribution_State_Handler[KeyM_DiagProc.state](
        Date_and_Time_In,
        Tick_Count_In,
        Tick_Count_Offset_In,
        Encrypted_Nonce_and_Shared_Secret_In,
        Ephemeral_VSM_Public_Key_In,
        Data_Signature_In,
        Certificates_In,
        DataLength);
    }

    /* #30 Set verification result and error code depending on the return value. */
    if (retVal != RTE_E_RoutineServices_Trust_Model_SecOC_ECU_Shared_Secret_Distribution_DCM_E_PENDING)
    {
      /* Clear temporary buffer containing among other things the decrypted secret. */
      KeyM_ClearDataBuffer(KeyM_DiagProc.ws.trustModelCommissioning.KeyM_SharedSecretEncDec_DataBuffer, SSA_KEYM_DIS_BUFFER_SIZE, SSA_KEYM_DIS_BUFFER_SIZE);

      *routineInfo_Out = SSA_ROUTINE_INFO_SUCCESFULLY_COMPLETED;

      /* check for positive or negative response and set either verification result or NRC */
      if (retVal == RTE_E_OK)
      {
        *Verification_Result_Out = KeyM_DiagProc.ws.trustModelCommissioning.verificationResult;
        /* #40 If the service is finished write the security log for event "successful diagnostic service execution"
         *     for use case "SecOC ECU Shared Secret Distribution" */
        (void)Rte_Call_SecLog_SuccessfulDiagServiceExecutionEvent_TrustModelEcuSharedSecretDistribution_SuccessfulDiagServiceExecution(
          (uint8)KeyM_DiagProc.ws.trustModelCommissioning.verificationResult);
      }
      else
      {
        *ErrorCode = KeyM_DiagProc.ws.trustModelCommissioning.errorCode;
      }

      /* back to idle state */
      KeyM_DiagProc.state = KEYM_ROUTINE_SECOC_ECU_SHARED_SECRET_DIST_STATE_IDLE;
    }
  }

  return retVal;

/* PRQA S 6010, 6030, 6050, 6060, 6080 4 */ /* MD_MSR_STPTH, MD_MSR_STCYC, MD_MSR_STCAL, MD_SSA_STPAR, MD_MSR_STMIF */
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << End of runnable implementation >>               DO NOT CHANGE THIS COMMENT!
 *********************************************************************************************************************/
}

#else

/**********************************************************************************************************************
 *
 * Runnable Entity Name: Ssa_KeyM_RoutineServices_Trust_Model_SecOC_ECU_Shared_Secret_Encryption
 *
 *---------------------------------------------------------------------------------------------------------------------
 *
 * Executed if at least one of the following trigger conditions occurred:
 *   - triggered by server invocation for OperationPrototype <Start> of PortPrototype <RoutineServices_Trust_Model_SecOC_ECU_Shared_Secret_Encryption>
 *
 **********************************************************************************************************************
 *
 * Client/Server Interfaces:
 * =========================
 *   Server Invocation:
 *   ------------------
 *   Std_ReturnType Rte_Call_CertP_Functions_ParseTime(const uint8 *data, uint16 dataLength, TimeM_DateTimeType *dateTime)
 *     Argument data: uint8* is of type Ssa_Data15ByteType
 *     Synchronous Server Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_CertP_Functions_E_NOT_OK
 *   Std_ReturnType Rte_Call_RightsM_DiagnosticChannel_GetDiagnosticUserRole(RightsM_DiagnosticUserRoleType *userRole)
 *     Synchronous Server Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_RightsM_DiagnosticChannel_E_NOT_OK
 *   Std_ReturnType Rte_Call_RightsM_DiagnosticChannel_GetPostProductionStatus(Ssa_PostProductionStatusType *status)
 *     Synchronous Server Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_RightsM_DiagnosticChannel_E_NOT_OK
 *   Std_ReturnType Rte_Call_RightsM_EnhancedRights_VerifySubjectKeyIdentifier(const uint8 *subjectKeyIdentifier)
 *     Argument subjectKeyIdentifier: uint8* is of type Ssa_Data20ByteType
 *     Synchronous Server Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_RightsM_EnhancedRights_E_NOT_OK
 *   Std_ReturnType Rte_Call_SecLog_FailedCertVerificationEvent_FailedCertificateVerification(CertP_PkiRoleType pkiRole, CertP_VerificationResultType validationResult)
 *     Synchronous Server Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_SecLog_FailedCertVerificationEvent_E_NOT_OK
 *   Std_ReturnType Rte_Call_SecLog_SuccessfulCertVerificationEvent_SuccessfulCertificateVerification(const uint8 *certId, CertP_PkiRoleType pkiRole)
 *     Argument certId: uint8* is of type RightsM_SerialNumberType
 *     Synchronous Server Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_SecLog_SuccessfulCertVerificationEvent_E_NOT_OK
 *   Std_ReturnType Rte_Call_SecLog_SuccessfulDiagServiceExecutionEvent_TrustModelEcuSharedSecretEncryption_SuccessfulDiagServiceExecution(uint8 additionalInfo)
 *     Synchronous Server Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_SecLog_SuccessfulDiagServiceExecutionEvent_E_NOT_OK
 *   Std_ReturnType Rte_Call_SsaCdd_Csm_Hash(uint32 jobId, Crypto_OperationModeType operationMode, Ssa_ConstDataPtr dataBuffer, uint32 dataLength, Ssa_DataPtr resultBuffer, Ssa_LengthPtr resultLength)
 *     Synchronous Server Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_SsaCdd_CryptoInterface_E_NOT_OK
 *   Std_ReturnType Rte_Call_SsaCdd_Csm_SignatureGenerate(uint32 jobId, Crypto_OperationModeType operationMode, Ssa_ConstDataPtr dataBuffer, uint32 dataLength, Ssa_DataPtr resultBuffer, Ssa_LengthPtr resultLength)
 *     Synchronous Server Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_SsaCdd_CryptoInterface_E_NOT_OK
 *   Std_ReturnType Rte_Call_SsaCdd_Csm_SignatureVerify(uint32 jobId, Crypto_OperationModeType operationMode, Ssa_ConstDataPtr dataBuffer, uint32 dataLength, Ssa_ConstDataPtr compareBuffer, uint32 compareLength, Ssa_VerifyResultPtr resultBuffer)
 *     Synchronous Server Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_SsaCdd_CryptoInterface_E_NOT_OK
 *   Std_ReturnType Rte_Call_SsaCdd_TrustModel_SetCertificate(KeyM_CertificateIdType CertId, Ssa_DataPtr CertData, uint32 CertDataLength)
 *     Synchronous Server Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_SsaCdd_KeyM_CertInterface_E_NOT_OK, RTE_E_SsaCdd_KeyM_CertInterface_KEYM_E_KEY_CERT_SIZE_MISMATCH, RTE_E_SsaCdd_KeyM_CertInterface_KEYM_E_PARAMETER_MISMATCH
 *   Std_ReturnType Rte_Call_Ssa_KeyProc_PrepareKeyExchange(Ssa_OpStatusType opStatus, uint32 keyId)
 *     Synchronous Server Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_Ssa_KeyProc_E_NOT_OK, RTE_E_Ssa_KeyProc_E_PENDING
 *   Std_ReturnType Rte_Call_TimeM_TimeRawData_Get(uint8 *dateTimeOffset, uint8 *tickCountOffset, uint8 *tickCount)
 *     Argument dateTimeOffset: uint8* is of type Ssa_Data7ByteType
 *     Argument tickCountOffset: uint8* is of type Ssa_Data5ByteType
 *     Argument tickCount: uint8* is of type Ssa_Data5ByteType
 *     Synchronous Server Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_TimeM_TimeRawData_E_NOT_OK
 *
 * Service Calls:
 * ==============
 *   Service Invocation:
 *   -------------------
 *   Std_ReturnType Rte_Call_CsmJobKeyExchangeCalcPubVal_KeyExchangeCalcPubVal(uint32 key, Csm_DataPtr publicValuePtr, Csm_LengthPtr publicValueLengthPtr)
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_CsmJobKeyExchangeCalcPubVal_CSM_E_BUSY, RTE_E_CsmJobKeyExchangeCalcPubVal_CSM_E_KEY_EMPTY, RTE_E_CsmJobKeyExchangeCalcPubVal_CSM_E_SMALL_BUFFER, RTE_E_CsmJobKeyExchangeCalcPubVal_E_NOT_OK
 *   Std_ReturnType Rte_Call_CsmJobKeyExchangeCalcSecret_KeyExchangeCalcSecret(uint32 key, Csm_const_DataPtr partnerPublicValuePtr, uint32 partnerPublicValueLength)
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_CsmJobKeyExchangeCalcSecret_CSM_E_BUSY, RTE_E_CsmJobKeyExchangeCalcSecret_CSM_E_KEY_EMPTY, RTE_E_CsmJobKeyExchangeCalcSecret_CSM_E_SMALL_BUFFER, RTE_E_CsmJobKeyExchangeCalcSecret_E_NOT_OK
 *   Std_ReturnType Rte_Call_CsmRandomGenerate_RandomGenerate(uint8 *resultBuffer, uint32 *resultLength)
 *     Argument resultBuffer: uint8* is of type Csm_RandomGenerateResultType_Random
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_CsmRandomGenerate_Random_CSM_E_BUSY, RTE_E_CsmRandomGenerate_Random_CSM_E_ENTROPY_EXHAUSTION, RTE_E_CsmRandomGenerate_Random_E_NOT_OK
 *   Std_ReturnType Rte_Call_CsmSymAES128Encrypt_Encrypt(const uint8 *dataBuffer, uint32 dataLength, uint8 *resultBuffer, uint32 *resultLength)
 *     Argument dataBuffer: uint8* is of type Csm_EncryptDataType_AES128Encrypt
 *     Argument resultBuffer: uint8* is of type Csm_EncryptResultType_AES128Encrypt
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_CsmEncrypt_AES128Encrypt_CSM_E_BUSY, RTE_E_CsmEncrypt_AES128Encrypt_CSM_E_KEY_EMPTY, RTE_E_CsmEncrypt_AES128Encrypt_CSM_E_KEY_NOT_VALID, RTE_E_CsmEncrypt_AES128Encrypt_CSM_E_KEY_SIZE_MISMATCH, RTE_E_CsmEncrypt_AES128Encrypt_CSM_E_SMALL_BUFFER, RTE_E_CsmEncrypt_AES128Encrypt_E_NOT_OK
 *   Std_ReturnType Rte_Call_KeyMCertificateElement_Ssa_TrustModelBackendPeerCert_SerialNo_CertificateElementGet(uint8 *CertificateElementData, uint32 *CertificateDataLength)
 *     Argument CertificateElementData: uint8* is of type KeyM_CertificateElementType_Ssa_TrustModelBackendPeerCert_SerialNo
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_KeyMCertificateElement_Ssa_TrustModelBackendPeerCert_SerialNo_E_NOT_OK, RTE_E_KeyMCertificateElement_Ssa_TrustModelBackendPeerCert_SerialNo_KEYM_E_KEY_CERT_EMPTY, RTE_E_KeyMCertificateElement_Ssa_TrustModelBackendPeerCert_SerialNo_KEYM_E_KEY_CERT_INVALID, RTE_E_KeyMCertificateElement_Ssa_TrustModelBackendPeerCert_SerialNo_KEYM_E_KEY_CERT_SIZE_MISMATCH, RTE_E_KeyMCertificateElement_Ssa_TrustModelBackendPeerCert_SerialNo_KEYM_E_PARAMETER_MISMATCH
 *   Std_ReturnType Rte_Call_KeyMCertificateElement_Ssa_TrustModelBackendPeerCert_Version_CertificateElementGet(uint8 *CertificateElementData, uint32 *CertificateDataLength)
 *     Argument CertificateElementData: uint8* is of type KeyM_CertificateElementType_Ssa_TrustModelBackendPeerCert_Version
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_KeyMCertificateElement_Ssa_TrustModelBackendPeerCert_Version_E_NOT_OK, RTE_E_KeyMCertificateElement_Ssa_TrustModelBackendPeerCert_Version_KEYM_E_KEY_CERT_EMPTY, RTE_E_KeyMCertificateElement_Ssa_TrustModelBackendPeerCert_Version_KEYM_E_KEY_CERT_INVALID, RTE_E_KeyMCertificateElement_Ssa_TrustModelBackendPeerCert_Version_KEYM_E_KEY_CERT_SIZE_MISMATCH, RTE_E_KeyMCertificateElement_Ssa_TrustModelBackendPeerCert_Version_KEYM_E_PARAMETER_MISMATCH
 *   Std_ReturnType Rte_Call_KeyMCertificateElement_Ssa_TrustModelBackendPeerCert_ext_authKeyId_CertificateElementGet(uint8 *CertificateElementData, uint32 *CertificateDataLength)
 *     Argument CertificateElementData: uint8* is of type KeyM_CertificateElementType_Ssa_TrustModelBackendPeerCert_ext_authKeyId
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_KeyMCertificateElement_Ssa_TrustModelBackendPeerCert_ext_authKeyId_E_NOT_OK, RTE_E_KeyMCertificateElement_Ssa_TrustModelBackendPeerCert_ext_authKeyId_KEYM_E_KEY_CERT_EMPTY, RTE_E_KeyMCertificateElement_Ssa_TrustModelBackendPeerCert_ext_authKeyId_KEYM_E_KEY_CERT_INVALID, RTE_E_KeyMCertificateElement_Ssa_TrustModelBackendPeerCert_ext_authKeyId_KEYM_E_KEY_CERT_SIZE_MISMATCH, RTE_E_KeyMCertificateElement_Ssa_TrustModelBackendPeerCert_ext_authKeyId_KEYM_E_PARAMETER_MISMATCH
 *   Std_ReturnType Rte_Call_KeyMCertificateElement_Ssa_TrustModelBackendPeerCert_ext_basicConstraints_CertificateElementGet(uint8 *CertificateElementData, uint32 *CertificateDataLength)
 *     Argument CertificateElementData: uint8* is of type KeyM_CertificateElementType_Ssa_TrustModelBackendPeerCert_ext_basicConstraints
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_KeyMCertificateElement_Ssa_TrustModelBackendPeerCert_ext_basicConstraints_E_NOT_OK, RTE_E_KeyMCertificateElement_Ssa_TrustModelBackendPeerCert_ext_basicConstraints_KEYM_E_KEY_CERT_EMPTY, RTE_E_KeyMCertificateElement_Ssa_TrustModelBackendPeerCert_ext_basicConstraints_KEYM_E_KEY_CERT_INVALID, RTE_E_KeyMCertificateElement_Ssa_TrustModelBackendPeerCert_ext_basicConstraints_KEYM_E_KEY_CERT_SIZE_MISMATCH, RTE_E_KeyMCertificateElement_Ssa_TrustModelBackendPeerCert_ext_basicConstraints_KEYM_E_PARAMETER_MISMATCH
 *   Std_ReturnType Rte_Call_KeyMCertificateElement_Ssa_TrustModelBackendPeerCert_ext_subKeyId_CertificateElementGet(uint8 *CertificateElementData, uint32 *CertificateDataLength)
 *     Argument CertificateElementData: uint8* is of type KeyM_CertificateElementType_Ssa_TrustModelBackendPeerCert_ext_subKeyId
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_KeyMCertificateElement_Ssa_TrustModelBackendPeerCert_ext_subKeyId_E_NOT_OK, RTE_E_KeyMCertificateElement_Ssa_TrustModelBackendPeerCert_ext_subKeyId_KEYM_E_KEY_CERT_EMPTY, RTE_E_KeyMCertificateElement_Ssa_TrustModelBackendPeerCert_ext_subKeyId_KEYM_E_KEY_CERT_INVALID, RTE_E_KeyMCertificateElement_Ssa_TrustModelBackendPeerCert_ext_subKeyId_KEYM_E_KEY_CERT_SIZE_MISMATCH, RTE_E_KeyMCertificateElement_Ssa_TrustModelBackendPeerCert_ext_subKeyId_KEYM_E_PARAMETER_MISMATCH
 *   Std_ReturnType Rte_Call_KeyMCertificateElement_Ssa_TrustModelBackendPeerCert_validityNotAfter_CertificateElementGet(uint8 *CertificateElementData, uint32 *CertificateDataLength)
 *     Argument CertificateElementData: uint8* is of type KeyM_CertificateElementType_Ssa_TrustModelBackendPeerCert_validityNotAfter
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_KeyMCertificateElement_Ssa_TrustModelBackendPeerCert_validityNotAfter_E_NOT_OK, RTE_E_KeyMCertificateElement_Ssa_TrustModelBackendPeerCert_validityNotAfter_KEYM_E_KEY_CERT_EMPTY, RTE_E_KeyMCertificateElement_Ssa_TrustModelBackendPeerCert_validityNotAfter_KEYM_E_KEY_CERT_INVALID, RTE_E_KeyMCertificateElement_Ssa_TrustModelBackendPeerCert_validityNotAfter_KEYM_E_KEY_CERT_SIZE_MISMATCH, RTE_E_KeyMCertificateElement_Ssa_TrustModelBackendPeerCert_validityNotAfter_KEYM_E_PARAMETER_MISMATCH
 *   Std_ReturnType Rte_Call_KeyMCertificateElement_Ssa_TrustModelEcuPeerCert_SerialNo_CertificateElementGet(uint8 *CertificateElementData, uint32 *CertificateDataLength)
 *     Argument CertificateElementData: uint8* is of type KeyM_CertificateElementType_Ssa_TrustModelEcuPeerCert_SerialNo
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_KeyMCertificateElement_Ssa_TrustModelEcuPeerCert_SerialNo_E_NOT_OK, RTE_E_KeyMCertificateElement_Ssa_TrustModelEcuPeerCert_SerialNo_KEYM_E_KEY_CERT_EMPTY, RTE_E_KeyMCertificateElement_Ssa_TrustModelEcuPeerCert_SerialNo_KEYM_E_KEY_CERT_INVALID, RTE_E_KeyMCertificateElement_Ssa_TrustModelEcuPeerCert_SerialNo_KEYM_E_KEY_CERT_SIZE_MISMATCH, RTE_E_KeyMCertificateElement_Ssa_TrustModelEcuPeerCert_SerialNo_KEYM_E_PARAMETER_MISMATCH
 *   Std_ReturnType Rte_Call_KeyMCertificateElement_Ssa_TrustModelEcuPeerCert_Version_CertificateElementGet(uint8 *CertificateElementData, uint32 *CertificateDataLength)
 *     Argument CertificateElementData: uint8* is of type KeyM_CertificateElementType_Ssa_TrustModelEcuPeerCert_Version
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_KeyMCertificateElement_Ssa_TrustModelEcuPeerCert_Version_E_NOT_OK, RTE_E_KeyMCertificateElement_Ssa_TrustModelEcuPeerCert_Version_KEYM_E_KEY_CERT_EMPTY, RTE_E_KeyMCertificateElement_Ssa_TrustModelEcuPeerCert_Version_KEYM_E_KEY_CERT_INVALID, RTE_E_KeyMCertificateElement_Ssa_TrustModelEcuPeerCert_Version_KEYM_E_KEY_CERT_SIZE_MISMATCH, RTE_E_KeyMCertificateElement_Ssa_TrustModelEcuPeerCert_Version_KEYM_E_PARAMETER_MISMATCH
 *   Std_ReturnType Rte_Call_KeyMCertificateElement_Ssa_TrustModelEcuPeerCert_ext_authKeyId_CertificateElementGet(uint8 *CertificateElementData, uint32 *CertificateDataLength)
 *     Argument CertificateElementData: uint8* is of type KeyM_CertificateElementType_Ssa_TrustModelEcuPeerCert_ext_authKeyId
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_KeyMCertificateElement_Ssa_TrustModelEcuPeerCert_ext_authKeyId_E_NOT_OK, RTE_E_KeyMCertificateElement_Ssa_TrustModelEcuPeerCert_ext_authKeyId_KEYM_E_KEY_CERT_EMPTY, RTE_E_KeyMCertificateElement_Ssa_TrustModelEcuPeerCert_ext_authKeyId_KEYM_E_KEY_CERT_INVALID, RTE_E_KeyMCertificateElement_Ssa_TrustModelEcuPeerCert_ext_authKeyId_KEYM_E_KEY_CERT_SIZE_MISMATCH, RTE_E_KeyMCertificateElement_Ssa_TrustModelEcuPeerCert_ext_authKeyId_KEYM_E_PARAMETER_MISMATCH
 *   Std_ReturnType Rte_Call_KeyMCertificateElement_Ssa_TrustModelEcuPeerCert_ext_specialEcu_CertificateElementGet(uint8 *CertificateElementData, uint32 *CertificateDataLength)
 *     Argument CertificateElementData: uint8* is of type KeyM_CertificateElementType_Ssa_TrustModelEcuPeerCert_ext_specialEcu
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_KeyMCertificateElement_Ssa_TrustModelEcuPeerCert_ext_specialEcu_E_NOT_OK, RTE_E_KeyMCertificateElement_Ssa_TrustModelEcuPeerCert_ext_specialEcu_KEYM_E_KEY_CERT_EMPTY, RTE_E_KeyMCertificateElement_Ssa_TrustModelEcuPeerCert_ext_specialEcu_KEYM_E_KEY_CERT_INVALID, RTE_E_KeyMCertificateElement_Ssa_TrustModelEcuPeerCert_ext_specialEcu_KEYM_E_KEY_CERT_SIZE_MISMATCH, RTE_E_KeyMCertificateElement_Ssa_TrustModelEcuPeerCert_ext_specialEcu_KEYM_E_PARAMETER_MISMATCH
 *   Std_ReturnType Rte_Call_KeyMCertificateElement_Ssa_TrustModelEcuPeerCert_ext_subKeyId_CertificateElementGet(uint8 *CertificateElementData, uint32 *CertificateDataLength)
 *     Argument CertificateElementData: uint8* is of type KeyM_CertificateElementType_Ssa_TrustModelEcuPeerCert_ext_subKeyId
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_KeyMCertificateElement_Ssa_TrustModelEcuPeerCert_ext_subKeyId_E_NOT_OK, RTE_E_KeyMCertificateElement_Ssa_TrustModelEcuPeerCert_ext_subKeyId_KEYM_E_KEY_CERT_EMPTY, RTE_E_KeyMCertificateElement_Ssa_TrustModelEcuPeerCert_ext_subKeyId_KEYM_E_KEY_CERT_INVALID, RTE_E_KeyMCertificateElement_Ssa_TrustModelEcuPeerCert_ext_subKeyId_KEYM_E_KEY_CERT_SIZE_MISMATCH, RTE_E_KeyMCertificateElement_Ssa_TrustModelEcuPeerCert_ext_subKeyId_KEYM_E_PARAMETER_MISMATCH
 *   Std_ReturnType Rte_Call_KeyMCertificateElement_Ssa_TrustModelEcuPeerCert_validityNotAfter_CertificateElementGet(uint8 *CertificateElementData, uint32 *CertificateDataLength)
 *     Argument CertificateElementData: uint8* is of type KeyM_CertificateElementType_Ssa_TrustModelEcuPeerCert_validityNotAfter
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_KeyMCertificateElement_Ssa_TrustModelEcuPeerCert_validityNotAfter_E_NOT_OK, RTE_E_KeyMCertificateElement_Ssa_TrustModelEcuPeerCert_validityNotAfter_KEYM_E_KEY_CERT_EMPTY, RTE_E_KeyMCertificateElement_Ssa_TrustModelEcuPeerCert_validityNotAfter_KEYM_E_KEY_CERT_INVALID, RTE_E_KeyMCertificateElement_Ssa_TrustModelEcuPeerCert_validityNotAfter_KEYM_E_KEY_CERT_SIZE_MISMATCH, RTE_E_KeyMCertificateElement_Ssa_TrustModelEcuPeerCert_validityNotAfter_KEYM_E_PARAMETER_MISMATCH
 *   Std_ReturnType Rte_Call_KeyMCertificateElement_Ssa_TrustModelIntermediatePeerCert_SerialNo_CertificateElementGet(uint8 *CertificateElementData, uint32 *CertificateDataLength)
 *     Argument CertificateElementData: uint8* is of type KeyM_CertificateElementType_Ssa_TrustModelIntermediatePeerCert_SerialNo
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_KeyMCertificateElement_Ssa_TrustModelIntermediatePeerCert_SerialNo_E_NOT_OK, RTE_E_KeyMCertificateElement_Ssa_TrustModelIntermediatePeerCert_SerialNo_KEYM_E_KEY_CERT_EMPTY, RTE_E_KeyMCertificateElement_Ssa_TrustModelIntermediatePeerCert_SerialNo_KEYM_E_KEY_CERT_INVALID, RTE_E_KeyMCertificateElement_Ssa_TrustModelIntermediatePeerCert_SerialNo_KEYM_E_KEY_CERT_SIZE_MISMATCH, RTE_E_KeyMCertificateElement_Ssa_TrustModelIntermediatePeerCert_SerialNo_KEYM_E_PARAMETER_MISMATCH
 *   Std_ReturnType Rte_Call_KeyMCertificateElement_Ssa_TrustModelIntermediatePeerCert_Version_CertificateElementGet(uint8 *CertificateElementData, uint32 *CertificateDataLength)
 *     Argument CertificateElementData: uint8* is of type KeyM_CertificateElementType_Ssa_TrustModelIntermediatePeerCert_Version
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_KeyMCertificateElement_Ssa_TrustModelIntermediatePeerCert_Version_E_NOT_OK, RTE_E_KeyMCertificateElement_Ssa_TrustModelIntermediatePeerCert_Version_KEYM_E_KEY_CERT_EMPTY, RTE_E_KeyMCertificateElement_Ssa_TrustModelIntermediatePeerCert_Version_KEYM_E_KEY_CERT_INVALID, RTE_E_KeyMCertificateElement_Ssa_TrustModelIntermediatePeerCert_Version_KEYM_E_KEY_CERT_SIZE_MISMATCH, RTE_E_KeyMCertificateElement_Ssa_TrustModelIntermediatePeerCert_Version_KEYM_E_PARAMETER_MISMATCH
 *   Std_ReturnType Rte_Call_KeyMCertificateElement_Ssa_TrustModelIntermediatePeerCert_ext_authKeyId_CertificateElementGet(uint8 *CertificateElementData, uint32 *CertificateDataLength)
 *     Argument CertificateElementData: uint8* is of type KeyM_CertificateElementType_Ssa_TrustModelIntermediatePeerCert_ext_authKeyId
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_KeyMCertificateElement_Ssa_TrustModelIntermediatePeerCert_ext_authKeyId_E_NOT_OK, RTE_E_KeyMCertificateElement_Ssa_TrustModelIntermediatePeerCert_ext_authKeyId_KEYM_E_KEY_CERT_EMPTY, RTE_E_KeyMCertificateElement_Ssa_TrustModelIntermediatePeerCert_ext_authKeyId_KEYM_E_KEY_CERT_INVALID, RTE_E_KeyMCertificateElement_Ssa_TrustModelIntermediatePeerCert_ext_authKeyId_KEYM_E_KEY_CERT_SIZE_MISMATCH, RTE_E_KeyMCertificateElement_Ssa_TrustModelIntermediatePeerCert_ext_authKeyId_KEYM_E_PARAMETER_MISMATCH
 *   Std_ReturnType Rte_Call_KeyMCertificateElement_Ssa_TrustModelIntermediatePeerCert_ext_basicConstraints_CertificateElementGet(uint8 *CertificateElementData, uint32 *CertificateDataLength)
 *     Argument CertificateElementData: uint8* is of type KeyM_CertificateElementType_Ssa_TrustModelIntermediatePeerCert_ext_basicConstraints
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_KeyMCertificateElement_Ssa_TrustModelIntermediatePeerCert_ext_basicConstraints_E_NOT_OK, RTE_E_KeyMCertificateElement_Ssa_TrustModelIntermediatePeerCert_ext_basicConstraints_KEYM_E_KEY_CERT_EMPTY, RTE_E_KeyMCertificateElement_Ssa_TrustModelIntermediatePeerCert_ext_basicConstraints_KEYM_E_KEY_CERT_INVALID, RTE_E_KeyMCertificateElement_Ssa_TrustModelIntermediatePeerCert_ext_basicConstraints_KEYM_E_KEY_CERT_SIZE_MISMATCH, RTE_E_KeyMCertificateElement_Ssa_TrustModelIntermediatePeerCert_ext_basicConstraints_KEYM_E_PARAMETER_MISMATCH
 *   Std_ReturnType Rte_Call_KeyMCertificateElement_Ssa_TrustModelIntermediatePeerCert_ext_subKeyId_CertificateElementGet(uint8 *CertificateElementData, uint32 *CertificateDataLength)
 *     Argument CertificateElementData: uint8* is of type KeyM_CertificateElementType_Ssa_TrustModelIntermediatePeerCert_ext_subKeyId
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_KeyMCertificateElement_Ssa_TrustModelIntermediatePeerCert_ext_subKeyId_E_NOT_OK, RTE_E_KeyMCertificateElement_Ssa_TrustModelIntermediatePeerCert_ext_subKeyId_KEYM_E_KEY_CERT_EMPTY, RTE_E_KeyMCertificateElement_Ssa_TrustModelIntermediatePeerCert_ext_subKeyId_KEYM_E_KEY_CERT_INVALID, RTE_E_KeyMCertificateElement_Ssa_TrustModelIntermediatePeerCert_ext_subKeyId_KEYM_E_KEY_CERT_SIZE_MISMATCH, RTE_E_KeyMCertificateElement_Ssa_TrustModelIntermediatePeerCert_ext_subKeyId_KEYM_E_PARAMETER_MISMATCH
 *   Std_ReturnType Rte_Call_KeyMCertificateElement_Ssa_TrustModelIntermediatePeerCert_validityNotAfter_CertificateElementGet(uint8 *CertificateElementData, uint32 *CertificateDataLength)
 *     Argument CertificateElementData: uint8* is of type KeyM_CertificateElementType_Ssa_TrustModelIntermediatePeerCert_validityNotAfter
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_KeyMCertificateElement_Ssa_TrustModelIntermediatePeerCert_validityNotAfter_E_NOT_OK, RTE_E_KeyMCertificateElement_Ssa_TrustModelIntermediatePeerCert_validityNotAfter_KEYM_E_KEY_CERT_EMPTY, RTE_E_KeyMCertificateElement_Ssa_TrustModelIntermediatePeerCert_validityNotAfter_KEYM_E_KEY_CERT_INVALID, RTE_E_KeyMCertificateElement_Ssa_TrustModelIntermediatePeerCert_validityNotAfter_KEYM_E_KEY_CERT_SIZE_MISMATCH, RTE_E_KeyMCertificateElement_Ssa_TrustModelIntermediatePeerCert_validityNotAfter_KEYM_E_PARAMETER_MISMATCH
 *   Std_ReturnType Rte_Call_KeyMCertificateElement_Ssa_TrustModelRootCert_Issuer_CertificateElementGet(uint8 *CertificateElementData, uint32 *CertificateDataLength)
 *     Argument CertificateElementData: uint8* is of type KeyM_CertificateElementType_Ssa_TrustModelRootCert_Issuer
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_KeyMCertificateElement_Ssa_TrustModelRootCert_Issuer_E_NOT_OK, RTE_E_KeyMCertificateElement_Ssa_TrustModelRootCert_Issuer_KEYM_E_KEY_CERT_EMPTY, RTE_E_KeyMCertificateElement_Ssa_TrustModelRootCert_Issuer_KEYM_E_KEY_CERT_INVALID, RTE_E_KeyMCertificateElement_Ssa_TrustModelRootCert_Issuer_KEYM_E_KEY_CERT_SIZE_MISMATCH, RTE_E_KeyMCertificateElement_Ssa_TrustModelRootCert_Issuer_KEYM_E_PARAMETER_MISMATCH
 *   Std_ReturnType Rte_Call_KeyMCertificateElement_Ssa_TrustModelRootCert_SerialNo_CertificateElementGet(uint8 *CertificateElementData, uint32 *CertificateDataLength)
 *     Argument CertificateElementData: uint8* is of type KeyM_CertificateElementType_Ssa_TrustModelRootCert_SerialNo
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_KeyMCertificateElement_Ssa_TrustModelRootCert_SerialNo_E_NOT_OK, RTE_E_KeyMCertificateElement_Ssa_TrustModelRootCert_SerialNo_KEYM_E_KEY_CERT_EMPTY, RTE_E_KeyMCertificateElement_Ssa_TrustModelRootCert_SerialNo_KEYM_E_KEY_CERT_INVALID, RTE_E_KeyMCertificateElement_Ssa_TrustModelRootCert_SerialNo_KEYM_E_KEY_CERT_SIZE_MISMATCH, RTE_E_KeyMCertificateElement_Ssa_TrustModelRootCert_SerialNo_KEYM_E_PARAMETER_MISMATCH
 *   Std_ReturnType Rte_Call_KeyMCertificateElement_Ssa_TrustModelRootCert_SubjectPublicKeyInfoKey_CertificateElementGet(uint8 *CertificateElementData, uint32 *CertificateDataLength)
 *     Argument CertificateElementData: uint8* is of type KeyM_CertificateElementType_Ssa_TrustModelRootCert_SubjectPublicKeyInfoKey
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_KeyMCertificateElement_Ssa_TrustModelRootCert_SubjectPublicKeyInfoKey_E_NOT_OK, RTE_E_KeyMCertificateElement_Ssa_TrustModelRootCert_SubjectPublicKeyInfoKey_KEYM_E_KEY_CERT_EMPTY, RTE_E_KeyMCertificateElement_Ssa_TrustModelRootCert_SubjectPublicKeyInfoKey_KEYM_E_KEY_CERT_INVALID, RTE_E_KeyMCertificateElement_Ssa_TrustModelRootCert_SubjectPublicKeyInfoKey_KEYM_E_KEY_CERT_SIZE_MISMATCH, RTE_E_KeyMCertificateElement_Ssa_TrustModelRootCert_SubjectPublicKeyInfoKey_KEYM_E_PARAMETER_MISMATCH
 *   Std_ReturnType Rte_Call_KeyMCertificateElement_Ssa_TrustModelRootCert_Version_CertificateElementGet(uint8 *CertificateElementData, uint32 *CertificateDataLength)
 *     Argument CertificateElementData: uint8* is of type KeyM_CertificateElementType_Ssa_TrustModelRootCert_Version
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_KeyMCertificateElement_Ssa_TrustModelRootCert_Version_E_NOT_OK, RTE_E_KeyMCertificateElement_Ssa_TrustModelRootCert_Version_KEYM_E_KEY_CERT_EMPTY, RTE_E_KeyMCertificateElement_Ssa_TrustModelRootCert_Version_KEYM_E_KEY_CERT_INVALID, RTE_E_KeyMCertificateElement_Ssa_TrustModelRootCert_Version_KEYM_E_KEY_CERT_SIZE_MISMATCH, RTE_E_KeyMCertificateElement_Ssa_TrustModelRootCert_Version_KEYM_E_PARAMETER_MISMATCH
 *   Std_ReturnType Rte_Call_KeyMCertificateElement_Ssa_TrustModelRootCert_ext_basicConstraints_CertificateElementGet(uint8 *CertificateElementData, uint32 *CertificateDataLength)
 *     Argument CertificateElementData: uint8* is of type KeyM_CertificateElementType_Ssa_TrustModelRootCert_ext_basicConstraints
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_KeyMCertificateElement_Ssa_TrustModelRootCert_ext_basicConstraints_E_NOT_OK, RTE_E_KeyMCertificateElement_Ssa_TrustModelRootCert_ext_basicConstraints_KEYM_E_KEY_CERT_EMPTY, RTE_E_KeyMCertificateElement_Ssa_TrustModelRootCert_ext_basicConstraints_KEYM_E_KEY_CERT_INVALID, RTE_E_KeyMCertificateElement_Ssa_TrustModelRootCert_ext_basicConstraints_KEYM_E_KEY_CERT_SIZE_MISMATCH, RTE_E_KeyMCertificateElement_Ssa_TrustModelRootCert_ext_basicConstraints_KEYM_E_PARAMETER_MISMATCH
 *   Std_ReturnType Rte_Call_KeyMCertificateElement_Ssa_TrustModelRootCert_ext_keyUsage_CertificateElementGet(uint8 *CertificateElementData, uint32 *CertificateDataLength)
 *     Argument CertificateElementData: uint8* is of type KeyM_CertificateElementType_Ssa_TrustModelRootCert_ext_keyUsage
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_KeyMCertificateElement_Ssa_TrustModelRootCert_ext_keyUsage_E_NOT_OK, RTE_E_KeyMCertificateElement_Ssa_TrustModelRootCert_ext_keyUsage_KEYM_E_KEY_CERT_EMPTY, RTE_E_KeyMCertificateElement_Ssa_TrustModelRootCert_ext_keyUsage_KEYM_E_KEY_CERT_INVALID, RTE_E_KeyMCertificateElement_Ssa_TrustModelRootCert_ext_keyUsage_KEYM_E_KEY_CERT_SIZE_MISMATCH, RTE_E_KeyMCertificateElement_Ssa_TrustModelRootCert_ext_keyUsage_KEYM_E_PARAMETER_MISMATCH
 *   Std_ReturnType Rte_Call_KeyMCertificateElement_Ssa_TrustModelRootCert_ext_subKeyId_CertificateElementGet(uint8 *CertificateElementData, uint32 *CertificateDataLength)
 *     Argument CertificateElementData: uint8* is of type KeyM_CertificateElementType_Ssa_TrustModelRootCert_ext_subKeyId
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_KeyMCertificateElement_Ssa_TrustModelRootCert_ext_subKeyId_E_NOT_OK, RTE_E_KeyMCertificateElement_Ssa_TrustModelRootCert_ext_subKeyId_KEYM_E_KEY_CERT_EMPTY, RTE_E_KeyMCertificateElement_Ssa_TrustModelRootCert_ext_subKeyId_KEYM_E_KEY_CERT_INVALID, RTE_E_KeyMCertificateElement_Ssa_TrustModelRootCert_ext_subKeyId_KEYM_E_KEY_CERT_SIZE_MISMATCH, RTE_E_KeyMCertificateElement_Ssa_TrustModelRootCert_ext_subKeyId_KEYM_E_PARAMETER_MISMATCH
 *   Std_ReturnType Rte_Call_KeyMCertificateElement_Ssa_TrustModelRootCert_subject_CertificateElementGet(uint8 *CertificateElementData, uint32 *CertificateDataLength)
 *     Argument CertificateElementData: uint8* is of type KeyM_CertificateElementType_Ssa_TrustModelRootCert_subject
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_KeyMCertificateElement_Ssa_TrustModelRootCert_subject_E_NOT_OK, RTE_E_KeyMCertificateElement_Ssa_TrustModelRootCert_subject_KEYM_E_KEY_CERT_EMPTY, RTE_E_KeyMCertificateElement_Ssa_TrustModelRootCert_subject_KEYM_E_KEY_CERT_INVALID, RTE_E_KeyMCertificateElement_Ssa_TrustModelRootCert_subject_KEYM_E_KEY_CERT_SIZE_MISMATCH, RTE_E_KeyMCertificateElement_Ssa_TrustModelRootCert_subject_KEYM_E_PARAMETER_MISMATCH
 *   Std_ReturnType Rte_Call_KeyMCertificateElement_Ssa_TrustModelRootCert_validityNotAfter_CertificateElementGet(uint8 *CertificateElementData, uint32 *CertificateDataLength)
 *     Argument CertificateElementData: uint8* is of type KeyM_CertificateElementType_Ssa_TrustModelRootCert_validityNotAfter
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_KeyMCertificateElement_Ssa_TrustModelRootCert_validityNotAfter_E_NOT_OK, RTE_E_KeyMCertificateElement_Ssa_TrustModelRootCert_validityNotAfter_KEYM_E_KEY_CERT_EMPTY, RTE_E_KeyMCertificateElement_Ssa_TrustModelRootCert_validityNotAfter_KEYM_E_KEY_CERT_INVALID, RTE_E_KeyMCertificateElement_Ssa_TrustModelRootCert_validityNotAfter_KEYM_E_KEY_CERT_SIZE_MISMATCH, RTE_E_KeyMCertificateElement_Ssa_TrustModelRootCert_validityNotAfter_KEYM_E_PARAMETER_MISMATCH
 *   Std_ReturnType Rte_Call_KeyMCertificate_Ssa_TrustModelBackendPeerCert_GetStatus(KeyM_CertificateStatusType *Status)
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_KeyMCertificate_Ssa_TrustModelBackendPeerCert_E_NOT_OK
 *   Std_ReturnType Rte_Call_KeyMCertificate_Ssa_TrustModelEcuPeerCert_GetStatus(KeyM_CertificateStatusType *Status)
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_KeyMCertificate_Ssa_TrustModelEcuPeerCert_E_NOT_OK
 *   Std_ReturnType Rte_Call_KeyMCertificate_Ssa_TrustModelEcuPeerCert_VerifyCertificate(void)
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_KeyMCertificate_Ssa_TrustModelEcuPeerCert_E_NOT_OK, RTE_E_KeyMCertificate_Ssa_TrustModelEcuPeerCert_KEYM_E_BUSY, RTE_E_KeyMCertificate_Ssa_TrustModelEcuPeerCert_KEYM_E_CERT_INVALID_CHAIN_OF_TRUST, RTE_E_KeyMCertificate_Ssa_TrustModelEcuPeerCert_KEYM_E_KEY_CERT_EMPTY, RTE_E_KeyMCertificate_Ssa_TrustModelEcuPeerCert_KEYM_E_KEY_CERT_SIZE_MISMATCH, RTE_E_KeyMCertificate_Ssa_TrustModelEcuPeerCert_KEYM_E_PARAMETER_MISMATCH
 *   Std_ReturnType Rte_Call_KeyMCertificate_Ssa_TrustModelIntermediatePeerCert_GetStatus(KeyM_CertificateStatusType *Status)
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_KeyMCertificate_Ssa_TrustModelIntermediatePeerCert_E_NOT_OK
 *   Std_ReturnType Rte_Call_Key_AesRamKey_KeyElementSet(uint32 keyElementId, const uint8 *keyPtr, uint32 keyLength)
 *     Argument keyPtr: uint8* is of type Csm_KeyDataType_Ssa_AesRamKey
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_CsmKeyManagement_Ssa_AesRamKey_CSM_E_BUSY, RTE_E_CsmKeyManagement_Ssa_AesRamKey_CSM_E_KEY_NOT_AVAILABLE, RTE_E_CsmKeyManagement_Ssa_AesRamKey_CSM_E_KEY_SIZE_MISMATCH, RTE_E_CsmKeyManagement_Ssa_AesRamKey_CSM_E_KEY_WRITE_FAIL, RTE_E_CsmKeyManagement_Ssa_AesRamKey_CSM_E_SMALL_BUFFER, RTE_E_CsmKeyManagement_Ssa_AesRamKey_E_NOT_OK
 *   Std_ReturnType Rte_Call_Key_AesRamKey_KeySetValid(void)
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_CsmKeyManagement_Ssa_AesRamKey_CSM_E_BUSY, RTE_E_CsmKeyManagement_Ssa_AesRamKey_E_NOT_OK
 *   Std_ReturnType Rte_Call_Key_SharedSecret_KeyElementGet(uint32 keyElementId, uint8 *keyPtr, uint32 *keyLength)
 *     Argument keyPtr: uint8* is of type Csm_KeyDataType_Ssa_SharedSecret
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_CsmKeyManagement_Ssa_SharedSecret_CSM_E_BUSY, RTE_E_CsmKeyManagement_Ssa_SharedSecret_CSM_E_KEY_EMPTY, RTE_E_CsmKeyManagement_Ssa_SharedSecret_CSM_E_KEY_NOT_AVAILABLE, RTE_E_CsmKeyManagement_Ssa_SharedSecret_CSM_E_KEY_READ_FAIL, RTE_E_CsmKeyManagement_Ssa_SharedSecret_CSM_E_SMALL_BUFFER, RTE_E_CsmKeyManagement_Ssa_SharedSecret_E_NOT_OK
 *   Std_ReturnType Rte_Call_Key_SharedSecret_KeyElementSet(uint32 keyElementId, const uint8 *keyPtr, uint32 keyLength)
 *     Argument keyPtr: uint8* is of type Csm_KeyDataType_Ssa_SharedSecret
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_CsmKeyManagement_Ssa_SharedSecret_CSM_E_BUSY, RTE_E_CsmKeyManagement_Ssa_SharedSecret_CSM_E_KEY_NOT_AVAILABLE, RTE_E_CsmKeyManagement_Ssa_SharedSecret_CSM_E_KEY_SIZE_MISMATCH, RTE_E_CsmKeyManagement_Ssa_SharedSecret_CSM_E_KEY_WRITE_FAIL, RTE_E_CsmKeyManagement_Ssa_SharedSecret_CSM_E_SMALL_BUFFER, RTE_E_CsmKeyManagement_Ssa_SharedSecret_E_NOT_OK
 *   Std_ReturnType Rte_Call_Key_SharedSecret_KeySetValid(void)
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_CsmKeyManagement_Ssa_SharedSecret_CSM_E_BUSY, RTE_E_CsmKeyManagement_Ssa_SharedSecret_E_NOT_OK
 *   Std_ReturnType Rte_Call_Key_SharedSecretKeyExchange_KeyElementGet(uint32 keyElementId, uint8 *keyPtr, uint32 *keyLength)
 *     Argument keyPtr: uint8* is of type Csm_KeyDataType_Ssa_SharedSecretKeyExchange
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_CsmKeyManagement_Ssa_SharedSecretKeyExchange_CSM_E_BUSY, RTE_E_CsmKeyManagement_Ssa_SharedSecretKeyExchange_CSM_E_KEY_EMPTY, RTE_E_CsmKeyManagement_Ssa_SharedSecretKeyExchange_CSM_E_KEY_NOT_AVAILABLE, RTE_E_CsmKeyManagement_Ssa_SharedSecretKeyExchange_CSM_E_KEY_READ_FAIL, RTE_E_CsmKeyManagement_Ssa_SharedSecretKeyExchange_CSM_E_SMALL_BUFFER, RTE_E_CsmKeyManagement_Ssa_SharedSecretKeyExchange_E_NOT_OK
 *   Std_ReturnType Rte_Call_Key_SharedSecretKeyExchange_KeyElementSet(uint32 keyElementId, const uint8 *keyPtr, uint32 keyLength)
 *     Argument keyPtr: uint8* is of type Csm_KeyDataType_Ssa_SharedSecretKeyExchange
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_CsmKeyManagement_Ssa_SharedSecretKeyExchange_CSM_E_BUSY, RTE_E_CsmKeyManagement_Ssa_SharedSecretKeyExchange_CSM_E_KEY_NOT_AVAILABLE, RTE_E_CsmKeyManagement_Ssa_SharedSecretKeyExchange_CSM_E_KEY_SIZE_MISMATCH, RTE_E_CsmKeyManagement_Ssa_SharedSecretKeyExchange_CSM_E_KEY_WRITE_FAIL, RTE_E_CsmKeyManagement_Ssa_SharedSecretKeyExchange_CSM_E_SMALL_BUFFER, RTE_E_CsmKeyManagement_Ssa_SharedSecretKeyExchange_E_NOT_OK
 *   Std_ReturnType Rte_Call_Key_SharedSecretKeyExchange_KeyExchangeCalcPubVal(uint8 *publicValuePtr, uint32 *publicValueLengthPtr)
 *     Argument publicValuePtr: uint8* is of type Csm_PublicValueDataType_Ssa_SharedSecretKeyExchange
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_CsmKeyManagement_Ssa_SharedSecretKeyExchange_CSM_E_BUSY, RTE_E_CsmKeyManagement_Ssa_SharedSecretKeyExchange_CSM_E_KEY_EMPTY, RTE_E_CsmKeyManagement_Ssa_SharedSecretKeyExchange_CSM_E_SMALL_BUFFER, RTE_E_CsmKeyManagement_Ssa_SharedSecretKeyExchange_E_NOT_OK
 *   Std_ReturnType Rte_Call_Key_SharedSecretKeyExchange_KeyExchangeCalcSecret(const uint8 *partnerPublicValuePtr, uint32 partnerPublicValueLength)
 *     Argument partnerPublicValuePtr: uint8* is of type Csm_PublicValueDataType_Ssa_SharedSecretKeyExchange
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_CsmKeyManagement_Ssa_SharedSecretKeyExchange_CSM_E_BUSY, RTE_E_CsmKeyManagement_Ssa_SharedSecretKeyExchange_CSM_E_KEY_EMPTY, RTE_E_CsmKeyManagement_Ssa_SharedSecretKeyExchange_CSM_E_SMALL_BUFFER, RTE_E_CsmKeyManagement_Ssa_SharedSecretKeyExchange_E_NOT_OK
 *   Std_ReturnType Rte_Call_Key_SharedSecretKeyExchange_KeySetValid(void)
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_CsmKeyManagement_Ssa_SharedSecretKeyExchange_CSM_E_BUSY, RTE_E_CsmKeyManagement_Ssa_SharedSecretKeyExchange_E_NOT_OK
 *   Std_ReturnType Rte_Call_Key_SignatureRamKey_KeyElementSet(uint32 keyElementId, const uint8 *keyPtr, uint32 keyLength)
 *     Argument keyPtr: uint8* is of type Csm_KeyDataType_Ssa_SignatureRamKey
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_CsmKeyManagement_Ssa_SignatureRamKey_CSM_E_BUSY, RTE_E_CsmKeyManagement_Ssa_SignatureRamKey_CSM_E_KEY_NOT_AVAILABLE, RTE_E_CsmKeyManagement_Ssa_SignatureRamKey_CSM_E_KEY_SIZE_MISMATCH, RTE_E_CsmKeyManagement_Ssa_SignatureRamKey_CSM_E_KEY_WRITE_FAIL, RTE_E_CsmKeyManagement_Ssa_SignatureRamKey_CSM_E_SMALL_BUFFER, RTE_E_CsmKeyManagement_Ssa_SignatureRamKey_E_NOT_OK
 *   Std_ReturnType Rte_Call_Key_SignatureRamKey_KeySetValid(void)
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_CsmKeyManagement_Ssa_SignatureRamKey_CSM_E_BUSY, RTE_E_CsmKeyManagement_Ssa_SignatureRamKey_E_NOT_OK
 *
 * Exclusive Area Access:
 * ======================
 *   void Rte_Enter_KeyM_ExclusiveArea(void)
 *   void Rte_Exit_KeyM_ExclusiveArea(void)
 *
 **********************************************************************************************************************
 *
 * Runnable prototype:
 * ===================
 *   Std_ReturnType Ssa_KeyM_RoutineServices_Trust_Model_SecOC_ECU_Shared_Secret_Encryption(const uint8 *Nonce_In, const uint8 *Ephemeral_ECU_Public_Key_In, const uint8 *In_Data_Signature_In, const uint8 *In_Certificates_In, Dcm_OpStatusType OpStatus, uint8 *routineInfo_Out, uint8 *Verification_Result_Out, uint8 *Date_and_Time_Out, uint8 *Tick_Count_Out, uint8 *Tick_Count_Offset_Out, uint8 *Encrypted_Nonce_and_Shared_Secret_Out, uint8 *Ephemeral_VSM_Public_Key_Out, uint8 *Out_Data_Signature_Out, uint8 *Out_Certificates_Out, uint16 *DataLength, Dcm_NegativeResponseCodeType *ErrorCode)
 *     Argument Nonce_In: uint8* is of type Dcm_Data32ByteType
 *     Argument Ephemeral_ECU_Public_Key_In: uint8* is of type Dcm_Data32ByteType
 *     Argument In_Data_Signature_In: uint8* is of type Dcm_Data64ByteType
 *     Argument In_Certificates_In: uint8* is of type Dcm_Data3006ByteType
 *     Argument Date_and_Time_Out: uint8* is of type Dcm_Data7ByteType
 *     Argument Tick_Count_Out: uint8* is of type Dcm_Data5ByteType
 *     Argument Tick_Count_Offset_Out: uint8* is of type Dcm_Data5ByteType
 *     Argument Encrypted_Nonce_and_Shared_Secret_Out: uint8* is of type Dcm_Data80ByteType
 *     Argument Ephemeral_VSM_Public_Key_Out: uint8* is of type Dcm_Data32ByteType
 *     Argument Out_Data_Signature_Out: uint8* is of type Dcm_Data64ByteType
 *     Argument Out_Certificates_Out: uint8* is of type Dcm_Data3006ByteType
 *
 **********************************************************************************************************************
 *
 * Available Application Errors:
 * =============================
 *   RTE_E_RoutineServices_Trust_Model_SecOC_ECU_Shared_Secret_Encryption_DCM_E_FORCE_RCRRP
 *   RTE_E_RoutineServices_Trust_Model_SecOC_ECU_Shared_Secret_Encryption_DCM_E_PENDING
 *   RTE_E_RoutineServices_Trust_Model_SecOC_ECU_Shared_Secret_Encryption_E_NOT_OK
 *
 *********************************************************************************************************************/
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << Start of documentation area >>                  DO NOT CHANGE THIS COMMENT!
 * Symbol: Ssa_KeyM_RoutineServices_Trust_Model_SecOC_ECU_Shared_Secret_Encryption_doc
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
/*!
 * \spec
 *    requires $lengthOf(Date_and_Time_Out) >= sizeof(Dcm_Data7ByteType);
 *    requires $lengthOf(Tick_Count_Out) >= sizeof(Dcm_Data5ByteType);
 *    requires $lengthOf(Tick_Count_Offset_Out) >= sizeof(Dcm_Data5ByteType);
 *    requires $lengthOf(Encrypted_Nonce_and_Shared_Secret_Out) >= sizeof(Dcm_Data80ByteType);
 *    requires $lengthOf(Ephemeral_VSM_Public_Key_Out) >= sizeof(Dcm_Data32ByteType);
 *    requires $lengthOf(Out_Data_Signature_Out) >= sizeof(Dcm_Data64ByteType);
 *    requires $lengthOf(Out_Certificates_Out) >= sizeof(Dcm_Data3006ByteType);
 * \endspec
 */
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << End of documentation area >>                    DO NOT CHANGE THIS COMMENT!
 *********************************************************************************************************************/

FUNC(Std_ReturnType, Ssa_KeyM_CODE) Ssa_KeyM_RoutineServices_Trust_Model_SecOC_ECU_Shared_Secret_Encryption(
  P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) Nonce_In,
  P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) Ephemeral_ECU_Public_Key_In,
  P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) In_Data_Signature_In,
  P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) In_Certificates_In,
  Dcm_OpStatusType OpStatus,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) routineInfo_Out,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) Verification_Result_Out,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) Date_and_Time_Out,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) Tick_Count_Out,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) Tick_Count_Offset_Out,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) Encrypted_Nonce_and_Shared_Secret_Out,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) Ephemeral_VSM_Public_Key_Out,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) Out_Data_Signature_Out,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) Out_Certificates_Out,
  P2VAR(uint16, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) DataLength,
  P2VAR(Dcm_NegativeResponseCodeType, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) ErrorCode) /* PRQA S 0624, 3206 */ /* MD_Rte_0624, MD_Rte_3206 */
{
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << Start of runnable implementation >>             DO NOT CHANGE THIS COMMENT!
 * Symbol: Ssa_KeyM_RoutineServices_Trust_Model_SecOC_ECU_Shared_Secret_Encryption (returns application error)
 *********************************************************************************************************************/

  Std_ReturnType retVal = RTE_E_RoutineServices_Trust_Model_SecOC_ECU_Shared_Secret_Encryption_E_NOT_OK;

  /* ----- Development Error Checks ------------------------------------- */
# if (SSA_DEV_ERROR_DETECT == STD_ON)
  if ((Nonce_In == NULL_PTR)
    || (Ephemeral_ECU_Public_Key_In == NULL_PTR)
    || (In_Data_Signature_In == NULL_PTR)
    || (In_Certificates_In == NULL_PTR)
    || (routineInfo_Out == NULL_PTR)
    || (Verification_Result_Out == NULL_PTR)
    || (Date_and_Time_Out == NULL_PTR)
    || (Tick_Count_Out == NULL_PTR)
    || (Tick_Count_Offset_Out == NULL_PTR)
    || (Encrypted_Nonce_and_Shared_Secret_Out == NULL_PTR)
    || (Ephemeral_VSM_Public_Key_Out == NULL_PTR)
    || (Out_Data_Signature_Out == NULL_PTR)
    || (Out_Certificates_Out == NULL_PTR)
    || (DataLength == NULL_PTR)
    || (ErrorCode == NULL_PTR))
  {
    /* retVal already set */
  }
  else
# endif /* SSA_DEV_ERROR_DETECT == STD_ON */
  {
    /* #10 Process the encryption of the car-specific secret and do not allow the usage of the standard shared secret. */
    retVal = KeyM_EncryptSharedSecret(
      SSA_TRUST_MODEL_LIVE_KEY_PAIR,
      Nonce_In,
      Ephemeral_ECU_Public_Key_In,
      In_Data_Signature_In,
      In_Certificates_In,
      OpStatus,
      routineInfo_Out,
      Verification_Result_Out,
      Date_and_Time_Out,
      Tick_Count_Out,
      Tick_Count_Offset_Out,
      Encrypted_Nonce_and_Shared_Secret_Out,
      Ephemeral_VSM_Public_Key_Out,
      Out_Data_Signature_Out,
      Out_Certificates_Out,
      DataLength,
      ErrorCode,
      FALSE);

    /* Map return value. */
    switch (retVal)
    {
      case SSA_E_PENDING:
        retVal = RTE_E_RoutineServices_Trust_Model_SecOC_ECU_Shared_Secret_Encryption_DCM_E_PENDING;
        break;
      case E_OK:
        retVal = RTE_E_OK;
        break;
      default:
        retVal = RTE_E_RoutineServices_Trust_Model_SecOC_ECU_Shared_Secret_Encryption_E_NOT_OK;
        break;
    }
  }

  return retVal;
  /* PRQA S 6060 4 */ /* MD_SSA_STPAR */
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << End of runnable implementation >>               DO NOT CHANGE THIS COMMENT!
 *********************************************************************************************************************/
}

/**********************************************************************************************************************
 *
 * Runnable Entity Name: Ssa_KeyM_RoutineServices_Trust_Model_SecOC_ECU_TickCount_Synchronization
 *
 *---------------------------------------------------------------------------------------------------------------------
 *
 * Executed if at least one of the following trigger conditions occurred:
 *   - triggered by server invocation for OperationPrototype <Start> of PortPrototype <RoutineServices_Trust_Model_SecOC_ECU_TickCount_Synchronization>
 *
 **********************************************************************************************************************
 *
 * Client/Server Interfaces:
 * =========================
 *   Server Invocation:
 *   ------------------
 *   Std_ReturnType Rte_Call_CertP_Functions_ParseTime(const uint8 *data, uint16 dataLength, TimeM_DateTimeType *dateTime)
 *     Argument data: uint8* is of type Ssa_Data15ByteType
 *     Synchronous Server Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_CertP_Functions_E_NOT_OK
 *   Std_ReturnType Rte_Call_RightsM_DiagnosticChannel_GetDiagnosticUserRole(RightsM_DiagnosticUserRoleType *userRole)
 *     Synchronous Server Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_RightsM_DiagnosticChannel_E_NOT_OK
 *   Std_ReturnType Rte_Call_RightsM_DiagnosticChannel_GetPostProductionStatus(Ssa_PostProductionStatusType *status)
 *     Synchronous Server Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_RightsM_DiagnosticChannel_E_NOT_OK
 *   Std_ReturnType Rte_Call_RightsM_EnhancedRights_VerifySubjectKeyIdentifier(const uint8 *subjectKeyIdentifier)
 *     Argument subjectKeyIdentifier: uint8* is of type Ssa_Data20ByteType
 *     Synchronous Server Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_RightsM_EnhancedRights_E_NOT_OK
 *   Std_ReturnType Rte_Call_SecLog_FailedCertVerificationEvent_FailedCertificateVerification(CertP_PkiRoleType pkiRole, CertP_VerificationResultType validationResult)
 *     Synchronous Server Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_SecLog_FailedCertVerificationEvent_E_NOT_OK
 *   Std_ReturnType Rte_Call_SecLog_SuccessfulCertVerificationEvent_SuccessfulCertificateVerification(const uint8 *certId, CertP_PkiRoleType pkiRole)
 *     Argument certId: uint8* is of type RightsM_SerialNumberType
 *     Synchronous Server Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_SecLog_SuccessfulCertVerificationEvent_E_NOT_OK
 *   Std_ReturnType Rte_Call_SecLog_SuccessfulDiagServiceExecutionEvent_TrustModelEcuTickcountSynchronization_SuccessfulDiagServiceExecution(uint8 additionalInfo)
 *     Synchronous Server Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_SecLog_SuccessfulDiagServiceExecutionEvent_E_NOT_OK
 *   Std_ReturnType Rte_Call_SsaCdd_Csm_Hash(uint32 jobId, Crypto_OperationModeType operationMode, Ssa_ConstDataPtr dataBuffer, uint32 dataLength, Ssa_DataPtr resultBuffer, Ssa_LengthPtr resultLength)
 *     Synchronous Server Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_SsaCdd_CryptoInterface_E_NOT_OK
 *   Std_ReturnType Rte_Call_SsaCdd_Csm_SignatureGenerate(uint32 jobId, Crypto_OperationModeType operationMode, Ssa_ConstDataPtr dataBuffer, uint32 dataLength, Ssa_DataPtr resultBuffer, Ssa_LengthPtr resultLength)
 *     Synchronous Server Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_SsaCdd_CryptoInterface_E_NOT_OK
 *   Std_ReturnType Rte_Call_SsaCdd_Csm_SignatureVerify(uint32 jobId, Crypto_OperationModeType operationMode, Ssa_ConstDataPtr dataBuffer, uint32 dataLength, Ssa_ConstDataPtr compareBuffer, uint32 compareLength, Ssa_VerifyResultPtr resultBuffer)
 *     Synchronous Server Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_SsaCdd_CryptoInterface_E_NOT_OK
 *   Std_ReturnType Rte_Call_SsaCdd_TrustModel_SetCertificate(KeyM_CertificateIdType CertId, Ssa_DataPtr CertData, uint32 CertDataLength)
 *     Synchronous Server Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_SsaCdd_KeyM_CertInterface_E_NOT_OK, RTE_E_SsaCdd_KeyM_CertInterface_KEYM_E_KEY_CERT_SIZE_MISMATCH, RTE_E_SsaCdd_KeyM_CertInterface_KEYM_E_PARAMETER_MISMATCH
 *   Std_ReturnType Rte_Call_Ssa_KeyProc_PrepareKeyExchange(Ssa_OpStatusType opStatus, uint32 keyId)
 *     Synchronous Server Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_Ssa_KeyProc_E_NOT_OK, RTE_E_Ssa_KeyProc_E_PENDING
 *   Std_ReturnType Rte_Call_TimeM_TimeRawData_Get(uint8 *dateTimeOffset, uint8 *tickCountOffset, uint8 *tickCount)
 *     Argument dateTimeOffset: uint8* is of type Ssa_Data7ByteType
 *     Argument tickCountOffset: uint8* is of type Ssa_Data5ByteType
 *     Argument tickCount: uint8* is of type Ssa_Data5ByteType
 *     Synchronous Server Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_TimeM_TimeRawData_E_NOT_OK
 *
 * Service Calls:
 * ==============
 *   Service Invocation:
 *   -------------------
 *   Std_ReturnType Rte_Call_CsmJobKeyExchangeCalcPubVal_KeyExchangeCalcPubVal(uint32 key, Csm_DataPtr publicValuePtr, Csm_LengthPtr publicValueLengthPtr)
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_CsmJobKeyExchangeCalcPubVal_CSM_E_BUSY, RTE_E_CsmJobKeyExchangeCalcPubVal_CSM_E_KEY_EMPTY, RTE_E_CsmJobKeyExchangeCalcPubVal_CSM_E_SMALL_BUFFER, RTE_E_CsmJobKeyExchangeCalcPubVal_E_NOT_OK
 *   Std_ReturnType Rte_Call_CsmJobKeyExchangeCalcSecret_KeyExchangeCalcSecret(uint32 key, Csm_const_DataPtr partnerPublicValuePtr, uint32 partnerPublicValueLength)
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_CsmJobKeyExchangeCalcSecret_CSM_E_BUSY, RTE_E_CsmJobKeyExchangeCalcSecret_CSM_E_KEY_EMPTY, RTE_E_CsmJobKeyExchangeCalcSecret_CSM_E_SMALL_BUFFER, RTE_E_CsmJobKeyExchangeCalcSecret_E_NOT_OK
 *   Std_ReturnType Rte_Call_CsmSymAES128Encrypt_Encrypt(const uint8 *dataBuffer, uint32 dataLength, uint8 *resultBuffer, uint32 *resultLength)
 *     Argument dataBuffer: uint8* is of type Csm_EncryptDataType_AES128Encrypt
 *     Argument resultBuffer: uint8* is of type Csm_EncryptResultType_AES128Encrypt
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_CsmEncrypt_AES128Encrypt_CSM_E_BUSY, RTE_E_CsmEncrypt_AES128Encrypt_CSM_E_KEY_EMPTY, RTE_E_CsmEncrypt_AES128Encrypt_CSM_E_KEY_NOT_VALID, RTE_E_CsmEncrypt_AES128Encrypt_CSM_E_KEY_SIZE_MISMATCH, RTE_E_CsmEncrypt_AES128Encrypt_CSM_E_SMALL_BUFFER, RTE_E_CsmEncrypt_AES128Encrypt_E_NOT_OK
 *   Std_ReturnType Rte_Call_KeyMCertificateElement_Ssa_TrustModelBackendPeerCert_SerialNo_CertificateElementGet(uint8 *CertificateElementData, uint32 *CertificateDataLength)
 *     Argument CertificateElementData: uint8* is of type KeyM_CertificateElementType_Ssa_TrustModelBackendPeerCert_SerialNo
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_KeyMCertificateElement_Ssa_TrustModelBackendPeerCert_SerialNo_E_NOT_OK, RTE_E_KeyMCertificateElement_Ssa_TrustModelBackendPeerCert_SerialNo_KEYM_E_KEY_CERT_EMPTY, RTE_E_KeyMCertificateElement_Ssa_TrustModelBackendPeerCert_SerialNo_KEYM_E_KEY_CERT_INVALID, RTE_E_KeyMCertificateElement_Ssa_TrustModelBackendPeerCert_SerialNo_KEYM_E_KEY_CERT_SIZE_MISMATCH, RTE_E_KeyMCertificateElement_Ssa_TrustModelBackendPeerCert_SerialNo_KEYM_E_PARAMETER_MISMATCH
 *   Std_ReturnType Rte_Call_KeyMCertificateElement_Ssa_TrustModelBackendPeerCert_Version_CertificateElementGet(uint8 *CertificateElementData, uint32 *CertificateDataLength)
 *     Argument CertificateElementData: uint8* is of type KeyM_CertificateElementType_Ssa_TrustModelBackendPeerCert_Version
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_KeyMCertificateElement_Ssa_TrustModelBackendPeerCert_Version_E_NOT_OK, RTE_E_KeyMCertificateElement_Ssa_TrustModelBackendPeerCert_Version_KEYM_E_KEY_CERT_EMPTY, RTE_E_KeyMCertificateElement_Ssa_TrustModelBackendPeerCert_Version_KEYM_E_KEY_CERT_INVALID, RTE_E_KeyMCertificateElement_Ssa_TrustModelBackendPeerCert_Version_KEYM_E_KEY_CERT_SIZE_MISMATCH, RTE_E_KeyMCertificateElement_Ssa_TrustModelBackendPeerCert_Version_KEYM_E_PARAMETER_MISMATCH
 *   Std_ReturnType Rte_Call_KeyMCertificateElement_Ssa_TrustModelBackendPeerCert_ext_authKeyId_CertificateElementGet(uint8 *CertificateElementData, uint32 *CertificateDataLength)
 *     Argument CertificateElementData: uint8* is of type KeyM_CertificateElementType_Ssa_TrustModelBackendPeerCert_ext_authKeyId
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_KeyMCertificateElement_Ssa_TrustModelBackendPeerCert_ext_authKeyId_E_NOT_OK, RTE_E_KeyMCertificateElement_Ssa_TrustModelBackendPeerCert_ext_authKeyId_KEYM_E_KEY_CERT_EMPTY, RTE_E_KeyMCertificateElement_Ssa_TrustModelBackendPeerCert_ext_authKeyId_KEYM_E_KEY_CERT_INVALID, RTE_E_KeyMCertificateElement_Ssa_TrustModelBackendPeerCert_ext_authKeyId_KEYM_E_KEY_CERT_SIZE_MISMATCH, RTE_E_KeyMCertificateElement_Ssa_TrustModelBackendPeerCert_ext_authKeyId_KEYM_E_PARAMETER_MISMATCH
 *   Std_ReturnType Rte_Call_KeyMCertificateElement_Ssa_TrustModelBackendPeerCert_ext_basicConstraints_CertificateElementGet(uint8 *CertificateElementData, uint32 *CertificateDataLength)
 *     Argument CertificateElementData: uint8* is of type KeyM_CertificateElementType_Ssa_TrustModelBackendPeerCert_ext_basicConstraints
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_KeyMCertificateElement_Ssa_TrustModelBackendPeerCert_ext_basicConstraints_E_NOT_OK, RTE_E_KeyMCertificateElement_Ssa_TrustModelBackendPeerCert_ext_basicConstraints_KEYM_E_KEY_CERT_EMPTY, RTE_E_KeyMCertificateElement_Ssa_TrustModelBackendPeerCert_ext_basicConstraints_KEYM_E_KEY_CERT_INVALID, RTE_E_KeyMCertificateElement_Ssa_TrustModelBackendPeerCert_ext_basicConstraints_KEYM_E_KEY_CERT_SIZE_MISMATCH, RTE_E_KeyMCertificateElement_Ssa_TrustModelBackendPeerCert_ext_basicConstraints_KEYM_E_PARAMETER_MISMATCH
 *   Std_ReturnType Rte_Call_KeyMCertificateElement_Ssa_TrustModelBackendPeerCert_ext_subKeyId_CertificateElementGet(uint8 *CertificateElementData, uint32 *CertificateDataLength)
 *     Argument CertificateElementData: uint8* is of type KeyM_CertificateElementType_Ssa_TrustModelBackendPeerCert_ext_subKeyId
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_KeyMCertificateElement_Ssa_TrustModelBackendPeerCert_ext_subKeyId_E_NOT_OK, RTE_E_KeyMCertificateElement_Ssa_TrustModelBackendPeerCert_ext_subKeyId_KEYM_E_KEY_CERT_EMPTY, RTE_E_KeyMCertificateElement_Ssa_TrustModelBackendPeerCert_ext_subKeyId_KEYM_E_KEY_CERT_INVALID, RTE_E_KeyMCertificateElement_Ssa_TrustModelBackendPeerCert_ext_subKeyId_KEYM_E_KEY_CERT_SIZE_MISMATCH, RTE_E_KeyMCertificateElement_Ssa_TrustModelBackendPeerCert_ext_subKeyId_KEYM_E_PARAMETER_MISMATCH
 *   Std_ReturnType Rte_Call_KeyMCertificateElement_Ssa_TrustModelBackendPeerCert_validityNotAfter_CertificateElementGet(uint8 *CertificateElementData, uint32 *CertificateDataLength)
 *     Argument CertificateElementData: uint8* is of type KeyM_CertificateElementType_Ssa_TrustModelBackendPeerCert_validityNotAfter
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_KeyMCertificateElement_Ssa_TrustModelBackendPeerCert_validityNotAfter_E_NOT_OK, RTE_E_KeyMCertificateElement_Ssa_TrustModelBackendPeerCert_validityNotAfter_KEYM_E_KEY_CERT_EMPTY, RTE_E_KeyMCertificateElement_Ssa_TrustModelBackendPeerCert_validityNotAfter_KEYM_E_KEY_CERT_INVALID, RTE_E_KeyMCertificateElement_Ssa_TrustModelBackendPeerCert_validityNotAfter_KEYM_E_KEY_CERT_SIZE_MISMATCH, RTE_E_KeyMCertificateElement_Ssa_TrustModelBackendPeerCert_validityNotAfter_KEYM_E_PARAMETER_MISMATCH
 *   Std_ReturnType Rte_Call_KeyMCertificateElement_Ssa_TrustModelEcuPeerCert_SerialNo_CertificateElementGet(uint8 *CertificateElementData, uint32 *CertificateDataLength)
 *     Argument CertificateElementData: uint8* is of type KeyM_CertificateElementType_Ssa_TrustModelEcuPeerCert_SerialNo
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_KeyMCertificateElement_Ssa_TrustModelEcuPeerCert_SerialNo_E_NOT_OK, RTE_E_KeyMCertificateElement_Ssa_TrustModelEcuPeerCert_SerialNo_KEYM_E_KEY_CERT_EMPTY, RTE_E_KeyMCertificateElement_Ssa_TrustModelEcuPeerCert_SerialNo_KEYM_E_KEY_CERT_INVALID, RTE_E_KeyMCertificateElement_Ssa_TrustModelEcuPeerCert_SerialNo_KEYM_E_KEY_CERT_SIZE_MISMATCH, RTE_E_KeyMCertificateElement_Ssa_TrustModelEcuPeerCert_SerialNo_KEYM_E_PARAMETER_MISMATCH
 *   Std_ReturnType Rte_Call_KeyMCertificateElement_Ssa_TrustModelEcuPeerCert_Version_CertificateElementGet(uint8 *CertificateElementData, uint32 *CertificateDataLength)
 *     Argument CertificateElementData: uint8* is of type KeyM_CertificateElementType_Ssa_TrustModelEcuPeerCert_Version
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_KeyMCertificateElement_Ssa_TrustModelEcuPeerCert_Version_E_NOT_OK, RTE_E_KeyMCertificateElement_Ssa_TrustModelEcuPeerCert_Version_KEYM_E_KEY_CERT_EMPTY, RTE_E_KeyMCertificateElement_Ssa_TrustModelEcuPeerCert_Version_KEYM_E_KEY_CERT_INVALID, RTE_E_KeyMCertificateElement_Ssa_TrustModelEcuPeerCert_Version_KEYM_E_KEY_CERT_SIZE_MISMATCH, RTE_E_KeyMCertificateElement_Ssa_TrustModelEcuPeerCert_Version_KEYM_E_PARAMETER_MISMATCH
 *   Std_ReturnType Rte_Call_KeyMCertificateElement_Ssa_TrustModelEcuPeerCert_ext_authKeyId_CertificateElementGet(uint8 *CertificateElementData, uint32 *CertificateDataLength)
 *     Argument CertificateElementData: uint8* is of type KeyM_CertificateElementType_Ssa_TrustModelEcuPeerCert_ext_authKeyId
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_KeyMCertificateElement_Ssa_TrustModelEcuPeerCert_ext_authKeyId_E_NOT_OK, RTE_E_KeyMCertificateElement_Ssa_TrustModelEcuPeerCert_ext_authKeyId_KEYM_E_KEY_CERT_EMPTY, RTE_E_KeyMCertificateElement_Ssa_TrustModelEcuPeerCert_ext_authKeyId_KEYM_E_KEY_CERT_INVALID, RTE_E_KeyMCertificateElement_Ssa_TrustModelEcuPeerCert_ext_authKeyId_KEYM_E_KEY_CERT_SIZE_MISMATCH, RTE_E_KeyMCertificateElement_Ssa_TrustModelEcuPeerCert_ext_authKeyId_KEYM_E_PARAMETER_MISMATCH
 *   Std_ReturnType Rte_Call_KeyMCertificateElement_Ssa_TrustModelEcuPeerCert_ext_specialEcu_CertificateElementGet(uint8 *CertificateElementData, uint32 *CertificateDataLength)
 *     Argument CertificateElementData: uint8* is of type KeyM_CertificateElementType_Ssa_TrustModelEcuPeerCert_ext_specialEcu
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_KeyMCertificateElement_Ssa_TrustModelEcuPeerCert_ext_specialEcu_E_NOT_OK, RTE_E_KeyMCertificateElement_Ssa_TrustModelEcuPeerCert_ext_specialEcu_KEYM_E_KEY_CERT_EMPTY, RTE_E_KeyMCertificateElement_Ssa_TrustModelEcuPeerCert_ext_specialEcu_KEYM_E_KEY_CERT_INVALID, RTE_E_KeyMCertificateElement_Ssa_TrustModelEcuPeerCert_ext_specialEcu_KEYM_E_KEY_CERT_SIZE_MISMATCH, RTE_E_KeyMCertificateElement_Ssa_TrustModelEcuPeerCert_ext_specialEcu_KEYM_E_PARAMETER_MISMATCH
 *   Std_ReturnType Rte_Call_KeyMCertificateElement_Ssa_TrustModelEcuPeerCert_ext_subKeyId_CertificateElementGet(uint8 *CertificateElementData, uint32 *CertificateDataLength)
 *     Argument CertificateElementData: uint8* is of type KeyM_CertificateElementType_Ssa_TrustModelEcuPeerCert_ext_subKeyId
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_KeyMCertificateElement_Ssa_TrustModelEcuPeerCert_ext_subKeyId_E_NOT_OK, RTE_E_KeyMCertificateElement_Ssa_TrustModelEcuPeerCert_ext_subKeyId_KEYM_E_KEY_CERT_EMPTY, RTE_E_KeyMCertificateElement_Ssa_TrustModelEcuPeerCert_ext_subKeyId_KEYM_E_KEY_CERT_INVALID, RTE_E_KeyMCertificateElement_Ssa_TrustModelEcuPeerCert_ext_subKeyId_KEYM_E_KEY_CERT_SIZE_MISMATCH, RTE_E_KeyMCertificateElement_Ssa_TrustModelEcuPeerCert_ext_subKeyId_KEYM_E_PARAMETER_MISMATCH
 *   Std_ReturnType Rte_Call_KeyMCertificateElement_Ssa_TrustModelEcuPeerCert_validityNotAfter_CertificateElementGet(uint8 *CertificateElementData, uint32 *CertificateDataLength)
 *     Argument CertificateElementData: uint8* is of type KeyM_CertificateElementType_Ssa_TrustModelEcuPeerCert_validityNotAfter
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_KeyMCertificateElement_Ssa_TrustModelEcuPeerCert_validityNotAfter_E_NOT_OK, RTE_E_KeyMCertificateElement_Ssa_TrustModelEcuPeerCert_validityNotAfter_KEYM_E_KEY_CERT_EMPTY, RTE_E_KeyMCertificateElement_Ssa_TrustModelEcuPeerCert_validityNotAfter_KEYM_E_KEY_CERT_INVALID, RTE_E_KeyMCertificateElement_Ssa_TrustModelEcuPeerCert_validityNotAfter_KEYM_E_KEY_CERT_SIZE_MISMATCH, RTE_E_KeyMCertificateElement_Ssa_TrustModelEcuPeerCert_validityNotAfter_KEYM_E_PARAMETER_MISMATCH
 *   Std_ReturnType Rte_Call_KeyMCertificateElement_Ssa_TrustModelIntermediatePeerCert_SerialNo_CertificateElementGet(uint8 *CertificateElementData, uint32 *CertificateDataLength)
 *     Argument CertificateElementData: uint8* is of type KeyM_CertificateElementType_Ssa_TrustModelIntermediatePeerCert_SerialNo
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_KeyMCertificateElement_Ssa_TrustModelIntermediatePeerCert_SerialNo_E_NOT_OK, RTE_E_KeyMCertificateElement_Ssa_TrustModelIntermediatePeerCert_SerialNo_KEYM_E_KEY_CERT_EMPTY, RTE_E_KeyMCertificateElement_Ssa_TrustModelIntermediatePeerCert_SerialNo_KEYM_E_KEY_CERT_INVALID, RTE_E_KeyMCertificateElement_Ssa_TrustModelIntermediatePeerCert_SerialNo_KEYM_E_KEY_CERT_SIZE_MISMATCH, RTE_E_KeyMCertificateElement_Ssa_TrustModelIntermediatePeerCert_SerialNo_KEYM_E_PARAMETER_MISMATCH
 *   Std_ReturnType Rte_Call_KeyMCertificateElement_Ssa_TrustModelIntermediatePeerCert_Version_CertificateElementGet(uint8 *CertificateElementData, uint32 *CertificateDataLength)
 *     Argument CertificateElementData: uint8* is of type KeyM_CertificateElementType_Ssa_TrustModelIntermediatePeerCert_Version
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_KeyMCertificateElement_Ssa_TrustModelIntermediatePeerCert_Version_E_NOT_OK, RTE_E_KeyMCertificateElement_Ssa_TrustModelIntermediatePeerCert_Version_KEYM_E_KEY_CERT_EMPTY, RTE_E_KeyMCertificateElement_Ssa_TrustModelIntermediatePeerCert_Version_KEYM_E_KEY_CERT_INVALID, RTE_E_KeyMCertificateElement_Ssa_TrustModelIntermediatePeerCert_Version_KEYM_E_KEY_CERT_SIZE_MISMATCH, RTE_E_KeyMCertificateElement_Ssa_TrustModelIntermediatePeerCert_Version_KEYM_E_PARAMETER_MISMATCH
 *   Std_ReturnType Rte_Call_KeyMCertificateElement_Ssa_TrustModelIntermediatePeerCert_ext_authKeyId_CertificateElementGet(uint8 *CertificateElementData, uint32 *CertificateDataLength)
 *     Argument CertificateElementData: uint8* is of type KeyM_CertificateElementType_Ssa_TrustModelIntermediatePeerCert_ext_authKeyId
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_KeyMCertificateElement_Ssa_TrustModelIntermediatePeerCert_ext_authKeyId_E_NOT_OK, RTE_E_KeyMCertificateElement_Ssa_TrustModelIntermediatePeerCert_ext_authKeyId_KEYM_E_KEY_CERT_EMPTY, RTE_E_KeyMCertificateElement_Ssa_TrustModelIntermediatePeerCert_ext_authKeyId_KEYM_E_KEY_CERT_INVALID, RTE_E_KeyMCertificateElement_Ssa_TrustModelIntermediatePeerCert_ext_authKeyId_KEYM_E_KEY_CERT_SIZE_MISMATCH, RTE_E_KeyMCertificateElement_Ssa_TrustModelIntermediatePeerCert_ext_authKeyId_KEYM_E_PARAMETER_MISMATCH
 *   Std_ReturnType Rte_Call_KeyMCertificateElement_Ssa_TrustModelIntermediatePeerCert_ext_basicConstraints_CertificateElementGet(uint8 *CertificateElementData, uint32 *CertificateDataLength)
 *     Argument CertificateElementData: uint8* is of type KeyM_CertificateElementType_Ssa_TrustModelIntermediatePeerCert_ext_basicConstraints
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_KeyMCertificateElement_Ssa_TrustModelIntermediatePeerCert_ext_basicConstraints_E_NOT_OK, RTE_E_KeyMCertificateElement_Ssa_TrustModelIntermediatePeerCert_ext_basicConstraints_KEYM_E_KEY_CERT_EMPTY, RTE_E_KeyMCertificateElement_Ssa_TrustModelIntermediatePeerCert_ext_basicConstraints_KEYM_E_KEY_CERT_INVALID, RTE_E_KeyMCertificateElement_Ssa_TrustModelIntermediatePeerCert_ext_basicConstraints_KEYM_E_KEY_CERT_SIZE_MISMATCH, RTE_E_KeyMCertificateElement_Ssa_TrustModelIntermediatePeerCert_ext_basicConstraints_KEYM_E_PARAMETER_MISMATCH
 *   Std_ReturnType Rte_Call_KeyMCertificateElement_Ssa_TrustModelIntermediatePeerCert_ext_subKeyId_CertificateElementGet(uint8 *CertificateElementData, uint32 *CertificateDataLength)
 *     Argument CertificateElementData: uint8* is of type KeyM_CertificateElementType_Ssa_TrustModelIntermediatePeerCert_ext_subKeyId
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_KeyMCertificateElement_Ssa_TrustModelIntermediatePeerCert_ext_subKeyId_E_NOT_OK, RTE_E_KeyMCertificateElement_Ssa_TrustModelIntermediatePeerCert_ext_subKeyId_KEYM_E_KEY_CERT_EMPTY, RTE_E_KeyMCertificateElement_Ssa_TrustModelIntermediatePeerCert_ext_subKeyId_KEYM_E_KEY_CERT_INVALID, RTE_E_KeyMCertificateElement_Ssa_TrustModelIntermediatePeerCert_ext_subKeyId_KEYM_E_KEY_CERT_SIZE_MISMATCH, RTE_E_KeyMCertificateElement_Ssa_TrustModelIntermediatePeerCert_ext_subKeyId_KEYM_E_PARAMETER_MISMATCH
 *   Std_ReturnType Rte_Call_KeyMCertificateElement_Ssa_TrustModelIntermediatePeerCert_validityNotAfter_CertificateElementGet(uint8 *CertificateElementData, uint32 *CertificateDataLength)
 *     Argument CertificateElementData: uint8* is of type KeyM_CertificateElementType_Ssa_TrustModelIntermediatePeerCert_validityNotAfter
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_KeyMCertificateElement_Ssa_TrustModelIntermediatePeerCert_validityNotAfter_E_NOT_OK, RTE_E_KeyMCertificateElement_Ssa_TrustModelIntermediatePeerCert_validityNotAfter_KEYM_E_KEY_CERT_EMPTY, RTE_E_KeyMCertificateElement_Ssa_TrustModelIntermediatePeerCert_validityNotAfter_KEYM_E_KEY_CERT_INVALID, RTE_E_KeyMCertificateElement_Ssa_TrustModelIntermediatePeerCert_validityNotAfter_KEYM_E_KEY_CERT_SIZE_MISMATCH, RTE_E_KeyMCertificateElement_Ssa_TrustModelIntermediatePeerCert_validityNotAfter_KEYM_E_PARAMETER_MISMATCH
 *   Std_ReturnType Rte_Call_KeyMCertificateElement_Ssa_TrustModelRootCert_Issuer_CertificateElementGet(uint8 *CertificateElementData, uint32 *CertificateDataLength)
 *     Argument CertificateElementData: uint8* is of type KeyM_CertificateElementType_Ssa_TrustModelRootCert_Issuer
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_KeyMCertificateElement_Ssa_TrustModelRootCert_Issuer_E_NOT_OK, RTE_E_KeyMCertificateElement_Ssa_TrustModelRootCert_Issuer_KEYM_E_KEY_CERT_EMPTY, RTE_E_KeyMCertificateElement_Ssa_TrustModelRootCert_Issuer_KEYM_E_KEY_CERT_INVALID, RTE_E_KeyMCertificateElement_Ssa_TrustModelRootCert_Issuer_KEYM_E_KEY_CERT_SIZE_MISMATCH, RTE_E_KeyMCertificateElement_Ssa_TrustModelRootCert_Issuer_KEYM_E_PARAMETER_MISMATCH
 *   Std_ReturnType Rte_Call_KeyMCertificateElement_Ssa_TrustModelRootCert_SerialNo_CertificateElementGet(uint8 *CertificateElementData, uint32 *CertificateDataLength)
 *     Argument CertificateElementData: uint8* is of type KeyM_CertificateElementType_Ssa_TrustModelRootCert_SerialNo
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_KeyMCertificateElement_Ssa_TrustModelRootCert_SerialNo_E_NOT_OK, RTE_E_KeyMCertificateElement_Ssa_TrustModelRootCert_SerialNo_KEYM_E_KEY_CERT_EMPTY, RTE_E_KeyMCertificateElement_Ssa_TrustModelRootCert_SerialNo_KEYM_E_KEY_CERT_INVALID, RTE_E_KeyMCertificateElement_Ssa_TrustModelRootCert_SerialNo_KEYM_E_KEY_CERT_SIZE_MISMATCH, RTE_E_KeyMCertificateElement_Ssa_TrustModelRootCert_SerialNo_KEYM_E_PARAMETER_MISMATCH
 *   Std_ReturnType Rte_Call_KeyMCertificateElement_Ssa_TrustModelRootCert_SubjectPublicKeyInfoKey_CertificateElementGet(uint8 *CertificateElementData, uint32 *CertificateDataLength)
 *     Argument CertificateElementData: uint8* is of type KeyM_CertificateElementType_Ssa_TrustModelRootCert_SubjectPublicKeyInfoKey
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_KeyMCertificateElement_Ssa_TrustModelRootCert_SubjectPublicKeyInfoKey_E_NOT_OK, RTE_E_KeyMCertificateElement_Ssa_TrustModelRootCert_SubjectPublicKeyInfoKey_KEYM_E_KEY_CERT_EMPTY, RTE_E_KeyMCertificateElement_Ssa_TrustModelRootCert_SubjectPublicKeyInfoKey_KEYM_E_KEY_CERT_INVALID, RTE_E_KeyMCertificateElement_Ssa_TrustModelRootCert_SubjectPublicKeyInfoKey_KEYM_E_KEY_CERT_SIZE_MISMATCH, RTE_E_KeyMCertificateElement_Ssa_TrustModelRootCert_SubjectPublicKeyInfoKey_KEYM_E_PARAMETER_MISMATCH
 *   Std_ReturnType Rte_Call_KeyMCertificateElement_Ssa_TrustModelRootCert_Version_CertificateElementGet(uint8 *CertificateElementData, uint32 *CertificateDataLength)
 *     Argument CertificateElementData: uint8* is of type KeyM_CertificateElementType_Ssa_TrustModelRootCert_Version
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_KeyMCertificateElement_Ssa_TrustModelRootCert_Version_E_NOT_OK, RTE_E_KeyMCertificateElement_Ssa_TrustModelRootCert_Version_KEYM_E_KEY_CERT_EMPTY, RTE_E_KeyMCertificateElement_Ssa_TrustModelRootCert_Version_KEYM_E_KEY_CERT_INVALID, RTE_E_KeyMCertificateElement_Ssa_TrustModelRootCert_Version_KEYM_E_KEY_CERT_SIZE_MISMATCH, RTE_E_KeyMCertificateElement_Ssa_TrustModelRootCert_Version_KEYM_E_PARAMETER_MISMATCH
 *   Std_ReturnType Rte_Call_KeyMCertificateElement_Ssa_TrustModelRootCert_ext_basicConstraints_CertificateElementGet(uint8 *CertificateElementData, uint32 *CertificateDataLength)
 *     Argument CertificateElementData: uint8* is of type KeyM_CertificateElementType_Ssa_TrustModelRootCert_ext_basicConstraints
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_KeyMCertificateElement_Ssa_TrustModelRootCert_ext_basicConstraints_E_NOT_OK, RTE_E_KeyMCertificateElement_Ssa_TrustModelRootCert_ext_basicConstraints_KEYM_E_KEY_CERT_EMPTY, RTE_E_KeyMCertificateElement_Ssa_TrustModelRootCert_ext_basicConstraints_KEYM_E_KEY_CERT_INVALID, RTE_E_KeyMCertificateElement_Ssa_TrustModelRootCert_ext_basicConstraints_KEYM_E_KEY_CERT_SIZE_MISMATCH, RTE_E_KeyMCertificateElement_Ssa_TrustModelRootCert_ext_basicConstraints_KEYM_E_PARAMETER_MISMATCH
 *   Std_ReturnType Rte_Call_KeyMCertificateElement_Ssa_TrustModelRootCert_ext_keyUsage_CertificateElementGet(uint8 *CertificateElementData, uint32 *CertificateDataLength)
 *     Argument CertificateElementData: uint8* is of type KeyM_CertificateElementType_Ssa_TrustModelRootCert_ext_keyUsage
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_KeyMCertificateElement_Ssa_TrustModelRootCert_ext_keyUsage_E_NOT_OK, RTE_E_KeyMCertificateElement_Ssa_TrustModelRootCert_ext_keyUsage_KEYM_E_KEY_CERT_EMPTY, RTE_E_KeyMCertificateElement_Ssa_TrustModelRootCert_ext_keyUsage_KEYM_E_KEY_CERT_INVALID, RTE_E_KeyMCertificateElement_Ssa_TrustModelRootCert_ext_keyUsage_KEYM_E_KEY_CERT_SIZE_MISMATCH, RTE_E_KeyMCertificateElement_Ssa_TrustModelRootCert_ext_keyUsage_KEYM_E_PARAMETER_MISMATCH
 *   Std_ReturnType Rte_Call_KeyMCertificateElement_Ssa_TrustModelRootCert_ext_subKeyId_CertificateElementGet(uint8 *CertificateElementData, uint32 *CertificateDataLength)
 *     Argument CertificateElementData: uint8* is of type KeyM_CertificateElementType_Ssa_TrustModelRootCert_ext_subKeyId
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_KeyMCertificateElement_Ssa_TrustModelRootCert_ext_subKeyId_E_NOT_OK, RTE_E_KeyMCertificateElement_Ssa_TrustModelRootCert_ext_subKeyId_KEYM_E_KEY_CERT_EMPTY, RTE_E_KeyMCertificateElement_Ssa_TrustModelRootCert_ext_subKeyId_KEYM_E_KEY_CERT_INVALID, RTE_E_KeyMCertificateElement_Ssa_TrustModelRootCert_ext_subKeyId_KEYM_E_KEY_CERT_SIZE_MISMATCH, RTE_E_KeyMCertificateElement_Ssa_TrustModelRootCert_ext_subKeyId_KEYM_E_PARAMETER_MISMATCH
 *   Std_ReturnType Rte_Call_KeyMCertificateElement_Ssa_TrustModelRootCert_subject_CertificateElementGet(uint8 *CertificateElementData, uint32 *CertificateDataLength)
 *     Argument CertificateElementData: uint8* is of type KeyM_CertificateElementType_Ssa_TrustModelRootCert_subject
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_KeyMCertificateElement_Ssa_TrustModelRootCert_subject_E_NOT_OK, RTE_E_KeyMCertificateElement_Ssa_TrustModelRootCert_subject_KEYM_E_KEY_CERT_EMPTY, RTE_E_KeyMCertificateElement_Ssa_TrustModelRootCert_subject_KEYM_E_KEY_CERT_INVALID, RTE_E_KeyMCertificateElement_Ssa_TrustModelRootCert_subject_KEYM_E_KEY_CERT_SIZE_MISMATCH, RTE_E_KeyMCertificateElement_Ssa_TrustModelRootCert_subject_KEYM_E_PARAMETER_MISMATCH
 *   Std_ReturnType Rte_Call_KeyMCertificateElement_Ssa_TrustModelRootCert_validityNotAfter_CertificateElementGet(uint8 *CertificateElementData, uint32 *CertificateDataLength)
 *     Argument CertificateElementData: uint8* is of type KeyM_CertificateElementType_Ssa_TrustModelRootCert_validityNotAfter
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_KeyMCertificateElement_Ssa_TrustModelRootCert_validityNotAfter_E_NOT_OK, RTE_E_KeyMCertificateElement_Ssa_TrustModelRootCert_validityNotAfter_KEYM_E_KEY_CERT_EMPTY, RTE_E_KeyMCertificateElement_Ssa_TrustModelRootCert_validityNotAfter_KEYM_E_KEY_CERT_INVALID, RTE_E_KeyMCertificateElement_Ssa_TrustModelRootCert_validityNotAfter_KEYM_E_KEY_CERT_SIZE_MISMATCH, RTE_E_KeyMCertificateElement_Ssa_TrustModelRootCert_validityNotAfter_KEYM_E_PARAMETER_MISMATCH
 *   Std_ReturnType Rte_Call_KeyMCertificate_Ssa_TrustModelBackendPeerCert_GetStatus(KeyM_CertificateStatusType *Status)
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_KeyMCertificate_Ssa_TrustModelBackendPeerCert_E_NOT_OK
 *   Std_ReturnType Rte_Call_KeyMCertificate_Ssa_TrustModelEcuPeerCert_GetStatus(KeyM_CertificateStatusType *Status)
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_KeyMCertificate_Ssa_TrustModelEcuPeerCert_E_NOT_OK
 *   Std_ReturnType Rte_Call_KeyMCertificate_Ssa_TrustModelEcuPeerCert_VerifyCertificate(void)
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_KeyMCertificate_Ssa_TrustModelEcuPeerCert_E_NOT_OK, RTE_E_KeyMCertificate_Ssa_TrustModelEcuPeerCert_KEYM_E_BUSY, RTE_E_KeyMCertificate_Ssa_TrustModelEcuPeerCert_KEYM_E_CERT_INVALID_CHAIN_OF_TRUST, RTE_E_KeyMCertificate_Ssa_TrustModelEcuPeerCert_KEYM_E_KEY_CERT_EMPTY, RTE_E_KeyMCertificate_Ssa_TrustModelEcuPeerCert_KEYM_E_KEY_CERT_SIZE_MISMATCH, RTE_E_KeyMCertificate_Ssa_TrustModelEcuPeerCert_KEYM_E_PARAMETER_MISMATCH
 *   Std_ReturnType Rte_Call_KeyMCertificate_Ssa_TrustModelIntermediatePeerCert_GetStatus(KeyM_CertificateStatusType *Status)
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_KeyMCertificate_Ssa_TrustModelIntermediatePeerCert_E_NOT_OK
 *   Std_ReturnType Rte_Call_Key_AesRamKey_KeyElementSet(uint32 keyElementId, const uint8 *keyPtr, uint32 keyLength)
 *     Argument keyPtr: uint8* is of type Csm_KeyDataType_Ssa_AesRamKey
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_CsmKeyManagement_Ssa_AesRamKey_CSM_E_BUSY, RTE_E_CsmKeyManagement_Ssa_AesRamKey_CSM_E_KEY_NOT_AVAILABLE, RTE_E_CsmKeyManagement_Ssa_AesRamKey_CSM_E_KEY_SIZE_MISMATCH, RTE_E_CsmKeyManagement_Ssa_AesRamKey_CSM_E_KEY_WRITE_FAIL, RTE_E_CsmKeyManagement_Ssa_AesRamKey_CSM_E_SMALL_BUFFER, RTE_E_CsmKeyManagement_Ssa_AesRamKey_E_NOT_OK
 *   Std_ReturnType Rte_Call_Key_AesRamKey_KeySetValid(void)
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_CsmKeyManagement_Ssa_AesRamKey_CSM_E_BUSY, RTE_E_CsmKeyManagement_Ssa_AesRamKey_E_NOT_OK
 *   Std_ReturnType Rte_Call_Key_SharedSecret_KeyElementGet(uint32 keyElementId, uint8 *keyPtr, uint32 *keyLength)
 *     Argument keyPtr: uint8* is of type Csm_KeyDataType_Ssa_SharedSecret
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_CsmKeyManagement_Ssa_SharedSecret_CSM_E_BUSY, RTE_E_CsmKeyManagement_Ssa_SharedSecret_CSM_E_KEY_EMPTY, RTE_E_CsmKeyManagement_Ssa_SharedSecret_CSM_E_KEY_NOT_AVAILABLE, RTE_E_CsmKeyManagement_Ssa_SharedSecret_CSM_E_KEY_READ_FAIL, RTE_E_CsmKeyManagement_Ssa_SharedSecret_CSM_E_SMALL_BUFFER, RTE_E_CsmKeyManagement_Ssa_SharedSecret_E_NOT_OK
 *   Std_ReturnType Rte_Call_Key_SharedSecretKeyExchange_KeyElementGet(uint32 keyElementId, uint8 *keyPtr, uint32 *keyLength)
 *     Argument keyPtr: uint8* is of type Csm_KeyDataType_Ssa_SharedSecretKeyExchange
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_CsmKeyManagement_Ssa_SharedSecretKeyExchange_CSM_E_BUSY, RTE_E_CsmKeyManagement_Ssa_SharedSecretKeyExchange_CSM_E_KEY_EMPTY, RTE_E_CsmKeyManagement_Ssa_SharedSecretKeyExchange_CSM_E_KEY_NOT_AVAILABLE, RTE_E_CsmKeyManagement_Ssa_SharedSecretKeyExchange_CSM_E_KEY_READ_FAIL, RTE_E_CsmKeyManagement_Ssa_SharedSecretKeyExchange_CSM_E_SMALL_BUFFER, RTE_E_CsmKeyManagement_Ssa_SharedSecretKeyExchange_E_NOT_OK
 *   Std_ReturnType Rte_Call_Key_SharedSecretKeyExchange_KeyElementSet(uint32 keyElementId, const uint8 *keyPtr, uint32 keyLength)
 *     Argument keyPtr: uint8* is of type Csm_KeyDataType_Ssa_SharedSecretKeyExchange
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_CsmKeyManagement_Ssa_SharedSecretKeyExchange_CSM_E_BUSY, RTE_E_CsmKeyManagement_Ssa_SharedSecretKeyExchange_CSM_E_KEY_NOT_AVAILABLE, RTE_E_CsmKeyManagement_Ssa_SharedSecretKeyExchange_CSM_E_KEY_SIZE_MISMATCH, RTE_E_CsmKeyManagement_Ssa_SharedSecretKeyExchange_CSM_E_KEY_WRITE_FAIL, RTE_E_CsmKeyManagement_Ssa_SharedSecretKeyExchange_CSM_E_SMALL_BUFFER, RTE_E_CsmKeyManagement_Ssa_SharedSecretKeyExchange_E_NOT_OK
 *   Std_ReturnType Rte_Call_Key_SharedSecretKeyExchange_KeyExchangeCalcPubVal(uint8 *publicValuePtr, uint32 *publicValueLengthPtr)
 *     Argument publicValuePtr: uint8* is of type Csm_PublicValueDataType_Ssa_SharedSecretKeyExchange
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_CsmKeyManagement_Ssa_SharedSecretKeyExchange_CSM_E_BUSY, RTE_E_CsmKeyManagement_Ssa_SharedSecretKeyExchange_CSM_E_KEY_EMPTY, RTE_E_CsmKeyManagement_Ssa_SharedSecretKeyExchange_CSM_E_SMALL_BUFFER, RTE_E_CsmKeyManagement_Ssa_SharedSecretKeyExchange_E_NOT_OK
 *   Std_ReturnType Rte_Call_Key_SharedSecretKeyExchange_KeyExchangeCalcSecret(const uint8 *partnerPublicValuePtr, uint32 partnerPublicValueLength)
 *     Argument partnerPublicValuePtr: uint8* is of type Csm_PublicValueDataType_Ssa_SharedSecretKeyExchange
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_CsmKeyManagement_Ssa_SharedSecretKeyExchange_CSM_E_BUSY, RTE_E_CsmKeyManagement_Ssa_SharedSecretKeyExchange_CSM_E_KEY_EMPTY, RTE_E_CsmKeyManagement_Ssa_SharedSecretKeyExchange_CSM_E_SMALL_BUFFER, RTE_E_CsmKeyManagement_Ssa_SharedSecretKeyExchange_E_NOT_OK
 *   Std_ReturnType Rte_Call_Key_SharedSecretKeyExchange_KeySetValid(void)
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_CsmKeyManagement_Ssa_SharedSecretKeyExchange_CSM_E_BUSY, RTE_E_CsmKeyManagement_Ssa_SharedSecretKeyExchange_E_NOT_OK
 *   Std_ReturnType Rte_Call_Key_SignatureRamKey_KeyElementSet(uint32 keyElementId, const uint8 *keyPtr, uint32 keyLength)
 *     Argument keyPtr: uint8* is of type Csm_KeyDataType_Ssa_SignatureRamKey
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_CsmKeyManagement_Ssa_SignatureRamKey_CSM_E_BUSY, RTE_E_CsmKeyManagement_Ssa_SignatureRamKey_CSM_E_KEY_NOT_AVAILABLE, RTE_E_CsmKeyManagement_Ssa_SignatureRamKey_CSM_E_KEY_SIZE_MISMATCH, RTE_E_CsmKeyManagement_Ssa_SignatureRamKey_CSM_E_KEY_WRITE_FAIL, RTE_E_CsmKeyManagement_Ssa_SignatureRamKey_CSM_E_SMALL_BUFFER, RTE_E_CsmKeyManagement_Ssa_SignatureRamKey_E_NOT_OK
 *   Std_ReturnType Rte_Call_Key_SignatureRamKey_KeySetValid(void)
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_CsmKeyManagement_Ssa_SignatureRamKey_CSM_E_BUSY, RTE_E_CsmKeyManagement_Ssa_SignatureRamKey_E_NOT_OK
 *
 **********************************************************************************************************************
 *
 * Runnable prototype:
 * ===================
 *   Std_ReturnType Ssa_KeyM_RoutineServices_Trust_Model_SecOC_ECU_TickCount_Synchronization(const uint8 *Nonce_In, const uint8 *Ephemeral_ECU_Public_Key_In, const uint8 *In_Data_Signature_In, const uint8 *In_Certificates_In, Dcm_OpStatusType OpStatus, uint8 *routineInfo_Out, uint8 *Verification_Result_Out, uint8 *Date_and_Time_Out, uint8 *Tick_Count_Out, uint8 *Tick_Count_Offset_Out, uint8 *Encrypted_Nonce_and_Shared_Secret_Out, uint8 *Ephemeral_VSM_Public_Key_Out, uint8 *Out_Data_Signature_Out, uint8 *Out_Certificates_Out, uint16 *DataLength, Dcm_NegativeResponseCodeType *ErrorCode)
 *     Argument Nonce_In: uint8* is of type Dcm_Data32ByteType
 *     Argument Ephemeral_ECU_Public_Key_In: uint8* is of type Dcm_Data32ByteType
 *     Argument In_Data_Signature_In: uint8* is of type Dcm_Data64ByteType
 *     Argument In_Certificates_In: uint8* is of type Dcm_Data3006ByteType
 *     Argument Date_and_Time_Out: uint8* is of type Dcm_Data7ByteType
 *     Argument Tick_Count_Out: uint8* is of type Dcm_Data5ByteType
 *     Argument Tick_Count_Offset_Out: uint8* is of type Dcm_Data5ByteType
 *     Argument Encrypted_Nonce_and_Shared_Secret_Out: uint8* is of type Dcm_Data80ByteType
 *     Argument Ephemeral_VSM_Public_Key_Out: uint8* is of type Dcm_Data32ByteType
 *     Argument Out_Data_Signature_Out: uint8* is of type Dcm_Data64ByteType
 *     Argument Out_Certificates_Out: uint8* is of type Dcm_Data3006ByteType
 *
 **********************************************************************************************************************
 *
 * Available Application Errors:
 * =============================
 *   RTE_E_RoutineServices_Trust_Model_SecOC_ECU_TickCount_Synchronization_DCM_E_FORCE_RCRRP
 *   RTE_E_RoutineServices_Trust_Model_SecOC_ECU_TickCount_Synchronization_DCM_E_PENDING
 *   RTE_E_RoutineServices_Trust_Model_SecOC_ECU_TickCount_Synchronization_E_NOT_OK
 *
 *********************************************************************************************************************/
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << Start of documentation area >>                  DO NOT CHANGE THIS COMMENT!
 * Symbol: Ssa_KeyM_RoutineServices_Trust_Model_SecOC_ECU_TickCount_Synchronization_doc
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
/*!
 * \spec
 *    requires $lengthOf(Date_and_Time_Out) >= sizeof(Dcm_Data7ByteType);
 *    requires $lengthOf(Tick_Count_Out) >= sizeof(Dcm_Data5ByteType);
 *    requires $lengthOf(Tick_Count_Offset_Out) >= sizeof(Dcm_Data5ByteType);
 *    requires $lengthOf(Encrypted_Nonce_and_Shared_Secret_Out) >= sizeof(Dcm_Data80ByteType);
 *    requires $lengthOf(Ephemeral_VSM_Public_Key_Out) >= sizeof(Dcm_Data32ByteType);
 *    requires $lengthOf(Out_Data_Signature_Out) >= sizeof(Dcm_Data64ByteType);
 *    requires $lengthOf(Out_Certificates_Out) >= sizeof(Dcm_Data3006ByteType);
 * \endspec
 */
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << End of documentation area >>                    DO NOT CHANGE THIS COMMENT!
 *********************************************************************************************************************/

FUNC(Std_ReturnType, Ssa_KeyM_CODE) Ssa_KeyM_RoutineServices_Trust_Model_SecOC_ECU_TickCount_Synchronization(
  P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) Nonce_In,
  P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) Ephemeral_ECU_Public_Key_In,
  P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) In_Data_Signature_In,
  P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) In_Certificates_In,
  Dcm_OpStatusType OpStatus,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) routineInfo_Out,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) Verification_Result_Out,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) Date_and_Time_Out,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) Tick_Count_Out,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) Tick_Count_Offset_Out,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) Encrypted_Nonce_and_Shared_Secret_Out,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) Ephemeral_VSM_Public_Key_Out,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) Out_Data_Signature_Out,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) Out_Certificates_Out,
  P2VAR(uint16, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) DataLength,
  P2VAR(Dcm_NegativeResponseCodeType, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) ErrorCode) /* PRQA S 0624, 3206 */ /* MD_Rte_0624, MD_Rte_3206 */
{
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << Start of runnable implementation >>             DO NOT CHANGE THIS COMMENT!
 * Symbol: Ssa_KeyM_RoutineServices_Trust_Model_SecOC_ECU_TickCount_Synchronization (returns application error)
 *********************************************************************************************************************/
  Std_ReturnType retVal = RTE_E_RoutineServices_Trust_Model_SecOC_ECU_TickCount_Synchronization_E_NOT_OK;

  /* ----- Development Error Checks ------------------------------------- */
# if (SSA_DEV_ERROR_DETECT == STD_ON)
  if ((Nonce_In == NULL_PTR)
    || (Ephemeral_ECU_Public_Key_In == NULL_PTR)
    || (In_Data_Signature_In == NULL_PTR)
    || (In_Certificates_In == NULL_PTR)
    || (routineInfo_Out == NULL_PTR)
    || (Verification_Result_Out == NULL_PTR)
    || (Date_and_Time_Out == NULL_PTR)
    || (Tick_Count_Out == NULL_PTR)
    || (Tick_Count_Offset_Out == NULL_PTR)
    || (Encrypted_Nonce_and_Shared_Secret_Out == NULL_PTR)
    || (Ephemeral_VSM_Public_Key_Out == NULL_PTR)
    || (Out_Data_Signature_Out == NULL_PTR)
    || (Out_Certificates_Out == NULL_PTR)
    || (DataLength == NULL_PTR)
    || (ErrorCode == NULL_PTR))
  {
    /* retVal already set */
  }
  else
# endif /* SSA_DEV_ERROR_DETECT == STD_ON */
  {
    /* #10 Process the encryption of the car-specific secret and do allow the usage of the standard shared secret. */
    retVal = KeyM_EncryptSharedSecret(
      SSA_TRUST_MODEL_LIVE_KEY_PAIR,
      Nonce_In,
      Ephemeral_ECU_Public_Key_In,
      In_Data_Signature_In,
      In_Certificates_In,
      OpStatus,
      routineInfo_Out,
      Verification_Result_Out,
      Date_and_Time_Out,
      Tick_Count_Out,
      Tick_Count_Offset_Out,
      Encrypted_Nonce_and_Shared_Secret_Out,
      Ephemeral_VSM_Public_Key_Out,
      Out_Data_Signature_Out,
      Out_Certificates_Out,
      DataLength,
      ErrorCode,
      TRUE);

    /* Map return value. */
    switch (retVal)
    {
      /* A compile time assertion ensures that the pending and E_NOT_OK values set here are equal to
       * RTE_E_RoutineServices_Trust_Model_SecOC_ECU_TickCount_Synchronization_DCM_E_PENDING and
         RTE_E_RoutineServices_Trust_Model_SecOC_ECU_TickCount_Synchronization_E_NOT_OK. */
      case SSA_E_PENDING:
        retVal = RTE_E_RoutineServices_Trust_Model_SecOC_ECU_Shared_Secret_Encryption_DCM_E_PENDING;
        break;
      case E_OK:
        retVal = RTE_E_OK;
        break;
      default:
        retVal = RTE_E_RoutineServices_Trust_Model_SecOC_ECU_Shared_Secret_Encryption_E_NOT_OK;
        break;
    }
  }

  return retVal;
  /* PRQA S 6060 4 */ /* MD_SSA_STPAR */
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << End of runnable implementation >>               DO NOT CHANGE THIS COMMENT!
 *********************************************************************************************************************/
}

#endif

#define Ssa_KeyM_STOP_SEC_CODE
#include "Ssa_KeyM_MemMap.h" /* PRQA S 5087 */ /* MD_MSR_MemMap */

/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << Start of function definition area >>            DO NOT CHANGE THIS COMMENT!
 *********************************************************************************************************************/

/**********************************************************************************************************************
 *  LOCAL FUNCTIONS
 *********************************************************************************************************************/
#define Ssa_KeyM_START_SEC_CODE
#include "Ssa_KeyM_MemMap.h" /* PRQA S 5087 */ /* MD_MSR_MemMap */

/**********************************************************************************************************************
 *  KeyM_StoreSecretHash()
 **********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 */
SSA_KEYM_LOCAL FUNC(Std_ReturnType, Ssa_KeyM_CODE) KeyM_StoreSecretHash(
  P2CONST(uint8, AUTOMATIC, AUTOMATIC) carSpecificSecret)
{
  uint8 sharedSecretHash[SSA_SIZEOF_HASHVALUE];
  uint32 secretHashLength = SSA_SIZEOF_HASHVALUE;
  Std_ReturnType retVal;
  /* #10 Calculate the hash value of secret. */
  retVal = Rte_Call_SsaCdd_Csm_Hash(SSA_KEYM_HASH_JOB_ID, CRYPTO_OPERATIONMODE_SINGLECALL, carSpecificSecret, SSA_SIZEOF_SECRET, sharedSecretHash, &secretHashLength);
  if ((retVal != E_OK) || (secretHashLength != SSA_SIZEOF_HASHVALUE))
  {
    retVal = E_NOT_OK;
  }
  else
  {
    /* #20 Store the calculated hash value. */
    retVal = Rte_Call_Key_SharedSecretHash_KeyElementSet(SSA_KE_MAC_PROOF, &sharedSecretHash[SSA_SIZEOF_HASHVALUE - SSA_SIZEOF_SECRETHASH], SSA_SIZEOF_SECRETHASH);
  }

  if (retVal == E_OK)
  {
    retVal = Rte_Call_Key_SharedSecretHash_KeySetValid();
  }

  return retVal;
}

/**********************************************************************************************************************
 *  KeyM_GetAndParseStoredCert()
 **********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 */
SSA_KEYM_LOCAL FUNC(Std_ReturnType, Ssa_KeyM_CODE) KeyM_GetAndParseStoredCert(
  CertP_PkiRoleType pkiRole,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) certBuffer,
  P2VAR(uint16, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) certBufferLength,
  boolean reParse)
{
  Std_ReturnType rVal = E_OK;
  uint32 lengthCert = SSA_SIZEOF_CERT_MAX;
  P2VAR(CertP_ParsedCertStructureType, AUTOMATIC, AUTOMATIC) parsedCert = &KeyM_ParsedBackendCert; /* PRQA S 2981 */ /* MD_SSA_REDUNDANT_INITIALIZATION */
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) certRawData;
  boolean parseCert = reParse;

#if (SSA_KEEP_BUFFER_VARIABLES_STATIC == STD_ON)
  rVal = E_OK;
  certRawData = KeyM_BackendCertBuf; /* PRQA S 2982 */ /* MD_SSA_REDUNDANT_INITIALIZATION */
#else
  certRawData = certBuffer;
#endif

  /* #10 Select by the given PKI role the buffer for the parsed and raw data of the requested certificate. */
  switch (pkiRole)
  {
#if (SSA_ECU_TYPE == SSA_ECU_TYPE_VSM)
    case CERTP_PKI_ROLE_ECU:
      parsedCert = &KeyM_ParsedEcuCert;
# if (SSA_KEEP_BUFFER_VARIABLES_STATIC == STD_ON)
      certRawData = KeyM_EcuCertBuf;
# endif
      break;
#endif
    case CERTP_PKI_ROLE_BACKEND:
      /* use already assigned default values */
      break;
    case CERTP_PKI_ROLE_ROOT:
      parsedCert = &KeyM_ParsedRootCert;
#if (SSA_KEEP_BUFFER_VARIABLES_STATIC == STD_ON)
      certRawData = KeyM_RootCertBuf;
#endif
      break;
    default:
      rVal = E_NOT_OK;
      break;
  }

  if (rVal == E_OK)
  {
#if (SSA_KEEP_BUFFER_VARIABLES_STATIC == STD_OFF)
    /* Copy the raw data from the crypto key elements to the given buffer depending on PKI role. */
    rVal = KeyM_GetAndParseStoredCert_GetCertificateRawDataByPkiRole(pkiRole, certRawData, &lengthCert);
#endif

    /* #20 Get raw data of the certificate and check if it has been successfully parsed and verified yet. */
    KeyM_GetAndParseStoredCert_GetCertificateRawDataAndCheckParsing(
      pkiRole, parsedCert, certRawData, &lengthCert, certBufferLength, &rVal, &parseCert);
  }

  /* #40 Parse the certificate and check for a positive parse result. */
  if (parseCert && (rVal == E_OK))
  {
    /* Check against RTE in buffer CertP_RawCertBufferType: certRawData points always to a buffer of size SSA_SIZEOF_CERT_MAX */
    if ((Rte_Call_CertP_Functions_Certificate_Parse(certRawData, (uint16)lengthCert, parsedCert) != E_OK)
        || (parsedCert->verificationResult != CERTP_VER_PARSE_OK))
    {
      rVal = E_NOT_OK;
    }
    else
    {
      /* Ok. Assign the length resulting from the parsing which is smaller than or equal to the length of the raw data. */
      *certBufferLength = parsedCert->parsedCertLength;
    }
  }

#if (SSA_KEEP_BUFFER_VARIABLES_STATIC == STD_ON)
  /* Finally copy the certificate data to the given buffer if destination buffer is not the source buffer. */
  if ((rVal == E_OK) && (certBuffer != certRawData))
  {
    /* The length of certBuffer is >= SSA_SIZEOF_CERT_MAX as ensured by a specification.
     * For the certBufferLength either the input value will be used unchanged, if the certificate has not been parsed yet.
     * Or certBufferLength is taken from a global variable (parsedCert), if the certificate had already been parsed. 
     * The following runtime check ensures correct copying into certBuffer with certBufferLength. */
    if (*certBufferLength < SSA_SIZEOF_CERT_MAX)
    {
      Ssa_MemCpy(certBuffer, certRawData, *certBufferLength);
    }
  }
#endif

  return rVal;
}

/**********************************************************************************************************************
 *  KeyM_GetAndParseStoredCert_GetCertificateRawDataAndCheckParsing()
 **********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 */
/* PRQA S 3673 6 */ /* MD_SSA_PARAM_NOT_P2CONST */
SSA_KEYM_LOCAL FUNC(void, Ssa_KeyM_CODE) KeyM_GetAndParseStoredCert_GetCertificateRawDataAndCheckParsing(
  CertP_PkiRoleType pkiRole,
  P2CONST(CertP_ParsedCertStructureType, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) parsedCert,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) certRawData,
  P2VAR(uint32, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) rawLengthCert,
  P2VAR(uint16, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) certBufferLength,
  P2VAR(Std_ReturnType, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) rVal,
  P2VAR(boolean, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) parseCertFlag)
{
  Std_ReturnType tmpRetVal = *rVal; /* always E_OK, when the function is called. */

  /* Also check against != CERTP_VER_PARSE_OK so that invalid certificates will always parsed again (and will fail again). */
  if ((parsedCert->verificationResult != CERTP_VER_PARSE_OK) && (parsedCert->verificationResult != CERTP_VER_OK))
  {
    *parseCertFlag = TRUE;
#if (SSA_KEEP_BUFFER_VARIABLES_STATIC == STD_ON)
    /* Copy the raw data from the crypto key element to the given buffer depending on PKI role. */
    tmpRetVal = KeyM_GetAndParseStoredCert_GetCertificateRawDataByPkiRole(pkiRole, certRawData, rawLengthCert);

    if (tmpRetVal != E_OK)
    {
      tmpRetVal = E_NOT_OK;
    }
#else
    SSA_DUMMY_STATEMENT(pkiRole); /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */
    SSA_DUMMY_STATEMENT(certRawData); /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */
    SSA_DUMMY_STATEMENT(rawLengthCert); /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */
#endif
  }
  else
  {
    /* Certificate has been already parsed or verified. 
      * Assign the length resulting from the parsing which is smaller than or equal to the length of the raw data. */
    *certBufferLength = parsedCert->parsedCertLength;
  }

  *rVal = tmpRetVal;
} /* PRQA S 6060 4 */ /* MD_SSA_STPAR */

/**********************************************************************************************************************
 *  KeyM_GetAndParseStoredCert_GetCertificateRawDataByPkiRole()
 **********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 */
SSA_KEYM_LOCAL FUNC(Std_ReturnType, Ssa_KeyM_CODE) KeyM_GetAndParseStoredCert_GetCertificateRawDataByPkiRole(
  CertP_PkiRoleType pkiRole,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) certRawData,
  P2VAR(uint32, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) lengthCert)
{
  Std_ReturnType rVal;

  switch (pkiRole)
  {
#if (SSA_ECU_TYPE == SSA_ECU_TYPE_VSM)
    case CERTP_PKI_ROLE_ECU:
      /* Get ECU cert */
      *lengthCert = sizeof(Csm_KeyDataType_Ssa_EcuCert);
      rVal = Rte_Call_Key_EcuCert_KeyElementGet(SSA_KE_CERTIFICATE_DATA, certRawData, lengthCert);
      break;
#endif

    case CERTP_PKI_ROLE_BACKEND:
      /* Get Backend cert */
      *lengthCert = sizeof(Csm_KeyDataType_Ssa_BackendCert);
      rVal = Rte_Call_Key_BackendCert_KeyElementGet(SSA_KE_CERTIFICATE_DATA, certRawData, lengthCert);
      break;

    case CERTP_PKI_ROLE_ROOT:
      /* Get Root cert */
      *lengthCert = sizeof(Csm_KeyDataType_Ssa_RootCert);
      rVal = Rte_Call_Key_RootCert_KeyElementGet(SSA_KE_CERTIFICATE_DATA, certRawData, lengthCert);
      break;

    default: /* COV_SSA_MISRA */
      rVal = E_NOT_OK;
      break;
  }

  return rVal;
}

/**********************************************************************************************************************
 *  KeyM_ExtractCertificateLength()
 **********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 */
SSA_KEYM_LOCAL FUNC(boolean, Ssa_KeyM_CODE) KeyM_ExtractCertificateLength(
  P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) certificates,
  uint16 dataLength,
  P2VAR(uint16, AUTOMATIC, AUTOMATIC) byteIdx,
  P2VAR(uint16, AUTOMATIC, AUTOMATIC) certificateLength)
{
  boolean errorOccurred = FALSE;
  /* #10 Check the byte index and the data length for consistency. */
  if (dataLength < (2u + *byteIdx))
  {
    errorOccurred = TRUE;
  }
  else
  {
    /* #20 Extract certificate length from the next two bytes of the input buffer starting at the passed byte index. */
    *certificateLength = KeyM_GetUint16(certificates[*byteIdx], certificates[*byteIdx + 1u]);
    /* #30 Check the byte index, the extracted certificate length and the data length for consistency. */
    /* Data Length must be at least 2 byte certificate lengths + ECU certificate length. */
    if (dataLength < (2u + *certificateLength + *byteIdx))
    {
      errorOccurred = TRUE;
    }
  }

  *byteIdx += 2u + *certificateLength;

  return errorOccurred;
}

/**********************************************************************************************************************
 *  KeyM_VerifyPublicKeyWithEcuPrivateKey()
 **********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 */
SSA_KEYM_LOCAL FUNC(Std_ReturnType, Ssa_KeyM_CODE) KeyM_VerifyPublicKeyWithEcuPrivateKey(
    uint8 chainOfTrust,
    P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) publicKey,
    P2VAR(Crypto_VerifyResultType, AUTOMATIC, AUTOMATIC) verificationResult)
{
  Std_ReturnType retVal = E_NOT_OK;
#if (SSA_KEEP_BUFFER_VARIABLES_STATIC == STD_OFF)
  uint8 KeyM_SignatureTest[SSA_SIZEOF_SIGNATURE] = {0u};
#endif

#if (SSA_ECU_TYPE != SSA_ECU_TYPE_VSM)
  SSA_DUMMY_STATEMENT(publicKey);   /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */
#endif

  /*  #10 Handle the following states:
   *      KEYM_VERIFY_CERTPUBLICKEY_WITH_ECUPRIVATEKEY_STATE_IDLE_GENERATE_SIGNATURE,
   *      KEYM_VERIFY_CERTPUBLICKEY_WITH_ECUPRIVATEKEY_STATE_VERIFY_SIGNATURE. */

  /* Set default verification result. */
  *verificationResult = CRYPTO_E_VER_NOT_OK;

  if (KeyM_VerifyPubKeyState == KEYM_VERIFY_CERTPUBLICKEY_WITH_ECUPRIVATEKEY_STATE_IDLE_GENERATE_SIGNATURE)
  {
    retVal = KeyM_CsmSignatureGenerate(chainOfTrust, KeyM_StandardSharedSecret, SSA_SIZEOF_SECRET, KeyM_SignatureTest);

#if (SSA_ENABLE_ASYNC_CSM_JOB_PROCESSING == STD_ON)
    if (retVal == SSA_E_PENDING)
    {
      /* Remain in current state. */
    }
    else
#endif
    {
      if (retVal == E_OK)
      {
        /* KeyM_CsmSignatureGenerate already checks the value of chainOfTrust.
         * If E_OK is returned, chainOfTrust has any of the following, valid values. */
        if (chainOfTrust == SSA_TRUST_MODEL_CSR_KEY_PAIR)
        {
          uint8 pubKey[SSA_SIZEOF_PUBLICKEY];
          uint32 pubKeyLength = SSA_SIZEOF_PUBLICKEY;

          /* use the verify job of the ECU peer certificate */
          retVal = Rte_Call_Key_TrustModelEcuCsrPublicKey_KeyElementGet(SSA_KE_SIGNATURE_KEY, pubKey, &pubKeyLength);
          retVal |= Rte_Call_Key_TrustModelTempPublicKey_KeyElementSet(SSA_KE_SIGNATURE_KEY, pubKey, pubKeyLength);
          retVal |= Rte_Call_Key_TrustModelTempPublicKey_KeySetValid();
        }
#if (SSA_ECU_TYPE == SSA_ECU_TYPE_VSM)
        else if ((chainOfTrust == SSA_DIAGNOSTIC_KEY_PAIR) && (publicKey != NULL_PTR))
        {
          retVal = Rte_Call_Key_SignatureRamKey_KeyElementSet(SSA_KE_SIGNATURE_KEY, publicKey, SSA_SIZEOF_PUBLICKEY);
          retVal |= Rte_Call_Key_SignatureRamKey_KeySetValid();
        }
        else if (
          (chainOfTrust == SSA_TRUST_MODEL_LIVE_KEY_PAIR) ||
          (chainOfTrust == SSA_TRUST_MODEL_LIVE_PUBLIC_KEY_AND_CSR_PRIVATE_KEY))
#else
        /* In a non-VSM ecu, the checks in KeyM_CsmSignatureGenerate already asserted, that chainOfTrust must now
         * either be SSA_TRUST_MODEL_LIVE_KEY_PAIR or SSA_TRUST_MODEL_LIVE_PUBLIC_KEY_AND_CSR_PRIVATE_KEY. */
        else
#endif
        {
          /* set the public key */
          uint8 pubKey[SSA_SIZEOF_PUBLICKEY];
          uint32 pubKeyLength = SSA_SIZEOF_PUBLICKEY;
          /* use the verify job of the ECU peer certificate */
          retVal = Rte_Call_Key_TrustModelEcuLivePublicKey_KeyElementGet(SSA_KE_SIGNATURE_KEY, pubKey, &pubKeyLength);
          retVal |= Rte_Call_Key_TrustModelTempPublicKey_KeyElementSet(SSA_KE_SIGNATURE_KEY, pubKey, pubKeyLength);
          retVal |= Rte_Call_Key_TrustModelTempPublicKey_KeySetValid();
        }
#if (SSA_ECU_TYPE == SSA_ECU_TYPE_VSM)
        else
        {
          /* unsupported chain and/or key;
           * In a VSM ecu, this path is reached, if the provided public key is a null pointer. */
          retVal = E_NOT_OK;
        }
#endif

        /* check for error */
        if (retVal == E_OK)
        {
          KeyM_VerifyPubKeyState = KEYM_VERIFY_CERTPUBLICKEY_WITH_ECUPRIVATEKEY_STATE_VERIFY_SIGNATURE;
        }
        else
        {
          /* Error */
          KeyM_VerifyPubKeyState = KEYM_VERIFY_CERTPUBLICKEY_WITH_ECUPRIVATEKEY_STATE_IDLE_GENERATE_SIGNATURE;
          retVal = E_NOT_OK;
        }
      }
      else
      {
        /* If Csm operations are handled synchronously, a PENDING return value shall be treated like an error. */
        KeyM_VerifyPubKeyState = KEYM_VERIFY_CERTPUBLICKEY_WITH_ECUPRIVATEKEY_STATE_IDLE_GENERATE_SIGNATURE;
        retVal = E_NOT_OK;
      }
    }
  }

  if (KeyM_VerifyPubKeyState == KEYM_VERIFY_CERTPUBLICKEY_WITH_ECUPRIVATEKEY_STATE_VERIFY_SIGNATURE)
  {
    retVal = KeyM_CsmSignatureVerify(
        chainOfTrust, KeyM_StandardSharedSecret, SSA_SIZEOF_SECRET, KeyM_SignatureTest, verificationResult);

#if (SSA_ENABLE_ASYNC_CSM_JOB_PROCESSING == STD_ON)
    if (retVal == SSA_E_PENDING)
    {
      /* Remain in current state. */
    }
    else
#endif
    {
      if (retVal == E_OK)
      {
        KeyM_VerifyPubKeyState = KEYM_VERIFY_CERTPUBLICKEY_WITH_ECUPRIVATEKEY_STATE_IDLE_GENERATE_SIGNATURE;
      }
      else
      {
        /* Error.
         * If Csm operations are handled synchronously, a PENDING return value shall be treated like an error. */
        KeyM_VerifyPubKeyState = KEYM_VERIFY_CERTPUBLICKEY_WITH_ECUPRIVATEKEY_STATE_IDLE_GENERATE_SIGNATURE;
        retVal = E_NOT_OK;
      }
    }
  }

  return retVal;
}  /* PRQA S 6030, 6080 */ /* MD_MSR_STCYC, MD_MSR_STMIF */

/**********************************************************************************************************************
 *  KeyM_KeyExchangeCalcSymmetricKey()
 **********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
 /* PRQA S 3673 5 */ /* MD_SSA_PARAM_NOT_P2CONST */
SSA_KEYM_LOCAL FUNC(Std_ReturnType, Ssa_KeyM_CODE) KeyM_KeyExchangeCalcSymmetricKey(
  P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) ePubKeyOther,
  P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) nonce,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) ePubKeyOwn)
{
  Std_ReturnType retVal = E_NOT_OK;

  /* #10 Handle the following states:
   *     KEYM_KEYEXCHANGECALCSYMKEY_STATE_IDLE,
   *     KEYM_KEYEXCHANGECALCSYMKEY_STATE_PREPARE,
   *     KEYM_KEYEXCHANGECALCSYMKEY_STATE_PREPARE_CHECK_STATE,
   *     KEYM_KEYEXCHANGECALCSYMKEY_STATE_CALC_PUBVAL and
   *     KEYM_KEYEXCHANGECALCSYMKEY_STATE_CALC_SECRET. */

  /* #20 If no out buffer for the own ephemeral key is provided, leave out the calculation of the own public key and
   * calculate directly the shared secret. */
  if (KeyM_KeyExchangeCalcSymmetricKeyState == KEYM_KEYEXCHANGECALCSYMKEY_STATE_IDLE)
  {
#if (SSA_ECU_TYPE != SSA_ECU_TYPE_VSM)
    /* In non-vsm configurations the ePubKeyOwn  is not required. */
    SSA_DUMMY_STATEMENT(ePubKeyOwn); /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */
    KeyM_KeyExchangeCalcSymmetricKeyState = KEYM_KEYEXCHANGECALCSYMKEY_STATE_CALC_SECRET;
#else
    KeyM_KeyExchangeCalcSymmetricKeyState = KEYM_KEYEXCHANGECALCSYMKEY_STATE_PREPARE;
#endif
  }

#if (SSA_ECU_TYPE == SSA_ECU_TYPE_VSM)
  if (KeyM_KeyExchangeCalcSymmetricKeyState == KEYM_KEYEXCHANGECALCSYMKEY_STATE_PREPARE_CHECK_STATE)
  {
    retVal = Rte_Call_Ssa_KeyProc_PrepareKeyExchange(SSA_OPSTATUS_CHECKSTATE, SSA_KEYM_CSM_KEY_EXCHANGE_KEY);

    KeyM_KeyExchangeCalcSymmetricKey_StateHandler_PrepareStates(&KeyM_KeyExchangeCalcSymmetricKeyState, &retVal);
  }

  if (KeyM_KeyExchangeCalcSymmetricKeyState == KEYM_KEYEXCHANGECALCSYMKEY_STATE_PREPARE)
  {
    retVal = Rte_Call_Ssa_KeyProc_PrepareKeyExchange(SSA_OPSTATUS_INITIAL, SSA_KEYM_CSM_KEY_EXCHANGE_KEY);

    KeyM_KeyExchangeCalcSymmetricKey_StateHandler_PrepareStates(&KeyM_KeyExchangeCalcSymmetricKeyState, &retVal);
  }

  /* #30 In state KEYM_KEYEXCHANGECALCSYMKEY_STATE_CALC_PUBVAL start and check the calculation of the own public key. */
  if (KeyM_KeyExchangeCalcSymmetricKeyState == KEYM_KEYEXCHANGECALCSYMKEY_STATE_CALC_PUBVAL)
  {
    /*@ assert ePubKeyOwn != NULL_PTR; */ /* VCA_SSA_KEYM_KEY_EXCHANGE_STATE_CALC_PUBVAL */
    retVal = KeyM_CsmKeyExchangeCalcPubVal(ePubKeyOwn);

    KeyM_KeyExchangeCalcSymmetricKey_StateHandler_CalcPubValState(&KeyM_KeyExchangeCalcSymmetricKeyState, &retVal);
  }
#endif


  /* #40 In state KEYM_KEYEXCHANGECALCSYMKEY_STATE_CALC_SECRET start and check the calculation of the shared secret. */
  if (KeyM_KeyExchangeCalcSymmetricKeyState == KEYM_KEYEXCHANGECALCSYMKEY_STATE_CALC_SECRET)
  {
    retVal = KeyM_CsmKeyExchangeCalcSecret(ePubKeyOther);

    KeyM_KeyExchangeCalcSymmetricKey_StateHandler_CalcSecretState(nonce, &KeyM_KeyExchangeCalcSymmetricKeyState, &retVal);
  }

  return retVal;
}

#if (SSA_ECU_TYPE == SSA_ECU_TYPE_VSM)
/**********************************************************************************************************************
 *  KeyM_KeyExchangeCalcSymmetricKey_StateHandler_PrepareStates()
 **********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 */
SSA_KEYM_LOCAL FUNC(void, Ssa_KeyM_CODE) KeyM_KeyExchangeCalcSymmetricKey_StateHandler_PrepareStates(
  P2VAR(Std_ReturnType, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) KeyExchangeCalcSymmetricKeyState,
  P2VAR(Std_ReturnType, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) retVal)
{
  /* Set the return value and state KeyExchangeCalcSymmetricKeyState according to the provided retVal. */

    /* PRQA S 2880 L1 */ /* MD_SSA_UNREACHABLE_CODE */
    /* PRQA S 2995, 2996 L2 */ /* MD_SSA_BOOLEXPR_ALWAYS_TRUE_OR_ALWAYS_FALSE  */
    /* PRQA S 2991, 2992 L3 */ /* MD_SSA_CTRLEXPR_ALWAYS_TRUE_OR_ALWAYS_FALSE */
    if (*retVal == RTE_E_Ssa_KeyProc_E_PENDING)
    {
      *KeyExchangeCalcSymmetricKeyState = KEYM_KEYEXCHANGECALCSYMKEY_STATE_PREPARE_CHECK_STATE;
      *retVal = SSA_E_PENDING;
    }
    else if ((*retVal == RTE_E_OK) || (*retVal == RTE_E_UNCONNECTED))
    {
      *KeyExchangeCalcSymmetricKeyState = KEYM_KEYEXCHANGECALCSYMKEY_STATE_CALC_PUBVAL;
    }
    else
    {
      *retVal = E_NOT_OK;
      /* reset state */
      *KeyExchangeCalcSymmetricKeyState = KEYM_KEYEXCHANGECALCSYMKEY_STATE_IDLE;
    }
    /* PRQA L:L3 */
    /* PRQA L:L2 */
    /* PRQA L:L1 */
}

/**********************************************************************************************************************
*  KeyM_KeyExchangeCalcSymmetricKey_StateHandler_CalcPubValState()
**********************************************************************************************************************/
/*!
* Internal comment removed.
 *
 *
 *
 *
*/
SSA_KEYM_LOCAL FUNC(void, Ssa_KeyM_CODE) KeyM_KeyExchangeCalcSymmetricKey_StateHandler_CalcPubValState(
  P2VAR(Std_ReturnType, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) KeyExchangeCalcSymmetricKeyState,
  P2VAR(Std_ReturnType, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) retVal)
{
  /* Set the return value and state KeyExchangeCalcSymmetricKeyState according to the provided retVal. */

  if (*retVal == SSA_E_PENDING)
  {
    /* remain in current state */
  }
  else if (*retVal == E_OK)
  {
    if (Rte_Call_Key_SharedSecretKeyExchange_KeySetValid() == RTE_E_OK)
    {
      /* change to next state */
      *KeyExchangeCalcSymmetricKeyState = KEYM_KEYEXCHANGECALCSYMKEY_STATE_CALC_SECRET;
    }
    else
    {
      *retVal = E_NOT_OK;
      /* reset state */
      *KeyExchangeCalcSymmetricKeyState = KEYM_KEYEXCHANGECALCSYMKEY_STATE_IDLE;
    }
  }
  else
  {
    *retVal = E_NOT_OK;
    /* reset state */
    *KeyExchangeCalcSymmetricKeyState = KEYM_KEYEXCHANGECALCSYMKEY_STATE_IDLE;
  }
}
#endif


/**********************************************************************************************************************
*  KeyM_KeyExchangeCalcSymmetricKey_StateHandler_CalcSecretState()
**********************************************************************************************************************/
/*!
* Internal comment removed.
 *
 *
 *
 *
*/
SSA_KEYM_LOCAL FUNC(void, Ssa_KeyM_CODE) KeyM_KeyExchangeCalcSymmetricKey_StateHandler_CalcSecretState(
  P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) nonce,
  P2VAR(Std_ReturnType, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) KeyExchangeCalcSymmetricKeyState,
  P2VAR(Std_ReturnType, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) retVal)
{
  /* Set the return value and state KeyExchangeCalcSymmetricKeyState according to the provided retVal. */

  if (*retVal == SSA_E_PENDING)
  {
    /* remain in current state */
  }
  else if (*retVal == E_OK)
  {
    if (Rte_Call_Key_SharedSecretKeyExchange_KeySetValid() == RTE_E_OK)
    {
      *retVal = KeyM_CalculateAndStoreCipherKey(nonce);
    }
    else
    {
      *retVal = E_NOT_OK;
    }

    /* reset state (since finished) */
    *KeyExchangeCalcSymmetricKeyState = KEYM_KEYEXCHANGECALCSYMKEY_STATE_IDLE;
  }
  else
  {
    *retVal = E_NOT_OK;
    /* reset state */
    *KeyExchangeCalcSymmetricKeyState = KEYM_KEYEXCHANGECALCSYMKEY_STATE_IDLE;
  }
}

/**********************************************************************************************************************
 *  KeyM_CarSpecificSecretDistribution_VerifyEcuCert()
 **********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
/* PRQA S 3673 8 */ /* MD_SSA_PARAM_NOT_P2CONST */
SSA_KEYM_LOCAL FUNC(Std_ReturnType, Ssa_KeyM_CODE) KeyM_CarSpecificSecretDistribution_VerifyEcuCert(
  uint8 chainOfTrust,
  P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) ecuCertificate,
  uint16 DataLength,
  P2VAR(uint8, AUTOMATIC, AUTOMATIC) ecuPublicKey,
  P2VAR(uint8, AUTOMATIC, AUTOMATIC) Verification_Result,
  P2VAR(Dcm_NegativeResponseCodeType, AUTOMATIC, AUTOMATIC) ErrorCode)
{
  /* #10 Depending on chain of trust call an appropriate sub-function. */
  Std_ReturnType retVal;
  if ((chainOfTrust == SSA_TRUST_MODEL_LIVE_KEY_PAIR) || (chainOfTrust == SSA_TRUST_MODEL_CSR_KEY_PAIR))
  {
    retVal = KeyM_CarSpecificSecretDistribution_VerifyEcuCert_UniqueEcuIdChain(
      ecuCertificate,
      DataLength,
      Verification_Result,
      ErrorCode);
  }
  else
  {
#if (SSA_ECU_TYPE == SSA_ECU_TYPE_VSM)
    retVal = KeyM_CarSpecificSecretDistribution_VerifyEcuCert_DiagChain(
      ecuCertificate,
      DataLength,
      ecuPublicKey,
      Verification_Result,
      ErrorCode);
#else
    SSA_DUMMY_STATEMENT(ecuPublicKey);   /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */
    retVal = E_NOT_OK;
#endif
  }
  return retVal;
} /* PRQA S 6060 */ /* MD_SSA_STPAR */

/**********************************************************************************************************************
 *  KeyM_CarSpecificSecretDistribution_VerifyEcuCert_UniqueEcuIdChain()
 **********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
SSA_KEYM_LOCAL FUNC(Std_ReturnType, Ssa_KeyM_CODE) KeyM_CarSpecificSecretDistribution_VerifyEcuCert_UniqueEcuIdChain(
  P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) ecuCertificate,
  uint16 DataLength,
  P2VAR(uint8, AUTOMATIC, AUTOMATIC) Verification_Result,
  P2VAR(Dcm_NegativeResponseCodeType, AUTOMATIC, AUTOMATIC) ErrorCode)
{
  Std_ReturnType retVal = SSA_E_PENDING;

  /* #10 Handle the following states:
   *     KEYM_SECRET_DISTRIB_VERIFY_ECUCERT_TM_STATE_IDLE,
   *     KEYM_SECRET_DISTRIB_VERIFY_ECUCERT_TM_STATE_REQUESTING_FOR_VERIFICATION_CERT_CHAIN,
   *     KEYM_SECRET_DISTRIB_VERIFY_ECUCERT_TM_STATE_AWAITING_VERIFICATION_RESULT */

  switch (KeyM_DiagProc.verifyCertState) {
  case KEYM_SECRET_DISTRIB_VERIFY_ECUCERT_TM_STATE_IDLE:
  {
    /* iteration 1 to 3 */
    uint16 certLength_ecu, certLength_intermediate, certLength_backend;
    uint16 certIdx_ecu, certIdx_intermediate, certIdx_backend;
    uint32 dataIdx = 0u;

    /* #20 Pass peer certificates to the AsrKeyM where check results for parse errors. */
    /* get length and index of provided certificates */
    /* check if this can be done once in DCM_INITIAL */
    if (KeyM_GetNextIteration(ecuCertificate, DataLength, &dataIdx, &certIdx_ecu, &certLength_ecu) == E_NOT_OK)
    {
      retVal = E_NOT_OK;
      *ErrorCode = DCM_E_INCORRECTMESSAGELENGTHORINVALIDFORMAT;
    }
    else if (KeyM_GetNextIteration(ecuCertificate, DataLength, &dataIdx, &certIdx_intermediate, &certLength_intermediate) == E_NOT_OK)
    {
      retVal = E_NOT_OK;
      *ErrorCode = DCM_E_INCORRECTMESSAGELENGTHORINVALIDFORMAT;
    }
    else if (KeyM_GetNextIteration(ecuCertificate, DataLength, &dataIdx, &certIdx_backend, &certLength_backend) == E_NOT_OK)
    {
      retVal = E_NOT_OK;
      *ErrorCode = DCM_E_INCORRECTMESSAGELENGTHORINVALIDFORMAT;
    }
    else if ((certLength_ecu > sizeof(KeyM_DiagProc.ws.trustModelCommissioning.certBufferEcuPeer))
      || (certLength_intermediate > sizeof(KeyM_DiagProc.ws.trustModelCommissioning.certBufferIntermediatePeer))
      || (certLength_backend > sizeof(KeyM_DiagProc.ws.trustModelCommissioning.certBufferBackendPeer)))
    {
      retVal = E_NOT_OK;
      *ErrorCode = DCM_E_CONDITIONSNOTCORRECT;
    }
    else
    {
      /* prepare setting Peer ECU certificate */
      /* Unfortunately the following is not possible with AsrKeyM:
       * KeyM_DiagProc.ws.trustModelCommissioning.keyMCertData[0u].certData = &Target_ECU_Certificate[certIdx_backend];
       * KeyM_DiagProc.ws.trustModelCommissioning.keyMCertData[1u].certData = &Target_ECU_Certificate[certIdx_intermediate];
       * KeyM_DiagProc.ws.trustModelCommissioning.keyMCertData[2u].certData = &Target_ECU_Certificate[certIdx_ecu];
       */
      /* instead copy data to static buffer */
      KeyM_CopyDataBuffer(KeyM_DiagProc.ws.trustModelCommissioning.certBufferBackendPeer, &ecuCertificate[certIdx_backend], certLength_backend);
      KeyM_DiagProc.ws.trustModelCommissioning.keyMCertData[0].certData = KeyM_DiagProc.ws.trustModelCommissioning.certBufferBackendPeer;

      /* copy data to static buffer  */
      KeyM_CopyDataBuffer(KeyM_DiagProc.ws.trustModelCommissioning.certBufferIntermediatePeer, &ecuCertificate[certIdx_intermediate], certLength_intermediate);
      KeyM_DiagProc.ws.trustModelCommissioning.keyMCertData[1].certData = KeyM_DiagProc.ws.trustModelCommissioning.certBufferIntermediatePeer;

      /* copy data to static buffer  */
      KeyM_CopyDataBuffer(KeyM_DiagProc.ws.trustModelCommissioning.certBufferEcuPeer, &ecuCertificate[certIdx_ecu], certLength_ecu);
      KeyM_DiagProc.ws.trustModelCommissioning.keyMCertData[2].certData = KeyM_DiagProc.ws.trustModelCommissioning.certBufferEcuPeer;
      /* end of instead */

      KeyM_DiagProc.ws.trustModelCommissioning.keyMCertData[0u].certDataLength = certLength_backend;
      KeyM_DiagProc.ws.trustModelCommissioning.keyMCertData[1u].certDataLength = certLength_intermediate;
      KeyM_DiagProc.ws.trustModelCommissioning.keyMCertData[2u].certDataLength = certLength_ecu;

      /* Pass the certificates to AsrKeyM via SetCertificate. */
      retVal = KeyM_CarSpecificSecretDistribution_VerifyEcuCert_UniqueEcuIdChain_PassCertsToAsrKeyM(Verification_Result);

      if (retVal == SSA_E_PENDING)
      {
        /* All certificates could be passed to the AsrKeyM, continue */
        KeyM_DiagProc.verifyCertState = KEYM_SECRET_DISTRIB_VERIFY_ECUCERT_TM_STATE_REQUESTING_FOR_VERIFICATION_CERT_CHAIN;
      }
    }
    break;
  }

  case KEYM_SECRET_DISTRIB_VERIFY_ECUCERT_TM_STATE_REQUESTING_FOR_VERIFICATION_CERT_CHAIN:
  {
    /* prepare asynchronous verify certificate chain call */
    KeyM_DiagProc.certificateVerifyCallbackResult = KEYM_CERTIFICATE_INVALID;
    KeyM_DiagProc.certificateVerifyCallbackOccurred = FALSE;

    /* #30 Start verification of chain. */
    retVal = Rte_Call_KeyMCertificate_Ssa_TrustModelEcuPeerCert_VerifyCertificate();
    switch (retVal)
    {
    case RTE_E_OK:
      /* proceed with next state */
      KeyM_DiagProc.verifyCertState = KEYM_SECRET_DISTRIB_VERIFY_ECUCERT_TM_STATE_AWAITING_VERIFICATION_RESULT;
      retVal = SSA_E_PENDING;
      break;

    case RTE_E_KeyMCertificate_Ssa_TrustModelEcuPeerCert_KEYM_E_BUSY:
      /* stay in current state and try again. */
      retVal = SSA_E_PENDING;
      break;

    case RTE_E_KeyMCertificate_Ssa_TrustModelEcuPeerCert_KEYM_E_KEY_CERT_EMPTY:
    case RTE_E_KeyMCertificate_Ssa_TrustModelEcuPeerCert_KEYM_E_CERT_INVALID_CHAIN_OF_TRUST:
      /* routine is finished */
      KeyM_DiagProc.verifyCertState = KEYM_SECRET_DISTRIB_VERIFY_ECUCERT_TM_STATE_IDLE;
      retVal = RTE_E_OK;
      *Verification_Result = SSA_VER_RES_TRUST_MODEL_SECOC_CSS_DISTRIB_ECU_CERTIFICATE_VERIFICATION_FAILED_INVALID_CHAIN_OF_TRUST;
      break;

    default:
      /* routine is finished */
      KeyM_DiagProc.verifyCertState = KEYM_SECRET_DISTRIB_VERIFY_ECUCERT_TM_STATE_IDLE;
      retVal = E_NOT_OK;
      *ErrorCode = DCM_E_CONDITIONSNOTCORRECT;
      break;
    }
    break;
  }

  case KEYM_SECRET_DISTRIB_VERIFY_ECUCERT_TM_STATE_AWAITING_VERIFICATION_RESULT:
  {
    /* check for callback */
    if (KeyM_DiagProc.certificateVerifyCallbackOccurred)
    {
      /* routine is finished */
      KeyM_DiagProc.verifyCertState = KEYM_SECRET_DISTRIB_VERIFY_ECUCERT_TM_STATE_IDLE;
      retVal = E_OK;

      /* #40 Check verification result and evaluate certificate's status */
      if (KeyM_EvalPeerTrustModelChain(KeyM_DiagProc.certificateVerifyCallbackResult, Verification_Result))
      {
        /* BackendPeer, IntermediatePeer and EcuPeer certificate have been verified by the KeyM */
        Std_ReturnType retVal_additionalVerification;

        /* #47 Do additional verification of certificate entries not verified by KeyM. */
        retVal_additionalVerification = KeyM_CarSpecificSecretDistribution_VerifyEcuCert_UniqueEcuIdChain_AdditionalCertElemVerification(
          Verification_Result, ErrorCode);

        if (retVal_additionalVerification != E_OK)
        {
          if (*ErrorCode == DCM_E_CONDITIONSNOTCORRECT)
          {
            retVal = E_NOT_OK;
          }
          else
          {
            /* Verification result has been set and logged in 
             * KeyM_CarSpecificSecretDistribution_VerifyEcuCert_UniqueEcuIdChain_AdditionalCertElemVerification() */
            /* retVal = E_OK */
          }
        }
        else
        {
          /* Additional verification succeeded. */

          /* Log successful Trust Model certififcate verification event */
          KeyM_LogTrustModelCertificateVerificationResult(SSA_TRUST_MODEL_ECU_PEER_CERT_ID, SSA_VER_RES_SUCCESSFUL);
          {
#if (SSA_ECU_TYPE != SSA_ECU_TYPE_VSM)
            uint8 specialECU[1] = { 0u };
            uint32 specialECULen = 1;
            /* #45 If ECU type is not configured as VSM, verify by the special ECU field that the received ECU certificate
            *     belongs to a VSM. */
            /* no need to check returned length; if it is 0, comparison will fail due to default value for specialECU */
            if ((Rte_Call_KeyMCertificateElement_Ssa_TrustModelEcuPeerCert_ext_specialEcu_CertificateElementGet(specialECU, &specialECULen) != RTE_E_OK)
              || (specialECU[0] != (uint8)SSA_SPECIALECU_ID_VSM))
            {
              *Verification_Result = SSA_VER_RES_TRUST_MODEL_SECOC_CSS_DISTRIB_ECU_CERTIFICATE_VERIFICATION_FAILED_INVALID_SCOPE;
            }
            else
#else
            uint8 specialECU[1] = { SSA_SPECIALECU_ID_VSM };
            uint32 specialECULen = 1;
            /* #46 If ECU type is configured as VSM, verify by the special ECU field that the received ECU certificate
             *     does not belong to a VSM and that it is eligible for SecOC-IS procedure and car shared secret provisioning
             *     (specialECU flag !=SSA_SPECIALECU_ID_NONSECOC_IS). */
             /* no need to check returned length, which has to 1 if the field exists;
              * if it is 0, comparison will fail due to default value for specialECU */
            if ((Rte_Call_KeyMCertificateElement_Ssa_TrustModelEcuPeerCert_ext_specialEcu_CertificateElementGet(specialECU, &specialECULen) == RTE_E_OK)
              && ((specialECU[0] == (uint8)SSA_SPECIALECU_ID_VSM) || (specialECU[0] == (uint8)SSA_SPECIALECU_ID_NONSECOC_IS)))
            {
              *Verification_Result = SSA_VER_RES_TRUST_MODEL_SECOC_CSS_ENCRYPT_ECU_CERTIFICATE_VERIFICATION_FAILED_INVALID_SCOPE;
            }
            else
#endif
            {
              /* #50 If verification passed check the requester's authorization. */
              uint8 subKeyId[SSA_SIZEOF_CERT_SUBJECT_KEY_ID];
              uint32 subKeyIdLen = SSA_SIZEOF_CERT_SUBJECT_KEY_ID;
              Std_ReturnType tmpRetVal = E_NOT_OK;
              boolean authorizationFlag = FALSE;
              /*  Get subject key identifier from ECU certificate */
              tmpRetVal = Rte_Call_KeyMCertificateElement_Ssa_TrustModelEcuPeerCert_ext_subKeyId_CertificateElementGet(subKeyId, &subKeyIdLen);
              if ((tmpRetVal != RTE_E_OK) || (subKeyIdLen != SSA_SIZEOF_CERT_SUBJECT_KEY_ID))
              {
                tmpRetVal = E_NOT_OK;
              }
              else
              {
                /* Check requesters authorization */
                authorizationFlag = KeyM_CheckRequestersAuthorization(subKeyId);
              }
              if ((tmpRetVal == E_NOT_OK) || (authorizationFlag == FALSE))
              {
#if (SSA_ECU_TYPE != SSA_ECU_TYPE_VSM)
                *Verification_Result = SSA_VER_RES_TRUST_MODEL_SECOC_CSS_DISTRIB_TARGET_SKID_FROM_ENH_RIGHTS_UNEQUAL_TRUST_MODEL_VSM_CERTIFICATE_SKID;
#else
                *Verification_Result = SSA_VER_RES_TRUST_MODEL_SECOC_CSS_ENCRYPT_NO_RIGHTS_TO_PROCEED_FOR_THIS_ECU;
#endif
              }
            }
          }
        }
      }
    }
    break;
  }

  default:
    /* undefined state */
    retVal = E_NOT_OK;
    *ErrorCode = DCM_E_GENERALREJECT;
    break;
  }

  return retVal;
} /* PRQA S 6010, 6030, 6050, 6060, 6080 */ /* MD_MSR_STPTH, MD_MSR_STCYC, MD_MSR_STCAL, MD_SSA_STPAR, MD_MSR_STMIF */

/**********************************************************************************************************************
 *  KeyM_CarSpecificSecretDistribution_VerifyEcuCert_UniqueEcuIdChain_PassCertsToAsrKeyM()
 **********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 */
SSA_KEYM_LOCAL FUNC(Std_ReturnType, Ssa_KeyM_CODE) KeyM_CarSpecificSecretDistribution_VerifyEcuCert_UniqueEcuIdChain_PassCertsToAsrKeyM(
  P2VAR(uint8, AUTOMATIC, AUTOMATIC) Verification_Result)
{

  Std_ReturnType retVal;

  if (KeyM_KeyM_SetCertificate(SSA_TRUST_MODEL_BACKEND_PEER_CERT_ID, &KeyM_DiagProc.ws.trustModelCommissioning.keyMCertData[0u]) != E_OK)
  {
    retVal = RTE_E_OK;
#if (SSA_ECU_TYPE == SSA_ECU_TYPE_VSM)
    *Verification_Result = SSA_VER_RES_TRUST_MODEL_SECOC_CSS_ENCRYPT_BACKEND_CERTIFICATE_VERIFICATION_FAILED_INVALID_FORMAT;
#else
    *Verification_Result = SSA_VER_RES_TRUST_MODEL_SECOC_CSS_DISTRIB_BACKEND_CERTIFICATE_VERIFICATION_FAILED_INVALID_FORMAT;
#endif
  }
  else if (KeyM_KeyM_SetCertificate(SSA_TRUST_MODEL_INTERMEDIATE_PEER_CERT_ID, &KeyM_DiagProc.ws.trustModelCommissioning.keyMCertData[1u]) != E_OK)
  {
    retVal = RTE_E_OK;
#if (SSA_ECU_TYPE == SSA_ECU_TYPE_VSM)
    *Verification_Result = SSA_VER_RES_TRUST_MODEL_SECOC_CSS_ENCRYPT_INTERMEDIATE_CERTIFICATE_VERIFICATION_FAILED_INVALID_FORMAT;
#else
    *Verification_Result = SSA_VER_RES_TRUST_MODEL_SECOC_CSS_DISTRIB_INTERMEDIATE_CERTIFICATE_VERIFICATION_FAILED_INVALID_FORMAT;
#endif
  }
  else if (KeyM_KeyM_SetCertificate(SSA_TRUST_MODEL_ECU_PEER_CERT_ID, &KeyM_DiagProc.ws.trustModelCommissioning.keyMCertData[2u]) != E_OK)
  {
    retVal = RTE_E_OK;
#if (SSA_ECU_TYPE == SSA_ECU_TYPE_VSM)
    *Verification_Result = SSA_VER_RES_TRUST_MODEL_SECOC_CSS_ENCRYPT_ECU_CERTIFICATE_VERIFICATION_FAILED_INVALID_FORMAT;
#else
    *Verification_Result = SSA_VER_RES_TRUST_MODEL_SECOC_CSS_DISTRIB_ECU_CERTIFICATE_VERIFICATION_FAILED_INVALID_FORMAT;
#endif
  }
  else
  {
    /* All certificates have been successfully passed to the AsrKeyM and have been successfully parsed. */
    retVal = SSA_E_PENDING;
  }
  return retVal;
}

/**********************************************************************************************************************
 *  KeyM_CarSpecificSecretDistribution_VerifyEcuCert_UniqueEcuIdChain_AdditionalCertElemVerification()
 **********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 */
SSA_KEYM_LOCAL FUNC(Std_ReturnType, Ssa_KeyM_CODE) KeyM_CarSpecificSecretDistribution_VerifyEcuCert_UniqueEcuIdChain_AdditionalCertElemVerification(
  P2VAR(uint8, AUTOMATIC, AUTOMATIC) Verification_Result,
  P2VAR(Dcm_NegativeResponseCodeType, AUTOMATIC, AUTOMATIC) ErrorCode)
{
  Std_ReturnType retVal;
  KeyM_CertificateStatusType localCertStatus;
  KeyM_CertificateIdType invalidCertificate_Id = SSA_TRUST_MODEL_ROOT_CERT_ID;

  /* Verify certificate elements that have not been checked by the KeyM. */
  retVal = KeyM_TrustModel_AdditionalVerificationOfCertEntries_CertificateChain(
    SSA_TRUST_MODEL_BACKEND_PEER_CERT_ID, SSA_TRUST_MODEL_INTERMEDIATE_PEER_CERT_ID, SSA_TRUST_MODEL_ECU_PEER_CERT_ID, &invalidCertificate_Id, &localCertStatus);

  if (retVal != E_OK)
  {
    /* Error in the additional verification, finish routine. */

    /* At least one of the certificates is invalid or could not be checked */
    /* Set the status of all certificates to "not available" */
    KeyM_SetCertificateStatusToNotAvailable(SSA_TRUST_MODEL_BACKEND_PEER_CERT_ID);
    KeyM_SetCertificateStatusToNotAvailable(SSA_TRUST_MODEL_INTERMEDIATE_PEER_CERT_ID);
    KeyM_SetCertificateStatusToNotAvailable(SSA_TRUST_MODEL_ECU_PEER_CERT_ID);

    retVal = E_NOT_OK;
    *ErrorCode = DCM_E_CONDITIONSNOTCORRECT;
  }
  else
  {
    if (localCertStatus != KEYM_CERTIFICATE_VALID) /* additional verification failed */
    {
      /* At least one of the certificates is invalid or could not be checked */
      /* Set the status of all certificates to "not available" */
      KeyM_SetCertificateStatusToNotAvailable(SSA_TRUST_MODEL_BACKEND_PEER_CERT_ID);
      KeyM_SetCertificateStatusToNotAvailable(SSA_TRUST_MODEL_INTERMEDIATE_PEER_CERT_ID);
      KeyM_SetCertificateStatusToNotAvailable(SSA_TRUST_MODEL_ECU_PEER_CERT_ID);

      retVal = E_NOT_OK;
      KeyM_SharedSecretDistribution_MapCertificateStatusToVerificationResult(invalidCertificate_Id, localCertStatus, Verification_Result);
      /* Log failed Trust Model certififcate verification event */
      KeyM_LogTrustModelCertificateVerificationResult(invalidCertificate_Id, *Verification_Result);
    }

    /* else, the additional verification succeeded. */
  }

  return retVal;
}

#if (SSA_ECU_TYPE == SSA_ECU_TYPE_VSM)

/**********************************************************************************************************************
 *  KeyM_CarSpecificSecretDistribution_VerifyEcuCert_DiagChain()
 **********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
SSA_KEYM_LOCAL FUNC(Std_ReturnType, Ssa_KeyM_CODE) KeyM_CarSpecificSecretDistribution_VerifyEcuCert_DiagChain(
  P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) ecuCertificate,
  uint16 DataLength,
  P2VAR(uint8, AUTOMATIC, AUTOMATIC) ecuPublicKey,
  P2VAR(uint8, AUTOMATIC, AUTOMATIC) Verification_Result,
  P2VAR(Dcm_NegativeResponseCodeType, AUTOMATIC, AUTOMATIC) ErrorCode)
{
  Std_ReturnType retVal = E_NOT_OK;
  uint16 backendCertLength = SSA_SIZEOF_CERT_MAX;
# if (SSA_KEEP_BUFFER_VARIABLES_STATIC == STD_OFF)
  uint8 KeyM_BackendCertBuf[SSA_SIZEOF_CERT_MAX];

  /* satisfy QAC, initialize */
  KeyM_BackendCertBuf[0] = 0;
# endif

  /*  #5 Handle the following states:
   *     KEYM_SECRET_DISTRIB_VERIFY_ECUCERT_STATE_IDLE, (parse certificate)
   *     KEYM_SECRET_DISTRIB_VERIFY_ECUCERT_STATE_VERIFY. */

  if (KeyM_DiagProc.verifyCertState == KEYM_SECRET_DISTRIB_VERIFY_ECUCERT_STATE_IDLE)
  {
    /* #10 Check input buffer length. */
    if (DataLength < 2u)
    {
      retVal = E_NOT_OK;
      *ErrorCode = DCM_E_INCORRECTMESSAGELENGTHORINVALIDFORMAT;
      KeyM_DiagProc.verifyCertState = KEYM_SECRET_DISTRIB_VERIFY_ECUCERT_STATE_IDLE;
    }
    else
    {
      /* #30 Parse the ECU certificate. */
      retVal = KeyM_CarSpecificSecretDistribution_VerifyEcuCert_DiagChain_GetEcuCertificate(ecuCertificate, DataLength, Verification_Result, ErrorCode, &KeyM_DiagProc.verifyCertState);

      if ((retVal == E_OK) && (KeyM_DiagProc.ws.replaceCerts.receivedParsedEcuCert.verificationResult == CERTP_VER_PARSE_OK))
      {
        /* #40 Get parsed backend certificate. */
        if (KeyM_GetAndParseStoredCert(CERTP_PKI_ROLE_BACKEND, (P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR))KeyM_BackendCertBuf, (P2VAR(uint16, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR))&backendCertLength, FALSE) != E_OK)
        {
          retVal = E_NOT_OK;
          *ErrorCode = DCM_E_GENERALREJECT;
          KeyM_DiagProc.verifyCertState = KEYM_SECRET_DISTRIB_VERIFY_ECUCERT_STATE_IDLE;
        }
        else
        {
          KeyM_DiagProc.verifyCertState = KEYM_SECRET_DISTRIB_VERIFY_ECUCERT_STATE_VERIFY;
        }
      }
      /* else: retVal and ErrorCode, resp. verification result have been set in 
       * KeyM_CarSpecificSecretDistribution_VerifyEcuCert_DiagChain_GetEcuCertificate() */
    }
  }

  if (KeyM_DiagProc.verifyCertState == KEYM_SECRET_DISTRIB_VERIFY_ECUCERT_STATE_VERIFY)
  {
    /* #50 Verify the received ECU certificate against the stored Backend CA certificate. */
    /* Check against RTE in buffer CertP_RawCertBufferType: ecuCertificate = Target_ECU_Certificate: uint8* is of type Dcm_Data1002ByteType */

    /*@ assert &(ecuCertificate[2]) != NULL_PTR; */
    /*@ assert &KeyM_DiagProc.ws.replaceCerts.receivedParsedEcuCert != NULL_PTR; */
    /*@ assert KeyM_BackendCertBuf != NULL_PTR; */
    /*@ assert &KeyM_ParsedBackendCert != NULL_PTR; */
    retVal = Rte_Call_CertP_Functions_Certificate_Verify( /* VCA_SSA_KEYM_FUNCTION_REQUIREMENTS_VIOLATED */
      &(ecuCertificate[2]), &KeyM_DiagProc.ws.replaceCerts.receivedParsedEcuCert, KeyM_BackendCertBuf, &KeyM_ParsedBackendCert, CERTP_PKI_ROLE_ECU);

    if (retVal == RTE_E_CertP_Functions_E_PENDING)
    {
      /* remain in current state */
      retVal = SSA_E_PENDING;
    }
    else if (retVal != E_OK)
    {
      retVal = E_NOT_OK;
      *ErrorCode = DCM_E_GENERALREJECT;
      KeyM_DiagProc.verifyCertState = KEYM_SECRET_DISTRIB_VERIFY_ECUCERT_STATE_IDLE;
    }
    else if (KeyM_DiagProc.ws.replaceCerts.receivedParsedEcuCert.verificationResult != CERTP_VER_OK)
    {
      /* Return the verification result from certificate verification. */
      *Verification_Result = KeyM_DiagProc.ws.replaceCerts.receivedParsedEcuCert.verificationResult;
      KeyM_DiagProc.verifyCertState = KEYM_SECRET_DISTRIB_VERIFY_ECUCERT_STATE_IDLE;
      /* No negative return. */
    }
    else
    {
      /* Verification against Backend CA certificate successful. */
      *Verification_Result = CERTP_VER_OK;

      /* #60 If ECU type is VSM verify if the subject key identifier is available in the received ECU certificate
       *     and verify it against the target subject key identifier. */
      if (!KeyM_DiagProc.ws.replaceCerts.receivedParsedEcuCert.subjectKeyIdentifier.validContent)
      {
        *Verification_Result = SSA_VER_RES_TRUST_MODEL_SECOC_CSS_ENCRYPT_NO_RIGHTS_TO_PROCEED_FOR_THIS_ECU;
        /* No negative return. */
      }
      else
      {
        /*@ assert &ecuCertificate[2u + KeyM_DiagProc.ws.replaceCerts.receivedParsedEcuCert.subjectKeyIdentifier.elemDataIdx] != NULL_PTR; */
        boolean authorizationApprovalFlag = KeyM_CheckRequestersAuthorization(&ecuCertificate[2u + KeyM_DiagProc.ws.replaceCerts.receivedParsedEcuCert.subjectKeyIdentifier.elemDataIdx]); /* VCA_SSA_KEYM_FUNCTION_REQUIREMENTS_VIOLATED */
        if (authorizationApprovalFlag == FALSE)
        {
          /* No rights to proceed for this ECU */
          *Verification_Result = SSA_VER_RES_TRUST_MODEL_SECOC_CSS_ENCRYPT_NO_RIGHTS_TO_PROCEED_FOR_THIS_ECU;
        }
      }

      /* #63 Verify by the special ECU field that the received ECU certificate is not a VSM certificate.
       *     and that it is eligible for SecOC-IS procedure and car shared secret provisioning (specialECU flag != SSA_SPECIALECU_ID_NONSECOC_IS). */
      /*     If there is no specialECU field, it will be set to 0xFF which is ok for the received certificate. */
      if ((KeyM_DiagProc.ws.replaceCerts.receivedParsedEcuCert.specialECU == (uint8)SSA_SPECIALECU_ID_VSM)
        || (KeyM_DiagProc.ws.replaceCerts.receivedParsedEcuCert.specialECU == (uint8)SSA_SPECIALECU_ID_NONSECOC_IS))
      {
        *Verification_Result = SSA_VER_RES_TRUST_MODEL_SECOC_CSS_ENCRYPT_ECU_CERTIFICATE_VERIFICATION_FAILED_INVALID_SCOPE;
      }

      if (*Verification_Result != CERTP_VER_OK)
      {
        /* Check if error occurred. */
      }
      else if (KeyM_DiagProc.ws.replaceCerts.receivedParsedEcuCert.publicKey.elemDataLength != SSA_SIZEOF_PUBLICKEY)
      {
        /* #66 Store the public key for later use. */
        *Verification_Result = SSA_VER_RES_TRUST_MODEL_SECOC_CSS_ENCRYPT_ECU_CERTIFICATE_VERIFICATION_FAILED_INVALID_FORMAT;
        /* No negative return. */
      }
      else
      {
        Ssa_MemCpy(ecuPublicKey, &(ecuCertificate[2u + KeyM_DiagProc.ws.replaceCerts.receivedParsedEcuCert.publicKey.elemDataIdx]), SSA_SIZEOF_PUBLICKEY);
      }

      /* Reset to idle state. */
      KeyM_DiagProc.verifyCertState = KEYM_SECRET_DISTRIB_VERIFY_ECUCERT_STATE_IDLE;
    }
  }

  return retVal;
} /* PRQA S 6010, 6030, 6050, 6060, 6080 */ /* MD_MSR_STPTH, MD_MSR_STCYC, MD_MSR_STCAL, MD_SSA_STPAR, MD_MSR_STMIF */

/**********************************************************************************************************************
 *  KeyM_CarSpecificSecretDistribution_VerifyEcuCert_DiagChain_GetEcuCertificate()
 **********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 */
SSA_KEYM_LOCAL FUNC(Std_ReturnType, Ssa_KeyM_CODE) KeyM_CarSpecificSecretDistribution_VerifyEcuCert_DiagChain_GetEcuCertificate(
  P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) ecuCertificate,
  uint16 DataLength,
  P2VAR(uint8, AUTOMATIC, AUTOMATIC) Verification_Result,
  P2VAR(uint8, AUTOMATIC, AUTOMATIC) ErrorCode,
  P2VAR(uint8, AUTOMATIC, AUTOMATIC) verifyCertState)
{
  Std_ReturnType retVal = E_NOT_OK;

  /* #1 Extract the length of the ECU certificate data and check it against the input buffer length. */
  uint16 ecuCertLength = KeyM_GetUint16(ecuCertificate[0], ecuCertificate[1]);
  /* Check length of ECU certificate and parse ECU certificate. */
  if (DataLength < (2u + ecuCertLength))
  {
    retVal = E_NOT_OK;
    *ErrorCode = DCM_E_INCORRECTMESSAGELENGTHORINVALIDFORMAT;
    *verifyCertState = KEYM_SECRET_DISTRIB_VERIFY_ECUCERT_STATE_IDLE;
  }
  else
  {
    P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) ecuCertificateWithoutLeadingBytes = &(ecuCertificate[2]);

    /* #2 Parse the ECU certificate. */
    /* Check against RTE in buffer CertP_RawCertBufferType: ecuCertificate = Target_ECU_Certificate: uint8* is of type Dcm_Data1002ByteType */

    /*@ assert ecuCertificateWithoutLeadingBytes != NULL_PTR; */
    /*@ assert &KeyM_DiagProc.ws.replaceCerts.receivedParsedEcuCert != NULL_PTR; */
    retVal = Rte_Call_CertP_Functions_Certificate_Parse(ecuCertificateWithoutLeadingBytes, ecuCertLength, &KeyM_DiagProc.ws.replaceCerts.receivedParsedEcuCert); /* VCA_SSA_KEYM_FUNCTION_REQUIREMENTS_VIOLATED */
    if (retVal != E_OK)
    {
      retVal = E_NOT_OK;
      *ErrorCode = DCM_E_GENERALREJECT;
      *verifyCertState = KEYM_SECRET_DISTRIB_VERIFY_ECUCERT_STATE_IDLE;
    }
    else if (KeyM_DiagProc.ws.replaceCerts.receivedParsedEcuCert.verificationResult != CERTP_VER_PARSE_OK)
    {
      *Verification_Result = CERTP_VER_INVALID_FORMAT;
      /* No negative return. */
      *verifyCertState = KEYM_SECRET_DISTRIB_VERIFY_ECUCERT_STATE_IDLE;
    }
    else
    {
      /* do nothing, retVal is E_OK */
    }
  }

  return retVal;
}
#endif

/**********************************************************************************************************************
 *  KeyM_Replace_Certificate_Extract_Certificates()
 **********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
SSA_KEYM_LOCAL_INLINE FUNC(uint8, Ssa_KeyM_CODE) KeyM_Replace_Certificate_Extract_Certificates(
  P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) Certificates,
  uint16 DataLength,
  P2VAR(Ssa_KeyM_CertChainDataType, AUTOMATIC, AUTOMATIC) cert,
  P2VAR(Dcm_NegativeResponseCodeType, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) errCode)
{
  uint8 certReplacement = KEYM_REPLACE_NO_CERT;
  Std_ReturnType tmpRetVal;

  uint16 certificate4Length = 0u;
  P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) certificate4 = NULL_PTR; /* PRQA S 2981 */ /* MD_SSA_REDUNDANT_INITIALIZATION */
  uint16 byteIdx = 0u;

  /* Initialize the certificate information data structure. */
  cert->ecu = NULL_PTR;
  cert->ecuLength = 0u;
  cert->backendCa = NULL_PTR;
  cert->backendCaLength = 0u;
  cert->backendCaLink = NULL_PTR;
  cert->backendCaLinkLength = 0u;
  cert->rootCa = NULL_PTR;
  cert->rootCaLength = 0u;
  cert->rootCaLink = NULL_PTR;
  cert->rootCaLinkLength = 0u;

  /* #10 Extract the lengths of the certificates. */
  tmpRetVal = KeyM_Replace_Certificate_Extract_Certificates_ExtractCertLengths(
    Certificates, DataLength, cert, &certificate4Length, &byteIdx, errCode);

  /* #50 Check based on the lengths of the extracted certificates for valid combinations for the certificates replacement. */
  if (tmpRetVal == E_OK)
  {
    /* Assign start address of the link certificate using the extracted length. */
    if ((certificate4Length) > 0u)
    {
      certificate4 = &(Certificates[byteIdx]);
    }

#if (SSA_ECU_TYPE == SSA_ECU_TYPE_VSM)
    if (cert->ecuLength > 0u)
#endif
    {
      if ((certificate4Length > 0u) && (cert->rootCaLength > 0u) && (cert->backendCaLength > 0u))
      {
        /* Replacement of Root CA Certificate, Backend CA Certificate and ECU Certificate (only VSM) */
        certReplacement = KEYM_REPLACE_CERT_ROOT_AND_LOWER;
        cert->rootCaLink = certificate4;
        cert->rootCaLinkLength = certificate4Length;
      }
      else if ((certificate4Length > 0u) && (cert->rootCaLength == 0u) && (cert->backendCaLength > 0u))
      {
        /* Replacement of Backend CA Certificate and ECU Certificate (only VSM)  */
        certReplacement = KEYM_REPLACE_CERT_BACKEND_AND_LOWER;
        cert->backendCaLink = certificate4;
        cert->backendCaLinkLength = certificate4Length;
      }
#if (SSA_ECU_TYPE == SSA_ECU_TYPE_VSM)
      else if ((certificate4Length == 0u) && (cert->rootCaLength == 0u) && (cert->backendCaLength == 0u))
      {
        /* Replacement of ECU Certificate (only VSM) only */
        certReplacement = KEYM_REPLACE_CERT_ECU_ONLY;
      }
#endif
      else
      {
        /* No negative return. */
      }
    }
  }

  /* #60 Return the number of certificates to be replaced which also defines the combination of the certificates to
   *     be replaced. */
  return certReplacement;
} /* PRQA S 6010, 6030, 6080 */ /* MD_MSR_STPTH, MD_MSR_STCYC, MD_MSR_STMIF */

/**********************************************************************************************************************
 *  KeyM_Replace_Certificate_Extract_Certificates_ExtractCertLengths()
 **********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
SSA_KEYM_LOCAL_INLINE FUNC(Std_ReturnType, Ssa_KeyM_CODE) KeyM_Replace_Certificate_Extract_Certificates_ExtractCertLengths(
  P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) Certificates,
  uint16 DataLength,
  P2VAR(Ssa_KeyM_CertChainDataType, AUTOMATIC, AUTOMATIC) cert,
  P2VAR(uint16, AUTOMATIC, AUTOMATIC) certificate4Length,
  P2VAR(uint16, AUTOMATIC, AUTOMATIC) byteIdx,
  P2VAR(Dcm_NegativeResponseCodeType, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) errCode)
{
  Std_ReturnType retVal = E_NOT_OK;

  /* #10 Extract length of certificate 1 which is always an ECU certificate. */
  /* #11 Parse the ECU certificate slot always even if it is only required in VSM */
  if (KeyM_ExtractCertificateLength(Certificates, DataLength, byteIdx, &(cert->ecuLength)) == TRUE)
  {
    *errCode = DCM_E_INCORRECTMESSAGELENGTHORINVALIDFORMAT;
  }
  /* #20 Extract length of certificate 2 which is always a Backend CA certificate. */
  else if (KeyM_ExtractCertificateLength(Certificates, DataLength, byteIdx, &(cert->backendCaLength)) == TRUE)
  {
    *errCode = DCM_E_INCORRECTMESSAGELENGTHORINVALIDFORMAT;
  }
  /* #30 Extract length of certificate 3 which is always a Root CA certificate. */
  else if (KeyM_ExtractCertificateLength(Certificates, DataLength, byteIdx, &(cert->rootCaLength)) == TRUE)
  {
    *errCode = DCM_E_INCORRECTMESSAGELENGTHORINVALIDFORMAT;
  }
  /* #40 Extract length of certificate 4 which is either a Root CA Link or a Backend CA Link certificate. */
  else if (KeyM_ExtractCertificateLength(Certificates, DataLength, byteIdx, certificate4Length) == TRUE)
  {
    *errCode = DCM_E_INCORRECTMESSAGELENGTHORINVALIDFORMAT;
  }
  /* #45 Assign start addresses of the extracted certificates using the extracted lengths. */
  else
  {
    *byteIdx = 2u;
    if ((cert->ecuLength) > 0u)
    {
      cert->ecu = &(Certificates[*byteIdx]);
    }
    *byteIdx += (cert->ecuLength + 2u);
    if ((cert->backendCaLength) > 0u)
    {
      cert->backendCa = &(Certificates[*byteIdx]);
    }
    *byteIdx += (cert->backendCaLength + 2u);
    if ((cert->rootCaLength) > 0u)
    {
      cert->rootCa = &(Certificates[*byteIdx]);
    }
    *byteIdx += (cert->rootCaLength + 2u);

    /* Assign start address of the link certificate (certificate4) outside this function, if retVal = E_OK. */

    retVal = E_OK;
  }

  return retVal;
} /* PRQA S 6060, 6080 */ /* MD_SSA_STPAR, MD_MSR_STMIF */

#if (SSA_ECU_TYPE == SSA_ECU_TYPE_VSM)
/**********************************************************************************************************************
 *  KeyM_Replace_Certificate_Verify_Ecu()
 **********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
SSA_KEYM_LOCAL FUNC(Std_ReturnType, Ssa_KeyM_CODE) KeyM_Replace_Certificate_Verify_Ecu(
  P2CONST(Ssa_KeyM_CertChainDataType, AUTOMATIC, AUTOMATIC) cert,
  P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) backendCertBuf,
  P2CONST(CertP_ParsedCertStructureType, AUTOMATIC, AUTOMATIC) parsedBackendCertPtr,
  P2VAR(uint8, AUTOMATIC, AUTOMATIC) Verification_Result,
  P2VAR(Dcm_NegativeResponseCodeType, AUTOMATIC, AUTOMATIC) ErrorCode)
{
  Std_ReturnType retVal = E_NOT_OK;
  Std_ReturnType tmpRetVal = E_OK; /* Used for handling the while loop.  */
  uint8 stateCounter = 0u;

  /*  #5 Handle the following states:
   *     KEYM_REPLACE_CERT_VERIFY_ECUCERT_STATE_IDLE,  (parse certificate)
   *     KEYM_REPLACE_CERT_VERIFY_ECUCERT_STATE_VERIFY_CERT,
   *     KEYM_REPLACE_CERT_VERIFY_ECUCERT_STATE_VERIFY_PUBKEY_AGAINST_PRIVKEY. */
  for (stateCounter = 0u; stateCounter < SSA_KEYM_REPLACE_CERT_VERIFY_ECU_UPPER_BOUNDARY; stateCounter++)
  {
    if (tmpRetVal == E_OK)
    {
      switch (KeyM_DiagProc.replaceCertificatesVerifyEcuState)
      {
        case KEYM_REPLACE_CERT_VERIFY_ECUCERT_STATE_IDLE:
        {
          /* #10 Execute the following steps and quit the function on any error or verification failure.
          * In case of an verification failure return the verification result from the called sub-function. */

          /* #20 Parse the received ECU certificate. */
          /*@ assert cert->ecu != NULL_PTR; */ /* VCA_SSA_KEYM_ECU_CERT_VALID_POINTER_BEFORE_REPLACEMENT */
          retVal = Rte_Call_CertP_Functions_Certificate_Parse(cert->ecu, cert->ecuLength, &KeyM_DiagProc.ws.replaceCerts.receivedParsedEcuCert);
          tmpRetVal = KeyM_ReplaceCertificates_HandleParsingResult(
            &retVal, KeyM_DiagProc.ws.replaceCerts.receivedParsedEcuCert.verificationResult, KEYM_REPLACE_CERT_VERIFY_ECU_ECU_CERT, Verification_Result, ErrorCode);

          KeyM_ReplaceCertificates_StateHandling(tmpRetVal,
            KEYM_REPLACE_CERT_VERIFY_ECUCERT_STATE_IDLE,
            KEYM_REPLACE_CERT_VERIFY_ECUCERT_STATE_VERIFY_CERT,
            &KeyM_DiagProc.replaceCertificatesVerifyEcuState);
          break;
        }

        case KEYM_REPLACE_CERT_VERIFY_ECUCERT_STATE_VERIFY_CERT:
        {
          /*@ assert cert->ecu != NULL_PTR; */ /* VCA_SSA_KEYM_ECU_CERT_VALID_POINTER_BEFORE_REPLACEMENT */
          /*@ assert sizeof(cert->ecu) >= sizeof(CertP_RawCertBufferType); */ /* VCA_SSA_KEYM_VALID_CERT_BUFFER_FOR_VERIFICATION */
          retVal = Rte_Call_CertP_Functions_Certificate_Verify(
            cert->ecu, &KeyM_DiagProc.ws.replaceCerts.receivedParsedEcuCert, backendCertBuf, parsedBackendCertPtr, CERTP_PKI_ROLE_ECU);
          tmpRetVal = KeyM_ReplaceCertificates_HandleCertificateVerificationResult(
            &retVal, KeyM_DiagProc.ws.replaceCerts.receivedParsedEcuCert.verificationResult, KEYM_REPLACE_CERT_VERIFY_ECU_ECU_CERT, Verification_Result, ErrorCode);

          if (tmpRetVal == E_OK)
          {
# if (SSA_KEEP_BUFFER_VARIABLES_STATIC == STD_OFF)
            uint8 KeyM_EcuCertBuf[SSA_SIZEOF_CERT_MAX];
# endif
            uint16 ecuCertLength = SSA_SIZEOF_CERT_MAX;
            /* #30 Compare if the Common Name field of the old ECU Certificate is identical to the
             *     Common Name field of the new ECU Certificate. If the contents of both Common Name fields
             *     do not match, return as verification result "Invalid Content".  */

             /* Verification against Backend CA certificate successful. */
            *Verification_Result = CERTP_VER_OK;

            /* Get parsed ECU certificate. */
            retVal = KeyM_GetAndParseStoredCert(CERTP_PKI_ROLE_ECU, (P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR))KeyM_EcuCertBuf, (P2VAR(uint16, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR))&ecuCertLength, FALSE);
            if (retVal == E_OK)
            {
              boolean isEqual = FALSE;
              /* Compare the Common Name field from the
              old ECU Certificate against the Common Name field from the new ECU Certificate
              provided within the routineControlOptionRecord. */

              /*@ assert cert->ecu != NULL_PTR; */ /* VCA_SSA_KEYM_ECU_CERT_VALID_POINTER_BEFORE_REPLACEMENT */
              retVal = Rte_Call_CertP_Functions_Certificate_Compare(
                KeyM_EcuCertBuf, &KeyM_ParsedEcuCert, CERTP_PKI_ROLE_ECU,
                cert->ecu, &KeyM_DiagProc.ws.replaceCerts.receivedParsedEcuCert, CERTP_PKI_ROLE_ECU, &isEqual);
              tmpRetVal = KeyM_ReplaceCertificates_HandleCertificateCompareResult(
                &retVal, isEqual, KEYM_REPLACE_CERT_VERIFY_ECU_ECU_CERT, Verification_Result, ErrorCode);
            }
            else
            {
              retVal = E_NOT_OK;
              *ErrorCode = DCM_E_GENERALREJECT;
              /* Leave while loop. */
              tmpRetVal = E_NOT_OK;
            }
          }

          KeyM_ReplaceCertificates_StateHandling(tmpRetVal,
            KEYM_REPLACE_CERT_VERIFY_ECUCERT_STATE_IDLE,
            KEYM_REPLACE_CERT_VERIFY_ECUCERT_STATE_VERIFY_PUBKEY_AGAINST_PRIVKEY,
            &KeyM_DiagProc.replaceCertificatesVerifyEcuState);
          break;
        }

        case KEYM_REPLACE_CERT_VERIFY_ECUCERT_STATE_VERIFY_PUBKEY_AGAINST_PRIVKEY:
        {
          /* #40 Verify that the PublicKeyECU from the new ECU Certificate with the PrivateKeyECU stored in ECU. */
          Crypto_VerifyResultType cryptoVerifResult = CRYPTO_E_VER_NOT_OK;
          tmpRetVal = E_NOT_OK; /* This is the final state, i.e. leave the while loop, if no pending is returned. */

          retVal = KeyM_VerifyPublicKeyWithEcuPrivateKey(
            SSA_DIAGNOSTIC_KEY_PAIR,
            &cert->ecu[KeyM_DiagProc.ws.replaceCerts.receivedParsedEcuCert.publicKey.elemDataIdx],
            &cryptoVerifResult);

          /* Handle result of public key verification */
# if (SSA_ENABLE_ASYNC_CSM_JOB_PROCESSING == STD_ON)
          if (retVal == SSA_E_PENDING)
          {
            /* Remain in state */
            /* Leave while loop. */
            tmpRetVal = SSA_E_PENDING;
          }
          else if (retVal != E_OK)
# else
        /* In a synchronous configuration, pending return values within
         * KeyM_VerifyPublicKeyWithEcuPrivateKey are treated like errors. */
          if (retVal != E_OK)
# endif
          {
            retVal = E_NOT_OK;
            *ErrorCode = DCM_E_GENERALREJECT;
          }
          else if (cryptoVerifResult != CRYPTO_E_VER_OK)
          {
            *Verification_Result = Map_VerRes_Ecu(CERTP_VER_INVALID_CHAIN_OF_TRUST);
          }
          else
          {
            /* success */
            *Verification_Result = CERTP_VER_OK;
          }

# if (SSA_ENABLE_ASYNC_CSM_JOB_PROCESSING == STD_ON)
          if (tmpRetVal == E_NOT_OK)
# endif
          {
            /* Change state to idle and leave while loop. */
            KeyM_DiagProc.replaceCertificatesVerifyEcuState = KEYM_REPLACE_CERT_VERIFY_ECUCERT_STATE_IDLE;
          }
          break;
        }
        default:
        {
          retVal = E_NOT_OK;
          *ErrorCode = DCM_E_GENERALREJECT;
          /* Leave while loop. */
          tmpRetVal = E_NOT_OK;
          break;
        }
      }
    }
    else
    {
      /* leave for-loop */
      break;
    }
  }
  return retVal;
} /* PRQA S 6010, 6030, 6080, 6050 */ /* MD_MSR_STPTH, MD_MSR_STCYC, MD_MSR_STMIF, MD_MSR_STCAL */
#endif

#if (SSA_ECU_TYPE == SSA_ECU_TYPE_VSM)
/**********************************************************************************************************************
 *  KeyM_Replace_Certificate_Replace_Ecu()
 **********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 */
SSA_KEYM_LOCAL_INLINE FUNC(Std_ReturnType, Ssa_KeyM_CODE) KeyM_Replace_Certificate_Replace_Ecu(
  P2CONST(Ssa_KeyM_CertChainDataType, AUTOMATIC, AUTOMATIC) cert,
  P2VAR(uint8, AUTOMATIC, AUTOMATIC) Verification_Result,
  P2VAR(Dcm_NegativeResponseCodeType, AUTOMATIC, AUTOMATIC) ErrorCode)
{
  Std_ReturnType retVal = E_NOT_OK;
  uint16 backendCertLength = SSA_SIZEOF_CERT_MAX;
# if (SSA_KEEP_BUFFER_VARIABLES_STATIC == STD_OFF)
  uint8 KeyM_BackendCertBuf[SSA_SIZEOF_CERT_MAX];
  /* satisfy QAC, initialize */
  KeyM_BackendCertBuf[0] = 0;
# endif

  /* #5 Handle the following states:
   *    KEYM_REPLACE_CERT_REPLACE_ECUCERT_STATE_IDLE,     (get stored Backend Ca certificate)
   *    KEYM_REPLACE_CERT_REPLACE_ECUCERT_STATE_VERIFY_ECU_CERT. */

  if (KeyM_DiagProc.replaceCertificatesReplaceEcuState == KEYM_REPLACE_CERT_REPLACE_ECUCERT_STATE_IDLE)
  {
    /* #10 Get parsed Backend CA certificate. */
    retVal = KeyM_GetAndParseStoredCert(CERTP_PKI_ROLE_BACKEND, (P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR))KeyM_BackendCertBuf, (P2VAR(uint16, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR))&backendCertLength, FALSE);

    if (retVal == E_OK)
    {
      KeyM_DiagProc.replaceCertificatesReplaceEcuState = KEYM_REPLACE_CERT_REPLACE_ECUCERT_STATE_VERIFY_ECU_CERT;
    }
    else
    {
      retVal = E_NOT_OK;
      *ErrorCode = DCM_E_GENERALREJECT;
    }
  }

  if (KeyM_DiagProc.replaceCertificatesReplaceEcuState == KEYM_REPLACE_CERT_REPLACE_ECUCERT_STATE_VERIFY_ECU_CERT)
  {
    /* #20 Execute all verifications around the ECU certificate. */
    retVal = KeyM_Replace_Certificate_Verify_Ecu(
      cert, (P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA))KeyM_BackendCertBuf, &KeyM_ParsedBackendCert, Verification_Result, ErrorCode);

# if (SSA_ENABLE_ASYNC_CSM_JOB_PROCESSING == STD_ON)
    if (retVal == SSA_E_PENDING)
    {
      /* remain in state */
    }
    else if (retVal == E_OK)
# else
    /* In a synchronous configuration, pending return values within KeyM_Replace_Certificate_Verify_Ecu
     * are treated like errors. */
    if (retVal == E_OK)
# endif
    {
      /* #30 When all verifications are successfully finished replace the ECU Certificate. */
      if (*Verification_Result == CERTP_VER_OK)
      {
        /*@ assert cert->ecu != NULL_PTR; */ /* VCA_SSA_KEYM_ECU_CERT_VALID_POINTER_BEFORE_REPLACEMENT */
        retVal = Rte_Call_SsaCdd_Keys_KeyElementSet(SSA_KEYM_CSM_KEY_DIAG_CHAIN_ECU_CERT, SSA_KE_CERTIFICATE_DATA, cert->ecu, cert->ecuLength);
        retVal |= Rte_Call_SsaCdd_Keys_KeySetValid(SSA_KEYM_CSM_KEY_DIAG_CHAIN_ECU_CERT);
        if (retVal != E_OK)
        {
          *ErrorCode = DCM_E_GENERALREJECT;
          retVal = E_NOT_OK;
        }
        else
        {
          /* #40 Reset the verification result of stored certificate so that it will be parsed again when used next time. */
          KeyM_ParsedEcuCert.verificationResult = CERTP_VER_NOT_PARSED;
          *Verification_Result = KEYM_VER_RES_CERT_VERIFIED_AND_REPLACED;
        }
      }
      KeyM_DiagProc.replaceCertificatesReplaceEcuState = KEYM_REPLACE_CERT_REPLACE_ECUCERT_STATE_IDLE;
    }
    else
    {
      /* error */
      KeyM_DiagProc.replaceCertificatesReplaceEcuState = KEYM_REPLACE_CERT_REPLACE_ECUCERT_STATE_IDLE;
      retVal = E_NOT_OK;
    }
  }

  return retVal;
} /* PRQA S 6080 */ /* MD_MSR_STMIF */
#endif

/**********************************************************************************************************************
 *  KeyM_Replace_Certificate_VerifyAndReplaceReceivedCertificates()
 **********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 */
SSA_KEYM_LOCAL_INLINE FUNC(Std_ReturnType, Ssa_KeyM_CODE) KeyM_Replace_Certificate_VerifyAndReplaceReceivedCertificates(
  uint8 extractedCertificate,
  P2CONST(Ssa_KeyM_CertChainDataType, AUTOMATIC, AUTOMATIC) cert,
  P2VAR(uint8, AUTOMATIC, AUTOMATIC) verResult,
  P2VAR(Dcm_NegativeResponseCodeType, AUTOMATIC, AUTOMATIC) errCode)
{

  Std_ReturnType retVal = E_NOT_OK;

  /* Check before any parse or verify RTE calls during routine Replace_Certificates are made all certificate lengths 
   * for the allowed maximum length. This ensures that in each case
   * cert->ecu, cert->backendCa, cert->rootCa, cert->backendCaLink, cert->rootCaLink point to a sub-buffer of certificates that
   * is greater than or equal to sizeof(CertP_RawCertBufferType) == SSA_SIZEOF_CERT_MAX
   * since SSA_SIZEOF_CERT_MAX + SSA_SIZEOF_CERT_MAX + SSA_SIZEOF_CERT_MAX + SSA_SIZEOF_CERT_MAX < sizeof(Certificates) = sizeof(Dcm_Data4008ByteType) */
#if (SSA_ECU_TYPE == SSA_ECU_TYPE_VSM)
  if (cert->ecuLength > SSA_SIZEOF_CERT_MAX)
  {
    retVal = E_OK;
    *verResult =  Map_VerRes_Ecu(CERTP_VER_INVALID_FORMAT);
  }
  else
#endif
  if (cert->backendCaLength > SSA_SIZEOF_CERT_MAX)
  {
    retVal = E_OK;
    *verResult = Map_VerRes_Backend(CERTP_VER_INVALID_FORMAT);
  }
  else if (cert->rootCaLength > SSA_SIZEOF_CERT_MAX)
  {
    retVal = E_OK;
    *verResult = Map_VerRes_Root(CERTP_VER_INVALID_FORMAT);
  }
  else if (((cert->backendCaLinkLength > 0u) && (cert->rootCaLinkLength > 0u))
    || ((cert->backendCaLinkLength > SSA_SIZEOF_CERT_MAX) || (cert->rootCaLinkLength > SSA_SIZEOF_CERT_MAX)))
  {
    retVal = E_OK;
    *verResult = Map_VerRes_Link(CERTP_VER_INVALID_FORMAT);
  }
  else
  {
#if (SSA_ECU_TYPE == SSA_ECU_TYPE_VSM)
    /*@ assert cert->ecu != NULL_PTR; */ /* VCA_SSA_KEYM_ECUCERT_VALID_POINTER_AFTER_EXTRACTION */
    /* ********** Replacement of ECU Certificate only ********** */
    if (extractedCertificate == KEYM_REPLACE_CERT_ECU_ONLY)
    {
      retVal = KeyM_Replace_Certificate_Replace_Ecu(
        cert, verResult, errCode);
    }
    /* ********** Replacement of Backend CA Certificate and ECU Certificate only ********** */
    else
#endif
    {
      if (extractedCertificate == KEYM_REPLACE_CERT_BACKEND_AND_LOWER)
      {
        /*@ assert cert->backendCaLink != NULL_PTR; */ /* VCA_SSA_KEYM_BACKENDCAANDLINK_VALID_POINTER_AFTER_EXTRACTION */
        /*@ assert cert->backendCa != NULL_PTR; */ /* VCA_SSA_KEYM_BACKENDCAANDLINK_VALID_POINTER_AFTER_EXTRACTION */
        retVal = KeyM_Replace_Certificate_Replace_BackendAndLower(
          cert, verResult, errCode);
      }
      /* ********** Replacement of Root CA Certificate, Backend CA Certificate and ECU Certificate ********** */
      else if (extractedCertificate == KEYM_REPLACE_CERT_ROOT_AND_LOWER)
      {
        /*@ assert cert->rootCa != NULL_PTR; */ /* VCA_SSA_KEYM_ROOTCAANDLINK_VALID_POINTER_AFTER_EXTRACTION */
        /*@ assert cert->rootCaLink != NULL_PTR; */ /* VCA_SSA_KEYM_ROOTCAANDLINK_VALID_POINTER_AFTER_EXTRACTION */
        /*@ assert cert->backendCa != NULL_PTR; */ /* VCA_SSA_KEYM_ROOTCAANDLINK_VALID_POINTER_AFTER_EXTRACTION */
        retVal = KeyM_Replace_Certificate_Replace_RootAndLower(
          cert, verResult, errCode);
      }
      else
      {
        /* Verification failure. */
        retVal = E_OK;
        *verResult = CERTP_VER_INVALID_FORMAT;
      }
    }
  }
  return retVal;
} /* PRQA S 6080 */ /* MD_MSR_STMIF */

/**********************************************************************************************************************
 *  KeyM_Replace_Certificate_StateHandler_VerifyAndReplace()
 **********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 */
SSA_KEYM_LOCAL_INLINE FUNC(Std_ReturnType, Ssa_KeyM_CODE) KeyM_Replace_Certificate_StateHandler_VerifyAndReplace(
  uint8 verResult,
  P2VAR(Std_ReturnType, AUTOMATIC, AUTOMATIC) retVal,
  P2VAR(uint8, AUTOMATIC, AUTOMATIC) state)
{
  Std_ReturnType tmpRetVal = E_NOT_OK;

  if (*retVal == SSA_E_PENDING)
  {
    /* state remains unchanged */
    *retVal = RTE_E_RoutineServices_Routine_Replace_Certificates_DCM_E_PENDING;
  }
  else if (*retVal != E_OK)
  {
    *retVal = RTE_E_RoutineServices_Routine_Replace_Certificates_E_NOT_OK;
    *state = KEYM_REPLACE_CERT_STATE_IDLE;
  }
  else if (verResult != KEYM_VER_RES_CERT_VERIFIED_AND_REPLACED)
  {
    *state = KEYM_REPLACE_CERT_STATE_IDLE;
  }
  else
  {
    tmpRetVal = E_OK;
  }

  return tmpRetVal;
}

/**********************************************************************************************************************
 *  KeyM_Replace_Certificate_Replace_BackendAndLower()
 **********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
SSA_KEYM_LOCAL_INLINE FUNC(Std_ReturnType, Ssa_KeyM_CODE) KeyM_Replace_Certificate_Replace_BackendAndLower(
  P2CONST(Ssa_KeyM_CertChainDataType, AUTOMATIC, AUTOMATIC) cert,
  P2VAR(uint8, AUTOMATIC, AUTOMATIC) Verification_Result,
  P2VAR(Dcm_NegativeResponseCodeType, AUTOMATIC, AUTOMATIC) ErrorCode)
{
#if (SSA_ECU_TYPE == SSA_ECU_TYPE_VSM)
  /*@ assert cert->ecu != NULL_PTR; */
#endif

  Std_ReturnType rVal = E_NOT_OK;
  Std_ReturnType tmpRetVal = E_OK; /* Used for handling the while loop. */
  uint8 stateCounter = 0u;

  uint16 certBackendOrRootLength = SSA_SIZEOF_CERT_MAX;
#if (SSA_KEEP_BUFFER_VARIABLES_STATIC == STD_ON)
  P2VAR(uint8, AUTOMATIC, AUTOMATIC) backendOrRootCertBuf = KeyM_BackendCertBuf;
#else
  uint8 backendOrRootCertBuf[SSA_SIZEOF_CERT_MAX];
  /* satisfy QAC, initialize */
  backendOrRootCertBuf[0] = 0;
#endif

  /*  #5 Handle the following states:
   *     KEYM_REPLACE_CERT_REPLACE_BACKEND_AND_LOWER_CERT_STATE_IDLE,  (parse received Backend Ca link certificate)
   *     KEYM_REPLACE_CERT_REPLACE_BACKEND_AND_LOWER_CERT_STATE_VERIFY_BACKEND_LINK_CERT,
   *     KEYM_REPLACE_CERT_REPLACE_BACKEND_AND_LOWER_CERT_STATE_VERIFY_BACKEND_CERT,
   *     KEYM_REPLACE_CERT_REPLACE_BACKEND_AND_LOWER_CERT_STATE_VERIFY_ECU_CERT. */
  for (stateCounter = 0; stateCounter < SSA_KEYM_REPLACE_CERT_REPLACE_BACKENDANDLOWER_UPPER_BOUNDARY; stateCounter++)
  {
    if (tmpRetVal == E_OK)
    {
      switch (KeyM_DiagProc.replaceCertificatesReplaceBackendAndLowerState)
      {
        case KEYM_REPLACE_CERT_REPLACE_BACKEND_AND_LOWER_CERT_STATE_IDLE:
        {
          /* #10 Execute the following steps and quit the function on any error or verification failure.
           * In case of a verification failure return the verification result from the called sub-function. */

           /* #20 Parse the received Backend CA link certificate and get the old parsed Backend CA certificate. */
           /*@ assert cert->backendCaLink != NULL_PTR; */ /* VCA_SSA_KEYM_BACKENDCAANDLINK_VALID_POINTER_BEFORE_REPLACEMENT */
          rVal = KeyM_ReplaceCertificates_ParseCertsForVerification(
            KEYM_REPLACE_CERT_REPLACE_BACKEND_AND_LOWER_CERT_ID_BACKEND_LINK_CERT,
            cert,
            &KeyM_DiagProc.ws.replaceCerts.receivedParsedBackendCaOrRootCaLinkCert,
            backendOrRootCertBuf, /* certBuffer */
            &certBackendOrRootLength,
            &tmpRetVal,
            Verification_Result,
            ErrorCode);

          KeyM_ReplaceCertificates_StateHandling(
            tmpRetVal,
            KEYM_REPLACE_CERT_REPLACE_BACKEND_AND_LOWER_CERT_STATE_IDLE,
            KEYM_REPLACE_CERT_REPLACE_BACKEND_AND_LOWER_CERT_STATE_VERIFY_BACKEND_LINK_CERT,
            &KeyM_DiagProc.replaceCertificatesReplaceBackendAndLowerState);

          break;
        }

        case KEYM_REPLACE_CERT_REPLACE_BACKEND_AND_LOWER_CERT_STATE_VERIFY_BACKEND_LINK_CERT:
        {
          /* #30 Verify the Backend CA Link certificate against the old Backend CA certificate. */
          /*@ assert cert->backendCaLink != NULL_PTR; */ /* VCA_SSA_KEYM_BACKENDCAANDLINK_VALID_POINTER_BEFORE_REPLACEMENT */
          /*@ assert sizeof(cert->backendCaLink) >= sizeof(CertP_RawCertBufferType); */ /* VCA_SSA_KEYM_VALID_CERT_BUFFER_FOR_VERIFICATION */
          rVal = Rte_Call_CertP_Functions_Certificate_Verify(
            cert->backendCaLink, &KeyM_DiagProc.ws.replaceCerts.receivedParsedBackendCaOrRootCaLinkCert, backendOrRootCertBuf, &KeyM_ParsedBackendCert, CERTP_PKI_ROLE_BACKEND_CA_LINK_CERT);

          tmpRetVal = KeyM_ReplaceCertificates_HandleCertificateVerificationResult(
            &rVal, KeyM_DiagProc.ws.replaceCerts.receivedParsedBackendCaOrRootCaLinkCert.verificationResult, KEYM_REPLACE_CERT_REPLACE_BACKEND_AND_LOWER_CERT_ID_BACKEND_LINK_CERT, Verification_Result, ErrorCode);

          if (tmpRetVal == E_OK)
          {
            /* Verification against Backend CA certificate successful. */
            *Verification_Result = CERTP_VER_OK;

#if (SSA_KEEP_BUFFER_VARIABLES_STATIC == STD_ON)
            backendOrRootCertBuf = KeyM_RootCertBuf;
            certBackendOrRootLength = SSA_SIZEOF_CERT_MAX;
#endif

            /* #40 Parse the received, new Backend CA certificate and get the old, parsed root CA certificate. */
            /*@ assert cert->backendCa != NULL_PTR; */ /* VCA_SSA_KEYM_BACKENDCAANDLINK_VALID_POINTER_BEFORE_REPLACEMENT */
            rVal = KeyM_ReplaceCertificates_ParseCertsForVerification(
              KEYM_REPLACE_CERT_REPLACE_BACKEND_AND_LOWER_CERT_ID_BACKEND_CERT,
              cert,
              &KeyM_DiagProc.ws.replaceCerts.receivedParsedBackendCaCert,
              backendOrRootCertBuf, /* certBuffer */
              &certBackendOrRootLength,
              &tmpRetVal,
              Verification_Result,
              ErrorCode);
          }

          KeyM_ReplaceCertificates_StateHandling(
            tmpRetVal,
            KEYM_REPLACE_CERT_REPLACE_BACKEND_AND_LOWER_CERT_STATE_IDLE,
            KEYM_REPLACE_CERT_REPLACE_BACKEND_AND_LOWER_CERT_STATE_VERIFY_BACKEND_CERT,
            &KeyM_DiagProc.replaceCertificatesReplaceBackendAndLowerState);
          break;
        }

        case KEYM_REPLACE_CERT_REPLACE_BACKEND_AND_LOWER_CERT_STATE_VERIFY_BACKEND_CERT:
        {
          /* #50 Verify the new Backend CA certificate against the Root CA certificate. */
          /*@ assert cert->backendCa != NULL_PTR; */ /* VCA_SSA_KEYM_BACKENDCAANDLINK_VALID_POINTER_BEFORE_REPLACEMENT */
          /*@ assert sizeof(cert->backendCa) >= sizeof(CertP_RawCertBufferType); */ /* VCA_SSA_KEYM_VALID_CERT_BUFFER_FOR_VERIFICATION */
          rVal = Rte_Call_CertP_Functions_Certificate_Verify(
            cert->backendCa, &KeyM_DiagProc.ws.replaceCerts.receivedParsedBackendCaCert, backendOrRootCertBuf, &KeyM_ParsedRootCert, CERTP_PKI_ROLE_BACKEND);

          tmpRetVal = KeyM_ReplaceCertificates_HandleCertificateVerificationResult(
            &rVal, KeyM_DiagProc.ws.replaceCerts.receivedParsedBackendCaCert.verificationResult, KEYM_REPLACE_CERT_REPLACE_BACKEND_AND_LOWER_CERT_ID_BACKEND_CERT, Verification_Result, ErrorCode);

          if (tmpRetVal == E_OK)
          {
            /* #60  Compare if the relevant contents of the Backend CA Link Certificate are identical
             * to the contents of the new Backend CA Certificate, return verification result "invalid scope"
             * if different. */
            boolean isEqual = FALSE;

            /*@ assert cert->backendCaLink != NULL_PTR; */ /* VCA_SSA_KEYM_BACKENDCAANDLINK_VALID_POINTER_BEFORE_REPLACEMENT */
            /*@ assert cert->backendCa != NULL_PTR; */ /* VCA_SSA_KEYM_BACKENDCAANDLINK_VALID_POINTER_BEFORE_REPLACEMENT */
            rVal = Rte_Call_CertP_Functions_Certificate_Compare(
              cert->backendCaLink, &KeyM_DiagProc.ws.replaceCerts.receivedParsedBackendCaOrRootCaLinkCert, CERTP_PKI_ROLE_BACKEND_CA_LINK_CERT,
              cert->backendCa, &KeyM_DiagProc.ws.replaceCerts.receivedParsedBackendCaCert, CERTP_PKI_ROLE_BACKEND, &isEqual);

            tmpRetVal = KeyM_ReplaceCertificates_HandleCertificateCompareResult(
              &rVal, isEqual, KEYM_REPLACE_CERT_REPLACE_BACKEND_AND_LOWER_CERT_ID_BACKEND_CERT, Verification_Result, ErrorCode);
          }

          KeyM_ReplaceCertificates_StateHandling(tmpRetVal,
            KEYM_REPLACE_CERT_REPLACE_BACKEND_AND_LOWER_CERT_STATE_IDLE,
            KEYM_REPLACE_CERT_REPLACE_BACKEND_AND_LOWER_CERT_STATE_VERIFY_ECU_CERT,
            &KeyM_DiagProc.replaceCertificatesReplaceBackendAndLowerState);
          break;
        }

        case KEYM_REPLACE_CERT_REPLACE_BACKEND_AND_LOWER_CERT_STATE_VERIFY_ECU_CERT:
        {
          /* #70 Execute all verifications around the ECU certificate. */
#if (SSA_ECU_TYPE == SSA_ECU_TYPE_VSM)
        /*@ assert cert->ecu != NULL_PTR; */ /* VCA_SSA_KEYM_ECU_CERT_VALID_POINTER_BEFORE_REPLACEMENT */
        /*@ assert cert->backendCa != NULL_PTR; */ /* VCA_SSA_KEYM_BACKENDCAANDLINK_VALID_POINTER_BEFORE_REPLACEMENT */
          rVal = KeyM_Replace_Certificate_Verify_Ecu(
            cert, cert->backendCa, &KeyM_DiagProc.ws.replaceCerts.receivedParsedBackendCaCert, Verification_Result, ErrorCode);
          tmpRetVal = KeyM_ReplaceCertificates_HandleCertificateVerification_Ecu_Result(&rVal, Verification_Result, ErrorCode);

          if (tmpRetVal == E_OK)
#endif
          {
            /* #80 When all verifications are successfully finished replace Backend CA Certificate and ECU Certificate. */

            /*@ assert cert->backendCa != NULL_PTR; */ /* VCA_SSA_KEYM_BACKENDCAANDLINK_VALID_POINTER_BEFORE_REPLACEMENT */
            rVal = Rte_Call_SsaCdd_Keys_KeyElementSet(SSA_KEYM_CSM_KEY_DIAG_CHAIN_BACKEND_CERT, SSA_KE_CERTIFICATE_DATA, cert->backendCa, cert->backendCaLength);
            rVal |= Rte_Call_SsaCdd_Keys_KeySetValid(SSA_KEYM_CSM_KEY_DIAG_CHAIN_BACKEND_CERT);
#if (SSA_ECU_TYPE == SSA_ECU_TYPE_VSM)
            /*@ assert cert->ecu != NULL_PTR; */ /* VCA_SSA_KEYM_ECU_CERT_VALID_POINTER_BEFORE_REPLACEMENT */
            rVal |= Rte_Call_SsaCdd_Keys_KeyElementSet(SSA_KEYM_CSM_KEY_DIAG_CHAIN_ECU_CERT, SSA_KE_CERTIFICATE_DATA, cert->ecu, cert->ecuLength);
            rVal |= Rte_Call_SsaCdd_Keys_KeySetValid(SSA_KEYM_CSM_KEY_DIAG_CHAIN_ECU_CERT);
#endif
            if (rVal != E_OK)
            {
              rVal = E_NOT_OK;
              *ErrorCode = DCM_E_GENERALREJECT;
            }
            /* #90 Reset the verification results of stored certificates so that they will be parsed again when used next time. */
            else
            {
              KeyM_ParsedBackendCert.verificationResult = CERTP_VER_NOT_PARSED;
#if (SSA_ECU_TYPE == SSA_ECU_TYPE_VSM)
              KeyM_ParsedEcuCert.verificationResult = CERTP_VER_NOT_PARSED;
#endif
              *Verification_Result = KEYM_VER_RES_CERT_VERIFIED_AND_REPLACED;
            }

            /* Change state to idle and stop processing the for-loop. */
            KeyM_DiagProc.replaceCertificatesReplaceBackendAndLowerState = KEYM_REPLACE_CERT_REPLACE_BACKEND_AND_LOWER_CERT_STATE_IDLE;
            tmpRetVal = E_NOT_OK;
          }

#if (SSA_ECU_TYPE == SSA_ECU_TYPE_VSM)
# if (SSA_ENABLE_ASYNC_CSM_JOB_PROCESSING == STD_ON)
          /* In a synchronous configuration, pending return values within KeyM_Replace_Certificate_Verify_Ecu
           * are treated like errors. */
          else if (tmpRetVal == SSA_E_PENDING)
          {
            /* Remain in state and stop processing the for-loop. */
          }
# endif
          else
          {
            /* Change state to idle and stop processing the for-loop. */
            KeyM_DiagProc.replaceCertificatesReplaceBackendAndLowerState = KEYM_REPLACE_CERT_REPLACE_BACKEND_AND_LOWER_CERT_STATE_IDLE;
          }
#endif
          break;
        }
        default:
        {
          rVal = E_NOT_OK;
          *ErrorCode = DCM_E_GENERALREJECT;
          /* Stop processing the for-loop. */
          tmpRetVal = E_NOT_OK;
          break;
        }
      }
    }
    else
    {
      /* Leave for-loop, since tmpRetVal is pending or NOT_OK */
      break;
    }
  }
  return rVal;
} /* PRQA S  6030, 6050, 6080 */ /* MD_MSR_STCYC, MD_MSR_STCAL, MD_MSR_STMIF */

/**********************************************************************************************************************
 *  KeyM_Replace_Certificate_Replace_RootAndLower()
 **********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
SSA_KEYM_LOCAL_INLINE FUNC(Std_ReturnType, Ssa_KeyM_CODE) KeyM_Replace_Certificate_Replace_RootAndLower(
  P2CONST(Ssa_KeyM_CertChainDataType, AUTOMATIC, AUTOMATIC) cert,
  P2VAR(uint8, AUTOMATIC, AUTOMATIC) Verification_Result,
  P2VAR(Dcm_NegativeResponseCodeType, AUTOMATIC, AUTOMATIC) ErrorCode)
{
#if (SSA_ECU_TYPE == SSA_ECU_TYPE_VSM)
  /*@ assert cert->ecu != NULL_PTR; */
#endif

  Std_ReturnType rVal = E_NOT_OK;
  uint8 stateCounter = 0u;
  Std_ReturnType tmpRetVal = E_OK; /* Used for handling the while loop. */
  uint16 rootCertLength = SSA_SIZEOF_CERT_MAX;
#if (SSA_KEEP_BUFFER_VARIABLES_STATIC == STD_OFF)
  uint8 KeyM_RootCertBuf[SSA_SIZEOF_CERT_MAX];
  /* satisfy QAC: initialize */
  KeyM_RootCertBuf[0] = 0;
#endif

  /* #10 Execute the following steps and quit the function on any error or verification failure.
  * In case of an verification failure return the verification result from the called sub-function. */

  /* #15 Handle the following states:
   *     KEYM_REPLACE_CERT_REPLACE_ROOT_AND_LOWER_CERT_STATE_IDLE, (parse received Root Ca link certificate)
   *     KEYM_REPLACE_CERT_REPLACE_ROOT_AND_LOWER_CERT_STATE_VERIFY_ROOT_LINK_CERT,
   *     KEYM_REPLACE_CERT_REPLACE_ROOT_AND_LOWER_CERT_STATE_VERIFY_ROOT_CERT,
   *     KEYM_REPLACE_CERT_REPLACE_ROOT_AND_LOWER_CERT_STATE_VERIFY_BACKEND_CERT,
   *     KEYM_REPLACE_CERT_REPLACE_ROOT_AND_LOWER_CERT_STATE_ECU_CERT. */

  for (stateCounter = 0u; stateCounter < SSA_KEYM_REPLACE_CERT_REPLACE_ROOTANDLOWER_UPPER_BOUNDARY; stateCounter++)
  {
    if (tmpRetVal == E_OK)
    {
      switch (KeyM_DiagProc.replaceCertificatesReplaceRootAndLowerState)
      {
        case KEYM_REPLACE_CERT_REPLACE_ROOT_AND_LOWER_CERT_STATE_IDLE:
        {
          /* #20 Parse the received Root CA link certificate and get the old parsed root ca certificate. */
          /*@ assert cert->rootCaLink != NULL_PTR; */ /* VCA_SSA_KEYM_ROOTCAANDLINK_VALID_POINTER_BEFORE_REPLACEMENT */
          rVal = KeyM_ReplaceCertificates_ParseCertsForVerification(
            KEYM_REPLACE_CERT_REPLACE_ROOT_AND_LOWER_CERT_ID_ROOT_LINK_CERT,
            cert,
            &KeyM_DiagProc.ws.replaceCerts.receivedParsedBackendCaOrRootCaLinkCert,
            KeyM_RootCertBuf, /* certBuffer */
            &rootCertLength,
            &tmpRetVal,
            Verification_Result,
            ErrorCode);

          KeyM_ReplaceCertificates_StateHandling(tmpRetVal,
            KEYM_REPLACE_CERT_REPLACE_ROOT_AND_LOWER_CERT_STATE_IDLE,
            KEYM_REPLACE_CERT_REPLACE_ROOT_AND_LOWER_CERT_STATE_VERIFY_ROOT_LINK_CERT,
            &KeyM_DiagProc.replaceCertificatesReplaceRootAndLowerState);
          break;
        }

        case KEYM_REPLACE_CERT_REPLACE_ROOT_AND_LOWER_CERT_STATE_VERIFY_ROOT_LINK_CERT:
        {
          /* #30 Verify the received root ca link certificate against the old parsed root ca certificate. */
          /*@ assert cert->rootCaLink != NULL_PTR; */ /* VCA_SSA_KEYM_ROOTCAANDLINK_VALID_POINTER_BEFORE_REPLACEMENT */
          /*@ assert sizeof(cert->rootCaLink) >= sizeof(CertP_RawCertBufferType); */ /* VCA_SSA_KEYM_VALID_CERT_BUFFER_FOR_VERIFICATION */
          rVal = Rte_Call_CertP_Functions_Certificate_Verify(
            cert->rootCaLink, &KeyM_DiagProc.ws.replaceCerts.receivedParsedBackendCaOrRootCaLinkCert, KeyM_RootCertBuf, &KeyM_ParsedRootCert, CERTP_PKI_ROLE_ROOT_CA_LINK_CERT);
          tmpRetVal = KeyM_ReplaceCertificates_HandleCertificateVerificationResult(
            &rVal, KeyM_DiagProc.ws.replaceCerts.receivedParsedBackendCaOrRootCaLinkCert.verificationResult, KEYM_REPLACE_CERT_REPLACE_ROOT_AND_LOWER_CERT_ID_ROOT_LINK_CERT, Verification_Result, ErrorCode);

          if (tmpRetVal == E_OK)
          {
            /* Verification against Root CA certificate successful. */
            *Verification_Result = CERTP_VER_OK;
            /* Check and store if a development certificate is to be replaced. */
            KeyM_DiagProc.ws.replaceCerts.isDevelopCertReplaced = (KeyM_ParsedRootCert.prodQualifier == 0x00u) ? TRUE : FALSE;

            /* #35 Parse the received, new Root CA certificate. */
            /*@ assert cert->rootCa != NULL_PTR; */ /* VCA_SSA_KEYM_ROOTCAANDLINK_VALID_POINTER_BEFORE_REPLACEMENT */
            rVal = Rte_Call_CertP_Functions_Certificate_Parse(cert->rootCa, cert->rootCaLength, &KeyM_DiagProc.ws.replaceCerts.receivedParsedRootCaCert);
            tmpRetVal = KeyM_ReplaceCertificates_HandleParsingResult(
              &rVal, KeyM_DiagProc.ws.replaceCerts.receivedParsedRootCaCert.verificationResult, KEYM_REPLACE_CERT_REPLACE_ROOT_AND_LOWER_CERT_ID_ROOT_CERT, Verification_Result, ErrorCode);
          }

          KeyM_ReplaceCertificates_StateHandling(tmpRetVal,
            KEYM_REPLACE_CERT_REPLACE_ROOT_AND_LOWER_CERT_STATE_IDLE,
            KEYM_REPLACE_CERT_REPLACE_ROOT_AND_LOWER_CERT_STATE_VERIFY_ROOT_CERT,
            &KeyM_DiagProc.replaceCertificatesReplaceRootAndLowerState);
          break;
        }

        case KEYM_REPLACE_CERT_REPLACE_ROOT_AND_LOWER_CERT_STATE_VERIFY_ROOT_CERT:
        {
          /* #40 Verify the new Root CA Certificate against itself. */
          /*@ assert cert->rootCa != NULL_PTR; */ /* VCA_SSA_KEYM_ROOTCAANDLINK_VALID_POINTER_BEFORE_REPLACEMENT */
          /*@ assert sizeof(cert->rootCa) >= sizeof(CertP_RawCertBufferType); */ /* VCA_SSA_KEYM_VALID_CERT_BUFFER_FOR_VERIFICATION */
          rVal = Rte_Call_CertP_Functions_Certificate_Verify(
            cert->rootCa, &KeyM_DiagProc.ws.replaceCerts.receivedParsedRootCaCert, cert->rootCa, &KeyM_DiagProc.ws.replaceCerts.receivedParsedRootCaCert, CERTP_PKI_ROLE_ROOT);
          tmpRetVal = KeyM_ReplaceCertificates_HandleCertificateVerificationResult(
            &rVal, KeyM_DiagProc.ws.replaceCerts.receivedParsedRootCaCert.verificationResult, KEYM_REPLACE_CERT_REPLACE_ROOT_AND_LOWER_CERT_ID_ROOT_CERT, Verification_Result, ErrorCode);

          if (tmpRetVal == E_OK)
          {
            boolean isEqual = FALSE;
            /* Verification against new Root CA certificate successful. */
            *Verification_Result = CERTP_VER_OK;

            /* #60  Compare if the relevant contents of the Root CA Link Certificate are identical
             *      to the contents of the new Root CA Certificate, return verification result "invalid scope"
             *      if different. */

             /*@ assert cert->rootCaLink != NULL_PTR; */ /* VCA_SSA_KEYM_ROOTCAANDLINK_VALID_POINTER_BEFORE_REPLACEMENT */
             /*@ assert cert->rootCa != NULL_PTR; */ /* VCA_SSA_KEYM_ROOTCAANDLINK_VALID_POINTER_BEFORE_REPLACEMENT */
            rVal = Rte_Call_CertP_Functions_Certificate_Compare(
              cert->rootCaLink, &KeyM_DiagProc.ws.replaceCerts.receivedParsedBackendCaOrRootCaLinkCert, CERTP_PKI_ROLE_ROOT_CA_LINK_CERT,
              cert->rootCa, &KeyM_DiagProc.ws.replaceCerts.receivedParsedRootCaCert, CERTP_PKI_ROLE_ROOT, &isEqual);
            tmpRetVal = KeyM_ReplaceCertificates_HandleCertificateCompareResult(
              &rVal, isEqual, KEYM_REPLACE_CERT_REPLACE_ROOT_AND_LOWER_CERT_ID_ROOT_CERT, Verification_Result, ErrorCode);

            if (tmpRetVal == E_OK)
            {
              /* The relevant contents of the compared certificates are equal. */
              /* #70 Parse the received, new Backend CA certificate. */
              rVal = Rte_Call_CertP_Functions_Certificate_Parse(cert->backendCa, cert->backendCaLength, &KeyM_DiagProc.ws.replaceCerts.receivedParsedBackendCaCert);
              tmpRetVal = KeyM_ReplaceCertificates_HandleParsingResult(
                &rVal, KeyM_DiagProc.ws.replaceCerts.receivedParsedBackendCaCert.verificationResult, KEYM_REPLACE_CERT_REPLACE_ROOT_AND_LOWER_CERT_ID_BACKEND_CERT, Verification_Result, ErrorCode);
            }
          }

          KeyM_ReplaceCertificates_StateHandling(tmpRetVal,
            KEYM_REPLACE_CERT_REPLACE_ROOT_AND_LOWER_CERT_STATE_IDLE,
            KEYM_REPLACE_CERT_REPLACE_ROOT_AND_LOWER_CERT_STATE_VERIFY_BACKEND_CERT,
            &KeyM_DiagProc.replaceCertificatesReplaceRootAndLowerState);
          break;
        }

        /* #80 Verify the new Backend CA certificate against the Root CA certificate. */
        case KEYM_REPLACE_CERT_REPLACE_ROOT_AND_LOWER_CERT_STATE_VERIFY_BACKEND_CERT:
        {
          /*@ assert cert->backendCa != NULL_PTR; */ /* VCA_SSA_KEYM_ROOTCAANDLINK_VALID_POINTER_BEFORE_REPLACEMENT */
          /*@ assert cert->rootCa != NULL_PTR; */ /* VCA_SSA_KEYM_ROOTCAANDLINK_VALID_POINTER_BEFORE_REPLACEMENT */
          /*@ assert sizeof(cert->backendCa) >= sizeof(CertP_RawCertBufferType); */ /* VCA_SSA_KEYM_VALID_CERT_BUFFER_FOR_VERIFICATION */
          /*@ assert sizeof(cert->rootCa) >= sizeof(CertP_RawCertBufferType); */ /* VCA_SSA_KEYM_VALID_CERT_BUFFER_FOR_VERIFICATION */
          rVal = Rte_Call_CertP_Functions_Certificate_Verify(
            cert->backendCa, &KeyM_DiagProc.ws.replaceCerts.receivedParsedBackendCaCert, cert->rootCa, &KeyM_DiagProc.ws.replaceCerts.receivedParsedRootCaCert, CERTP_PKI_ROLE_BACKEND);
          tmpRetVal = KeyM_ReplaceCertificates_HandleCertificateVerificationResult(
            &rVal, KeyM_DiagProc.ws.replaceCerts.receivedParsedBackendCaCert.verificationResult, KEYM_REPLACE_CERT_REPLACE_ROOT_AND_LOWER_CERT_ID_BACKEND_CERT, Verification_Result, ErrorCode);

          if (tmpRetVal == E_OK)
          {
            /* Verification against new Root CA certificate successful. */
            *Verification_Result = CERTP_VER_OK;

            /* change state */
            KeyM_DiagProc.replaceCertificatesReplaceRootAndLowerState = KEYM_REPLACE_CERT_REPLACE_ROOT_AND_LOWER_CERT_STATE_ECU_CERT;
          }

          if (tmpRetVal == E_NOT_OK)
          {
            /* Change state to idle and leave while loop. */
            KeyM_DiagProc.replaceCertificatesReplaceRootAndLowerState = KEYM_REPLACE_CERT_REPLACE_ROOT_AND_LOWER_CERT_STATE_IDLE;
          }
          break;
        }

        /* #90 Execute all verifications around the ECU certificate. */
        case KEYM_REPLACE_CERT_REPLACE_ROOT_AND_LOWER_CERT_STATE_ECU_CERT:
        {
#if (SSA_ECU_TYPE == SSA_ECU_TYPE_VSM)
          /*@ assert cert->ecu != NULL_PTR; */ /* VCA_SSA_KEYM_ECU_CERT_VALID_POINTER_BEFORE_REPLACEMENT */
          /*@ assert cert->backendCa != NULL_PTR; */ /* VCA_SSA_KEYM_ROOTCAANDLINK_VALID_POINTER_BEFORE_REPLACEMENT */
          rVal = KeyM_Replace_Certificate_Verify_Ecu(
            cert, cert->backendCa, &KeyM_DiagProc.ws.replaceCerts.receivedParsedBackendCaCert, Verification_Result, ErrorCode);
          tmpRetVal = KeyM_ReplaceCertificates_HandleCertificateVerification_Ecu_Result(&rVal, Verification_Result, ErrorCode);

          if (tmpRetVal == E_OK)
#endif
          {
            /* #100 When all verifications are successfully finished replace Root CA Certificate, Backend CA Certificate and ECU Certificate. */
            /*@ assert cert->rootCa != NULL_PTR; */ /* VCA_SSA_KEYM_ROOTCAANDLINK_VALID_POINTER_BEFORE_REPLACEMENT */
            rVal = Rte_Call_SsaCdd_Keys_KeyElementSet(SSA_KEYM_CSM_KEY_DIAG_CHAIN_ROOT_CERT, SSA_KE_CERTIFICATE_DATA, cert->rootCa, cert->rootCaLength);
            rVal |= Rte_Call_SsaCdd_Keys_KeySetValid(SSA_KEYM_CSM_KEY_DIAG_CHAIN_ROOT_CERT);
            /* #110 If a development Root CA Certificate is replaced by a productive Root CA Certificate inform the
            * application about the replacement .*/
            if ((rVal == E_OK) && KeyM_DiagProc.ws.replaceCerts.isDevelopCertReplaced && (KeyM_DiagProc.ws.replaceCerts.receivedParsedRootCaCert.prodQualifier != 0x00u))
            {
              (void)Rte_Write_KeyM_ReplaceRootCertificate_isProductive(TRUE); /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */
            }

            /*@ assert cert->backendCa != NULL_PTR; */ /* VCA_SSA_KEYM_ROOTCAANDLINK_VALID_POINTER_BEFORE_REPLACEMENT */
            rVal |= Rte_Call_SsaCdd_Keys_KeyElementSet(SSA_KEYM_CSM_KEY_DIAG_CHAIN_BACKEND_CERT, SSA_KE_CERTIFICATE_DATA, cert->backendCa, cert->backendCaLength);
            rVal |= Rte_Call_SsaCdd_Keys_KeySetValid(SSA_KEYM_CSM_KEY_DIAG_CHAIN_BACKEND_CERT);
#if (SSA_ECU_TYPE == SSA_ECU_TYPE_VSM)
            /*@ assert cert->ecu != NULL_PTR; */ /* VCA_SSA_KEYM_ECU_CERT_VALID_POINTER_BEFORE_REPLACEMENT */
            rVal |= Rte_Call_SsaCdd_Keys_KeyElementSet(SSA_KEYM_CSM_KEY_DIAG_CHAIN_ECU_CERT, SSA_KE_CERTIFICATE_DATA, cert->ecu, cert->ecuLength);
            rVal |= Rte_Call_SsaCdd_Keys_KeySetValid(SSA_KEYM_CSM_KEY_DIAG_CHAIN_ECU_CERT);
#endif
            if (rVal != E_OK)
            {
              rVal = E_NOT_OK;
              *ErrorCode = DCM_E_GENERALREJECT;
              /* change state */
            }
            /* #115 Reset the verification results of stored certificates so that they will be parsed again when used next time. */
            else
            {
              KeyM_ParsedRootCert.verificationResult = CERTP_VER_NOT_PARSED;
              KeyM_ParsedBackendCert.verificationResult = CERTP_VER_NOT_PARSED;
#if (SSA_ECU_TYPE == SSA_ECU_TYPE_VSM)
              KeyM_ParsedEcuCert.verificationResult = CERTP_VER_NOT_PARSED;
#endif
              *Verification_Result = KEYM_VER_RES_CERT_VERIFIED_AND_REPLACED;
            }

            /* Change state to idle and leave while loop. */
            KeyM_DiagProc.replaceCertificatesReplaceRootAndLowerState = KEYM_REPLACE_CERT_REPLACE_ROOT_AND_LOWER_CERT_STATE_IDLE;
            tmpRetVal = E_NOT_OK;
          }

#if (SSA_ECU_TYPE == SSA_ECU_TYPE_VSM)
# if (SSA_ENABLE_ASYNC_CSM_JOB_PROCESSING == STD_ON)
          /* In a synchronous configuration, pending return values within KeyM_Replace_Certificate_Verify_Ecu
           * are treated like errors. */
          else if (tmpRetVal == SSA_E_PENDING)
          {
            /* Remain in state and leave while loop. */
          }
# endif
          else
          {
            /* Change state to idle and leave while loop. */
            KeyM_DiagProc.replaceCertificatesReplaceRootAndLowerState = KEYM_REPLACE_CERT_REPLACE_ROOT_AND_LOWER_CERT_STATE_IDLE;
          }
#endif
          break;
        }
        default:
        {
          rVal = E_NOT_OK;
          *ErrorCode = DCM_E_GENERALREJECT;
          /* Leave while loop. */
          tmpRetVal = E_NOT_OK;
          break;
        }
      }
    }
    else
    {
      /* leave for-loop */
      break;
    }
  }
  return rVal;
} /* PRQA S 6030, 6050, 6080 */ /* MD_MSR_STCYC, MD_MSR_STCAL, MD_MSR_STMIF */

/**********************************************************************************************************************
 *  KeyM_ReplaceCertificates_ParseCertsForVerification()
 **********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 */
SSA_KEYM_LOCAL_INLINE FUNC(Std_ReturnType, Ssa_KeyM_CODE) KeyM_ReplaceCertificates_ParseCertsForVerification(
  uint8 subjectCertIdentifier,
  P2CONST(Ssa_KeyM_CertChainDataType, AUTOMATIC, AUTOMATIC) certStructure,
  P2VAR(CertP_ParsedCertStructureType, AUTOMATIC, RTE_SSA_CERTP_APPL_VAR) subjectParsedCert,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) issuerCertBuffer,
  P2VAR(uint16, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) issuerCertBufferLength,
  P2VAR(Std_ReturnType, AUTOMATIC, AUTOMATIC) replacementAbortionFlag,
  P2VAR(uint8, AUTOMATIC, AUTOMATIC) Verification_Result,
  P2VAR(Dcm_NegativeResponseCodeType, AUTOMATIC, AUTOMATIC) ErrorCode)
{
  Std_ReturnType retVal;
  Std_ReturnType tmpRetVal; /* Used for handling the while loop. */

  P2CONST(uint8, AUTOMATIC, RTE_SSA_CERTP_APPL_DATA) subjectRawCertData;
  uint16 subjectRawCertLength;
  CertP_PkiRoleType issuerPkiRole;

  /* Prepare rawData and pki role depending on the certificate to be verified. */
  switch (subjectCertIdentifier)
  {
    case KEYM_REPLACE_CERT_REPLACE_BACKEND_AND_LOWER_CERT_ID_BACKEND_LINK_CERT:
      /*@ assert certStructure->backendCaLink != NULL_PTR; */ /* VCA_SSA_KEYM_NEW_CERT_POINTER_VALID */
      subjectRawCertData = certStructure->backendCaLink;
      subjectRawCertLength = certStructure->backendCaLinkLength;
      issuerPkiRole = CERTP_PKI_ROLE_BACKEND;
      break;
    case KEYM_REPLACE_CERT_REPLACE_BACKEND_AND_LOWER_CERT_ID_BACKEND_CERT:
      /*@ assert certStructure->backendCa != NULL_PTR; */ /* VCA_SSA_KEYM_NEW_CERT_POINTER_VALID */
      subjectRawCertData = certStructure->backendCa;
      subjectRawCertLength = certStructure->backendCaLength;
      issuerPkiRole = CERTP_PKI_ROLE_ROOT;
      break;
    case KEYM_REPLACE_CERT_REPLACE_ROOT_AND_LOWER_CERT_ID_ROOT_LINK_CERT:
      /* Fall through */
    default:
      /*@ assert certStructure->rootCaLink != NULL_PTR; */ /* VCA_SSA_KEYM_NEW_CERT_POINTER_VALID */
      subjectRawCertData = certStructure->rootCaLink;
      subjectRawCertLength = certStructure->rootCaLinkLength;
      issuerPkiRole = CERTP_PKI_ROLE_ROOT;
      break;
  }

  /* #10 Parse the received new certificate. */
  retVal = Rte_Call_CertP_Functions_Certificate_Parse(subjectRawCertData, subjectRawCertLength, subjectParsedCert);

  tmpRetVal = KeyM_ReplaceCertificates_HandleParsingResult(
    &retVal, subjectParsedCert->verificationResult, subjectCertIdentifier, Verification_Result, ErrorCode);

  if (tmpRetVal == E_OK)
  {
    /* #20 Get the old parsed certificate against which the new one shall be verified. */
    retVal = KeyM_GetAndParseStoredCert(issuerPkiRole, issuerCertBuffer, issuerCertBufferLength, FALSE);

    if (retVal != E_OK)
    {
      retVal = E_NOT_OK;
      *ErrorCode = DCM_E_GENERALREJECT;
      tmpRetVal = E_NOT_OK;
    }
  }

  *replacementAbortionFlag = tmpRetVal;

  return retVal;
} /* PRQA S 6060 */ /* MD_SSA_STPAR */

/**********************************************************************************************************************
 *  KeyM_ReplaceCertificates_HandleParsingResult()
 **********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 */
SSA_KEYM_LOCAL FUNC(Std_ReturnType, Ssa_KeyM_CODE) KeyM_ReplaceCertificates_HandleParsingResult(
  P2VAR(Std_ReturnType, AUTOMATIC, AUTOMATIC) rVal,
  uint8 verResToBeChecked,
  uint8 parsedCertId,
  P2VAR(uint8, AUTOMATIC, AUTOMATIC) Verification_Result,
  P2VAR(Dcm_NegativeResponseCodeType, AUTOMATIC, AUTOMATIC) ErrorCode)
{
  Std_ReturnType retVal = E_NOT_OK;

  /* Check and handle return value and verification result. */
  if (*rVal != E_OK)
  {
    /* Check and handle return value. */
    *rVal = E_NOT_OK;
    *ErrorCode = DCM_E_GENERALREJECT;
  }
  else if (verResToBeChecked != CERTP_VER_PARSE_OK)
  {
    /* Check and handle verification result */

    /* No negative return. */
    /* The mapping function for the verification result is certificate-specific. */
    switch (parsedCertId)
    {
      case KEYM_REPLACE_CERT_REPLACE_BACKEND_AND_LOWER_CERT_ID_BACKEND_LINK_CERT:
        /* Fall through */
      case KEYM_REPLACE_CERT_REPLACE_ROOT_AND_LOWER_CERT_ID_ROOT_LINK_CERT:
        *Verification_Result = Map_VerRes_Link(CERTP_VER_INVALID_FORMAT);
        break;
      case KEYM_REPLACE_CERT_REPLACE_BACKEND_AND_LOWER_CERT_ID_BACKEND_CERT:
        /* Fall through */
      case KEYM_REPLACE_CERT_REPLACE_ROOT_AND_LOWER_CERT_ID_BACKEND_CERT:
        *Verification_Result = Map_VerRes_Backend(CERTP_VER_INVALID_FORMAT);
        break;
      case KEYM_REPLACE_CERT_REPLACE_ROOT_AND_LOWER_CERT_ID_ROOT_CERT:
        *Verification_Result = Map_VerRes_Root(CERTP_VER_INVALID_FORMAT);
        break;
      case KEYM_REPLACE_CERT_VERIFY_ECU_ECU_CERT:
        *Verification_Result = Map_VerRes_Ecu(CERTP_VER_INVALID_FORMAT);
        break;
      default:
        *rVal = E_NOT_OK;
        *ErrorCode = DCM_E_GENERALREJECT;
        break;
    }
  }
  else
  {
    /* No error during parsing. */
    retVal = E_OK;
  }

  return retVal;
}

/**********************************************************************************************************************
 *  KeyM_ReplaceCertificates_HandleCertificateCompareResult()
 **********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 */
SSA_KEYM_LOCAL FUNC(Std_ReturnType, Ssa_KeyM_CODE) KeyM_ReplaceCertificates_HandleCertificateCompareResult(
  P2VAR(Std_ReturnType, AUTOMATIC, AUTOMATIC) rVal,
  boolean isEqual,
  uint8 newCertId,
  P2VAR(uint8, AUTOMATIC, AUTOMATIC) Verification_Result,
  P2VAR(Dcm_NegativeResponseCodeType, AUTOMATIC, AUTOMATIC) ErrorCode)
{
  Std_ReturnType retVal = E_NOT_OK;

  if (*rVal != E_OK)
  {
    /* Check and handle return value. */
    *rVal = E_NOT_OK;
    *ErrorCode = DCM_E_GENERALREJECT;
  }
  else if (!isEqual)
  {
    /* Check and handle comparison result. */
    /* The mapping function for the verification result is certificate-specific. */
    switch (newCertId)
    {
      case KEYM_REPLACE_CERT_REPLACE_BACKEND_AND_LOWER_CERT_ID_BACKEND_CERT:
        /* Set the verification result "invalid scope". */
        *Verification_Result = Map_VerRes_Backend(CERTP_VER_INVALID_SCOPE);
        break;
      case KEYM_REPLACE_CERT_REPLACE_ROOT_AND_LOWER_CERT_ID_ROOT_CERT:
        /* Set the verification result "invalid scope". */
        *Verification_Result = Map_VerRes_Root(CERTP_VER_INVALID_SCOPE);
        break;
      case KEYM_REPLACE_CERT_VERIFY_ECU_ECU_CERT:
        /* Set verification result indicating "Invalid Content". */
        *Verification_Result = Map_VerRes_Ecu(CERTP_VER_INVALID_CONTENT);
        break;
      default:
        *rVal = E_NOT_OK;
        *ErrorCode = DCM_E_GENERALREJECT;
        break;
    }
    /* No negative return. */
  }
  else
  {
    retVal = E_OK;
  }

  return retVal;
}

/**********************************************************************************************************************
 *  KeyM_ReplaceCertificates_HandleCertificateVerificationResult()
 **********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 */
SSA_KEYM_LOCAL FUNC(Std_ReturnType, Ssa_KeyM_CODE) KeyM_ReplaceCertificates_HandleCertificateVerificationResult(
  P2VAR(Std_ReturnType, AUTOMATIC, AUTOMATIC) rVal,
  uint8 verResToBeChecked,
  uint8 verifiedCertId,
  P2VAR(uint8, AUTOMATIC, AUTOMATIC) Verification_Result,
  P2VAR(Dcm_NegativeResponseCodeType, AUTOMATIC, AUTOMATIC) ErrorCode)
{
  Std_ReturnType retVal = E_NOT_OK;

  if (*rVal == RTE_E_CertP_Functions_E_PENDING)
  {
    /* remain in state */
    *rVal = SSA_E_PENDING;
    retVal = SSA_E_PENDING;
  }
  else if (*rVal != E_OK)
  {
    *rVal = E_NOT_OK;
    *ErrorCode = DCM_E_GENERALREJECT;
  }
  else if (verResToBeChecked != CERTP_VER_OK)
  {
    /* No negative return. */
    /* Return the verification result from certificate verification. */
    /* The mapping function for the verification result is certificate-specific. */
    switch (verifiedCertId)
    {
      case KEYM_REPLACE_CERT_REPLACE_BACKEND_AND_LOWER_CERT_ID_BACKEND_CERT:
        /* Fall through */
      case KEYM_REPLACE_CERT_REPLACE_ROOT_AND_LOWER_CERT_ID_BACKEND_CERT:
        *Verification_Result = Map_VerRes_Backend(verResToBeChecked);
        break;
      case KEYM_REPLACE_CERT_REPLACE_BACKEND_AND_LOWER_CERT_ID_BACKEND_LINK_CERT:
        /* Fall through */
      case KEYM_REPLACE_CERT_REPLACE_ROOT_AND_LOWER_CERT_ID_ROOT_LINK_CERT:
        *Verification_Result = Map_VerRes_Link(verResToBeChecked);
        break;
      case KEYM_REPLACE_CERT_REPLACE_ROOT_AND_LOWER_CERT_ID_ROOT_CERT:
        *Verification_Result = Map_VerRes_Root(verResToBeChecked);
        break;
      case KEYM_REPLACE_CERT_VERIFY_ECU_ECU_CERT:
        *Verification_Result = Map_VerRes_Ecu(verResToBeChecked);
        break;
      default:
        *rVal = E_NOT_OK;
        *ErrorCode = DCM_E_GENERALREJECT;
        break;
    }
  }
  else
  {
    retVal = E_OK;
  }

  return retVal;
}

#if (SSA_ECU_TYPE == SSA_ECU_TYPE_VSM)
/**********************************************************************************************************************
 *  KeyM_ReplaceCertificates_HandleCertificateVerification_Ecu_Result()
 **********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 */
SSA_KEYM_LOCAL FUNC(Std_ReturnType, Ssa_KeyM_CODE) KeyM_ReplaceCertificates_HandleCertificateVerification_Ecu_Result(
  P2VAR(Std_ReturnType, AUTOMATIC, AUTOMATIC) rVal,
  P2CONST(uint8, AUTOMATIC, AUTOMATIC) Verification_Result,
  P2VAR(Dcm_NegativeResponseCodeType, AUTOMATIC, AUTOMATIC) ErrorCode)
{
  Std_ReturnType retVal = E_NOT_OK;

  if (*rVal == SSA_E_PENDING)
  {
    /* remain in state */
    retVal = SSA_E_PENDING;
  }
  else if (*rVal != E_OK)
  {
    *rVal = E_NOT_OK;
    *ErrorCode = DCM_E_GENERALREJECT;
  }
  else if (*Verification_Result != CERTP_VER_OK)
  {
    /* No negative return. */
    /* Return the verification result from certificate verification. */
  }
  else
  {
    retVal = E_OK;
  }

  return retVal;
}
#endif

/**********************************************************************************************************************
 *  KeyM_ReplaceCertificates_StateHandling()
 **********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
SSA_KEYM_LOCAL FUNC(void, Ssa_KeyM_CODE) KeyM_ReplaceCertificates_StateHandling(
  Std_ReturnType retVal,
  uint8 idleState,
  uint8 nextState,
  P2VAR(uint8, AUTOMATIC, AUTOMATIC) state)
{
  if (retVal == E_OK)
  {
    /* Proceed state. */
    *state = nextState;
  }
  else if (retVal == SSA_E_PENDING)
  {
    /* Remain in state. */
  }
  else
  {
    /* Change state to idle. */
    *state = idleState;
  }
}

/**********************************************************************************************************************
 *  KeyM_CsmRandomGenerate()
 **********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
SSA_KEYM_LOCAL FUNC(Std_ReturnType, Ssa_KeyM_CODE) KeyM_CsmRandomGenerate(
  uint32 resultBufferLength,
  P2VAR(uint8, AUTOMATIC, AUTOMATIC) resultBuffer)
{
  Std_ReturnType retVal;
  boolean jobIsAsync;
#if (SSA_ENABLE_ASYNC_CSM_JOB_PROCESSING == STD_ON)
  jobIsAsync = TRUE;
  retVal = Ssa_AsyncPreAction(&KeyM_RandomGenerateAsyncState, jobIsAsync);
  if (retVal == E_OK)
#else
  jobIsAsync = FALSE;
#endif
  {
    KeyM_RandomGenerateResultLength = resultBufferLength;
    retVal = Rte_Call_CsmRandomGenerate_RandomGenerate(resultBuffer, &KeyM_RandomGenerateResultLength);
    Ssa_AsyncPostAction(&KeyM_RandomGenerateAsyncState, retVal, jobIsAsync);
  }

  retVal = Ssa_AsyncFinalize(&KeyM_RandomGenerateAsyncState, jobIsAsync);

  if (retVal == E_OK)
  {
    retVal = (Std_ReturnType)((KeyM_RandomGenerateResultLength == resultBufferLength) ? E_OK : E_NOT_OK);
  }

  return retVal;
}

#if (SSA_ECU_TYPE == SSA_ECU_TYPE_VSM)
/**********************************************************************************************************************
 *  KeyM_CarSpecificSecretDistribution_Encrypt()
 **********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 */
SSA_KEYM_LOCAL_INLINE FUNC(Std_ReturnType, Ssa_KeyM_CODE) KeyM_CarSpecificSecretDistribution_Encrypt(
  P2VAR(uint8, AUTOMATIC, AUTOMATIC) dataBuffer,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) Encrypted_Nonce_and_Shared_Secret)
{
  Std_ReturnType retVal;
  uint32 encryptedNonceAndSecretLength = SSA_SIZEOF_ENCRYPTED_NONCE_AND_SECRET;

  /* #20 Encrypt the concatenation of the nonce and the car-specific secret. */
  Ssa_MemCpy(
    (P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR))&dataBuffer[SSA_KEYM_DIS_POSITION_ENCRYPTED_NONCE_AND_SECRET],
    (P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA))KeyM_DiagProc.ws.trustModelCommissioning.KeyM_SharedSecretEncDec_Nonce,
    SSA_SIZEOF_NONCE);
  retVal = Rte_Call_CsmSymAES128Encrypt_Encrypt(&dataBuffer[SSA_KEYM_DIS_POSITION_ENCRYPTED_NONCE_AND_SECRET], SSA_SIZEOF_NONCE + SSA_SIZEOF_SECRET, Encrypted_Nonce_and_Shared_Secret, &encryptedNonceAndSecretLength);
  if ((retVal != E_OK) || (encryptedNonceAndSecretLength != SSA_SIZEOF_ENCRYPTED_NONCE_AND_SECRET))
  {
    retVal = E_NOT_OK;
  }
  else
  {
    /* #30 Copy the encrypted data into the temporary data buffer as preparation for the signature generation. */
    /* signedData = Nonce | Date_and_Time_Offset | TickCount| TickCount_Offset | Encrypted_Nonce_and_Secret */
    Ssa_MemCpy((P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR))&dataBuffer[SSA_KEYM_DIS_POSITION_ENCRYPTED_NONCE_AND_SECRET], Encrypted_Nonce_and_Shared_Secret, SSA_SIZEOF_ENCRYPTED_NONCE_AND_SECRET);
  }

  return retVal;
} /* PRQA S 6060 */ /* MD_SSA_STPAR */

/**********************************************************************************************************************
 *  KeyM_CarSpecificSecretDistribution_AppendVsmCert()
 **********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 */
SSA_KEYM_LOCAL_INLINE FUNC(boolean, Ssa_KeyM_CODE) KeyM_CarSpecificSecretDistribution_AppendVsmCert(
  uint8 chainOfTrust,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) VSM_s_ECU_Certificate,
  P2VAR(uint16, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) DataLength,
  P2VAR(Dcm_NegativeResponseCodeType, AUTOMATIC, AUTOMATIC) ErrorCode)
{
  /*@ assert *DataLength == 0u; */
  boolean funcFinished = FALSE;

  if ((chainOfTrust == SSA_TRUST_MODEL_LIVE_KEY_PAIR) || (chainOfTrust == SSA_TRUST_MODEL_CSR_KEY_PAIR))
  {
    uint16 dataIdx = 0u;
    uint16 dataLength = sizeof(Dcm_Data3006ByteType);
    Std_ReturnType retVal;

    /* append all required certificates: ECU, Intermediate, Backend */
    retVal = KeyM_KeyM_GetCertificateDataAsIteration(SSA_TRUST_MODEL_ECU_CERT_ID, &VSM_s_ECU_Certificate[dataIdx], &dataLength);
    if (retVal == E_OK)
    {
      dataIdx = dataLength;
      dataLength = (uint16)((uint16)sizeof(Dcm_Data3006ByteType) - (uint16)dataIdx);
      retVal = KeyM_KeyM_GetCertificateDataAsIteration(SSA_TRUST_MODEL_INTERMEDIATE_CERT_ID, &VSM_s_ECU_Certificate[dataIdx], &dataLength);
    }

    if (retVal == E_OK)
    {
      dataIdx += dataLength;
      dataLength = (uint16)((uint16)sizeof(Dcm_Data3006ByteType) - (uint16)dataIdx);
      retVal = KeyM_KeyM_GetCertificateDataAsIteration(SSA_TRUST_MODEL_BACKEND_CERT_ID, &VSM_s_ECU_Certificate[dataIdx], &dataLength);
    }

    if (retVal == E_OK)
    {
      *DataLength = dataIdx + dataLength;
    }
    else
    {
      funcFinished = TRUE;
      *ErrorCode = DCM_E_GENERALREJECT;
    }
  }
  else
  {
    uint16 certLength = SSA_SIZEOF_CERT_MAX;
    /* #10 Get the stored VSM's ECU certificate and copy it to the output buffer. */
    /*@ assert $lengthOf(VSM_s_ECU_Certificate) >= sizeof(Dcm_Data1002ByteType); */
    if (KeyM_GetAndParseStoredCert(CERTP_PKI_ROLE_ECU, &(VSM_s_ECU_Certificate[*DataLength + 2u]), (P2VAR(uint16, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR))&certLength, FALSE) != E_OK)
    {
      funcFinished = TRUE;
      *ErrorCode = DCM_E_GENERALREJECT;
    }
    else
    {
      /* #20 Write the length of the appended certificate in the two, preceding bytes. */
      VSM_s_ECU_Certificate[*DataLength] = KeyM_GetUint16HiByte(certLength);
      VSM_s_ECU_Certificate[*DataLength + 1u] = KeyM_GetUint16LoByte(certLength);
      *DataLength += (certLength + 2u);
    }
  }

  return funcFinished;
}

/**********************************************************************************************************************
 *  KeyM_EncryptSharedSecret()
 **********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
SSA_KEYM_LOCAL FUNC(Std_ReturnType, Ssa_KeyM_CODE) KeyM_EncryptSharedSecret(
  uint8 chainOfTrust,
  P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) Nonce,
  P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) Ephemeral_ECU_Public_Key,
  P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) Data_Signature_In,
  P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) Target_ECU_Certificate,
  Dcm_OpStatusType OpStatus,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) routineInfo,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) Verification_Result,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) Date_and_Time,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) Tick_Count,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) Tick_Count_Offset,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) Encrypted_Nonce_and_Shared_Secret,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) Ephemeral_VSM_Public_Key,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) Data_Signature_Out,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) VSM_s_ECU_Certificate,
  P2VAR(uint16, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) DataLength,
  P2VAR(Dcm_NegativeResponseCodeType, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) ErrorCode,
  boolean allowStandardSecret) /* PRQA S 0850 */ /* MD_MSR_MacroArgumentEmpty */
{
  Std_ReturnType retVal = E_NOT_OK;
  Dcm_NegativeResponseCodeType errorCode = DCM_E_POSITIVERESPONSE;

  /* #10 Generate, if required, a new car-specific secret and the SecOC keys, then encrypt the car-specific secret
   *     and gather the needed time information.
   *     Go to idle state if service is canceled by DCM.
   *     Proceed only if state is valid. */

  if (OpStatus == DCM_CANCEL)
  {
    /* back to idle state */
    KeyM_DiagProc.state = KEYM_ENCRYPTSHAREDSECRET_STATE_IDLE;
    retVal = RTE_E_OK;
    /* use default verification result */
  }
  else if (!KeyM_IsEncryptSharedSecretStateValid())
  {
    /* back to idle state */
    KeyM_DiagProc.state = KEYM_ENCRYPTSHAREDSECRET_STATE_IDLE;
    errorCode = DCM_E_GENERALREJECT;
  }
  /* #15 Check whether Trust Model chain of trust has already been injected. */
  else if (*Rte_Pim_KeyMTrustModelChainOfTrustState() == SSA_TRUSTMODELCHAINSTATE_INITIAL)
  {
    /* back to idle state */
    KeyM_DiagProc.state = KEYM_ENCRYPTSHAREDSECRET_STATE_IDLE;
    errorCode = DCM_E_CONDITIONSNOTCORRECT;
  }
  else
  {
    /* #20 Handle the following states:
     *     KEYM_ENCRYPTSHAREDSECRET_STATE_IDLE,
     *     KEYM_ENCRYPTSHAREDSECRET_STATE_VERIFY_ECU_CERTIFICATE,
     *     KEYM_ENCRYPTSHAREDSECRET_STATE_VERIFY_SIGNATURE,
     *     KEYM_ENCRYPTSHAREDSECRET_STATE_GEN_CAR_SPEC_SECRET,
     *     KEYM_ENCRYPTSHAREDSECRET_STATE_DERIVE_SECOC_KEYS,
     *     KEYM_ENCRYPTSHAREDSECRET_STATE_WAIT,
     *     KEYM_ENCRYPTSHAREDSECRET_STATE_KEYEXCHANGE_ENCRYPT_GET_TIME,
     *     KEYM_ENCRYPTSHAREDSECRET_STATE_GEN_SIGNATURE. */

    retVal = KeyM_Shared_Secret_Encryption_State_Handler[KeyM_DiagProc.state](
      chainOfTrust,
      Nonce,
      Ephemeral_ECU_Public_Key,
      Data_Signature_In,
      Target_ECU_Certificate,
      OpStatus,
      routineInfo,
      &KeyM_DiagProc.ws.trustModelCommissioning.verificationResult,
      Date_and_Time,
      Tick_Count,
      Tick_Count_Offset,
      Encrypted_Nonce_and_Shared_Secret,
      Ephemeral_VSM_Public_Key,
      Data_Signature_Out,
      VSM_s_ECU_Certificate,
      DataLength,
      &errorCode,
      allowStandardSecret);
  }

  /* #30 Set verification result and error code depending on the return value. */
  if (retVal != SSA_E_PENDING)
  {
    /* Clear temporary buffer in any case. */
    KeyM_ClearDataBuffer(KeyM_DiagProc.ws.trustModelCommissioning.KeyM_SharedSecretEncDec_DataBuffer, SSA_KEYM_DIS_BUFFER_SIZE, SSA_KEYM_DIS_BUFFER_SIZE);

    *routineInfo = SSA_ROUTINE_INFO_SUCCESFULLY_COMPLETED;
    /* check for positive or negative response and set either verification result or NRC */
    if (retVal == E_OK)
    {
      *Verification_Result = KeyM_DiagProc.ws.trustModelCommissioning.verificationResult;
      *DataLength = KeyM_DiagProc.ws.trustModelCommissioning.KeyM_RoutineCtrlDataLengthOut;
      /* #40 If the service is finished write the security log for event
       *     "successful diagnostic service execution" for use case "SecOC ECU Shared Secret Distribution" */
      if (chainOfTrust == SSA_DIAGNOSTIC_KEY_PAIR)
      {
        /* Since the logging event for the routine SecOC_ECU_TickCount_Synchronization is missing in the specification,
         * this event is also logged as EcuSharedSecretEncryption here. */
        (void)Rte_Call_SecLog_SuccessfulDiagServiceExecutionEvent_EcuSharedSecretEncryption_SuccessfulDiagServiceExecution(*Verification_Result);
      }
      else if (allowStandardSecret)
      {
        (void)Rte_Call_SecLog_SuccessfulDiagServiceExecutionEvent_TrustModelEcuTickcountSynchronization_SuccessfulDiagServiceExecution(*Verification_Result);
      }
      else
      {
        (void)Rte_Call_SecLog_SuccessfulDiagServiceExecutionEvent_TrustModelEcuSharedSecretEncryption_SuccessfulDiagServiceExecution(*Verification_Result);
      }

      if (KeyM_DiagProc.ws.trustModelCommissioning.verificationResult != SSA_VER_RES_TRUST_MODEL_SECOC_CSS_ENCRYPT_CERTIFICATE_VERIFIED_SECOC_KEY_CALCULATED)
      {
        /* Append empty certificate (i.e. just 2 size bytes) if response is positive but verification result is negative. */
        VSM_s_ECU_Certificate[0] = 0u;
        VSM_s_ECU_Certificate[1] = 0u;
        *DataLength += 2u;
      }
    }
    else
    {
      *ErrorCode = errorCode;
    }
  }

  return retVal;
} /* PRQA S 6010, 6030, 6050, 6060, 6080 4 */ /* MD_MSR_STPTH, MD_MSR_STCYC, MD_MSR_STCAL, MD_SSA_STPAR, MD_MSR_STMIF */

#else

/**********************************************************************************************************************
 *  KeyM_CarSpecificSecretDistribution_Decrypt()
 **********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 */
SSA_KEYM_LOCAL_INLINE FUNC(boolean, Ssa_KeyM_CODE) KeyM_CarSpecificSecretDistribution_Decrypt(
  P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) Encrypted_Nonce_and_Shared_Secret,
  P2VAR(uint8, AUTOMATIC, AUTOMATIC) dataBuffer,
  P2VAR(uint8, AUTOMATIC, AUTOMATIC) Verification_Result,
  P2VAR(Dcm_NegativeResponseCodeType, AUTOMATIC, AUTOMATIC) ErrorCode)
{
  Std_ReturnType retVal;
  boolean funcFinished = FALSE;

  uint32 resultLength = SSA_SIZEOF_ENCRYPTED_NONCE_AND_SECRET;
  /* #10 Decrypt encrypted nonce and car-specific secret. */
  retVal = Rte_Call_CsmSymAES128Decrypt_Decrypt(Encrypted_Nonce_and_Shared_Secret, SSA_SIZEOF_ENCRYPTED_NONCE_AND_SECRET, &dataBuffer[SSA_KEYM_DIS_POSITION_ENCRYPTED_NONCE_AND_SECRET], &resultLength);
  if (retVal == RTE_E_UNCONNECTED)
  {
    funcFinished = TRUE;
    *ErrorCode = DCM_E_GENERALREJECT;
  }
  else if ((retVal != E_OK) || (resultLength < (SSA_SIZEOF_NONCE + SSA_SIZEOF_SECRET)))
  {
    funcFinished = TRUE;
    *Verification_Result = SSA_VER_RES_TRUST_MODEL_SECOC_CSS_DISTRIB_INVALID_ENCR_NONCE_OR_SHARED_SECRET;
  }
  /* #20 Verify if the decrypted nonce is valid by comparing it with the one passed to this function. */
  else if (!KeyM_CompareData(
    KeyM_DiagProc.ws.trustModelCommissioning.KeyM_SharedSecretEncDec_Nonce,
    &dataBuffer[SSA_KEYM_DIS_POSITION_ENCRYPTED_NONCE_AND_SECRET],
    SSA_SIZEOF_NONCE))
  {
    funcFinished = TRUE;
    *Verification_Result = SSA_VER_RES_TRUST_MODEL_SECOC_CSS_DISTRIB_INVALID_ENCR_NONCE_OR_SHARED_SECRET;
  }
  else
  {
    /* Ok. Go on.*/
    *Verification_Result = SSA_VER_RES_TRUST_MODEL_SECOC_CSS_DISTRIB_CERTIFICATE_VERIFIED_SECOC_KEY_CALCULATED;
  }

  return funcFinished;
}

#endif

/**********************************************************************************************************************
 *  KeyM_CsmSignatureGenerate()
 **********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 */
SSA_KEYM_LOCAL FUNC(Std_ReturnType, Ssa_KeyM_CODE) KeyM_CsmSignatureGenerate(
    uint8 chainOfTrust,
    P2CONST(uint8, AUTOMATIC, RTE_SSA_RIGHTSM_APPL_DATA) dataIn,
    uint16 dataInLength,
    P2VAR(uint8, AUTOMATIC, RTE_SSA_RIGHTSM_APPL_VAR) signatureOut)
{
  Std_ReturnType retVal;
  boolean jobIsAsync;
#if (SSA_KEEP_BUFFER_VARIABLES_STATIC == STD_OFF)
  uint32 KeyM_SignatureOutLength = 0;
#endif
#if (SSA_ENABLE_ASYNC_CSM_JOB_PROCESSING == STD_ON)
  jobIsAsync = TRUE;
  retVal = Ssa_AsyncPreAction(&KeyM_SigGenAsyncState, jobIsAsync);
  if (retVal == E_OK)
#else
  jobIsAsync = FALSE;
#endif
  {
    KeyM_SignatureOutLength = SSA_SIZEOF_SIGNATURE;

    if ((chainOfTrust == SSA_TRUST_MODEL_CSR_KEY_PAIR) ||
        (chainOfTrust == SSA_TRUST_MODEL_LIVE_PUBLIC_KEY_AND_CSR_PRIVATE_KEY))
    {
      retVal = Rte_Call_SsaCdd_Csm_SignatureGenerate(SSA_KEYM_TRUST_MODEL_ECU_CSR_SIGNATURE_GENERATE_JOB_ID, CRYPTO_OPERATIONMODE_SINGLECALL,
          dataIn, (uint32)dataInLength, signatureOut, &KeyM_SignatureOutLength);
    }
#if (SSA_ECU_TYPE == SSA_ECU_TYPE_VSM)
    else if (chainOfTrust == SSA_DIAGNOSTIC_KEY_PAIR)
    {
      retVal = Rte_Call_SsaCdd_Csm_SignatureGenerate(SSA_KEYM_ECU_SIGNATURE_GENERATE_JOB_ID, CRYPTO_OPERATIONMODE_SINGLECALL,
          dataIn, (uint32)dataInLength, signatureOut, &KeyM_SignatureOutLength);
    }
#endif
    else if ((chainOfTrust == SSA_TRUST_MODEL_LIVE_KEY_PAIR) && (*Rte_Pim_KeyMTrustModelChainOfTrustState() != SSA_TRUSTMODELCHAINSTATE_INITIAL))
    {
      /*@ assert $lengthOf(signatureOut) >= SSA_SIZEOF_SIGNATURE; */
      /*@ assert $lengthOf(signatureOut) >= KeyM_SignatureOutLength; */
      retVal = Rte_Call_SsaCdd_Csm_SignatureGenerate(SSA_KEYM_TRUST_MODEL_ECU_LIVE_SIGNATURE_GENERATE_JOB_ID, CRYPTO_OPERATIONMODE_SINGLECALL,
        dataIn, (uint32)dataInLength, signatureOut, &KeyM_SignatureOutLength);
    }
    else
    {
      retVal = E_NOT_OK;
    }

    Ssa_AsyncPostAction(&KeyM_SigGenAsyncState, retVal, jobIsAsync);
  }

  retVal = Ssa_AsyncFinalize(&KeyM_SigGenAsyncState, jobIsAsync);

  if (retVal == E_OK)
  {
    retVal = (uint8)((KeyM_SignatureOutLength == SSA_SIZEOF_SIGNATURE) ? E_OK : E_NOT_OK);
  }

  return retVal;
}

/**********************************************************************************************************************
 *  KeyM_CsmSignatureVerify()
 **********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
SSA_KEYM_LOCAL FUNC(Std_ReturnType, Ssa_KeyM_CODE) KeyM_CsmSignatureVerify(
    uint8 chainOfTrust,
    P2CONST(uint8, AUTOMATIC, RTE_SSA_RIGHTSM_APPL_DATA) dataIn,
    uint32 dataInLength,
    P2CONST(uint8, AUTOMATIC, RTE_SSA_RIGHTSM_APPL_DATA) signatureIn,
    P2VAR(Crypto_VerifyResultType, AUTOMATIC, AUTOMATIC) csmVerifyResult)
{
  Std_ReturnType retVal;
  boolean jobIsAsync;
#if (SSA_KEEP_BUFFER_VARIABLES_STATIC == STD_OFF)
  Crypto_VerifyResultType KeyM_CsmVerificationResult = CRYPTO_E_VER_NOT_OK;
#endif
#if (SSA_ENABLE_ASYNC_CSM_JOB_PROCESSING == STD_ON)
  jobIsAsync = TRUE;
  retVal = Ssa_AsyncPreAction(&KeyM_SigVerifAsyncState, jobIsAsync);
  if (retVal == E_OK)
#else
  jobIsAsync = FALSE;
#endif
  {
    if (chainOfTrust == SSA_DIAGNOSTIC_KEY_PAIR)
    {
      retVal = Rte_Call_SsaCdd_Csm_SignatureVerify(SSA_KEYM_SIGNATURE_VERIFY_JOB_ID, CRYPTO_OPERATIONMODE_SINGLECALL,
          dataIn, dataInLength, signatureIn, SSA_SIZEOF_SIGNATURE, &KeyM_CsmVerificationResult);
    }
    else
#if ((SSA_ECU_TYPE != SSA_ECU_TYPE_VSM) && (SSA_DIAG_SERVICE_INJECT_SEED == STD_ON))
    if (chainOfTrust == SSA_TRUST_MODEL_LIVE_BACKEND_PUBLIC_KEY)
    {
      retVal = Rte_Call_SsaCdd_Csm_SignatureVerify(SSA_KEYM_TRUST_MODEL_BACKEND_SIGNATURE_VERIFY_JOB_ID, CRYPTO_OPERATIONMODE_SINGLECALL,
          dataIn, dataInLength, signatureIn, SSA_SIZEOF_SIGNATURE, &KeyM_CsmVerificationResult);
    }
    else
#endif
    if ((chainOfTrust == SSA_TRUST_MODEL_LIVE_KEY_PAIR)
      || (chainOfTrust == SSA_TRUST_MODEL_CSR_KEY_PAIR)
      || (chainOfTrust == SSA_TRUST_MODEL_LIVE_PUBLIC_KEY_AND_CSR_PRIVATE_KEY))
    {
      retVal = Rte_Call_SsaCdd_Csm_SignatureVerify(SSA_KEYM_TRUST_MODEL_TEMP_SIGNATURE_VERIFY_JOB_ID, CRYPTO_OPERATIONMODE_SINGLECALL,
          dataIn, dataInLength, signatureIn, SSA_SIZEOF_SIGNATURE, &KeyM_CsmVerificationResult);
    }
    else
    {
      retVal = E_NOT_OK;
    }

    Ssa_AsyncPostAction(&KeyM_SigVerifAsyncState, retVal, jobIsAsync);
  }

  retVal = Ssa_AsyncFinalize(&KeyM_SigVerifAsyncState, jobIsAsync);
  if (retVal == E_OK)
  {
    *csmVerifyResult = KeyM_CsmVerificationResult;
  }

  return retVal;
}

/**********************************************************************************************************************
 *  KeyM_CsmKeyExchangeCalcPubVal()
 **********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
SSA_KEYM_LOCAL FUNC(Std_ReturnType, Ssa_KeyM_CODE) KeyM_CsmKeyExchangeCalcPubVal(
  P2VAR(uint8, AUTOMATIC, RTE_SSA_RIGHTSM_APPL_VAR) keyExchangePubVal)
{
  Std_ReturnType retVal;
  boolean operationIsAsync;
#if (SSA_ENABLE_ASYNC_CSM_KEYM_ANAGEMENT_PRIMITIVES == STD_ON)
  operationIsAsync = TRUE;
  retVal = Ssa_AsyncPreAction(&KeyM_CalcPubValAsyncState, operationIsAsync);
  if (retVal == E_OK)
#else
  operationIsAsync = FALSE;
#endif
  {
    KeyM_KeyExchangePubValLength = SSA_SIZEOF_PUBLICKEY;
#if (SSA_ENABLE_ASYNC_CSM_KEYM_ANAGEMENT_PRIMITIVES == STD_ON)
    retVal = Rte_Call_CsmJobKeyExchangeCalcPubVal_KeyExchangeCalcPubVal(
        SSA_KEYM_CSM_KEY_EXCHANGE_KEY, keyExchangePubVal, &KeyM_KeyExchangePubValLength);
#else
    retVal =
        Rte_Call_Key_SharedSecretKeyExchange_KeyExchangeCalcPubVal(keyExchangePubVal, &KeyM_KeyExchangePubValLength);
#endif

    Ssa_AsyncPostAction(&KeyM_CalcPubValAsyncState, retVal, operationIsAsync);
  }

  retVal = Ssa_AsyncFinalize(&KeyM_CalcPubValAsyncState, operationIsAsync);
  if (retVal == E_OK)
  {
    retVal = (Std_ReturnType)((KeyM_KeyExchangePubValLength == SSA_SIZEOF_PUBLICKEY) ? E_OK : E_NOT_OK);
  }

  return retVal;
}

/**********************************************************************************************************************
 *  KeyM_CsmKeyExchangeCalcSecret()
 **********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
SSA_KEYM_LOCAL FUNC(Std_ReturnType, Ssa_KeyM_CODE) KeyM_CsmKeyExchangeCalcSecret(
  P2CONST(uint8, AUTOMATIC, RTE_SSA_RIGHTSM_APPL_VAR) partnerPubVal)
{
  Std_ReturnType retVal;

  boolean operationIsAsync;
#if (SSA_ENABLE_ASYNC_CSM_KEYM_ANAGEMENT_PRIMITIVES == STD_ON)
  operationIsAsync = TRUE;
  retVal = Ssa_AsyncPreAction(&KeyM_CalcSecretAsyncState, operationIsAsync);
  if (retVal == E_OK)
#else
  operationIsAsync = FALSE;
#endif
  {
#if (SSA_ENABLE_ASYNC_CSM_KEYM_ANAGEMENT_PRIMITIVES == STD_ON)
    retVal = Rte_Call_CsmJobKeyExchangeCalcSecret_KeyExchangeCalcSecret(
        SSA_KEYM_CSM_KEY_EXCHANGE_KEY, partnerPubVal, SSA_SIZEOF_PUBLICKEY);
#else
    retVal = Rte_Call_Key_SharedSecretKeyExchange_KeyExchangeCalcSecret(partnerPubVal, SSA_SIZEOF_PUBLICKEY);
#endif

    Ssa_AsyncPostAction(&KeyM_CalcSecretAsyncState, retVal, operationIsAsync);
  }

  retVal = Ssa_AsyncFinalize(&KeyM_CalcSecretAsyncState, operationIsAsync);

  return retVal;
}

#if ((SSA_DIAG_SERVICE_TRUST_MODEL_GENERATE_KEY_PAIR == STD_ON) && (SSA_GENERATE_KEY_PAIR_CUSTOM_CALLOUT == STD_OFF))

/**********************************************************************************************************************
 *  KeyM_CsmKeyGenerate_TrustModelEcuCsrKey()
 **********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
SSA_KEYM_LOCAL FUNC(Std_ReturnType, Ssa_KeyM_CODE) KeyM_CsmKeyGenerate_TrustModelEcuCsrKey(void)
{
  Std_ReturnType retVal;
  boolean operationIsAsync;
# if (SSA_ENABLE_ASYNC_CSM_KEYM_ANAGEMENT_PRIMITIVES == STD_ON)
  operationIsAsync = TRUE;
  retVal =  Ssa_AsyncPreAction(&KeyM_GenerateTrustModelEcuCsrKeyAsyncState, operationIsAsync);
  if (retVal == E_OK)
# else
  operationIsAsync = FALSE;
# endif
  {
# if (SSA_ENABLE_ASYNC_CSM_KEYM_ANAGEMENT_PRIMITIVES == STD_ON)
    retVal = Rte_Call_CsmJobKeyGenerate_TrustModelEcuCsr_KeyGenerate(SSA_KEYM_CSM_KEY_TRUST_MODEL_ECU_CSR_PRIVATE_KEY);
# else
    retVal = Rte_Call_Key_TrustModelEcuCsrPrivateKey_KeyGenerate();
# endif

    Ssa_AsyncPostAction(&KeyM_GenerateTrustModelEcuCsrKeyAsyncState, retVal, operationIsAsync);
  }

  retVal = Ssa_AsyncFinalize(&KeyM_GenerateTrustModelEcuCsrKeyAsyncState, operationIsAsync);

  return retVal;
}

#endif

/**********************************************************************************************************************
 *  KeyM_SelfCheck_DiagnosticChain()
 **********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */

SSA_KEYM_LOCAL_INLINE FUNC(Std_ReturnType, Ssa_KeyM_CODE) KeyM_SelfCheck_DiagnosticChain(void)
{
  /* Declarations */
  Std_ReturnType retVal = KEYM_NO_RETVAL;
  uint8 stateCounter = 0u;

#if (SSA_ECU_TYPE == SSA_ECU_TYPE_VSM)
  Crypto_VerifyResultType cryptoVerifyResult = CRYPTO_E_VER_NOT_OK;
#endif

#if (SSA_KEEP_BUFFER_VARIABLES_STATIC == STD_OFF)
  uint8 KeyM_RootCertBuf[SSA_SIZEOF_CERT_MAX];
  uint8 KeyM_BackendCertBuf[SSA_SIZEOF_CERT_MAX];
# if (SSA_ECU_TYPE == SSA_ECU_TYPE_VSM)
  uint8 KeyM_EcuCertBuf[SSA_SIZEOF_CERT_MAX];
# endif

  /* satisfy QAC: initialize */
  KeyM_RootCertBuf[0] = 0;
  KeyM_BackendCertBuf[0] = 0;
# if (SSA_ECU_TYPE == SSA_ECU_TYPE_VSM)
  KeyM_EcuCertBuf[0] = 0;
# endif
#endif

  /* Implementation */
  for (stateCounter = 0u; stateCounter < SSA_KEYM_SELFCHECK_DIAGCHAIN_UPPER_BOUNDARY; stateCounter++)
  {
    if (retVal == KEYM_NO_RETVAL)
    {
      Std_ReturnType rVal;

      switch (KeyM_DiagProc.state)
      {
        case KEYM_CERTIFICATE_SELFCHECK_STATE_IDLE:
          /* Initialize verResultLen */
          KeyM_DiagProc.ws.certSelfCheck.verResultLen = 0u;
          KeyM_ClearDataBuffer(KeyM_DiagProc.ws.certSelfCheck.verResult, SSA_KEYM_SELFCHECK_SIZEOF_VERIFICATION_RESULT, SSA_KEYM_SELFCHECK_SIZEOF_VERIFICATION_RESULT);

          /* #10 Check for all relevant certificates if they exist and parse them. */
#if (SSA_ECU_TYPE == SSA_ECU_TYPE_VSM)
          KeyM_SelfCheck_DiagnosticChain_ParseCertificates(KeyM_RootCertBuf, KeyM_BackendCertBuf, KeyM_EcuCertBuf);
#else
          KeyM_SelfCheck_DiagnosticChain_ParseCertificates(
            KeyM_RootCertBuf,
            KeyM_BackendCertBuf,
            KeyM_RootCertBuf); /* Last buffer is only used for if ECU_TYPE is VSM, here it is a "dummy buffer". */
#endif
          KeyM_DiagProc.state = KEYM_CERTIFICATE_SELFCHECK_STATE_VERIFY_ROOT_CA_CERT;
          break;

        case KEYM_CERTIFICATE_SELFCHECK_STATE_VERIFY_ROOT_CA_CERT:
          /* #20 Check root certificate against itself. */
          /* Check if parsing of root certificate was successful. */
          if (KeyM_ParsedRootCert.pkiRole == CERTP_PKI_ROLE_ROOT)
          {
            rVal = KeyM_SelfCheck_DiagnosticChain_CheckCertificateAgainstIssuer(
              KeyM_RootCertBuf, &KeyM_ParsedRootCert, KeyM_RootCertBuf, &KeyM_ParsedRootCert, CERTP_PKI_ROLE_ROOT);

            retVal = KeyM_SelfCheck_DiagnosticChain_Handle_CheckResults(
              rVal,
              SSA_VER_RES_CERTSELFCHECK_ROOT_CERTIFICATE_IS_NOT_ACCESSIBLE_OR_IS_INVALID,
              KEYM_CERTIFICATE_SELFCHECK_STATE_VERIFY_BACKEND_CA_CERT);
          }
          else
          {
            retVal = RTE_E_OK;
            /* Verification result for missing root has already been set. */
          }
          break;

        case KEYM_CERTIFICATE_SELFCHECK_STATE_VERIFY_BACKEND_CA_CERT:
          /* #30 Check backend against root certificate. */
          /* Check if parsing of backend was successful. */
          if (KeyM_ParsedBackendCert.pkiRole == CERTP_PKI_ROLE_BACKEND)
          {
            rVal = KeyM_SelfCheck_DiagnosticChain_CheckCertificateAgainstIssuer(
              KeyM_BackendCertBuf,
              &KeyM_ParsedBackendCert,
              KeyM_RootCertBuf,
              &KeyM_ParsedRootCert,
              CERTP_PKI_ROLE_BACKEND);

#if (SSA_ECU_TYPE == SSA_ECU_TYPE_VSM)
            retVal = KeyM_SelfCheck_DiagnosticChain_Handle_CheckResults(
              rVal,
              SSA_VER_RES_CERTSELFCHECK_BACKEND_CERTIFICATE_CANNOT_BE_VERIFIED_BY_ROOT_CERTIFICATE,
              KEYM_CERTIFICATE_SELFCHECK_STATE_VERIFY_ECU_CERT);
#else
            /* Proceed with check of trust model chain. */
            retVal = KeyM_SelfCheck_DiagnosticChain_Handle_CheckResults(
              rVal,
              SSA_VER_RES_CERTSELFCHECK_BACKEND_CERTIFICATE_CANNOT_BE_VERIFIED_BY_ROOT_CERTIFICATE,
              KEYM_CERTIFICATE_SELFCHECK_STATE_VERIFY_TRUST_MODEL_CERT_CHAIN);
            if (retVal == KEYM_NO_RETVAL)
            {
              retVal = RTE_E_OK;
            }
#endif
          }
          else
          {
            retVal = RTE_E_OK;
            /* Verification result for missing backend has already been set. */
          }
          break;

          /* #40  VSM only: Check ECU against backend certificate. */
          /* #50 VSM only: Verify the stored private key against the public key of the ECU certificate. */
#if (SSA_ECU_TYPE == SSA_ECU_TYPE_VSM)
        case KEYM_CERTIFICATE_SELFCHECK_STATE_VERIFY_ECU_CERT:
          /* Check ECU against backend certificate. */
          /* Check if parsing of ECU was successful.*/
          if (KeyM_ParsedEcuCert.pkiRole == CERTP_PKI_ROLE_ECU)
          {
            rVal = KeyM_SelfCheck_DiagnosticChain_CheckCertificateAgainstIssuer(
              KeyM_EcuCertBuf, &KeyM_ParsedEcuCert, KeyM_BackendCertBuf, &KeyM_ParsedBackendCert, CERTP_PKI_ROLE_ECU);

            retVal = KeyM_SelfCheck_DiagnosticChain_Handle_CheckResults(
              rVal,
              SSA_VER_RES_CERTSELFCHECK_ECU_CERTIFICATE_CANNOT_BE_VERIFIED_BY_BACKEND_CERTIFICATE,
              KEYM_CERTIFICATE_SELFCHECK_STATE_CHECK_PRIVATE_KEY_ACCESSIBILITY);
          }
          else
          {
            retVal = RTE_E_OK;
            /* Verification result for missing ECU has already been set. */
          }
          break;

        case KEYM_CERTIFICATE_SELFCHECK_STATE_CHECK_PRIVATE_KEY_ACCESSIBILITY:
          /* Check if private key is accessible. */
          rVal = KeyM_SelfCheck_DiagnosticChain_CheckPrivateKeyAccessibility(KeyM_EcuCertBuf);

          retVal = KeyM_SelfCheck_DiagnosticChain_Handle_CheckResults(
            rVal,
            SSA_VER_RES_CERTSELFCHECK_PRIVATEKEY_IS_NOT_ACCESSIBLE,
            KEYM_CERTIFICATE_SELFCHECK_STATE_VERIFY_PRIVATE_KEY);
          break;

        case KEYM_CERTIFICATE_SELFCHECK_STATE_VERIFY_PRIVATE_KEY:
          /* Verify the stored private key against the public key of the ECU certificate. */
          rVal = KeyM_VerifyPublicKeyWithEcuPrivateKey(
            SSA_DIAGNOSTIC_KEY_PAIR,
            &KeyM_EcuCertBuf[KeyM_ParsedEcuCert.publicKey.elemDataIdx],
            &cryptoVerifyResult);

          /* Map rVal for Handle_CheckResults function. */
# if (SSA_ENABLE_ASYNC_CSM_JOB_PROCESSING == STD_ON)
          if (rVal == SSA_E_PENDING)
          {
            rVal = RTE_E_RoutineServices_Routine_Certificate_Self_Check_DCM_E_PENDING;
          }
          else if ((rVal != E_OK) || (cryptoVerifyResult != CRYPTO_E_VER_OK))
# else
          if ((rVal != E_OK) || (cryptoVerifyResult != CRYPTO_E_VER_OK))
# endif
          {
            rVal = E_NOT_OK;
          }
          else
          {
            /* do nothing */
          }

          retVal = KeyM_SelfCheck_DiagnosticChain_Handle_CheckResults(
            rVal,
            SSA_VER_RES_CERTSELFCHECK_ECU_CERTIFICATE_PRIVATE_KEY_DO_NOT_MATCH,
            KEYM_CERTIFICATE_SELFCHECK_STATE_VERIFY_TRUST_MODEL_CERT_CHAIN);

# if (SSA_ENABLE_ASYNC_CSM_JOB_PROCESSING == STD_ON)
          if (retVal != RTE_E_RoutineServices_Routine_Certificate_Self_Check_DCM_E_PENDING)
# else
          if (retVal == KEYM_NO_RETVAL)
# endif
          {
            /* Leave this function, since all checks were successful. */
            retVal = RTE_E_OK;
          }

          break;
#endif
        default:
          /* unexpected state */
          retVal = RTE_E_RoutineServices_Routine_Certificate_Self_Check_E_NOT_OK;
          /* remain in unexpected state */
          break;
      }
    }
    else
    {
      /* leave for-loop */
      break;
    }
  }
#if (SSA_ENABLE_ASYNC_CSM_JOB_PROCESSING == STD_ON)
  if (retVal == RTE_E_OK)
#endif
  {
    /* Proceed with check of Unique ECU ID chain. */
    KeyM_DiagProc.state = KEYM_CERTIFICATE_SELFCHECK_STATE_VERIFY_TRUST_MODEL_CERT_CHAIN;
  }

  return retVal;
} /* PRQA S 6030, 6080 */ /* MD_MSR_STCYC, MD_MSR_STMIF */

/**********************************************************************************************************************
 *  KeyM_SelfCheck_DiagnosticChain_Handle_CheckResults()
 **********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
SSA_KEYM_LOCAL FUNC(Std_ReturnType, Ssa_KeyM_CODE) KeyM_SelfCheck_DiagnosticChain_Handle_CheckResults(
  Std_ReturnType rVal,
  uint8 verificationResult,
  uint8 nextCheckState)
{
  Std_ReturnType retVal;

  if (rVal == E_NOT_OK)
  {
    /* Verification failed, quit Routine. */
    KeyM_SelfCheck_SetVerificationResult(verificationResult);
    retVal = RTE_E_OK;
  }
#if (SSA_ENABLE_ASYNC_CSM_JOB_PROCESSING == STD_ON)
  else if (rVal == RTE_E_RoutineServices_Routine_Certificate_Self_Check_DCM_E_PENDING)
  {
    /* Finish routine and call again. */
    retVal = RTE_E_RoutineServices_Routine_Certificate_Self_Check_DCM_E_PENDING;
  }
#endif
  else
  {
    /* Proceed with next check. */
    KeyM_DiagProc.state = nextCheckState;
    retVal = KEYM_NO_RETVAL;
  }

  return retVal;
}

/**********************************************************************************************************************
 *  KeyM_SelfCheck_DiagnosticChain_ParseCertificates()
 **********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 */
/* PRQA S 3673 4 */ /* MD_SSA_PARAM_NOT_P2CONST */
SSA_KEYM_LOCAL_INLINE FUNC(void, Ssa_KeyM_CODE) KeyM_SelfCheck_DiagnosticChain_ParseCertificates(
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) rootCertBuf,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) backendCertBuf,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) ecuCertBuf)
{
  Std_ReturnType retVal;
  uint16 rootCertLength = SSA_SIZEOF_CERT_MAX;
  uint16 backendCertLength = SSA_SIZEOF_CERT_MAX;
#if (SSA_ECU_TYPE == SSA_ECU_TYPE_VSM)
  uint16 ecuCertLength = SSA_SIZEOF_CERT_MAX;
#endif

  /* Get and parse the stored root certificate. Check its PKI role. */
  retVal = KeyM_GetAndParseStoredCert(CERTP_PKI_ROLE_ROOT, (P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR))rootCertBuf, &rootCertLength, TRUE);
  if ((retVal != E_OK) || (KeyM_ParsedRootCert.pkiRole != CERTP_PKI_ROLE_ROOT))
  {
    KeyM_SelfCheck_SetVerificationResult(SSA_VER_RES_CERTSELFCHECK_ROOT_CERTIFICATE_IS_NOT_ACCESSIBLE_OR_IS_INVALID);
  }

  /* Get and parse the stored backend certificate. Check its PKI role. */
  retVal = KeyM_GetAndParseStoredCert(CERTP_PKI_ROLE_BACKEND, (P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR))backendCertBuf, &backendCertLength, TRUE);
  if ((retVal != E_OK) || (KeyM_ParsedBackendCert.pkiRole != CERTP_PKI_ROLE_BACKEND))
  {
    KeyM_SelfCheck_SetVerificationResult(SSA_VER_RES_CERTSELFCHECK_BACKEND_CERTIFICATE_IS_NOT_ACCESSIBLE_OR_IS_INVALID);
  }

#if (SSA_ECU_TYPE == SSA_ECU_TYPE_VSM)
  /* Get and parse the stored ECU certificate. Check its PKI role. */
  retVal = KeyM_GetAndParseStoredCert(CERTP_PKI_ROLE_ECU, (P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR))ecuCertBuf, &ecuCertLength, TRUE);
  if ((retVal != E_OK) || (KeyM_ParsedEcuCert.pkiRole != CERTP_PKI_ROLE_ECU))
  {
    KeyM_SelfCheck_SetVerificationResult(SSA_VER_RES_CERTSELFCHECK_ECU_CERTIFICATE_IS_NOT_ACCESSIBLE_OR_IS_INVALID);
  }
#else
  SSA_DUMMY_STATEMENT(ecuCertBuf);   /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */
#endif
}

/**********************************************************************************************************************
 *  KeyM_SelfCheck_DiagnosticChain_CheckCertificateAgainstIssuer()
 **********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
SSA_KEYM_LOCAL FUNC(Std_ReturnType, Ssa_KeyM_CODE) KeyM_SelfCheck_DiagnosticChain_CheckCertificateAgainstIssuer(
  P2CONST(uint8, AUTOMATIC, RTE_SSA_CERTP_APPL_DATA) rawCertData,
  P2VAR(CertP_ParsedCertStructureType, AUTOMATIC, RTE_SSA_CERTP_APPL_VAR) parsedCert,
  P2CONST(uint8, AUTOMATIC, RTE_SSA_CERTP_APPL_DATA) rawCertIssuer,
  P2CONST(CertP_ParsedCertStructureType, AUTOMATIC, RTE_SSA_CERTP_APPL_DATA) parsedCertIssuer,
  CertP_PkiRoleType expectedPkiRole)
{
  Std_ReturnType retVal = RTE_E_OK;
  Std_ReturnType rVal;

  /* Verify certificate against issuer. */
  /* Check against RTE in buffer CertP_RawCertBufferType:
  *   rawCertData and rawCertIssuer point always to a buffer of size SSA_SIZEOF_CERT_MAX */
  rVal = Rte_Call_CertP_Functions_Certificate_Verify(rawCertData, parsedCert, rawCertIssuer, parsedCertIssuer, expectedPkiRole);
#if (SSA_ENABLE_ASYNC_CSM_JOB_PROCESSING == STD_ON)
  if (rVal == RTE_E_CertP_Functions_E_PENDING)
  {
    retVal = RTE_E_RoutineServices_Routine_Certificate_Self_Check_DCM_E_PENDING;
  }
  else
#endif
  {
    if ((rVal != E_OK) || (parsedCert->verificationResult != CERTP_VER_OK))
    {
      retVal = E_NOT_OK;
    }
  }

  return retVal;
}

#if (SSA_ECU_TYPE == SSA_ECU_TYPE_VSM)
/**********************************************************************************************************************
 *  KeyM_SelfCheck_DiagnosticChain_CheckPrivateKey()
 **********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
SSA_KEYM_LOCAL_INLINE FUNC(Std_ReturnType, Ssa_KeyM_CODE) KeyM_SelfCheck_DiagnosticChain_CheckPrivateKeyAccessibility(
  P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) ecuCertBuf)
{
  Std_ReturnType retVal = RTE_E_OK;
  Std_ReturnType rVal;

# if (SSA_KEEP_BUFFER_VARIABLES_STATIC == STD_OFF)
    uint8 KeyM_SignatureTest[SSA_SIZEOF_SIGNATURE];
# endif

  rVal = KeyM_CsmSignatureGenerate(
    SSA_DIAGNOSTIC_KEY_PAIR,
    ecuCertBuf,
    SSA_SIZEOF_PUBLICKEY,
    KeyM_SignatureTest);

# if (SSA_ENABLE_ASYNC_CSM_JOB_PROCESSING == STD_ON)
  if (rVal == SSA_E_PENDING)
  {
    retVal = RTE_E_RoutineServices_Routine_Certificate_Self_Check_DCM_E_PENDING;
  }
  else
# endif
  {
    if (rVal != E_OK)
    {
      retVal = E_NOT_OK;
    }
  }

  return retVal;
}
#endif

/**********************************************************************************************************************
 *  KeyM_SelfCheck_UniqueEcuIdChain()
 **********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
SSA_KEYM_LOCAL_INLINE FUNC(Std_ReturnType, Ssa_KeyM_CODE) KeyM_SelfCheck_UniqueEcuIdChain(void)
{
  Std_ReturnType retVal = KEYM_NO_RETVAL;
  uint8 stateCounter = 0u;

  for(stateCounter = 0u; stateCounter < SSA_KEYM_SELFCHECK_UNIQUEECUID_CHAIN_UPPER_BOUNDARY; stateCounter++)
  {
    if (retVal == KEYM_NO_RETVAL)
    {
      Std_ReturnType rVal;

      switch (KeyM_DiagProc.state)
      {
        case KEYM_CERTIFICATE_SELFCHECK_STATE_VERIFY_TRUST_MODEL_CERT_CHAIN:
          /* #10 Check for all certificates if they are available and can be parsed. */
          rVal = KeyM_SelfCheck_EcuIdChain_CheckCertificateAvailability();
          if (rVal == E_OK)
          {
            /* root is valid and accessible, proceed with next state */
            KeyM_DiagProc.state = KEYM_CERTIFICATE_SELFCHECK_STATE_VERIFY_TRUST_MODEL_CERT_CHAIN_GET_STATUS;
          }
          else
          {
            /* root is not valid or not accessible, finish routine */
            retVal = RTE_E_OK;
          }
          break;

        case KEYM_CERTIFICATE_SELFCHECK_STATE_VERIFY_TRUST_MODEL_CERT_CHAIN_GET_STATUS:
          /* #10 Check for all certificates if they are available and can be parsed. */
          rVal = KeyM_SelfCheck_EcuIdChain_GetCertParseStatus();
          if (rVal == E_OK)
          {
            /* root is valid and accessible, proceed with next state */
            KeyM_DiagProc.state = KEYM_CERTIFICATE_SELFCHECK_STATE_UPDATE_ROOT;
          }
          else if (rVal == RTE_E_RoutineServices_Routine_Certificate_Self_Check_DCM_E_PENDING)
          {
            retVal = RTE_E_RoutineServices_Routine_Certificate_Self_Check_DCM_E_PENDING;
          }
          else
          {
            /* root is not valid or not accessible, finish routine */
            retVal = RTE_E_OK;
          }
          break;

        case KEYM_CERTIFICATE_SELFCHECK_STATE_UPDATE_ROOT:
          /* #20 Verify the chain of trust. */

          /* Perform an update of the root certificate for checking the whole chain of trust. */
          rVal = KeyM_SelfCheck_EcuIdChain_UpdateRootCertificate();
          if (rVal == E_OK)
          {
            /* proceed with next state */
            KeyM_DiagProc.state = KEYM_CERTIFICATE_SELFCHECK_STATE_AWAITING_VERIFICATION_RESULT_CERT_CHAIN;
            retVal = RTE_E_RoutineServices_Routine_Certificate_Self_Check_DCM_E_PENDING;
          }
          else
          {
            /* finish routine */
            retVal = RTE_E_RoutineServices_Routine_Certificate_Self_Check_E_NOT_OK;
          }
          break;

        case KEYM_CERTIFICATE_SELFCHECK_STATE_AWAITING_VERIFICATION_RESULT_CERT_CHAIN:
        {
          /* Check for callback. */
          if (KeyM_DiagProc.serviceResponseCallbackOccurred)
          {
            /* #25 Evaluate the verification results of AsrKeyM and do additional verification
                   of certificate entries not verified by KeyM. */
            retVal = KeyM_SelfCheck_HandleCallbackResult(KeyM_DiagProc.serviceResponseCallbackResult);
          }
          else
          {
            retVal = RTE_E_RoutineServices_Routine_Certificate_Self_Check_DCM_E_PENDING;
          }
          break;
        }

        case KEYM_CERTIFICATE_SELFCHECK_STATE_VERIFY_TRUST_MODEL_PRIVATE_KEY:
        {
          /* #30 Verify the Trust Model private key against the public key of the Trust Model ECU certificate. */
          Crypto_VerifyResultType cryptoVerifResult = CRYPTO_E_VER_NOT_OK;

          rVal = KeyM_VerifyPublicKeyWithEcuPrivateKey(
            SSA_TRUST_MODEL_LIVE_KEY_PAIR,
            NULL_PTR,
            &cryptoVerifResult);
#if (SSA_ENABLE_ASYNC_CSM_JOB_PROCESSING == STD_ON)
          if (rVal == SSA_E_PENDING)
          {
            /* remain in state */
            retVal = RTE_E_RoutineServices_Routine_Certificate_Self_Check_DCM_E_PENDING;
          }
          else
#endif
            if (rVal != E_OK)
            {
              KeyM_SelfCheck_SetVerificationResult(SSA_VER_RES_CERTSELFCHECK_PRIVATEKEY_SELF_SIGNED_IS_NOT_ACCESSIBLE);
              retVal = RTE_E_OK;
            }
            else if (cryptoVerifResult != CRYPTO_E_VER_OK)
            {
              KeyM_SelfCheck_SetVerificationResult(SSA_VER_RES_CERTSELFCHECK_TRUST_MODEL_ECU_CERTIFICATE_PRIVATE_KEY_DO_NOT_MATCH);
              retVal = RTE_E_OK;
            }
            else
            {
              retVal = RTE_E_OK;
            }
        }
        break;

        default:
          /* unexpected state */
          retVal = RTE_E_RoutineServices_Routine_Certificate_Self_Check_E_NOT_OK;
          break;
      }
    }
    else
    {
      /* leave for-loop */
      break;
    }
  }

  return retVal;
} /* PRQA S 6030, 6080 */ /* MD_MSR_STCYC, MD_MSR_STMIF */


/**********************************************************************************************************************
 *  KeyM_SelfCheck_EcuIdChain_CheckCertificateAvailability()
 **********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
SSA_KEYM_LOCAL_INLINE FUNC(Std_ReturnType, Ssa_KeyM_CODE) KeyM_SelfCheck_EcuIdChain_CheckCertificateAvailability( void )
{
  Std_ReturnType retVal;

  /* root */
  /* for the following verifications it is relevant if the root is accessible and valid */
  retVal = KeyM_SelfCheck_EcuIdChain_ParseCertificate(SSA_TRUST_MODEL_ROOT_CERT_ID, SSA_VER_RES_CERTSELFCHECK_TRUST_MODEL_ROOT_CERTIFICATE_IS_NOT_ACCESSIBLE_OR_IS_INVALID);

  /* backend */
  (void)KeyM_SelfCheck_EcuIdChain_ParseCertificate(SSA_TRUST_MODEL_BACKEND_CERT_ID, SSA_VER_RES_CERTSELFCHECK_TRUST_MODEL_BACKEND_CERTIFICATE_IS_NOT_ACCESSIBLE_OR_IS_INVALID);

  /* intermediate */
  (void)KeyM_SelfCheck_EcuIdChain_ParseCertificate(SSA_TRUST_MODEL_INTERMEDIATE_CERT_ID, SSA_VER_RES_CERTSELFCHECK_TRUST_MODEL_INTERMEDIATE_CERTIFICATE_IS_NOT_ACCESSIBLE_OR_IS_INVALID);

  /* ECU */
  (void)KeyM_SelfCheck_EcuIdChain_ParseCertificate(SSA_TRUST_MODEL_ECU_CERT_ID, SSA_VER_RES_CERTSELFCHECK_TRUST_MODEL_ECU_CERTIFICATE_IS_NOT_ACCESSIBLE_OR_IS_INVALID);

  return retVal;
}

/**********************************************************************************************************************
*  KeyM_SelfCheck_EcuIdChain_AdditionalVerificationOfCertEntries()
**********************************************************************************************************************/
/*!
* Internal comment removed.
 *
 *
*/
SSA_KEYM_LOCAL_INLINE FUNC(Std_ReturnType, Ssa_KeyM_CODE) KeyM_SelfCheck_EcuIdChain_AdditionalVerificationOfCertEntries(void)
{

  Std_ReturnType localRetVal;
  Std_ReturnType retVal = KEYM_NO_RETVAL; /* This value is used for controlling when to stop the verification (in KeyM_SelfCheck_EcuIdChain()). */
  KeyM_CertificateStatusType localCertStatus = KEYM_CERTIFICATE_INVALID;
  KeyM_CertificateIdType invalidCertificate_Id = SSA_TRUST_MODEL_ROOT_CERT_ID;

  /* Additional verification of root certificate */
  localRetVal = KeyM_TrustModel_AdditionalVerificationOfCertificateEntries_SingleCertificate(SSA_TRUST_MODEL_ROOT_CERT_ID, SSA_TRUST_MODEL_ROOT_CERT_ID, &localCertStatus);
  if (localRetVal != E_OK)
  {
    /* Error in additional verification, finish routine */
    retVal = RTE_E_RoutineServices_Routine_Certificate_Self_Check_E_NOT_OK;
  }
  else
  {
    if (localCertStatus != KEYM_CERTIFICATE_VALID) /* additional verification failed */
    {
      KeyM_SelfCheck_SetVerificationResult(SSA_VER_RES_CERTSELFCHECK_TRUST_MODEL_ROOT_CERTIFICATE_IS_NOT_ACCESSIBLE_OR_IS_INVALID);
      retVal = RTE_E_OK;
    }
    else
    {
      /* Additional verification of certificate chain */
      localRetVal = KeyM_TrustModel_AdditionalVerificationOfCertEntries_CertificateChain(
        SSA_TRUST_MODEL_BACKEND_CERT_ID, SSA_TRUST_MODEL_INTERMEDIATE_CERT_ID, SSA_TRUST_MODEL_ECU_CERT_ID, &invalidCertificate_Id, &localCertStatus);
      if (localRetVal != E_OK)
      {
        /* Error in additional verification, finish routine */
        retVal = RTE_E_RoutineServices_Routine_Certificate_Self_Check_E_NOT_OK;
      }
      else
      {
        if (localCertStatus != KEYM_CERTIFICATE_VALID) /* additional verification failed */
        {
          retVal = RTE_E_OK;
          /* Set verification result based on the certificate id of the invalid certificate. */
          KeyM_SelfCheck_TrustModel_MapInvalidCertIdToVerificationResult(invalidCertificate_Id);
        }
      }
    }
  }
  /* If the retVal is still KEYM_NO_RETVAL the verification was successful. */
  return retVal;
}

/**********************************************************************************************************************
 *  KeyM_IsMultiRetVal()
 **********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
SSA_KEYM_LOCAL_INLINE FUNC(boolean, Ssa_KeyM_CODE) KeyM_IsMultiRetVal(P2CONST(uint8, AUTOMATIC, AUTOMATIC) rVal, uint8 size, Std_ReturnType expected)
{
  uint8 i;
  boolean found = FALSE;

  for (i = 0u; i < size; i++)
  {
    if (rVal[i] == expected)
    {
      found = TRUE;
      break;
    }
  }

  return found;
}

/**********************************************************************************************************************
 *  KeyM_SelfCheck_EcuIdChain_GetCertParseStatus()
 **********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 */
SSA_KEYM_LOCAL_INLINE FUNC(Std_ReturnType, Ssa_KeyM_CODE) KeyM_SelfCheck_EcuIdChain_GetCertParseStatus(void)
{
  Std_ReturnType localRet[4], retVal;
  KeyM_CertificateStatusType status[4];

  /* root */
  localRet[0] = KeyM_SelfCheck_EcuIdChain_GetCertificateStatus(SSA_TRUST_MODEL_ROOT_CERT_ID,
                                                                   &status[0]);

  /* backend */
  localRet[1] = KeyM_SelfCheck_EcuIdChain_GetCertificateStatus(SSA_TRUST_MODEL_BACKEND_CERT_ID,
                                                                   &status[1]);

  /* intermediate */
  localRet[2] = KeyM_SelfCheck_EcuIdChain_GetCertificateStatus(SSA_TRUST_MODEL_INTERMEDIATE_CERT_ID,
                                                                   &status[2]);

  /* ECU */
  localRet[3] = KeyM_SelfCheck_EcuIdChain_GetCertificateStatus(SSA_TRUST_MODEL_ECU_CERT_ID,
                                                                   &status[3]);

  /* check if a request is pending or has failed */
  if (KeyM_IsMultiRetVal(localRet, 4, RTE_E_RoutineServices_Routine_Certificate_Self_Check_DCM_E_PENDING))
  {
    retVal = RTE_E_RoutineServices_Routine_Certificate_Self_Check_DCM_E_PENDING;
  }
  else
  {
    /* root */
    KeyM_SelfCheck_EcuIdChain_HandleCertificateStatus(SSA_VER_RES_CERTSELFCHECK_TRUST_MODEL_ROOT_CERTIFICATE_IS_NOT_ACCESSIBLE_OR_IS_INVALID,
                                                       localRet[0], status[0]);

    /* backend */
    KeyM_SelfCheck_EcuIdChain_HandleCertificateStatus(SSA_VER_RES_CERTSELFCHECK_TRUST_MODEL_BACKEND_CERTIFICATE_IS_NOT_ACCESSIBLE_OR_IS_INVALID,
                                                       localRet[1], status[1]);

    /* intermediate */
    KeyM_SelfCheck_EcuIdChain_HandleCertificateStatus(SSA_VER_RES_CERTSELFCHECK_TRUST_MODEL_INTERMEDIATE_CERTIFICATE_IS_NOT_ACCESSIBLE_OR_IS_INVALID,
                                                       localRet[2], status[2]);

    /* ECU */
    KeyM_SelfCheck_EcuIdChain_HandleCertificateStatus(SSA_VER_RES_CERTSELFCHECK_TRUST_MODEL_ECU_CERTIFICATE_IS_NOT_ACCESSIBLE_OR_IS_INVALID,
                                                       localRet[3], status[3]);

  if (KeyM_IsMultiRetVal(localRet, 4, E_NOT_OK))
  {
    retVal = E_NOT_OK;
  }
  else
  {
    retVal = E_OK;
  }
  }

  return retVal;
}

/**********************************************************************************************************************
 *  KeyM_SelfCheck_EcuIdChain_ParseCertificate()
 **********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 */
SSA_KEYM_LOCAL FUNC(Std_ReturnType, Ssa_KeyM_CODE) KeyM_SelfCheck_EcuIdChain_ParseCertificate(KeyM_CertificateIdType certId, uint8 verificationResult)
{
  Std_ReturnType retVal = E_OK;
  Std_ReturnType rVal;
  Ssa_KeyM_CertDataType certificate;
  uint8 certificateBuffer[SSA_KEYM_SIZEOF_CERTIFICATEDATA_BUFFER];

  /* initialize certData and certDataLength.*/
  certificate.certData = certificateBuffer;
  certificate.certDataLength = SSA_KEYM_SIZEOF_CERTIFICATEDATA_BUFFER;

  /* Get the certificate given as input, in order to be able to parse it. */
  rVal = KeyM_KeyM_GetCertificate(certId, &certificate);
  if (rVal == E_OK)
  {
    /* Parse the certificate (SetCertificate always parses the certificate after setting it). */
    rVal = KeyM_KeyM_SetCertificate(certId, &certificate);
  }
  if (rVal != E_OK)
  {
    /* parsing failed, since certificate is either not accessible or invalid */
    KeyM_SelfCheck_SetVerificationResult(verificationResult);
    retVal = E_NOT_OK;
  }

  return retVal;
}

/**********************************************************************************************************************
 *  KeyM_SelfCheck_EcuIdChain_GetCertificateStatus()
 **********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
SSA_KEYM_LOCAL FUNC(Std_ReturnType, Ssa_KeyM_CODE) KeyM_SelfCheck_EcuIdChain_GetCertificateStatus(
  KeyM_CertificateIdType certId,
  P2VAR(KeyM_CertificateStatusType, AUTOMATIC, AUTOMATIC) status)
{
  Std_ReturnType retVal = E_OK;
  Std_ReturnType rVal;

  /* Check if the parsing was successful. */
  rVal = KeyM_KeyM_CertGetStatus(certId, status);
  if (rVal != E_OK)
  {
    retVal = E_NOT_OK;
  }
  else if (*status == KEYM_CERTIFICATE_NOT_PARSED)
  {
    /* Parsing is still pending */
    retVal = RTE_E_RoutineServices_Routine_Certificate_Self_Check_DCM_E_PENDING;
  }
  else
  {
    /* parsing finished */
  }

  return retVal;
}

/**********************************************************************************************************************
 *  KeyM_SelfCheck_EcuIdChain_HandleCertificateStatus()
 **********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
SSA_KEYM_LOCAL FUNC(void, Ssa_KeyM_CODE) KeyM_SelfCheck_EcuIdChain_HandleCertificateStatus(
  uint8 verificationResult,
  Std_ReturnType error,
  KeyM_CertificateStatusType status)
{
  if ((error != E_OK) || (status != KEYM_CERTIFICATE_PARSED_NOT_VALIDATED))
  {
    /* parsing failed, since certificate is either not accessible or invalid */
    KeyM_SelfCheck_UpdateLastVerificationResult(verificationResult);
  }
}

/**********************************************************************************************************************
 *  KeyM_SelfCheck_EcuIdChain_UpdateRootCertificate()
 **********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 */
SSA_KEYM_LOCAL_INLINE FUNC(Std_ReturnType, Ssa_KeyM_CODE) KeyM_SelfCheck_EcuIdChain_UpdateRootCertificate( void )
{
  Std_ReturnType rVal;
  Std_ReturnType retVal = E_NOT_OK;
  Ssa_KeyM_CertDataType certificateData;

  /* Prepare buffer to which certificate data and its length shall be written to. */
  certificateData.certData = KeyM_DiagProc.ws.certSelfCheck.certBufferRoot;
  certificateData.certDataLength = sizeof(KeyM_DiagProc.ws.certSelfCheck.certBufferRoot);

  /* Get certificate data from KeyM. */
  rVal = KeyM_KeyM_GetCertificate(SSA_TRUST_MODEL_ROOT_CERT_ID, &certificateData);
  if (rVal != E_OK)
  {
    /* error */
  }
  else
  {
    /* Prepare asynchronous service certificate call. */
    KeyM_DiagProc.serviceResponseCallbackOccurred = FALSE;

    /* Service certificate call for updating Trust Model root certificate */
    rVal = Rte_Call_SsaCdd_TrustModel_ServiceCertificate(
      KEYM_SERVICE_CERT_UPDATE_ROOT,
      KeyM_TrustModelRootCertName(), KeyM_TrustModelRootCertNameLength(),
      certificateData.certData, certificateData.certDataLength,
      KeyM_DiagProc.serviceResponseBuffer, sizeof(KeyM_DiagProc.serviceResponseBuffer));
    if (rVal == RTE_E_OK)
    {
      retVal = E_OK;
    }
    else if (rVal == RTE_E_SsaCdd_KeyM_CertInterface_KEYM_E_BUSY)
    {
      retVal = RTE_E_RoutineServices_Routine_Certificate_Self_Check_DCM_E_PENDING;
    }
    else
    {
      /* update failed. */
    }
  }

  return retVal;
}

/**********************************************************************************************************************
 *  KeyM_SelfCheck_EcuIdChain_CheckCertificateEvaluationResult()
 **********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
SSA_KEYM_LOCAL_INLINE FUNC(Std_ReturnType, Ssa_KeyM_CODE) KeyM_SelfCheck_EcuIdChain_CheckCertificateEvaluationResult( void )
{
  Std_ReturnType rVal;
  Std_ReturnType retVal = KEYM_NO_RETVAL;
  uint8 status;

  /* Check backend */
  rVal = KeyM_KeyM_CertGetStatus(SSA_TRUST_MODEL_BACKEND_CERT_ID, &status);
  if ((rVal != E_OK) || (status != KEYM_CERTIFICATE_VALID))
  {
    /* Verification failed, quit Routine. */
    if (status != KEYM_CERTIFICATE_NOT_AVAILABLE) /* availability has already been checked */
    {
      /* if the certificate is available set verification result */
      KeyM_SelfCheck_SetVerificationResult(SSA_VER_RES_CERTSELFCHECK_TRUST_MODEL_BACKEND_CERTIFICATE_CANNOT_BE_VERIFIED_BY_TRUST_MODEL_ROOT_CERTIFICATE);
    }
    retVal = RTE_E_OK;
  }

  if (retVal != RTE_E_OK)
  {
    /* Check intermediate */
    rVal = KeyM_KeyM_CertGetStatus(SSA_TRUST_MODEL_INTERMEDIATE_CERT_ID, &status);
    if ((rVal != E_OK) || (status != KEYM_CERTIFICATE_VALID))
    {
      /* Verification failed, quit Routine. */
      if (status != KEYM_CERTIFICATE_NOT_AVAILABLE) /* availability has already been checked */
      {
        /* if the certificate is available set verification result */
        KeyM_SelfCheck_SetVerificationResult(SSA_VER_RES_CERTSELFCHECK_TRUST_MODEL_INTERMEDIATE_CERTIFICATE_CANNOT_BE_VERIFIED_BY_TRUST_MODEL_BACKEND_CERTIFICATE);
      }
      retVal = RTE_E_OK;
    }
  }

  if (retVal != RTE_E_OK)
  {
    /* Check ECU */
    rVal = KeyM_KeyM_CertGetStatus(SSA_TRUST_MODEL_ECU_CERT_ID, &status);
    if ((rVal != E_OK) || (status != KEYM_CERTIFICATE_VALID))
    {
      /* Verification failed, quit Routine. */
      if (status != KEYM_CERTIFICATE_NOT_AVAILABLE) /* availability has already been checked */
      {
        /* if the certificate is available set verification result */
        KeyM_SelfCheck_SetVerificationResult(SSA_VER_RES_CERTSELFCHECK_TRUST_MODEL_ECU_CERTIFICATE_CANNOT_BE_VERIFIED_BY_TRUST_MODEL_INTERMEDIATE_CERTIFICATE);
      }
      retVal = RTE_E_OK;
    }
  }

  return retVal;
}

/**********************************************************************************************************************
 * KeyM_SelfCheck_TrustModel_MapInvalidCertIdToVerificationResult()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 */
SSA_KEYM_LOCAL FUNC(void, Ssa_KeyM_CODE) KeyM_SelfCheck_TrustModel_MapInvalidCertIdToVerificationResult(
  CONST(KeyM_CertificateIdType, AUTOMATIC) invalidCertificate_Id)
{
  /* Map AsrKeyM certificate id to verification result. */
  switch (invalidCertificate_Id)
  {
    case SSA_TRUST_MODEL_BACKEND_CERT_ID:
    {
      KeyM_SelfCheck_SetVerificationResult(SSA_VER_RES_CERTSELFCHECK_TRUST_MODEL_BACKEND_CERTIFICATE_IS_NOT_ACCESSIBLE_OR_IS_INVALID);
      break;
    }
    case SSA_TRUST_MODEL_INTERMEDIATE_CERT_ID:
    {
      KeyM_SelfCheck_SetVerificationResult(SSA_VER_RES_CERTSELFCHECK_TRUST_MODEL_INTERMEDIATE_CERTIFICATE_IS_NOT_ACCESSIBLE_OR_IS_INVALID);
      break;
    }
    case SSA_TRUST_MODEL_ECU_CERT_ID:
      /* Fall through */
    default: /* This case should not occur */
    {
      KeyM_SelfCheck_SetVerificationResult(SSA_VER_RES_CERTSELFCHECK_TRUST_MODEL_ECU_CERTIFICATE_IS_NOT_ACCESSIBLE_OR_IS_INVALID);
      break;
    }
  }
}

/**********************************************************************************************************************
 * KeyM_SelfCheck_SetVerificationResult()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
SSA_KEYM_LOCAL FUNC(void, Ssa_KeyM_CODE) KeyM_SelfCheck_SetVerificationResult(uint8 verificationResult)
{
  /* Check for writing out of bounds. */
  if (KeyM_DiagProc.ws.certSelfCheck.verResultLen < (SSA_KEYM_SELFCHECK_SIZEOF_VERIFICATION_RESULT))
  {
    /* Set the verification result. */
    KeyM_DiagProc.ws.certSelfCheck.verResult[KeyM_DiagProc.ws.certSelfCheck.verResultLen] = verificationResult;
    KeyM_DiagProc.ws.certSelfCheck.verResultLen += 1u;
  }
}

/**********************************************************************************************************************
 * KeyM_SelfCheck_UpdateLastVerificationResult()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 */
SSA_KEYM_LOCAL FUNC(void, Ssa_KeyM_CODE) KeyM_SelfCheck_UpdateLastVerificationResult(uint8 verificationResult)
{
  if (KeyM_DiagProc.ws.certSelfCheck.verResultLen == 0u)
  {
    /* If no verification result has been set at all, set the current verification result as the first one.*/
    KeyM_SelfCheck_SetVerificationResult(verificationResult);
  }
  else
  {
    /* Check for writing out of bounds. */
    if (KeyM_DiagProc.ws.certSelfCheck.verResultLen < (SSA_KEYM_SELFCHECK_SIZEOF_VERIFICATION_RESULT))
    {
      /* Set the verification result. */
      if (KeyM_DiagProc.ws.certSelfCheck.verResult[KeyM_DiagProc.ws.certSelfCheck.verResultLen - 1u] != verificationResult)
      {
        KeyM_SelfCheck_SetVerificationResult(verificationResult);
      }
    }
  }
}

/**********************************************************************************************************************
* KeyM_SelfCheck_HandleCallbackResult()
*********************************************************************************************************************/
/*!
* Internal comment removed.
 *
 *
 *
 *
*/
SSA_KEYM_LOCAL FUNC(Std_ReturnType, Ssa_KeyM_CODE) KeyM_SelfCheck_HandleCallbackResult(uint8 callbackResult)
{
  Std_ReturnType retVal = RTE_E_OK;

  if (callbackResult == KEYM_RT_OK)
  {
    /* root certificate could be verified against itself */

    /* Check if the other certificates are valid and could be verified against their issuers. */
    retVal = KeyM_SelfCheck_EcuIdChain_CheckCertificateEvaluationResult();

    if (retVal == KEYM_NO_RETVAL) /* All certificates passed the KeyM verification */
    {
      /* Do additional verification of certificate entries not verified by KeyM. */

      retVal = KeyM_SelfCheck_EcuIdChain_AdditionalVerificationOfCertEntries();
      if (retVal == KEYM_NO_RETVAL)
      {
        /* Verification was successful, proceed with next state. */
        KeyM_DiagProc.state = KEYM_CERTIFICATE_SELFCHECK_STATE_VERIFY_TRUST_MODEL_PRIVATE_KEY;
      }
    }

    /* If any certificate is invalid, RTE_E_OK is returned and the selfCheck finishes */
  }
  else
  {
    /* root could not be verified against itself */
    KeyM_SelfCheck_SetVerificationResult(SSA_VER_RES_CERTSELFCHECK_TRUST_MODEL_ROOT_CERTIFICATE_IS_NOT_ACCESSIBLE_OR_IS_INVALID);
    retVal = RTE_E_OK;
  }

  return retVal;
}


/**********************************************************************************************************************
 *  KeyM_GetMainLoopStateLock()
 **********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 */
SSA_KEYM_LOCAL FUNC(boolean, Ssa_KeyM_CODE) KeyM_GetMainLoopStateLock(void)
{
  boolean retVal = FALSE;
  Rte_Enter_KeyM_ExclusiveArea();
  /* #10 If main loop processing state is IDLE change to state PROCESSING and return TRUE.
   *     Protect state change by an exclusive area. */
  if (KeyM_MainLoopProc.state == KEYM_GENERATE_SYM_KEYS_STATE_IDLE)
  {
    KeyM_MainLoopProc.state = KEYM_GENERATE_SYM_KEYS_STATE_LOCKED;
    retVal = TRUE;
  }
  Rte_Exit_KeyM_ExclusiveArea();
  return retVal;
}

/**********************************************************************************************************************
 * KeyM_GenerateAndStoreSecOcKeys()
 **********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
SSA_KEYM_LOCAL_INLINE FUNC(Std_ReturnType, Ssa_KeyM_CODE) KeyM_GenerateAndStoreSecOcKeys(void)
{
  Std_ReturnType retVal = RTE_E_OK;
  uint16 localPduId, byteIdx;
  uint8 hashDataBuffer[SSA_SIZEOF_HASHVALUE];
  uint8 hashResultBuffer[SSA_SIZEOF_HASHVALUE];
  uint32 hashResultLength;
  uint16 startLocalPduId = KeyM_MainLoopProc.numGenSymKeys;
  uint16 endLocalPduId;

#if (SSA_KEYM_NUMBER_KEYS_GENERATED_IN_MAIN > Ssa_GetSizeOfDataIdInfo())
  endLocalPduId = Ssa_GetSizeOfDataIdInfo();
#else
  /* #10 Set start and stop index for looping over the Secured PDUs. */
  if (((uint32)startLocalPduId + SSA_KEYM_NUMBER_KEYS_GENERATED_IN_MAIN) > (uint32)Ssa_GetSizeOfDataIdInfo()) /*lint !e587 */
  {
    endLocalPduId = Ssa_GetSizeOfDataIdInfo();
  }
  else
  {
    /* PRQA S 2880 1 */ /* MD_SSA_UNREACHABLE_CODE */
    endLocalPduId = (uint16)(startLocalPduId + SSA_KEYM_NUMBER_KEYS_GENERATED_IN_MAIN);
  }
#endif

  /* #20 Concatenate the car-specific secret and the PDU data ID. */
  /* #30 Add car specific secret to hash buffer. */
  Ssa_MemCpy((P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR))hashDataBuffer, KeyM_CarSpecificSecret, SSA_SIZEOF_SECRET);

  /* #40 Fill padding zeros up to the required input length for the hash algorithm. */
  for (byteIdx = SSA_SIZEOF_SECRET + 2u; byteIdx < SSA_SIZEOF_HASHVALUE; byteIdx++)
  {
    hashDataBuffer[byteIdx] = 0x00u;
  }

  /* #50 Iterate over all configured Secured PDUs. */
  for (localPduId = startLocalPduId; localPduId < endLocalPduId; localPduId++) /* FETA_SSA_KEYM_MONOTONIC_LOOP_UP_WITH_UNCHANGED_UPPER_BOUND */
  {
    hashResultLength = SSA_SIZEOF_HASHVALUE;

    /* #60 Add Data ID to the hash buffer. */
    hashDataBuffer[SSA_SIZEOF_SECRET] = ((uint8)(((uint16)(Ssa_GetDataIdOfDataIdInfo(localPduId))) >> 8));
    hashDataBuffer[SSA_SIZEOF_SECRET + 1u] = ((uint8)(((uint16)(Ssa_GetDataIdOfDataIdInfo(localPduId))) & 0xFFu));

    /* #70 Calculate the hash value from the concatenation.  */
    retVal = Rte_Call_SsaCdd_Csm_Hash(SSA_KEYM_HASH_JOB_ID, CRYPTO_OPERATIONMODE_SINGLECALL, hashDataBuffer, SSA_SIZEOF_HASHVALUE, hashResultBuffer, &hashResultLength);

    if ((retVal != RTE_E_OK) || (hashResultLength != SSA_SIZEOF_HASHVALUE))
    {
      retVal = E_NOT_OK;
    }
    else
    {
      /* #80 Store the leftmost bits of the hash value as symmetric key. */
      retVal = Rte_Call_SsaCdd_Keys_KeyElementSet(Ssa_GetKeyIdOfDataIdInfo(localPduId), SSA_KE_MAC_KEY, hashResultBuffer, SSA_SIZEOF_SYMKEY);
    }

    if (retVal == RTE_E_OK)
    {
      /* #90 Store the rightmost bits of the hash value as symmetric key checksum. */
      retVal = Rte_Call_SsaCdd_Keys_KeyElementSet(Ssa_GetKeyIdOfDataIdInfo(localPduId), SSA_KE_MAC_PROOF, &hashResultBuffer[SSA_SIZEOF_HASHVALUE - SSA_SIZEOF_KEY_CHECKSUM], SSA_SIZEOF_KEY_CHECKSUM);
    }

    if (retVal == RTE_E_OK)
    {
      retVal = Rte_Call_SsaCdd_Keys_KeySetValid(Ssa_GetKeyIdOfDataIdInfo(localPduId));
    }

    /* If not successful leave loop.
       So, in the busy case localPduId identifies the PDU ID which the generation stopped for
       and which is the PDU ID that generation shall proceed with. */
    if (retVal != RTE_E_OK)
    {
      break;
    }
  }

  /* check for busy in order to retry generation */
  KeyM_GenerateAndStoreSecOcKeys_RetryCheck(&retVal, &KeyM_MainLoopProc.counterRetry);

  /* the number of keys generated also identifies the key to proceed in next main function call */
  KeyM_MainLoopProc.numGenSymKeys = localPduId;

  return retVal;
}

/**********************************************************************************************************************
 *  KeyM_GenerateAndStoreSecOcKeys_RetryCheck()
 **********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 */
SSA_KEYM_LOCAL_INLINE FUNC(void, Ssa_KeyM_CODE) KeyM_GenerateAndStoreSecOcKeys_RetryCheck(
  P2VAR(Std_ReturnType, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) retVal,
  P2VAR(uint16, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) retryCounter)
{
  if ((*retVal == RTE_E_SsaCdd_Csm_KeyInterface_E_BUSY) &&
    (*retryCounter > 0u))
  {
   (*retryCounter)--;
    *retVal = RTE_E_OK;
  }
  else
  {
    /* reset the retry counter */
    *retryCounter = SSA_KEYM_NUMBER_RETRIES_KEY_GENERATION;
  }
}

/**********************************************************************************************************************
 *  KeyM_CalculateAndStoreCipherKey()
 **********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 */
SSA_KEYM_LOCAL_INLINE FUNC(Std_ReturnType, Ssa_KeyM_CODE) KeyM_CalculateAndStoreCipherKey(
  P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) nonce)
{
  uint8 ecdhSharedSecret[SSA_SIZEOF_NONCE + SSA_SIZEOF_KEY_EXCHANGE_SECRET];
  uint32 ecdhSharedSecretLength = SSA_SIZEOF_KEY_EXCHANGE_SECRET;
  Std_ReturnType retVal;

  /* #10 Get the shared secret. */
  retVal = Rte_Call_Key_SharedSecretKeyExchange_KeyElementGet(SSA_KE_KEYEXCHANGE_SHAREDVALUE, &ecdhSharedSecret[SSA_SIZEOF_NONCE], &ecdhSharedSecretLength);
  if ((retVal != E_OK) || (ecdhSharedSecretLength != SSA_SIZEOF_KEY_EXCHANGE_SECRET))
  {
    retVal = E_NOT_OK;
  }
  else
  {
    uint8 hashResult[SSA_SIZEOF_HASHVALUE];
    uint32 hashResultLength = SSA_SIZEOF_HASHVALUE;

    /* #20 Calculate the hash from the concatenation of the given nonce and the previously calculated ECDH shared secret. */
    Ssa_MemCpy((P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR))ecdhSharedSecret, nonce, SSA_SIZEOF_NONCE);
    retVal = Rte_Call_SsaCdd_Csm_Hash(SSA_KEYM_HASH_JOB_ID, CRYPTO_OPERATIONMODE_SINGLECALL, ecdhSharedSecret, SSA_SIZEOF_NONCE + SSA_SIZEOF_KEY_EXCHANGE_SECRET, hashResult, &hashResultLength);

    /* #30 Clear the shared secret RAM buffer content immediately afterwards. */
    KeyM_ClearDataBuffer(ecdhSharedSecret, SSA_SIZEOF_NONCE + SSA_SIZEOF_KEY_EXCHANGE_SECRET, SSA_SIZEOF_NONCE + SSA_SIZEOF_KEY_EXCHANGE_SECRET);

    if ((retVal != E_OK) || (hashResultLength != SSA_SIZEOF_HASHVALUE))
    {
      retVal = E_NOT_OK;
    }
    else
    {
      /* #40 Use the 128 most significant bits of the calculated hash value as symmetric cipher key and store it. */
      retVal = Rte_Call_Key_AesRamKey_KeyElementSet(SSA_KE_CIPHER_KEY, hashResult, SSA_SIZEOF_SYMKEY);

      /* #50 Use the 128 least significant bits of the calculated hash as IV and store it. */
      retVal |= Rte_Call_Key_AesRamKey_KeyElementSet(SSA_KE_CIPHER_IV, &(hashResult[SSA_SIZEOF_HASHVALUE - SSA_SIZEOF_SYMKEY]), SSA_SIZEOF_SYMKEY);
      retVal |= Rte_Call_Key_AesRamKey_KeySetValid();

      /* #60 Clear the hashResult RAM buffer content immediately afterwards. */
      KeyM_ClearDataBuffer(hashResult, SSA_SIZEOF_HASHVALUE, SSA_SIZEOF_HASHVALUE);
    }
  }

  return retVal;
}

/**********************************************************************************************************************
 * KeyM_GetSerialNumberFromCert()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
SSA_KEYM_LOCAL FUNC(Std_ReturnType, Ssa_KeyM_CODE) KeyM_GetSerialNumberFromCert(
  P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) certificate,
  P2CONST(CertP_BerElementType, AUTOMATIC, AUTOMATIC) certSerialNumber,
  P2VAR(uint8, AUTOMATIC, AUTOMATIC) serialNumber,
  uint16 serialNumberLength)
{
  Std_ReturnType retVal;

  /* #10 Copy the serial number right-aligned into the output buffer of fixed size and prepend leading zeros if required. */
  retVal = Ssa_Utils_ConvertSerialNumber(&certificate[certSerialNumber->elemDataIdx], certSerialNumber->elemDataLength,
                                    serialNumber, serialNumberLength);

  return retVal;
}

/**********************************************************************************************************************
 * Trust Model Functions
 *********************************************************************************************************************/

/**********************************************************************************************************************
 * KeyM_KeyM_CheckCertificateStatus()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
SSA_KEYM_LOCAL FUNC(KeyM_CertificateStatusType, Ssa_KeyM_CODE) KeyM_KeyM_CheckCertificateStatus(
  KeyM_CertificateIdType CertId,
  P2VAR(Dcm_NegativeResponseCodeType, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) ErrorCode)
{
  Std_ReturnType retVal;
  Dcm_NegativeResponseCodeType errorCode = DCM_E_POSITIVERESPONSE;
  KeyM_CertificateStatusType certificateStatus = KEYM_CERTIFICATE_INVALID;

  /* #10 Get the certificate's status. */
  retVal = KeyM_KeyM_CertGetStatus(CertId, &certificateStatus);
  if (retVal != RTE_E_OK)
  {
    errorCode = DCM_E_GENERALREJECT;
    certificateStatus = KEYM_CERTIFICATE_INVALID;
  }
  else if (certificateStatus == KEYM_CERTIFICATE_NOT_AVAILABLE)
  {
    errorCode = DCM_E_CONDITIONSNOTCORRECT;
  }
  else
  {
    /* no action */
  }

  if (errorCode != DCM_E_POSITIVERESPONSE)
  {
    *ErrorCode = errorCode;
  }

  return certificateStatus;
}

/**********************************************************************************************************************
 * KeyM_KeyM_CertificateIsReadable()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 */
SSA_KEYM_LOCAL_INLINE FUNC(boolean, Ssa_KeyM_CODE) KeyM_KeyM_CertificateIsReadable(
  KeyM_CertificateIdType CertId,
  P2VAR(Dcm_NegativeResponseCodeType, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) ErrorCode)
{
  boolean readable;
  Dcm_NegativeResponseCodeType errorCode = DCM_E_POSITIVERESPONSE;

  /* #10 Check if KeyM_KeyM_CheckCertificateStatus reports an error. */
  (void)KeyM_KeyM_CheckCertificateStatus(CertId, &errorCode);

  if (errorCode == DCM_E_POSITIVERESPONSE)
  {
    /* #20 If no error code was returned, return TRUE. */
    readable = TRUE;
  }
  else
  {
    /* #30 If an error code was returned, return FALSE and set *ErrorCode accordingly. */
    readable = FALSE;
    *ErrorCode = errorCode;
  }

  return readable;
}

/**********************************************************************************************************************
 * KeyM_DestroyTrustModelEcuCert()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 */
SSA_KEYM_LOCAL_INLINE FUNC(void, Ssa_KeyM_CODE) KeyM_DestroyTrustModelEcuCert(void)
{
  uint8 dummy;
  Ssa_KeyM_CertDataType cert;

  /* #10 Generate empty certificate. */
  cert.certDataLength = 0;
  cert.certData = &dummy;

  /* #20 Set empty cert in AsrKeyM to erase the ECU certificate. */
  (void)KeyM_KeyM_SetCertificate(SSA_TRUST_MODEL_ECU_CERT_ID, &cert);
}

/**********************************************************************************************************************
 * KeyM_KeyM_GetCertificateDataAsIteration()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 */
SSA_KEYM_LOCAL FUNC(Std_ReturnType, Ssa_KeyM_CODE) KeyM_KeyM_GetCertificateDataAsIteration(
  KeyM_CertificateIdType CertId,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) Data,
  P2VAR(uint16, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) DataLength)
{
  Std_ReturnType retVal = E_NOT_OK;
  uint32 usableDataLength;
  if (*DataLength >= 2u)
  {
    /* #10 Prepare buffer where certificate data and its length shall be written to. */
    usableDataLength = (uint32)((uint32)*DataLength - (uint32)2u);

    /* #20 Get certificate data from KeyM. */
    if (Rte_Call_SsaCdd_TrustModel_GetCertificate(CertId, &Data[2u], &usableDataLength) == RTE_E_OK)
    {
      /* #30 Prepend length information */
      Data[0] = KeyM_GetUint16HiByte((uint16)(usableDataLength));
      Data[1] = KeyM_GetUint16LoByte((uint16)(usableDataLength));
      *DataLength = (uint16)usableDataLength + 2u;
      retVal = E_OK;
    }
  }

  return retVal;
}

/**********************************************************************************************************************
 * KeyM_GetNextIteration()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
SSA_KEYM_LOCAL FUNC(Std_ReturnType, Ssa_KeyM_CODE) KeyM_GetNextIteration(
  P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) dataBuffer,
  uint16 dataBufferLength,
  P2VAR(uint32, AUTOMATIC, AUTOMATIC) dataIdx,
  P2VAR(uint16, AUTOMATIC, AUTOMATIC) iterIdx,
  P2VAR(uint16, AUTOMATIC, AUTOMATIC) iterLength
  )
{
  Std_ReturnType retVal = E_NOT_OK;

  /* #10 Get next iteration. */
  if ((uint32)dataBufferLength >= (*dataIdx + 2u))
  {
    /* get iteration length and index */
    *iterLength = KeyM_GetUint16(dataBuffer[*dataIdx], dataBuffer[*dataIdx + 1u]);
    *iterIdx = (uint16)*dataIdx + 2u;

    /* check that iteration is within provided buffer */
    *dataIdx = (uint32)*iterIdx + (uint32)*iterLength;
    if (*dataIdx <= (uint32)dataBufferLength)
    {
      retVal = E_OK;
    }
  }

  return retVal;
}

/**********************************************************************************************************************
 * KeyM_AddNextIteration()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
SSA_KEYM_LOCAL FUNC(Std_ReturnType, Ssa_KeyM_CODE) KeyM_AddNextIteration(
  KeyM_CertificateIdType CertId,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) bufferIn,
  uint32 bufferInLength,
  P2VAR(uint32, AUTOMATIC, AUTOMATIC) dataIdx)
{
  Std_ReturnType retVal = E_NOT_OK;
  Ssa_KeyM_CertDataType certificate;
  if (bufferInLength >= (*dataIdx + 2u))
  {
    /* #10 Get certificate data for given identifier from AsrKeyM and add it as next iteration into given buffer. */
    certificate.certData = &bufferIn[*dataIdx + 2u];
    certificate.certDataLength = (uint32)(bufferInLength - *dataIdx - 2u);
    if (KeyM_KeyM_GetCertificate(CertId, &certificate) == E_OK)
    {
      bufferIn[*dataIdx] = (uint8)(certificate.certDataLength >> 8u);
      bufferIn[*dataIdx + 1u] = (uint8)(certificate.certDataLength & 0xFFu);
      *dataIdx += 2u + certificate.certDataLength;
      retVal = E_OK;
    }
  }

  return retVal;
}

/**********************************************************************************************************************
 * KeyM_CheckRequestersAuthorization()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
SSA_KEYM_LOCAL FUNC(boolean, Ssa_KeyM_CODE) KeyM_CheckRequestersAuthorization(P2CONST(uint8, AUTOMATIC, RTE_SSA_RIGHTSM_APPL_DATA) subjectKeyIdentifier)
{
  boolean authorizationApprovalFlag = FALSE;
  Std_ReturnType retVal;

  /* #10 The requester is authorized if
   *     the subjectKeyIdentifier of the received ECU certificate can be verified successfully
   *     OR
   *     the requester is authenticated as diagnostic user production AND the post production status is not activated */

  /* #20 Verify subject key identifier from ECU certificate */
  if (Rte_Call_RightsM_EnhancedRights_VerifySubjectKeyIdentifier(subjectKeyIdentifier) != RTE_E_OK)
  {
    RightsM_DiagnosticUserRoleType userRole;
    Ssa_PostProductionStatusType postProductionStatus = SSA_POST_PRODUCTION_STATUS_IRREVERSIBLY_ACTIVATED;

    /* #40 Check diagnostic user role for PRODUCTION */
    retVal = Rte_Call_RightsM_DiagnosticChannel_GetDiagnosticUserRole(&userRole);
    if ((retVal == RTE_E_OK) && (userRole == RIGHTSM_USERROLE_PRODUCTION))
    {
      /* #50 Check post production status for being NOT activated */
      retVal = Rte_Call_RightsM_DiagnosticChannel_GetPostProductionStatus(&postProductionStatus);
      if ((retVal == RTE_E_OK) && (postProductionStatus == SSA_POST_PRODUCTION_STATUS_DEACTIVATED))
      {
        /* requester is authorized to proceed */
        authorizationApprovalFlag = TRUE;
      }
    }
  }
  else
  {
    /* SubjectKeyId could be verified: requester is authorized to proceed */
    authorizationApprovalFlag = TRUE;
  }

  return authorizationApprovalFlag;
}

/**********************************************************************************************************************
 * KeyM_ReplaceCertificate_MapCertificateStatusToVerificationResult()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 */
SSA_KEYM_LOCAL FUNC(void, Ssa_KeyM_CODE) KeyM_ReplaceCertificate_MapCertificateStatusToVerificationResult(
  CertP_PkiRoleType pkiRole,
  KeyM_CertificateStatusType certificateStatus,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) Verification_Result_Out)
{
  /* #10 Map AsrKeyM certificate status to verification result depending on PKI role. */
  switch (pkiRole)
  {
  case  CERTP_PKI_ROLE_TRUST_MODEL_BACKEND_CA:
    switch (certificateStatus)
    {
    case KEYM_E_CERTIFICATE_VALIDITY_PERIOD_FAIL:
      *Verification_Result_Out = SSA_VER_RES_TRUST_MODEL_REPLACE_CERTS_BACKEND_CERTIFICATE_VERIFICATION_FAILED_INVALID_TIME_PERIOD;
      break;
    case KEYM_E_CERTIFICATE_SIGNATURE_FAIL:
      *Verification_Result_Out = SSA_VER_RES_TRUST_MODEL_REPLACE_CERTS_BACKEND_CERTIFICATE_VERIFICATION_FAILED_INVALID_SIGNATURE;
      break;
    case KEYM_E_CERTIFICATE_INVALID_CHAIN_OF_TRUST:
      *Verification_Result_Out = SSA_VER_RES_TRUST_MODEL_REPLACE_CERTS_BACKEND_CERTIFICATE_VERIFICATION_FAILED_INVALID_CHAIN_OF_TRUST;
      break;
    case KEYM_E_CERTIFICATE_INVALID_TYPE:
      *Verification_Result_Out = SSA_VER_RES_TRUST_MODEL_REPLACE_CERTS_BACKEND_CERTIFICATE_VERIFICATION_FAILED_INVALID_TYPE;
      break;
    case KEYM_E_CERTIFICATE_INVALID_FORMAT:
      *Verification_Result_Out = SSA_VER_RES_TRUST_MODEL_REPLACE_CERTS_BACKEND_CERTIFICATE_VERIFICATION_FAILED_INVALID_FORMAT;
      break;
    case KEYM_E_CERTIFICATE_INVALID_CONTENT:
      *Verification_Result_Out = SSA_VER_RES_TRUST_MODEL_REPLACE_CERTS_BACKEND_CERTIFICATE_VERIFICATION_FAILED_INVALID_CONTENT;
      break;
    default:
      /* according to SSA-IS-2655 */
      *Verification_Result_Out = SSA_VER_RES_TRUST_MODEL_REPLACE_CERTS_BACKEND_CERTIFICATE_VERIFICATION_FAILED_INVALID_CHAIN_OF_TRUST;
      break;
    }
    break;

  case  CERTP_PKI_ROLE_TRUST_MODEL_INTERMEDIATE_CA:
    switch (certificateStatus)
    {
    case KEYM_E_CERTIFICATE_VALIDITY_PERIOD_FAIL:
      *Verification_Result_Out = SSA_VER_RES_TRUST_MODEL_REPLACE_CERTS_INTERMEDIATE_CERTIFICATE_VERIFICATION_FAILED_INVALID_TIME_PERIOD;
      break;
    case KEYM_E_CERTIFICATE_SIGNATURE_FAIL:
      *Verification_Result_Out = SSA_VER_RES_TRUST_MODEL_REPLACE_CERTS_INTERMEDIATE_CERTIFICATE_VERIFICATION_FAILED_INVALID_SIGNATURE;
      break;
    case KEYM_E_CERTIFICATE_INVALID_CHAIN_OF_TRUST:
      *Verification_Result_Out = SSA_VER_RES_TRUST_MODEL_REPLACE_CERTS_INTERMEDIATE_CERTIFICATE_VERIFICATION_FAILED_INVALID_CHAIN_OF_TRUST;
      break;
    case KEYM_E_CERTIFICATE_INVALID_TYPE:
      *Verification_Result_Out = SSA_VER_RES_TRUST_MODEL_REPLACE_CERTS_INTERMEDIATE_CERTIFICATE_VERIFICATION_FAILED_INVALID_TYPE;
      break;
    case KEYM_E_CERTIFICATE_INVALID_FORMAT:
      *Verification_Result_Out = SSA_VER_RES_TRUST_MODEL_REPLACE_CERTS_INTERMEDIATE_CERTIFICATE_VERIFICATION_FAILED_INVALID_FORMAT;
      break;
    case KEYM_E_CERTIFICATE_INVALID_CONTENT:
      *Verification_Result_Out = SSA_VER_RES_TRUST_MODEL_REPLACE_CERTS_INTERMEDIATE_CERTIFICATE_VERIFICATION_FAILED_INVALID_CONTENT;
      break;
    default:
      /* according to SSA-IS-2655 */
      *Verification_Result_Out = SSA_VER_RES_TRUST_MODEL_REPLACE_CERTS_INTERMEDIATE_CERTIFICATE_VERIFICATION_FAILED_INVALID_CHAIN_OF_TRUST;
      break;
    }
    break;

  default:
  /* case  CERTP_PKI_ROLE_TRUST_MODEL_ECU: */
    switch (certificateStatus)
    {
    case KEYM_E_CERTIFICATE_VALIDITY_PERIOD_FAIL:
      *Verification_Result_Out = SSA_VER_RES_TRUST_MODEL_REPLACE_CERTS_ECU_CERTIFICATE_VERIFICATION_FAILED_INVALID_TIME_PERIOD;
      break;
    case KEYM_E_CERTIFICATE_SIGNATURE_FAIL:
      *Verification_Result_Out = SSA_VER_RES_TRUST_MODEL_REPLACE_CERTS_ECU_CERTIFICATE_VERIFICATION_FAILED_INVALID_SIGNATURE;
      break;
    case KEYM_E_CERTIFICATE_INVALID_CHAIN_OF_TRUST:
      *Verification_Result_Out = SSA_VER_RES_TRUST_MODEL_REPLACE_CERTS_ECU_CERTIFICATE_VERIFICATION_FAILED_INVALID_CHAIN_OF_TRUST;
      break;
    case KEYM_E_CERTIFICATE_INVALID_TYPE:
      *Verification_Result_Out = SSA_VER_RES_TRUST_MODEL_REPLACE_CERTS_ECU_CERTIFICATE_VERIFICATION_FAILED_INVALID_TYPE;
      break;
    case KEYM_E_CERTIFICATE_INVALID_FORMAT:
      *Verification_Result_Out = SSA_VER_RES_TRUST_MODEL_REPLACE_CERTS_ECU_CERTIFICATE_VERIFICATION_FAILED_INVALID_FORMAT;
      break;
    case KEYM_E_CERTIFICATE_INVALID_CONTENT:
      *Verification_Result_Out = SSA_VER_RES_TRUST_MODEL_REPLACE_CERTS_ECU_CERTIFICATE_VERIFICATION_FAILED_INVALID_CONTENT;
      break;
    default:
      /* according to SSA-IS-2655 */
      *Verification_Result_Out = SSA_VER_RES_TRUST_MODEL_REPLACE_CERTS_ECU_CERTIFICATE_VERIFICATION_FAILED_INVALID_CHAIN_OF_TRUST;
      break;
    }
    break;
  }
}  /* PRQA S 6030 */ /* MD_SSA_CYC_VERIFICATION_RESULT_MAPPING */

/**********************************************************************************************************************
 * KeyM_KeepCurrentCertificates()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
SSA_KEYM_LOCAL_INLINE FUNC(void, Ssa_KeyM_CODE) KeyM_KeepCurrentCertificates(void)
{
  Std_ReturnType retVal;

  KeyM_DiagProc.ws.trustModelReplaceCerts.rollbackState = SSA_KEYM_NO_ROLLBACK;

  /* #10 Get status of certificates and only if all certificates are available keep them static. */
  retVal = KeyM_KeyM_CertGetStatus(SSA_TRUST_MODEL_BACKEND_CERT_ID, &KeyM_DiagProc.ws.trustModelReplaceCerts.certificateStatusBackend);
  retVal |= KeyM_KeyM_CertGetStatus(SSA_TRUST_MODEL_INTERMEDIATE_CERT_ID, &KeyM_DiagProc.ws.trustModelReplaceCerts.certificateStatusIntermediate);
  retVal |= KeyM_KeyM_CertGetStatus(SSA_TRUST_MODEL_ECU_CERT_ID, &KeyM_DiagProc.ws.trustModelReplaceCerts.certificateStatusEcu);
  if ((retVal == E_OK)
    && (KeyM_DiagProc.ws.trustModelReplaceCerts.certificateStatusBackend != KEYM_CERTIFICATE_NOT_AVAILABLE)
    && (KeyM_DiagProc.ws.trustModelReplaceCerts.certificateStatusIntermediate != KEYM_CERTIFICATE_NOT_AVAILABLE)
    && (KeyM_DiagProc.ws.trustModelReplaceCerts.certificateStatusEcu != KEYM_CERTIFICATE_NOT_AVAILABLE))
  {
    uint32 idx = 0;
    retVal = KeyM_AddNextIteration(SSA_TRUST_MODEL_ECU_CERT_ID, KeyM_DiagProc.ws.trustModelReplaceCerts.trustCertificatesBackup, sizeof(Dcm_Data3006ByteType), &idx);
    retVal |= KeyM_AddNextIteration(SSA_TRUST_MODEL_INTERMEDIATE_CERT_ID, KeyM_DiagProc.ws.trustModelReplaceCerts.trustCertificatesBackup, sizeof(Dcm_Data3006ByteType), &idx);
    retVal |= KeyM_AddNextIteration(SSA_TRUST_MODEL_BACKEND_CERT_ID, KeyM_DiagProc.ws.trustModelReplaceCerts.trustCertificatesBackup, sizeof(Dcm_Data3006ByteType), &idx);
    if (retVal == E_OK)
    {
      /* idx is smaller than sizeof(Dcm_Data3006ByteType) */
      KeyM_DiagProc.ws.trustModelReplaceCerts.dataLengthBackup = (uint16)idx;
      KeyM_DiagProc.ws.trustModelReplaceCerts.rollbackState = SSA_KEYM_ROLLBACK_POSSIBLE;
    }
  }
}

/**********************************************************************************************************************
 * KeyM_ReplaceTrustModelCerts_HandleStateIdle()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 */
/* PRQA S 3673 7 */ /* MD_SSA_PARAM_NOT_P2CONST */
SSA_KEYM_LOCAL FUNC(Std_ReturnType, Ssa_KeyM_CODE) KeyM_ReplaceTrustModelCerts_HandleStateIdle(
  P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) Trust_Certificates_In,
  Dcm_OpStatusType OpStatus,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) routineInfo_Out,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) Verification_Result_Out,
  uint16 DataLength,
  P2VAR(Dcm_NegativeResponseCodeType, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) ErrorCode)
{
  Std_ReturnType retVal;
  uint16 certLength_ecu, certLength_intermediate, certLength_backend;
  uint16 certIdx_ecu, certIdx_intermediate, certIdx_backend;
  uint32 dataIdx = 0u;

  SSA_DUMMY_STATEMENT(OpStatus);   /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */
  SSA_DUMMY_STATEMENT(routineInfo_Out);   /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */
  SSA_DUMMY_STATEMENT(Verification_Result_Out);   /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */

  /* #10 Initially get length and indices of provided certificates. */
  /* NOTE: check if this can be done once in DCM_INITIAL */
  if (KeyM_GetNextIteration(
    Trust_Certificates_In, DataLength, &dataIdx, &certIdx_ecu, &certLength_ecu) == E_NOT_OK)
  {
    retVal = RTE_E_RoutineServices_Replace_Trust_model_Certificates_E_NOT_OK;
    *ErrorCode = DCM_E_INCORRECTMESSAGELENGTHORINVALIDFORMAT;
  }
  else if (KeyM_GetNextIteration(
    Trust_Certificates_In, DataLength, &dataIdx, &certIdx_intermediate, &certLength_intermediate) == E_NOT_OK)
  {
    retVal = RTE_E_RoutineServices_Replace_Trust_model_Certificates_E_NOT_OK;
    *ErrorCode = DCM_E_INCORRECTMESSAGELENGTHORINVALIDFORMAT;
  }
  else if (KeyM_GetNextIteration(
    Trust_Certificates_In, DataLength, &dataIdx, &certIdx_backend, &certLength_backend) == E_NOT_OK)
  {
    retVal = RTE_E_RoutineServices_Replace_Trust_model_Certificates_E_NOT_OK;
    *ErrorCode = DCM_E_INCORRECTMESSAGELENGTHORINVALIDFORMAT;
  }
  else if ((certLength_ecu > SSA_MAX_SIZE_TRUSTMODEL_ECU_CERT) || (certLength_intermediate > SSA_MAX_SIZE_TRUSTMODEL_INTERMEDIATE_CA_CERT) || (certLength_backend > SSA_MAX_SIZE_TRUSTMODEL_BACKEND_CA_CERT))
  {
    retVal = RTE_E_RoutineServices_Replace_Trust_model_Certificates_E_NOT_OK;
    *ErrorCode = DCM_E_INCORRECTMESSAGELENGTHORINVALIDFORMAT;
  }
  else /* #20 If the lengths and indices could be obtained successfully: */
  {
    /* #30 Store the lengths and indices statically. */
    KeyM_DiagProc.ws.trustModelReplaceCerts.certIdx_ecu             = certIdx_ecu;
    KeyM_DiagProc.ws.trustModelReplaceCerts.certLength_ecu          = certLength_ecu;
    KeyM_DiagProc.ws.trustModelReplaceCerts.certIdx_intermediate    = certIdx_intermediate;
    KeyM_DiagProc.ws.trustModelReplaceCerts.certLength_intermediate = certLength_intermediate;
    KeyM_DiagProc.ws.trustModelReplaceCerts.certIdx_backend         = certIdx_backend;
    KeyM_DiagProc.ws.trustModelReplaceCerts.certLength_backend      = certLength_backend;

    /* #40 Try to clear the certificate data of complete chain from RAM so that AsrKeyM hopefully does not check the chain
     * downward which is not needed but consumes much time. */
    KeyM_DestroyTrustModelEcuCert();

    /* #50 Set or update the Trust Model Backend CA certificate at AsrKeyM depending on its status. */
    KeyM_DiagProc.state = SSA_KEYM_REPLACE_TRUST_MODEL_CERTS_STATE_REQUESTING_SERVICE_CERT_BACKEND;

    /* call the state handler directly to reduce latency */
    retVal = KeyM_ReplaceTrustModelCerts_HandleStateRequestingServiceCertBackend(
        Trust_Certificates_In, OpStatus, routineInfo_Out, Verification_Result_Out, DataLength, ErrorCode);
  }

  return retVal;
} /* PRQA S 6060 */ /* MD_MSR_MD_MSR_STPAR */

/**********************************************************************************************************************
 * KeyM_ReplaceTrustModelCerts_HandleStateRequestingServiceCertBackend()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 */
/* PRQA S 3673 7 */ /* MD_SSA_PARAM_NOT_P2CONST */
SSA_KEYM_LOCAL FUNC(Std_ReturnType, Ssa_KeyM_CODE) KeyM_ReplaceTrustModelCerts_HandleStateRequestingServiceCertBackend(
  P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) Trust_Certificates_In,
  Dcm_OpStatusType OpStatus,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) routineInfo_Out,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) Verification_Result_Out,
  uint16 DataLength,
  P2VAR(Dcm_NegativeResponseCodeType, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) ErrorCode)
{
  Std_ReturnType retVal;
  KeyM_CertificateStatusType certificateStatus = KEYM_CERTIFICATE_INVALID;

  SSA_DUMMY_STATEMENT(OpStatus);   /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */
  SSA_DUMMY_STATEMENT(routineInfo_Out);   /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */
  SSA_DUMMY_STATEMENT(Verification_Result_Out);   /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */
  SSA_DUMMY_STATEMENT(DataLength);   /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */

  /* #10 Prepare asynchronous service certificate call */
  KeyM_DiagProc.serviceResponseCallbackOccurred = FALSE;

  /* #20 Set or update the Trust Model Backend CA certificate at AsrKeyM depending on its status */
  /*@ assert KeyM_TrustModelBackendCertName() != NULL_PTR; */
  /*@ assert &Trust_Certificates_In[KeyM_DiagProc.ws.trustModelReplaceCerts.certIdx_backend] != NULL_PTR; */ /* VCA_SSA_KEYM_ACCESS_TRUST_CERTIFICATES_IN_AT_IDX */
  /*@ assert KeyM_DiagProc.serviceResponseBuffer != NULL_PTR; */
  /*@ assert $lengthOf(KeyM_DiagProc.serviceResponseBuffer) >= sizeof(KeyM_DiagProc.serviceResponseBuffer); */
  (void)KeyM_KeyM_CertGetStatus(SSA_TRUST_MODEL_BACKEND_CERT_ID, &certificateStatus);
  retVal = Rte_Call_SsaCdd_TrustModel_ServiceCertificate( /* VCA_SSA_KEYM_ACCESS_TRUST_CERTIFICATES_IN_AT_IDX */
      (certificateStatus == KEYM_CERTIFICATE_NOT_AVAILABLE) ? KEYM_SERVICE_CERT_SET_INTERMEDIATE
                                                            : KEYM_SERVICE_CERT_UPDATE_INTERMEDIATE,
      KeyM_TrustModelBackendCertName(),
      KeyM_TrustModelBackendCertNameLength(),
      &Trust_Certificates_In[KeyM_DiagProc.ws.trustModelReplaceCerts.certIdx_backend],
      KeyM_DiagProc.ws.trustModelReplaceCerts.certLength_backend,
      KeyM_DiagProc.serviceResponseBuffer,
      sizeof(KeyM_DiagProc.serviceResponseBuffer));

  /* #30 Advance to AWAITING_VERIFICATION_RESULT_BACKEND_CERT if the Backend CA certificate was accepted by the
   *     AUTOSAR KeyM
   */
  switch (retVal)
  {
    case RTE_E_OK: /* proceed with next state */
      KeyM_DiagProc.state = SSA_KEYM_REPLACE_TRUST_MODEL_CERTS_STATE_AWAITING_VERIFICATION_RESULT_BACKEND_CERT;
      retVal              = RTE_E_RoutineServices_Replace_Trust_model_Certificates_DCM_E_PENDING;
      break;

    case RTE_E_SsaCdd_KeyM_CertInterface_KEYM_E_BUSY: /* remain in current state and retry */
      retVal = RTE_E_RoutineServices_Replace_Trust_model_Certificates_DCM_E_PENDING;
      break;

    case RTE_E_SsaCdd_KeyM_CertInterface_KEYM_E_KEY_CERT_SIZE_MISMATCH:
      *Verification_Result_Out = SSA_VER_RES_TRUST_MODEL_REPLACE_CERTS_BACKEND_CERTIFICATE_VERIFICATION_FAILED_INVALID_FORMAT;
      /* finish routine */
      retVal = RTE_E_OK;
      KeyM_DiagProc.state = SSA_KEYM_REPLACE_TRUST_MODEL_CERTS_STATE_IDLE;
      /* Log failed Trust Model certififcate verification event */
      KeyM_LogTrustModelCertificateVerificationResult(SSA_TRUST_MODEL_BACKEND_CERT_ID, *Verification_Result_Out);
      break;

    case RTE_E_SsaCdd_KeyM_CertInterface_KEYM_E_CERT_INVALID_CHAIN_OF_TRUST:
    case RTE_E_SsaCdd_KeyM_CertInterface_E_NOT_OK:
    {
      certificateStatus = KEYM_CERTIFICATE_VALID;
      /* get the certificate's status. */
      (void)KeyM_KeyM_CertGetStatus(SSA_TRUST_MODEL_BACKEND_CERT_ID, &certificateStatus);
      /* map status to verification result */
      KeyM_ReplaceCertificate_MapCertificateStatusToVerificationResult(CERTP_PKI_ROLE_TRUST_MODEL_BACKEND_CA, certificateStatus, Verification_Result_Out);
      /* finish routine */
      KeyM_DiagProc.state = SSA_KEYM_REPLACE_TRUST_MODEL_CERTS_STATE_IDLE;
      /* Log failed Trust Model certififcate verification event */
      KeyM_LogTrustModelCertificateVerificationResult(SSA_TRUST_MODEL_BACKEND_CERT_ID, *Verification_Result_Out);
      retVal = RTE_E_OK;
      break;
    }

    /* RTE_E_SsaCdd_KeyM_CertInterface_KEYM_E_PARAMETER_MISMATCH - wrong key slot */
    /* RTE_E_SsaCdd_KeyM_CertInterface_KEYM_E_KEY_CERT_EMPTY - no data in key slot */
    default: /* finish diagnostic routine */
      KeyM_DiagProc.state = SSA_KEYM_REPLACE_TRUST_MODEL_CERTS_STATE_IDLE;
      retVal              = RTE_E_RoutineServices_Replace_Trust_model_Certificates_E_NOT_OK;
      *ErrorCode          = DCM_E_CONDITIONSNOTCORRECT;
      break;
  }

  return retVal;
} /* PRQA S 6060 */ /* MD_MSR_MD_MSR_STPAR */

/**********************************************************************************************************************
 * KeyM_ReplaceTrustModelCerts_AwaitingVerificationResultBackendCert()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 */
/* PRQA S 3673 7 */ /* MD_SSA_PARAM_NOT_P2CONST */
SSA_KEYM_LOCAL FUNC(Std_ReturnType, Ssa_KeyM_CODE) KeyM_ReplaceTrustModelCerts_AwaitingVerificationResultBackendCert(
  P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) Trust_Certificates_In,
  Dcm_OpStatusType OpStatus,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) routineInfo_Out,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) Verification_Result_Out,
  uint16 DataLength,
  P2VAR(Dcm_NegativeResponseCodeType, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) ErrorCode)
{
  Std_ReturnType retVal = RTE_E_RoutineServices_Replace_Trust_model_Certificates_DCM_E_PENDING;

  SSA_DUMMY_STATEMENT(OpStatus);   /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */
  SSA_DUMMY_STATEMENT(routineInfo_Out);   /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */
  SSA_DUMMY_STATEMENT(DataLength);   /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */

  /* #10 Wait for callback of the service certificate request for setting/updating the Trust Model Backend CA certificate. */
  if (KeyM_DiagProc.serviceResponseCallbackOccurred)
  {
    /* #20 Check the result. */
    switch (KeyM_DiagProc.serviceResponseCallbackResult)
    {
      /* #30 If verification passed set or update Trust Model Intermediate CA certificate at the AsrKeyM depending on its status. */
      case KEYM_RT_OK:
      {
        /* Backend certificate has been verified by the KeyM */
        /* #31 Do additional verification of certificate entries not verified by KeyM. */
        uint8 localRet;
        KeyM_CertificateStatusType localCertStatus = KEYM_CERTIFICATE_INVALID;
        localRet = KeyM_TrustModel_AdditionalVerificationOfCertificateEntries_SingleCertificate(SSA_TRUST_MODEL_BACKEND_CERT_ID, SSA_TRUST_MODEL_ROOT_CERT_ID, &localCertStatus);

        if ((localRet != E_OK) || (localCertStatus != KEYM_CERTIFICATE_VALID))  /* additional verification failed */
        {
          /* finish routine */
          retVal = RTE_E_OK;
          KeyM_DiagProc.state = SSA_KEYM_REPLACE_TRUST_MODEL_CERTS_STATE_IDLE;

          /* map localCertStatus to verification result */
          KeyM_ReplaceCertificate_MapCertificateStatusToVerificationResult(CERTP_PKI_ROLE_TRUST_MODEL_BACKEND_CA, localCertStatus, Verification_Result_Out);
          /* Log failed Trust Model certififcate verification event */
          KeyM_LogTrustModelCertificateVerificationResult(SSA_TRUST_MODEL_BACKEND_CERT_ID, *Verification_Result_Out);
        }
        else /* additional verification succeeded */
        {
          KeyM_CertificateStatusType certificateStatus = KEYM_CERTIFICATE_INVALID;
          /* Log successful Trust Model certififcate verification event */
          KeyM_LogTrustModelCertificateVerificationResult(SSA_TRUST_MODEL_BACKEND_CERT_ID, 0u);
          (void)KeyM_KeyM_CertGetStatus(SSA_TRUST_MODEL_INTERMEDIATE_CERT_ID, &certificateStatus);
          /* prepare asynchronous service certificate call */
          KeyM_DiagProc.serviceResponseCallbackOccurred = FALSE;
          /* set certificate */
          /*@ assert KeyM_TrustModelIntermediateCertName() != NULL_PTR; */
          /*@ assert &Trust_Certificates_In[KeyM_DiagProc.ws.trustModelReplaceCerts.certIdx_intermediate] != NULL_PTR; */ /* VCA_SSA_KEYM_ACCESS_TRUST_CERTIFICATES_IN_AT_IDX */
          /*@ assert KeyM_DiagProc.serviceResponseBuffer != NULL_PTR; */
          /*@ assert $lengthOf(KeyM_DiagProc.serviceResponseBuffer) >= sizeof(KeyM_DiagProc.serviceResponseBuffer); */
          retVal = Rte_Call_SsaCdd_TrustModel_ServiceCertificate( /* VCA_SSA_KEYM_ACCESS_TRUST_CERTIFICATES_IN_AT_IDX */
            (certificateStatus == KEYM_CERTIFICATE_NOT_AVAILABLE) ? KEYM_SERVICE_CERT_SET_INTERMEDIATE : KEYM_SERVICE_CERT_UPDATE_INTERMEDIATE,
            KeyM_TrustModelIntermediateCertName(), KeyM_TrustModelIntermediateCertNameLength(),
            &Trust_Certificates_In[KeyM_DiagProc.ws.trustModelReplaceCerts.certIdx_intermediate], KeyM_DiagProc.ws.trustModelReplaceCerts.certLength_intermediate,
            KeyM_DiagProc.serviceResponseBuffer, sizeof(KeyM_DiagProc.serviceResponseBuffer));

          switch (retVal)
          {
            case RTE_E_OK:
              /* proceed with next state */
              KeyM_DiagProc.state = SSA_KEYM_REPLACE_TRUST_MODEL_CERTS_STATE_AWAITING_VERIFICATION_RESULT_INTERMEDIATE_CERT;
              retVal = RTE_E_RoutineServices_Replace_Trust_model_Certificates_DCM_E_PENDING;
              break;

            case RTE_E_SsaCdd_KeyM_CertInterface_KEYM_E_BUSY:
              /* remain in current state and retry */
              retVal = RTE_E_RoutineServices_Replace_Trust_model_Certificates_DCM_E_PENDING;
              /* Before the ServiceCertificate()-call for the intermediate certificate, the global variable KeyM_DiagProc.serviceResponseCallbackOccurred is reset to false.
              If the ServiceCertificate()-call now returns "busy", no callback for the intermediate certificate can be expected.
              During the next routine-call, the routine will return into the unchanged state AWAITING_VERIFICATION_RESULT_BACKEND_CERT (i.e. this function here).
              In order to be able to repeat the evaluation of the callback for the backend certificate in the beginning of the function,
              the following reset of KeyM_DiagProc.serviceResponseCallbackOccurred to TRUE is required. */
              KeyM_DiagProc.serviceResponseCallbackOccurred = TRUE;
              break;

            case RTE_E_SsaCdd_KeyM_CertInterface_KEYM_E_KEY_CERT_SIZE_MISMATCH:
              *Verification_Result_Out = SSA_VER_RES_TRUST_MODEL_REPLACE_CERTS_INTERMEDIATE_CERTIFICATE_VERIFICATION_FAILED_INVALID_FORMAT;
              /* finish routine */
              retVal = RTE_E_OK;
              KeyM_DiagProc.state = SSA_KEYM_REPLACE_TRUST_MODEL_CERTS_STATE_IDLE;
              /* Log failed Trust Model certififcate verification event */
              KeyM_LogTrustModelCertificateVerificationResult(SSA_TRUST_MODEL_INTERMEDIATE_CERT_ID, *Verification_Result_Out);
              break;

            case RTE_E_SsaCdd_KeyM_CertInterface_KEYM_E_CERT_INVALID_CHAIN_OF_TRUST:
            case RTE_E_SsaCdd_KeyM_CertInterface_E_NOT_OK:
            {
              certificateStatus = KEYM_CERTIFICATE_VALID;
              /* get the certificate's status. */
              (void)KeyM_KeyM_CertGetStatus(SSA_TRUST_MODEL_INTERMEDIATE_CERT_ID, &certificateStatus);
              /* map status to verification result */
              KeyM_ReplaceCertificate_MapCertificateStatusToVerificationResult(
                CERTP_PKI_ROLE_TRUST_MODEL_INTERMEDIATE_CA, certificateStatus, Verification_Result_Out);

              /* finish routine */
              KeyM_DiagProc.state = SSA_KEYM_REPLACE_TRUST_MODEL_CERTS_STATE_IDLE;
              /* Log failed Trust Model certififcate verification event */
              KeyM_LogTrustModelCertificateVerificationResult(SSA_TRUST_MODEL_INTERMEDIATE_CERT_ID, *Verification_Result_Out);
              retVal = RTE_E_OK;
              break;
            }

            /* RTE_E_SsaCdd_KeyM_CertInterface_KEYM_E_PARAMETER_MISMATCH - wrong key slot */
            /* RTE_E_SsaCdd_KeyM_CertInterface_KEYM_E_KEY_CERT_EMPTY - no data in key slot */
            default:
              /* finish routine */
              KeyM_DiagProc.state = SSA_KEYM_REPLACE_TRUST_MODEL_CERTS_STATE_IDLE;
              retVal = RTE_E_RoutineServices_Replace_Trust_model_Certificates_E_NOT_OK;
              *ErrorCode = DCM_E_CONDITIONSNOTCORRECT;
              break;
          }
        }
        break;
      }

      /* #40 Else finish routine. */
      default:
      {
        KeyM_CertificateStatusType certificateStatus = KEYM_CERTIFICATE_VALID;
        /* get the certificate's status. */
        (void)KeyM_KeyM_CertGetStatus(SSA_TRUST_MODEL_BACKEND_CERT_ID, &certificateStatus);
        /* map status to verification result */
        KeyM_ReplaceCertificate_MapCertificateStatusToVerificationResult(CERTP_PKI_ROLE_TRUST_MODEL_BACKEND_CA, certificateStatus, Verification_Result_Out);
        /* finish routine */
        KeyM_DiagProc.state = SSA_KEYM_REPLACE_TRUST_MODEL_CERTS_STATE_IDLE;
        /* Log failed Trust Model certififcate verification event */
        KeyM_LogTrustModelCertificateVerificationResult(SSA_TRUST_MODEL_BACKEND_CERT_ID, *Verification_Result_Out);
        retVal = RTE_E_OK;
        break;
      }
    }
  }

  return retVal;
} /* PRQA S 6060, 6080 */ /* MD_SSA_STPAR, MD_MSR_STMIF */

/**********************************************************************************************************************
 * KeyM_ReplaceTrustModelCerts_AwaitingVerificationResultIntermediateCert()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
/* PRQA S 3673 7 */ /* MD_SSA_PARAM_NOT_P2CONST */
SSA_KEYM_LOCAL FUNC(Std_ReturnType, Ssa_KeyM_CODE) KeyM_ReplaceTrustModelCerts_AwaitingVerificationResultIntermediateCert(
  P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) Trust_Certificates_In,
  Dcm_OpStatusType OpStatus,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) routineInfo_Out,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) Verification_Result_Out,
  uint16 DataLength,
  P2VAR(Dcm_NegativeResponseCodeType, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) ErrorCode)
{
  Std_ReturnType retVal = RTE_E_RoutineServices_Replace_Trust_model_Certificates_DCM_E_PENDING;

  SSA_DUMMY_STATEMENT(Trust_Certificates_In);   /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */
  SSA_DUMMY_STATEMENT(OpStatus);   /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */
  SSA_DUMMY_STATEMENT(routineInfo_Out);   /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */
  SSA_DUMMY_STATEMENT(DataLength);   /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */

  /*
   * #10 Wait for callback of the service certificate request for setting/updating the Trust Model Intermediate CA
   *     certificate.
   */
  if (KeyM_DiagProc.serviceResponseCallbackOccurred)
  {
    /* #20 Check the result. */
    switch (KeyM_DiagProc.serviceResponseCallbackResult)
    {
    /* #30 If verification passed set Trust Model ECU certificate at the AsrKeyM. */
      case KEYM_RT_OK:
      {

        /* Intermediate certificate has been verified by the KeyM */

        /* #31 Do additional verification of certificate entries not verified by KeyM. */
        uint8 localRet;
        KeyM_CertificateStatusType localCertStatus = KEYM_CERTIFICATE_INVALID;
        localRet = KeyM_TrustModel_AdditionalVerificationOfCertificateEntries_SingleCertificate(SSA_TRUST_MODEL_INTERMEDIATE_CERT_ID, SSA_TRUST_MODEL_BACKEND_CERT_ID, &localCertStatus);

        if ((localRet != E_OK) || (localCertStatus != KEYM_CERTIFICATE_VALID)) /* additional verification failed */
        {
          /* finish routine */
          retVal = RTE_E_OK;
          KeyM_DiagProc.state = SSA_KEYM_REPLACE_TRUST_MODEL_CERTS_STATE_IDLE;

          /* map localCertStatus to verification result */
          KeyM_ReplaceCertificate_MapCertificateStatusToVerificationResult(CERTP_PKI_ROLE_TRUST_MODEL_INTERMEDIATE_CA, localCertStatus, Verification_Result_Out);
          /* Log failed Trust Model certififcate verification event */
          KeyM_LogTrustModelCertificateVerificationResult(SSA_TRUST_MODEL_INTERMEDIATE_CERT_ID, *Verification_Result_Out);
        }
        else /* additional verfication succeeded */
        {
          Ssa_KeyM_CertDataType ecuCertData;
          /* Log successful Trust Model certififcate verification event */
          KeyM_LogTrustModelCertificateVerificationResult(SSA_TRUST_MODEL_INTERMEDIATE_CERT_ID, 0u);
          /*
           * Unfortunately the AUTOSAR KeyM API does not provide a const guarantee for the certificate data buffer,
           * so the following is not possible (this might be resolved in a future AUTOSAR version):
           *     ecuCertData.certData = &Trust_Certificates_In[certIdx_ecu];
           * So instead, we copy the data to a currently unused buffer in our workspace that does not have to be const.
           */

#ifdef __VCA__ /* COV_SSA_VECTOR_CODE_ANALYZER_ASSIGNMENT_OF_STRUCT_VARIABLE */
          uint16 certLength_ecu = KeyM_DiagProc.ws.trustModelReplaceCerts.certLength_ecu;
#endif
          /*@ assert sizeof(KeyM_DiagProc.serviceResponseBuffer) == SSA_MAX_SIZE_TRUSTMODEL_ECU_CERT; */
          /*@ assert certLength_ecu <= SSA_MAX_SIZE_TRUSTMODEL_ECU_CERT; */ /* VCA_SSA_KEYM_COPY_TO_SERVICE_RESPONSE_BUFFER */
          /*@ assert sizeof(KeyM_DiagProc.serviceResponseBuffer) >= certLength_ecu; */
          KeyM_CopyDataBuffer( 
            KeyM_DiagProc.serviceResponseBuffer,
            &Trust_Certificates_In[KeyM_DiagProc.ws.trustModelReplaceCerts.certIdx_ecu],
            KeyM_DiagProc.ws.trustModelReplaceCerts.certLength_ecu);
          ecuCertData.certData = KeyM_DiagProc.serviceResponseBuffer;
          ecuCertData.certDataLength = KeyM_DiagProc.ws.trustModelReplaceCerts.certLength_ecu;

          /* set certificate */
          retVal = KeyM_KeyM_SetCertificate(SSA_TRUST_MODEL_ECU_CERT_ID, &ecuCertData);

          switch (retVal)
          {
            case RTE_E_OK:
            {
              /* #50 If the Trust Model ECU certificate was set successfully, switch to the state
               * SSA_KEYM_REPLACE_TRUST_MODEL_CERTS_STATE_AWAITING_PARSING_RESULT_ECU_CERT and
               * request its status. */
              KeyM_DiagProc.state = SSA_KEYM_REPLACE_TRUST_MODEL_CERTS_STATE_AWAITING_PARSING_RESULT_ECU_CERT;
              /* call directly next state handler to avoid main function call */
              retVal = KeyM_ReplaceTrustModelCerts_AwaitingParsingResultEcuCert(
                Trust_Certificates_In, OpStatus, routineInfo_Out, Verification_Result_Out, DataLength, ErrorCode);
              break;
            }
            
            case RTE_E_SsaCdd_KeyM_CertInterface_KEYM_E_KEY_CERT_SIZE_MISMATCH:
            case RTE_E_SsaCdd_KeyM_CertInterface_E_NOT_OK:
            {
              /* invalid cert size or parse error */
              *Verification_Result_Out = SSA_VER_RES_TRUST_MODEL_REPLACE_CERTS_ECU_CERTIFICATE_VERIFICATION_FAILED_INVALID_FORMAT;
              /* finish routine */
              KeyM_DiagProc.state = SSA_KEYM_REPLACE_TRUST_MODEL_CERTS_STATE_IDLE;
              retVal = RTE_E_OK;

              break;
            }

            /* RTE_E_SsaCdd_KeyM_CertInterface_KEYM_E_PARAMETER_MISMATCH */
            default:
              KeyM_DiagProc.state = SSA_KEYM_REPLACE_TRUST_MODEL_CERTS_STATE_IDLE;
              retVal = RTE_E_RoutineServices_Replace_Trust_model_Certificates_E_NOT_OK;
              *ErrorCode = DCM_E_CONDITIONSNOTCORRECT;
              break;
          }
        }
        break;
      }

      /* #60 Else finish routine. */
      default:
      {
        KeyM_CertificateStatusType certificateStatus = KEYM_CERTIFICATE_VALID;
        /* get the certificate's status. */
        (void)KeyM_KeyM_CertGetStatus(SSA_TRUST_MODEL_INTERMEDIATE_CERT_ID, &certificateStatus);
        /* map status to verification result */
        KeyM_ReplaceCertificate_MapCertificateStatusToVerificationResult(
          CERTP_PKI_ROLE_TRUST_MODEL_INTERMEDIATE_CA, certificateStatus, Verification_Result_Out);

        /* finish routine */
        KeyM_DiagProc.state = SSA_KEYM_REPLACE_TRUST_MODEL_CERTS_STATE_IDLE;
        /* Log failed Trust Model certififcate verification event */
        KeyM_LogTrustModelCertificateVerificationResult(SSA_TRUST_MODEL_INTERMEDIATE_CERT_ID, *Verification_Result_Out);
        retVal = RTE_E_OK;

        break;
      }
    }
  }

  return retVal;
} /* PRQA S 6060, 6080 */ /* MD_SSA_STPAR, MD_MSR_STMIF */

/**********************************************************************************************************************
 * KeyM_ReplaceTrustModelCerts_AwaitingParsingResultEcuCert()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 */
/* PRQA S 3673 7 */ /* MD_SSA_PARAM_NOT_P2CONST */
SSA_KEYM_LOCAL FUNC(Std_ReturnType, Ssa_KeyM_CODE) KeyM_ReplaceTrustModelCerts_AwaitingParsingResultEcuCert(
  P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) Trust_Certificates_In,
  Dcm_OpStatusType OpStatus,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) routineInfo_Out,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) Verification_Result_Out,
  uint16 DataLength,
  P2VAR(Dcm_NegativeResponseCodeType, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) ErrorCode)
{
  Std_ReturnType retVal;
  KeyM_CertificateStatusType status = KEYM_CERTIFICATE_NOT_PARSED;

  SSA_DUMMY_STATEMENT(Trust_Certificates_In);   /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */
  SSA_DUMMY_STATEMENT(OpStatus);   /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */
  SSA_DUMMY_STATEMENT(routineInfo_Out);   /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */
  SSA_DUMMY_STATEMENT(DataLength);   /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */

  /* #10 Wait until certificate parsing has finished. This can be determined by the certificate status. */
  retVal = KeyM_KeyM_CertGetStatus(SSA_TRUST_MODEL_ECU_CERT_ID, &status);

  switch (retVal)
  {
    case RTE_E_OK:
    {
      if (status == KEYM_CERTIFICATE_NOT_PARSED)
      {
        retVal = RTE_E_RoutineServices_Replace_Trust_model_Certificates_DCM_E_PENDING;
      }
      else if (status != KEYM_CERTIFICATE_PARSED_NOT_VALIDATED)
      {
        /* parse error */
        *Verification_Result_Out = SSA_VER_RES_TRUST_MODEL_REPLACE_CERTS_ECU_CERTIFICATE_VERIFICATION_FAILED_INVALID_FORMAT;
        /* finish routine */
        KeyM_DiagProc.state = SSA_KEYM_REPLACE_TRUST_MODEL_CERTS_STATE_IDLE;
        retVal = RTE_E_OK;
      }
      else
      {
        /* #20 If successfully parsed check the UniqueEcuId field of the received certificate against the configured ones. */
        if (!KeyM_IsUniqueEcuIdFieldEqual())
        {
          /* verification of UniqueEcuId failed */
          KeyM_DiagProc.state = SSA_KEYM_REPLACE_TRUST_MODEL_CERTS_STATE_IDLE;
          retVal = RTE_E_OK;
          *Verification_Result_Out = SSA_VER_RES_TRUST_MODEL_REPLACE_CERTS_ECU_CERTIFICATE_VERIFICATION_FAILED_INVALID_SCOPE;
        }
        else
        {
          /*
           * #30 If the Trust Model ECU certificate was set successfully, switch to the state
           *     SSA_KEYM_REPLACE_TRUST_MODEL_CERTS_STATE_REQUESTING_FOR_VERIFICATION_ECU_CERT and
           *     request its verification.
           */
          KeyM_DiagProc.state = SSA_KEYM_REPLACE_TRUST_MODEL_CERTS_STATE_REQUESTING_FOR_VERIFICATION_ECU_CERT;
          /* call directly next state handler to avoid main function call */
          retVal = KeyM_ReplaceTrustModelCerts_RequestingVerificationEcuCert(
            Trust_Certificates_In, OpStatus, routineInfo_Out, Verification_Result_Out, DataLength, ErrorCode);
        }
      }

      break;
    }

    default:
    {
      KeyM_DiagProc.state = SSA_KEYM_REPLACE_TRUST_MODEL_CERTS_STATE_IDLE;
      retVal = RTE_E_RoutineServices_Replace_Trust_model_Certificates_E_NOT_OK;
      *ErrorCode = DCM_E_CONDITIONSNOTCORRECT;
      break;
    }
  }

  return retVal;
} /* PRQA S 6060 */ /* MD_SSA_STPAR */

/**********************************************************************************************************************
 * KeyM_ReplaceTrustModelCerts_RequestingVerificationEcuCert()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 */
/* PRQA S 3673 7 */ /* MD_SSA_PARAM_NOT_P2CONST */
SSA_KEYM_LOCAL FUNC(Std_ReturnType, Ssa_KeyM_CODE) KeyM_ReplaceTrustModelCerts_RequestingVerificationEcuCert(
    P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) Trust_Certificates_In,
    Dcm_OpStatusType OpStatus,
    P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) routineInfo_Out,
    P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) Verification_Result_Out,
    uint16 DataLength,
    P2VAR(Dcm_NegativeResponseCodeType, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) ErrorCode)
{
  Std_ReturnType retVal;

  SSA_DUMMY_STATEMENT(Trust_Certificates_In);   /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */
  SSA_DUMMY_STATEMENT(OpStatus);   /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */
  SSA_DUMMY_STATEMENT(routineInfo_Out);   /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */
  SSA_DUMMY_STATEMENT(DataLength);   /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */

  /* #10 Request AsrKeyM to asynchronously verify the ECU certificate. */
  KeyM_DiagProc.certificateVerifyCallbackResult = KEYM_CERTIFICATE_INVALID;
  KeyM_DiagProc.certificateVerifyCallbackOccurred = FALSE;

  retVal = Rte_Call_KeyMCertificate_Ssa_TrustModelEcuCert_VerifyCertificate();
  /* #20 Continue according to the request state: */
  switch (retVal)
  {
  case RTE_E_OK:
    /*
     * #30 If the request was accepted, proceed to next state
     *     SSA_KEYM_REPLACE_TRUST_MODEL_CERTS_STATE_AWAITING_VERIFICATION_RESULT_ECU_CERT.
     */
    KeyM_DiagProc.state = SSA_KEYM_REPLACE_TRUST_MODEL_CERTS_STATE_AWAITING_VERIFICATION_RESULT_ECU_CERT;
    retVal = RTE_E_RoutineServices_Replace_Trust_model_Certificates_DCM_E_PENDING;
    break;

  case RTE_E_KeyMCertificate_Ssa_TrustModelEcuCert_KEYM_E_BUSY:
    /* #40 If the AsrKeyM is busy, stay in current state and try again. */
    retVal = RTE_E_RoutineServices_Replace_Trust_model_Certificates_DCM_E_PENDING;
    break;

  case RTE_E_KeyMCertificate_Ssa_TrustModelEcuCert_KEYM_E_CERT_INVALID_CHAIN_OF_TRUST:
    /* #50 If the chain of trust is broken, abort the diagnostic routine. */
    KeyM_DiagProc.state = SSA_KEYM_REPLACE_TRUST_MODEL_CERTS_STATE_IDLE;
    retVal = RTE_E_OK;
    *Verification_Result_Out =
        SSA_VER_RES_TRUST_MODEL_REPLACE_CERTS_ECU_CERTIFICATE_VERIFICATION_FAILED_INVALID_CHAIN_OF_TRUST;
    break;

  default:
    /* #60 In any other case, abort the diagnostic routine and report invalid conditions. */
    KeyM_DiagProc.state = SSA_KEYM_REPLACE_TRUST_MODEL_CERTS_STATE_IDLE;
    retVal = RTE_E_RoutineServices_Replace_Trust_model_Certificates_E_NOT_OK;
    *ErrorCode = DCM_E_CONDITIONSNOTCORRECT;
    break;
  }

  return retVal;
} /* PRQA S 6060 */ /* MD_SSA_STPAR */

/**********************************************************************************************************************
 * KeyM_ReplaceTrustModelCerts_AwaitingVerificationResultEcuCert()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 */
/* PRQA S 3673 7 */ /* MD_SSA_PARAM_NOT_P2CONST */
SSA_KEYM_LOCAL FUNC(Std_ReturnType, Ssa_KeyM_CODE) KeyM_ReplaceTrustModelCerts_AwaitingVerificationResultEcuCert(
  P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) Trust_Certificates_In,
  Dcm_OpStatusType OpStatus,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) routineInfo_Out,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) Verification_Result_Out,
  uint16 DataLength,
  P2VAR(Dcm_NegativeResponseCodeType, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) ErrorCode)
{
  Std_ReturnType retVal = RTE_E_RoutineServices_Replace_Trust_model_Certificates_DCM_E_PENDING;

  SSA_DUMMY_STATEMENT(Trust_Certificates_In);   /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */
  SSA_DUMMY_STATEMENT(OpStatus);   /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */
  SSA_DUMMY_STATEMENT(routineInfo_Out);   /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */
  SSA_DUMMY_STATEMENT(DataLength);   /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */
  SSA_DUMMY_STATEMENT(ErrorCode);   /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */


  /* #10 Wait for callback of request for verifying the Trust Model ECU certificate. */
  if (KeyM_DiagProc.certificateVerifyCallbackOccurred)
  {
    /* #20 Check the result. */
    switch (KeyM_DiagProc.certificateVerifyCallbackResult)
    {
      /*  #30 If verification passed verify the certificate's public key against the unique private key. */
      case KEYM_CERTIFICATE_VALID:
      {

        /* Ecu certificate has been verified by the KeyM */

        /* #31 Do additional verification of certificate entries not verified by KeyM. */
        uint8 localRet;
        KeyM_CertificateStatusType localCertStatus = KEYM_CERTIFICATE_INVALID;
        localRet = KeyM_TrustModel_AdditionalVerificationOfCertificateEntries_SingleCertificate(SSA_TRUST_MODEL_ECU_CERT_ID, SSA_TRUST_MODEL_INTERMEDIATE_CERT_ID, &localCertStatus);

        if ((localRet != E_OK) || (localCertStatus != KEYM_CERTIFICATE_VALID)) /* additional verification failed */
        {
          /* Finish routine */
          /* Destroy Ecu certificate, i.e. set certificate to status "not available"  */
          KeyM_SetCertificateStatusToNotAvailable(SSA_TRUST_MODEL_ECU_CERT_ID);

          retVal = RTE_E_OK;
          KeyM_DiagProc.state = SSA_KEYM_REPLACE_TRUST_MODEL_CERTS_STATE_IDLE;

          /* map localCertStatus to verification result */
          KeyM_ReplaceCertificate_MapCertificateStatusToVerificationResult(CERTP_PKI_ROLE_TRUST_MODEL_ECU, localCertStatus, Verification_Result_Out);
          /* Log failed Trust Model certififcate verification event */
          KeyM_LogTrustModelCertificateVerificationResult(SSA_TRUST_MODEL_ECU_CERT_ID, *Verification_Result_Out);
        }
        else /* additional verfication succeeded */
        {
          KeyM_DiagProc.state = SSA_KEYM_REPLACE_TRUST_MODEL_CERTS_STATE_VERIFY_TRUST_MODEL_PRIVATE_KEY;
          retVal = RTE_E_RoutineServices_Replace_Trust_model_Certificates_DCM_E_PENDING;
          /* Log successful Trust Model certififcate verification event */
          KeyM_LogTrustModelCertificateVerificationResult(SSA_TRUST_MODEL_ECU_CERT_ID, 0u);
        }
        break;
      }

      /* #40 Else finish routine. */
      default:
      {
        KeyM_CertificateStatusType certificateStatus = KEYM_CERTIFICATE_VALID;
        /* get the certificate's status. */
        (void)KeyM_KeyM_CertGetStatus(SSA_TRUST_MODEL_ECU_CERT_ID, &certificateStatus);
        /* map status to verification result */
        KeyM_ReplaceCertificate_MapCertificateStatusToVerificationResult(CERTP_PKI_ROLE_TRUST_MODEL_ECU, certificateStatus, Verification_Result_Out);

        /* finish routine */
        KeyM_DiagProc.state = SSA_KEYM_REPLACE_TRUST_MODEL_CERTS_STATE_IDLE;
        /* Log failed Trust Model certififcate verification event */
        KeyM_LogTrustModelCertificateVerificationResult(SSA_TRUST_MODEL_ECU_CERT_ID, *Verification_Result_Out);
        retVal = RTE_E_OK;

        break;
      }
    }
  }

  return retVal;
} /* PRQA S 6060, 6080 */ /* MD_SSA_STPAR, MD_MSR_STMIF */

/**********************************************************************************************************************
 * KeyM_ReplaceTrustModelCerts_VerifyingKey()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 */
/* PRQA S 3673 7 */ /* MD_SSA_PARAM_NOT_P2CONST */
SSA_KEYM_LOCAL FUNC(Std_ReturnType, Ssa_KeyM_CODE) KeyM_ReplaceTrustModelCerts_VerifyingKey(
  P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) Trust_Certificates_In,
  Dcm_OpStatusType OpStatus,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) routineInfo_Out,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) Verification_Result_Out,
  uint16 DataLength,
  P2VAR(Dcm_NegativeResponseCodeType, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) ErrorCode)
{
  Std_ReturnType retVal;
  Crypto_VerifyResultType cryptoVerifResult = CRYPTO_E_VER_NOT_OK;

  SSA_DUMMY_STATEMENT(Trust_Certificates_In);   /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */
  SSA_DUMMY_STATEMENT(OpStatus);   /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */
  SSA_DUMMY_STATEMENT(routineInfo_Out);   /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */
  SSA_DUMMY_STATEMENT(DataLength);   /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */
  SSA_DUMMY_STATEMENT(ErrorCode);   /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */

  /* #10 Verify the Trust Model private key against the public key of the Trust Model ECU certificate. */
  retVal = KeyM_VerifyPublicKeyWithEcuPrivateKey(
      SSA_TRUST_MODEL_LIVE_PUBLIC_KEY_AND_CSR_PRIVATE_KEY,
      NULL_PTR,
      &cryptoVerifResult);
#if (SSA_ENABLE_ASYNC_CSM_JOB_PROCESSING == STD_ON)
  if (retVal == SSA_E_PENDING)
  {
    /* remain in state */
    retVal = RTE_E_RoutineServices_Replace_Trust_model_Certificates_DCM_E_PENDING;
  }
  else
#endif
  if ((retVal != E_OK) || (cryptoVerifResult != CRYPTO_E_VER_OK))
  {
    KeyM_DiagProc.state = SSA_KEYM_REPLACE_TRUST_MODEL_CERTS_STATE_IDLE;
    *Verification_Result_Out = SSA_VER_RES_TRUST_MODEL_REPLACE_CERTS_PRIVATEKEY_ECU_INVALID;
    retVal = RTE_E_OK;
  }
  else
  {
    /* verification is finally successful */
    {
      /* #15 Replace staging keys and set them valid. */
      retVal = Rte_Call_Key_TrustModelEcuCsrPrivateKey_KeyElementCopy(SSA_KE_SIGNATURE_KEY, SSA_KEYM_CSM_KEY_TRUST_MODEL_ECU_STAGING_PRIVATE_KEY, SSA_KE_SIGNATURE_KEY);
      retVal |= Rte_Call_Key_TrustModelEcuCsrPublicKey_KeyElementCopy(SSA_KE_SIGNATURE_KEY, SSA_KEYM_CSM_KEY_TRUST_MODEL_ECU_STAGING_PUBLIC_KEY, SSA_KE_SIGNATURE_KEY);
      retVal |= Rte_Call_Key_TrustModelEcuStagingPrivateKey_KeySetValid();
      retVal |= Rte_Call_Key_TrustModelEcuStagingPublicKey_KeySetValid();

      /* #20 Copy unique private ECU key to private ECU key and set it valid. */
      /* public key is set by AsrKeyM after succcessful verification of Trust Model ECU certificate */
      retVal |= Rte_Call_Key_TrustModelEcuStagingPrivateKey_KeyElementCopy(SSA_KE_SIGNATURE_KEY, SSA_KEYM_CSM_KEY_TRUST_MODEL_ECU_LIVE_PRIVATE_KEY, SSA_KE_SIGNATURE_KEY);
      retVal |= Rte_Call_Key_TrustModelEcuLivePrivateKey_KeySetValid();

      if (retVal != RTE_E_OK)
      {

        KeyM_DiagProc.state = SSA_KEYM_REPLACE_TRUST_MODEL_CERTS_STATE_IDLE;
        retVal = RTE_E_RoutineServices_Replace_Trust_model_Certificates_E_NOT_OK;
        *ErrorCode = DCM_E_CONDITIONSNOTCORRECT;
      }
      else
      {
        KeyM_DiagProc.state = SSA_KEYM_REPLACE_TRUST_MODEL_CERTS_STATE_STORE_INIT;
        retVal = RTE_E_RoutineServices_Replace_Trust_model_Certificates_DCM_E_PENDING;
      }
    }
  }
  return retVal;
} /* PRQA S 6060 */ /* MD_SSA_STPAR */

/**********************************************************************************************************************
 * KeyM_ReplaceTrustModelCerts_Storing()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
/* PRQA S 3673 7 */ /* MD_SSA_PARAM_NOT_P2CONST */
SSA_KEYM_LOCAL FUNC(Std_ReturnType, Ssa_KeyM_CODE) KeyM_ReplaceTrustModelCerts_Storing(
  P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) Trust_Certificates_In,
  Dcm_OpStatusType OpStatus,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) routineInfo_Out,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) Verification_Result_Out,
  uint16 DataLength,
  P2VAR(Dcm_NegativeResponseCodeType, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) ErrorCode)
{
  Std_ReturnType retVal;

  SSA_DUMMY_STATEMENT(Trust_Certificates_In);   /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */
  SSA_DUMMY_STATEMENT(OpStatus);   /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */
  SSA_DUMMY_STATEMENT(routineInfo_Out);   /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */
  SSA_DUMMY_STATEMENT(DataLength);   /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */

  /* #10 Trigger the application to store the Trust Model certificates and wait until storing is finished. */
  retVal = Rte_Call_Ssa_KeyStorage_StorePermanently(
    SSA_KEYSTORAGE_USECASE_TRUST_MODEL_CERTIFICATES,
    (KeyM_DiagProc.state == SSA_KEYM_REPLACE_TRUST_MODEL_CERTS_STATE_STORE_INIT) ? SSA_KEYSTORAGE_TASK_INITIAL : SSA_KEYSTORAGE_TASK_CHECKSTATE);

  if (retVal == RTE_E_Ssa_KeyStorage_E_PENDING)
  {
    KeyM_DiagProc.state = SSA_KEYM_REPLACE_TRUST_MODEL_CERTS_STATE_STORE_PENDING;
    retVal = RTE_E_RoutineServices_Replace_Trust_model_Certificates_DCM_E_PENDING;
  }
  else if (retVal == E_OK)
  {
    /* Now a full, valid Trust Model Chain is injected */
    *Rte_Pim_KeyMTrustModelChainOfTrustState() = SSA_TRUSTMODELCHAINSTATE_FULLY_INJECTED;

    KeyM_DiagProc.state = SSA_KEYM_REPLACE_TRUST_MODEL_CERTS_STATE_NVM_WRITE;
    /* call directly next state handler to avoid main function call */
    retVal = KeyM_ReplaceTrustModelCerts_WritingToNVM(
      Trust_Certificates_In, OpStatus, routineInfo_Out, Verification_Result_Out, DataLength, ErrorCode);
  }
  else
  {
    KeyM_DiagProc.state = SSA_KEYM_REPLACE_TRUST_MODEL_CERTS_STATE_IDLE;
    retVal = RTE_E_RoutineServices_Replace_Trust_model_Certificates_E_NOT_OK;
    *ErrorCode = DCM_E_GENERALREJECT;
  }
  return retVal;
} /* PRQA S 6060 */ /* MD_SSA_STPAR */

/**********************************************************************************************************************
 * KeyM_ReplaceTrustModelCerts_WritingToNVM()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
/* PRQA S 3673 7 */ /* MD_SSA_PARAM_NOT_P2CONST */
SSA_KEYM_LOCAL FUNC(Std_ReturnType, Ssa_KeyM_CODE) KeyM_ReplaceTrustModelCerts_WritingToNVM(
  P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) Trust_Certificates_In,
  Dcm_OpStatusType OpStatus,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) routineInfo_Out,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) Verification_Result_Out,
  uint16 DataLength,
  P2VAR(Dcm_NegativeResponseCodeType, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) ErrorCode)
{
  Std_ReturnType retVal = RTE_E_RoutineServices_Replace_Trust_model_Certificates_DCM_E_PENDING;

  SSA_DUMMY_STATEMENT(Trust_Certificates_In);   /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */
  SSA_DUMMY_STATEMENT(OpStatus);   /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */
  SSA_DUMMY_STATEMENT(routineInfo_Out);   /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */
  SSA_DUMMY_STATEMENT(DataLength);   /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */
  SSA_DUMMY_STATEMENT(ErrorCode);   /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */

  /* #10 Request NVM to write KeyM Ram block and wait until writing is finished. */
  if ((KeyM_DiagProc.state == SSA_KEYM_REPLACE_TRUST_MODEL_CERTS_STATE_NVM_WRITE)
    || (KeyM_DiagProc.state == SSA_KEYM_REPLACE_TRUST_MODEL_CERTS_STATE_NVM_WAIT))
  {
    Std_ReturnType ret;
    NvM_RequestResultType errorStatus = NVM_REQ_PENDING;

    /* get status of NVRAM block */
    ret = Rte_Call_NvMService_KeyM_TrustModelChainOfTrustState_GetErrorStatus(&errorStatus);
    if ((ret == RTE_E_OK) && (errorStatus != NVM_REQ_PENDING))
    {
      /* write NV block if it has been started and do not change back to idle state as long as NVRAM block status is pending */
      if (KeyM_DiagProc.state == SSA_KEYM_REPLACE_TRUST_MODEL_CERTS_STATE_NVM_WRITE)
      {
        if (Rte_Call_NvMService_KeyM_TrustModelChainOfTrustState_WriteBlock((dtRef_const_VOID)(NULL_PTR)) == E_OK) /* PRQA S 0314 */ /* MD_SSA_P2VOID_CAST */
        {
          KeyM_DiagProc.state = SSA_KEYM_REPLACE_TRUST_MODEL_CERTS_STATE_NVM_WAIT;
        }
      }
      /* must be SSA_KEYM_REPLACE_TRUST_MODEL_CERTS_STATE_NVM_WAIT */
      else
      {
        if (errorStatus == NVM_REQ_OK)
        {
          KeyM_DiagProc.state = SSA_KEYM_REPLACE_TRUST_MODEL_CERTS_STATE_IDLE;
          retVal = RTE_E_OK;
          *Verification_Result_Out = SSA_VER_RES_TRUST_MODEL_REPLACE_CERTS_CERTIFICATES_VERIFIED_AND_REPLACED;
        }
        else
        {
          /* Writing the NvM block failed. */
          KeyM_DiagProc.state = SSA_KEYM_REPLACE_TRUST_MODEL_CERTS_STATE_IDLE;
          retVal = RTE_E_RoutineServices_Replace_Trust_model_Certificates_E_NOT_OK;
          *ErrorCode = DCM_E_GENERALPROGRAMMINGFAILURE;
        }
      }
    }
    else
    {
      /* Stay in current state */
    }
  }

  return retVal;
} /* PRQA S 6060 */ /* MD_SSA_STPAR */

/**********************************************************************************************************************
 * KeyM_ReplaceTrustModelRootCert_HandleStateIdleAndVerifyingEnhanceCert()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
SSA_KEYM_LOCAL FUNC(Std_ReturnType, Ssa_KeyM_CODE) KeyM_ReplaceTrustModelRootCert_HandleStateIdleAndVerifyingEnhanceCert(
  P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) signature_new_Root_In,
  P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) signature_In,
  P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) Certificates_In,
  Dcm_OpStatusType OpStatus,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) routineInfo_Out,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) Verification_Result_Out,
  uint16 DataLength,
  P2VAR(Dcm_NegativeResponseCodeType, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) ErrorCode)
{
  Std_ReturnType retVal = RTE_E_OK;

  SSA_DUMMY_STATEMENT(signature_In);   /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */

  /* #10 Initially get length and indices of provided certificates of format [Enhanced Rights cert | New Root Ca cert]
   *     and keep them static. */
  if (OpStatus == DCM_INITIAL)
  {
    /* iteration 1 to 2 */
    uint16 certLength_enh = 0u, certLength_newroot = 0u;
    uint16 certIdx_enh = 0u, certIdx_newroot = 0u;
    uint32 dataIdx = 0u;

    if (KeyM_GetNextIteration(Certificates_In, DataLength, &dataIdx, &certIdx_enh, &certLength_enh) == E_NOT_OK)
    {
      retVal = RTE_E_RoutineServices_Replace_Trust_model_Root_Certificate_E_NOT_OK;
      *ErrorCode = DCM_E_INCORRECTMESSAGELENGTHORINVALIDFORMAT;
    }
    else if (KeyM_GetNextIteration(Certificates_In, DataLength, &dataIdx, &certIdx_newroot, &certLength_newroot) == E_NOT_OK)
    {
      retVal = RTE_E_RoutineServices_Replace_Trust_model_Root_Certificate_E_NOT_OK;
      *ErrorCode = DCM_E_INCORRECTMESSAGELENGTHORINVALIDFORMAT;
    }
    else if (certLength_newroot > SSA_MAX_SIZE_TRUSTMODEL_ROOT_CA_CERT)
    {
      retVal = RTE_E_RoutineServices_Replace_Trust_model_Root_Certificate_E_NOT_OK;
      *ErrorCode = DCM_E_INCORRECTMESSAGELENGTHORINVALIDFORMAT;
    }
    else if ((certLength_enh + certLength_newroot + SSA_SIZEOF_SIGNATURE + SSA_SIZEOF_SIGNATURE) > SSA_SIZEOF_REPLACEMENT_PACKAGE_BUFFER)
    {
      retVal = RTE_E_RoutineServices_Replace_Trust_model_Root_Certificate_E_NOT_OK;
      *ErrorCode = DCM_E_GENERALREJECT;
    }
    else
    {
      /* keep length and indices */
      KeyM_DiagProc.ws.trustModelReplaceRootCert.certIdx_enh = certIdx_enh;
      /*@ assert certIdx_newroot < sizeof(Dcm_Data2004ByteType); */ /* VCA_SSA_KEYM_REPLACE_ROOT_CERT_CERT_START_IDX */
      KeyM_DiagProc.ws.trustModelReplaceRootCert.certIdx_newroot = certIdx_newroot;
      KeyM_DiagProc.ws.trustModelReplaceRootCert.certLength_enh = certLength_enh;
      KeyM_DiagProc.ws.trustModelReplaceRootCert.certLength_newroot = certLength_newroot;
    }
  }

  if (retVal == RTE_E_OK)
  {
    /* #20 Use routine control application interface from RightsM for processing the enhance access rights certificate. */
    /*@ assert $lengthOf(Certificates_In) >= sizeof(Dcm_Data2004ByteType); */ /* VCA_SSA_KEYM_LENGTH_SPECIFIED_IN_FCT_CALL */
    retVal = Rte_Call_RC_Enhance_Access_Rights_Start(Certificates_In, OpStatus, routineInfo_Out, Verification_Result_Out, DataLength, ErrorCode); /* VCA_SSA_KEYM_LENGTH_SPECIFIED_IN_FCT_CALL */

    switch (retVal)
    {
    case RTE_E_RoutineServices_Routine_Enhance_Access_Rights_DCM_E_PENDING:
      /* stay in current state */
      retVal = RTE_E_RoutineServices_Replace_Trust_model_Root_Certificate_DCM_E_PENDING;
      break;

    case RTE_E_OK:
      /* #30 If certificate is valid:*/
      if (*Verification_Result_Out == SSA_VER_RES_ENHANCE_ACCESS_RIGHTS_CERTIFICATE_VERIFIFED_ACCESS_RIGHTS_ENHANCED)
      {
#if (SSA_KEEP_BUFFER_VARIABLES_STATIC == STD_OFF)
        uint8 KeyM_BackendCertBuf[SSA_SIZEOF_CERT_MAX];
#endif
        uint16 backendCertLength = SSA_SIZEOF_CERT_MAX;

        /* #32 Get stored, parsed Diagnostic Chain Backend Ca certificate. */
        retVal = KeyM_GetAndParseStoredCert(CERTP_PKI_ROLE_BACKEND, (P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR))KeyM_BackendCertBuf, &backendCertLength, FALSE);
        /* #34 Set public key of Backend Ca certificate as key for verifying the replacement package. */
        retVal |= Rte_Call_Key_SignatureRamKey_KeyElementSet(SSA_KE_SIGNATURE_KEY, &KeyM_BackendCertBuf[KeyM_ParsedBackendCert.publicKey.elemDataIdx], SSA_SIZEOF_PUBLICKEY);
        retVal |= Rte_Call_Key_SignatureRamKey_KeySetValid();

        if (retVal != RTE_E_OK)
        {
          KeyM_DiagProc.state = SSA_KEYM_REPLACE_TRUST_MODEL_ROOT_CERT_STATE_IDLE;
          retVal = RTE_E_RoutineServices_Replace_Trust_model_Root_Certificate_E_NOT_OK;
          *ErrorCode = DCM_E_CONDITIONSNOTCORRECT;
        }
        else
        {
          /* #36 Arrange replacement package data to be verified. */
          /*@ assert $lengthOf(KeyM_DiagProc.ws.trustModelReplaceRootCert.replacementPackageBuffer) >= SSA_SIZEOF_REPLACEMENT_PACKAGE_BUFFER; */
          KeyM_DiagProc.ws.trustModelReplaceRootCert.replacementPackageBufferLength = 0u;
          KeyM_CopyDataBuffer( /* VCA_SSA_KEYM_COPY_TO_REPLACEMENT_PACKAGE_BUFFER */
            &KeyM_DiagProc.ws.trustModelReplaceRootCert.replacementPackageBuffer[KeyM_DiagProc.ws.trustModelReplaceRootCert.replacementPackageBufferLength],
            &Certificates_In[KeyM_DiagProc.ws.trustModelReplaceRootCert.certIdx_enh],
            KeyM_DiagProc.ws.trustModelReplaceRootCert.certLength_enh);
          KeyM_DiagProc.ws.trustModelReplaceRootCert.replacementPackageBufferLength = KeyM_DiagProc.ws.trustModelReplaceRootCert.certLength_enh;
          KeyM_CopyDataBuffer( /* VCA_SSA_KEYM_COPY_TO_REPLACEMENT_PACKAGE_BUFFER */
            &KeyM_DiagProc.ws.trustModelReplaceRootCert.replacementPackageBuffer[KeyM_DiagProc.ws.trustModelReplaceRootCert.replacementPackageBufferLength],
            &Certificates_In[KeyM_DiagProc.ws.trustModelReplaceRootCert.certIdx_newroot],
            KeyM_DiagProc.ws.trustModelReplaceRootCert.certLength_newroot);
          KeyM_DiagProc.ws.trustModelReplaceRootCert.replacementPackageBufferLength += KeyM_DiagProc.ws.trustModelReplaceRootCert.certLength_newroot;
          KeyM_CopyDataBuffer( /* VCA_SSA_KEYM_COPY_TO_REPLACEMENT_PACKAGE_BUFFER */
            &KeyM_DiagProc.ws.trustModelReplaceRootCert.replacementPackageBuffer[KeyM_DiagProc.ws.trustModelReplaceRootCert.replacementPackageBufferLength],
            signature_new_Root_In,
            SSA_SIZEOF_SIGNATURE);
          KeyM_DiagProc.ws.trustModelReplaceRootCert.replacementPackageBufferLength += SSA_SIZEOF_SIGNATURE;

          /* #38 Change to next state. */
          KeyM_DiagProc.state = SSA_KEYM_REPLACE_TRUST_MODEL_ROOT_CERT_STATE_VERIFYING_REPLACEMENT_PACKAGE_SUBKEYID;
          retVal = RTE_E_RoutineServices_Replace_Trust_model_Root_Certificate_DCM_E_PENDING;
        }
      }
      else
      {
        /* #40 Else (certificate is not valid) change back to idle state. */
        KeyM_DiagProc.state = SSA_KEYM_REPLACE_TRUST_MODEL_ROOT_CERT_STATE_IDLE;
        /* #45 Map verification result codes. */
        switch (*Verification_Result_Out){
        case SSA_VER_RES_ENHANCE_ACCESS_RIGHTS_CERTIFICATE_VERIFICATION_FAILED_INVALID_TIME_PERIOD:
          *Verification_Result_Out = SSA_VER_RES_TRUST_MODEL_REPLACE_ROOT_CERT_ENHANCED_RIGHTS_CERTIFICATE_VERIFICATION_FAILED_INVALID_TIME_PERIOD;
          break;
        case SSA_VER_RES_ENHANCE_ACCESS_RIGHTS_CERTIFICATE_VERIFICATION_FAILED_INVALID_SIGNATURE:
          *Verification_Result_Out = SSA_VER_RES_TRUST_MODEL_REPLACE_ROOT_CERT_ENHANCED_RIGHTS_CERTIFICATE_VERIFICATION_FAILED_INVALID_SIGNATURE;
          break;
        case SSA_VER_RES_ENHANCE_ACCESS_RIGHTS_CERTIFICATE_VERIFICATION_FAILED_INVALID_CHAIN_OF_TRUST:
          *Verification_Result_Out = SSA_VER_RES_TRUST_MODEL_REPLACE_ROOT_CERT_ENHANCED_RIGHTS_CERTIFICATE_VERIFICATION_FAILED_INVALID_CHAIN_OF_TRUST;
          break;
        case SSA_VER_RES_ENHANCE_ACCESS_RIGHTS_CERTIFICATE_VERIFICATION_FAILED_INVALID_TYPE:
          *Verification_Result_Out = SSA_VER_RES_TRUST_MODEL_REPLACE_ROOT_CERT_ENHANCED_RIGHTS_CERTIFICATE_VERIFICATION_FAILED_INVALID_TYPE;
          break;
        case SSA_VER_RES_ENHANCE_ACCESS_RIGHTS_CERTIFICATE_VERIFICATION_FAILED_INVALID_FORMAT:
          *Verification_Result_Out = SSA_VER_RES_TRUST_MODEL_REPLACE_ROOT_CERT_ENHANCED_RIGHTS_CERTIFICATE_VERIFICATION_FAILED_INVALID_FORMAT;
          break;
        case SSA_VER_RES_ENHANCE_ACCESS_RIGHTS_CERTIFICATE_VERIFICATION_FAILED_INVALID_CONTENT:
          *Verification_Result_Out = SSA_VER_RES_TRUST_MODEL_REPLACE_ROOT_CERT_ENHANCED_RIGHTS_CERTIFICATE_VERIFICATION_FAILED_INVALID_CONTENT;
          break;
        case SSA_VER_RES_ENHANCE_ACCESS_RIGHTS_CERTIFICATE_VERIFICATION_FAILED_INVALID_SCOPE:
          *Verification_Result_Out = SSA_VER_RES_TRUST_MODEL_REPLACE_ROOT_CERT_ENHANCED_RIGHTS_CERTIFICATE_VERIFICATION_FAILED_INVALID_SCOPE;
          break;
        default:
          *Verification_Result_Out = SSA_VER_RES_TRUST_MODEL_REPLACE_ROOT_CERT_ENHANCED_RIGHTS_CERTIFICATE_VERIFICATION_FAILED_INVALID_FORMAT;
          break;
        }
      }
      break;

    default:
      /* any error */
      /* change to idle state */
      KeyM_DiagProc.state = SSA_KEYM_REPLACE_TRUST_MODEL_ROOT_CERT_STATE_IDLE;
      retVal = RTE_E_RoutineServices_Replace_Trust_model_Root_Certificate_E_NOT_OK;
      /* error code is set within previous subfunction call */
      break;
    }
  }
  return retVal;
} /* PRQA S 6030, 6060, 6080 */ /* MD_MSR_STCYC, MD_SSA_STPAR, MD_MSR_STMIF */

/**********************************************************************************************************************
 * KeyM_ReplaceTrustModelRootCert_HandleStateVerifyingReplacementPackageAndSubjectKeyId()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 */
/* PRQA S 3673 9 */ /* MD_SSA_PARAM_NOT_P2CONST */
SSA_KEYM_LOCAL FUNC(Std_ReturnType, Ssa_KeyM_CODE)KeyM_ReplaceTrustModelRootCert_HandleStateVerifyingReplacementPackageAndSubjectKeyId(
  P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) signature_new_Root_In,
  P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) signature_In,
  P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) Certificates_In,
  Dcm_OpStatusType OpStatus,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) routineInfo_Out,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) Verification_Result_Out,
  uint16 DataLength,
  P2VAR(Dcm_NegativeResponseCodeType, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) ErrorCode)
{
  Std_ReturnType retVal;
  Crypto_VerifyResultType csmVerificationResult;

  SSA_DUMMY_STATEMENT(signature_new_Root_In);   /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */
  SSA_DUMMY_STATEMENT(Certificates_In);   /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */
  SSA_DUMMY_STATEMENT(OpStatus);   /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */
  SSA_DUMMY_STATEMENT(routineInfo_Out);   /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */
  SSA_DUMMY_STATEMENT(DataLength);   /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */

  /* #10 Verify replacement package with Diagnostic Chain Backend CA certificate. */
  retVal = KeyM_CsmSignatureVerify(SSA_DIAGNOSTIC_KEY_PAIR, KeyM_DiagProc.ws.trustModelReplaceRootCert.replacementPackageBuffer, KeyM_DiagProc.ws.trustModelReplaceRootCert.replacementPackageBufferLength, signature_In, &csmVerificationResult);
  if (retVal == SSA_E_PENDING)
  {
    /* remain in current state */
    retVal = RTE_E_RoutineServices_Replace_Trust_model_Root_Certificate_DCM_E_PENDING;
  }
  else if (retVal != E_OK)
  {
    *ErrorCode = DCM_E_GENERALREJECT;
    KeyM_DiagProc.state = SSA_KEYM_REPLACE_TRUST_MODEL_ROOT_CERT_STATE_IDLE;
  }
  else if (csmVerificationResult != CERTP_VER_OK)
  {
    /* No negative return. */
    *Verification_Result_Out = SSA_VER_RES_TRUST_MODEL_REPLACE_ROOT_CERT_REPLACEMENT_PACKAGE_INVALID_SIGNATURE;
    KeyM_DiagProc.state = SSA_KEYM_REPLACE_TRUST_MODEL_ROOT_CERT_STATE_IDLE;
  }
  else
  {
    uint8 subjectKeyIdOldRoot[SSA_SIZEOF_CERT_SUBJECT_KEY_ID];
    uint32 subjectKeyIdOldRootLength = SSA_SIZEOF_CERT_SUBJECT_KEY_ID;

    /* #20 Get subject key identifier of stored Trust Model Root CA certificate and verify it against the
     *     target subject key identifier provided by the previously processed enhanced rights certificate. */
    retVal = Rte_Call_KeyMCertificateElement_Ssa_TrustModelRootCert_ext_subKeyId_CertificateElementGet(
      subjectKeyIdOldRoot,
      &subjectKeyIdOldRootLength);

    if ((retVal != RTE_E_OK) || (subjectKeyIdOldRootLength != SSA_SIZEOF_CERT_SUBJECT_KEY_ID))
    {
      KeyM_DiagProc.state = SSA_KEYM_REPLACE_TRUST_MODEL_ROOT_CERT_STATE_IDLE;
      retVal = RTE_E_OK;
      *Verification_Result_Out = SSA_VER_RES_TRUST_MODEL_REPLACE_ROOT_CERT_EXISTING_ROOT_CERT_INVALID_STATE;
    }
    else
    {
      retVal = Rte_Call_RightsM_EnhancedRights_VerifySubjectKeyIdentifier(subjectKeyIdOldRoot);

      /* #30 Proceed to next state only after successful verification of the subject key identifier. */
      if (retVal != RTE_E_OK)
      {
        KeyM_DiagProc.state = SSA_KEYM_REPLACE_TRUST_MODEL_ROOT_CERT_STATE_IDLE;
        retVal = RTE_E_OK;
        *Verification_Result_Out = SSA_VER_RES_TRUST_MODEL_REPLACE_ROOT_CERT_NO_RIGHTS_TO_PROCEED_FOR_THIS_ECU;
      }
      else
      {
        retVal = RTE_E_RoutineServices_Replace_Trust_model_Root_Certificate_DCM_E_PENDING;
        KeyM_DiagProc.state = SSA_KEYM_REPLACE_TRUST_MODEL_ROOT_CERT_STATE_STARTING_VERIFICATION_SIGNATURE_NEW_ROOT;
      }
    }
  }
  return retVal;
} /* PRQA S 6060, 6080 */ /* MD_SSA_STPAR, MD_MSR_STCYC */

/**********************************************************************************************************************
 * KeyM_ReplaceTrustModelRootCert_HandleStateVerifyingSignatureNewRoot()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 */
/* PRQA S 3673 9 */ /* MD_SSA_PARAM_NOT_P2CONST */
SSA_KEYM_LOCAL FUNC(Std_ReturnType, Ssa_KeyM_CODE)KeyM_ReplaceTrustModelRootCert_HandleStateVerifyingSignatureNewRoot(
  P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) signature_new_Root_In,
  P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) signature_In,
  P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) Certificates_In,
  Dcm_OpStatusType OpStatus,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) routineInfo_Out,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) Verification_Result_Out,
  uint16 DataLength,
  P2VAR(Dcm_NegativeResponseCodeType, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) ErrorCode)
{
  Std_ReturnType retVal = RTE_E_RoutineServices_Replace_Trust_model_Root_Certificate_DCM_E_PENDING;

  SSA_DUMMY_STATEMENT(signature_In);   /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */
  SSA_DUMMY_STATEMENT(OpStatus);   /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */
  SSA_DUMMY_STATEMENT(routineInfo_Out);   /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */
  SSA_DUMMY_STATEMENT(DataLength);   /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */

  /* #10 Verify the signature over the passed, new Trust Model Root CA certificate using the replacement authority's public key. */
  if (KeyM_DiagProc.state == SSA_KEYM_REPLACE_TRUST_MODEL_ROOT_CERT_STATE_STARTING_VERIFICATION_SIGNATURE_NEW_ROOT)
  {
#if (SSA_ENABLE_ASYNC_CSM_JOB_PROCESSING == STD_ON)
    KeyM_DiagProc.ws.trustModelReplaceRootCert.csmReplacementAuthorityCallbackResult = E_NOT_OK;
    KeyM_DiagProc.ws.trustModelReplaceRootCert.csmReplacementAuthorityCallbackOccurred = FALSE;
#else
    KeyM_DiagProc.ws.trustModelReplaceRootCert.csmReplacementAuthorityCallbackResult = E_OK;
    KeyM_DiagProc.ws.trustModelReplaceRootCert.csmReplacementAuthorityCallbackOccurred = TRUE;
#endif
    KeyM_DiagProc.ws.trustModelReplaceRootCert.csmReplacementAuthorityCryptoVerifyResult = CRYPTO_E_VER_NOT_OK;

    /*@ assert $lengthOf(Certificates_In) >= sizeof(Dcm_Data2004ByteType); */ /* VCA_SSA_KEYM_LENGTH_SPECIFIED_IN_FCT_CALL */
    /*@ assert KeyM_DiagProc.ws.trustModelReplaceRootCert.certIdx_newroot < sizeof(Dcm_Data2004ByteType); */ /* VCA_SSA_KEYM_REPLACE_ROOT_CERT_CERT_START_IDX */
    /*@ assert &Certificates_In[KeyM_DiagProc.ws.trustModelReplaceRootCert.certIdx_newroot] != NULL_PTR; */ /* VCA_SSA_KEYM_REPLACE_ROOT_CERT_CERT_START_IDX */
    /*@ assert signature_new_Root_In != NULL_PTR; */
    /*@ assert &KeyM_DiagProc.ws.trustModelReplaceRootCert.csmReplacementAuthorityCryptoVerifyResult != NULL_PTR; */
    retVal = Rte_Call_SsaCdd_Csm_SignatureVerify( /* VCA_SSA_KEYM_REPLACE_ROOT_CERT_CERT_START_IDX */
      SSA_KEYM_SIGNATURE_VERIFY_REPLACMENT_AUTHORITY_JOB_ID,
      CRYPTO_OPERATIONMODE_SINGLECALL,
      &Certificates_In[KeyM_DiagProc.ws.trustModelReplaceRootCert.certIdx_newroot],
      KeyM_DiagProc.ws.trustModelReplaceRootCert.certLength_newroot,
      signature_new_Root_In,
      SSA_SIZEOF_SIGNATURE,
      &KeyM_DiagProc.ws.trustModelReplaceRootCert.csmReplacementAuthorityCryptoVerifyResult);

    switch (retVal)
    {
    case RTE_E_OK:
      /* proceed with next state */
      KeyM_DiagProc.state = SSA_KEYM_REPLACE_TRUST_MODEL_ROOT_CERT_STATE_AWAITING_VERIF_RESULT_SIGNATURE_NEW_ROOT;
      retVal = RTE_E_RoutineServices_Replace_Trust_model_Root_Certificate_DCM_E_PENDING;
      break;

    case SSA_CRYPTO_E_BUSY:
    case SSA_CRYPTO_E_QUEUE_FULL:
      /* stay in current state so that the csm call in tried again in next cycle */
      retVal = RTE_E_RoutineServices_Replace_Trust_model_Root_Certificate_DCM_E_PENDING;
      break;

    default:
      /* finish routine */
      KeyM_DiagProc.state = SSA_KEYM_REPLACE_TRUST_MODEL_ROOT_CERT_STATE_IDLE;
      retVal = RTE_E_RoutineServices_Replace_Trust_model_Root_Certificate_E_NOT_OK;
      *ErrorCode = DCM_E_CONDITIONSNOTCORRECT;
      break;
    }
  }

  if (KeyM_DiagProc.state == SSA_KEYM_REPLACE_TRUST_MODEL_ROOT_CERT_STATE_AWAITING_VERIF_RESULT_SIGNATURE_NEW_ROOT)
  {
    /* #20 Only after successful verification update the Trust Model Root CA certificate and
     *     change to next state.
     *     Before doing this keep the current Trust Model Root CA certificate static for
     *     a potentially required rollback of this data. */
    if (KeyM_DiagProc.ws.trustModelReplaceRootCert.csmReplacementAuthorityCallbackOccurred)
    {
      if ((KeyM_DiagProc.ws.trustModelReplaceRootCert.csmReplacementAuthorityCallbackResult == E_OK)
        && (KeyM_DiagProc.ws.trustModelReplaceRootCert.csmReplacementAuthorityCryptoVerifyResult == CRYPTO_E_VER_OK))
      {
        /* get existing root if needed for rollback */
        /* prepare buffer where certificate data and its length shall be written to */
        KeyM_DiagProc.ws.trustModelReplaceRootCert.certificateDataRootBackup.certData =
            &KeyM_DiagProc.ws.trustModelReplaceRootCert.certBufferRoot[0];
        KeyM_DiagProc.ws.trustModelReplaceRootCert.certificateDataRootBackup.certDataLength =
            sizeof(KeyM_DiagProc.ws.trustModelReplaceRootCert.certBufferRoot);
        /* get certificate data from KeyM */
        /* It does not matter whether valid data are filled in, since the backup data are only used for the rollback.
         * Therefore, the return value can be voided. */
        (void)KeyM_KeyM_GetCertificate(SSA_TRUST_MODEL_ROOT_CERT_ID, &KeyM_DiagProc.ws.trustModelReplaceRootCert.certificateDataRootBackup);
        /* prepare asynchronous service certificate call */
        KeyM_DiagProc.serviceResponseCallbackOccurred = FALSE;

        /* it is not the rollback case */
        KeyM_DiagProc.ws.trustModelReplaceRootCert.isRollback = FALSE;

        /* service certificate call for updating Trust Model root certificate */
        /*@ assert KeyM_TrustModelRootCertName() != NULL_PTR; */
        /*@ assert &Certificates_In[KeyM_DiagProc.ws.trustModelReplaceRootCert.certIdx_newroot] != NULL_PTR; */ /* VCA_SSA_KEYM_REPLACE_ROOT_CERT_CERT_START_IDX */
        /*@ assert KeyM_DiagProc.serviceResponseBuffer != NULL_PTR; */
        /*@ assert $lengthOf(KeyM_DiagProc.serviceResponseBuffer) >= sizeof(KeyM_DiagProc.serviceResponseBuffer); */
        retVal = Rte_Call_SsaCdd_TrustModel_ServiceCertificate( /* VCA_SSA_KEYM_REPLACE_ROOT_CERT_CERT_START_IDX */
          KEYM_SERVICE_CERT_UPDATE_ROOT,
          KeyM_TrustModelRootCertName(), KeyM_TrustModelRootCertNameLength(),
          &Certificates_In[KeyM_DiagProc.ws.trustModelReplaceRootCert.certIdx_newroot], KeyM_DiagProc.ws.trustModelReplaceRootCert.certLength_newroot,
          KeyM_DiagProc.serviceResponseBuffer, sizeof(KeyM_DiagProc.serviceResponseBuffer));

        switch (retVal)
        {
        case RTE_E_OK:
          /* proceed with next state */
          /*@ assert KeyM_DiagProc.ws.trustModelReplaceRootCert.certificateDataRootBackup.certData == &KeyM_DiagProc.ws.trustModelReplaceRootCert.certBufferRoot[0]; */
          KeyM_DiagProc.state = SSA_KEYM_REPLACE_TRUST_MODEL_ROOT_CERT_STATE_AWAITING_VERIF_RESULT_NEW_ROOT_CERT;
          retVal = RTE_E_RoutineServices_Replace_Trust_model_Root_Certificate_DCM_E_PENDING;
          break;

        case RTE_E_SsaCdd_KeyM_CertInterface_KEYM_E_BUSY:
          /* stay in current state so that the csm call in tried again in next cycle */
          retVal = RTE_E_RoutineServices_Replace_Trust_model_Root_Certificate_DCM_E_PENDING;
          break;

        case RTE_E_SsaCdd_KeyM_CertInterface_KEYM_E_KEY_CERT_SIZE_MISMATCH:
          *Verification_Result_Out = SSA_VER_RES_TRUST_MODEL_REPLACE_ROOT_CERT_CERTIFICATE_VERIFICATION_FAILED_INVALID_FORMAT;
          /* finish routine */
          retVal = RTE_E_RoutineServices_Replace_Trust_model_Root_Certificate_DCM_E_PENDING;
          KeyM_DiagProc.state = SSA_KEYM_REPLACE_TRUST_MODEL_ROOT_CERT_STATE_ROLLING_BACK_CERTIFICATE_DATA;
          KeyM_DiagProc.ws.trustModelReplaceRootCert.verifResultBeforeRollback = *Verification_Result_Out;
          KeyM_DiagProc.ws.trustModelReplaceRootCert.isRollback = TRUE;
          /* Log failed Trust Model certififcate verification event */
          KeyM_LogTrustModelCertificateVerificationResult(SSA_TRUST_MODEL_ROOT_CERT_ID, *Verification_Result_Out);
          break;

        case RTE_E_SsaCdd_KeyM_CertInterface_KEYM_E_CERT_INVALID_CHAIN_OF_TRUST:
        case RTE_E_SsaCdd_KeyM_CertInterface_E_NOT_OK:
        {
          KeyM_CertificateStatusType certificateStatus = KEYM_CERTIFICATE_VALID;

          /* get the certificate's status. */
          (void)KeyM_KeyM_CertGetStatus(SSA_TRUST_MODEL_ROOT_CERT_ID, &certificateStatus);
          KeyM_ReplaceRoot_MapCertificateStatusToVerificationResult(certificateStatus, Verification_Result_Out);
          /* finish routine */
          KeyM_DiagProc.state = SSA_KEYM_REPLACE_TRUST_MODEL_ROOT_CERT_STATE_ROLLING_BACK_CERTIFICATE_DATA;
          KeyM_DiagProc.ws.trustModelReplaceRootCert.verifResultBeforeRollback = *Verification_Result_Out;
          KeyM_DiagProc.ws.trustModelReplaceRootCert.isRollback = TRUE;
          /* Log failed Trust Model certififcate verification event */
          KeyM_LogTrustModelCertificateVerificationResult(SSA_TRUST_MODEL_ROOT_CERT_ID, *Verification_Result_Out);
          retVal = RTE_E_RoutineServices_Replace_Trust_model_Root_Certificate_DCM_E_PENDING;
          break;
        }

        /* RTE_E_SsaCdd_KeyM_CertInterface_KEYM_E_PARAMETER_MISMATCH - wrong key slot */
        /* RTE_E_SsaCdd_KeyM_CertInterface_KEYM_E_KEY_CERT_EMPTY - no data in key slot */
        default:
          /* finish routine */
          KeyM_DiagProc.state = SSA_KEYM_REPLACE_TRUST_MODEL_ROOT_CERT_STATE_IDLE;
          retVal = RTE_E_RoutineServices_Replace_Trust_model_Root_Certificate_E_NOT_OK;
          *ErrorCode = DCM_E_CONDITIONSNOTCORRECT;
          break;
        }
      }
      else
      {
        KeyM_DiagProc.state = SSA_KEYM_REPLACE_TRUST_MODEL_ROOT_CERT_STATE_IDLE;
        retVal = RTE_E_OK;
        *Verification_Result_Out = SSA_VER_RES_TRUST_MODEL_REPLACE_ROOT_CERT_NEW_ROOT_INVALID_SIGNATURE;
      }
    }
  }
  return retVal;
} /* PRQA S 6060, 6030 */ /* MD_SSA_STPAR, MD_MSR_STCYC */

/**********************************************************************************************************************
 * KeyM_ReplaceTrustModelRootCert_HandleStateAwaitingVerificationResultNewRootCertAndStoring()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
/* PRQA S 3673 9 */ /* MD_SSA_PARAM_NOT_P2CONST */
SSA_KEYM_LOCAL FUNC(Std_ReturnType, Ssa_KeyM_CODE)KeyM_ReplaceTrustModelRootCert_HandleStateAwaitingVerificationResultNewRootCertAndStoring(
  P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) signature_new_Root_In,
  P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) signature_In,
  P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) Certificates_In,
  Dcm_OpStatusType OpStatus,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) routineInfo_Out,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) Verification_Result_Out,
  uint16 DataLength,
  P2VAR(Dcm_NegativeResponseCodeType, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) ErrorCode)
{
  Std_ReturnType retVal = RTE_E_RoutineServices_Replace_Trust_model_Root_Certificate_DCM_E_PENDING;

  SSA_DUMMY_STATEMENT(signature_new_Root_In);   /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */
  SSA_DUMMY_STATEMENT(signature_In);   /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */
  SSA_DUMMY_STATEMENT(Certificates_In);   /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */
  SSA_DUMMY_STATEMENT(OpStatus);   /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */
  SSA_DUMMY_STATEMENT(routineInfo_Out);   /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */
  SSA_DUMMY_STATEMENT(DataLength);   /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */

  /* #10 Wait for result of updating the Trust Model Root CA certificate. Depending on whether the update was successful
  *      or not change to appropriate, next state. */
  if (KeyM_DiagProc.state == SSA_KEYM_REPLACE_TRUST_MODEL_ROOT_CERT_STATE_AWAITING_VERIF_RESULT_NEW_ROOT_CERT)
  {
    if (KeyM_DiagProc.serviceResponseCallbackOccurred)
    {
      switch (KeyM_DiagProc.serviceResponseCallbackResult)
      {
      case KEYM_RT_OK:
      {
        /* Do additional verification of certificate entries not verified by AsrKeyM. */
        Std_ReturnType localRet;
        KeyM_CertificateStatusType localCertStatus = KEYM_CERTIFICATE_INVALID;
        localRet = KeyM_TrustModel_AdditionalVerificationOfCertificateEntries_SingleCertificate(
          SSA_TRUST_MODEL_ROOT_CERT_ID,
          SSA_TRUST_MODEL_ROOT_CERT_ID,
          &localCertStatus);

        if ((localRet != E_OK) || (localCertStatus != KEYM_CERTIFICATE_VALID)) /* additional verification failed */
        {
          /* finish routine. */
          if (KeyM_DiagProc.ws.trustModelReplaceRootCert.isRollback)
          {
            /* now there is a problem, old chain could not be verified */
            KeyM_DiagProc.state = SSA_KEYM_REPLACE_TRUST_MODEL_ROOT_CERT_STATE_IDLE;
            retVal = RTE_E_RoutineServices_Replace_Trust_model_Root_Certificate_E_NOT_OK;
            *ErrorCode = DCM_E_CONDITIONSNOTCORRECT;
          }
          else
          {
            /* #15 Trigger a rollback, to replace the new certificate data in RAM by the original certificate data. */
            KeyM_DiagProc.ws.trustModelReplaceRootCert.isRollback = TRUE;
            KeyM_DiagProc.state = SSA_KEYM_REPLACE_TRUST_MODEL_ROOT_CERT_STATE_ROLLING_BACK_CERTIFICATE_DATA;

            /* In case of localRet != E_OK, the localCertStatus is not set and is still "KEYM_CERTIFICATE_INVALID". */
            KeyM_ReplaceRoot_MapCertificateStatusToVerificationResult(localCertStatus, Verification_Result_Out);

            KeyM_DiagProc.ws.trustModelReplaceRootCert.verifResultBeforeRollback = *Verification_Result_Out;
            /* Log failed Trust Model certififcate verification event */
            KeyM_LogTrustModelCertificateVerificationResult(SSA_TRUST_MODEL_ROOT_CERT_ID, *Verification_Result_Out);
          }
        }
        else /* additional verification succeeded*/
        {
          /* change state */
          if (KeyM_DiagProc.ws.trustModelReplaceRootCert.isRollback)
          {
            KeyM_DiagProc.state = SSA_KEYM_REPLACE_TRUST_MODEL_ROOT_CERT_STATE_IDLE;
            retVal = RTE_E_OK;
            *Verification_Result_Out = KeyM_DiagProc.ws.trustModelReplaceRootCert.verifResultBeforeRollback;
          }
          else
          {
            /* Log successful Trust Model certififcate verification event */
            KeyM_LogTrustModelCertificateVerificationResult(SSA_TRUST_MODEL_ROOT_CERT_ID, 0u);
            KeyM_DiagProc.state = SSA_KEYM_REPLACE_TRUST_MODEL_ROOT_CERT_STATE_STORE_INIT;
          }
        }
        break;
      }

      default:
      {
        KeyM_CertificateStatusType certificateStatus = KEYM_CERTIFICATE_VALID;

        /* get the certificate's status. */
        (void)KeyM_KeyM_CertGetStatus(SSA_TRUST_MODEL_ROOT_CERT_ID, &certificateStatus);

        KeyM_ReplaceRoot_MapCertificateStatusToVerificationResult(certificateStatus, Verification_Result_Out);

        /* finish routine */
        if (KeyM_DiagProc.ws.trustModelReplaceRootCert.isRollback)
        {
          /* now there is a problem, old chain could not be verified */
          KeyM_DiagProc.state = SSA_KEYM_REPLACE_TRUST_MODEL_ROOT_CERT_STATE_IDLE;
          retVal = RTE_E_RoutineServices_Replace_Trust_model_Root_Certificate_E_NOT_OK;
          *ErrorCode = DCM_E_CONDITIONSNOTCORRECT;
        }
        else
        {
          KeyM_DiagProc.state = SSA_KEYM_REPLACE_TRUST_MODEL_ROOT_CERT_STATE_ROLLING_BACK_CERTIFICATE_DATA;
          KeyM_DiagProc.ws.trustModelReplaceRootCert.verifResultBeforeRollback = *Verification_Result_Out;
          KeyM_DiagProc.ws.trustModelReplaceRootCert.isRollback = TRUE;
          /* Log failed Trust Model certififcate verification event */
          KeyM_LogTrustModelCertificateVerificationResult(SSA_TRUST_MODEL_ROOT_CERT_ID, *Verification_Result_Out);
        }
        break;
      }
      }
    }
  }

  /* #20 If update was not successful change to state rolling back the Trust Model Root CA certificate.
   *     Else, trigger the application to store the Trust Model Root CA certificate and wait until storing is finished. */
  if ((KeyM_DiagProc.state == SSA_KEYM_REPLACE_TRUST_MODEL_ROOT_CERT_STATE_AWAITING_VERIF_RESULT_NEW_ROOT_CERT)
    || (KeyM_DiagProc.state == SSA_KEYM_REPLACE_TRUST_MODEL_ROOT_CERT_STATE_IDLE))
  {
    /* nothing */
  }
  else if (KeyM_DiagProc.state == SSA_KEYM_REPLACE_TRUST_MODEL_ROOT_CERT_STATE_ROLLING_BACK_CERTIFICATE_DATA)
  {
    KeyM_CertificateStatusType certificateStatus = KEYM_CERTIFICATE_INVALID;

    /* rollback */

    /* prepare asynchronous service certificate call */
    KeyM_DiagProc.serviceResponseCallbackOccurred = FALSE;

    KeyM_DiagProc.ws.trustModelReplaceRootCert.isRollback = TRUE;

    (void)KeyM_KeyM_CertGetStatus(SSA_TRUST_MODEL_ROOT_CERT_ID, &certificateStatus);

    /* service certificate call for updating Trust Model root certificate */
    /*@ assert KeyM_TrustModelRootCertName() != NULL_PTR; */
    /*@ assert KeyM_DiagProc.ws.trustModelReplaceRootCert.certificateDataRootBackup.certData != NULL_PTR; */ /* VCA_SSA_KEYM_TRUST_MODEL_ROOT_CERT_CERT_BUFFER */
    /*@ assert KeyM_DiagProc.serviceResponseBuffer != NULL_PTR; */
    /*@ assert $lengthOf(KeyM_DiagProc.serviceResponseBuffer) >= sizeof(KeyM_DiagProc.serviceResponseBuffer); */
    retVal = Rte_Call_SsaCdd_TrustModel_ServiceCertificate(
      (certificateStatus == KEYM_CERTIFICATE_NOT_AVAILABLE) ? KEYM_SERVICE_CERT_SET_ROOT : KEYM_SERVICE_CERT_UPDATE_ROOT,
      KeyM_TrustModelRootCertName(), KeyM_TrustModelRootCertNameLength(),
      KeyM_DiagProc.ws.trustModelReplaceRootCert.certificateDataRootBackup.certData, KeyM_DiagProc.ws.trustModelReplaceRootCert.certificateDataRootBackup.certDataLength,
      KeyM_DiagProc.serviceResponseBuffer, sizeof(KeyM_DiagProc.serviceResponseBuffer));

    switch (retVal)
    {
    case RTE_E_OK:
      /* proceed with next state */
      KeyM_DiagProc.state = SSA_KEYM_REPLACE_TRUST_MODEL_ROOT_CERT_STATE_AWAITING_VERIF_RESULT_NEW_ROOT_CERT;
      retVal = RTE_E_RoutineServices_Replace_Trust_model_Root_Certificate_DCM_E_PENDING;
      break;

    case RTE_E_SsaCdd_KeyM_CertInterface_KEYM_E_BUSY:
      /* stay in current state so that the csm call in tried again in next cycle */
      retVal = RTE_E_RoutineServices_Replace_Trust_model_Root_Certificate_DCM_E_PENDING;
      break;

    default:
      /* finish routine */
      KeyM_DiagProc.state = SSA_KEYM_REPLACE_TRUST_MODEL_ROOT_CERT_STATE_IDLE;
      retVal = RTE_E_RoutineServices_Replace_Trust_model_Root_Certificate_E_NOT_OK;
      *ErrorCode = DCM_E_CONDITIONSNOTCORRECT;
      break;
    }
  }
  else
  {
    /* call callout function to induce the application to permanently store the certificate data */
    retVal = Rte_Call_Ssa_KeyStorage_StorePermanently(
      SSA_KEYSTORAGE_USECASE_TRUST_MODEL_ROOT_CERTIFICATE,
      (KeyM_DiagProc.state == SSA_KEYM_REPLACE_TRUST_MODEL_ROOT_CERT_STATE_STORE_INIT) ? SSA_KEYSTORAGE_TASK_INITIAL : SSA_KEYSTORAGE_TASK_CHECKSTATE);

    if (retVal == RTE_E_Ssa_KeyStorage_E_PENDING)
    {
      KeyM_DiagProc.state = SSA_KEYM_REPLACE_TRUST_MODEL_ROOT_CERT_STATE_STORE_PENDING;
      retVal = RTE_E_RoutineServices_Replace_Trust_model_Root_Certificate_DCM_E_PENDING;
    }
    else if (retVal == RTE_E_OK)
    {
      /* Now a valid Trust Model Root certificate is injected (without knowing the state of the lower certificates of the chain). */

      /* The TrustModelChainOfTrustState is only changed, if the injected root is different from the old root certificate. */
      boolean rootCertsEqual = KeyM_CompareData_WithLengths(&Certificates_In[KeyM_DiagProc.ws.trustModelReplaceRootCert.certIdx_newroot],
        KeyM_DiagProc.ws.trustModelReplaceRootCert.certificateDataRootBackup.certData,
        KeyM_DiagProc.ws.trustModelReplaceRootCert.certLength_newroot, KeyM_DiagProc.ws.trustModelReplaceRootCert.certificateDataRootBackup.certDataLength);

      if (rootCertsEqual == FALSE)
      {
        *Rte_Pim_KeyMTrustModelChainOfTrustState() = SSA_TRUSTMODELCHAINSTATE_ROOT_INJECTED;
      }

      KeyM_DiagProc.state = SSA_KEYM_REPLACE_TRUST_MODEL_ROOT_CERT_STATE_NVM_WRITE;
      /* call directly next state handler to avoid main function call */
      retVal = KeyM_ReplaceTrustModelRootCert_HandleStateWritingToNVM(
        signature_new_Root_In, signature_In, Certificates_In, OpStatus, routineInfo_Out, Verification_Result_Out, DataLength, ErrorCode);
    }
    else
    {
      KeyM_DiagProc.state = SSA_KEYM_REPLACE_TRUST_MODEL_ROOT_CERT_STATE_IDLE;
      retVal = RTE_E_RoutineServices_Replace_Trust_model_Root_Certificate_E_NOT_OK;
      *ErrorCode = DCM_E_GENERALREJECT;
    }
  }

  return retVal;
}  /* PRQA S 6010, 6030, 6050, 6060, 6080 */ /* MD_MSR_STPTH, MD_MSR_STCYC, MD_MSR_STCAL, MD_SSA_STPAR, MD_MSR_STMIF */

/**********************************************************************************************************************
 * KeyM_ReplaceTrustModelRootCert_HandleStateWritingToNVM()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
/* PRQA S 3673 9 */ /* MD_SSA_PARAM_NOT_P2CONST */
SSA_KEYM_LOCAL FUNC(Std_ReturnType, Ssa_KeyM_CODE) KeyM_ReplaceTrustModelRootCert_HandleStateWritingToNVM(
  P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) signature_new_Root_In,
  P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) signature_In,
  P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) Certificates_In,
  Dcm_OpStatusType OpStatus,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) routineInfo_Out,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) Verification_Result_Out,
  uint16 DataLength,
  P2VAR(Dcm_NegativeResponseCodeType, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) ErrorCode)
{
  Std_ReturnType retVal = RTE_E_RoutineServices_Replace_Trust_model_Root_Certificate_DCM_E_PENDING;

  SSA_DUMMY_STATEMENT(signature_new_Root_In);   /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */
  SSA_DUMMY_STATEMENT(signature_In);   /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */
  SSA_DUMMY_STATEMENT(Certificates_In);   /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */
  SSA_DUMMY_STATEMENT(OpStatus);   /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */
  SSA_DUMMY_STATEMENT(routineInfo_Out);   /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */
  SSA_DUMMY_STATEMENT(DataLength);   /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */
  SSA_DUMMY_STATEMENT(ErrorCode);   /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */

  /* #10 Request NVM to write KeyM Ram block and wait until writing is finished. */
  if ((KeyM_DiagProc.state == SSA_KEYM_REPLACE_TRUST_MODEL_ROOT_CERT_STATE_NVM_WRITE)
    || (KeyM_DiagProc.state == SSA_KEYM_REPLACE_TRUST_MODEL_ROOT_CERT_STATE_NVM_WAIT))
  {
    Std_ReturnType ret;
    NvM_RequestResultType errorStatus = NVM_REQ_PENDING;

    /* get status of NVRAM block */
    ret = Rte_Call_NvMService_KeyM_TrustModelChainOfTrustState_GetErrorStatus(&errorStatus);
    if ((ret == RTE_E_OK) && (errorStatus != NVM_REQ_PENDING))
    {
      /* write NV block if it has been started and do not change back to idle state as long as NVRAM block status is pending */
      if (KeyM_DiagProc.state == SSA_KEYM_REPLACE_TRUST_MODEL_ROOT_CERT_STATE_NVM_WRITE)
      {
        if (Rte_Call_NvMService_KeyM_TrustModelChainOfTrustState_WriteBlock((dtRef_const_VOID)(NULL_PTR)) == E_OK) /* PRQA S 0314 */ /* MD_SSA_P2VOID_CAST */
        {
          KeyM_DiagProc.state = SSA_KEYM_REPLACE_TRUST_MODEL_ROOT_CERT_STATE_NVM_WAIT;
        }
      }
      /* must be SSA_KEYM_REPLACE_TRUST_MODEL_CERTS_STATE_NVM_WAIT */
      else
      {
        if (errorStatus == NVM_REQ_OK)
        {
          KeyM_DiagProc.state = SSA_KEYM_REPLACE_TRUST_MODEL_ROOT_CERT_STATE_IDLE;
          retVal = RTE_E_OK;
          *Verification_Result_Out = SSA_VER_RES_TRUST_MODEL_REPLACE_ROOT_CERT_CERTIFICATE_VERIFIED_AND_REPLACED;
        }
        else
        {
          /* Writing the NvM block failed. */
          KeyM_DiagProc.state = SSA_KEYM_REPLACE_TRUST_MODEL_ROOT_CERT_STATE_IDLE;
          retVal = RTE_E_RoutineServices_Replace_Trust_model_Root_Certificate_E_NOT_OK;
          *ErrorCode = DCM_E_GENERALPROGRAMMINGFAILURE;
        }
      }
    }
    else
    {
      /* Stay in current state */
    }
  }

  return retVal;
}  /* PRQA S 6010, 6030, 6060 */ /* MD_MSR_STPTH, MD_MSR_STCYC, MD_SSA_STPAR */

/**********************************************************************************************************************
 * KeyM_ReplaceRoot_MapCertificateStatusToVerificationResult()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 */
SSA_KEYM_LOCAL FUNC(void, Ssa_KeyM_CODE) KeyM_ReplaceRoot_MapCertificateStatusToVerificationResult(
  KeyM_CertificateStatusType certificateStatus,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) Verification_Result_Out)
{
  /* #10 Map AsrKeyM certificate status to verification result. */
  switch (certificateStatus)
  {
    case KEYM_E_CERTIFICATE_VALIDITY_PERIOD_FAIL:
      *Verification_Result_Out = SSA_VER_RES_TRUST_MODEL_REPLACE_ROOT_CERT_CERTIFICATE_VERIFICATION_FAILED_INVALID_TIME_PERIOD;
      break;
    case KEYM_E_CERTIFICATE_SIGNATURE_FAIL:
      *Verification_Result_Out = SSA_VER_RES_TRUST_MODEL_REPLACE_ROOT_CERT_CERTIFICATE_VERIFICATION_FAILED_INVALID_SIGNATURE;
      break;
    case KEYM_E_CERTIFICATE_INVALID_CHAIN_OF_TRUST:
      *Verification_Result_Out = SSA_VER_RES_TRUST_MODEL_REPLACE_ROOT_CERT_CERTIFICATE_VERIFICATION_FAILED_INVALID_CHAIN_OF_TRUST;
      break;
    case KEYM_E_CERTIFICATE_INVALID_TYPE:
      *Verification_Result_Out = SSA_VER_RES_TRUST_MODEL_REPLACE_ROOT_CERT_CERTIFICATE_VERIFICATION_FAILED_INVALID_TYPE;
      break;
    case KEYM_E_CERTIFICATE_INVALID_FORMAT:
      *Verification_Result_Out = SSA_VER_RES_TRUST_MODEL_REPLACE_ROOT_CERT_CERTIFICATE_VERIFICATION_FAILED_INVALID_FORMAT;
      break;
    case KEYM_E_CERTIFICATE_INVALID_CONTENT:
      *Verification_Result_Out = SSA_VER_RES_TRUST_MODEL_REPLACE_ROOT_CERT_CERTIFICATE_VERIFICATION_FAILED_INVALID_CONTENT;
      break;
    default:
      /* according to SSA-IS-2655 */
      *Verification_Result_Out = SSA_VER_RES_TRUST_MODEL_REPLACE_ROOT_CERT_CERTIFICATE_VERIFICATION_FAILED_INVALID_CHAIN_OF_TRUST;
      break;
  }
}  /* PRQA S 6030 */ /* MD_MSR_STCYC */

#if (SSA_DIAG_SERVICE_TRUST_MODEL_GENERATE_KEY_PAIR == STD_ON)

/**********************************************************************************************************************
 * KeyM_TrustModelGenerateKeyPair_HandleStateIdle()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
SSA_KEYM_LOCAL FUNC(Std_ReturnType, Ssa_KeyM_CODE) KeyM_TrustModelGenerateKeyPair_HandleStateIdle(
    P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) Verification_Result_Out,
    P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) CSR_Signature_Out,
    P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) Trust_Model_ECU_CSR_Out,
    P2VAR(uint16, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) DataLength)
{
  KeyM_DiagProc.state = SSA_KEYM_TRUST_MODEL_GENERATE_KEY_PAIR_STATE_GENERATING_KEY_PAIR;
  return KeyM_TrustModelGenerateKeyPair_HandleStateGeneratingKeyPair(
      Verification_Result_Out, CSR_Signature_Out, Trust_Model_ECU_CSR_Out, DataLength);
}

/**********************************************************************************************************************
 * KeyM_TrustModelGenerateKeyPair_HandleStateGeneratingKeyPair()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
/* PRQA S 3673 5 */ /* MD_SSA_PARAM_NOT_P2CONST */
SSA_KEYM_LOCAL FUNC(Std_ReturnType, Ssa_KeyM_CODE) KeyM_TrustModelGenerateKeyPair_HandleStateGeneratingKeyPair(
    P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) Verification_Result_Out,
    P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) CSR_Signature_Out,
    P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) Trust_Model_ECU_CSR_Out,
    P2VAR(uint16, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) DataLength)
{

# if (SSA_GENERATE_KEY_PAIR_CUSTOM_CALLOUT == STD_ON)
  Std_ReturnType retVal;

  /* Call callout function for preparing the key exchange as long as it returns E_PENDING. */
  retVal = Rte_Call_Ssa_KeyProc_GenerateKeyPair(
    SSA_KEYM_CSM_KEY_TRUST_MODEL_ECU_CSR_PRIVATE_KEY,
    SSA_KEYM_CSM_KEY_TRUST_MODEL_ECU_CSR_PUBLIC_KEY);

  SSA_DUMMY_STATEMENT(CSR_Signature_Out);   /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */
  SSA_DUMMY_STATEMENT(Trust_Model_ECU_CSR_Out);   /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */
  SSA_DUMMY_STATEMENT(DataLength);   /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */

  /* PRQA S 2880 L1 */ /* MD_SSA_UNREACHABLE_CODE */
  /* PRQA S 2995, 2996 L2 */ /* MD_SSA_BOOLEXPR_ALWAYS_TRUE_OR_ALWAYS_FALSE  */
  /* PRQA S 2991, 2992 L3 */ /* MD_SSA_CTRLEXPR_ALWAYS_TRUE_OR_ALWAYS_FALSE */
  if (retVal == RTE_E_Ssa_KeyProc_E_PENDING)
  {
    /* stay in this state and query again next time we are called */
    retVal = SSA_E_PENDING;
  }
  else if (retVal == RTE_E_OK)
  {
    KeyM_DiagProc.state = SSA_KEYM_TRUST_MODEL_GENERATE_KEY_PAIR_STATE_VERIFYING_KEY_PAIR;
    retVal = SSA_E_PENDING;
  }
  else
  {
    /* key generation failed */
    retVal = E_OK;
    *Verification_Result_Out = SSA_VER_RES_TRUST_MODEL_GENERATE_KEY_PAIR_COULD_NOT_CREATE_KEY_PAIR;
  }
  /* PRQA L:L3 */
  /* PRQA L:L2 */
  /* PRQA L:L1 */

  return retVal;
# else
  Std_ReturnType retVal = KeyM_CsmKeyGenerate_TrustModelEcuCsrKey();

  SSA_DUMMY_STATEMENT(CSR_Signature_Out);   /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */
  SSA_DUMMY_STATEMENT(Trust_Model_ECU_CSR_Out);   /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */
  SSA_DUMMY_STATEMENT(DataLength);   /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */

  if (retVal == SSA_E_PENDING)
  {
    /* stay in this state and query again next time we are called */
    retVal = SSA_E_PENDING;
  }
  else if (retVal == E_OK)
  {
    retVal = Rte_Call_Key_TrustModelEcuCsrPrivateKey_KeySetValid();
    retVal |= Rte_Call_Key_TrustModelEcuCsrPrivateKey_KeyElementCopy(
      SSA_KE_KEYEXCHANGE_OWNPUBKEY, SSA_KEYM_CSM_KEY_TRUST_MODEL_ECU_CSR_PUBLIC_KEY, SSA_KE_SIGNATURE_KEY);
    retVal |= Rte_Call_Key_TrustModelEcuCsrPublicKey_KeySetValid();
    if (retVal == E_OK)
    {
      KeyM_DiagProc.state = SSA_KEYM_TRUST_MODEL_GENERATE_KEY_PAIR_STATE_VERIFYING_KEY_PAIR;
      retVal = SSA_E_PENDING;
    }
    else
    {
      /* copying into public key slot failed */
      retVal = E_NOT_OK;
    }
  }
  else
  {
    /* key generation failed */
    retVal = E_OK;
    *Verification_Result_Out = SSA_VER_RES_TRUST_MODEL_GENERATE_KEY_PAIR_COULD_NOT_CREATE_KEY_PAIR;
  }

  return retVal;
# endif
}

/**********************************************************************************************************************
 * KeyM_TrustModelGenerateKeyPair_HandleStateVerifyingKeyPair()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 */
/* PRQA S 3673 5 */ /* MD_SSA_PARAM_NOT_P2CONST */
SSA_KEYM_LOCAL FUNC(Std_ReturnType, Ssa_KeyM_CODE) KeyM_TrustModelGenerateKeyPair_HandleStateVerifyingKeyPair(
    P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) Verification_Result_Out,
    P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) CSR_Signature_Out,
    P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) Trust_Model_ECU_CSR_Out,
    P2VAR(uint16, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) DataLength)
{
  Std_ReturnType retVal = KeyM_TrustModel_VerifyPrivateKeyAndInitCsr();

  SSA_DUMMY_STATEMENT(Verification_Result_Out);   /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */
  SSA_DUMMY_STATEMENT(CSR_Signature_Out);   /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */
  SSA_DUMMY_STATEMENT(Trust_Model_ECU_CSR_Out);   /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */
  SSA_DUMMY_STATEMENT(DataLength);   /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */

  if (retVal == SSA_E_PENDING)
  {
    /* stay in this state and query again next time we are called */
    retVal = SSA_E_PENDING;
  }
  else if (retVal == E_OK)
  {
    KeyM_DiagProc.state = SSA_KEYM_TRUST_MODEL_GENERATE_KEY_PAIR_STATE_AWAITING_CSR;
    retVal = SSA_E_PENDING;
  }
  else
  {
    retVal = E_NOT_OK;
  }

  return retVal;
}

/**********************************************************************************************************************
 * KeyM_TrustModelGenerateKeyPair_HandleStateAwaitingCsr()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
/* PRQA S 3673 5 */ /* MD_SSA_PARAM_NOT_P2CONST */
SSA_KEYM_LOCAL FUNC(Std_ReturnType, Ssa_KeyM_CODE) KeyM_TrustModelGenerateKeyPair_HandleStateAwaitingCsr(
    P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) Verification_Result_Out,
    P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) CSR_Signature_Out,
    P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) Trust_Model_ECU_CSR_Out,
    P2VAR(uint16, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) DataLength)
{
  Std_ReturnType retVal;

  SSA_DUMMY_STATEMENT(Verification_Result_Out);   /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */
  SSA_DUMMY_STATEMENT(CSR_Signature_Out);   /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */

  if (KeyM_DiagProc.serviceResponseCallbackOccurred)
  {
    if (KeyM_DiagProc.serviceResponseCallbackResult == KEYM_RT_OK)
    {
      /* creating CSR succeeded */
      uint16 csrLength = KeyM_DiagProc.serviceResponseBufferLength;

      uint16 maxOutputLength = sizeof(Dcm_Data1002ByteType);
      uint16 lengthOfLengthField = sizeof(uint16);
      uint16 csrLengthMax = maxOutputLength - lengthOfLengthField;

      if (csrLength > csrLengthMax)
      {
        /* CSR is too long to fit into Trust_Model_ECU_CSR_Out */
        retVal = E_NOT_OK;
      }
      else
      {
        /* write CSR length */
        Trust_Model_ECU_CSR_Out[0] = KeyM_GetUint16HiByte(csrLength);
        Trust_Model_ECU_CSR_Out[1] = KeyM_GetUint16LoByte(csrLength);
        *DataLength = lengthOfLengthField + csrLength;

        /* write CSR */
        Ssa_MemCpy(
            &Trust_Model_ECU_CSR_Out[lengthOfLengthField],
            KeyM_DiagProc.serviceResponseBuffer,
            KeyM_DiagProc.serviceResponseBufferLength);

        retVal = SSA_E_PENDING;
        KeyM_DiagProc.state = SSA_KEYM_TRUST_MODEL_GENERATE_KEY_PAIR_STATE_CREATING_SIGNATURE;
      }
    }
    else
    {
      /* error while creating CSR */
      retVal = E_NOT_OK;
    }
  }
  else
  {
    retVal = SSA_E_PENDING;
  }

  return retVal;
}

/**********************************************************************************************************************
 * KeyM_TrustModelGenerateKeyPair_HandleStateCreatingSignature()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 */
/* PRQA S 3673 5 */ /* MD_SSA_PARAM_NOT_P2CONST */
SSA_KEYM_LOCAL FUNC(Std_ReturnType, Ssa_KeyM_CODE) KeyM_TrustModelGenerateKeyPair_HandleStateCreatingSignature(
    P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) Verification_Result_Out,
    P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) CSR_Signature_Out,
    P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) Trust_Model_ECU_CSR_Out,
    P2VAR(uint16, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) DataLength)
{
  /* Skip leading length field */
  P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) csrBegin = &Trust_Model_ECU_CSR_Out[2];
  uint16 csrLength = (uint16)(*DataLength - 2u);

  Std_ReturnType retVal =
      KeyM_CsmSignatureGenerate(SSA_TRUST_MODEL_LIVE_KEY_PAIR, csrBegin, csrLength, CSR_Signature_Out);

  if (retVal == E_OK)
  {
    /* routine finished successfully */
    *Verification_Result_Out = SSA_VER_RES_TRUST_MODEL_GENERATE_KEY_PAIR_SUCCESSFUL;
  }
  else if (retVal == SSA_E_PENDING)
  {
    /* return pending and try again next time */
  }
  else
  {
    retVal = E_NOT_OK;
  }

  return retVal;
}

#endif

#if (SSA_ECU_TYPE == SSA_ECU_TYPE_VSM)

/**********************************************************************************************************************
 * KeyM_EcuSharedSecretEncryption_HandleStateIdle()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 */
/* PRQA S 3673 18 */ /* MD_SSA_PARAM_NOT_P2CONST */
SSA_KEYM_LOCAL FUNC(Std_ReturnType, Ssa_KeyM_CODE) KeyM_EcuSharedSecretEncryption_HandleStateIdle(
  uint8 chainOfTrust,
  P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) Nonce,
  P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) Ephemeral_ECU_Public_Key,
  P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) Data_Signature_In,
  P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) Target_ECU_Certificate,
  Dcm_OpStatusType OpStatus,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) routineInfo,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) Verification_Result,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) Date_and_Time,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) Tick_Count,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) Tick_Count_Offset,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) Encrypted_Nonce_and_Shared_Secret,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) Ephemeral_VSM_Public_Key,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) Data_Signature_Out,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) VSM_s_ECU_Certificate,
  P2VAR(uint16, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) DataLength,
  P2VAR(Dcm_NegativeResponseCodeType, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) ErrorCode,
  boolean allowStandardSecret)
{
  Std_ReturnType retVal = SSA_E_PENDING;
  Std_ReturnType result;

  SSA_DUMMY_STATEMENT(Data_Signature_In);   /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */
  SSA_DUMMY_STATEMENT(OpStatus);   /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */
  SSA_DUMMY_STATEMENT(routineInfo);   /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */
  SSA_DUMMY_STATEMENT(Date_and_Time);   /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */
  SSA_DUMMY_STATEMENT(Tick_Count);   /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */
  SSA_DUMMY_STATEMENT(Tick_Count_Offset);   /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */
  SSA_DUMMY_STATEMENT(Encrypted_Nonce_and_Shared_Secret);   /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */
  SSA_DUMMY_STATEMENT(Ephemeral_VSM_Public_Key);   /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */
  SSA_DUMMY_STATEMENT(Data_Signature_Out);   /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */
  SSA_DUMMY_STATEMENT(VSM_s_ECU_Certificate);   /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */
  SSA_DUMMY_STATEMENT(allowStandardSecret);   /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */


  /* #10  Initialize routine's output length and verification result. */
  if (KeyM_DiagProc.state == KEYM_ENCRYPTSHAREDSECRET_STATE_IDLE)
  {
    /* Initialize to zero when this function is entered */
    KeyM_DiagProc.ws.trustModelCommissioning.KeyM_RoutineCtrlDataLengthOut = 0u;
    *Verification_Result = SSA_VER_RES_TRUST_MODEL_SECOC_CSS_ENCRYPT_GENERATION_OF_CAR_SPECIFIC_SECRET_FAILED;

    /* Copy the nonce into the temporary data buffer. */
    Ssa_MemCpy((P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR))KeyM_DiagProc.ws.trustModelCommissioning.KeyM_SharedSecretEncDec_Nonce, Nonce, SSA_SIZEOF_NONCE);

    KeyM_DiagProc.state = KEYM_ENCRYPTSHAREDSECRET_STATE_VERIFY_ECU_CERTIFICATE;
    /*@ assert KeyM_DiagProc.ws.trustModelCommissioning.KeyM_RoutineCtrlDataLengthOut == 0u; */
  }

  /* #20 Verify the received, target ECU certificate(s). */
  if (KeyM_DiagProc.state == KEYM_ENCRYPTSHAREDSECRET_STATE_VERIFY_ECU_CERTIFICATE)
  {
    result = KeyM_CarSpecificSecretDistribution_VerifyEcuCert(
      chainOfTrust,
      Target_ECU_Certificate,
      *DataLength,
      KeyM_DiagProc.ws.trustModelCommissioning.KeyM_TargetEcuPublicKey,
      Verification_Result,
      ErrorCode);

    if (result == SSA_E_PENDING)
    {
      /* remain in current state */
    }
    else if (result != E_OK)
    {
      retVal = E_NOT_OK;
      KeyM_DiagProc.state = KEYM_ENCRYPTSHAREDSECRET_STATE_IDLE;
    }
    else if (*Verification_Result != SSA_VER_RES_TRUST_MODEL_SECOC_CSS_ENCRYPT_CERTIFICATE_VERIFIED_SECOC_KEY_CALCULATED)
    {
      retVal = E_OK;
      KeyM_DiagProc.state = KEYM_ENCRYPTSHAREDSECRET_STATE_IDLE;
    }
    else
    {
      /* copy nonce and ephemeral public key for the later signature verification here to avoid re-copies */
      Ssa_MemCpy((P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR))&KeyM_DiagProc.ws.trustModelCommissioning.KeyM_SharedSecretEncDec_DataBuffer[0], Nonce, SSA_SIZEOF_NONCE);
      Ssa_MemCpy((P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR))&KeyM_DiagProc.ws.trustModelCommissioning.KeyM_SharedSecretEncDec_DataBuffer[SSA_SIZEOF_NONCE], Ephemeral_ECU_Public_Key, SSA_SIZEOF_PUBLICKEY);

      /* #30 In case of diagnostic chain set public key of the target ECU as RAM key resp. as signature verification key.
       *     (In case of UniqueEcuId chain the public key is set by AsrKeyM.) */
      if (chainOfTrust == SSA_DIAGNOSTIC_KEY_PAIR)
      {
        result = Rte_Call_Key_SignatureRamKey_KeyElementSet(
          SSA_KE_SIGNATURE_KEY,
          KeyM_DiagProc.ws.trustModelCommissioning.KeyM_TargetEcuPublicKey,
          SSA_SIZEOF_PUBLICKEY);
        result |= Rte_Call_Key_SignatureRamKey_KeySetValid();
      }

      if (result != E_OK)
      {
        retVal = E_NOT_OK;
        *ErrorCode = DCM_E_GENERALREJECT;
        KeyM_DiagProc.state = KEYM_ENCRYPTSHAREDSECRET_STATE_IDLE;
      }
      else
      {
        KeyM_DiagProc.state = KEYM_ENCRYPTSHAREDSECRET_STATE_VERIFY_SIGNATURE;
      }
    }
  }

  return retVal;
}  /* PRQA S  6060, 6080 */ /* MD_SSA_STPAR, MD_MSR_STMIF  */

/**********************************************************************************************************************
 * KeyM_EcuSharedSecretEncryption_HandleStateVerifySignature()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 */
/* PRQA S 3673 18 */ /* MD_SSA_PARAM_NOT_P2CONST */
  SSA_KEYM_LOCAL FUNC(Std_ReturnType, Ssa_KeyM_CODE) KeyM_EcuSharedSecretEncryption_HandleStateVerifySignature(
  uint8 chainOfTrust,
  P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) Nonce,
  P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) Ephemeral_ECU_Public_Key,
  P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) Data_Signature_In,
  P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) Target_ECU_Certificate,
  Dcm_OpStatusType OpStatus,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) routineInfo,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) Verification_Result,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) Date_and_Time,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) Tick_Count,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) Tick_Count_Offset,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) Encrypted_Nonce_and_Shared_Secret,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) Ephemeral_VSM_Public_Key,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) Data_Signature_Out,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) VSM_s_ECU_Certificate,
  P2VAR(uint16, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) DataLength,
  P2VAR(Dcm_NegativeResponseCodeType, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) ErrorCode,
  boolean allowStandardSecret)
{
  Std_ReturnType retVal = SSA_E_PENDING;
  Std_ReturnType result;
  Crypto_VerifyResultType csmVerificationResult;

  SSA_DUMMY_STATEMENT(Nonce);   /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */
  SSA_DUMMY_STATEMENT(Ephemeral_ECU_Public_Key);   /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */
  SSA_DUMMY_STATEMENT(Target_ECU_Certificate);   /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */
  SSA_DUMMY_STATEMENT(OpStatus);   /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */
  SSA_DUMMY_STATEMENT(routineInfo);   /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */
  SSA_DUMMY_STATEMENT(Date_and_Time);   /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */
  SSA_DUMMY_STATEMENT(Tick_Count);   /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */
  SSA_DUMMY_STATEMENT(Tick_Count_Offset);   /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */
  SSA_DUMMY_STATEMENT(Encrypted_Nonce_and_Shared_Secret);   /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */
  SSA_DUMMY_STATEMENT(Ephemeral_VSM_Public_Key);   /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */
  SSA_DUMMY_STATEMENT(Data_Signature_Out);   /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */
  SSA_DUMMY_STATEMENT(VSM_s_ECU_Certificate);   /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */
  SSA_DUMMY_STATEMENT(DataLength);   /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */

  /* #10 Verify signature over nonce and ephemeral public key. */
  result = KeyM_CsmSignatureVerify(
    chainOfTrust,
    &KeyM_DiagProc.ws.trustModelCommissioning.KeyM_SharedSecretEncDec_DataBuffer[0],
    SSA_SIZEOF_NONCE + SSA_SIZEOF_PUBLICKEY,
    Data_Signature_In,
    &csmVerificationResult);

  if (result == SSA_E_PENDING)
  {
    /* remain in current state */
  }
  else if (result != E_OK)
  {
    retVal = E_NOT_OK;
    *ErrorCode = DCM_E_GENERALREJECT;
    KeyM_DiagProc.state = KEYM_ENCRYPTSHAREDSECRET_STATE_IDLE;
  }
  else if (csmVerificationResult != CRYPTO_E_VER_OK)
  {
    /* No negative return. */
    retVal = E_OK;
    *Verification_Result = SSA_VER_RES_TRUST_MODEL_SECOC_CSS_ENCRYPT_SIGNATURE_VERIFICATION_FAILED;
    KeyM_DiagProc.state = KEYM_ENCRYPTSHAREDSECRET_STATE_IDLE;
  }
  else
  {
    /* #20 If verification has passed get the stored car-specific secret. */
    uint32 sharedSecretLength = SSA_SIZEOF_SECRET;

    result = Rte_Call_Key_SharedSecret_KeyElementGet(SSA_KE_MAC_KEY, &KeyM_DiagProc.ws.trustModelCommissioning.KeyM_SharedSecretEncDec_DataBuffer[SSA_KEYM_DIS_POSITION_DECRYPTED_SECRET], &sharedSecretLength);
    if ((result != E_OK) || (sharedSecretLength != SSA_SIZEOF_SECRET))
    {
      retVal = E_NOT_OK;
      *ErrorCode = DCM_E_GENERALREJECT;
      KeyM_DiagProc.state = KEYM_ENCRYPTSHAREDSECRET_STATE_IDLE;
    }
    /* #30 Start renewing the car-specific secret if it equals the standard secret and if a further usage of the standard secret is not requested. */
    else if (!allowStandardSecret)
    {
      /* Check if secret equals the standard secret. */
      if (KeyM_CompareData(&KeyM_DiagProc.ws.trustModelCommissioning.KeyM_SharedSecretEncDec_DataBuffer[SSA_KEYM_DIS_POSITION_DECRYPTED_SECRET], KeyM_StandardSharedSecret, SSA_SIZEOF_SECRET) == TRUE)
      {
        KeyM_DiagProc.state = KEYM_ENCRYPTSHAREDSECRET_STATE_GEN_CAR_SPEC_SECRET;
      }
      else
      {
        KeyM_DiagProc.state = KEYM_ENCRYPTSHAREDSECRET_STATE_KEYEXCHANGE_ENCRYPT_GET_TIME;
      }
    }
    else
    {
      /* Everything ok, secret was load to buffer */
      KeyM_DiagProc.state = KEYM_ENCRYPTSHAREDSECRET_STATE_KEYEXCHANGE_ENCRYPT_GET_TIME;
    }
  }

  return retVal;
}  /* PRQA S  6060, 6080 */ /* MD_SSA_STPAR, MD_MSR_STMIF  */

/**********************************************************************************************************************
 * KeyM_EcuSharedSecretEncryption_HandleStateGenCarSpecificSecret()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 */
/* PRQA S 3673 18 */ /* MD_SSA_PARAM_NOT_P2CONST */
  SSA_KEYM_LOCAL FUNC(Std_ReturnType, Ssa_KeyM_CODE) KeyM_EcuSharedSecretEncryption_HandleStateGenCarSpecificSecret(
  uint8 chainOfTrust,
  P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) Nonce,
  P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) Ephemeral_ECU_Public_Key,
  P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) Data_Signature_In,
  P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) Target_ECU_Certificate,
  Dcm_OpStatusType OpStatus,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) routineInfo,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) Verification_Result,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) Date_and_Time,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) Tick_Count,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) Tick_Count_Offset,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) Encrypted_Nonce_and_Shared_Secret,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) Ephemeral_VSM_Public_Key,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) Data_Signature_Out,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) VSM_s_ECU_Certificate,
  P2VAR(uint16, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) DataLength,
  P2VAR(Dcm_NegativeResponseCodeType, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) ErrorCode,
  boolean allowStandardSecret)
{
  Std_ReturnType retVal = SSA_E_PENDING;
  Std_ReturnType result;

  SSA_DUMMY_STATEMENT(chainOfTrust);   /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */
  SSA_DUMMY_STATEMENT(Nonce);   /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */
  SSA_DUMMY_STATEMENT(Ephemeral_ECU_Public_Key);   /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */
  SSA_DUMMY_STATEMENT(Data_Signature_In);   /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */
  SSA_DUMMY_STATEMENT(Target_ECU_Certificate);   /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */
  SSA_DUMMY_STATEMENT(OpStatus);   /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */
  SSA_DUMMY_STATEMENT(routineInfo);   /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */
  SSA_DUMMY_STATEMENT(Verification_Result);   /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */
  SSA_DUMMY_STATEMENT(Date_and_Time);   /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */
  SSA_DUMMY_STATEMENT(Tick_Count);   /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */
  SSA_DUMMY_STATEMENT(Tick_Count_Offset);   /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */
  SSA_DUMMY_STATEMENT(Encrypted_Nonce_and_Shared_Secret);   /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */
  SSA_DUMMY_STATEMENT(Ephemeral_VSM_Public_Key);   /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */
  SSA_DUMMY_STATEMENT(Data_Signature_Out);   /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */
  SSA_DUMMY_STATEMENT(VSM_s_ECU_Certificate);   /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */
  SSA_DUMMY_STATEMENT(DataLength);   /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */
  SSA_DUMMY_STATEMENT(allowStandardSecret);   /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */

  /* #10 Generate random data used for the new car-specific secret. */
  result = KeyM_CsmRandomGenerate(
    SSA_SIZEOF_SECRET, &KeyM_DiagProc.ws.trustModelCommissioning.KeyM_SharedSecretEncDec_DataBuffer[SSA_KEYM_DIS_POSITION_DECRYPTED_SECRET]);

  if (result == SSA_E_PENDING)
  {
    /* remain in current state */
  }
  else if (result != E_OK)
  {
    retVal = E_NOT_OK;
    *ErrorCode = DCM_E_GENERALREJECT;
    KeyM_DiagProc.state = KEYM_ENCRYPTSHAREDSECRET_STATE_IDLE;
  }
  else
  {
    /* #20 Set the newly generated shared secret. Its hash will be set in the following state. Not until then.
     *     both elements are supposed to be stored during execution of callout function StorePermanently. */
    result = Rte_Call_Key_SharedSecret_KeyElementSet(
      SSA_KE_MAC_KEY,
      &KeyM_DiagProc.ws.trustModelCommissioning.KeyM_SharedSecretEncDec_DataBuffer[SSA_KEYM_DIS_POSITION_DECRYPTED_SECRET],
      SSA_SIZEOF_SECRET);
    result |= Rte_Call_Key_SharedSecret_KeySetValid();
    if (result != RTE_E_OK)
    {
      retVal = E_NOT_OK;
      *ErrorCode = DCM_E_GENERALREJECT;
      KeyM_DiagProc.state = KEYM_ENCRYPTSHAREDSECRET_STATE_IDLE;
    }
    else
    {
      KeyM_DiagProc.state = KEYM_ENCRYPTSHAREDSECRET_STATE_DERIVE_SECOC_KEYS;
    }
  }

  return retVal;
}  /* PRQA S  6060 */ /* MD_SSA_STPAR */

/**********************************************************************************************************************
 * KeyM_EcuSharedSecretEncryption_HandleStateGenSecOcKeys()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
/* PRQA S 3673 18 */ /* MD_SSA_PARAM_NOT_P2CONST */
SSA_KEYM_LOCAL FUNC(Std_ReturnType, Ssa_KeyM_CODE) KeyM_EcuSharedSecretEncryption_HandleStateGenSecOcKeys(
  uint8 chainOfTrust,
  P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) Nonce,
  P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) Ephemeral_ECU_Public_Key,
  P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) Data_Signature_In,
  P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) Target_ECU_Certificate,
  Dcm_OpStatusType OpStatus,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) routineInfo,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) Verification_Result,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) Date_and_Time,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) Tick_Count,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) Tick_Count_Offset,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) Encrypted_Nonce_and_Shared_Secret,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) Ephemeral_VSM_Public_Key,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) Data_Signature_Out,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) VSM_s_ECU_Certificate,
  P2VAR(uint16, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) DataLength,
  P2VAR(Dcm_NegativeResponseCodeType, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) ErrorCode,
  boolean allowStandardSecret)
{
  Std_ReturnType retVal = SSA_E_PENDING;

  SSA_DUMMY_STATEMENT(chainOfTrust);   /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */
  SSA_DUMMY_STATEMENT(Nonce);   /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */
  SSA_DUMMY_STATEMENT(Ephemeral_ECU_Public_Key);   /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */
  SSA_DUMMY_STATEMENT(Data_Signature_In);   /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */
  SSA_DUMMY_STATEMENT(Target_ECU_Certificate);   /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */
  SSA_DUMMY_STATEMENT(OpStatus);   /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */
  SSA_DUMMY_STATEMENT(routineInfo);   /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */
  SSA_DUMMY_STATEMENT(Verification_Result);   /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */
  SSA_DUMMY_STATEMENT(Date_and_Time);   /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */
  SSA_DUMMY_STATEMENT(Tick_Count);   /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */
  SSA_DUMMY_STATEMENT(Tick_Count_Offset);   /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */
  SSA_DUMMY_STATEMENT(Encrypted_Nonce_and_Shared_Secret);   /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */
  SSA_DUMMY_STATEMENT(Ephemeral_VSM_Public_Key);   /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */
  SSA_DUMMY_STATEMENT(Data_Signature_Out);   /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */
  SSA_DUMMY_STATEMENT(VSM_s_ECU_Certificate);   /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */
  SSA_DUMMY_STATEMENT(DataLength);   /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */
  SSA_DUMMY_STATEMENT(allowStandardSecret);   /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */

  /* #10 Start main loop processing for calculating the secret hash and the SecOC keys and wait until it is finished. */
  if (KeyM_DiagProc.state == KEYM_ENCRYPTSHAREDSECRET_STATE_DERIVE_SECOC_KEYS)
  {
    if (KeyM_GetMainLoopStateLock() == TRUE)
    {
      Ssa_MemCpy((P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR))KeyM_CarSpecificSecret, (P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA))&KeyM_DiagProc.ws.trustModelCommissioning.KeyM_SharedSecretEncDec_DataBuffer[SSA_KEYM_DIS_POSITION_DECRYPTED_SECRET], SSA_SIZEOF_SECRET);
      KeyM_MainLoopProc.conf = KEY_MAINLOOP_PROC_CONF_COMPLETE;
      KeyM_MainLoopProc.result = E_OK;
      KeyM_MainLoopProc.state = KEYM_GENERATE_SYM_KEYS_STATE_HASH_SECRET;

      KeyM_DiagProc.state = KEYM_ENCRYPTSHAREDSECRET_STATE_WAIT;
    }
    else
    {
      /* remain in current state */
    }
  }

  if (KeyM_DiagProc.state == KEYM_ENCRYPTSHAREDSECRET_STATE_WAIT)
  {
    if (KeyM_IsMainloopStateIdle())
    {
      if (KeyM_MainLoopProc.result == E_OK)
      {
        KeyM_DiagProc.state = KEYM_ENCRYPTSHAREDSECRET_STATE_KEYEXCHANGE_ENCRYPT_GET_TIME;
      }
      else
      {
        *ErrorCode = DCM_E_GENERALREJECT;
        retVal = E_NOT_OK;
        KeyM_DiagProc.state = KEYM_ENCRYPTSHAREDSECRET_STATE_IDLE;
      }
    }
    else
    {
      /* remain in current state */
    }
  }

  return retVal;
}  /* PRQA S  6060 */ /* MD_SSA_STPAR */

/**********************************************************************************************************************
 * KeyM_EcuSharedSecretEncryption_HandleStateKeyExchangeEncrypt()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 */
/* PRQA S 3673 18 */ /* MD_SSA_PARAM_NOT_P2CONST */
SSA_KEYM_LOCAL FUNC(Std_ReturnType, Ssa_KeyM_CODE) KeyM_EcuSharedSecretEncryption_HandleStateKeyExchangeEncrypt(
  uint8 chainOfTrust,
  P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) Nonce,
  P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) Ephemeral_ECU_Public_Key,
  P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) Data_Signature_In,
  P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) Target_ECU_Certificate,
  Dcm_OpStatusType OpStatus,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) routineInfo,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) Verification_Result,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) Date_and_Time,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) Tick_Count,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) Tick_Count_Offset,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) Encrypted_Nonce_and_Shared_Secret,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) Ephemeral_VSM_Public_Key,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) Data_Signature_Out,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) VSM_s_ECU_Certificate,
  P2VAR(uint16, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) DataLength,
  P2VAR(Dcm_NegativeResponseCodeType, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) ErrorCode,
  boolean allowStandardSecret)
{
  Std_ReturnType retVal = SSA_E_PENDING;
  Std_ReturnType result;

  SSA_DUMMY_STATEMENT(chainOfTrust);   /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */
  SSA_DUMMY_STATEMENT(Nonce);   /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */
  SSA_DUMMY_STATEMENT(Data_Signature_In);   /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */
  SSA_DUMMY_STATEMENT(Target_ECU_Certificate);   /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */
  SSA_DUMMY_STATEMENT(OpStatus);   /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */
  SSA_DUMMY_STATEMENT(routineInfo);   /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */
  SSA_DUMMY_STATEMENT(Verification_Result);   /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */
  SSA_DUMMY_STATEMENT(Data_Signature_Out);   /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */
  SSA_DUMMY_STATEMENT(VSM_s_ECU_Certificate);   /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */
  SSA_DUMMY_STATEMENT(DataLength);   /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */
  SSA_DUMMY_STATEMENT(allowStandardSecret);   /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */

  /* #10 Derive the symmetric key for encryption using the ephemeral ECU public key and the nonce. */
  result = KeyM_KeyExchangeCalcSymmetricKey(
    Ephemeral_ECU_Public_Key, (P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR))KeyM_DiagProc.ws.trustModelCommissioning.KeyM_SharedSecretEncDec_DataBuffer, Ephemeral_VSM_Public_Key);

  if (result == SSA_E_PENDING)
  {
    /* remain in current state */
  }
  else if (result != E_OK)
  {
    retVal = E_NOT_OK;
    *ErrorCode = DCM_E_GENERALREJECT;
    KeyM_DiagProc.state = KEYM_ENCRYPTSHAREDSECRET_STATE_IDLE;
  }
  else
  {
    /* #20 Encrypt the concatenation of nonce and car-specific secret. */
    if (KeyM_CarSpecificSecretDistribution_Encrypt(KeyM_DiagProc.ws.trustModelCommissioning.KeyM_SharedSecretEncDec_DataBuffer, Encrypted_Nonce_and_Shared_Secret) != E_OK)
    {
      retVal = E_NOT_OK;
      *ErrorCode = DCM_E_GENERALREJECT;
      KeyM_DiagProc.state = KEYM_ENCRYPTSHAREDSECRET_STATE_IDLE;
    }
    else if (Rte_Call_TimeM_TimeRawData_Get(Date_and_Time, Tick_Count_Offset, Tick_Count) != RTE_E_OK)
    {
      retVal = E_NOT_OK;
      *ErrorCode = DCM_E_GENERALREJECT;
      KeyM_DiagProc.state = KEYM_ENCRYPTSHAREDSECRET_STATE_IDLE;
    }
    else
    {
      /* #30 Copy the time raw data into the buffer used for signature generation.
       *     signedData = Date_and_Time | Tick_Count| Tick_Count_Offset | Encrypted_Nonce_and_Secret | Ephemeral_VSM_Public_Key */
      Ssa_MemCpy((P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR))&KeyM_DiagProc.ws.trustModelCommissioning.KeyM_SharedSecretEncDec_DataBuffer[SSA_KEYM_DIS_POSITION_DATE_AND_TIME], Date_and_Time, SSA_SIZEOF_REALTIME);
      Ssa_MemCpy((P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR))&KeyM_DiagProc.ws.trustModelCommissioning.KeyM_SharedSecretEncDec_DataBuffer[SSA_KEYM_DIS_POSITION_TICKCOUNTOFFSET], Tick_Count_Offset, SSA_SIZEOF_TICKCOUNT);
      Ssa_MemCpy((P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR))&KeyM_DiagProc.ws.trustModelCommissioning.KeyM_SharedSecretEncDec_DataBuffer[SSA_KEYM_DIS_POSITION_TICKCOUNT], Tick_Count, SSA_SIZEOF_TICKCOUNT);
      /* Copy ephemeral public key into the buffer. */
      Ssa_MemCpy((P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR))&KeyM_DiagProc.ws.trustModelCommissioning.KeyM_SharedSecretEncDec_DataBuffer[SSA_KEYM_DIS_POSITION_EPHEMERAL_PUBLIC_KEY], Ephemeral_VSM_Public_Key, SSA_SIZEOF_PUBLICKEY);

      KeyM_DiagProc.state = KEYM_ENCRYPTSHAREDSECRET_STATE_GEN_SIGNATURE;
    }
  }

  return retVal;
}  /* PRQA S  6060 */ /* MD_SSA_STPAR */

/**********************************************************************************************************************
 * KeyM_EcuSharedSecretEncryption_HandleStateGenSignature()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 */
/* PRQA S 3673 18 */ /* MD_SSA_PARAM_NOT_P2CONST */
SSA_KEYM_LOCAL FUNC(Std_ReturnType, Ssa_KeyM_CODE) KeyM_EcuSharedSecretEncryption_HandleStateGenSignature(
  uint8 chainOfTrust,
  P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) Nonce,
  P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) Ephemeral_ECU_Public_Key,
  P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) Data_Signature_In,
  P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) Target_ECU_Certificate,
  Dcm_OpStatusType OpStatus,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) routineInfo,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) Verification_Result,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) Date_and_Time,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) Tick_Count,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) Tick_Count_Offset,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) Encrypted_Nonce_and_Shared_Secret,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) Ephemeral_VSM_Public_Key,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) Data_Signature_Out,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) VSM_s_ECU_Certificate,
  P2VAR(uint16, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) DataLength,
  P2VAR(Dcm_NegativeResponseCodeType, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) ErrorCode,
  boolean allowStandardSecret)
{
  Std_ReturnType retVal = SSA_E_PENDING;
  Std_ReturnType result;

  SSA_DUMMY_STATEMENT(Nonce);   /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */
  SSA_DUMMY_STATEMENT(Ephemeral_ECU_Public_Key);   /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */
  SSA_DUMMY_STATEMENT(Data_Signature_In);   /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */
  SSA_DUMMY_STATEMENT(Target_ECU_Certificate);   /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */
  SSA_DUMMY_STATEMENT(OpStatus);   /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */
  SSA_DUMMY_STATEMENT(routineInfo);   /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */
  SSA_DUMMY_STATEMENT(Verification_Result);   /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */
  SSA_DUMMY_STATEMENT(Date_and_Time);   /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */
  SSA_DUMMY_STATEMENT(Tick_Count);   /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */
  SSA_DUMMY_STATEMENT(Tick_Count_Offset);   /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */
  SSA_DUMMY_STATEMENT(Encrypted_Nonce_and_Shared_Secret);   /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */
  SSA_DUMMY_STATEMENT(Ephemeral_VSM_Public_Key);   /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */
  SSA_DUMMY_STATEMENT(DataLength);   /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */
  SSA_DUMMY_STATEMENT(allowStandardSecret);   /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */

  /* #10 Generate the signature. */
  result = KeyM_CsmSignatureGenerate(
    chainOfTrust,
    &KeyM_DiagProc.ws.trustModelCommissioning.KeyM_SharedSecretEncDec_DataBuffer[SSA_KEYM_DIS_POSITION_DATE_AND_TIME],
    SSA_KEYM_DIS_BUFFER_SIZE,
    Data_Signature_Out);

  if (result == SSA_E_PENDING)
  {
    /* remain in current state */
  }
  else if (result != E_OK)
  {
    retVal = E_NOT_OK;
    *ErrorCode = DCM_E_GENERALREJECT;
    KeyM_DiagProc.state = KEYM_ENCRYPTSHAREDSECRET_STATE_IDLE;
  }
  else
  {
    /* Clear temporary buffer. */
    KeyM_ClearDataBuffer(KeyM_DiagProc.ws.trustModelCommissioning.KeyM_SharedSecretEncDec_DataBuffer, SSA_KEYM_DIS_BUFFER_SIZE, SSA_KEYM_DIS_BUFFER_SIZE);

    /* #20 Append VSM's ECU certificate to the output buffer. */
    KeyM_DiagProc.ws.trustModelCommissioning.KeyM_RoutineCtrlDataLengthOut = 0u;
    if (KeyM_CarSpecificSecretDistribution_AppendVsmCert(
      chainOfTrust,
      VSM_s_ECU_Certificate,
      &KeyM_DiagProc.ws.trustModelCommissioning.KeyM_RoutineCtrlDataLengthOut,
      ErrorCode) == TRUE)
    {
      retVal = E_NOT_OK;
    }
    else
    {
      retVal = E_OK;
    }
    KeyM_DiagProc.state = KEYM_ENCRYPTSHAREDSECRET_STATE_IDLE;
  }

  return retVal;
}  /* PRQA S  6060 */ /* MD_SSA_STPAR */

#else

/**********************************************************************************************************************
 * KeyM_EcuSharedSecretDistribution_HandleStateIdle()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 */
/* PRQA S 3673 13 */ /* MD_SSA_PARAM_NOT_P2CONST */
SSA_KEYM_LOCAL FUNC(Std_ReturnType, Ssa_KeyM_CODE) KeyM_EcuSharedSecretDistribution_HandleStateIdle(
  P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) Date_and_Time_In,
  P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) Tick_Count_In,
  P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) Tick_Count_Offset_In,
  P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) Encrypted_Nonce_and_Shared_Secret_In,
  P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) Ephemeral_VSM_Public_Key_In,
  P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) Data_Signature_In,
  P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) Certificates_In,
  uint16 DataLength)
{
  Std_ReturnType retVal = RTE_E_RoutineServices_Trust_Model_SecOC_ECU_Shared_Secret_Distribution_DCM_E_PENDING;
  Std_ReturnType result;

  SSA_DUMMY_STATEMENT(Data_Signature_In);   /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */

  if (KeyM_DiagProc.state == KEYM_ROUTINE_SECOC_ECU_SHARED_SECRET_DIST_STATE_IDLE)
  {
    uint8 vsmPublicKey[SSA_SIZEOF_PUBLICKEY] = { 0u };

    /* set initial error code and verification result */
    KeyM_DiagProc.ws.trustModelCommissioning.errorCode = DCM_E_POSITIVERESPONSE;
    KeyM_DiagProc.ws.trustModelCommissioning.verificationResult = SSA_VER_RES_TRUST_MODEL_SECOC_CSS_DISTRIB_SECOC_KEY_GENERATION_FAILED;

    /* #5 Verify certificate data. */
    result = KeyM_CarSpecificSecretDistribution_VerifyEcuCert(
      SSA_TRUST_MODEL_LIVE_KEY_PAIR,
      Certificates_In,
      DataLength,
      vsmPublicKey,
      &KeyM_DiagProc.ws.trustModelCommissioning.verificationResult,
      &KeyM_DiagProc.ws.trustModelCommissioning.errorCode);

    if (result == SSA_E_PENDING)
    {
      /* remain in current state */
    }
    else if (result != RTE_E_OK)
    {
      /* abort service execution */
      retVal = RTE_E_RoutineServices_Trust_Model_SecOC_ECU_Shared_Secret_Distribution_E_NOT_OK;
    }
    else if (KeyM_DiagProc.ws.trustModelCommissioning.verificationResult != SSA_VER_RES_TRUST_MODEL_SECOC_CSS_DISTRIB_CERTIFICATE_VERIFIED_SECOC_KEY_CALCULATED)
    {
      /* finish routine */
      retVal = RTE_E_OK;
    }
    else
    {
      /* #10 Get the current nonce from RightsM and verify the ECU certificate as VSM certificates and check if required, special rights are granted. */
      result = Rte_Call_RightsM_Nonce_Get(FALSE, KeyM_DiagProc.ws.trustModelCommissioning.KeyM_SharedSecretEncDec_Nonce);
      if (result == RTE_E_RightsM_Nonce_E_INVALID)
      {
        /* finish routine */
        retVal = RTE_E_OK;
        KeyM_DiagProc.ws.trustModelCommissioning.verificationResult = SSA_VER_RES_TRUST_MODEL_SECOC_CSS_DISTRIB_SECOC_KEY_GENERATION_FAILED;
      }
      else if (result != RTE_E_OK)
      {
        /* abort service execution */
        retVal = RTE_E_RoutineServices_Trust_Model_SecOC_ECU_Shared_Secret_Distribution_E_NOT_OK;
        KeyM_DiagProc.ws.trustModelCommissioning.errorCode = DCM_E_GENERALREJECT;
      }
      else
      {
        /* #20 Gather all data needed in a static buffer needed for signature verification:
         *     signedData =  Date_and_Time_Offset | TickCount| TickCount_Offset | Encrypted_Nonce_and_Secret */
        Ssa_MemCpy((P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR))&KeyM_DiagProc.ws.trustModelCommissioning.KeyM_SharedSecretEncDec_DataBuffer[SSA_KEYM_DIS_POSITION_DATE_AND_TIME], Date_and_Time_In, SSA_SIZEOF_REALTIME);
        Ssa_MemCpy((P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR))&KeyM_DiagProc.ws.trustModelCommissioning.KeyM_SharedSecretEncDec_DataBuffer[SSA_KEYM_DIS_POSITION_TICKCOUNT], Tick_Count_In, SSA_SIZEOF_TICKCOUNT);
        Ssa_MemCpy((P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR))&KeyM_DiagProc.ws.trustModelCommissioning.KeyM_SharedSecretEncDec_DataBuffer[SSA_KEYM_DIS_POSITION_TICKCOUNTOFFSET], Tick_Count_Offset_In, SSA_SIZEOF_TICKCOUNT);
        Ssa_MemCpy((P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR))&KeyM_DiagProc.ws.trustModelCommissioning.KeyM_SharedSecretEncDec_DataBuffer[SSA_KEYM_DIS_POSITION_ENCRYPTED_NONCE_AND_SECRET], Encrypted_Nonce_and_Shared_Secret_In, SSA_SIZEOF_ENCRYPTED_NONCE_AND_SECRET);
        Ssa_MemCpy((P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR))&KeyM_DiagProc.ws.trustModelCommissioning.KeyM_SharedSecretEncDec_DataBuffer[SSA_KEYM_DIS_POSITION_EPHEMERAL_PUBLIC_KEY], Ephemeral_VSM_Public_Key_In, SSA_SIZEOF_PUBLICKEY);

        /* proceed */
        KeyM_DiagProc.state = KEYM_ROUTINE_SECOC_ECU_SHARED_SECRET_DIST_STATE_VERIFY_SIGNATURE;
      }
    }
  }

  return retVal;
}  /* PRQA S  6060, 6080 */ /* MD_SSA_STPAR, MD_MSR_STMIF */

/**********************************************************************************************************************
 * KeyM_EcuSharedSecretDistribution_HandleStateVerifySignature()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
/* PRQA S 3673 13 */ /* MD_SSA_PARAM_NOT_P2CONST */
SSA_KEYM_LOCAL FUNC(Std_ReturnType, Ssa_KeyM_CODE) KeyM_EcuSharedSecretDistribution_HandleStateVerifySignature(
  P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) Date_and_Time_In,
  P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) Tick_Count_In,
  P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) Tick_Count_Offset_In,
  P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) Encrypted_Nonce_and_Shared_Secret_In,
  P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) Ephemeral_VSM_Public_Key_In,
  P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) Data_Signature_In,
  P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) Certificates_In,
  uint16 DataLength)
{
  Std_ReturnType retVal = RTE_E_RoutineServices_Trust_Model_SecOC_ECU_Shared_Secret_Distribution_DCM_E_PENDING;
  Std_ReturnType result;
  Crypto_VerifyResultType csmVerificationResult;

  SSA_DUMMY_STATEMENT(Date_and_Time_In);   /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */
  SSA_DUMMY_STATEMENT(Tick_Count_In);   /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */
  SSA_DUMMY_STATEMENT(Tick_Count_Offset_In);   /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */
  SSA_DUMMY_STATEMENT(Encrypted_Nonce_and_Shared_Secret_In);   /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */
  SSA_DUMMY_STATEMENT(Ephemeral_VSM_Public_Key_In);   /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */
  SSA_DUMMY_STATEMENT(Certificates_In);   /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */
  SSA_DUMMY_STATEMENT(DataLength);   /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */

  /* #10 Verify signature. If it fails do not leave routine without destroying nonce. */
  result = KeyM_CsmSignatureVerify(
    SSA_TRUST_MODEL_LIVE_KEY_PAIR,
    &KeyM_DiagProc.ws.trustModelCommissioning.KeyM_SharedSecretEncDec_DataBuffer[SSA_KEYM_DIS_POSITION_DATE_AND_TIME],
    SSA_KEYM_DIS_BUFFER_SIZE,
    Data_Signature_In,
    &csmVerificationResult);

  if (result == SSA_E_PENDING)
  {
    /* remain in current state */
  }
  else if (result != E_OK)
  {
    /* abort service execution */
    retVal = RTE_E_RoutineServices_Trust_Model_SecOC_ECU_Shared_Secret_Distribution_E_NOT_OK;
    KeyM_DiagProc.ws.trustModelCommissioning.errorCode = DCM_E_GENERALREJECT;
  }
  else if (csmVerificationResult != CERTP_VER_OK)
  {
    /* finish routine */
    KeyM_DiagProc.ws.trustModelCommissioning.verificationResult = SSA_VER_RES_TRUST_MODEL_SECOC_CSS_DISTRIB_INVALID_DATA_SIGNATURE;
    retVal = RTE_E_OK;
  }
  else
  {
    /* proceed */
    KeyM_DiagProc.state = KEYM_ROUTINE_SECOC_ECU_SHARED_SECRET_DIST_STATE_KEYEXCHANGE_DECRYPT;
  }

  return retVal;
}  /* PRQA S  6060 */ /* MD_SSA_STPAR */

/**********************************************************************************************************************
 * KeyM_EcuSharedSecretDistribution_HandleStateKeyExchangeDecrypt()
 *********************************************************************************************************************/
 /*!
  * Internal comment removed.
 *
 *
 *
 *
  */
/* PRQA S 3673 13 */ /* MD_SSA_PARAM_NOT_P2CONST */
SSA_KEYM_LOCAL FUNC(Std_ReturnType, Ssa_KeyM_CODE) KeyM_EcuSharedSecretDistribution_HandleStateKeyExchangeDecrypt(
  P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) Date_and_Time_In,
  P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) Tick_Count_In,
  P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) Tick_Count_Offset_In,
  P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) Encrypted_Nonce_and_Shared_Secret_In,
  P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) Ephemeral_VSM_Public_Key_In,
  P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) Data_Signature_In,
  P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) Certificates_In,
  uint16 DataLength)
{
  Std_ReturnType retVal = RTE_E_RoutineServices_Trust_Model_SecOC_ECU_Shared_Secret_Distribution_DCM_E_PENDING;
  Std_ReturnType result;

  SSA_DUMMY_STATEMENT(Date_and_Time_In);   /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */
  SSA_DUMMY_STATEMENT(Tick_Count_In);   /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */
  SSA_DUMMY_STATEMENT(Tick_Count_Offset_In);   /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */
  SSA_DUMMY_STATEMENT(Encrypted_Nonce_and_Shared_Secret_In);   /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */
  SSA_DUMMY_STATEMENT(Ephemeral_VSM_Public_Key_In);   /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */
  SSA_DUMMY_STATEMENT(Data_Signature_In);   /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */
  SSA_DUMMY_STATEMENT(Certificates_In);   /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */
  SSA_DUMMY_STATEMENT(DataLength);   /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */

  /* #10 Derive the symmetric key for decryption using the ephemeral VSM public key and the nonce.
   *     In error case do not leave routine without destroying nonce. */
  result = KeyM_KeyExchangeCalcSymmetricKey(
    Ephemeral_VSM_Public_Key_In,
    (P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR))KeyM_DiagProc.ws.trustModelCommissioning.KeyM_SharedSecretEncDec_Nonce,
    NULL_PTR);

  if (result == SSA_E_PENDING)
  {
    /* remain in current state */
  }
  else if (result != E_OK)
  {
    /* abort routine but destroy nonce before */
    KeyM_DiagProc.ws.trustModelCommissioning.errorCode = DCM_E_CONDITIONSNOTCORRECT;
    KeyM_DiagProc.state = KEYM_ROUTINE_SECOC_ECU_SHARED_SECRET_DIST_STATE_DESTROY_NONCE;
  }
  else
  {
    /* #20 Decrypt the nonce and car-specific secret and check the nonce. */
    if (KeyM_CarSpecificSecretDistribution_Decrypt(
      Encrypted_Nonce_and_Shared_Secret_In,
      KeyM_DiagProc.ws.trustModelCommissioning.KeyM_SharedSecretEncDec_DataBuffer,
      &KeyM_DiagProc.ws.trustModelCommissioning.verificationResult,
      &KeyM_DiagProc.ws.trustModelCommissioning.errorCode) == FALSE)
    {
      /* proceed */
      KeyM_DiagProc.state = KEYM_ROUTINE_SECOC_ECU_SHARED_SECRET_DIST_STATE_DERIVE_SECOC_KEYS;
    }
    else
    {
      /* finish routine after destroying nonce */
      KeyM_DiagProc.state = KEYM_ROUTINE_SECOC_ECU_SHARED_SECRET_DIST_STATE_DESTROY_NONCE;
    }
  }

  return retVal;
}  /* PRQA S  6060 */ /* MD_SSA_STPAR */

/**********************************************************************************************************************
 * KeyM_EcuSharedSecretDistribution_HandleStateDeriveSecOcKeys()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 */
/* PRQA S 3673 13 */ /* MD_SSA_PARAM_NOT_P2CONST */
SSA_KEYM_LOCAL FUNC(Std_ReturnType, Ssa_KeyM_CODE) KeyM_EcuSharedSecretDistribution_HandleStateDeriveSecOcKeys(
  P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) Date_and_Time_In,
  P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) Tick_Count_In,
  P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) Tick_Count_Offset_In,
  P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) Encrypted_Nonce_and_Shared_Secret_In,
  P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) Ephemeral_VSM_Public_Key_In,
  P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) Data_Signature_In,
  P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) Certificates_In,
  uint16 DataLength)
{
  Std_ReturnType retVal = RTE_E_RoutineServices_Trust_Model_SecOC_ECU_Shared_Secret_Distribution_DCM_E_PENDING;

  SSA_DUMMY_STATEMENT(Date_and_Time_In);   /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */
  SSA_DUMMY_STATEMENT(Tick_Count_In);   /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */
  SSA_DUMMY_STATEMENT(Tick_Count_Offset_In);   /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */
  SSA_DUMMY_STATEMENT(Encrypted_Nonce_and_Shared_Secret_In);   /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */
  SSA_DUMMY_STATEMENT(Ephemeral_VSM_Public_Key_In);   /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */
  SSA_DUMMY_STATEMENT(Data_Signature_In);   /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */
  SSA_DUMMY_STATEMENT(Certificates_In);   /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */
  SSA_DUMMY_STATEMENT(DataLength);   /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */

  /* #10 Start main loop processing for calculating the secret hash and the SecOC keys and wait until it is finished. */
  if (KeyM_DiagProc.state == KEYM_ROUTINE_SECOC_ECU_SHARED_SECRET_DIST_STATE_DERIVE_SECOC_KEYS)
  {
    if (KeyM_GetMainLoopStateLock() == TRUE)
    {
      Ssa_MemCpy(
        (P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR))KeyM_CarSpecificSecret,
        (P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA))&KeyM_DiagProc.ws.trustModelCommissioning.KeyM_SharedSecretEncDec_DataBuffer[SSA_KEYM_DIS_POSITION_DECRYPTED_SECRET],
        SSA_SIZEOF_SECRET);

      KeyM_MainLoopProc.conf = KEY_MAINLOOP_PROC_CONF_COMPLETE;
      KeyM_MainLoopProc.result = E_OK;
      KeyM_MainLoopProc.state = KEYM_GENERATE_SYM_KEYS_STATE_HASH_SECRET;

      KeyM_DiagProc.state = KEYM_ROUTINE_SECOC_ECU_SHARED_SECRET_DIST_STATE_WAIT_AND_SET_NEW_TIME;
    }
    else
    {
      /* remain in current state */
    }
  }

  if (KeyM_DiagProc.state == KEYM_ROUTINE_SECOC_ECU_SHARED_SECRET_DIST_STATE_WAIT_AND_SET_NEW_TIME)
  {
    /* #20 When finished clear temporary buffer containing among other things the decrypted secret. */
    if (KeyM_IsMainloopStateIdle())
    {
      KeyM_ClearDataBuffer(KeyM_DiagProc.ws.trustModelCommissioning.KeyM_SharedSecretEncDec_DataBuffer, SSA_KEYM_DIS_BUFFER_SIZE, SSA_KEYM_DIS_BUFFER_SIZE);

      /* #30 If everything ok so far set new time (real-time offset and tick-count). */
      KeyM_DiagProc.state = KEYM_ROUTINE_SECOC_ECU_SHARED_SECRET_DIST_STATE_DESTROY_NONCE;
      KeyM_DiagProc.ws.trustModelCommissioning.errorCode = DCM_E_CONDITIONSNOTCORRECT;
      if (KeyM_MainLoopProc.result == E_OK)
      {
        if (Rte_Call_TimeM_TimeRawData_Set(Date_and_Time_In, Tick_Count_Offset_In, Tick_Count_In) == RTE_E_OK)
        {
          /* proceed */
          KeyM_DiagProc.ws.trustModelCommissioning.errorCode = DCM_E_POSITIVERESPONSE;
        }
      }
    }
    else
    {
      /* remain in current state */
    }
  }

  return retVal;
}  /* PRQA S  6060 */ /* MD_SSA_STPAR */

/**********************************************************************************************************************
 * KeyM_EcuSharedSecretDistribution_HandleStateDestroyNonce()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
/* PRQA S 3673 13 */ /* MD_SSA_PARAM_NOT_P2CONST */
SSA_KEYM_LOCAL FUNC(Std_ReturnType, Ssa_KeyM_CODE) KeyM_EcuSharedSecretDistribution_HandleStateDestroyNonce(
  P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) Date_and_Time_In,
  P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) Tick_Count_In,
  P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) Tick_Count_Offset_In,
  P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) Encrypted_Nonce_and_Shared_Secret_In,
  P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) Ephemeral_VSM_Public_Key_In,
  P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) Data_Signature_In,
  P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) Certificates_In,
  uint16 DataLength)
{
  Std_ReturnType retVal = RTE_E_RoutineServices_Trust_Model_SecOC_ECU_Shared_Secret_Distribution_DCM_E_PENDING;
  Std_ReturnType result;

  SSA_DUMMY_STATEMENT(Date_and_Time_In);   /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */
  SSA_DUMMY_STATEMENT(Tick_Count_In);   /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */
  SSA_DUMMY_STATEMENT(Tick_Count_Offset_In);   /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */
  SSA_DUMMY_STATEMENT(Encrypted_Nonce_and_Shared_Secret_In);   /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */
  SSA_DUMMY_STATEMENT(Ephemeral_VSM_Public_Key_In);   /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */
  SSA_DUMMY_STATEMENT(Data_Signature_In);   /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */
  SSA_DUMMY_STATEMENT(Certificates_In);   /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */
  SSA_DUMMY_STATEMENT(DataLength);   /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */

  /* #10 Destroy Nonce stored at RightsM. */
  result = Rte_Call_RightsM_Nonce_Destroy();
  if (result == RTE_E_RightsM_Nonce_E_PENDING)
  {
    /* remain in current state, try again  */
  }
  else
  {
    if (result != RTE_E_OK)
    {
      /* abort routine */
      retVal = RTE_E_RoutineServices_Trust_Model_SecOC_ECU_Shared_Secret_Distribution_E_NOT_OK;
      KeyM_DiagProc.ws.trustModelCommissioning.errorCode = DCM_E_CONDITIONSNOTCORRECT;
    }
    else if (KeyM_DiagProc.ws.trustModelCommissioning.errorCode != DCM_E_POSITIVERESPONSE)
    {
      /* abort routine */
      retVal = RTE_E_RoutineServices_Trust_Model_SecOC_ECU_Shared_Secret_Distribution_E_NOT_OK;
    }
    else if (KeyM_DiagProc.ws.trustModelCommissioning.verificationResult != SSA_VER_RES_TRUST_MODEL_SECOC_CSS_ENCRYPT_CERTIFICATE_VERIFIED_SECOC_KEY_CALCULATED)
    {
      /* finish routine */
      retVal = RTE_E_OK;
    }
    else
    {
      /* finally finished */
      retVal = RTE_E_OK;
    }
    KeyM_DiagProc.state = KEYM_ROUTINE_SECOC_ECU_SHARED_SECRET_DIST_STATE_IDLE;
  }

  return retVal;
}  /* PRQA S  6060 */ /* MD_SSA_STPAR */

#endif

/**********************************************************************************************************************
 * KeyM_CopyValidEntry()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
SSA_KEYM_LOCAL FUNC(Std_ReturnType, Ssa_KeyM_CODE) KeyM_CopyValidEntry(
  P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) certBuf,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) targetDataBuf,
  P2VAR(uint16, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) targetLength,
  P2CONST(CertP_BerElementType, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) entry,
  uint32_least dataLength)
{
  /*@ assert dataLength == sizeof(Dcm_Data64ByteType); */
  /*@ assert $lengthOf(targetDataBuf) >= sizeof(Dcm_Data64ByteType); */
  Std_ReturnType retVal = E_NOT_OK;

  if ((entry->validContent) && (entry->elemDataLength <= dataLength))
  {
    retVal = E_OK;
    /* Copy valid entry */
    Ssa_MemCpy(targetDataBuf, (P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA))&(certBuf[entry->elemDataIdx]), entry->elemDataLength); /* VCA_SSA_KEYM_COPY_VALID_ENTRY */
    *targetLength = entry->elemDataLength;
  }

  return retVal;
}

/**********************************************************************************************************************
 * KeyM_GetEntry_SetVerification()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
SSA_KEYM_LOCAL FUNC(void, Ssa_KeyM_CODE) KeyM_GetEntry_SetVerification(
  Std_ReturnType result,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) Verification_Result_Out)
{
  if (result == E_OK)
  {
    *Verification_Result_Out = SSA_VER_RES_GET_CERTIFICATE_ENTRY_SUCCESSFULLY_READ;
  }
  else
  {
    *Verification_Result_Out = SSA_VER_RES_GET_CERTIFICATE_ENTRY_ENTRY_IN_CERTIFICATE_NOT_AVAILABLE;
  }
}

/**********************************************************************************************************************
 * KeyM_GetCertEntry_DiagnosticChain_ReadEntry()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 */
SSA_KEYM_LOCAL_INLINE FUNC(void, Ssa_KeyM_CODE) KeyM_GetCertEntry_DiagnosticChain_ReadEntry(
  uint8 entryId,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) Verification_Result_Out,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) Certificate_Content_Out,
  P2VAR(uint16, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) DataLength,
  P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) certBuf,
  P2CONST(CertP_ParsedCertStructureType, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) parsedCert)
{
  Std_ReturnType tmpRVal;

  switch (entryId)
  {
    case SSA_KEYM_CERT_ENTRY_ENTRY_ID_SERIAL_NUMBER:
      tmpRVal = KeyM_GetSerialNumberFromCert(certBuf, &parsedCert->serialNumber, Certificate_Content_Out, SSA_SIZEOF_SERIALNUMBER);
      KeyM_GetEntry_SetVerification(tmpRVal, Verification_Result_Out);
      if (tmpRVal == E_OK)
      {
        *DataLength = SSA_SIZEOF_SERIALNUMBER;
      }
      break;

    case SSA_KEYM_CERT_ENTRY_ENTRY_ID_SUBJECT:
      KeyM_GetEntry_SetVerification(
        KeyM_CopyValidEntry(certBuf, Certificate_Content_Out, DataLength, &parsedCert->subject, SSA_KEYM_CERT_ENTRY_SIZEOF_ENTRY_BUFFER),
        Verification_Result_Out);
      break;

    case SSA_KEYM_CERT_ENTRY_ENTRY_ID_SPECIAL_ECU:
      /* Check if parsed entry is empty/not available (relevant for optional entry) */
      if (parsedCert->specialECU == SSA_KEYM_CERT_ENTRY_CONTENT_NOT_AVAILABLE)
      {
        *Verification_Result_Out = SSA_VER_RES_GET_CERTIFICATE_ENTRY_ENTRY_IN_CERTIFICATE_NOT_AVAILABLE;
      }
      else
      {
        /* Copy valid entry */
        Certificate_Content_Out[0] = parsedCert->specialECU;
        *DataLength = sizeof(parsedCert->specialECU);
      }
      break;

    case SSA_KEYM_CERT_ENTRY_ENTRY_ID_SUBJECT_PUBLIC_KEY:
      KeyM_GetEntry_SetVerification(
        KeyM_CopyValidEntry(certBuf, Certificate_Content_Out, DataLength, &parsedCert->publicKey, SSA_KEYM_CERT_ENTRY_SIZEOF_ENTRY_BUFFER),
        Verification_Result_Out);
      break;

    case SSA_KEYM_CERT_ENTRY_ENTRY_ID_ISSUER:
      KeyM_GetEntry_SetVerification(
        KeyM_CopyValidEntry(certBuf, Certificate_Content_Out, DataLength, &parsedCert->issuer, SSA_KEYM_CERT_ENTRY_SIZEOF_ENTRY_BUFFER),
        Verification_Result_Out);
      break;

    case SSA_KEYM_CERT_ENTRY_ENTRY_ID_SUBJECT_KEY_IDENTIFIER:
      KeyM_GetEntry_SetVerification(
        KeyM_CopyValidEntry(certBuf, Certificate_Content_Out, DataLength, &parsedCert->subjectKeyIdentifier, SSA_KEYM_CERT_ENTRY_SIZEOF_ENTRY_BUFFER),
        Verification_Result_Out);
      break;

    case SSA_KEYM_CERT_ENTRY_ENTRY_ID_AUTHORITY_KEY_IDENTIFIER:
      KeyM_GetEntry_SetVerification(
        KeyM_CopyValidEntry(certBuf, Certificate_Content_Out, DataLength, &parsedCert->authorityKeyIdentifier, SSA_KEYM_CERT_ENTRY_SIZEOF_ENTRY_BUFFER),
        Verification_Result_Out);
      break;

    case SSA_KEYM_CERT_ENTRY_ENTRY_ID_PKI_ROLE:
      /* Check if parsed entry is empty/not available. */
      if (parsedCert->pkiRole == SSA_KEYM_CERT_ENTRY_CONTENT_NOT_AVAILABLE)
      {
        *Verification_Result_Out = SSA_VER_RES_GET_CERTIFICATE_ENTRY_ENTRY_IN_CERTIFICATE_NOT_AVAILABLE;
      }
      else
      {
        /* Copy valid entry */
        Certificate_Content_Out[0] = parsedCert->pkiRole;
        *DataLength = sizeof(parsedCert->pkiRole);
      }
      break;

    case SSA_KEYM_CERT_ENTRY_ENTRY_ID_PROD_QUALIFIER:
      /* Check if parsed entry is empty/not available. */
      if (parsedCert->prodQualifier == SSA_KEYM_CERT_ENTRY_CONTENT_NOT_AVAILABLE)
      {
        *Verification_Result_Out = SSA_VER_RES_GET_CERTIFICATE_ENTRY_ENTRY_IN_CERTIFICATE_NOT_AVAILABLE;
      }
      else
      {
        /* Copy valid entry */
        Certificate_Content_Out[0] = parsedCert->prodQualifier;
        *DataLength = sizeof(parsedCert->prodQualifier);
      }
      break;

    default:
      *Verification_Result_Out = SSA_VER_RES_GET_CERTIFICATE_ENTRY_ENTRY_IN_CERTIFICATE_NOT_AVAILABLE;
      break;
  }
} /* PRQA S 6030, 6060 */ /* MD_MSR_STCYC, MD_SSA_STPAR */

/**********************************************************************************************************************
 * KeyM_GetCertEntry_IsIdValid()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
SSA_KEYM_LOCAL_INLINE FUNC(boolean, Ssa_KeyM_CODE) KeyM_GetCertEntry_IsIdValid(
  uint8 lowerInvalid,
  uint8 upperValid,
  uint8 id)
{
  boolean valid = FALSE;

  if ((id > lowerInvalid) &&
    (id <= upperValid))
  {
    valid = TRUE;
  }

  return valid;
}

/**********************************************************************************************************************
 * KeyM_GetCertEntry_DiagnosticChain()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 */
SSA_KEYM_LOCAL_INLINE FUNC(void, Ssa_KeyM_CODE) KeyM_GetCertEntry_DiagnosticChain(
  uint8 Certificate_Identification_In,
  uint8 In_Certificate_Entry_In,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) Verification_Result_Out,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) Certificate_Content_Out,
  P2VAR(uint16, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) DataLength)
{

  P2CONST(CertP_ParsedCertStructureType, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) parsedCert = &KeyM_ParsedRootCert;  /* PRQA S 2981 */ /* MD_SSA_REDUNDANT_INITIALIZATION */
#if (SSA_KEEP_BUFFER_VARIABLES_STATIC == STD_ON)
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) certBuf = KeyM_RootCertBuf;  /* PRQA S 2981 */ /* MD_SSA_REDUNDANT_INITIALIZATION */
#else
  uint8 certBuf[SSA_SIZEOF_CERT_MAX];
#endif
  uint16 certLength = SSA_SIZEOF_CERT_MAX;

  Std_ReturnType tmpRVal;
  CertP_PkiRoleType pkiRole = CERTP_PKI_ROLE_ROOT;  /* PRQA S 2981 */ /* MD_SSA_REDUNDANT_INITIALIZATION */
  uint8 certId = Certificate_Identification_In;
  uint8 entryId = In_Certificate_Entry_In;

  boolean failed = FALSE;

  /* Dispatch certificate. */
  switch (certId)
  {
    case SSA_KEYM_CERT_ENTRY_CERT_ID_ROOT_CA_CERT:
      pkiRole = CERTP_PKI_ROLE_ROOT;
      parsedCert = &KeyM_ParsedRootCert;
#if (SSA_KEEP_BUFFER_VARIABLES_STATIC == STD_ON)
      certBuf = KeyM_RootCertBuf;
#endif
      break;

    case SSA_KEYM_CERT_ENTRY_CERT_ID_BACKEND_CA_CERT:
      pkiRole = CERTP_PKI_ROLE_BACKEND;
      parsedCert = &KeyM_ParsedBackendCert;
#if (SSA_KEEP_BUFFER_VARIABLES_STATIC == STD_ON)
      certBuf = KeyM_BackendCertBuf;
#endif
      break;

#if (SSA_ECU_TYPE == SSA_ECU_TYPE_VSM)
    case SSA_KEYM_CERT_ENTRY_CERT_ID_ECU_CA_CERT:
      pkiRole = CERTP_PKI_ROLE_ECU;
      parsedCert = &KeyM_ParsedEcuCert;
# if (SSA_KEEP_BUFFER_VARIABLES_STATIC == STD_ON)
      certBuf = KeyM_EcuCertBuf;
# endif
      break;
#endif

    default:
      failed = TRUE;
      *Verification_Result_Out = SSA_VER_RES_GET_CERTIFICATE_ENTRY_CERTIFICATE_NOT_FOUND;
      break;
  }

  if (!failed)
  {
    /* Parse stored certificate. */
    tmpRVal = KeyM_GetAndParseStoredCert(pkiRole, (P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR))certBuf, &certLength, FALSE);
    if (tmpRVal != E_OK)
    {
      failed = TRUE;
      *Verification_Result_Out = SSA_VER_RES_GET_CERTIFICATE_ENTRY_CERTIFICATE_INVALID;
    }
    else
    {
      /* set already positive verification result, which will be overwritten when reading the entry fails */
      *Verification_Result_Out = SSA_VER_RES_GET_CERTIFICATE_ENTRY_SUCCESSFULLY_READ;
    }

    if (!failed)
    {
      /* Dispatch entry. */
      KeyM_GetCertEntry_DiagnosticChain_ReadEntry(entryId,
                                                      Verification_Result_Out, Certificate_Content_Out, DataLength,
                                                      certBuf, parsedCert);
    }
  }
} /* PRQA S 6060 */ /* MD_SSA_STPAR */

/**********************************************************************************************************************
 * KeyM_GetCertEntry_TrustModel()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 */
SSA_KEYM_LOCAL_INLINE FUNC(Std_ReturnType, Ssa_KeyM_CODE) KeyM_GetCertEntry_TrustModel(
  uint8 Certificate_Identification_In,
  uint8 In_Certificate_Entry_In,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) Verification_Result_Out,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) Certificate_Content_Out,
  P2VAR(uint16, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) DataLength,
  P2VAR(Dcm_NegativeResponseCodeType, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) ErrorCode)
{
  /*@ assert Certificate_Identification_In > SSA_KEYM_CERT_ENTRY_CERT_ID_ECU_CA_CERT && Certificate_Identification_In <= SSA_KEYM_CERT_ENTRY_CERT_ID_TRUSTMODEL_ECU_CA_CERT; */
  /*@ assert In_Certificate_Entry_In > 0 && In_Certificate_Entry_In <= 10; */

  KeyM_CertificateIdType localCertId;
  KeyM_CertElementIdType localElementId;
  uint32 length = SSA_KEYM_CERT_ENTRY_SIZEOF_ENTRY_BUFFER;
  Std_ReturnType retVal = RTE_E_OK, localRet;

  /* Find service */
  localCertId = (KeyM_CertificateIdType)((KeyM_CertificateIdType)Certificate_Identification_In - SSA_KEYM_CERT_ENTRY_CERT_ID_TRUSTMODEL_ROOT_CA_CERT);
  /*@ assert localCertId >= 0 && localCertId <= 3; */

  /* Get element ID */
  localElementId = (KeyM_CertElementIdType)((KeyM_CertElementIdType)In_Certificate_Entry_In - 1u); /* no overflow due to VCA assertion */
  if (KeyM_GetCertEntry_KeyM_CertElementGet_List[localCertId][localElementId] != NULL_PTR)
  {
    /* Read certificate entry */
    localRet = KeyM_GetCertEntry_KeyM_CertElementGet_List[localCertId][localElementId](Certificate_Content_Out, &length); /* VCA_SSA_KEYM_CALL_FUNCTION_FROM_CERTELEMENTGET_LIST */

    /* Handle result */
    switch (localRet)
    {
      case SSA_KEYM_ASR_KEYM_E_OK:
        *Verification_Result_Out = SSA_VER_RES_GET_CERTIFICATE_ENTRY_SUCCESSFULLY_READ;
        if (In_Certificate_Entry_In == SSA_KEYM_CERT_ENTRY_ENTRY_ID_SERIAL_NUMBER)
        {
          /* Transform serial number format */
          localRet = Ssa_Utils_ConvertSerialNumber(Certificate_Content_Out, (uint16)length, Certificate_Content_Out, SSA_SIZEOF_SERIALNUMBER);
          KeyM_GetEntry_SetVerification(localRet, Verification_Result_Out);
          if (localRet == E_OK)
          {
            *DataLength = SSA_SIZEOF_SERIALNUMBER;
          }
        }
        else if ((In_Certificate_Entry_In == SSA_KEYM_CERT_ENTRY_ENTRY_ID_SUBJECT_PUBLIC_KEY)
              && (length == (SSA_SIZEOF_PUBLICKEY + 1u))
              && (Certificate_Content_Out[0] == 0x00u))
        {
          /* Discard the first byte */
          Ssa_MemCpy(&Certificate_Content_Out[0], &Certificate_Content_Out[1], SSA_SIZEOF_PUBLICKEY);
          *DataLength = SSA_SIZEOF_PUBLICKEY;
        }
        else
        {
          /* cast is ok since length has been restricted to sizeof(Dcm_Data64ByteType) */
          *DataLength = (uint16)length;
        }
        break;
      case SSA_KEYM_ASR_KEYM_E_NOT_OK:
        *Verification_Result_Out = SSA_VER_RES_GET_CERTIFICATE_ENTRY_ENTRY_IN_CERTIFICATE_NOT_AVAILABLE;
        break;
      case SSA_KEYM_ASR_KEYM_E_KEY_CERT_EMPTY:
        /* Fall through */
      case SSA_KEYM_ASR_KEYM_E_KEY_CERT_INVALID:
        *Verification_Result_Out = SSA_VER_RES_GET_CERTIFICATE_ENTRY_CERTIFICATE_INVALID;
        break;
      default:
        /* SSA_KEYM_ASR_KEYM_E_PARAMETER_MISMATCH
         * SSA_KEYM_ASR_KEYM_E_KEY_CERT_SIZE_MISMATCH
         * RTE_E_UNCONNECTED */
        *ErrorCode = DCM_E_GENERALREJECT;
        retVal = RTE_E_RoutineServices_Get_Certificate_Entry_E_NOT_OK;
        break;
    }
  }
  else
  {
    *Verification_Result_Out = SSA_VER_RES_GET_CERTIFICATE_ENTRY_ENTRY_IN_CERTIFICATE_NOT_AVAILABLE;
  }

  return retVal;
} /* PRQA S 6060 */ /* MD_SSA_STPAR */

#if (SSA_ECU_TYPE != SSA_ECU_TYPE_VSM)

# if (SSA_DIAG_SERVICE_INJECT_SEED == STD_ON)

/**********************************************************************************************************************
 * KeyM_InjectSeed_HandleStateIdle()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 */
SSA_KEYM_LOCAL FUNC(Std_ReturnType, Ssa_KeyM_CODE) KeyM_InjectSeed_HandleStateIdle(
  P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) Ephemeral_Backend_Public_Key_In,
  P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) Data_Signature_In,
  P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) Encrypted_Seed_In,
  uint16 DataLength)
{
  Std_ReturnType retVal = RTE_E_RoutineServices_Inject_Seed_DCM_E_PENDING;
  Std_ReturnType result;
  uint16 encryptedSeedLength = 0u;

  /* set initial error code and verification result */
  KeyM_DiagProc.ws.injectSeed.errorCode = DCM_E_POSITIVERESPONSE;
  KeyM_DiagProc.ws.injectSeed.verificationResult = SSA_VER_RES_INJECT_SEED_SUCCESSFULLY_SEEDED;

  if ((DataLength < 2u) || (DataLength > sizeof(Dcm_Data1058ByteType)))
  {
    /* abort routine */
    retVal = RTE_E_RoutineServices_Inject_Seed_E_NOT_OK;
    KeyM_DiagProc.ws.injectSeed.errorCode = DCM_E_INCORRECTMESSAGELENGTHORINVALIDFORMAT;
  }
  else if (DataLength < (KeyM_GetUint16(Encrypted_Seed_In[0u], Encrypted_Seed_In[1u]) + 2u))
  {
    /* abort routine */
    retVal = RTE_E_RoutineServices_Inject_Seed_E_NOT_OK;
    KeyM_DiagProc.ws.injectSeed.errorCode = DCM_E_INCORRECTMESSAGELENGTHORINVALIDFORMAT;
  }
  else
  {
    /* get seed length */
    encryptedSeedLength = KeyM_GetUint16(Encrypted_Seed_In[0u], Encrypted_Seed_In[1u]);
    /*@ assert DataLength <= sizeof(Dcm_Data1058ByteType); */
    /*@ assert (encryptedSeedLength + 2u) <= DataLength; */ /* VCA_SSA_KEYM_COPY_TO_INJECTSEED_DATABUFFER */
    KeyM_DiagProc.ws.injectSeed.seedLength = encryptedSeedLength;

    /* get nonce (but not a new one) */
    result = Rte_Call_RightsM_Nonce_Get(FALSE, KeyM_DiagProc.ws.injectSeed.currentNonce);

    if (result == RTE_E_RightsM_Nonce_E_INVALID)
    {
      /* there is no current nonce, finish routine */
      retVal = RTE_E_OK;
      KeyM_DiagProc.ws.injectSeed.verificationResult = SSA_VER_RES_INJECT_SEED_INVALID_NONCE;
    }
    else if (result != RTE_E_OK)
    {
      /* abort routine */
      retVal = RTE_E_RoutineServices_Inject_Seed_E_NOT_OK;
      KeyM_DiagProc.ws.injectSeed.errorCode = DCM_E_GENERALREJECT;
    }
    else
    {
      /* Gather data for signature verification */

      /*@ assert $lengthOf(KeyM_DiagProc.ws.injectSeed.dataBuffer) >= SSA_KEYM_INJECT_SEED_DATA_BUFFER_SIZE; */
      /*@ assert SSA_KEYM_INJECT_SEED_DATA_BUFFER_SIZE == (sizeof(Dcm_Data1058ByteType) + sizeof(Dcm_Data32ByteType)); */
      /*@ assert KeyM_DiagProc.ws.injectSeed.seedLength <= 1056; */ /* VCA_SSA_KEYM_COPY_TO_INJECTSEED_DATABUFFER */
      /*@ assert SSA_SIZEOF_PUBLICKEY == sizeof(Dcm_Data32ByteType); */

      Ssa_MemCpy( /* VCA_SSA_KEYM_COPY_TO_INJECTSEED_DATABUFFER */
        (P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR))&KeyM_DiagProc.ws.injectSeed.dataBuffer[0u],
        &Encrypted_Seed_In[2u],
        KeyM_DiagProc.ws.injectSeed.seedLength);
      Ssa_MemCpy( /* VCA_SSA_KEYM_COPY_TO_INJECTSEED_DATABUFFER */
        (P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR))&KeyM_DiagProc.ws.injectSeed.dataBuffer[KeyM_DiagProc.ws.injectSeed.seedLength],
        Ephemeral_Backend_Public_Key_In,
        SSA_SIZEOF_PUBLICKEY);

      /* change state */
      KeyM_DiagProc.state = SSA_KEYM_ROUTINE_INJECT_SEED_STATE_VERIFY_SIGNATURE;
    }
  }

  SSA_DUMMY_STATEMENT(Data_Signature_In);   /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */

  return retVal;
}

/**********************************************************************************************************************
 * KeyM_InjectSeed_HandleStateVerifySignature()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
SSA_KEYM_LOCAL FUNC(Std_ReturnType, Ssa_KeyM_CODE) KeyM_InjectSeed_HandleStateVerifySignature(
  P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) Ephemeral_Backend_Public_Key_In,
  P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) Data_Signature_In,
  P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) Encrypted_Seed_In,
  uint16 DataLength)
{
  Std_ReturnType retVal = RTE_E_RoutineServices_Inject_Seed_DCM_E_PENDING;
  Std_ReturnType result;

  /* verify signature */
  result = KeyM_CsmSignatureVerify(
    SSA_TRUST_MODEL_LIVE_BACKEND_PUBLIC_KEY,
    KeyM_DiagProc.ws.injectSeed.dataBuffer,
    KeyM_DiagProc.ws.injectSeed.seedLength + SSA_SIZEOF_PUBLICKEY,
    Data_Signature_In,
    &KeyM_DiagProc.ws.injectSeed.verificationResult);

  if (result == SSA_E_PENDING)
  {
    /* remain in current state */
  }
  else if (result != E_OK)
  {
    /* abort routine */
    retVal = RTE_E_RoutineServices_Inject_Seed_E_NOT_OK;
    KeyM_DiagProc.ws.injectSeed.errorCode = DCM_E_GENERALREJECT;
  }
  else if (KeyM_DiagProc.ws.injectSeed.verificationResult != CRYPTO_E_VER_OK)
  {
    /* finish routine */
    retVal = RTE_E_OK;
    KeyM_DiagProc.ws.injectSeed.verificationResult = SSA_VER_RES_INJECT_SEED_INVALID_DATA_SIGNATURE;
  }
  else
  {
    /* proceed routine */
    KeyM_DiagProc.state = SSA_KEYM_ROUTINE_INJECT_SEED_STATE_KEYEXCHANGE;
    /* call directly next state handler to avoid main function call */
    retVal = KeyM_InjectSeed_HandleStateKeyExchange(Ephemeral_Backend_Public_Key_In, Data_Signature_In, Encrypted_Seed_In, DataLength);
  }

  SSA_DUMMY_STATEMENT(Ephemeral_Backend_Public_Key_In);   /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */
  SSA_DUMMY_STATEMENT(Encrypted_Seed_In);   /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */
  SSA_DUMMY_STATEMENT(DataLength);   /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */

  return retVal;
}

/**********************************************************************************************************************
 * KeyM_InjectSeed_HandleStateKeyExchange()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 */
SSA_KEYM_LOCAL FUNC(Std_ReturnType, Ssa_KeyM_CODE) KeyM_InjectSeed_HandleStateKeyExchange(
  P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) Ephemeral_Backend_Public_Key_In,
  P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) Data_Signature_In,
  P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) Encrypted_Seed_In,
  uint16 DataLength)
{
  Std_ReturnType retVal = RTE_E_RoutineServices_Inject_Seed_DCM_E_PENDING;
  Std_ReturnType result;

  /* derive session key */
  result = KeyM_KeyExchangeCalcSymmetricKey(
    Ephemeral_Backend_Public_Key_In,
    (P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR))KeyM_DiagProc.ws.injectSeed.currentNonce,
    NULL_PTR);

  if (result == SSA_E_PENDING)
  {
    /* remain in current state */
  }
  else if (result != E_OK)
  {
    /* abort routine but destroy nonce before */
    KeyM_DiagProc.ws.injectSeed.errorCode = DCM_E_CONDITIONSNOTCORRECT;
    KeyM_DiagProc.state = SSA_KEYM_ROUTINE_INJECT_SEED_STATE_DESTROY_NONCE;
  }
  else
  {
    /* proceed routine */
    KeyM_DiagProc.state = SSA_KEYM_ROUTINE_INJECT_SEED_STATE_DECRYPT;
    /* call directly next state handler to avoid main function call */
    retVal = KeyM_InjectSeed_HandleStateDecrypt(Ephemeral_Backend_Public_Key_In, Data_Signature_In, Encrypted_Seed_In, DataLength);
  }

  SSA_DUMMY_STATEMENT(Data_Signature_In);   /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */
  SSA_DUMMY_STATEMENT(Encrypted_Seed_In);   /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */
  SSA_DUMMY_STATEMENT(DataLength);   /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */

  return retVal;
}

/**********************************************************************************************************************
 * KeyM_InjectSeed_HandleStateDecrypt()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 */
SSA_KEYM_LOCAL FUNC(Std_ReturnType, Ssa_KeyM_CODE) KeyM_InjectSeed_HandleStateDecrypt(
  P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) Ephemeral_Backend_Public_Key_In,
  P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) Data_Signature_In,
  P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) Encrypted_Seed_In,
  uint16 DataLength)
{
  Std_ReturnType retVal = RTE_E_RoutineServices_Inject_Seed_DCM_E_PENDING;
  Std_ReturnType result;

  uint32 resultLength = SSA_KEYM_INJECT_SEED_DATA_BUFFER_SIZE;

  /*@ assert &Encrypted_Seed_In[2u] != NULL_PTR; */
  /*@ assert KeyM_DiagProc.ws.injectSeed.dataBuffer != NULL_PTR; */
  /*@ assert &resultLength != NULL_PTR; */
  /*@ assert $lengthOf(KeyM_DiagProc.ws.injectSeed.dataBuffer) >= resultLength; */
  /*@ assert $lengthOf(KeyM_DiagProc.ws.injectSeed.dataBuffer) >= sizeof(Csm_DecryptResultType_AES128DecryptWithPadding); */

  /* Encrypted_Seed_In is of size sizeof(Dcm_Data1058ByteType) */
  result = Rte_Call_CsmSymAES128DecryptWithPadding_Decrypt( /* VCA_SSA_KEYM_FUNCTION_REQUIREMENTS_VIOLATED */
    &Encrypted_Seed_In[2u],
    KeyM_DiagProc.ws.injectSeed.seedLength,
    KeyM_DiagProc.ws.injectSeed.dataBuffer,
    &resultLength);

  if (result == SSA_CRYPTO_E_BUSY)
  {
    /* remain in current state, try again */
  }
  else if (result != RTE_E_OK)
  {
    KeyM_DiagProc.ws.injectSeed.errorCode = DCM_E_CONDITIONSNOTCORRECT;
    KeyM_DiagProc.state = SSA_KEYM_ROUTINE_INJECT_SEED_STATE_DESTROY_NONCE;
  }
  else if (resultLength < SSA_SIZEOF_NONCE)
  {
    /* too less data for checking nonce, finish routine */
    KeyM_DiagProc.ws.injectSeed.verificationResult = SSA_VER_RES_INJECT_SEED_INVALID_NONCE;
    KeyM_DiagProc.state = SSA_KEYM_ROUTINE_INJECT_SEED_STATE_DESTROY_NONCE;
  }
  else if (!KeyM_CompareData(
    KeyM_DiagProc.ws.injectSeed.currentNonce,
    &KeyM_DiagProc.ws.injectSeed.dataBuffer[resultLength - SSA_SIZEOF_NONCE],
    SSA_SIZEOF_NONCE))
  {
    /* invalid nonce, finish routine */
    KeyM_DiagProc.ws.injectSeed.verificationResult = SSA_VER_RES_INJECT_SEED_INVALID_NONCE;
    KeyM_DiagProc.state = SSA_KEYM_ROUTINE_INJECT_SEED_STATE_DESTROY_NONCE;
  }
  else
  {
    /* get seed size */
    KeyM_DiagProc.ws.injectSeed.seedLength = resultLength - SSA_SIZEOF_NONCE;
    /* proceed routine */
    KeyM_DiagProc.state = SSA_KEYM_ROUTINE_INJECT_SEED_STATE_SEED_RNG;
  }

  SSA_DUMMY_STATEMENT(Ephemeral_Backend_Public_Key_In);   /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */
  SSA_DUMMY_STATEMENT(Data_Signature_In);   /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */
  SSA_DUMMY_STATEMENT(DataLength);   /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */

  return retVal;
}

/**********************************************************************************************************************
 * Ssa_KeyM_InjectSeed_HandleStateSeedRng()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 */
SSA_KEYM_LOCAL FUNC(Std_ReturnType, Ssa_KeyM_CODE) Ssa_KeyM_InjectSeed_HandleStateSeedRng(
  P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) Ephemeral_Backend_Public_Key_In,
  P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) Data_Signature_In,
  P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) Encrypted_Seed_In,
  uint16 DataLength)
{
  Std_ReturnType retVal = RTE_E_RoutineServices_Inject_Seed_DCM_E_PENDING;
  Std_ReturnType result;

  result = KeyM_CsmRandomSeed(KeyM_DiagProc.ws.injectSeed.dataBuffer, KeyM_DiagProc.ws.injectSeed.seedLength);
  if (result == SSA_E_PENDING)
  {
    /* remain in current state */
  }
  else if (result != RTE_E_OK)
    {
      /* abort routine */
      KeyM_DiagProc.ws.injectSeed.errorCode = DCM_E_CONDITIONSNOTCORRECT;
      KeyM_DiagProc.state = SSA_KEYM_ROUTINE_INJECT_SEED_STATE_DESTROY_NONCE;
    }
  else
  {
    /* proceed routine */
    KeyM_DiagProc.ws.injectSeed.verificationResult = SSA_VER_RES_INJECT_SEED_SUCCESSFULLY_SEEDED;
    KeyM_DiagProc.state = SSA_KEYM_ROUTINE_INJECT_SEED_STATE_DESTROY_NONCE;
    /* call directly next state handler to avoid main function call */
    retVal = KeyM_InjectSeed_HandleStateDestroyNonce(Ephemeral_Backend_Public_Key_In, Data_Signature_In, Encrypted_Seed_In, DataLength);
  }

  SSA_DUMMY_STATEMENT(Ephemeral_Backend_Public_Key_In);   /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */
  SSA_DUMMY_STATEMENT(Data_Signature_In);   /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */
  SSA_DUMMY_STATEMENT(Encrypted_Seed_In);   /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */
  SSA_DUMMY_STATEMENT(DataLength);   /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */

  return retVal;
}

/**********************************************************************************************************************
 * KeyM_InjectSeed_HandleStateDestroyNonce()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 */
SSA_KEYM_LOCAL FUNC(Std_ReturnType, Ssa_KeyM_CODE) KeyM_InjectSeed_HandleStateDestroyNonce(
  P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) Ephemeral_Backend_Public_Key_In,
  P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) Data_Signature_In,
  P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) Encrypted_Seed_In,
  uint16 DataLength)
{
  Std_ReturnType retVal = RTE_E_RoutineServices_Inject_Seed_DCM_E_PENDING;
  Std_ReturnType result;

  /* Destroy Nonce stored at RightsM. */
  result = Rte_Call_RightsM_Nonce_Destroy();
  if (result == RTE_E_RightsM_Nonce_E_PENDING)
  {
    /* remain in current state, try again  */
  }
  else
  {
    if (result != RTE_E_OK)
    {
      /* abort routine */
      retVal = RTE_E_RoutineServices_Inject_Seed_E_NOT_OK;
      KeyM_DiagProc.ws.injectSeed.errorCode = DCM_E_CONDITIONSNOTCORRECT;
    }
    else if (KeyM_DiagProc.ws.injectSeed.errorCode != DCM_E_POSITIVERESPONSE)
    {
      /* abort routine */
      retVal = RTE_E_RoutineServices_Inject_Seed_E_NOT_OK;
    }
    else if (KeyM_DiagProc.ws.injectSeed.verificationResult != SSA_VER_RES_INJECT_SEED_SUCCESSFULLY_SEEDED)
    {
      /* finish routine */
      retVal = RTE_E_OK;
    }
    else
    {
      /* proceed routine */
      KeyM_DiagProc.state = SSA_KEYM_ROUTINE_INJECT_SEED_STATE_STORE_INIT;
      /* call directly next state handler to avoid main function call */
      retVal = KeyM_InjectSeed_HandleStateStorePermanently(Ephemeral_Backend_Public_Key_In, Data_Signature_In, Encrypted_Seed_In, DataLength);
    }
  }

  SSA_DUMMY_STATEMENT(Ephemeral_Backend_Public_Key_In);   /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */
  SSA_DUMMY_STATEMENT(Data_Signature_In);   /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */
  SSA_DUMMY_STATEMENT(Encrypted_Seed_In);   /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */
  SSA_DUMMY_STATEMENT(DataLength);   /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */

  return retVal;
}

/**********************************************************************************************************************
 * KeyM_InjectSeed_HandleStateStorePermanently()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
SSA_KEYM_LOCAL FUNC(Std_ReturnType, Ssa_KeyM_CODE) KeyM_InjectSeed_HandleStateStorePermanently(
  P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) Ephemeral_Backend_Public_Key_In,
  P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) Data_Signature_In,
  P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) Encrypted_Seed_In,
  uint16 DataLength)
{
  Std_ReturnType retVal = RTE_E_RoutineServices_Inject_Seed_DCM_E_PENDING;
  Std_ReturnType result;

  /* Trigger the application to store the RNG's seed state and wait until storing is finished. */
  result = Rte_Call_Ssa_KeyStorage_StorePermanently(
    SSA_KEYSTORAGE_USECASE_RNG_SEED_STATE,
      (KeyM_DiagProc.state == SSA_KEYM_ROUTINE_INJECT_SEED_STATE_STORE_INIT) ? SSA_KEYSTORAGE_TASK_INITIAL
                                                                             : SSA_KEYSTORAGE_TASK_CHECKSTATE);

  if (result == RTE_E_Ssa_KeyStorage_E_PENDING)
  {
    KeyM_DiagProc.state = SSA_KEYM_ROUTINE_INJECT_SEED_STATE_STORE_PENDING;
  }
  else if (result == E_OK)
  {
    /* finally finish routine */
    retVal = RTE_E_OK;
  }
  else
  {
    /* abort routine */
    retVal = RTE_E_RoutineServices_Inject_Seed_E_NOT_OK;
    KeyM_DiagProc.ws.injectSeed.errorCode = DCM_E_GENERALPROGRAMMINGFAILURE;
  }

  SSA_DUMMY_STATEMENT(Ephemeral_Backend_Public_Key_In);   /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */
  SSA_DUMMY_STATEMENT(Data_Signature_In);   /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */
  SSA_DUMMY_STATEMENT(Encrypted_Seed_In);   /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */
  SSA_DUMMY_STATEMENT(DataLength);   /* PRQA S 1338, 2983, 3112  */ /* MD_MSR_DummyStmt */ /*lint -e{438} */

  return retVal;
}

# endif /* (SSA_DIAG_SERVICE_INJECT_SEED == STD_ON) */

#endif /* (SSA_ECU_TYPE != SSA_ECU_TYPE_VSM) */

/**********************************************************************************************************************
 * KeyM_GetNumBytesNeededForDerEncoding()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
SSA_KEYM_LOCAL FUNC(uint16, Ssa_KeyM_CODE) KeyM_GetNumBytesNeededForDerEncoding(
  uint16 lenIn)
{
  uint16 num;

  /* #10 Derive number of bytes needed for the DER encoding depending in input length. */
  if (lenIn < 0x80uL)
  {
    num = 2u;
  }
  else if (lenIn < 0x100uL)
  {
    num = 3u;
  }
  else
  {
    num = 4u;
  }
  return num + lenIn;
}

/**********************************************************************************************************************
 * KeyM_GetNumBytesNeededForEncodingUniqueEcuIds()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 */
SSA_KEYM_LOCAL FUNC(Std_ReturnType, Ssa_KeyM_CODE) KeyM_GetNumBytesNeededForEncodingUniqueEcuIds(
  P2VAR(uint16, AUTOMATIC, AUTOMATIC) sizeOctetString,
  P2VAR(uint16, AUTOMATIC, AUTOMATIC) sizeSet)
{
  Std_ReturnType retVal = E_OK;
  uint16 num=0u;
  uint16 currentLength = 0u;
  uint16 i;

  *sizeOctetString = 0u;
  *sizeSet = 0u;

  /* #10 Iterate through the configured UniqueEcuIDs and get number of bytes used for DER encoding */
  for (i = 0u; i < Ssa_GetSizeOfUniqueEcuId(); ++i)
  {
    currentLength = (uint16)((uint16)Ssa_GetUniqueEcuIdsUniqueEcuIdsEndIdxOfUniqueEcuId(i) -
                             (uint16)Ssa_GetUniqueEcuIdsUniqueEcuIdsStartIdxOfUniqueEcuId(i));
    if (currentLength <= SSA_MAX_SIZEOF_UNIQUEECUID) /* COV_SSA_KEYM_UNIQUE_ECU_ID_LENGTH_CHECK */
    {
      num += KeyM_GetNumBytesNeededForDerEncoding(currentLength);
    }
    else
    {
      retVal = E_NOT_OK;
      break;
    }
  }

  if (retVal == E_OK) /* COV_SSA_KEYM_UNIQUE_ECU_ID_LENGTH_CHECK */
  {
    /* #20 Get additionally needed number for SET and OCTET STRING structure */
    *sizeSet = num;
    *sizeOctetString = KeyM_GetNumBytesNeededForDerEncoding(*sizeSet);
    /* The total number of bytes to store the encoded unique ECU IDs is given by
     * num = KeyM_GetNumBytesNeededForDerEncoding(*sizeOctetString); */
  }

  return retVal;
}

/**********************************************************************************************************************
 * KeyM_PrepareDerEncodingElement()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
SSA_KEYM_LOCAL FUNC(void, Ssa_KeyM_CODE) KeyM_PrepareDerEncodingElement(
  P2VAR(uint8, AUTOMATIC, AUTOMATIC) buffer,
  P2VAR(uint16, AUTOMATIC, AUTOMATIC) bufferIndex,
  uint16 bufferLen,
  uint8 tag,
  uint16 lenIn)
{
  /*@ assert $lengthOf(buffer) >= bufferLen; */
  /* #10 Set the tag and then the length information depending on input length and update buffer index. */
  buffer[(*bufferIndex)%bufferLen] = tag; /* VCA_SSA_KEYM_ENCODING_ELEMENT_BUFFER_ACCESS */
  (*bufferIndex)++;
  if (lenIn < 0x80uL)
  {
    buffer[(*bufferIndex)%bufferLen] = (uint8)lenIn; /* VCA_SSA_KEYM_ENCODING_ELEMENT_BUFFER_ACCESS */
    (*bufferIndex)++;
  }
  else if (lenIn < 0x100uL)
  {
    buffer[(*bufferIndex)%bufferLen] = 0x81u; /* VCA_SSA_KEYM_ENCODING_ELEMENT_BUFFER_ACCESS */
    (*bufferIndex)++;
    buffer[(*bufferIndex)%bufferLen] = (uint8)lenIn; /* VCA_SSA_KEYM_ENCODING_ELEMENT_BUFFER_ACCESS */
    (*bufferIndex)++;
  }
  else
  {
    buffer[(*bufferIndex)%bufferLen] = 0x82u; /* VCA_SSA_KEYM_ENCODING_ELEMENT_BUFFER_ACCESS */
    (*bufferIndex)++;
    buffer[(*bufferIndex)%bufferLen] = (uint8)(lenIn >> 8u); /* VCA_SSA_KEYM_ENCODING_ELEMENT_BUFFER_ACCESS */
    (*bufferIndex)++;
    buffer[(*bufferIndex)%bufferLen] = (uint8)(lenIn); /* VCA_SSA_KEYM_ENCODING_ELEMENT_BUFFER_ACCESS */
    (*bufferIndex)++;
  }
}

/**********************************************************************************************************************
 * KeyM_EncodeUniqueEcuIds()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 */
SSA_KEYM_LOCAL FUNC(Std_ReturnType, Ssa_KeyM_CODE) KeyM_EncodeUniqueEcuIds(
  P2VAR(uint8, AUTOMATIC, AUTOMATIC) buffer,
  P2VAR(uint16, AUTOMATIC, AUTOMATIC) bufferLen)
{
  Std_ReturnType retVal = E_NOT_OK;
  uint16 bufferIdx = 0u, sizeOctetString = 0u, sizeSet = 0u;
  uint16 i;
  uint16 lengthUniqueEcuId;

  /* The parameter 'buffer' provides
   * (SSA_SECLOG_LENGTH_OF_ALL_UNIQUE_ECU_IDS + (2u*SSA_SECLOG_NUMBER_OF_UNIQUE_ECU_IDS) + 8u) many bytes.
   * This is sufficient to store all encoded unique ECU IDs (see comment at definition of
   * SSA_SIZEOF_ENCODED_UNIQUEECUIDS).
   * A check in KeyM_GetNumBytesNeededForEncodingUniqueEcuIds() ensures that no unique ECU ID
   * is longer than SSA_MAX_SIZEOF_UNIQUEECUID (30) bytes. */

  /* #10 Encode the configured UniqueEcuIds */
  retVal = KeyM_GetNumBytesNeededForEncodingUniqueEcuIds(&sizeOctetString, &sizeSet);

  if (retVal == E_OK) /* COV_SSA_KEYM_UNIQUE_ECU_ID_LENGTH_CHECK */
  {
    /* #20 Create an OCTET STRING */
    KeyM_PrepareDerEncodingElement(buffer, &bufferIdx, *bufferLen, SSA_DER_ENCODING_TAG_OCTET_STRING, sizeOctetString);
    /* #30 Create a SET */
    KeyM_PrepareDerEncodingElement(buffer, &bufferIdx, *bufferLen, SSA_DER_ENCODING_TAG_SET, sizeSet);
    /* #40 Iterate through the configured UniqueEcuIDs and create for each UniqueEcuId an UTF8String */
    for (i = 0u; i < Ssa_GetSizeOfUniqueEcuId(); ++i)
    {
      lengthUniqueEcuId = (uint16)((uint16)Ssa_GetUniqueEcuIdsUniqueEcuIdsEndIdxOfUniqueEcuId(i) - (uint16)Ssa_GetUniqueEcuIdsUniqueEcuIdsStartIdxOfUniqueEcuId(i));
      KeyM_PrepareDerEncodingElement(buffer, &bufferIdx, *bufferLen, SSA_DER_ENCODING_TAG_UTF8_STRING, lengthUniqueEcuId);
      KeyM_CopyDataBuffer(&buffer[bufferIdx], Ssa_GetAddrUniqueEcuIds(Ssa_GetUniqueEcuIdsUniqueEcuIdsStartIdxOfUniqueEcuId(i)), lengthUniqueEcuId); /* VCA_SSA_KEYM_ENCODE_UNIQUE_ECU_IDS */
      bufferIdx += lengthUniqueEcuId;
    }
  }

  *bufferLen = bufferIdx;
  return retVal;

}

/**********************************************************************************************************************
 * KeyM_TrustModel_CopyCsrKey()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
SSA_KEYM_LOCAL FUNC(Std_ReturnType, Ssa_KeyM_CODE) KeyM_TrustModel_CopyCsrKey(void)
{
  Std_ReturnType retVal;

  /* Set Private and Public CSR Key */
  retVal = Rte_Call_Key_TrustModelEcuStagingPrivateKey_KeyElementCopy(SSA_KE_SIGNATURE_KEY, SSA_KEYM_CSM_KEY_TRUST_MODEL_ECU_CSR_PRIVATE_KEY, SSA_KE_SIGNATURE_KEY);
  retVal |= Rte_Call_Key_TrustModelEcuStagingPublicKey_KeyElementCopy(SSA_KE_SIGNATURE_KEY, SSA_KEYM_CSM_KEY_TRUST_MODEL_ECU_CSR_PUBLIC_KEY, SSA_KE_SIGNATURE_KEY);
  retVal |= Rte_Call_Key_TrustModelEcuCsrPrivateKey_KeySetValid();
  retVal |= Rte_Call_Key_TrustModelEcuCsrPublicKey_KeySetValid();

/* Error Handling */
  if (retVal != E_OK)
  {
    retVal = E_NOT_OK;
  }

  return retVal;
}

/**********************************************************************************************************************
 * KeyM_TrustModel_VerifyPrivateKeyAndInitCsr()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 */
SSA_KEYM_LOCAL FUNC(Std_ReturnType, Ssa_KeyM_CODE) KeyM_TrustModel_VerifyPrivateKeyAndInitCsr(void)
{
  Std_ReturnType retVal;
  Crypto_VerifyResultType cryptoVerifResult = CRYPTO_E_VER_NOT_OK;

  /* Check for new request */
  if (!KeyM_lastCsrCreationReturnedBusy)
  {
    /* Verify the public key against the private key */
    retVal = KeyM_VerifyPublicKeyWithEcuPrivateKey(SSA_TRUST_MODEL_CSR_KEY_PAIR, NULL_PTR, &cryptoVerifResult);
#if (SSA_ENABLE_ASYNC_CSM_JOB_PROCESSING == STD_ON)
    if (retVal != SSA_E_PENDING)
#endif
    {
      /* If private and public key are invalid: Return ASCII-encoded, null-terminated "Not_OK" as CSR.
       * The 'BUSY' case in a synchronous configuration is also handled here. */
      if ((retVal != E_OK) || (cryptoVerifResult != CRYPTO_E_VER_OK))
      {
        CONST(uint8, AUTOMATIC) errorDescription[] = "Not_OK";
        KeyM_CopyDataBuffer(KeyM_DiagProc.serviceResponseBuffer, errorDescription, sizeof(errorDescription));
        KeyM_DiagProc.serviceResponseBufferLength = sizeof(errorDescription);
        KeyM_DiagProc.serviceResponseCallbackOccurred = TRUE;
        KeyM_DiagProc.serviceResponseCallbackResult = KEYM_RT_OK;

        retVal = E_OK;
      }
      else
      {
        retVal = KeyM_TrustModel_InitCsr();
      }
    }
  }
  else
  {
    /* KeyM_TrustModel_InitCsr() was already called, so we can skip the key pair verification. */
    retVal = KeyM_TrustModel_InitCsr();
  }

  return retVal;
}

/**********************************************************************************************************************
 * KeyM_TrustModel_InitCsr()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
SSA_KEYM_LOCAL FUNC(Std_ReturnType, Ssa_KeyM_CODE) KeyM_TrustModel_InitCsr(void)
{
  Std_ReturnType retVal = E_NOT_OK;

  /* Check for new request */
  if (!KeyM_lastCsrCreationReturnedBusy)
  {
    uint16 extensionsUniqueEcuIdsLen = SSA_SIZEOF_ENCODED_UNIQUEECUIDS;

    /* #30 Define content of certificate signing request.
     *     Use static element data buffers since buffers might be accessed
     *     not until service certificate is called (asynchronously). */

    /* #35 Get VeDoc relevant info from application in order to use it as common name for the CSR */
    KeyM_TrustModelEcuCsrCommonNameLength() = SSS_KEYM_MAX_LEN_COMMON_NAME;
    if (Rte_Call_Ssa_VeDocRelevantInfo_GetData(
      KeyM_TrustModelEcuCsrCommonName(),
      &KeyM_TrustModelEcuCsrCommonNameLength()) != RTE_E_OK)
    {
      /* use default return value */
    }
    /* #40 OBJECT IDENTIFIER 2.5.4.3 commonName (X.520 DN component) */
    else if (Rte_Call_SsaCdd_TrustModel_CsrElementSet(
        SSA_TRUST_MODEL_ECU_CSR_CERT_ID,
        SSA_TRUST_MODEL_ECU_CSR_CERTIFICATE_ELEMENT_COMMON_NAME,
        KEYM_CSR_ENCODING_NONE,
        KeyM_TrustModelEcuCsrCommonName(),
        KeyM_TrustModelEcuCsrCommonNameLength()) != RTE_E_OK)
    {
      /* use default return value */
    }
    /* #42 OBJECT IDENTIFIER 1.3.6.1.4.1.2916.3.6.509.5.108 (uniqueECUID) */
    else if (KeyM_EncodeUniqueEcuIds(KeyM_DiagProc.extensionsUniqueEcuIds, &extensionsUniqueEcuIdsLen) != E_OK) /* COV_SSA_KEYM_UNIQUE_ECU_ID_LENGTH_CHECK */
    {
      /* use default return value */
    }
    else if (Rte_Call_SsaCdd_TrustModel_CsrElementSet(
      SSA_TRUST_MODEL_ECU_CSR_CERT_ID,
      SSA_TRUST_MODEL_ECU_CSR_CERTIFICATE_ELEMENT_UNIQUE_ECU_ID,
      KEYM_CSR_ENCODING_DER,
      KeyM_DiagProc.extensionsUniqueEcuIds,
      extensionsUniqueEcuIdsLen) != RTE_E_OK)
    {
      /* use default return value */
    }
    /* #44 OBJECT IDENTIFIER 1.3.6.1.4.1.2916.3.6.509.5.109 (SpecialECU) in case of ECU type VSM  */
#if (SSA_ECU_TYPE == SSA_ECU_TYPE_VSM)
    else if (Rte_Call_SsaCdd_TrustModel_CsrElementSet(
      SSA_TRUST_MODEL_ECU_CSR_CERT_ID,
      SSA_TRUST_MODEL_ECU_CSR_CERTIFICATE_ELEMENT_SPECIAL_ECU,
      KEYM_CSR_ENCODING_DER,
      extensionSpecialEcu,
      sizeof(extensionSpecialEcu)) != RTE_E_OK)
    {
      /* use default return value */
    }
#endif
    else
    {
      /* contents for CSR have been successfully defined, continue */
      retVal = RTE_E_OK;
    }
  }
  else
  {
    /* contents for CSR have been already defined, continue */
    retVal = RTE_E_OK;
  }

  if (retVal == RTE_E_OK)
  {
    /* prepare asynchronous service certificate call */
    KeyM_DiagProc.serviceResponseCallbackOccurred = FALSE;

    /* #50 Request AsrKeyM to create the CSR. */
    retVal = Rte_Call_SsaCdd_TrustModel_ServiceCertificate(
        KEYM_SERVICE_CERT_REQUEST_CSR,
        KeyM_TrustModelEcuCsrName(),
        KeyM_TrustModelEcuCsrNameLength(),
        InitCsrRespBuffer,
        0u,
        KeyM_DiagProc.serviceResponseBuffer,
        sizeof(KeyM_DiagProc.serviceResponseBuffer));

    KeyM_lastCsrCreationReturnedBusy = ((retVal == SSA_CRYPTO_E_BUSY) ? TRUE : FALSE);
  }

  if (retVal == RTE_E_OK)
  {
    retVal = E_OK;
  }
  else if (retVal == SSA_CRYPTO_E_BUSY)
  {
    retVal = SSA_E_PENDING;
  }
  else
  {
    retVal = E_NOT_OK;
  }

  return retVal;
} /* PRQA S 6080 */ /* MD_MSR_STMIF */

/**********************************************************************************************************************
 * KeyM_EvalPeerTrustModelChain()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 */
SSA_KEYM_LOCAL FUNC(boolean, Ssa_KeyM_CODE) KeyM_EvalPeerTrustModelChain(
  uint8 verifResultIn,
  P2VAR(uint8, AUTOMATIC, AUTOMATIC) verifResultOut)
{
  boolean verificationPasssed = FALSE;

  /* #10  Check the overall verification result. */
  if (verifResultIn == KEYM_CERTIFICATE_VALID)
  {
#if (SSA_ECU_TYPE == SSA_ECU_TYPE_VSM)
    *verifResultOut = SSA_VER_RES_TRUST_MODEL_SECOC_CSS_ENCRYPT_CERTIFICATE_VERIFIED_SECOC_KEY_CALCULATED;
#else
    *verifResultOut = SSA_VER_RES_TRUST_MODEL_SECOC_CSS_DISTRIB_CERTIFICATE_VERIFIED_SECOC_KEY_CALCULATED;
#endif
    verificationPasssed = TRUE;
  }
  else
  {
    KeyM_CertificateStatusType certificateStatus = KEYM_CERTIFICATE_INVALID;

    /* #20 Check the status of all verified certificates if the overall verification result indicates a failure.
     *     and  map the certificate's status to a defined verification result.
     *     Start with top level certificate. */

     /* evaluate status of backend peer certificate */
    if ((KeyM_KeyM_CertGetStatus(SSA_TRUST_MODEL_BACKEND_PEER_CERT_ID, &certificateStatus) == E_OK)
      && (certificateStatus != KEYM_CERTIFICATE_VALID))
    {
      /* map status to verification result */
      KeyM_SharedSecretDistribution_MapCertificateStatusToVerificationResult(SSA_TRUST_MODEL_BACKEND_PEER_CERT_ID, certificateStatus, verifResultOut);
      /* Log failed Trust Model certififcate verification event */
      KeyM_LogTrustModelCertificateVerificationResult(SSA_TRUST_MODEL_BACKEND_PEER_CERT_ID, *verifResultOut);
    }
    /* evaluate status of intermediate peer certificate */
    else if ((KeyM_KeyM_CertGetStatus(SSA_TRUST_MODEL_INTERMEDIATE_PEER_CERT_ID, &certificateStatus) == E_OK)
      && (certificateStatus != KEYM_CERTIFICATE_VALID))
    {
      /* map status to verification result */
      KeyM_SharedSecretDistribution_MapCertificateStatusToVerificationResult(SSA_TRUST_MODEL_INTERMEDIATE_PEER_CERT_ID, certificateStatus, verifResultOut);
      /* Log failed Trust Model certififcate verification event */
      KeyM_LogTrustModelCertificateVerificationResult(SSA_TRUST_MODEL_INTERMEDIATE_PEER_CERT_ID, *verifResultOut);
    }
    /* evaluate status of ECU peer certificate */
    else
    {
      /* Map callback result to verification result (verifResultIn is the status of the EcuPeer certificate. */
      KeyM_SharedSecretDistribution_MapCertificateStatusToVerificationResult(SSA_TRUST_MODEL_ECU_PEER_CERT_ID, verifResultIn, verifResultOut);
      /* Log failed Trust Model certififcate verification event */
      KeyM_LogTrustModelCertificateVerificationResult(SSA_TRUST_MODEL_ECU_PEER_CERT_ID, *verifResultOut);
    }
  }
  return verificationPasssed;
} /* PRQA S 6030 */ /* MD_MSR_STCYC */

/**********************************************************************************************************************
 * KeyM_SharedSecretDistribution_MapCertificateStatusToVerificationResult()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 */
SSA_KEYM_LOCAL FUNC(void, Ssa_KeyM_CODE) KeyM_SharedSecretDistribution_MapCertificateStatusToVerificationResult(
  CONST(KeyM_CertificateIdType, AUTOMATIC) certId,
  CONST(KeyM_CertificateStatusType, AUTOMATIC) certificateStatus,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) verifResultOut)
{
  /* #10 Map AsrKeyM certificate status to verification result depending on certificate Id. */
#if (SSA_ECU_TYPE == SSA_ECU_TYPE_VSM)
  switch (certId)
  {
    case SSA_TRUST_MODEL_BACKEND_PEER_CERT_ID:
    {
      switch (certificateStatus)
      {
        case KEYM_E_CERTIFICATE_VALIDITY_PERIOD_FAIL:
          *verifResultOut = SSA_VER_RES_TRUST_MODEL_SECOC_CSS_ENCRYPT_BACKEND_CERTIFICATE_VERIFICATION_FAILED_INVALID_TIME_PERIOD;
          break;

        case KEYM_E_CERTIFICATE_SIGNATURE_FAIL:
          *verifResultOut = SSA_VER_RES_TRUST_MODEL_SECOC_CSS_ENCRYPT_BACKEND_CERTIFICATE_VERIFICATION_FAILED_INVALID_SIGNATURE;
          break;

        case KEYM_E_CERTIFICATE_INVALID_CHAIN_OF_TRUST:
          *verifResultOut = SSA_VER_RES_TRUST_MODEL_SECOC_CSS_ENCRYPT_BACKEND_CERTIFICATE_VERIFICATION_FAILED_INVALID_CHAIN_OF_TRUST;
          break;

        case KEYM_E_CERTIFICATE_INVALID_TYPE:
          *verifResultOut = SSA_VER_RES_TRUST_MODEL_SECOC_CSS_ENCRYPT_BACKEND_CERTIFICATE_VERIFICATION_FAILED_INVALID_TYPE;
          break;

        case KEYM_E_CERTIFICATE_INVALID_FORMAT:
          *verifResultOut = SSA_VER_RES_TRUST_MODEL_SECOC_CSS_ENCRYPT_BACKEND_CERTIFICATE_VERIFICATION_FAILED_INVALID_FORMAT;
          break;

        case KEYM_E_CERTIFICATE_INVALID_CONTENT:
          *verifResultOut = SSA_VER_RES_TRUST_MODEL_SECOC_CSS_ENCRYPT_BACKEND_CERTIFICATE_VERIFICATION_FAILED_INVALID_CONTENT;
          break;

        default:
          /* for the time being set "invalid scope" */
          *verifResultOut = SSA_VER_RES_TRUST_MODEL_SECOC_CSS_ENCRYPT_BACKEND_CERTIFICATE_VERIFICATION_FAILED_INVALID_SCOPE;
          break;
      }
      break;
    }

    case SSA_TRUST_MODEL_INTERMEDIATE_PEER_CERT_ID:
    {
      switch (certificateStatus)
      {
        case KEYM_E_CERTIFICATE_VALIDITY_PERIOD_FAIL:
          *verifResultOut = SSA_VER_RES_TRUST_MODEL_SECOC_CSS_ENCRYPT_INTERMEDIATE_CERTIFICATE_VERIFICATION_FAILED_INVALID_TIME_PERIOD;
          break;

        case KEYM_E_CERTIFICATE_SIGNATURE_FAIL:
          *verifResultOut = SSA_VER_RES_TRUST_MODEL_SECOC_CSS_ENCRYPT_INTERMEDIATE_CERTIFICATE_VERIFICATION_FAILED_INVALID_SIGNATURE;
          break;

        case KEYM_E_CERTIFICATE_INVALID_CHAIN_OF_TRUST:
          *verifResultOut = SSA_VER_RES_TRUST_MODEL_SECOC_CSS_ENCRYPT_INTERMEDIATE_CERTIFICATE_VERIFICATION_FAILED_INVALID_CHAIN_OF_TRUST;
          break;

        case KEYM_E_CERTIFICATE_INVALID_TYPE:
          *verifResultOut = SSA_VER_RES_TRUST_MODEL_SECOC_CSS_ENCRYPT_INTERMEDIATE_CERTIFICATE_VERIFICATION_FAILED_INVALID_TYPE;
          break;

        case KEYM_E_CERTIFICATE_INVALID_FORMAT:
          *verifResultOut = SSA_VER_RES_TRUST_MODEL_SECOC_CSS_ENCRYPT_INTERMEDIATE_CERTIFICATE_VERIFICATION_FAILED_INVALID_FORMAT;
          break;

        case KEYM_E_CERTIFICATE_INVALID_CONTENT:
          *verifResultOut = SSA_VER_RES_TRUST_MODEL_SECOC_CSS_ENCRYPT_INTERMEDIATE_CERTIFICATE_VERIFICATION_FAILED_INVALID_CONTENT;
          break;

        default:
          /* for the time being set "invalid scope" */
          *verifResultOut = SSA_VER_RES_TRUST_MODEL_SECOC_CSS_ENCRYPT_INTERMEDIATE_CERTIFICATE_VERIFICATION_FAILED_INVALID_SCOPE;
          break;
      }
      break;
    }

    case SSA_TRUST_MODEL_ECU_PEER_CERT_ID:
      /* Fall through. */
    default:
    {
      switch (certificateStatus)
      {
        case KEYM_E_CERTIFICATE_VALIDITY_PERIOD_FAIL:
          *verifResultOut = SSA_VER_RES_TRUST_MODEL_SECOC_CSS_ENCRYPT_ECU_CERTIFICATE_VERIFICATION_FAILED_INVALID_TIME_PERIOD;
          break;

        case KEYM_E_CERTIFICATE_SIGNATURE_FAIL:
          *verifResultOut = SSA_VER_RES_TRUST_MODEL_SECOC_CSS_ENCRYPT_ECU_CERTIFICATE_VERIFICATION_FAILED_INVALID_SIGNATURE;
          break;

        case KEYM_E_CERTIFICATE_INVALID_CHAIN_OF_TRUST:
          *verifResultOut = SSA_VER_RES_TRUST_MODEL_SECOC_CSS_ENCRYPT_ECU_CERTIFICATE_VERIFICATION_FAILED_INVALID_CHAIN_OF_TRUST;
          break;

        case KEYM_E_CERTIFICATE_INVALID_TYPE:
          *verifResultOut = SSA_VER_RES_TRUST_MODEL_SECOC_CSS_ENCRYPT_ECU_CERTIFICATE_VERIFICATION_FAILED_INVALID_TYPE;
          break;

        case KEYM_E_CERTIFICATE_INVALID_FORMAT:
          *verifResultOut = SSA_VER_RES_TRUST_MODEL_SECOC_CSS_ENCRYPT_ECU_CERTIFICATE_VERIFICATION_FAILED_INVALID_FORMAT;
          break;

        case KEYM_E_CERTIFICATE_INVALID_CONTENT:
          *verifResultOut = SSA_VER_RES_TRUST_MODEL_SECOC_CSS_ENCRYPT_ECU_CERTIFICATE_VERIFICATION_FAILED_INVALID_CONTENT;
          break;

        default:
          /* for the time being set "invalid scope" */
          *verifResultOut = SSA_VER_RES_TRUST_MODEL_SECOC_CSS_ENCRYPT_ECU_CERTIFICATE_VERIFICATION_FAILED_INVALID_SCOPE;
          break;
      }
      break;
    }
  }
#else
switch (certId)
{
  case SSA_TRUST_MODEL_BACKEND_PEER_CERT_ID:
  {
    switch (certificateStatus)
    {
      case KEYM_E_CERTIFICATE_VALIDITY_PERIOD_FAIL:
        *verifResultOut = SSA_VER_RES_TRUST_MODEL_SECOC_CSS_DISTRIB_BACKEND_CERTIFICATE_VERIFICATION_FAILED_INVALID_TIME_PERIOD;
        break;

      case KEYM_E_CERTIFICATE_SIGNATURE_FAIL:
        *verifResultOut = SSA_VER_RES_TRUST_MODEL_SECOC_CSS_DISTRIB_BACKEND_CERTIFICATE_VERIFICATION_FAILED_INVALID_SIGNATURE;
        break;

      case KEYM_E_CERTIFICATE_INVALID_CHAIN_OF_TRUST:
        *verifResultOut = SSA_VER_RES_TRUST_MODEL_SECOC_CSS_DISTRIB_BACKEND_CERTIFICATE_VERIFICATION_FAILED_INVALID_CHAIN_OF_TRUST;
        break;

      case KEYM_E_CERTIFICATE_INVALID_TYPE:
        *verifResultOut = SSA_VER_RES_TRUST_MODEL_SECOC_CSS_DISTRIB_BACKEND_CERTIFICATE_VERIFICATION_FAILED_INVALID_TYPE;
        break;

      case KEYM_E_CERTIFICATE_INVALID_FORMAT:
        *verifResultOut = SSA_VER_RES_TRUST_MODEL_SECOC_CSS_DISTRIB_BACKEND_CERTIFICATE_VERIFICATION_FAILED_INVALID_FORMAT;
        break;

      case KEYM_E_CERTIFICATE_INVALID_CONTENT:
        *verifResultOut = SSA_VER_RES_TRUST_MODEL_SECOC_CSS_DISTRIB_BACKEND_CERTIFICATE_VERIFICATION_FAILED_INVALID_CONTENT;
        break;

      default:
        /* for the time being set "invalid scope" */
        *verifResultOut = SSA_VER_RES_TRUST_MODEL_SECOC_CSS_DISTRIB_BACKEND_CERTIFICATE_VERIFICATION_FAILED_INVALID_SCOPE;
        break;
    }
    break;
  }

  case SSA_TRUST_MODEL_INTERMEDIATE_PEER_CERT_ID:
  {
    switch (certificateStatus)
    {
      case KEYM_E_CERTIFICATE_VALIDITY_PERIOD_FAIL:
        *verifResultOut = SSA_VER_RES_TRUST_MODEL_SECOC_CSS_DISTRIB_INTERMEDIATE_CERTIFICATE_VERIFICATION_FAILED_INVALID_TIME_PERIOD;
        break;

      case KEYM_E_CERTIFICATE_SIGNATURE_FAIL:
        *verifResultOut = SSA_VER_RES_TRUST_MODEL_SECOC_CSS_DISTRIB_INTERMEDIATE_CERTIFICATE_VERIFICATION_FAILED_INVALID_SIGNATURE;
        break;

      case KEYM_E_CERTIFICATE_INVALID_CHAIN_OF_TRUST:
        *verifResultOut = SSA_VER_RES_TRUST_MODEL_SECOC_CSS_DISTRIB_INTERMEDIATE_CERTIFICATE_VERIFICATION_FAILED_INVALID_CHAIN_OF_TRUST;
        break;

      case KEYM_E_CERTIFICATE_INVALID_TYPE:
        *verifResultOut = SSA_VER_RES_TRUST_MODEL_SECOC_CSS_DISTRIB_INTERMEDIATE_CERTIFICATE_VERIFICATION_FAILED_INVALID_TYPE;
        break;

      case KEYM_E_CERTIFICATE_INVALID_FORMAT:
        *verifResultOut = SSA_VER_RES_TRUST_MODEL_SECOC_CSS_DISTRIB_INTERMEDIATE_CERTIFICATE_VERIFICATION_FAILED_INVALID_FORMAT;
        break;

      case KEYM_E_CERTIFICATE_INVALID_CONTENT:
        *verifResultOut = SSA_VER_RES_TRUST_MODEL_SECOC_CSS_DISTRIB_INTERMEDIATE_CERTIFICATE_VERIFICATION_FAILED_INVALID_CONTENT;
        break;

      default:
        /* for the time being set "invalid scope" */
        *verifResultOut = SSA_VER_RES_TRUST_MODEL_SECOC_CSS_DISTRIB_INTERMEDIATE_CERTIFICATE_VERIFICATION_FAILED_INVALID_SCOPE;
        break;
    }
    break;
  }

  case SSA_TRUST_MODEL_ECU_PEER_CERT_ID:
    /* Fall through. */
  default:
  {
    switch (certificateStatus)
    {
      case KEYM_E_CERTIFICATE_VALIDITY_PERIOD_FAIL:
        *verifResultOut = SSA_VER_RES_TRUST_MODEL_SECOC_CSS_DISTRIB_ECU_CERTIFICATE_VERIFICATION_FAILED_INVALID_TIME_PERIOD;
        break;

      case KEYM_E_CERTIFICATE_SIGNATURE_FAIL:
        *verifResultOut = SSA_VER_RES_TRUST_MODEL_SECOC_CSS_DISTRIB_ECU_CERTIFICATE_VERIFICATION_FAILED_INVALID_SIGNATURE;
        break;

      case KEYM_E_CERTIFICATE_INVALID_CHAIN_OF_TRUST:
        *verifResultOut = SSA_VER_RES_TRUST_MODEL_SECOC_CSS_DISTRIB_ECU_CERTIFICATE_VERIFICATION_FAILED_INVALID_CHAIN_OF_TRUST;
        break;

      case KEYM_E_CERTIFICATE_INVALID_TYPE:
        *verifResultOut = SSA_VER_RES_TRUST_MODEL_SECOC_CSS_DISTRIB_ECU_CERTIFICATE_VERIFICATION_FAILED_INVALID_TYPE;
        break;

      case KEYM_E_CERTIFICATE_INVALID_FORMAT:
        *verifResultOut = SSA_VER_RES_TRUST_MODEL_SECOC_CSS_DISTRIB_ECU_CERTIFICATE_VERIFICATION_FAILED_INVALID_FORMAT;
        break;

      case KEYM_E_CERTIFICATE_INVALID_CONTENT:
        *verifResultOut = SSA_VER_RES_TRUST_MODEL_SECOC_CSS_DISTRIB_ECU_CERTIFICATE_VERIFICATION_FAILED_INVALID_CONTENT;
        break;

      default:
        /* for the time being set "invalid scope" */
        *verifResultOut = SSA_VER_RES_TRUST_MODEL_SECOC_CSS_DISTRIB_ECU_CERTIFICATE_VERIFICATION_FAILED_INVALID_SCOPE;
        break;
    }
    break;
  }
}
#endif
}  /* PRQA S 6030 */ /* MD_SSA_CYC_VERIFICATION_RESULT_MAPPING */

/**********************************************************************************************************************
 * KeyM_KeyM_GetCertificate()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
SSA_KEYM_LOCAL FUNC(Std_ReturnType, Ssa_KeyM_CODE) KeyM_KeyM_GetCertificate(
  KeyM_CertificateIdType CertId,
  P2VAR(Ssa_KeyM_CertDataType, AUTOMATIC, AUTOMATIC) CertificateDataPtr)
{
  /* #10 Get Trust Model certificate via CDD. */
  return Rte_Call_SsaCdd_TrustModel_GetCertificate(
    CertId,
    CertificateDataPtr->certData,
    &CertificateDataPtr->certDataLength);
}

/**********************************************************************************************************************
 * KeyM_KeyM_SetCertificate()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
SSA_KEYM_LOCAL FUNC(Std_ReturnType, Ssa_KeyM_CODE) KeyM_KeyM_SetCertificate(
  KeyM_CertificateIdType CertId,
  P2CONST(Ssa_KeyM_CertDataType, AUTOMATIC, AUTOMATIC) CertificateDataPtr)
{
  /* #10 Set Trust Model certificate via CDD. */
  return Rte_Call_SsaCdd_TrustModel_SetCertificate(
    CertId,
    CertificateDataPtr->certData,
    CertificateDataPtr->certDataLength);
}

/**********************************************************************************************************************
 * KeyM_KeyM_CertGetStatus()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
SSA_KEYM_LOCAL FUNC(Std_ReturnType, Ssa_KeyM_CODE) KeyM_KeyM_CertGetStatus(
  KeyM_CertificateIdType CertId,
  P2VAR(KeyM_CertificateStatusType, AUTOMATIC, AUTOMATIC) Status)
{
  Std_ReturnType retVal = E_NOT_OK;
  /* #10 Get certificate status via appropriate RTE port. */
  switch (CertId)
  {
  case SSA_TRUST_MODEL_ECU_CERT_ID:
    retVal = Rte_Call_KeyMCertificate_Ssa_TrustModelEcuCert_GetStatus(Status);
    break;
  case SSA_TRUST_MODEL_ECU_PEER_CERT_ID:
    retVal = Rte_Call_KeyMCertificate_Ssa_TrustModelEcuPeerCert_GetStatus(Status);
    break;
  case SSA_TRUST_MODEL_INTERMEDIATE_CERT_ID:
    retVal = Rte_Call_KeyMCertificate_Ssa_TrustModelIntermediateCert_GetStatus(Status);
    break;
  case SSA_TRUST_MODEL_INTERMEDIATE_PEER_CERT_ID:
    retVal = Rte_Call_KeyMCertificate_Ssa_TrustModelIntermediatePeerCert_GetStatus(Status);
    break;
  case SSA_TRUST_MODEL_BACKEND_CERT_ID:
    retVal = Rte_Call_KeyMCertificate_Ssa_TrustModelBackendCert_GetStatus(Status);
    break;
  case SSA_TRUST_MODEL_BACKEND_PEER_CERT_ID:
    retVal = Rte_Call_KeyMCertificate_Ssa_TrustModelBackendPeerCert_GetStatus(Status);
    break;
  case SSA_TRUST_MODEL_ROOT_CERT_ID:
    retVal = Rte_Call_KeyMCertificate_Ssa_TrustModelRootCert_GetStatus(Status);
      break;
  default:
    /* Invalid CertId */
    break;
  }

  return retVal;
}

/**********************************************************************************************************************
 * KeyM_IsUniqueEcuIdFieldEqual()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 */
SSA_KEYM_LOCAL FUNC(boolean, Ssa_KeyM_CODE) KeyM_IsUniqueEcuIdFieldEqual(void)
{
  boolean isUniqueEcuIdFieldEqual = FALSE;
  Std_ReturnType tmpRetVal = E_NOT_OK;

  KeyM_CertificateElementType_Ssa_TrustModelEcuCert_ext_uniqueECUID uniqueEcuId = { 0u };
  uint32 uniqueEcuIdOfCertificateLength = sizeof(KeyM_CertificateElementType_Ssa_TrustModelEcuCert_ext_uniqueECUID);

  uint16 idx = 0u;
  uint16 combinedLengthUniqueEcuId = 0u, lengthUniqueEcuId = 0u;
  Ssa_UniqueEcuIdIterType i = 0u;

  /* #10 Check whether the aggregated entry lengths in the uniqueECUID field exceed the length of
         the uniqueECUID field in the new Trust Model ECU Certificate and if so, stop the comparison
         and return false. */
  for (i = 0u; i < Ssa_GetSizeOfUniqueEcuId(); ++i)
  {
    /* length = offset for flag and length + length of entry itself */
    combinedLengthUniqueEcuId += 2u;
    combinedLengthUniqueEcuId += (uint16)((uint16)Ssa_GetUniqueEcuIdsUniqueEcuIdsEndIdxOfUniqueEcuId(i) - (uint16)Ssa_GetUniqueEcuIdsUniqueEcuIdsStartIdxOfUniqueEcuId(i));
  }

  tmpRetVal = Rte_Call_KeyMCertificateElement_Ssa_TrustModelEcuCert_ext_uniqueECUID_CertificateElementGet(
    uniqueEcuId,
    &uniqueEcuIdOfCertificateLength);

  if (tmpRetVal == RTE_E_OK)
  {
    if (combinedLengthUniqueEcuId > uniqueEcuIdOfCertificateLength)
    {
      tmpRetVal = E_NOT_OK;
    }
  }

  /* #20 Compare the uniqueECUID field filled into the ECU CSR Body against the uniqueECUID field
  *     from the new Trust Model ECU Certificate and proceed routine only if equal. */
  if (tmpRetVal == RTE_E_OK)
  {
    /* iterate through the configured UniqueEcuIDs */
    for (i = 0u; i < Ssa_GetSizeOfUniqueEcuId(); ++i)
    {
      isUniqueEcuIdFieldEqual = FALSE;
      lengthUniqueEcuId = (uint16)((uint16)Ssa_GetUniqueEcuIdsUniqueEcuIdsEndIdxOfUniqueEcuId(i) - (uint16)Ssa_GetUniqueEcuIdsUniqueEcuIdsStartIdxOfUniqueEcuId(i));
      if ((uniqueEcuId[idx] == SSA_DER_ENCODING_TAG_UTF8_STRING) &&
        (uniqueEcuId[idx + 1u] == lengthUniqueEcuId))
      {
        if (KeyM_CompareData(Ssa_GetAddrUniqueEcuIds(Ssa_GetUniqueEcuIdsUniqueEcuIdsStartIdxOfUniqueEcuId(i)),
          &uniqueEcuId[idx + 2u],
          lengthUniqueEcuId))
        {
          isUniqueEcuIdFieldEqual = TRUE;
          idx += 2u + lengthUniqueEcuId;
        }
      }

      if (!isUniqueEcuIdFieldEqual)
      {
        break;
      }
    }
  }

  return isUniqueEcuIdFieldEqual;
}

#if (SSA_ECU_TYPE != SSA_ECU_TYPE_VSM)

# if (SSA_DIAG_SERVICE_INJECT_SEED == STD_ON)

/**********************************************************************************************************************
 *  KeyM_CsmRandomSeed()
 **********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
SSA_KEYM_LOCAL FUNC(Std_ReturnType, Ssa_KeyM_CODE) KeyM_CsmRandomSeed(
  P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) seed, uint32 seedLength)
{
  Std_ReturnType retVal;
  boolean operationIsAsync;
#  if (SSA_ENABLE_ASYNC_CSM_KEYM_ANAGEMENT_PRIMITIVES == STD_ON)
  operationIsAsync = TRUE;
  retVal = Ssa_AsyncPreAction(&KeyM_RandomSeedState, operationIsAsync);
  if (retVal == E_OK)
#  else
  operationIsAsync = FALSE;
#  endif
  {
#  if (SSA_ENABLE_ASYNC_CSM_KEYM_ANAGEMENT_PRIMITIVES == STD_ON)
      retVal = Rte_Call_CsmJobRandomSeed_RandomSeed(SSA_KEYM_CSM_RANDOM_SEED_KEY, seed, seedLength);
#  else
      /* seed is of size SSA_KEYM_INJECT_SEED_DATA_BUFFER_SIZE */
      retVal = Rte_Call_Key_RandomSeed_RandomSeed(seed, seedLength);
#  endif

      Ssa_AsyncPostAction(&KeyM_RandomSeedState, retVal, operationIsAsync);
  }

  retVal = Ssa_AsyncFinalize(&KeyM_RandomSeedState, operationIsAsync);

  return retVal;
}

# endif

#endif

/**********************************************************************************************************************
 *  KeyM_TrustModel_AdditionalVerificationOfCertEntries_CertificateChain()
 **********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 */
SSA_KEYM_LOCAL FUNC(Std_ReturnType, Ssa_KeyM_CODE) KeyM_TrustModel_AdditionalVerificationOfCertEntries_CertificateChain(
  CONST(KeyM_CertificateIdType, AUTOMATIC) certIdBackend,
  CONST(KeyM_CertificateIdType, AUTOMATIC) certIdIntermediate,
  CONST(KeyM_CertificateIdType, AUTOMATIC) certIdEcu,
  P2VAR(KeyM_CertificateIdType, AUTOMATIC, AUTOMATIC) certIdInvalidCert,
  P2VAR(KeyM_CertificateStatusType, AUTOMATIC, AUTOMATIC) certificateStatus)
{
  Std_ReturnType retVal;
  Std_ReturnType stateHandlingRetVal;
  KeyM_CertificateStatusType localCertStatus = KEYM_CERTIFICATE_INVALID;

  /* #1 Verify backend certificate. */
  retVal = KeyM_TrustModel_AdditionalVerificationOfCertificateEntries_SingleCertificate(certIdBackend, SSA_TRUST_MODEL_ROOT_CERT_ID, &localCertStatus);

  stateHandlingRetVal = KeyM_TrustModel_AdditionalVerificationOfCertificateEntries_StateHandling_Chain(retVal, localCertStatus, certIdBackend, certIdInvalidCert);

  if (stateHandlingRetVal == E_OK)
  {
    /* #2 Verify intermediate certificate. */
    retVal = KeyM_TrustModel_AdditionalVerificationOfCertificateEntries_SingleCertificate(certIdIntermediate, certIdBackend, &localCertStatus);

    stateHandlingRetVal = KeyM_TrustModel_AdditionalVerificationOfCertificateEntries_StateHandling_Chain(retVal, localCertStatus, certIdIntermediate, certIdInvalidCert);
  }

  if (stateHandlingRetVal == E_OK)
  {
    /* #3 Verify ecu certificate. */
    retVal = KeyM_TrustModel_AdditionalVerificationOfCertificateEntries_SingleCertificate(certIdEcu, certIdIntermediate, &localCertStatus);

    /* For the last check it is not relevant if the verification was successful or not.
     * Also for a failed verification the certStatus has to be stored. */
    (void)KeyM_TrustModel_AdditionalVerificationOfCertificateEntries_StateHandling_Chain(retVal, localCertStatus, certIdEcu, certIdInvalidCert);
  }

  if (retVal == E_OK)
  {
    /* Set the certificate status of the last certificate that has been checked. */
    /* This is either the status of the first certificate for which the verification failed
     * or the status KEYM_CERTIFICATE_VALID if all certificates could be validated. */
    *certificateStatus = localCertStatus;
  }

  return retVal;
}

/**********************************************************************************************************************
 *  KeyM_TrustModel_AdditionalVerificationOfCertificateEntries_StateHandling_Chain()
 **********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 */
SSA_KEYM_LOCAL_INLINE FUNC(Std_ReturnType, Ssa_KeyM_CODE) KeyM_TrustModel_AdditionalVerificationOfCertificateEntries_StateHandling_Chain(
  Std_ReturnType retVal,
  KeyM_CertificateStatusType certStatus,
  KeyM_CertificateIdType checkedCertId,
  P2VAR(KeyM_CertificateIdType, AUTOMATIC, AUTOMATIC) invalidCertId)
{
  Std_ReturnType tmpRetVal = E_NOT_OK;

  if (retVal == E_OK)
  {
    if (certStatus != KEYM_CERTIFICATE_VALID)
    {
      /* additional verification failed */
      *invalidCertId = checkedCertId;
    }
    else
    {
      /* verification was successful */
      tmpRetVal = E_OK;
    }
  }

  return tmpRetVal;
}

/**********************************************************************************************************************
 *  KeyM_TrustModel_AdditionalVerificationOfCertificateEntries_SingleCertificate()
 **********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
SSA_KEYM_LOCAL FUNC(Std_ReturnType, Ssa_KeyM_CODE) KeyM_TrustModel_AdditionalVerificationOfCertificateEntries_SingleCertificate(
  CONST(KeyM_CertificateIdType, AUTOMATIC) certId,
  CONST(KeyM_CertificateIdType, AUTOMATIC) issuerCertId,
  P2VAR(KeyM_CertificateStatusType, AUTOMATIC, AUTOMATIC) certStatus)
{
  Std_ReturnType retVal;
  KeyM_CertificateStatusType localCertStatus = KEYM_CERTIFICATE_INVALID;
  uint8 certIdx = SSA_KEYM_CERT_ENTRY_CERT_INDEX_TRUSTMODEL_ROOT_CA_CERT; /* initialize with root */

  boolean stopVerificationFlag = TRUE;
  /* indicates which certificate element should be checked within the following switch */
  uint8 elementToBeChecked = SSA_KEYM_CERT_ENTRY_ENTRY_ID_VERSION;
  uint8 elemToBeCheckedCounter = 0;

  /* Map certificate Id to internal certificate index. */
  retVal = KeyM_MapInternalCertIdToListIndex(certId, &certIdx);
  if (retVal == E_OK)
  {
    /* start verification */
    stopVerificationFlag = FALSE;
  }

  for (elemToBeCheckedCounter = 0u; elemToBeCheckedCounter < SSA_KEYM_TRUSTMODEL_ADDITIONAL_VERIFICATION_UPPER_BOUNDARY; elemToBeCheckedCounter++)
  {
    if (stopVerificationFlag == FALSE)
    {
      switch (elementToBeChecked)
      {
        /* #5 Check certificate version. */
        case SSA_KEYM_CERT_ENTRY_ENTRY_ID_VERSION:
        {
          retVal = KeyM_CheckCertificateVersion(certIdx, &localCertStatus);

          KeyM_TrustModel_AdditionalVerificationOfCertificateEntries_StateHandling_CertEntry(
            retVal, localCertStatus, SSA_KEYM_CERT_ENTRY_ENTRY_ID_BASIC_CONSTRAINTS, &elementToBeChecked, &stopVerificationFlag);
          break;
        }

        /* #6 Check basic constraints (only maximum depth of valid certification path is checked). */
        case SSA_KEYM_CERT_ENTRY_ENTRY_ID_BASIC_CONSTRAINTS:
        {
          /* This check is not done for the ecu certificates */
          if ((certId != SSA_TRUST_MODEL_ECU_CERT_ID) && (certId != SSA_TRUST_MODEL_ECU_PEER_CERT_ID))
          {
            retVal = KeyM_CheckCertificateBasicConstraints_DepthOfCertPath(certIdx, &localCertStatus);

            KeyM_TrustModel_AdditionalVerificationOfCertificateEntries_StateHandling_CertEntry(
              retVal, localCertStatus, SSA_KEYM_CERT_ENTRY_ENTRY_ID_NOT_AFTER, &elementToBeChecked, &stopVerificationFlag);
          }
          else
          {
            /* check next certificate element */
            elementToBeChecked = SSA_KEYM_CERT_ENTRY_ENTRY_ID_NOT_AFTER;
          }
          break;
        }

        /* #7 Check if the time validNotAfter is already exceeded. */
        case SSA_KEYM_CERT_ENTRY_ENTRY_ID_NOT_AFTER:
        {
          retVal = KeyM_CheckCertificateTime_ValidNotAfter(certIdx, &localCertStatus);

          KeyM_TrustModel_AdditionalVerificationOfCertificateEntries_StateHandling_CertEntry(
            retVal, localCertStatus, SSA_KEYM_CERT_ENTRY_ENTRY_ID_AUTHORITY_KEY_IDENTIFIER, &elementToBeChecked, &stopVerificationFlag);
          break;
        }

        /* #8 Check authorityKeyId vs subjectKeyId. */
        default:
        /* case SSA_KEYM_CERT_ENTRY_ENTRY_ID_AUTHORITY_KEY_IDENTIFIER: */
        {
          /* This is the final element that is checked, stop processing the for-loop */
          stopVerificationFlag = TRUE;

          if (certId != SSA_TRUST_MODEL_ROOT_CERT_ID) /* This check is not done for the root certificate. */
          {
            uint8 issuerCertIdx = SSA_KEYM_CERT_ENTRY_CERT_INDEX_TRUSTMODEL_BACKEND_CA_CERT; /* initialize with backend */

            /* Map issuerCertId to internal certificate index. */
            retVal = KeyM_MapInternalCertIdToListIndex(issuerCertId, &issuerCertIdx);

            if (retVal == E_OK)
            {
              retVal = KeyM_CheckTrustModelKeyIds(certIdx, issuerCertIdx, &localCertStatus);
            }
          }
          break;
        }
      }
    }
    else
    {
      /* leave for-loop */
      break;
    }
  }

  /* #9 Set certificate status if no error occurred. */
  if (retVal == E_OK)
  {
    *certStatus = localCertStatus;
  }

  return retVal;
} /* PRQA S 6030, 6080 */ /* MD_MSR_STCYC, MD_MSR_STMIF */

/**********************************************************************************************************************
 *  KeyM_TrustModel_AdditionalVerificationOfCertificateEntries_StateHandling_CertEntry()
 **********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 */
SSA_KEYM_LOCAL_INLINE FUNC(void, Ssa_KeyM_CODE) KeyM_TrustModel_AdditionalVerificationOfCertificateEntries_StateHandling_CertEntry(
  Std_ReturnType retVal,
  KeyM_CertificateStatusType certStatus,
  uint8 nextCertElement,
  P2VAR(uint8, AUTOMATIC, AUTOMATIC) certElementState,
  P2VAR(boolean, AUTOMATIC, AUTOMATIC) stopVerificationFlag)
{
  if ((retVal == E_OK) && (certStatus == KEYM_CERTIFICATE_VALID))
  {
    /* check next certificate element */
    *certElementState = nextCertElement;
  }
  else
  {
    /* stop processing the verification */
    *stopVerificationFlag = TRUE;
  }
}

/**********************************************************************************************************************
 *  KeyM_MapInternalCertIdToListIndex()
 **********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
SSA_KEYM_LOCAL_INLINE FUNC(Std_ReturnType, Ssa_KeyM_CODE) KeyM_MapInternalCertIdToListIndex(
  CONST(KeyM_CertificateIdType, AUTOMATIC) certId,
  P2VAR(uint8, AUTOMATIC, AUTOMATIC) listIndex)
{
  Std_ReturnType retVal = E_OK;

  switch (certId)
  {
    case SSA_TRUST_MODEL_ROOT_CERT_ID:
    {
      *listIndex = SSA_KEYM_CERT_ENTRY_CERT_INDEX_TRUSTMODEL_ROOT_CA_CERT;
      break;
    }
    case SSA_TRUST_MODEL_BACKEND_CERT_ID:
    {
      *listIndex = SSA_KEYM_CERT_ENTRY_CERT_INDEX_TRUSTMODEL_BACKEND_CA_CERT;
      break;
    }
    case SSA_TRUST_MODEL_INTERMEDIATE_CERT_ID:
    {
      *listIndex = SSA_KEYM_CERT_ENTRY_CERT_INDEX_TRUSTMODEL_INTERMEDIATE_CA_CERT;
      break;
    }
    case SSA_TRUST_MODEL_ECU_CERT_ID:
    {
      *listIndex = SSA_KEYM_CERT_ENTRY_CERT_INDEX_TRUSTMODEL_ECU_CA_CERT;
      break;
    }
    case SSA_TRUST_MODEL_BACKEND_PEER_CERT_ID:
    {
      *listIndex = SSA_KEYM_CERT_ENTRY_CERT_INDEX_TRUSTMODEL_BACKEND_PEER_CERT;
      break;
    }
    case SSA_TRUST_MODEL_INTERMEDIATE_PEER_CERT_ID:
    {
      *listIndex = SSA_KEYM_CERT_ENTRY_CERT_INDEX_TRUSTMODEL_INTERMEDIATE_PEER_CERT;
      break;
    }
    case SSA_TRUST_MODEL_ECU_PEER_CERT_ID:
    {
      *listIndex = SSA_KEYM_CERT_ENTRY_CERT_INDEX_TRUSTMODEL_ECU_PEER_CERT;
      break;
    }
    default:
    {
      retVal = E_NOT_OK;
      break;
    }
  }

  return retVal;
}

/**********************************************************************************************************************
 *  KeyM_CheckCertificateVersion()
 **********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 */
SSA_KEYM_LOCAL_INLINE FUNC(Std_ReturnType, Ssa_KeyM_CODE) KeyM_CheckCertificateVersion(
  CONST(uint8, AUTOMATIC) certIdx,
  P2VAR(KeyM_CertificateStatusType, AUTOMATIC, AUTOMATIC) certStatus)
{
  Std_ReturnType retVal = E_NOT_OK;
  uint8 entryIdx = SSA_KEYM_CERT_ENTRY_ENTRY_ID_VERSION - 1u;

  uint8 versionBuffer[SSA_KEYM_SIZEOF_VERSION] = { SSA_KEYM_CERT_ENTRY_INVALID_VERSION };
  uint32 versionLen = SSA_KEYM_SIZEOF_VERSION;

  /* For any value of certIdx, there is a valid Version_CertElementGet function in
   * KeyM_GetCertEntry_KeyM_CertElementGet_List, which is not a null pointer. */
  if (KeyM_GetCertEntry_KeyM_CertElementGet_List[certIdx][entryIdx](versionBuffer, &versionLen) == RTE_E_OK)
  {
    retVal = E_OK;
    /* length check not needed due to invalid inital value */
    if (versionBuffer[0] != SSA_KEYM_CERT_ENTRY_VERSION)
    {
      *certStatus = KEYM_E_CERTIFICATE_INVALID_FORMAT;
    }
    else
    {
      *certStatus = KEYM_CERTIFICATE_VALID;
    }
  }


  return retVal;
} /* PRQA S 6010 */ /* MD_MSR_STPTH */

/**********************************************************************************************************************
 *  KeyM_CheckCertificateBasicConstraints_DepthOfCertPath()
 **********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
SSA_KEYM_LOCAL_INLINE FUNC(Std_ReturnType, Ssa_KeyM_CODE) KeyM_CheckCertificateBasicConstraints_DepthOfCertPath(
  CONST(uint8, AUTOMATIC) certIdx,
  P2VAR(KeyM_CertificateStatusType, AUTOMATIC, AUTOMATIC) certStatus)
{
  Std_ReturnType retVal = E_NOT_OK;
  uint8 entryIdx = SSA_KEYM_CERT_ENTRY_ENTRY_ID_BASIC_CONSTRAINTS - 1u;

  if (KeyM_GetCertEntry_KeyM_CertElementGet_List[certIdx][entryIdx] != NULL_PTR)
  {
    uint8 expectedPathLength;
    uint8 basicConstraintsBuffer[SSA_KEYM_SIZEOF_BASIC_CONSTRAINTS] = { SSA_KEYM_CERT_ENTRY_BASIC_CONSTRAINTS_INVALID };
    uint32 basicConstraintsLen = SSA_KEYM_SIZEOF_BASIC_CONSTRAINTS;

    /* Prepare: Define the expected maximum depth of certification path for the individual certificate. */
    switch (certIdx)
    {
    case SSA_KEYM_CERT_ENTRY_CERT_INDEX_TRUSTMODEL_ROOT_CA_CERT:
      expectedPathLength = SSA_KEYM_CERT_ENTRY_BASIC_CONSTRAINTS_DEPTH_ROOT;
      break;
    case SSA_KEYM_CERT_ENTRY_CERT_INDEX_TRUSTMODEL_BACKEND_CA_CERT:
    case SSA_KEYM_CERT_ENTRY_CERT_INDEX_TRUSTMODEL_BACKEND_PEER_CERT:
      expectedPathLength = SSA_KEYM_CERT_ENTRY_BASIC_CONSTRAINTS_DEPTH_BACKEND;
      break;
    /* use default case
    case SSA_KEYM_CERT_ENTRY_CERT_INDEX_TRUSTMODEL_INTERMEDIATE_CA_CERT:
    case SSA_KEYM_CERT_ENTRY_CERT_INDEX_TRUSTMODEL_INTERMEDIATE_PEER_CERT:
    */
    default:
      expectedPathLength = SSA_KEYM_CERT_ENTRY_BASIC_CONSTRAINTS_DEPTH_INTERMEDIATE;
      break;
    }

    if (KeyM_GetCertEntry_KeyM_CertElementGet_List[certIdx][entryIdx](basicConstraintsBuffer, &basicConstraintsLen) == RTE_E_OK)
    {
      retVal = E_OK;
      /* length check not needed due to invalid inital value */
      if (basicConstraintsBuffer[0] != expectedPathLength)
      {
        *certStatus = KEYM_E_CERTIFICATE_INVALID_FORMAT;
      }
      else
      {
        *certStatus = KEYM_CERTIFICATE_VALID;
      }
    }
  }

  return retVal;
}

/**********************************************************************************************************************
 *  KeyM_CheckCertificateTime_ValidNotAfter()
 **********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
SSA_KEYM_LOCAL_INLINE FUNC(Std_ReturnType, Ssa_KeyM_CODE) KeyM_CheckCertificateTime_ValidNotAfter(
  CONST(uint8, AUTOMATIC) certIdx,
  P2VAR(KeyM_CertificateStatusType, AUTOMATIC, AUTOMATIC) certStatus)
{
  Std_ReturnType retVal = E_NOT_OK;
  uint8 entryIdx = SSA_KEYM_CERT_ENTRY_ENTRY_ID_NOT_AFTER - 1u;
  Ssa_Data15ByteType timeBuffer = { 0 };
  uint32 timeLen = sizeof(Ssa_Data15ByteType);

  /* For any value of certIdx, there is a valid ValidityNotAfter_CertElementGet function in
   * KeyM_GetCertEntry_KeyM_CertElementGet_List, which is not a null pointer. */
  retVal = KeyM_GetCertEntry_KeyM_CertElementGet_List[certIdx][entryIdx](timeBuffer, &timeLen);

  if (retVal == RTE_E_OK)
  {
    /* Compare time validNotAfter to realTime. */
    TimeM_DateTimeType realTime;
    TimeM_DateTimeType validNotAfter;
    const TimeM_CompareOperatorType opIsGreater = 0;
    boolean isValid = FALSE;

    /* Get real time */
    retVal = Rte_Call_TimeM_RealTime_Get(&realTime);
    /* Parse time validNotAfter, uint16 cast is ok due to initial value. */
    retVal |= Rte_Call_CertP_Functions_ParseTime(timeBuffer, (uint16)timeLen, &validNotAfter);

    if (retVal == RTE_E_OK)
    {
      /* In order to find out if realTime < validNotAfter, check if NOT(realTime > validNotAfter)  */
      if (Rte_Call_TimeM_RealTime_Compare(&realTime, opIsGreater, &validNotAfter, &isValid) == RTE_E_OK)
      {
        retVal = E_OK;
        if (isValid == TRUE)
        {
          /* realTime > validNotAfter, so handle error */
          *certStatus = KEYM_E_CERTIFICATE_VALIDITY_PERIOD_FAIL;
        }
        else
        {
          *certStatus = KEYM_CERTIFICATE_VALID;
        }
      }
      else
      {
        retVal = E_NOT_OK;
      }
    }
  }

  return retVal;
}

/**********************************************************************************************************************
 *  KeyM_CheckTrustModelKeyIds()
 **********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 */
SSA_KEYM_LOCAL FUNC(Std_ReturnType, Ssa_KeyM_CODE) KeyM_CheckTrustModelKeyIds(
  CONST(uint8, AUTOMATIC) certIdxSubject,
  CONST(uint8, AUTOMATIC) certIdxIssuer,
  P2VAR(KeyM_CertificateStatusType, AUTOMATIC, AUTOMATIC) certStatus)
{
  Std_ReturnType retVal;
  uint8 entryIdx;
  uint8 timeCheckVerResult = KEYM_E_CERTIFICATE_VALIDITY_PERIOD_FAIL;

  uint8 authKeyId[SSA_SIZEOF_CERT_SUBJECT_KEY_ID] = { 0 };
  /* Initialize the subjKeyId with a different value than the authKeyId for each byte */
  uint8 subjKeyId[SSA_SIZEOF_CERT_SUBJECT_KEY_ID] = { 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1 };
  uint32 authKeyIdLen = SSA_SIZEOF_CERT_SUBJECT_KEY_ID;
  uint32 subjKeyIdLen = SSA_SIZEOF_CERT_SUBJECT_KEY_ID;

  /* Check if the issuer certificate has not expired. */
  retVal = KeyM_CheckCertificateTime_ValidNotAfter(certIdxIssuer, &timeCheckVerResult);

  /* Get authorityKeyId of certificate under test */
  if (retVal == RTE_E_OK)
  {
    entryIdx = SSA_KEYM_CERT_ENTRY_ENTRY_ID_AUTHORITY_KEY_IDENTIFIER - 1u;
    if (KeyM_GetCertEntry_KeyM_CertElementGet_List[certIdxSubject][entryIdx] != NULL_PTR)
    {
      retVal = KeyM_GetCertEntry_KeyM_CertElementGet_List[certIdxSubject][entryIdx](authKeyId, &authKeyIdLen);
    }
    else
    {
      retVal = E_NOT_OK;
    }
  }

  /* Get subjectKeyId of issuing certificate */
  if (retVal == RTE_E_OK)
  {
    entryIdx = SSA_KEYM_CERT_ENTRY_ENTRY_ID_SUBJECT_KEY_IDENTIFIER - 1u;
    /* For any value of certIdxIssuer, there is a valid SubjectKeyId_CertElementGet function in
     * KeyM_GetCertEntry_KeyM_CertElementGet_List, which is not a null pointer. */
    retVal = KeyM_GetCertEntry_KeyM_CertElementGet_List[certIdxIssuer][entryIdx](subjKeyId, &subjKeyIdLen);
  }

  if (retVal == RTE_E_OK)
  {
    retVal = E_OK;
    if (timeCheckVerResult == KEYM_CERTIFICATE_VALID)
    {
      /* not checking returned lengths of key ids is ok due to initial values and fixed comparison length */
      if (KeyM_CompareData(authKeyId, subjKeyId, SSA_SIZEOF_CERT_SUBJECT_KEY_ID))
      {
        *certStatus = KEYM_CERTIFICATE_VALID;
      }
      else
      {
        *certStatus = KEYM_E_CERTIFICATE_INVALID_CHAIN_OF_TRUST;
      }
    }
    else
    {
      *certStatus = KEYM_E_CERTIFICATE_INVALID_CHAIN_OF_TRUST;
      /* In this case the issuer certificate would be invalid */
    }
  }

  return retVal;
}

/**********************************************************************************************************************
 *  KeyM_SetCertificateStatusToNotAvailable()
 **********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 */
SSA_KEYM_LOCAL FUNC(void, Ssa_KeyM_CODE) KeyM_SetCertificateStatusToNotAvailable(
  CONST(KeyM_CertificateIdType, AUTOMATIC) certId)
{
  uint8 dummy = 0u;
  Ssa_KeyM_CertDataType cert;

  /* #10 Generate empty certificate. */
  cert.certDataLength = 0u;
  cert.certData = &dummy;

  /* #20 Set empty cert in AsrKeyM to erase the certificate - is set to not available. */
  (void)KeyM_KeyM_SetCertificate(certId, &cert);
}

/**********************************************************************************************************************
 *  KeyM_LogTrustModelCertificateVerificationResult()
 **********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 */
SSA_KEYM_LOCAL FUNC(void, Ssa_KeyM_CODE) KeyM_LogTrustModelCertificateVerificationResult(
  KeyM_CertificateIdType certId,
  uint8 verificationResult)
{

  Std_ReturnType retVal = E_NOT_OK;
  CertP_PkiRoleType pkiRole = CERTP_PKI_ROLE_INVALID;

  /* assign PKI role */
  switch (certId) {
  case SSA_TRUST_MODEL_ROOT_CERT_ID:
    pkiRole = CERTP_PKI_ROLE_TRUST_MODEL_ROOT_CA;
    break;
  case SSA_TRUST_MODEL_BACKEND_CERT_ID:
  case SSA_TRUST_MODEL_BACKEND_PEER_CERT_ID:
    pkiRole = CERTP_PKI_ROLE_TRUST_MODEL_BACKEND_CA;
    break;
  case SSA_TRUST_MODEL_INTERMEDIATE_CERT_ID:
  case SSA_TRUST_MODEL_INTERMEDIATE_PEER_CERT_ID:
    pkiRole = CERTP_PKI_ROLE_TRUST_MODEL_INTERMEDIATE_CA;
    break;
  case SSA_TRUST_MODEL_ECU_CERT_ID:
  case SSA_TRUST_MODEL_ECU_PEER_CERT_ID:
    pkiRole = CERTP_PKI_ROLE_TRUST_MODEL_ECU;
    break;
  default:
    /* ignore, use default value */
    break;
  }

  if (verificationResult == 0u)
  {
    /* invalid SN by setting last 3 byte representing the Registration Authority to prohibited value 00-00-00 */
    RightsM_SerialNumberType serialNumber = { 0 };

    /* get certificate's serial number */
    switch (certId) {
      case SSA_TRUST_MODEL_ROOT_CERT_ID:
      {
        KeyM_CertificateElementType_Ssa_TrustModelRootCert_SerialNo serialNoBuffer;
        uint32 serialNoLen = sizeof(KeyM_CertificateElementType_Ssa_TrustModelRootCert_SerialNo);
        retVal = Rte_Call_KeyMCertificateElement_Ssa_TrustModelRootCert_SerialNo_CertificateElementGet(serialNoBuffer, &serialNoLen);
        if (retVal == RTE_E_OK)
        {
          /* cast ok due to intial value */
          (void)Ssa_Utils_ConvertSerialNumber(serialNoBuffer, (uint16)serialNoLen, serialNumber, SSA_SIZEOF_SERIALNUMBER);
        }
        break;
      }

      case SSA_TRUST_MODEL_BACKEND_CERT_ID:
      {
        KeyM_CertificateElementType_Ssa_TrustModelBackendCert_SerialNo serialNoBuffer;
        uint32 serialNoLen = sizeof(KeyM_CertificateElementType_Ssa_TrustModelBackendCert_SerialNo);
        retVal = Rte_Call_KeyMCertificateElement_Ssa_TrustModelBackendCert_SerialNo_CertificateElementGet(serialNoBuffer, &serialNoLen);
        if (retVal == RTE_E_OK)
        {
          /* cast ok due to intial value */
          (void)Ssa_Utils_ConvertSerialNumber(serialNoBuffer, (uint16)serialNoLen, serialNumber, SSA_SIZEOF_SERIALNUMBER);
        }
        break;
      }

      case SSA_TRUST_MODEL_INTERMEDIATE_CERT_ID:
      {
        KeyM_CertificateElementType_Ssa_TrustModelIntermediateCert_SerialNo serialNoBuffer;
        uint32 serialNoLen = sizeof(KeyM_CertificateElementType_Ssa_TrustModelIntermediateCert_SerialNo);
        retVal = Rte_Call_KeyMCertificateElement_Ssa_TrustModelIntermediateCert_SerialNo_CertificateElementGet(serialNoBuffer, &serialNoLen);
        if (retVal == RTE_E_OK)
        {
          /* cast ok due to intial value */
          (void)Ssa_Utils_ConvertSerialNumber(serialNoBuffer, (uint16)serialNoLen, serialNumber, SSA_SIZEOF_SERIALNUMBER);
        }
        break;
      }

      case SSA_TRUST_MODEL_ECU_CERT_ID:
      {
        KeyM_CertificateElementType_Ssa_TrustModelEcuCert_SerialNo serialNoBuffer;
        uint32 serialNoLen = sizeof(KeyM_CertificateElementType_Ssa_TrustModelEcuCert_SerialNo);
        retVal = Rte_Call_KeyMCertificateElement_Ssa_TrustModelEcuCert_SerialNo_CertificateElementGet(serialNoBuffer, &serialNoLen);
        if (retVal == RTE_E_OK)
        {
          /* cast ok due to intial value */
          (void)Ssa_Utils_ConvertSerialNumber(serialNoBuffer, (uint16)serialNoLen, serialNumber, SSA_SIZEOF_SERIALNUMBER);
        }
        break;
      }

      case SSA_TRUST_MODEL_BACKEND_PEER_CERT_ID:
      {
        KeyM_CertificateElementType_Ssa_TrustModelBackendPeerCert_SerialNo serialNoBuffer;
        uint32 serialNoLen = sizeof(KeyM_CertificateElementType_Ssa_TrustModelBackendPeerCert_SerialNo);
        retVal = Rte_Call_KeyMCertificateElement_Ssa_TrustModelBackendPeerCert_SerialNo_CertificateElementGet(serialNoBuffer, &serialNoLen);
        if (retVal == RTE_E_OK)
        {
          /* cast ok due to intial value */
          (void)Ssa_Utils_ConvertSerialNumber(serialNoBuffer, (uint16)serialNoLen, serialNumber, SSA_SIZEOF_SERIALNUMBER);
        }
        break;
      }

      case SSA_TRUST_MODEL_INTERMEDIATE_PEER_CERT_ID:
      {
        KeyM_CertificateElementType_Ssa_TrustModelIntermediatePeerCert_SerialNo serialNoBuffer;
        uint32 serialNoLen = sizeof(KeyM_CertificateElementType_Ssa_TrustModelIntermediatePeerCert_SerialNo);
        retVal = Rte_Call_KeyMCertificateElement_Ssa_TrustModelIntermediatePeerCert_SerialNo_CertificateElementGet(serialNoBuffer, &serialNoLen);
        if (retVal == RTE_E_OK)
        {
          /* cast ok due to intial value */
          (void)Ssa_Utils_ConvertSerialNumber(serialNoBuffer, (uint16)serialNoLen, serialNumber, SSA_SIZEOF_SERIALNUMBER);
        }
        break;
      }

      case SSA_TRUST_MODEL_ECU_PEER_CERT_ID:
      {
        KeyM_CertificateElementType_Ssa_TrustModelEcuPeerCert_SerialNo serialNoBuffer;
        uint32 serialNoLen = sizeof(KeyM_CertificateElementType_Ssa_TrustModelEcuPeerCert_SerialNo);
        retVal = Rte_Call_KeyMCertificateElement_Ssa_TrustModelEcuPeerCert_SerialNo_CertificateElementGet(serialNoBuffer, &serialNoLen);
        if (retVal == RTE_E_OK)
        {
          /* cast ok due to intial value */
          (void)Ssa_Utils_ConvertSerialNumber(serialNoBuffer, (uint16)serialNoLen, serialNumber, SSA_SIZEOF_SERIALNUMBER);
        }
        break;
      }

      default:
        /* ignore, use default return value */
        break;
    }

    (void)Rte_Call_SecLog_SuccessfulCertVerificationEvent_SuccessfulCertificateVerification(serialNumber, pkiRole);
  }
  else
  {
    /* In case certificate verification failed, only log a general 'failed certificate verification result',
     * which is not routine or certificate specific (SSA_IS-2219). */
    (void)Rte_Call_SecLog_FailedCertVerificationEvent_FailedCertificateVerification(pkiRole, KeyM_MapRoutineSpecificVerResToFailedCertificateVerRes(verificationResult));
  }
}  /* PRQA S 6030, 6050 */ /* MD_MSR_STCYC, MD_MSR_STCAL */

/**********************************************************************************************************************
 *  Ssa_KeyM_Certificate_SignDataWithEcuPrivateKey()
 **********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
SSA_KEYM_LOCAL FUNC(Std_ReturnType, Ssa_KeyM_CODE) Ssa_KeyM_Certificate_SignDataWithEcuPrivateKey(
  P2CONST(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_DATA) data,
  uint16 dataLength,
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) signature)
{
  Std_ReturnType retVal = RTE_E_KeyM_Certificate_E_NOT_OK;

  /* ----- Development Error Checks ------------------------------------- */
#if (SSA_DEV_ERROR_DETECT == STD_ON)
  if ((data == NULL_PTR)
    || (signature == NULL_PTR))
  {
    /* retVal already set */
  }
  else
#endif /* SSA_DEV_ERROR_DETECT == STD_ON */
  {
    /* #10 Generate the signature over the passed data with the stored ECU private key. */
    retVal = KeyM_CsmSignatureGenerate(SSA_TRUST_MODEL_LIVE_KEY_PAIR, data, dataLength, signature);
    switch (retVal) {
      case SSA_E_PENDING:
        retVal = RTE_E_KeyM_Certificate_E_PENDING;
        break;
      case E_OK:
        retVal = RTE_E_OK;
        break;
      default:
        retVal = RTE_E_KeyM_Certificate_E_NOT_OK;
        break;
    }
  }

  return retVal;
}

/**********************************************************************************************************************
 *  KeyM_MemClear()
 **********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 */
SSA_KEYM_LOCAL FUNC(void, Ssa_KeyM_CODE) KeyM_MemClear(
  P2VAR(uint8, AUTOMATIC, RTE_SSA_KEYM_APPL_VAR) targetDataBuf,
  uint16_least targetDataBufLength,
  uint16_least lengthToClear)
{
  uint16_least byteIdx, numBytesToClear;

  numBytesToClear = ((lengthToClear > targetDataBufLength) ? targetDataBufLength : lengthToClear);

  /* #10 Set each byte of the target data buffer to the given data value. */
  for (byteIdx = 0u; byteIdx < numBytesToClear; byteIdx++) /* FETA_SSA_KEYM_MONOTONIC_LOOP_UP_WITH_UNCHANGED_UPPER_BOUND */
  {
    targetDataBuf[byteIdx] = 0u; /* VCA_SSA_KEYM_WRITE_WITH_LENGTH_REQUIREMENT */
  }
}

#define Ssa_KeyM_STOP_SEC_CODE
#include "Ssa_KeyM_MemMap.h" /* PRQA S 5087 */ /* MD_MSR_MemMap */

/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << End of function definition area >>              DO NOT CHANGE THIS COMMENT!
 *********************************************************************************************************************/

/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << Start of removed code area >>                   DO NOT CHANGE THIS COMMENT!
 *********************************************************************************************************************/

/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << End of removed code area >>                     DO NOT CHANGE THIS COMMENT!
 *********************************************************************************************************************/

/**********************************************************************************************************************
 MISRA 2012 violations and justifications
 *********************************************************************************************************************/

/* module specific MISRA deviations:
   MD_Rte_0624:  MISRA rule: Rule8.3
     Reason:     This MISRA violation is a consequence from the RTE requirements [SWS_Rte_01007] [SWS_Rte_01150].
                 The typedefs are never used in the same context.
     Risk:       No functional risk. Only a cast to uint8* is performed.
     Prevention: Not required.

   MD_Rte_3206:  MISRA rule: Rule2.7
     Reason:     The parameter are not used by the code in all possible code variants.
     Risk:       No functional risk.
     Prevention: Not required.

 */


/**********************************************************************************************************************
 *  SAFEBSW JUSTIFICATIONS
 *********************************************************************************************************************/

/* VCA_JUSTIFICATION_BEGIN

    \ID  VCA_SSA_KEYM_READDATA_TRUST_MODEL_ECU_CSR
      \DESCRIPTION      According to VCA, the function 'Ssa_Utils_MemCpy' is possibly called outside its specification,
                        where the parameters for this function are as follows:
                        - destination = Data,
                        - source = KeyM_DiagProc.serviceResponseBuffer and
                        - length = KeyM_DiagProc.serviceResponseBufferLength.
                        The function call occurred in Ssa_KeyM_DataServices_DID_019A_Trust_model_ECU_CSR_ReadData().
      \COUNTERMEASURE   \N The function call is valid due to the following reasons:
                        - The user has to stick to the following call order:
                          - Ssa_KeyM_DataServices_DID_019A_Trust_model_ECU_CSR_ConditionCheckRead()
                          - Ssa_KeyM_DataServices_DID_019A_Trust_model_ECU_CSR_ReadDataLength()
                          - Ssa_KeyM_DataServices_DID_019A_Trust_model_ECU_CSR_ReadData().
                        - Ssa_KeyM_DataServices_DID_019A_Trust_model_ECU_CSR_ConditionCheckRead() only returns with E_OK,
                          if in particular KeyM_DiagProc.serviceResponseBufferLength was set.
                        - Ssa_KeyM_DataServices_DID_019A_Trust_model_ECU_CSR_ReadDataLength() returns
                          *DataLength = 2 + KeyM_DiagProc.serviceResponseBufferLength.
                        - The user must call Ssa_KeyM_DataServices_DID_019A_Trust_model_ECU_CSR_ReadData()
                          with a buffer Data which provides *DataLength many bytes.
                          The function writes (2 + KeyM_DiagProc.serviceResponseBufferLength) many bytes to Data.

    \ID  VCA_SSA_KEYM_READDATA_SECOC_PDU_DATA_IDS_AND_KEY_CHECKSUM
      \DESCRIPTION      According to VCA, the functions
                        - 'Ssa_Cdd_Csm_KeyElementGet' and
                        - 'KeyM_MemClear'
                        are possibly called outside its specification, (indicating a possibly invalid write access to Data)
                        or the access of Data[<index>] is possibly out of bounds in function
                        Ssa_KeyM_DataServices_SecOC_PDU_Data_IDs_and_Key_Checksum_ReadData().
      \COUNTERMEASURE   \N The function call is valid due to the following reasons:
                        - The user has to stick to the following call order:
                          - Ssa_KeyM_DataServices_SecOC_PDU_Data_IDs_and_Key_Checksum_ConditionCheckRead() (does nothing)
                          - Ssa_KeyM_DataServices_SecOC_PDU_Data_IDs_and_Key_Checksum_ReadDataLength()
                          - Ssa_KeyM_DataServices_SecOC_PDU_Data_IDs_and_Key_Checksum_ReadData().
                        - Ssa_KeyM_DataServices_SecOC_PDU_Data_IDs_and_Key_Checksum_ReadDataLength() returns
                          *DataLength = Ssa_GetSizeOfDataIdInfo() * (2u + SSA_SIZEOF_KEY_CHECKSUM).
                        - The user must call Ssa_KeyM_DataServices_SecOC_PDU_Data_IDs_and_Key_Checksum_ReadData()
                          with a buffer Data which provides *DataLength many bytes.
                          The function writes (Ssa_GetSizeOfDataIdInfo() * (2u + SSA_SIZEOF_KEY_CHECKSUM)) many bytes to Data,
                          no matter whether Data is filled with bytes retrieved via KeyElementGet or with zero bytes.

  \ID  VCA_SSA_KEYM_WRITE_WITH_LENGTH_REQUIREMENT
    \DESCRIPTION      According to VCA, write access to buffer[idx] may be out of bounds.
    \COUNTERMEASURE   \R The function has a requirement that ensures that $lengthOf(buffer) >= len.
                         idx is limited by a for loop to a value < len.
                         The write access is thus in bounds.

    \ID  VCA_SSA_KEYM_ENCODING_ELEMENT_BUFFER_ACCESS
      \DESCRIPTION      According to VCA, the indexed array access
                         buffer[(*bufferIndex)%bufferLen]
                       is out of bounds
      \COUNTERMEASURE   \R A VCA specification asserts that when the function, in which the access occurs, is called,
                        it holds than $lengthOf(buffer) >= bufferLen.
                        The modulo operation ensures that
                          (*bufferIndex) % bufferLen <= (bufferLen - 1).
                        Thus, the array is accessed at valid indices only.

    \ID  VCA_SSA_KEYM_COPY_TO_SERVICE_RESPONSE_BUFFER
      \DESCRIPTION      According to VCA, the following assertions may fail:
                          assert KeyM_DiagProc.ws.trustModelReplaceCerts.certLength_ecu <= SSA_MAX_SIZE_TRUSTMODEL_ECU_CERT;
      \COUNTERMEASURE   \R The value assigned to KeyM_DiagProc.ws.trustModelReplaceCerts.certLength_ecu is checked 
                          to be  < SSA_MAX_SIZE_TRUSTMODEL_ECU_CERT in the beginning of the routine in function
                          KeyM_ReplaceTrustModelCerts_HandleStateIdle() and is not changed afterwards.

    \ID  VCA_SSA_KEYM_COPY_TO_REPLACEMENT_PACKAGE_BUFFER
      \DESCRIPTION      According to VCA, the following sequence of function calls is possibly outside its specification
                          KeyM_DiagProc.ws.trustModelReplaceRootCert.replacementPackageBufferLength = 0u;

                          KeyM_CopyDataBuffer(&KeyM_DiagProc.ws.trustModelReplaceRootCert.replacementPackageBuffer[KeyM_DiagProc.ws.trustModelReplaceRootCert.replacementPackageBufferLength],
                                              someSource,
                                              certLength_enh);
                          KeyM_DiagProc.ws.trustModelReplaceRootCert.replacementPackageBufferLength = certLength_enh;

                          KeyM_CopyDataBuffer(&KeyM_DiagProc.ws.trustModelReplaceRootCert.replacementPackageBuffer[KeyM_DiagProc.ws.trustModelReplaceRootCert.replacementPackageBufferLength],
                                              someSource,
                                              certLength_newroot);          
                          KeyM_DiagProc.ws.trustModelReplaceRootCert.replacementPackageBufferLength += certLength_newroot;

                          KeyM_CopyDataBuffer(&KeyM_DiagProc.ws.trustModelReplaceRootCert.replacementPackageBuffer[KeyM_DiagProc.ws.trustModelReplaceRootCert.replacementPackageBufferLength],
                                              someSource,
                                              SSA_SIZEOF_SIGNATURE);

                        This sequence occurs in function KeyM_ReplaceTrustModelRootCert_HandleStateIdleAndVerifyingEnhanceCert().
      \COUNTERMEASURE   \R The buffer KeyM_DiagProc.ws.trustModelReplaceRootCert.replacementPackageBuffer is of size SSA_SIZEOF_REPLACEMENT_PACKAGE_BUFFER.
                        This is asserted.
                        Before the sequence is reached, a runtime check ensures that
                        ((certLength_enh + certLength_newroot + SSA_SIZEOF_SIGNATURE + SSA_SIZEOF_SIGNATURE) <= SSA_SIZEOF_REPLACEMENT_PACKAGE_BUFFER).
                        These length values are stored in KeyM_DiagProc.ws.trustModelReplaceRootCert. They are only modified in this function
                        and nowhere else. This is ensured by review.


    \ID  VCA_SSA_KEYM_RANGE_CHECK
      \DESCRIPTION      According to VCA, the following assertion may be violated:
                          In_Certificate_Entry_In > SSA_KEYM_CERT_ENTRY_ENTRY_ID_INVALID && In_Certificate_Entry_In <= SSA_KEYM_CERT_ENTRY_ENTRY_ID_NUM.
      \COUNTERMEASURE   \R A runtime check asserts that the assertion is fulfilled.
                        Hint: The check is contained in function KeyM_GetCertEntry_IsIdValid.

    \ID  VCA_SSA_KEYM_CALL_FUNCTION_FROM_CERTELEMENTGET_LIST
      \DESCRIPTION      According to VCA, a null pointer may be called in the expression
                          KeyM_GetCertEntry_KeyM_CertElementGet_List[localCertId][localElementId](someParameters);
      \COUNTERMEASURE   \R KeyM_GetCertEntry_KeyM_CertElementGet_List is a two dimensional array containing functions,
                        some entries are null pointers. Before a function from the array is called, a runtime check
                        ensures that the corresponding entry is not a null pointer.

    \ID  VCA_SSA_KEYM_COPY_TO_INJECTSEED_DATABUFFER
      \DESCRIPTION      According to VCA, the following assertion may be violated:
                           (encryptedSeedLength + 2u) <= DataLength.
                        Subsequently, the following function calls may occur outside their specification:
                          Ssa_MemCpy(&KeyM_DiagProc.ws.injectSeed.dataBuffer[<someStartIdx>], <someSource>, <someLength>).
      \COUNTERMEASURE   \R In function KeyM_InjectSeed_HandleStateIdle, data from the input parameter Encrypted_Seed_In
                        shall be copied to the static buffer KeyM_DiagProc.ws.injectSeed.dataBuffer.
                        The first two bytes of Encrypted_Seed_In contain the length of the encrypted seed contained
                        in this buffer; the additional input parameter DataLength contains the total length of the buffer
                        Encrypted_Seed_In. This is stated in the API contract of the calling function 
                        Ssa_KeyM_RoutineServices_Inject_Seed() and verified by review.
                        The following statements are ensured by runtime checks which are perfomed in
                        function KeyM_InjectSeed_HandleStateIdle:
                        - DataLength <= sizeof(Dcm_Data1058ByteType), i.e., the total length of the buffer Encrypted_Seed_In
                          does not exceed 1058 bytes.
                        - (encryptedSeedLength + 2) = (KeyM_GetUint16(Encrypted_Seed_In[0u], Encrypted_Seed_In[1u]) + 2) <= DataLength,
                          i.e., the length of the encrypted seed itself does not exceed 1058 bytes either.
                        If both runtime checks were satisfied, data is copied to the static buffer
                        KeyM_DiagProc.ws.injectSeed.dataBuffer in two steps. 
                        - First, the encrypted seed itself is copied to the static buffer.
                          As shown above, the seed is at most 1058 bytes long.
                        - Then, a public key of 32 bytes is copied to the buffer.
                        It is asserted that the length of the static buffer is sufficient to store (1058 + 32) bytes.
                        Thus, also the calls to Ssa_Utils_MemCpy are valid.

    \ID  VCA_SSA_KEYM_COPY_VALID_ENTRY
      \DESCRIPTION      According to VCA, the following function call is possibly outside its specification:
                          Ssa_MemCpy(targetDataBuf, &(certBuf[entry->elemDataIdx]), entry->elemDataLength)
                        within function KeyM_CopyValidEntry().
      \COUNTERMEASURE   \R It is asserted within KeyM_CopyValidEntry() that the destination
                        buffer targetDataBuf is 64 bytes long.
                        It is asserted within KeyM_CopyValidEntry() that dataLength = 64.
                        A runtime check ensures that the size value entry->elemDataLength, which is passed
                        to Ssa_MemCpy does not exceed dataLength = 64.
                        Thus, at most 64 bytes are copied and the call to Ssa_MemCpy is valid.

    \ID  VCA_SSA_KEYM_ENCODE_UNIQUE_ECU_IDS
      \DESCRIPTION      According to VCA the following function call within KeyM_EncodeUniqueEcuIds() is
                        outside its specification:
                        Ssa_Utils_MemCpy(&buffer[bufferIdx], Ssa_GetAddrUniqueEcuIds(Ssa_GetUniqueEcuIdsUniqueEcuIdsStartIdxOfUniqueEcuId(i)), lengthUniqueEcuId),
                        where
                        - buffer is a parameter of KeyM_EncodeUniqueEcuIds(),
                        - bufferIdx is a local variable and
                        - lengthUniqueEcuId is a local variable.
                        The copy function is called repeatedly within a for-loop, where also the value of bufferIdx is increased in each iteration.
      \COUNTERMEASURE   \R KeyM_EncodeUniqueEcuIds() is only called once with a static buffer of known size as parameter 'buffer'.
                           The size of the buffer is constructed in such a way, that it is sufficiently large to store all
                           DER encoded unique ECU IDs, see comment at the definition of SSA_SIZEOF_ENCODED_UNIQUEECUIDS.
                           The sufficency of the buffer size is further ensured by a runtime check in function
                           KeyM_GetNumBytesNeededForEncodingUniqueEcuIds(), where it is ensured that each unique ECU ID is at most
                           SSA_MAX_SIZEOF_UNIQUEECUID (30) bytes long.
                           A VCA specification ensures that when KeyM_EncodeUniqueEcuIds() is called, buffer and *bufferLen match.

    \ID  VCA_SSA_KEYM_LENGTH_SPECIFIED_IN_FCT_CALL
      \DESCRIPTION      According to VCA, the following assertion is possibly violated:
                          $lengthOf(<parameter>) >= <specified size>.
                       This affects calls to functions in
                         - Ssa_KeyM_RoutineServices_Replace_Trust_model_Root_Certificate
                         - KeyM_Replace_Trust_model_Root_Certificate_State_Handler
                         - Ssa_KeyM_RoutineServices_Trust_Model_Generate_Key_Pair
                         - Ssa_KeyM_Certificate_VerifyCertWithBackendCert
                       and function calls therein.
      \COUNTERMEASURE   \N A specification ensures that when the function is called,
                        $lengthOf(<parameter>) >= <specified size> holds.

    \ID  VCA_SSA_KEYM_REPLACE_ROOT_CERT_CERT_START_IDX
      \DESCRIPTION      According to VCA, the following assertions are possibly violated:
                          - KeyM_DiagProc.ws.trustModelReplaceRootCert.certIdx_newroot < sizeof(Dcm_Data2004ByteType)
                          - certIdx_newroot < sizeof(Dcm_Data2004ByteType)
                          -  &Certificates_In[KeyM_DiagProc.ws.trustModelReplaceRootCert.certIdx_newroot] != NULL_PTR
                        and the functions
                          - Vcastub_Rte_Call_Csm_SignatureVerify and
                          - Vcastub_Rte_Call_Ssa_Cdd_KeyM_ServiceCertificate
                        might be called outside its specification.
                        The root of the call tree leading to these violations is API
                        Ssa_KeyM_RoutineServices_Replace_Trust_model_Root_Certificate().
      \COUNTERMEASURE   \N In this API, a state machine is processed. Within the first processed state,
                        which is handled in KeyM_ReplaceTrustModelRootCert_HandleStateIdleAndVerifyingEnhanceCert(),
                        the static variable KeyM_DiagProc.ws.trustModelReplaceRootCert.certIdx_newroot is updated.
                        This variable is not written at any other point. This is ensured by review.
                        The stored value does not exceed sizeof(Dcm_Data2004ByteType). This is ensured by a runtime check.
                        Thus, in a state which is processed later in KeyM_ReplaceTrustModelRootCert_HandleStateVerifyingSignatureNewRoot(),
                        it still holds that KeyM_DiagProc.ws.trustModelReplaceRootCert.certIdx_newroot < sizeof(Dcm_Data2004ByteType).
                        Since it is ensured by specifications that $lengthOf(Certificates_In) >= sizeof(Dcm_Data2004ByteType), 
                        &Certificates_In[KeyM_DiagProc.ws.trustModelReplaceRootCert.certIdx_newroot] is a valid pointer.
                        Hence, since all other parameters are valid pointers, too, the calls to 
                        Vcastub_Rte_Call_Csm_SignatureVerify and Vcastub_Rte_Call_Ssa_Cdd_KeyM_ServiceCertificate are valid.

    \ID  VCA_SSA_KEYM_TRUST_MODEL_ROOT_CERT_CERT_BUFFER
      \DESCRIPTION      According to VCA, the following assertion is possibly violated:
                          - KeyM_DiagProc.ws.trustModelReplaceRootCert.certificateDataRootBackup.certData = &KeyM_DiagProc.ws.trustModelReplaceRootCert.certBufferRoot[0]
                        in function KeyM_ReplaceTrustModelRootCert_HandleStateAwaitingVerificationResultNewRootCertAndStoring().                          
                        The root of the call tree leading to these violations is API
                        Ssa_KeyM_RoutineServices_Replace_Trust_model_Root_Certificate().
      \COUNTERMEASURE   \N In this API, a state machine is processed. The following states
                        are handled directly one after another:    
                          - KeyM_ReplaceTrustModelRootCert_HandleStateVerifyingSignatureNewRoot()and 
                          - KeyM_ReplaceTrustModelRootCert_HandleStateAwaitingVerificationResultNewRootCertAndStoring(),
                        where the latter state reached only if the former state was finalized successfully. This is ensured
                        by a runtime check.
                        In the former state, the following pointer is assgined to a valid address:
                          KeyM_DiagProc.ws.trustModelReplaceRootCert.certificateDataRootBackup.certData = &KeyM_DiagProc.ws.trustModelReplaceRootCert.certBufferRoot[0];
                        This is ensured by a VCA assertion.
                        In the latter state, the pointer certData is used, and is still a valid pointer at that time.
                        This is also why the call to Vcastub_Rte_Call_Ssa_Cdd_KeyM_ServiceCertificate is valid.

    \ID  VCA_SSA_KEYM_KEY_EXCHANGE_STATE_CALC_PUBVAL
      \DESCRIPTION      According to VCA, the following assertion for calling KeyM_CsmKeyExchangeCalcPubVal() is possibly violated:
                          - keyExchangePubVal != NULL_PTR;
                        when being called within the function KeyM_KeyExchangeCalcSymmetricKey().
      \COUNTERMEASURE   \R In the function KeyM_KeyExchangeCalcSymmetricKey(), a state machine is processed.
                        The described violation occurs in the state XXX_CALC_PUBVAL.
                        If the buffer ePubKeyOwn == NULL_PTR, the state variable is set to XXX_CALC_SECRET.
                        In the state XXX_CALC_SECRET, after calculating the secret, the state variable is directly set back to idle.
                        Therefore it is not possible to reach the state XXX_CALC_PUBVAL with ePubKeyOwn == NULL_PTR.

    \ID  VCA_SSA_KEYM_BACKENDCAANDLINK_VALID_POINTER_AFTER_EXTRACTION
      \DESCRIPTION      According to VCA, the following assertions may fail:
                          - cert->backendCaLink != NULL_PTR
                          - cert->backendCa != NULL_PTR
                        in function KeyM_Replace_Certificate_VerifyAndReplaceReceivedCertificates().
      \COUNTERMEASURE   \N The function KeyM_Replace_Certificate_VerifyAndReplaceReceivedCertificates() is called to process a state of a statemachine.
                        The previous state is handled by KeyM_Replace_Certificate_Extract_Certificates(). 
                        If this function was executed successfully and returned KEYM_REPLACE_CERT_BACKEND_AND_LOWER, cert->backendCaLink
                        and cert->backendCa are valid pointers.
                        This is ensured by review.
                        The return value of KeyM_Replace_Certificate_Extract_Certificates() is used parameter value extractedCertificate
                        in KeyM_Replace_Certificate_VerifyAndReplaceReceivedCertificates().
                        This is ensured by review.
                        Therefore, the pointers cert->backendCaLink and cert->backendCa are still valid when
                        calling KeyM_Replace_Certificate_Replace_BackendAndLower().

    \ID  VCA_SSA_KEYM_BACKENDCAANDLINK_VALID_POINTER_BEFORE_REPLACEMENT
      \DESCRIPTION      According to VCA, the following assertions may fail:
                          - cert->backendCaLink != NULL_PTR
                          - cert->backendCa != NULL_PTR
                        in function KeyM_Replace_Certificate_Replace_BackendAndLower().
      \COUNTERMEASURE   \N When calling the function KeyM_Replace_Certificate_Replace_BackendAndLower(),
                        the pointers cert->backendCaLink and cert->backendCa are valid.
                        This is ensured by function specification.
                        KeyM_Replace_Certificate_Replace_BackendAndLower() processes a state machine with the initial state IDLE.
                        The state variable KeyM_DiagProc.replaceCertificatesReplaceBackendAndLowerState is initialized
                        as IDLE in KeyM_Init() and only modified within KeyM_Replace_Certificate_Replace_BackendAndLower().
                        This is ensured by review.
                        Within the IDLE-state the parameter cert is passed as const pointer to another function and therefore
                        cert->backendCaLink and cert->backendCa are not modified and also still valid pointers in the
                        following states.

    \ID  VCA_SSA_KEYM_ROOTCAANDLINK_VALID_POINTER_AFTER_EXTRACTION
      \DESCRIPTION      According to VCA, the following assertions may fail:
                          - cert->rootCa != NULL_PTR
                          - cert->rootCaLink != NULL_PTR
                          - cert->backendCa != NULL_PTR
                        in function KeyM_Replace_Certificate_VerifyAndReplaceReceivedCertificates().
      \COUNTERMEASURE   \N The function KeyM_Replace_Certificate_VerifyAndReplaceReceivedCertificates() is called to process a state of a statemachine.
                        The previous state is handled by KeyM_Replace_Certificate_Extract_Certificates().
                        If this function was executed successfully and returned KEYM_REPLACE_CERT_ROOT_AND_LOWER, cert->rootCa, cert->rootCaLink
                        and cert->backendCa are valid pointers.
                        This is ensured by review.
                        The return value of KeyM_Replace_Certificate_Extract_Certificates() is used parameter value extractedCertificate
                        in KeyM_Replace_Certificate_VerifyAndReplaceReceivedCertificates().
                        This is ensured by review.
                        Therefore, the pointers cert->rootCa, cert->rootCaLink and cert->backendCa are still valid when
                        calling KeyM_Replace_Certificate_Replace_RootAndLower().

    \ID  VCA_SSA_KEYM_ROOTCAANDLINK_VALID_POINTER_BEFORE_REPLACEMENT
      \DESCRIPTION      According to VCA, the following assertions may fail:
                          - cert->rootCa != NULL_PTR
                          - cert->rootCaLink != NULL_PTR
                          - cert->backendCa != NULL_PTR
                        in function KeyM_Replace_Certificate_Replace_RootAndLower().
      \COUNTERMEASURE   \N When calling the function KeyM_Replace_Certificate_Replace_RootAndLower(),
                        the pointers cert->rootCa, cert->rootCaLink and cert->backendCa are valid.
                        This is ensured by function specification.
                        KeyM_Replace_Certificate_Replace_RootAndLower() processes a state machine with the initial state IDLE.
                        The state variable KeyM_DiagProc.replaceCertificatesReplaceRootAndLowerState is initialized
                        as IDLE in KeyM_Init() and only modified within KeyM_Replace_Certificate_Replace_RootAndLower().
                        This is ensured by review.
                        Within the IDLE-state the parameter cert is passed as const pointer to another function and therefore
                        cert->rootCa, cert->rootCaLink and cert->backendCa are not modified and also still valid pointers in the
                        following states.

    \ID  VCA_SSA_KEYM_ECUCERT_VALID_POINTER_AFTER_EXTRACTION
      \DESCRIPTION      According to VCA, the following assertion may fail:
                          cert->ecu != NULL_PTR
                        in function KeyM_Replace_Certificate_VerifyAndReplaceReceivedCertificates(),
                        if SSA_ECU_TYPE == SSA_ECU_TYPE_VSM.
      \COUNTERMEASURE   \N The function KeyM_Replace_Certificate_VerifyAndReplaceReceivedCertificates() is called
                        to process a state of a statemachine.
                        The previous state is handled by KeyM_Replace_Certificate_Extract_Certificates().
                        If this function was executed successfully and returned anything but KEYM_REPLACE_NO_CERT,
                        cert->ecu is a valid pointer, if SSA_ECU_TYPE == SSA_ECU_TYPE_VSM. This is ensured by review.
                        Therefore, the pointer cert->ecu is still valid when
                        KeyM_Replace_Certificate_VerifyAndReplaceReceivedCertificates is called
                        and SSA_ECU_TYPE == SSA_ECU_TYPE_VSM.

    \ID  VCA_SSA_KEYM_ECU_CERT_VALID_POINTER_BEFORE_REPLACEMENT
      \DESCRIPTION      According to VCA, the following assertion may fail:
                          cert->ecu != NULL_PTR
                        in functions
                        - KeyM_Replace_Certificate_Replace_BackendAndLower(),
                        - KeyM_Replace_Certificate_Replace_RootAndLower(),
                        - KeyM_Replace_Certificate_Replace_Ecu() and
                        - KeyM_Replace_Certificate_Verify_Ecu().
      \COUNTERMEASURE   \N When calling any of the listed functions for a VSM ECU, the pointer cert->ecu is valid.
                        This is ensured by VCA assertions at the beginning of each of the listed functions
                        or by specifications.
                        All functions process a state machine with the initial state IDLE, see also
                        - VCA_SSA_KEYM_BACKENDCAANDLINK_VALID_POINTER_BEFORE_REPLACEMENT and
                        - VCA_SSA_KEYM_ROOTCAANDLINK_VALID_POINTER_BEFORE_REPLACEMENT.
                        All state variables are initialized as IDLE in KeyM_Init() and only modified within
                        the listed functions. This is ensured by review.
                        Within the IDLE-state the parameter cert is passed as const pointer to another function and therefore
                        cert->ecu is not modified and still a valid pointer in the following states.
                        Note: In function KeyM_Replace_Certificate_Replace_Ecu(), cert is not passed during the IDLE-state,
                        but during state KEYM_REPLACE_CERT_REPLACE_ECUCERT_STATE_VERIFY_ECU_CERT. This is the only difference.

    \ID  VCA_SSA_KEYM_NEW_CERT_POINTER_VALID
      \DESCRIPTION      According to VCA, the following assertions may fail:
                          - certStructure->backendCaLink != NULL_PTR;
                          - certStructure->backendCa != NULL_PTR;
                          - certStructure->rootCaLink != NULL_PTR
                        in function KeyM_ReplaceCertificates_ParseCertsForVerification().
      \COUNTERMEASURE   \N Function KeyM_ReplaceCertificates_ParseCertsForVerification() is called from two other functions, namely
                        - KeyM_Replace_Certificate_Replace_BackendAndLower() and
                        - KeyM_Replace_Certificate_Replace_RootAndLower().
                        Parameter subjectCertIdentifier is used to identify from where KeyM_ReplaceCertificates_ParseCertsForVerification()
                        is called. This is ensured by review.
                        In each case, only members of certStructure, which are valid pointers, are accessed, since the
                        following justifications hold:
                        - VCA_SSA_KEYM_BACKENDCAANDLINK_VALID_POINTER_BEFORE_REPLACEMENT and
                        - VCA_SSA_KEYM_ROOTCAANDLINK_VALID_POINTER_BEFORE_REPLACEMENT.

    \ID  VCA_SSA_KEYM_ACCESS_TRUST_CERTIFICATES_IN_AT_IDX
      \DESCRIPTION      According to VCA, the following function might be called outside its specification:
                          Rte_Call_SsaCdd_TrustModel_ServiceCertificate,
                        i.e., the buffer passed to it as RequestData may be a null pointer.
      \COUNTERMEASURE \R In API Ssa_KeyM_RoutineServices_Replace_Trust_model_Certificates(), the state handler
                      KeyM_Replace_Trust_Model_Certificates_State_Handler handles the following states
                        - IDLE (by calling KeyM_ReplaceTrustModelCerts_HandleStateIdle),
                        - REQUESTING_SERVICE_CERT_BACKEND (by calling KeyM_ReplaceTrustModelCerts_HandleStateRequestingServiceCertBackend) and
                        - AWAITING_VERIFICATION_RESULT_BACKEND_CERT (by calling KeyM_ReplaceTrustModelCerts_AwaitingVerificationResultBackendCert)
                      one after another, there are no states inbetween. The next state is processed only if the previous state was finalized without error.
                      In the two latter states, buffer Trust_Certificates_In is accessed at
                        - KeyM_DiagProc.ws.trustModelReplaceCerts.certIdx_backend in KeyM_ReplaceTrustModelCerts_HandleStateRequestingServiceCertBackend() and at
                        - KeyM_DiagProc.ws.trustModelReplaceCerts.certIdx_intermediate in KeyM_ReplaceTrustModelCerts_AwaitingVerificationResultBackendCert().
                      The values of these two indices are set during the first state, IDLE,
                      in KeyM_ReplaceTrustModelCerts_HandleStateIdle(). A runtime check asserts
                      that the value does not exceed the real length of Trust_Certificates_In
                      (which is stored in parameter DataLength of the outermost API).

   \ID  VCA_SSA_KEYM_FUNCTION_REQUIREMENTS_VIOLATED
    \DESCRIPTION      According to VCA, the following functions might be called outside their specifications:
                        1. Rte_Call_CertP_Functions_Certificate_Verify
                        2. Rte_Call_CertP_Functions_Certificate_Parse
                        3. KeyM_CheckRequestersAuthorization
                        4. Rte_Call_CsmSymAES128DecryptWithPadding_Decrypt
    \COUNTERMEASURE   \R Before calling the functions, all function requirements (specified in Rte.vcaspecs.c (1+2+4) or the function declaration (3)) are checked by assertions:
                          1. - rawCertData != NULL_PTR;
                             - parsedCert != NULL_PTR;
                             - rawCertIssuer != NULL_PTR;
                             - parsedCertIssuer != NULL_PTR;
                          2. - rawCertData != NULL_PTR;
                             - parsedCert != NULL_PTR
                          3. - subjectKeyIdentifier != NULL_PTR
                          4. - dataPtr != NULL_PTR;
                             - resultPtr != NULL_PTR;
                             - resultLengthPtr != NULL_PTR;
                             - $lengthOf(resultPtr) >= *resultLengthPtr;
                             - $lengthOf(resultPtr) >= sizeof(Csm_DecryptResultType_AES128DecryptWithPadding);
                         If all assertions are okay, no specifications are violated.

    \ID  VCA_SSA_KEYM_VALID_CERT_BUFFER_FOR_VERIFICATION
      \DESCRIPTION      According to VCA, one or more of the following assertions may fail:
                          - sizeof(cert->ecu) >= sizeof(CertP_RawCertBufferType);
                          - sizeof(cert->backendCa) >= sizeof(CertP_RawCertBufferType);
                          - sizeof(cert->backendCaLink) >= sizeof(CertP_RawCertBufferType);
                          - sizeof(cert->rootCa) >= sizeof(CertP_RawCertBufferType);
                          - sizeof(cert->rootCaLink) >= sizeof(CertP_RawCertBufferType);
                        within in the functions:
                          - KeyM_Replace_Certificate_Verify_Ecu
                          - KeyM_Replace_Certificate_Replace_BackendAndLower
                          - KeyM_Replace_Certificate_Replace_RootAndLower
                        before calling Rte_Call_CertP_Functions_Certificate_Verify().
      \COUNTERMEASURE   \N All three functions are called from within KeyM_Replace_Certificate_VerifyAndReplaceReceivedCertificates,
                        after all certificate lengths are checked for the allowed maximum length. This ensures that in
                        each case cert->ecu, cert->backendCa, cert->rootCa, cert->backendCaLink, cert->rootCaLink
                        point to a sub-buffer of certificates that is greater than or equal to sizeof(CertP_RawCertBufferType) == SSA_SIZEOF_CERT_MAX
                        since SSA_SIZEOF_CERT_MAX + SSA_SIZEOF_CERT_MAX + SSA_SIZEOF_CERT_MAX + SSA_SIZEOF_CERT_MAX < sizeof(Certificates) = sizeof(Dcm_Data4008ByteType).

  VCA_JUSTIFICATION_END */

/***********************************************************************************************************************
 *  FETA JUSTIFICATIONS
 **********************************************************************************************************************/
/* FETA_JUSTIFICATION_BEGIN

\ID FETA_SSA_KEYM_MONOTONIC_LOOP_UP_WITH_UNCHANGED_UPPER_BOUND
    \DESCRIPTION  According to FETA loop may not terminate
                  in functions
                  - KeyM_GenerateAndStoreSecOcKeys()
                  - KeyM_MemClear();
    \COUNTERMEASURE \N The here applied loop uses a variable as upper bound that remains unchanged during loop
                       execution. The loop's type of the counter variable is appropriate for the loop's type of upper
                       bound variable and is increased once within each single loop (strictly monotonically increasing)
                       until it reaches a value that makes the loop stop without any occurrences of overflows. This
                       is done by a comparison used as loop termination condition that considers the amount of the 
                       increment that is applied within each single loop.

FETA_JUSTIFICATION_END */

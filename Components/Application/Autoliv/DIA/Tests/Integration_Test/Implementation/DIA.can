/*@!Encoding:1252*/
includes
{

  #include "S:\Tools\CANoe\Config\DAIMLER_MMA_INTEGRATION\Includes\WinIdea_Includes\Debugger_Functions.cin"
  #include "..\Includes\SW_Modules\SW_Modules_Project\Project_Includes_Configuration.cin"
  #include "S:\Tools\CANoe\Config\DAIMLER_MMA_INTEGRATION\Includes\WinIdea_Includes\Debugger_Defines.cin"
}


variables
{
enum        bool {TRUE = 1, FALSE = 0};
}

void SendDiagnosticRequestNegativeResponse(diagRequest * dRequest, diagResponse * dResponse, enum bool isPositiveResultExpected)
{
  stack int iErrHandle = 0;

  diagSendRequest(dRequest);

  iErrHandle = testWaitForDiagRequestSent(dRequest, 2500); // 500 ms too short for Write Steps Library.

 

  if (isPositiveResultExpected == 0)
        {

          diagGetLastResponse(dRequest, dResponse);
          testStepFail("Error", "Error occured while receiving diagnostic response");
          dResponse.SetPrimitiveData(bEmptyBuffer, dRequest.GetRespPrimitiveSize());
          testReportWriteDiagObject(dRequest);
      }
        else
        {
          testStepPass("", "Negative response received as expected.");
          dResponse.SetPrimitiveData(bEmptyBuffer, dRequest.GetRespPrimitiveSize());
      }
  }

testcase InitTestModule()
{
  ConfigureTestModuleInformation(PVI);
  
  strncpy(cLogPath, "S:\\Tools\\CANoe\\Config\\DAIMLER_MMA_INTEGRATION\\Logs\\DIA\\",  elcount(cLogPath));
}


testcase SW_Int_DIA_runDidF18C_EcuSerialNumberRead_01()
{
  ////***********************************Test report header*********************************
  testReportAddMiscInfoBlock("AUTOLIV ELECTRONICS document");
  TestReportAddMiscInfo("Nightly test", "No");
  TestReportAddMiscInfo("Test type", "Requirement-Based test");
  TestReportAddMiscInfo("Regression Test", "Yes");
  TestReportAddMiscInfo("Fault injection method used", "No");
  TestReportAddMiscInfo("Resource usage evaluation", "No");
  TestReportAddMiscInfo("Priority", "No");
  TestReportAddMiscInfo("Safety relevant", "No");
  
  AddRequirementInfo("Requirement under test", "ARCH_SW_DIA_0000; ARCH_SW_DIA_0051; ARCH_SW_DIA_0052, ARCH_SW_NVP_0003");
  AddRequirementInfo("ARCH_SW_DIA_0000", "Service 0x22 will be implemented for DID F18C.");
  AddRequirementInfo("ARCH_SW_DIA_0051", "Service should be available in Default and extended session.");
  AddRequirementInfo("ARCH_SW_DIA_0052", "NVP_BLOCK_ID_AEE_TRACEABILITY_RamBlockData will be read.");
  AddRequirementInfo("ARCH_SW_NVP_0003", "NVP_BLOCK_ID_AEE_TRACEABILITY block shall be configured. Parameter NVP_au8AeeTraceabilityNumber should have 12 bytes and should store AEE ECU Traceability number. (default values 0xFF).");


  ////***************************************************************************************

  testCaseComment("Preconditions");
  testStep("STEP", "Bench Initialization");
  
  testStep("", "Delete all breakpoint from debugger.");
  debugger_deleteAllBreakpoints();

  testStep("", "Reset the debugger.");
  debugger_reset();
    
  testStep("", "Run the debugger.");
  debugger_run();
  
  RunPreTs();
  ////====================================================

  testStep("STEP", "Enter default or extended session.");
  EnterDiagnosticSession("default");
  
  testStep("STEP", "Set breakpoint in function *DIA_runDidF18C_ECUSerialNumberRead*.");
  debugger_setRelativeFunctionBpAtLine("DIA_runDidF18C_EcuSerialNumberRead", "4");
  debugger_run();
 
  testCaseComment("Action: ARCH_SW_DIA_0000, ARCH_SW_DIA_0051");
  testStep("STEP", "Send diag request for 22 F18C and wait for timeout error --> Timeout received.");
  SendDiagnosticRequestNegativeResponse(dECUSerialNumberReadRequest, dECUSerialNumberReadResponse, TRUE);

  testStep("STEP", "Check if breakpoint from function DIA_runDidF18C_ECUSerialNumberRead was reached. --> BP was reached.");
  debugger_waitUntilBPisReached("5000");
  ExpectedTestResult(debugger_result, IS_CPU_STOP_AT_BP_SUCCESFUL, "BP is reached.");
  
  testCaseComment("Action: ARCH_SW_DIA_0000, ARCH_SW_DIA_0051, ARCH_SW_NVP_0003");
  testStep("STEP", "Read first byte of NVP_BLOCK_ID_AEE_TRACEABILITY_RamBlockData --> Byte was read.");
  debugger_readVariable("uint8", "NVP_BLOCK_ID_AEE_TRACEABILITY_RamBlockData,,app.elf", "0");
  ExpectedTestResult(debugger_result, "NVP_BLOCK_ID_AEE_TRACEABILITY_RamBlockData", "Byte was read");

  ////====================================================
  testCaseComment("Postcondition");
  testStep("STEP", "Return ECU to default values");
  RunPostTs();
}

testcase SW_Int_DIA_runDidF18C_EcuSerialNumberReadDataLength_01()
{
  ////***********************************Test report header*********************************
  testReportAddMiscInfoBlock("AUTOLIV ELECTRONICS document");
  TestReportAddMiscInfo("Nightly test", "No");
  TestReportAddMiscInfo("Test type", "Requirement-Based test");
  TestReportAddMiscInfo("Regression Test", "Yes");
  TestReportAddMiscInfo("Fault injection method used", "No");
  TestReportAddMiscInfo("Resource usage evaluation", "No");
  TestReportAddMiscInfo("Priority", "No");
  TestReportAddMiscInfo("Safety relevant", "No");
  
  AddRequirementInfo("Requirement under test", "ARCH_SW_DIA_0000; ARCH_SW_DIA_0053");
  AddRequirementInfo("ARCH_SW_DIA_0000", "Service 0x22 will be implemented for DID F18C.");
  AddRequirementInfo("ARCH_SW_DIA_0053", "Runnable shall set response length to 12.");

  ////***************************************************************************************

  testCaseComment("Preconditions");
  testStep("STEP", "Bench Initialization");
  
  testStep("", "Delete all breakpoint from debugger.");
  debugger_deleteAllBreakpoints();

  testStep("", "Reset the debugger.");
  debugger_reset();
    
  testStep("", "Run the debugger.");
  debugger_run();
  
  RunPreTs();
  ////====================================================

  testStep("STEP", "Enter default or extended session.");
  EnterDiagnosticSession("extended");
  
  testCaseComment("Action: ARCH_SW_DIA_0000, ARCH_SW_DIA_0053");
  testStep("STEP", "Send diag request for 22 F1 8C, and evaluate response --> Request sent.");
  SendDiagnosticRequest(dECUSerialNumberReadRequest, dECUSerialNumberReadResponse);

  testStep("STEP", "Evaluate response data lenght. --> response data lenght is 12.");
  EvaluateDiagResponseSize(dECUSerialNumberReadRequest, 12);

  ////====================================================
  testCaseComment("Postcondition");
  testStep("STEP", "Return ECU to default values");
  RunPostTs();
}

testcase SW_Int_DIA_runDid0340_UniqueSeatbeltSerialNumberRead_01()
{
  ////***********************************Test report header*********************************
  testReportAddMiscInfoBlock("AUTOLIV ELECTRONICS document");
  TestReportAddMiscInfo("Nightly test", "No");
  TestReportAddMiscInfo("Test type", "Requirement-Based test");
  TestReportAddMiscInfo("Regression Test", "Yes");
  TestReportAddMiscInfo("Fault injection method used", "No");
  TestReportAddMiscInfo("Resource usage evaluation", "No");
  TestReportAddMiscInfo("Priority", "No");
  TestReportAddMiscInfo("Safety relevant", "No");
  
  AddRequirementInfo("Requirement under test", "ARCH_SW_DIA_0001; ARCH_SW_DIA_0054; ARCH_SW_DIA_0055; ARCH_SW_NVP_0001");
  AddRequirementInfo("ARCH_SW_DIA_0001", "Service 0x22 will be implemented for DID 0340.");
  AddRequirementInfo("ARCH_SW_DIA_0054", "Service should be available in Default and extended session.");
  AddRequirementInfo("ARCH_SW_DIA_0055", "NVP_BLOCK_ID_BELT_ASSEMBLY_MANUF_DATE_AND_SN_RamBlockData will be read.");
  AddRequirementInfo("ARCH_SW_NVP_0001", "NVP_BLOCK_ID_BELT_ASSEMBLY_MANUF_DATE_AND_SN block shall be configured. Parameter NVP_au8AssemblySerialNumber should have 28 bytes and should store belt assembly Serial Number written at ANG (default values 0xFF).");


  ////***************************************************************************************

  testCaseComment("Preconditions");
  testStep("STEP", "Bench Initialization");
  
  testStep("", "Delete all breakpoint from debugger.");
  debugger_deleteAllBreakpoints();

  testStep("", "Reset the debugger.");
  debugger_reset();
    
  testStep("", "Run the debugger.");
  debugger_run();
  
  RunPreTs();
  ////====================================================

  testStep("STEP", "Enter default or extended session.");
  EnterDiagnosticSession("default");
  
  testStep("STEP", "Set breakpoint in function *DIA_runDid0340_UniqueSeatbeltSerialNumberRead*.");
  debugger_setRelativeFunctionBpAtLine("DIA_runDid0340_UniqueSeatbeltSerialNumberRead", "4");
  debugger_run();
 
  testCaseComment("Action: ARCH_SW_DIA_0001, ARCH_SW_DIA_0054");
  testStep("STEP", "Send diag request for 22 0340 and wait for timeout error --> Timeout reached.");
  SendDiagnosticRequestNegativeResponse(dSeatBeltSerialNumberReadRequest, dSeatBeltSerialNumberReadResponse, TRUE);

  testStep("STEP", "Check if breakpoint from function DIA_runDid0340_UniqueSeatbeltSerialNumberRead was reached. --> BP was reached.");
  debugger_waitUntilBPisReached("5000");
  ExpectedTestResult(debugger_result, IS_CPU_STOP_AT_BP_SUCCESFUL, "BP is reached.");
  
  testCaseComment("Action: ARCH_SW_DIA_0055, ARCH_SW_NVP_0001");
  testStep("STEP", "Read first byte of NVP_BLOCK_ID_BELT_ASSEMBLY_MANUF_DATE_AND_SN_RamBlockData --> Variable read.");
  debugger_readVariable("uint8", "NVP_BLOCK_ID_BELT_ASSEMBLY_MANUF_DATE_AND_SN_RamBlockData,,app.elf", "0");
  ExpectedTestResult(debugger_result, "NVP_BLOCK_ID_BELT_ASSEMBLY_MANUF_DATE_AND_SN_RamBlockData", "Variable is read");

  ////====================================================
  testCaseComment("Postcondition");
  testStep("STEP", "Return ECU to default values");
  RunPostTs();
}

testcase SW_Int_DIA_runDidFD2F_EcuLocationRead_01()
{
  //***********************************Test report header*********************************
  testReportAddMiscInfoBlock("AUTOLIV ELECTRONICS document");
  TestReportAddMiscInfo("Nightly test", "No");
  TestReportAddMiscInfo("Test type", "Requirement-Based test");
  TestReportAddMiscInfo("Regression Test", "Yes");
  TestReportAddMiscInfo("Fault injection method used", "No");
  TestReportAddMiscInfo("Resource usage evaluation", "No");
  TestReportAddMiscInfo("Priority", "No");
  TestReportAddMiscInfo("Safety relevant", "No");
  
  AddRequirementInfo("Requirement under test", "ARCH_SW_DIA_0002; ARCH_SW_DIA_0062; ARCH_SW_DIA_0063");
  AddRequirementInfo("ARCH_SW_DIA_0002", "Service 0x22 will be implemented for DID FD2F.");
  AddRequirementInfo("ARCH_SW_DIA_0062", "Service should be available in Default and extended session.");
  AddRequirementInfo("ARCH_SW_DIA_0063", "NVP_BLOCK_ID_ECU_LOCATION_RamBlockData will be read.");
  AddRequirementInfo("ARCH_SW_NVP_0000", "NVP_BLOCK_ID_ECU_LOCATION block shall be configured");


  //***************************************************************************************

  testCaseComment("Preconditions");
  testStep("STEP", "Bench Initialization");
  
  testStep("", "Delete all breakpoint from debugger.");
  debugger_deleteAllBreakpoints();

  testStep("", "Reset the debugger.");
  debugger_reset();
    
  testStep("", "Run the debugger.");
  debugger_run();
  
  RunPreTs();
  //====================================================

  testStep("STEP", "Enter default or extended session.");
  EnterDiagnosticSession("default");
  
  testStep("STEP", "Set breakpoint in function *DIA_runDidFD2F_EcuLocationRead*.");
  debugger_setRelativeFunctionBpAtLine("DIA_runDidFD2F_EcuLocationRead", "4");
  debugger_run();
 
  testCaseComment("Action: ARCH_SW_DIA_0002; ARCH_SW_DIA_0062;");
  testStep("STEP", "Send diag request for 22 FD2F and wait for timeout error --> Timeout reached.");
  SendDiagnosticRequestNegativeResponse(dReadECULocationRequest, dReadECULocationResponse, TRUE);

  testStep("STEP", "Check if breakpoint from function DIA_runDidFD2F_EcuLocationRead was reached. --> BP was reached.");
  debugger_waitUntilBPisReached("5000");
  ExpectedTestResult(debugger_result, IS_CPU_STOP_AT_BP_SUCCESFUL, "BP is reached.");
  
  testCaseComment("Action: ARCH_SW_DIA_0063; ARCH_SW_NVP_0000;");
  testStep("STEP", "Read first byte of NVP_BLOCK_ID_ECU_LOCATION_RamBlockData --> Variable read.");
  debugger_readVariable("uint8", "NVP_BLOCK_ID_ECU_LOCATION_RamBlockData,,app.elf", "0");
  ExpectedTestResult(debugger_result, "NVP_BLOCK_ID_ECU_LOCATION_RamBlockData", "Variable is read");

  debugger_run();
  //====================================================
  testCaseComment("Postcondition");
  testStep("STEP", "Return ECU to default values");
  RunPostTs();
}

testcase SW_Int_DIA_runDidFD10_CycleConfigurationRead_01()
{
  ////***********************************Test report header*********************************
  testReportAddMiscInfoBlock("AUTOLIV ELECTRONICS document");
  TestReportAddMiscInfo("Nightly test", "No");
  TestReportAddMiscInfo("Test type", "Requirement-Based test");
  TestReportAddMiscInfo("Regression Test", "Yes");
  TestReportAddMiscInfo("Fault injection method used", "No");
  TestReportAddMiscInfo("Resource usage evaluation", "No");
  TestReportAddMiscInfo("Priority", "No");
  TestReportAddMiscInfo("Safety relevant", "No");
  
  AddRequirementInfo("Requirement under test", "ARCH_SW_DIA_0004; ARCH_SW_DIA_0064; ARCH_SW_DIA_0065; ARCH_SW_DIA_0065");
  AddRequirementInfo("ARCH_SW_DIA_0004", "Service 0x22 will be implemented for DID FD10.");
  AddRequirementInfo("ARCH_SW_DIA_0064", "Service should be available in Development Session.");
  AddRequirementInfo("ARCH_SW_DIA_0065", "NVP_BLOCK_ID_CYCLE0-34_RamBlockData will be read.");
  AddRequirementInfo("ARCH_SW_NVP_0006", "NVP_BLOCK_ID_CYCLE_0  34 blocks should be configured. Parameter NVP_au8BeltProfilesDefinitions should have 420 bytes.");
  AddRequirementInfo("ARCH_SW_NVP_0017", "NVP_BLOCK_ID_CYCLE_5 shall be configured with max duration of 5 sec and no following cycle.");

  ////***************************************************************************************

  testCaseComment("Preconditions");
  testStep("STEP", "Bench Initialization");
  
  testStep("", "Delete all breakpoint from debugger.");
  debugger_deleteAllBreakpoints();

  testStep("", "Reset the debugger.");
  debugger_reset();
    
  testStep("", "Run the debugger.");
  debugger_run();
  
  RunPreTs();
  ////====================================================

  testStep("STEP", "Set breakpoint in function *DIA_runDidFD10_CycleConfigurationRead*.");
  debugger_setRelativeFunctionBpAtLine("DIA_runDidFD10_CycleConfigurationRead", "4");
  debugger_run();
 
  testCaseComment("Action: ARCH_SW_DIA_0004, ARCH_SW_DIA_0064");
  testStep("STEP", "Send diag request for 22 FD10 and wait for timeout error --> Timeout received.");
  SendDiagnosticRequestNegativeResponse(dCycleConfigReadRequest, dCycleConfigReadResponse, TRUE);

  testStep("STEP", "Check if breakpoint from function DIA_runDidFD10_CycleConfigurationRead was reached. --> BP was reached.");
  debugger_waitUntilBPisReached("5000");
  ExpectedTestResult(debugger_result, IS_CPU_STOP_AT_BP_SUCCESFUL, "BP is reached.");
  
  testCaseComment("Action: ARCH_SW_DIA_0065, ARCH_SW_NVP_0006");
  testStep("STEP", "Read first byte of NVP_BLOCK_ID_CYCLE_0_RamBlockData --> Byte was read.");
  debugger_readVariable("uint8", "NVP_BLOCK_ID_CYCLE_0_RamBlockData,,app.elf", "0");
  ExpectedTestResult(debugger_result, "NVP_BLOCK_ID_CYCLE_0_RamBlockData", "Byte was read");

  ////====================================================
  testCaseComment("Postcondition");
  testStep("STEP", "Return ECU to default values");
  RunPostTs();
}

testcase SW_Int_DIA_runDidFD10_CycleConfigurationRead_02()
{
  ////***********************************Test report header*********************************
  testReportAddMiscInfoBlock("AUTOLIV ELECTRONICS document");
  TestReportAddMiscInfo("Nightly test", "No");
  TestReportAddMiscInfo("Test type", "Requirement-Based test");
  TestReportAddMiscInfo("Regression Test", "Yes");
  TestReportAddMiscInfo("Fault injection method used", "No");
  TestReportAddMiscInfo("Resource usage evaluation", "No");
  TestReportAddMiscInfo("Priority", "No");
  TestReportAddMiscInfo("Safety relevant", "No");
  
  AddRequirementInfo("Requirement under test", "ARCH_SW_DIA_0004; ARCH_SW_DIA_0082");
  AddRequirementInfo("ARCH_SW_DIA_0004", "Service 0x22 will be implemented for DID FD10.");
  AddRequirementInfo("ARCH_SW_DIA_0082", "Data Length shall be 420 bytes long.");
  ////***************************************************************************************

  testCaseComment("Preconditions");
  testStep("STEP", "Bench Initialization");
  
  testStep("", "Delete all breakpoint from debugger.");
  debugger_deleteAllBreakpoints();

  testStep("", "Reset the debugger.");
  debugger_reset();
    
  testStep("", "Run the debugger.");
  debugger_run();
  
  RunPreTs();
  ////====================================================
  
  testCaseComment("Action: ARCH_SW_DIA_0004, ARCH_SW_DIA_0082");
  testStep("STEP", "Send diag request for 22 FD 10, and evaluate response --> Request sent.");
  SendDiagnosticRequest(dCycleConfigReadRequest, dCycleConfigReadResponse);

  testStep("STEP", "Evaluate response data lenght. --> response data lenght is 420.");
  EvaluateDiagResponseSize(dCycleConfigReadRequest, 420);

  ////====================================================
  testCaseComment("Postcondition");
  testStep("STEP", "Return ECU to default values");
  RunPostTs();
}

testcase SW_Int_DIA_runDidFD2A_StepsLibraryRead_01()
{
  ////***********************************Test report header*********************************
  testReportAddMiscInfoBlock("AUTOLIV ELECTRONICS document");
  TestReportAddMiscInfo("Nightly test", "No");
  TestReportAddMiscInfo("Test type", "Requirement-Based test");
  TestReportAddMiscInfo("Regression Test", "Yes");
  TestReportAddMiscInfo("Fault injection method used", "No");
  TestReportAddMiscInfo("Resource usage evaluation", "No");
  TestReportAddMiscInfo("Priority", "No");
  TestReportAddMiscInfo("Safety relevant", "No");
  
  AddRequirementInfo("Requirement under test", "ARCH_SW_DIA_0006; ARCH_SW_DIA_0068; ARCH_SW_DIA_0069; ARCH_SW_NVP_0007");
  AddRequirementInfo("ARCH_SW_DIA_0006", "Service 0x22 will be implemented for DID FD2A.");
  AddRequirementInfo("ARCH_SW_DIA_0068", "Service should be available in Development Session.");
  AddRequirementInfo("ARCH_SW_DIA_0069", "NVP_BLOCK_ID_STEPS0 - 144_RamBlockData will be read.");
  AddRequirementInfo("ARCH_SW_NVP_0007", "NVP_BLOCK_ID_STEP_0  144 blocks should be configured. Parameter NVP_au8StepsDefinitions should have 1160 bytes.");
  AddRequirementInfo("ARCH_SW_NVP_0020", "Steps parameters shall be configured like :  Byte 4 = velocity control order type if 0x02 = Velocity control order type enabled 0x03 = Velocity control and PWM backup 0x05 = velocity control and current backup 0x06 = velocity control and Volatge backup  Byte 7 = velocity control order value [120 grades/s l 1200 grades/s] ");

  ////***************************************************************************************

  testCaseComment("Preconditions");
  testStep("STEP", "Bench Initialization");
  
  testStep("", "Delete all breakpoint from debugger.");
  debugger_deleteAllBreakpoints();

  testStep("", "Reset the debugger.");
  debugger_reset();
    
  testStep("", "Run the debugger.");
  debugger_run();
  
  RunPreTs();
  ////====================================================

  testStep("STEP", "Set breakpoint in function *DIA_runDidFD2A_StepsLibraryRead*.");
  debugger_setRelativeFunctionBpAtLine("DIA_runDidFD2A_StepsLibraryRead", "4");
  debugger_run();
 
  testCaseComment("Action: ARCH_SW_DIA_0006; ARCH_SW_DIA_0068; ARCH_SW_DIA_0083");
  testStep("STEP", "Send diag request for 22 FD2A and wait for timeout error --> Timeout received.");
  SendDiagnosticRequestNegativeResponse(dReadStepsConfigRequest, dReadStepsConfigResponse, TRUE);

  testStep("STEP", "Check if breakpoint from function DIA_runDidFD2A_StepsLibraryRead was reached. --> BP was reached.");
  debugger_waitUntilBPisReached("5000");
  ExpectedTestResult(debugger_result, IS_CPU_STOP_AT_BP_SUCCESFUL, "BP is reached.");
 
  testCaseComment("Action: ARCH_SW_NVP_0007; ARCH_SW_DIA_0069");
  testStep("STEP", "Read first byte of NVP_BLOCK_ID_STEP_0_RamBlockData --> Byte was read.");
  debugger_readVariable("uint8", "NVP_BLOCK_ID_STEP_0_RamBlockData,,app.elf", "0");
  ExpectedTestResult(debugger_result, "NVP_BLOCK_ID_STEP_0_RamBlockData", "Byte was read");

  ////====================================================
  testCaseComment("Postcondition");
  testStep("STEP", "Return ECU to default values");
  RunPostTs();
}

testcase SW_Int_DIA_runDidFD2A_StepsLibraryRead_02()
{
  ////***********************************Test report header*********************************
  testReportAddMiscInfoBlock("AUTOLIV ELECTRONICS document");
  TestReportAddMiscInfo("Nightly test", "No");
  TestReportAddMiscInfo("Test type", "Requirement-Based test");
  TestReportAddMiscInfo("Regression Test", "Yes");
  TestReportAddMiscInfo("Fault injection method used", "No");
  TestReportAddMiscInfo("Resource usage evaluation", "No");
  TestReportAddMiscInfo("Priority", "No");
  TestReportAddMiscInfo("Safety relevant", "No");
  
  AddRequirementInfo("Requirement under test", "ARCH_SW_DIA_0006; ARCH_SW_DIA_0083");
  AddRequirementInfo("ARCH_SW_DIA_0006", "Service 0x22 will be implemented for DID FD2A.");
  AddRequirementInfo("ARCH_SW_DIA_0082", "Data Length shall be 1160 bytes long.");
  ////***************************************************************************************

  testCaseComment("Preconditions");
  testStep("STEP", "Bench Initialization");
  
  testStep("", "Delete all breakpoint from debugger.");
  debugger_deleteAllBreakpoints();

  testStep("", "Reset the debugger.");
  debugger_reset();
    
  testStep("", "Run the debugger.");
  debugger_run();
  
  RunPreTs();
  ////====================================================
  
  testCaseComment("Action: ARCH_SW_DIA_0006; ARCH_SW_DIA_0083");
  testStep("STEP", "Send diag request for 22 FD2A, and evaluate response --> Request sent.");
  SendDiagnosticRequest(dReadStepsConfigRequest, dReadStepsConfigResponse);

  testStep("STEP", "Evaluate response data lenght. --> response data lenght is 1160.");
  EvaluateDiagResponseSize(dReadStepsConfigRequest, 1160);

  ////====================================================
  testCaseComment("Postcondition");
  testStep("STEP", "Return ECU to default values");
  RunPostTs();
}

testcase SW_Int_DIA_runDid0244_PreSafeCounterRead_01()
{
  diagRequest RBTMFL174.PRE_SAFE_Counter_read_Read dPresafeCounterReadRequest;
  diagResponse RBTMFL174.PRE_SAFE_Counter_read_Read dPresafeCounterReadResponse;
  //***********************************Test report header*********************************
  testReportAddMiscInfoBlock("AUTOLIV ELECTRONICS document");
  TestReportAddMiscInfo("Nightly test", "No");
  TestReportAddMiscInfo("Test type", "Requirement-Based test");
  TestReportAddMiscInfo("Regression Test", "Yes");
  TestReportAddMiscInfo("Fault injection method used", "No");
  TestReportAddMiscInfo("Resource usage evaluation", "No");
  TestReportAddMiscInfo("Priority", "No");
  TestReportAddMiscInfo("Safety relevant", "No");
  
  AddRequirementInfo("Requirement under test", "ARCH_SW_DIA_0011; ARCH_SW_DIA_0076; ARCH_SW_DIA_0077; ARCH_SW_DIA_0366; ARCH_SW_DIA_0367");
  AddRequirementInfo("ARCH_SW_DIA_0011", "Service 0x22 will be implemented for DID 0244.");
  AddRequirementInfo("ARCH_SW_DIA_0076", "Service should be available in Default, Extended and Development Session.");
  AddRequirementInfo("ARCH_SW_DIA_0077", "NVP_BLOCK_ID_EXECUTION_COUNTERS_RamBlockData will be read..");
  AddRequirementInfo("ARCH_SW_DIA_0366", "Bytes 0-1 shall return the request counter value.");
  AddRequirementInfo("ARCH_SW_DIA_0367", "Bytes 6-7 shall return the Max Force counter value.");
  AddRequirementInfo("ARCH_SW_NVP_0004", "NVP_BLOCK_ID_EXECUTION_COUNTERS block shall be configured. Parameter NVP_au32ExecutedCycleCounters should have 20 bytes and should store executed cycle counter. ");
  //***************************************************************************************

  testCaseComment("Preconditions");
  testStep("STEP", "Bench Initialization");
  
  testStep("", "Delete all breakpoint from debugger.");
  debugger_deleteAllBreakpoints();

  testStep("", "Reset the debugger.");
  debugger_reset();
    
  testStep("", "Run the debugger.");
  debugger_run();
  
  RunPreTs();
  //====================================================

  testStep("STEP", "Set breakpoint in function *DIA_runDid0244_PreSafeCounterRead*.");
  debugger_setRelativeFunctionBpAtLine("DIA_runDid0244_PreSafeCounterRead", "4");
  debugger_run();
 
  testCaseComment("Action: ARCH_SW_DIA_0011; ARCH_SW_DIA_0076; ARCH_SW_DIA_0077; ARCH_SW_DIA_0366; ARCH_SW_DIA_0367; ARCH_SW_NVP_0004");
  testStep("STEP", "Send diag request for 22 0244 and wait for timeout error --> Timeout received.");
  SendDiagnosticRequestNegativeResponse(dPresafeCounterReadRequest, dPresafeCounterReadResponse, TRUE);

  testStep("STEP", "Check if breakpoint from function DIA_runDid0244_PreSafeCounterRead was reached. --> BP was reached.");
  debugger_waitUntilBPisReached("5000");
  ExpectedTestResult(debugger_result, IS_CPU_STOP_AT_BP_SUCCESFUL, "BP is reached.");
  
  testStep("STEP", "Read first byte of NVP_BLOCK_ID_EXECUTION_COUNTERS_RamBlockData --> Byte was read.");
  debugger_readVariable("uint8", "NVP_BLOCK_ID_EXECUTION_COUNTERS_RamBlockData,,app.elf", "0");
  ExpectedTestResult(debugger_result, "NVP_BLOCK_ID_EXECUTION_COUNTERS_RamBlockData", "Byte was read");
  
  testStep("STEP", "Read last byte of NVP_BLOCK_ID_EXECUTION_COUNTERS_RamBlockData --> Byte was read.");
  debugger_readVariable("uint8", "NVP_BLOCK_ID_EXECUTION_COUNTERS_RamBlockData,,app.elf", "7");
  ExpectedTestResult(debugger_result, "NVP_BLOCK_ID_EXECUTION_COUNTERS_RamBlockData", "Byte was read");
  
  //====================================================
  testCaseComment("Postcondition");
  testStep("STEP", "Return ECU to default values");
  RunPostTs();
}

testcase SW_Int_DIA_runDid0244_PreSafeCounterReadDataLength_01()
{
  ////***********************************Test report header*********************************
  testReportAddMiscInfoBlock("AUTOLIV ELECTRONICS document");
  TestReportAddMiscInfo("Nightly test", "No");
  TestReportAddMiscInfo("Test type", "Requirement-Based test");
  TestReportAddMiscInfo("Regression Test", "Yes");
  TestReportAddMiscInfo("Fault injection method used", "No");
  TestReportAddMiscInfo("Resource usage evaluation", "No");
  TestReportAddMiscInfo("Priority", "No");
  TestReportAddMiscInfo("Safety relevant", "No");
  
  AddRequirementInfo("Requirement under test", "ARCH_SW_DIA_0011; ARCH_SW_DIA_0078");
  AddRequirementInfo("ARCH_SW_DIA_0011", "Service 0x22 will be implemented for DID 0244.");
  AddRequirementInfo("ARCH_SW_DIA_0078", "Response data length shall be 8 bytes long.");

  ////***************************************************************************************

  testCaseComment("Preconditions");
  testStep("STEP", "Bench Initialization");
  
  testStep("", "Delete all breakpoint from debugger.");
  debugger_deleteAllBreakpoints();

  testStep("", "Reset the debugger.");
  debugger_reset();
    
  testStep("", "Run the debugger.");
  debugger_run();
  
  RunPreTs();
  ////====================================================

  testCaseComment("Action: ARCH_SW_DIA_0011; ARCH_SW_DIA_0078");
  testStep("STEP", "Send diag request for 22 0244, and evaluate response --> Request sent.");
  SendDiagnosticRequest(dPresafeCounterReadRequest, dPresafeCounterReadResponse);

  testStep("STEP", "Evaluate response data lenght. --> Response data size is 8 bytes.");
  EvaluateDiagResponseSize(dPresafeCounterReadRequest, 8);

  ////====================================================
  testCaseComment("Postcondition");
  testStep("STEP", "Return ECU to default values");
  RunPostTs();
}

testcase SW_Int_DIA_runDid0243_BSRCounterRead_01()
{
  diagRequest RBTMFL174.BSR_Counter_read_Read dBSRCounterReadRequest;
  diagResponse RBTMFL174.BSR_Counter_read_Read dBSRCounterReadResponse;
  //***********************************Test report header*********************************
  testReportAddMiscInfoBlock("AUTOLIV ELECTRONICS document");
  TestReportAddMiscInfo("Nightly test", "No");
  TestReportAddMiscInfo("Test type", "Requirement-Based test");
  TestReportAddMiscInfo("Regression Test", "Yes");
  TestReportAddMiscInfo("Fault injection method used", "No");
  TestReportAddMiscInfo("Resource usage evaluation", "No");
  TestReportAddMiscInfo("Priority", "No");
  TestReportAddMiscInfo("Safety relevant", "No");
  
  AddRequirementInfo("Requirement under test", "ARCH_SW_DIA_0012; ARCH_SW_DIA_0079; ARCH_SW_DIA_0080; ARCH_SW_DIA_0081");
  AddRequirementInfo("ARCH_SW_DIA_0012", "Service 0x22 will be implemented for DID 0243.");
  AddRequirementInfo("ARCH_SW_DIA_0079", "Service should be available in Default, Extended and Development Session.");
  AddRequirementInfo("ARCH_SW_DIA_0080", "Response Data Length shall be 3 bytes.");
  AddRequirementInfo("ARCH_SW_DIA_0081", "NVP_BLOCK_ID_EXECUTION_COUNTERS_RamBlockData.ComfortCounter will be read.");
  
  //***************************************************************************************

  testCaseComment("Preconditions");
  testStep("STEP", "Bench Initialization");
  
  testStep("", "Delete all breakpoint from debugger.");
  debugger_deleteAllBreakpoints();

  testStep("", "Reset the debugger.");
  debugger_reset();
    
  testStep("", "Run the debugger.");
  debugger_run();
  
  RunPreTs();
  //====================================================

  testStep("STEP", "Set breakpoint in function *DIA_runDid0243_BSRCounterRead*.");
  debugger_setRelativeFunctionBpAtLine("DIA_runDid0243_BSRCounterRead", "4");
  debugger_run();
 
  testCaseComment("Action: ARCH_SW_DIA_0012; ARCH_SW_DIA_0079; ARCH_SW_DIA_0081");
  testStep("STEP", "Send diag request for 22 0243 and wait for timeout error --> Timeout received.");
  SendDiagnosticRequestNegativeResponse(dBSRCounterReadRequest, dBSRCounterReadResponse, TRUE);

  testStep("STEP", "Check if breakpoint from function DIA_runDid0243_BSRCounterRead was reached. --> BP was reached.");
  debugger_waitUntilBPisReached("5000");
  ExpectedTestResult(debugger_result, IS_CPU_STOP_AT_BP_SUCCESFUL, "BP is reached.");
  
  testStep("STEP", "Read first byte of NVP_BLOCK_ID_EXECUTION_COUNTERS_RamBlockData --> Byte was read.");
  debugger_readVariable("uint8", "NVP_BLOCK_ID_EXECUTION_COUNTERS_RamBlockData,,app.elf", "0");
  ExpectedTestResult(debugger_result, "NVP_BLOCK_ID_EXECUTION_COUNTERS_RamBlockData", "Byte was read");
  
  //====================================================
  testCaseComment("Postcondition");
  testStep("STEP", "Return ECU to default values");
  RunPostTs();
}

testcase SW_Int_DIA_runDid0243_BSRCounterRead_02()
{
  ////***********************************Test report header*********************************
  testReportAddMiscInfoBlock("AUTOLIV ELECTRONICS document");
  TestReportAddMiscInfo("Nightly test", "No");
  TestReportAddMiscInfo("Test type", "Requirement-Based test");
  TestReportAddMiscInfo("Regression Test", "Yes");
  TestReportAddMiscInfo("Fault injection method used", "No");
  TestReportAddMiscInfo("Resource usage evaluation", "No");
  TestReportAddMiscInfo("Priority", "No");
  TestReportAddMiscInfo("Safety relevant", "No");
  
  AddRequirementInfo("Requirement under test", "ARCH_SW_DIA_0012; ARCH_SW_DIA_0080");
  AddRequirementInfo("ARCH_SW_DIA_0012", "Service 0x22 will be implemented for DID 0243.");
  AddRequirementInfo("ARCH_SW_DIA_0080", "Response Data Length shall be 3 bytes.");

  ////***************************************************************************************

  testCaseComment("Preconditions");
  testStep("STEP", "Bench Initialization");
  
  testStep("", "Delete all breakpoint from debugger.");
  debugger_deleteAllBreakpoints();

  testStep("", "Reset the debugger.");
  debugger_reset();
    
  testStep("", "Run the debugger.");
  debugger_run();
  
  RunPreTs();
  ////====================================================

  testCaseComment("Action: ARCH_SW_DIA_0012; ARCH_SW_DIA_0080");
  testStep("STEP", "Send diag request for 22 0243, and evaluate response --> Request sent.");
  SendDiagnosticRequest(dBSRCounterReadRequest, dBSRCounterReadResponse);

  testStep("STEP", "Evaluate response data lenght. --> Response data size is 3 bytes.");
  EvaluateDiagResponseSize(dBSRCounterReadRequest, 3);

  ////====================================================
  testCaseComment("Postcondition");
  testStep("STEP", "Return ECU to default values");
  RunPostTs();
}

testcase SW_Int_DIA_DataServices_PreSafe_Cycles_Level_1_8_CombinedSignal_ReadData_01()
{
  
  diagRequest RBTMFL174.PreSafe_Cycles_Level_1_8_Read dPresafeCycleReadRequest;
  diagResponse RBTMFL174.PreSafe_Cycles_Level_1_8_Read dPresafeCycleReadResponse;

  //***********************************Test report header*********************************
  testReportAddMiscInfoBlock("AUTOLIV ELECTRONICS document");
  TestReportAddMiscInfo("Nightly test", "No");
  TestReportAddMiscInfo("Test type", "Requirement-Based test");
  TestReportAddMiscInfo("Regression Test", "Yes");
  TestReportAddMiscInfo("Fault injection method used", "No");
  TestReportAddMiscInfo("Resource usage evaluation", "No");
  TestReportAddMiscInfo("Priority", "No");
  TestReportAddMiscInfo("Safety relevant", "No");
  
  AddRequirementInfo("Requirement under test", "ARCH_SW_DIA_0021; ARCH_SW_DIA_0086; ARCH_SW_DIA_0087; ARCH_SW_DIA_0202;");
  AddRequirementInfo("ARCH_SW_DIA_0021", "Service 0x22 will be implemented for DID 0300.");
  AddRequirementInfo("ARCH_SW_DIA_0086", "Service shall be available in Default, Extended and Development session.");
  AddRequirementInfo("ARCH_SW_DIA_0202", "Data contained in NVP_BLOCK_ID_CYCLE_0 to NVP_BLOCK_ID_CYCLE_25 and NVP_BLOCK_ID_STEP_0 to NVP_BLOCK_ID_STEP_91 shall be returned.");

  
  //***************************************************************************************

  testCaseComment("Preconditions");
  testStep("STEP", "Bench Initialization");
  
  testStep("", "Delete all breakpoint from debugger.");
  debugger_deleteAllBreakpoints();

  testStep("", "Reset the debugger.");
  debugger_reset();
    
  testStep("", "Run the debugger.");
  debugger_run();
  
  RunPreTs();
  //====================================================

  testStep("STEP", "Set breakpoint in function *DataServices_PreSafe_Cycles_Level_1_8_CombinedSignal_ReadData*.");
  debugger_setRelativeFunctionBpAtLine("DataServices_PreSafe_Cycles_Level_1_8_CombinedSignal_ReadData", "0");
  debugger_run();
 
  testCaseComment("Action: ARCH_SW_DIA_0021; ARCH_SW_DIA_0086; ARCH_SW_DIA_0087; ARCH_SW_DIA_0202;");
  testStep("STEP", "Send diag request for 22 0300 and wait for timeout error --> Timeout received.");
  SendDiagnosticRequestNegativeResponse(dPresafeCycleReadRequest, dPresafeCycleReadResponse, TRUE);

  testStep("STEP", "Check if breakpoint from function DataServices_PreSafe_Cycles_Level_1_8_CombinedSignal_ReadData was reached. --> BP was reached.");
  debugger_waitUntilBPisReached("5000");
  ExpectedTestResult(debugger_result, IS_CPU_STOP_AT_BP_SUCCESFUL, "BP is reached.");
  
  testStep("STEP", "Read first byte of NVP_BLOCK_ID_CYCLE_0_RamBlockData --> Byte was read.");
  debugger_readVariable("uint8", "NVP_BLOCK_ID_CYCLE_0_RamBlockData,,app.elf", "0");
  ExpectedTestResult(debugger_result, "NVP_BLOCK_ID_CYCLE_0_RamBlockData", "Byte was read");
  
  debugger_run();
  //====================================================
  testCaseComment("Postcondition");
  testStep("STEP", "Return ECU to default values");
  RunPostTs();
}

testcase SW_Int_DIA_DataServices_PreSafe_Cycles_Level_1_8_CombinedSignal_ReadData_02()
{
  ////***********************************Test report header*********************************
  testReportAddMiscInfoBlock("AUTOLIV ELECTRONICS document");
  TestReportAddMiscInfo("Nightly test", "No");
  TestReportAddMiscInfo("Test type", "Requirement-Based test");
  TestReportAddMiscInfo("Regression Test", "Yes");
  TestReportAddMiscInfo("Fault injection method used", "No");
  TestReportAddMiscInfo("Resource usage evaluation", "No");
  TestReportAddMiscInfo("Priority", "No");
  TestReportAddMiscInfo("Safety relevant", "No");
  
  AddRequirementInfo("Requirement under test", "ARCH_SW_DIA_0087");
  AddRequirementInfo("ARCH_SW_DIA_0087", "Response data shall be 1048 bytes long.");

  ////***************************************************************************************

  testCaseComment("Preconditions");
  testStep("STEP", "Bench Initialization");
  
  testStep("", "Delete all breakpoint from debugger.");
  debugger_deleteAllBreakpoints();

  testStep("", "Reset the debugger.");
  debugger_reset();
    
  testStep("", "Run the debugger.");
  debugger_run();
  
  RunPreTs();
  ////====================================================

  testCaseComment("Action: ARCH_SW_DIA_0012; ARCH_SW_DIA_0080");
  testStep("STEP", "Send diag request for 22 0300, and evaluate response --> Request sent.");
  SendDiagnosticRequest(dPresafeCycleReadRequest, dPresafeCycleReadResponse);

  testStep("STEP", "Evaluate response data lenght. --> Response data size is 1048 bytes.");
  EvaluateDiagResponseSize(dPresafeCycleReadRequest, 1048);

  ////====================================================
  testCaseComment("Postcondition");
  testStep("STEP", "Return ECU to default values");
  RunPostTs();
}

testcase SW_Int_DIA_DataServices_Release_Cycles_BSR_and_PreSafe_CombinedSignal_ReadData_01()
{
  ////***********************************Test report header*********************************
  testReportAddMiscInfoBlock("AUTOLIV ELECTRONICS document");
  TestReportAddMiscInfo("Nightly test", "No");
  TestReportAddMiscInfo("Test type", "Requirement-Based test");
  TestReportAddMiscInfo("Regression Test", "Yes");
  TestReportAddMiscInfo("Fault injection method used", "No");
  TestReportAddMiscInfo("Resource usage evaluation", "No");
  TestReportAddMiscInfo("Priority", "No");
  TestReportAddMiscInfo("Safety relevant", "No");
  
  AddRequirementInfo("Requirement under test", "ARCH_SW_DIA_0023; ARCH_SW_DIA_0090; ARCH_SW_DIA_0092;");
  AddRequirementInfo("ARCH_SW_DIA_0023", "Service 0x22 will be implemented for DID 0301.");
  AddRequirementInfo("ARCH_SW_DIA_0090", "Service shall be available in Default, Extended and Development session.");
  AddRequirementInfo("ARCH_SW_DIA_0092", "Data contained in NVP_BLOCK_ID_CYCLE_29 to NVP_BLOCK_ID_CYCLE_32 and NVP_BLOCK_ID_STEP_92 to NVP_BLOCK_ID_STEP_115 shall be returned.");
  
  ////***************************************************************************************

  testCaseComment("Preconditions");
  testStep("STEP", "Bench Initialization");
  
  testStep("", "Delete all breakpoint from debugger.");
  debugger_deleteAllBreakpoints();

  testStep("", "Reset the debugger.");
  debugger_reset();
    
  testStep("", "Run the debugger.");
  debugger_run();
  
  RunPreTs();
  ////====================================================

  testStep("STEP", "Set breakpoint in function *DataServices_Release_Cycles_BSR_and_PreSafe_CombinedSignal_ReadData*.");
  debugger_setRelativeFunctionBpAtLine("DataServices_Release_Cycles_BSR_and_PreSafe_CombinedSignal_ReadData", "4");
  debugger_run();
 
  testCaseComment("Action: ARCH_SW_DIA_0023; ARCH_SW_DIA_0090; ARCH_SW_DIA_0091; ARCH_SW_DIA_0092;");
  testStep("STEP", "Send diag request for 22 0301 and wait for timeout error --> Timeout received.");
  SendDiagnosticRequestNegativeResponse(dReleaseCyclesBSRandPresafeReadRequest, dReleaseCyclesBSRandPresafeReadResponse, TRUE);

  testStep("STEP", "Check if breakpoint from function DataServices_Release_Cycles_BSR_and_PreSafe_CombinedSignal_ReadData. --> BP was reached.");
  debugger_waitUntilBPisReached("5000");
  ExpectedTestResult(debugger_result, IS_CPU_STOP_AT_BP_SUCCESFUL, "BP is reached.");
  
  testStep("STEP", "Read 29th byte of NVP_BLOCK_ID_CYCLE_0_RamBlockData --> Byte was read.");
  debugger_readVariable("uint8", "NVP_BLOCK_ID_CYCLE_0_RamBlockData,,app.elf", "29");
  ExpectedTestResult(debugger_result, "NVP_BLOCK_ID_CYCLE_0_RamBlockData", "Byte was read");
  
  ////====================================================
  testCaseComment("Postcondition");
  testStep("STEP", "Return ECU to default values");
  RunPostTs();
}

testcase SW_Int_DIA_DataServices_Release_Cycles_BSR_and_PreSafe_CombinedSignal_ReadData_02()
{
  ////***********************************Test report header*********************************
  testReportAddMiscInfoBlock("AUTOLIV ELECTRONICS document");
  TestReportAddMiscInfo("Nightly test", "No");
  TestReportAddMiscInfo("Test type", "Requirement-Based test");
  TestReportAddMiscInfo("Regression Test", "Yes");
  TestReportAddMiscInfo("Fault injection method used", "No");
  TestReportAddMiscInfo("Resource usage evaluation", "No");
  TestReportAddMiscInfo("Priority", "No");
  TestReportAddMiscInfo("Safety relevant", "No");
  
  AddRequirementInfo("Requirement under test", "ARCH_SW_DIA_0091");
  AddRequirementInfo("ARCH_SW_DIA_0091", "Response data shall be 144 bytes long.");

  ////***************************************************************************************

  testCaseComment("Preconditions");
  testStep("STEP", "Bench Initialization");
  
  testStep("", "Delete all breakpoint from debugger.");
  debugger_deleteAllBreakpoints();

  testStep("", "Reset the debugger.");
  debugger_reset();
    
  testStep("", "Run the debugger.");
  debugger_run();
  
  RunPreTs();
  ////====================================================

  testCaseComment("Action: ARCH_SW_DIA_0091;");
  testStep("STEP", "Send diag request for 22 0301, and evaluate response --> Request sent.");
  SendDiagnosticRequest(dReleaseCyclesBSRandPresafeReadRequest, dReleaseCyclesBSRandPresafeReadResponse);

  testStep("STEP", "Evaluate response data lenght. --> Response data size is 144 bytes.");
  EvaluateDiagResponseSize(dReleaseCyclesBSRandPresafeReadRequest, 144);

  ////====================================================
  testCaseComment("Postcondition");
  testStep("STEP", "Return ECU to default values");
  RunPostTs();
}

testcase SW_Int_DIA_DataServices_Tensioning_Cycle_BSR_CombinedSignal_ReadData_01()
{
  ////***********************************Test report header*********************************
  testReportAddMiscInfoBlock("AUTOLIV ELECTRONICS document");
  TestReportAddMiscInfo("Nightly test", "No");
  TestReportAddMiscInfo("Test type", "Requirement-Based test");
  TestReportAddMiscInfo("Regression Test", "Yes");
  TestReportAddMiscInfo("Fault injection method used", "No");
  TestReportAddMiscInfo("Resource usage evaluation", "No");
  TestReportAddMiscInfo("Priority", "No");
  TestReportAddMiscInfo("Safety relevant", "No");
  
  AddRequirementInfo("Requirement under test", "ARCH_SW_DIA_0025; ARCH_SW_DIA_0096; ARCH_SW_DIA_0097; ARCH_SW_DIA_0098;");
  AddRequirementInfo("ARCH_SW_DIA_0025", "Service 0x22 will be implemented for DID 0302.");
  AddRequirementInfo("ARCH_SW_DIA_0096", "Service shall be available in Default, Extended and Development session.");
  AddRequirementInfo("ARCH_SW_DIA_0097", "Response data shall be 228 bytes long.");
  AddRequirementInfo("ARCH_SW_DIA_0098", "Data contained in NVP_BLOCK_ID_CYCLE_26 to NVP_BLOCK_ID_CYCLE_28 and NVP_BLOCK_ID_STEP_116 to NVP_BLOCK_ID_STEP_144 shall be returned.");

  
  ////***************************************************************************************

  testCaseComment("Preconditions");
  testStep("STEP", "Bench Initialization");
  
  testStep("", "Delete all breakpoint from debugger.");
  debugger_deleteAllBreakpoints();

  testStep("", "Reset the debugger.");
  debugger_reset();
    
  testStep("", "Run the debugger.");
  debugger_run();
  
  RunPreTs();
  ////====================================================

  testStep("STEP", "Set breakpoint in function *DataServices_Tensioning_Cycle_BSR_CombinedSignal_ReadData*.");
  debugger_setRelativeFunctionBpAtLine("DataServices_Tensioning_Cycle_BSR_CombinedSignal_ReadData", "0");
  debugger_run();
 
  testCaseComment("Action: ARCH_SW_DIA_0025; ARCH_SW_DIA_0096; ARCH_SW_DIA_0097; ARCH_SW_DIA_0098;");
  testStep("STEP", "Send diag request for 22 0302 and wait for timeout error --> Timeout received.");
  SendDiagnosticRequestNegativeResponse(dTensioningCycleBSRReadRequest, dTensioningCycleBSRReadResponse, TRUE);

  testStep("STEP", "Check if breakpoint from function DataServices_Tensioning_Cycle_BSR_CombinedSignal_ReadData. --> BP was reached.");
  debugger_waitUntilBPisReached("5000");
  ExpectedTestResult(debugger_result, IS_CPU_STOP_AT_BP_SUCCESFUL, "BP is reached.");
  
  testStep("STEP", "Read 26th byte of NVP_BLOCK_ID_CYCLE_0_RamBlockData --> Byte was read.");
  debugger_readVariable("uint8", "NVP_BLOCK_ID_CYCLE_0_RamBlockData,,app.elf", "26");
  ExpectedTestResult(debugger_result, "NVP_BLOCK_ID_CYCLE_0_RamBlockData", "Byte was read");
  
  ////====================================================
  testCaseComment("Postcondition");
  testStep("STEP", "Return ECU to default values");
  RunPostTs();
}

testcase SW_Int_DIA_DataServices_Tensioning_Cycle_BSR_CombinedSignal_ReadData_02()
{
  ////***********************************Test report header*********************************
  testReportAddMiscInfoBlock("AUTOLIV ELECTRONICS document");
  TestReportAddMiscInfo("Nightly test", "No");
  TestReportAddMiscInfo("Test type", "Requirement-Based test");
  TestReportAddMiscInfo("Regression Test", "Yes");
  TestReportAddMiscInfo("Fault injection method used", "No");
  TestReportAddMiscInfo("Resource usage evaluation", "No");
  TestReportAddMiscInfo("Priority", "No");
  TestReportAddMiscInfo("Safety relevant", "No");
  
  AddRequirementInfo("Requirement under test", "ARCH_SW_DIA_0097");
  AddRequirementInfo("ARCH_SW_DIA_0097", "Response data shall be 228 bytes long.");

  ////***************************************************************************************

  testCaseComment("Preconditions");
  testStep("STEP", "Bench Initialization");
  
  testStep("", "Delete all breakpoint from debugger.");
  debugger_deleteAllBreakpoints();

  testStep("", "Reset the debugger.");
  debugger_reset();
    
  testStep("", "Run the debugger.");
  debugger_run();
  
  RunPreTs();
  ////====================================================

  testCaseComment("Action: ARCH_SW_DIA_0097;");
  testStep("STEP", "Send diag request for 22 0302, and evaluate response --> Request sent.");
  SendDiagnosticRequest(dTensioningCycleBSRReadRequest, dTensioningCycleBSRReadResponse);

  testStep("STEP", "Evaluate response data lenght. --> Response data size is 228 bytes.");
  EvaluateDiagResponseSize(dTensioningCycleBSRReadRequest, 228);

  ////====================================================
  testCaseComment("Postcondition");
  testStep("STEP", "Return ECU to default values");
  RunPostTs();
}

testcase SW_Int_DIA_DataServices_Vehicle_Equipment_Read_Equipment_1_ReadData_01()
{
  ////***********************************Test report header*********************************
  testReportAddMiscInfoBlock("AUTOLIV ELECTRONICS document");
  TestReportAddMiscInfo("Nightly test", "No");
  TestReportAddMiscInfo("Test type", "Requirement-Based test");
  TestReportAddMiscInfo("Regression Test", "Yes");
  TestReportAddMiscInfo("Fault injection method used", "No");
  TestReportAddMiscInfo("Resource usage evaluation", "No");
  TestReportAddMiscInfo("Priority", "No");
  TestReportAddMiscInfo("Safety relevant", "No");
  
  AddRequirementInfo("Requirement under test", "ARCH_SW_DIA_0027; ARCH_SW_DIA_0102; ARCH_SW_DIA_0103; ARCH_SW_DIA_0104; ARCH_SW_DIA_0368; ARCH_SW_DIA_0045");
  AddRequirementInfo("ARCH_SW_DIA_0027", "Service 0x22 will be implemented for DID 0310.");
  AddRequirementInfo("ARCH_SW_DIA_0102", "Service shall be available in Default, Extended and Development session.");
  AddRequirementInfo("ARCH_SW_DIA_0103", "Response data shall be 1 byte long.");
  AddRequirementInfo("ARCH_SW_DIA_0104", "Data returned shall represent Equipment 1 stored in Rte_Ct_MBBL_SsaAppl_Coding_VehicleEquipment.Equipment1");
  AddRequirementInfo("ARCH_SW_DIA_0368", "Byte 0 shall represent Equipment 1.");
  AddRequirementInfo("ARCH_SW_DIA_0045", "There shall be 2 reserved bytes located between Equipment 6 and Uberspannungsabbruchschwelle for response of DID 0310.");


  ////***************************************************************************************

  testCaseComment("Preconditions");
  testStep("STEP", "Bench Initialization");
  
  testStep("", "Delete all breakpoint from debugger.");
  debugger_deleteAllBreakpoints();

  testStep("", "Reset the debugger.");
  debugger_reset();
    
  testStep("", "Run the debugger.");
  debugger_run();
  
  RunPreTs();
  ////====================================================

  testStep("STEP", "Set breakpoint in function *DataServices_Vehicle_Equipment_Read_Equipment_1_ReadData*.");
  debugger_setRelativeFunctionBpAtLine("DataServices_Vehicle_Equipment_Read_Equipment_1_ReadData", "18");
  debugger_run();
 
  testCaseComment("Action: ARCH_SW_DIA_0027; ARCH_SW_DIA_0102; ARCH_SW_DIA_0103; ARCH_SW_DIA_0104; ARCH_SW_DIA_0368; ARCH_SW_DIA_0045");
  testStep("STEP", "Send diag request for 22 03 10 and wait for timeout error --> Timeout received.");
  SendDiagnosticRequestNegativeResponse(dVehicleEquipmentReadRequest, dVehicleEquipmentReadResponse, TRUE);

  testStep("STEP", "Check if breakpoint from function DataServices_Vehicle_Equipment_Read_Equipment_1_ReadData. --> BP was reached.");
  debugger_waitUntilBPisReached("5000");
  ExpectedTestResult(debugger_result, IS_CPU_STOP_AT_BP_SUCCESFUL, "BP is reached.");
  
  testStep("STEP", "Read Equipment 1 byte of Rte_Ct_MBBL_SsaAppl_Coding_VehicleEquipment --> Byte was read.");
  debugger_readVariable("uint8", "Rte_Ct_MBBL_SsaAppl_Coding_VehicleEquipment,,app.elf", "0");
  ExpectedTestResult(debugger_result, "Rte_Ct_MBBL_SsaAppl_Coding_VehicleEquipment", "Byte was read");
  
  ////====================================================
  testCaseComment("Postcondition");
  testStep("STEP", "Return ECU to default values");
  RunPostTs();
}

testcase SW_Int_DIA_DataServices_Vehicle_Equipment_Read_Equipment_2_ReadData_01()
{
  ////***********************************Test report header*********************************
  testReportAddMiscInfoBlock("AUTOLIV ELECTRONICS document");
  TestReportAddMiscInfo("Nightly test", "No");
  TestReportAddMiscInfo("Test type", "Requirement-Based test");
  TestReportAddMiscInfo("Regression Test", "Yes");
  TestReportAddMiscInfo("Fault injection method used", "No");
  TestReportAddMiscInfo("Resource usage evaluation", "No");
  TestReportAddMiscInfo("Priority", "No");
  TestReportAddMiscInfo("Safety relevant", "No");
  
  AddRequirementInfo("Requirement under test", "ARCH_SW_DIA_0027; ARCH_SW_DIA_0108; ARCH_SW_DIA_0109");
  AddRequirementInfo("ARCH_SW_DIA_0027", "Service 0x22 will be implemented for DID 0310.");
  AddRequirementInfo("ARCH_SW_DIA_0108", "Response data shall be 1 byte long.");
  AddRequirementInfo("ARCH_SW_DIA_0103", "Data returned shall represent Equipment 2 stored in Rte_Ct_MBBL_SsaAppl_Coding_VehicleEquipment.Equipment2");
  ////***************************************************************************************

  testCaseComment("Preconditions");
  testStep("STEP", "Bench Initialization");
  
  testStep("", "Delete all breakpoint from debugger.");
  debugger_deleteAllBreakpoints();

  testStep("", "Reset the debugger.");
  debugger_reset();
    
  testStep("", "Run the debugger.");
  debugger_run();
  
  RunPreTs();
  ////====================================================

  testStep("STEP", "Set breakpoint in function *DataServices_Vehicle_Equipment_Read_Equipment_2_ReadData*.");
  debugger_setRelativeFunctionBpAtLine("DataServices_Vehicle_Equipment_Read_Equipment_2_ReadData", "18");
  debugger_run();
 
  testCaseComment("Action: ARCH_SW_DIA_0027; ARCH_SW_DIA_0108; ARCH_SW_DIA_0109;");
  testStep("STEP", "Send diag request for 22 03 10 and wait for timeout error --> Timeout received.");
  SendDiagnosticRequestNegativeResponse(dVehicleEquipmentReadRequest, dVehicleEquipmentReadResponse, TRUE);

  testStep("STEP", "Check if breakpoint from function DataServices_Vehicle_Equipment_Read_Equipment_2_ReadData. --> BP was reached.");
  debugger_waitUntilBPisReached("5000");
  ExpectedTestResult(debugger_result, IS_CPU_STOP_AT_BP_SUCCESFUL, "BP is reached.");
  
  testStep("STEP", "Read Equipment 2 byte of Rte_Ct_MBBL_SsaAppl_Coding_VehicleEquipment --> Byte was read.");
  debugger_readVariable("uint8", "Rte_Ct_MBBL_SsaAppl_Coding_VehicleEquipment,,app.elf", "1");
  ExpectedTestResult(debugger_result, "Rte_Ct_MBBL_SsaAppl_Coding_VehicleEquipment", "Byte was read");
  
  ////====================================================
  testCaseComment("Postcondition");
  testStep("STEP", "Return ECU to default values");
  RunPostTs();
}

testcase SW_Int_DIA_DataServices_Vehicle_Equipment_Read_Equipment_3_ReadData_01()
{
  ////***********************************Test report header*********************************
  testReportAddMiscInfoBlock("AUTOLIV ELECTRONICS document");
  TestReportAddMiscInfo("Nightly test", "No");
  TestReportAddMiscInfo("Test type", "Requirement-Based test");
  TestReportAddMiscInfo("Regression Test", "Yes");
  TestReportAddMiscInfo("Fault injection method used", "No");
  TestReportAddMiscInfo("Resource usage evaluation", "No");
  TestReportAddMiscInfo("Priority", "No");
  TestReportAddMiscInfo("Safety relevant", "No");
  
  AddRequirementInfo("Requirement under test", "ARCH_SW_DIA_0027; ARCH_SW_DIA_0112; ARCH_SW_DIA_0113");
  AddRequirementInfo("ARCH_SW_DIA_0027", "Service 0x22 will be implemented for DID 0310.");
  AddRequirementInfo("ARCH_SW_DIA_0112", "Response data shall be 1 byte long.");
  AddRequirementInfo("ARCH_SW_DIA_0113", "Data returned shall represent Equipment 3 stored in Rte_Ct_MBBL_SsaAppl_Coding_VehicleEquipment.Equipment3");
  ////***************************************************************************************

  testCaseComment("Preconditions");
  testStep("STEP", "Bench Initialization");
  
  testStep("", "Delete all breakpoint from debugger.");
  debugger_deleteAllBreakpoints();

  testStep("", "Reset the debugger.");
  debugger_reset();
    
  testStep("", "Run the debugger.");
  debugger_run();
  
  RunPreTs();
  ////====================================================

  testStep("STEP", "Set breakpoint in function *DataServices_Vehicle_Equipment_Read_Equipment_3_ReadData*.");
  debugger_setRelativeFunctionBpAtLine("DataServices_Vehicle_Equipment_Read_Equipment_3_ReadData", "18");
  debugger_run();
 
  testCaseComment("Action: ARCH_SW_DIA_0027; ARCH_SW_DIA_0112; ARCH_SW_DIA_0113;");
  testStep("STEP", "Send diag request for 22 03 10 and wait for timeout error --> Timeout received.");
  SendDiagnosticRequestNegativeResponse(dVehicleEquipmentReadRequest, dVehicleEquipmentReadResponse, TRUE);

  testStep("STEP", "Check if breakpoint from function DataServices_Vehicle_Equipment_Read_Equipment_3_ReadData. --> BP was reached.");
  debugger_waitUntilBPisReached("5000");
  ExpectedTestResult(debugger_result, IS_CPU_STOP_AT_BP_SUCCESFUL, "BP is reached.");
  
  testStep("STEP", "Read Equipment 3 byte of Rte_Ct_MBBL_SsaAppl_Coding_VehicleEquipment --> Byte was read.");
  debugger_readVariable("uint8", "Rte_Ct_MBBL_SsaAppl_Coding_VehicleEquipment,,app.elf", "2");
  ExpectedTestResult(debugger_result, "Rte_Ct_MBBL_SsaAppl_Coding_VehicleEquipment", "Byte was read");
  
  ////====================================================
  testCaseComment("Postcondition");
  testStep("STEP", "Return ECU to default values");
  RunPostTs();
}

testcase SW_Int_DIA_DataServices_Vehicle_Equipment_Read_Equipment_4_ReadData_01()
{
  ////***********************************Test report header*********************************
  testReportAddMiscInfoBlock("AUTOLIV ELECTRONICS document");
  TestReportAddMiscInfo("Nightly test", "No");
  TestReportAddMiscInfo("Test type", "Requirement-Based test");
  TestReportAddMiscInfo("Regression Test", "Yes");
  TestReportAddMiscInfo("Fault injection method used", "No");
  TestReportAddMiscInfo("Resource usage evaluation", "No");
  TestReportAddMiscInfo("Priority", "No");
  TestReportAddMiscInfo("Safety relevant", "No");
  
  AddRequirementInfo("Requirement under test", "ARCH_SW_DIA_0027; ARCH_SW_DIA_0116; ARCH_SW_DIA_0117");
  AddRequirementInfo("ARCH_SW_DIA_0027", "Service 0x22 will be implemented for DID 0310.");
  AddRequirementInfo("ARCH_SW_DIA_0116", "Response data shall be 1 byte long.");
  AddRequirementInfo("ARCH_SW_DIA_0117", "Data returned shall represent Equipment 4 stored in Rte_Ct_MBBL_SsaAppl_Coding_VehicleEquipment.Equipment4");
  ////***************************************************************************************

  testCaseComment("Preconditions");
  testStep("STEP", "Bench Initialization");
  
  testStep("", "Delete all breakpoint from debugger.");
  debugger_deleteAllBreakpoints();

  testStep("", "Reset the debugger.");
  debugger_reset();
    
  testStep("", "Run the debugger.");
  debugger_run();
  
  RunPreTs();
  ////====================================================

  testStep("STEP", "Set breakpoint in function *DataServices_Vehicle_Equipment_Read_Equipment_4_ReadData*.");
  debugger_setRelativeFunctionBpAtLine("DataServices_Vehicle_Equipment_Read_Equipment_4_ReadData", "18");
  debugger_run();
 
  testCaseComment("Action: ARCH_SW_DIA_0027; ARCH_SW_DIA_0116; ARCH_SW_DIA_0117;");
  testStep("STEP", "Send diag request for 22 03 10 and wait for timeout error --> Timeout received.");
  SendDiagnosticRequestNegativeResponse(dVehicleEquipmentReadRequest, dVehicleEquipmentReadResponse, TRUE);

  testStep("STEP", "Check if breakpoint from function DataServices_Vehicle_Equipment_Read_Equipment_4_ReadData. --> BP was reached.");
  debugger_waitUntilBPisReached("5000");
  ExpectedTestResult(debugger_result, IS_CPU_STOP_AT_BP_SUCCESFUL, "BP is reached.");
  
  testStep("STEP", "Read Equipment 4 byte of Rte_Ct_MBBL_SsaAppl_Coding_VehicleEquipment --> Byte was read.");
  debugger_readVariable("uint8", "Rte_Ct_MBBL_SsaAppl_Coding_VehicleEquipment,,app.elf", "3");
  ExpectedTestResult(debugger_result, "Rte_Ct_MBBL_SsaAppl_Coding_VehicleEquipment", "Byte was read");
  
  ////====================================================
  testCaseComment("Postcondition");
  testStep("STEP", "Return ECU to default values");
  RunPostTs();
}

testcase SW_Int_DIA_DataServices_Vehicle_Equipment_Read_Equipment_5_ReadData_01()
{
  ////***********************************Test report header*********************************
  testReportAddMiscInfoBlock("AUTOLIV ELECTRONICS document");
  TestReportAddMiscInfo("Nightly test", "No");
  TestReportAddMiscInfo("Test type", "Requirement-Based test");
  TestReportAddMiscInfo("Regression Test", "Yes");
  TestReportAddMiscInfo("Fault injection method used", "No");
  TestReportAddMiscInfo("Resource usage evaluation", "No");
  TestReportAddMiscInfo("Priority", "No");
  TestReportAddMiscInfo("Safety relevant", "No");
  
  AddRequirementInfo("Requirement under test", "ARCH_SW_DIA_0027; ARCH_SW_DIA_0120; ARCH_SW_DIA_0121");
  AddRequirementInfo("ARCH_SW_DIA_0027", "Service 0x22 will be implemented for DID 0310.");
  AddRequirementInfo("ARCH_SW_DIA_0120", "Response data shall be 1 byte long.");
  AddRequirementInfo("ARCH_SW_DIA_0121", "Data returned shall represent Equipment 55 stored in Rte_Ct_MBBL_SsaAppl_Coding_VehicleEquipment.Equipment5");
  ////***************************************************************************************

  testCaseComment("Preconditions");
  testStep("STEP", "Bench Initialization");
  
  testStep("", "Delete all breakpoint from debugger.");
  debugger_deleteAllBreakpoints();

  testStep("", "Reset the debugger.");
  debugger_reset();
    
  testStep("", "Run the debugger.");
  debugger_run();
  
  RunPreTs();
  ////====================================================

  testStep("STEP", "Set breakpoint in function *DataServices_Vehicle_Equipment_Read_Equipment_5_ReadData*.");
  debugger_setRelativeFunctionBpAtLine("DataServices_Vehicle_Equipment_Read_Equipment_5_ReadData", "0");
  debugger_run();
 
  testCaseComment("Action: ARCH_SW_DIA_0027; ARCH_SW_DIA_0120; ARCH_SW_DIA_0121;");
  testStep("STEP", "Send diag request for 22 03 10 and wait for timeout error --> Timeout received.");
  SendDiagnosticRequestNegativeResponse(dVehicleEquipmentReadRequest, dVehicleEquipmentReadResponse, TRUE);

  testStep("STEP", "Check if breakpoint from function DataServices_Vehicle_Equipment_Read_Equipment_5_ReadData. --> BP was reached.");
  debugger_waitUntilBPisReached("5000");
  ExpectedTestResult(debugger_result, IS_CPU_STOP_AT_BP_SUCCESFUL, "BP is reached.");
  
  testStep("STEP", "Read Equipment 5 byte of Rte_Ct_MBBL_SsaAppl_Coding_VehicleEquipment --> Byte was read.");
  debugger_readVariable("uint8", "Rte_Ct_MBBL_SsaAppl_Coding_VehicleEquipment,,app.elf", "4");
  ExpectedTestResult(debugger_result, "Rte_Ct_MBBL_SsaAppl_Coding_VehicleEquipment", "Byte was read");
  
  ////====================================================
  testCaseComment("Postcondition");
  testStep("STEP", "Return ECU to default values");
  RunPostTs();
}

testcase SW_Int_DIA_DataServices_Vehicle_Equipment_Read_Equipment_6_ReadData_01()
{
  ////***********************************Test report header*********************************
  testReportAddMiscInfoBlock("AUTOLIV ELECTRONICS document");
  TestReportAddMiscInfo("Nightly test", "No");
  TestReportAddMiscInfo("Test type", "Requirement-Based test");
  TestReportAddMiscInfo("Regression Test", "Yes");
  TestReportAddMiscInfo("Fault injection method used", "No");
  TestReportAddMiscInfo("Resource usage evaluation", "No");
  TestReportAddMiscInfo("Priority", "No");
  TestReportAddMiscInfo("Safety relevant", "No");
  
  AddRequirementInfo("Requirement under test", "ARCH_SW_DIA_0027; ARCH_SW_DIA_0124; ARCH_SW_DIA_0125");
  AddRequirementInfo("ARCH_SW_DIA_0027", "Service 0x22 will be implemented for DID 0310.");
  AddRequirementInfo("ARCH_SW_DIA_0124", "Response data shall be 1 byte long.");
  AddRequirementInfo("ARCH_SW_DIA_0125", "Data returned shall represent Equipment 6 stored in Rte_Ct_MBBL_SsaAppl_Coding_VehicleEquipment.Equipment6");
  ////***************************************************************************************

  testCaseComment("Preconditions");
  testStep("STEP", "Bench Initialization");
  
  testStep("", "Delete all breakpoint from debugger.");
  debugger_deleteAllBreakpoints();

  testStep("", "Reset the debugger.");
  debugger_reset();
    
  testStep("", "Run the debugger.");
  debugger_run();
  
  RunPreTs();
  ////====================================================

  testStep("STEP", "Set breakpoint in function *DataServices_Vehicle_Equipment_Read_Equipment_6_ReadData*.");
  debugger_setRelativeFunctionBpAtLine("DataServices_Vehicle_Equipment_Read_Equipment_6_ReadData", "0");
  debugger_run();
 
  testCaseComment("Action: ARCH_SW_DIA_0027; ARCH_SW_DIA_0124; ARCH_SW_DIA_0125;");
  testStep("STEP", "Send diag request for 22 03 10 and wait for timeout error --> Timeout received.");
  SendDiagnosticRequestNegativeResponse(dVehicleEquipmentReadRequest, dVehicleEquipmentReadResponse, TRUE);

  testStep("STEP", "Check if breakpoint from function DataServices_Vehicle_Equipment_Read_Equipment_6_ReadData. --> BP was reached.");
  debugger_waitUntilBPisReached("5000");
  ExpectedTestResult(debugger_result, IS_CPU_STOP_AT_BP_SUCCESFUL, "BP is reached.");
  
  testStep("STEP", "Read Equipment 6 byte of Rte_Ct_MBBL_SsaAppl_Coding_VehicleEquipment --> Byte was read.");
  debugger_readVariable("uint8", "Rte_Ct_MBBL_SsaAppl_Coding_VehicleEquipment,,app.elf", "5");
  ExpectedTestResult(debugger_result, "Rte_Ct_MBBL_SsaAppl_Coding_VehicleEquipment", "Byte was read");
  
  ////====================================================
  testCaseComment("Postcondition");
  testStep("STEP", "Return ECU to default values");
  RunPostTs();
}

testcase SW_Int_DIA_DataServices_Vehicle_Equipment_Read_Uberspannungsabbruchschwelle_ReadData_01()
{
  diagRequest RBTMFL174.Vehicle_Equipment_Read dVehicleEquipmentReadRequest;
  diagResponse RBTMFL174.Vehicle_Equipment_Read dVehicleEquipmentReadResponse;
  //***********************************Test report header*********************************
  testReportAddMiscInfoBlock("AUTOLIV ELECTRONICS document");
  TestReportAddMiscInfo("Nightly test", "No");
  TestReportAddMiscInfo("Test type", "Requirement-Based test");
  TestReportAddMiscInfo("Regression Test", "Yes");
  TestReportAddMiscInfo("Fault injection method used", "No");
  TestReportAddMiscInfo("Resource usage evaluation", "No");
  TestReportAddMiscInfo("Priority", "No");
  TestReportAddMiscInfo("Safety relevant", "No");
  
  AddRequirementInfo("Requirement under test", "ARCH_SW_DIA_0027; ARCH_SW_DIA_0128; ARCH_SW_DIA_0129");
  AddRequirementInfo("ARCH_SW_DIA_0027", "Service 0x22 will be implemented for DID 0310.");
  AddRequirementInfo("ARCH_SW_DIA_0128", "Response data shall be 2 bytes long.");
  AddRequirementInfo("ARCH_SW_DIA_0129", "Data returned shall represent Uberspannungsabbruchschwelle stored in Rte_Ct_MBBL_SsaAppl_Coding_VehicleEquipment. Uberspannungsabbruchschwelle.");
  //***************************************************************************************

  testCaseComment("Preconditions");
  testStep("STEP", "Bench Initialization");
  
  testStep("", "Delete all breakpoint from debugger.");
  debugger_deleteAllBreakpoints();

  testStep("", "Reset the debugger.");
  debugger_reset();
    
  testStep("", "Run the debugger.");
  debugger_run();
  
  RunPreTs();
  //====================================================
  
  testStep("STEP", "Set breakpoint in function *DataServices_Vehicle_Equipment_Read_Uberspannungsabbruchschwelle_ReadData*.");
  debugger_setRelativeFunctionBpAtLine("DataServices_Vehicle_Equipment_Read_Uberspannungsabbruchschwelle_ReadData", "18");
  debugger_run();
 
  testCaseComment("Action: ARCH_SW_DIA_0027; ARCH_SW_DIA_0128; ARCH_SW_DIA_0129");
  testStep("STEP", "Send diag request for 22 03 10 and wait for timeout error --> Timeout received.");
  SendDiagnosticRequestNegativeResponse(dVehicleEquipmentReadRequest, dVehicleEquipmentReadResponse, TRUE);

  testStep("STEP", "Check if breakpoint from function DataServices_Vehicle_Equipment_Read_Uberspannungsabbruchschwelle_ReadData. --> BP was reached.");
  debugger_waitUntilBPisReached("5000");
  ExpectedTestResult(debugger_result, IS_CPU_STOP_AT_BP_SUCCESFUL, "BP is reached.");
  
  testStep("STEP", "Read byte 7 byte of Rte_Ct_MBBL_SsaAppl_Coding_VehicleEquipment --> Byte was read.");
  debugger_readVariable("uint8", "Rte_Ct_MBBL_SsaAppl_Coding_VehicleEquipment,,app.elf", "6");
  ExpectedTestResult(debugger_result, "Rte_Ct_MBBL_SsaAppl_Coding_VehicleEquipment", "Byte was read");
  
  //====================================================
  testCaseComment("Postcondition");
  testStep("STEP", "Return ECU to default values");
  RunPostTs();
}

testcase SW_Int_DIA_DataServices_Vehicle_Equipment_Read_Uberspannungsbereichsschwelle_ReadData_01()
{
  ////***********************************Test report header*********************************
  testReportAddMiscInfoBlock("AUTOLIV ELECTRONICS document");
  TestReportAddMiscInfo("Nightly test", "No");
  TestReportAddMiscInfo("Test type", "Requirement-Based test");
  TestReportAddMiscInfo("Regression Test", "Yes");
  TestReportAddMiscInfo("Fault injection method used", "No");
  TestReportAddMiscInfo("Resource usage evaluation", "No");
  TestReportAddMiscInfo("Priority", "No");
  TestReportAddMiscInfo("Safety relevant", "No");
  
  AddRequirementInfo("Requirement under test", "ARCH_SW_DIA_0027; ARCH_SW_DIA_0132; ARCH_SW_DIA_0133");
  AddRequirementInfo("ARCH_SW_DIA_0027", "Service 0x22 will be implemented for DID 0310.");
  AddRequirementInfo("ARCH_SW_DIA_0132", "Response data shall be 2 bytes long.");
  AddRequirementInfo("ARCH_SW_DIA_0133", "Data returned shall represent Uberspannungsbereichsschwelle stored in Rte_Ct_MBBL_SsaAppl_Coding_VehicleEquipment. Uberspannungsbereichsschwelle.");
  ////***************************************************************************************

  testCaseComment("Preconditions");
  testStep("STEP", "Bench Initialization");
  
  testStep("", "Delete all breakpoint from debugger.");
  debugger_deleteAllBreakpoints();

  testStep("", "Reset the debugger.");
  debugger_reset();
    
  testStep("", "Run the debugger.");
  debugger_run();
  
  RunPreTs();
  ////====================================================

  testStep("STEP", "Set breakpoint in function *DataServices_Vehicle_Equipment_Read_Uberspannungsbereichsschwelle_ReadData*.");
  debugger_setRelativeFunctionBpAtLine("DataServices_Vehicle_Equipment_Read_Uberspannungsbereichsschwelle_ReadData", "0");
  debugger_run();
 
  testCaseComment("Action: ARCH_SW_DIA_0027; ARCH_SW_DIA_0124; ARCH_SW_DIA_0125;");
  testStep("STEP", "Send diag request for 22 03 10 and wait for timeout error --> Timeout received.");
  SendDiagnosticRequestNegativeResponse(dVehicleEquipmentReadRequest, dVehicleEquipmentReadResponse, TRUE);

  testStep("STEP", "Check if breakpoint from function DataServices_Vehicle_Equipment_Read_Uberspannungsbereichsschwelle_ReadData. --> BP was reached.");
  debugger_waitUntilBPisReached("5000");
  ExpectedTestResult(debugger_result, IS_CPU_STOP_AT_BP_SUCCESFUL, "BP is reached.");
  
  testStep("STEP", "Read byte 9 of Rte_Ct_MBBL_SsaAppl_Coding_VehicleEquipment --> Byte was read.");
  debugger_readVariable("uint8", "Rte_Ct_MBBL_SsaAppl_Coding_VehicleEquipment,,app.elf", "8");
  ExpectedTestResult(debugger_result, "Rte_Ct_MBBL_SsaAppl_Coding_VehicleEquipment", "Byte was read");
  
  ////====================================================
  testCaseComment("Postcondition");
  testStep("STEP", "Return ECU to default values");
  RunPostTs();
}

testcase SW_Int_DIA_DataServices_Vehicle_Equipment_Read_Unterspannungsabbruchschwelle_ReadData_01()
{
  ////***********************************Test report header*********************************
  testReportAddMiscInfoBlock("AUTOLIV ELECTRONICS document");
  TestReportAddMiscInfo("Nightly test", "No");
  TestReportAddMiscInfo("Test type", "Requirement-Based test");
  TestReportAddMiscInfo("Regression Test", "Yes");
  TestReportAddMiscInfo("Fault injection method used", "No");
  TestReportAddMiscInfo("Resource usage evaluation", "No");
  TestReportAddMiscInfo("Priority", "No");
  TestReportAddMiscInfo("Safety relevant", "No");
  
  AddRequirementInfo("Requirement under test", "ARCH_SW_DIA_0027; ARCH_SW_DIA_0136; ARCH_SW_DIA_0137");
  AddRequirementInfo("ARCH_SW_DIA_0027", "Service 0x22 will be implemented for DID 0310.");
  AddRequirementInfo("ARCH_SW_DIA_0132", "Response data shall be 2 bytes long.");
  AddRequirementInfo("ARCH_SW_DIA_0133", "Data returned shall represent Überspannungsbereichsschwelle stored in Rte_Ct_MBBL_SsaAppl_Coding_VehicleEquipment. Überspannungsbereichsschwelle.");
  ////***************************************************************************************

  testCaseComment("Preconditions");
  testStep("STEP", "Bench Initialization");
  
  testStep("", "Delete all breakpoint from debugger.");
  debugger_deleteAllBreakpoints();

  testStep("", "Reset the debugger.");
  debugger_reset();
    
  testStep("", "Run the debugger.");
  debugger_run();
  
  RunPreTs();
  ////====================================================

  testStep("STEP", "Set breakpoint in function *DataServices_Vehicle_Equipment_Read_Unterspannungsabbruchschwelle_ReadData*.");
  debugger_setRelativeFunctionBpAtLine("DataServices_Vehicle_Equipment_Read_Unterspannungsabbruchschwelle_ReadData", "0");
  debugger_run();
 
  testCaseComment("Action: ARCH_SW_DIA_0027; ARCH_SW_DIA_0136; ARCH_SW_DIA_0137");
  testStep("STEP", "Send diag request for 22 03 10 and wait for timeout error --> Timeout received.");
  SendDiagnosticRequestNegativeResponse(dVehicleEquipmentReadRequest, dVehicleEquipmentReadResponse, TRUE);

  testStep("STEP", "Check if breakpoint from function DataServices_Vehicle_Equipment_Read_Unterspannungsabbruchschwelle_ReadData. --> BP was reached.");
  debugger_waitUntilBPisReached("5000");
  ExpectedTestResult(debugger_result, IS_CPU_STOP_AT_BP_SUCCESFUL, "BP is reached.");
  
  testStep("STEP", "Read 11th byte of Rte_Ct_MBBL_SsaAppl_Coding_VehicleEquipment --> Byte was read.");
  debugger_readVariable("uint8", "Rte_Ct_MBBL_SsaAppl_Coding_VehicleEquipment,,app.elf", "10");
  ExpectedTestResult(debugger_result, "Rte_Ct_MBBL_SsaAppl_Coding_VehicleEquipment", "Byte was read");
  
  ////====================================================
  testCaseComment("Postcondition");
  testStep("STEP", "Return ECU to default values");
  RunPostTs();
}

testcase SW_Int_DIA_DataServices_Vehicle_Equipment_Read_Unterspannungsbereichsschwelle_ReadData_01()
{
  ////***********************************Test report header*********************************
  testReportAddMiscInfoBlock("AUTOLIV ELECTRONICS document");
  TestReportAddMiscInfo("Nightly test", "No");
  TestReportAddMiscInfo("Test type", "Requirement-Based test");
  TestReportAddMiscInfo("Regression Test", "Yes");
  TestReportAddMiscInfo("Fault injection method used", "No");
  TestReportAddMiscInfo("Resource usage evaluation", "No");
  TestReportAddMiscInfo("Priority", "No");
  TestReportAddMiscInfo("Safety relevant", "No");
  
  AddRequirementInfo("Requirement under test", "ARCH_SW_DIA_0027; ARCH_SW_DIA_0140; ARCH_SW_DIA_0141");
  AddRequirementInfo("ARCH_SW_DIA_0027", "Service 0x22 will be implemented for DID 0310.");
  AddRequirementInfo("ARCH_SW_DIA_0140", "Response data shall be 2 bytes long.");
  AddRequirementInfo("ARCH_SW_DIA_0141", "Data returned shall represent Überspannungsabbruchschwelle stored in Rte_Ct_MBBL_SsaAppl_Coding_VehicleEquipment. Überspannungsabbruchschwelle");
  ////***************************************************************************************

  testCaseComment("Preconditions");
  testStep("STEP", "Bench Initialization");
  
  testStep("", "Delete all breakpoint from debugger.");
  debugger_deleteAllBreakpoints();

  testStep("", "Reset the debugger.");
  debugger_reset();
    
  testStep("", "Run the debugger.");
  debugger_run();
  
  RunPreTs();
  ////====================================================

  testStep("STEP", "Set breakpoint in function *DataServices_Vehicle_Equipment_Read_Unterspannungsbereichsschwelle_ReadData*.");
  debugger_setRelativeFunctionBpAtLine("DataServices_Vehicle_Equipment_Read_Unterspannungsbereichsschwelle_ReadData", "0");
  debugger_run();
 
  testCaseComment("Action: ARCH_SW_DIA_0027; ARCH_SW_DIA_0140; ARCH_SW_DIA_0141");
  testStep("STEP", "Send diag request for 22 03 10 and wait for timeout error --> Timeout received.");
  SendDiagnosticRequestNegativeResponse(dVehicleEquipmentReadRequest, dVehicleEquipmentReadResponse, TRUE);

  testStep("STEP", "Check if breakpoint from function DataServices_Vehicle_Equipment_Read_Unterspannungsabbruchschwelle_ReadData. --> BP was reached.");
  debugger_waitUntilBPisReached("5000");
  ExpectedTestResult(debugger_result, IS_CPU_STOP_AT_BP_SUCCESFUL, "BP is reached.");
  
  testStep("STEP", "Read 12th byte of Rte_Ct_MBBL_SsaAppl_Coding_VehicleEquipment --> Byte was read.");
  debugger_readVariable("uint8", "Rte_Ct_MBBL_SsaAppl_Coding_VehicleEquipment,,app.elf", "12");
  ExpectedTestResult(debugger_result, "Rte_Ct_MBBL_SsaAppl_Coding_VehicleEquipment", "Byte was read");
  
  ////====================================================
  testCaseComment("Postcondition");
  testStep("STEP", "Return ECU to default values");
  RunPostTs();
}

testcase SW_Int_DIA_DataServices_ZZZ_Vehicle_Equipment_Development_Read_Zykluszeit_Messtechnik_ReadData_01()
{
  ////***********************************Test report header*********************************
  testReportAddMiscInfoBlock("AUTOLIV ELECTRONICS document");
  TestReportAddMiscInfo("Nightly test", "No");
  TestReportAddMiscInfo("Test type", "Requirement-Based test");
  TestReportAddMiscInfo("Regression Test", "Yes");
  TestReportAddMiscInfo("Fault injection method used", "No");
  TestReportAddMiscInfo("Resource usage evaluation", "No");
  TestReportAddMiscInfo("Priority", "No");
  TestReportAddMiscInfo("Safety relevant", "No");
  
  AddRequirementInfo("Requirement under test", "ARCH_SW_DIA_0029; ARCH_SW_DIA_0150; ARCH_SW_DIA_0151");
  AddRequirementInfo("ARCH_SW_DIA_0029", "Service 0x22 will be implemented for DID 0311.");
  AddRequirementInfo("ARCH_SW_DIA_0150", "Response data shall be 1 byte long.");
  AddRequirementInfo("ARCH_SW_DIA_0151", "Data returned shall represent Zykluszeit Messtechnikstored in Rte_Ct_MBBL_SsaAppl_Coding_ZZZ_VehicleEquipment_Development. Zykluszeit_Messtechnik.");
  ////***************************************************************************************

  testCaseComment("Preconditions");
  testStep("STEP", "Bench Initialization");
  
  testStep("", "Delete all breakpoint from debugger.");
  debugger_deleteAllBreakpoints();

  testStep("", "Reset the debugger.");
  debugger_reset();
    
  testStep("", "Run the debugger.");
  debugger_run();
  
  RunPreTs();
  ////====================================================

  testStep("STEP", "Set breakpoint in function *DataServices_ZZZ_Vehicle_Equipment_Development_Read_Zykluszeit_Messtechnik_ReadData*.");
  debugger_setRelativeFunctionBpAtLine("DataServices_ZZZ_Vehicle_Equipment_Development_Read_Zykluszeit_Messtechnik_ReadData", "18");
  debugger_run();
 
  testCaseComment("Action: ARCH_SW_DIA_0029; ARCH_SW_DIA_0150; ARCH_SW_DIA_0151");
  testStep("STEP", "Send diag request for 22 0311 and wait for timeout error --> Timeout received.");
  SendDiagnosticRequestNegativeResponse(dZZZVehicleEquipmentReadRequest, dZZZVehicleEquipmentReadResponse, TRUE);

  testStep("STEP", "Check if breakpoint from function DataServices_ZZZ_Vehicle_Equipment_Development_Read_Zykluszeit_Messtechnik_ReadData was reached. --> BP was reached.");
  debugger_waitUntilBPisReached("5000");
  ExpectedTestResult(debugger_result, IS_CPU_STOP_AT_BP_SUCCESFUL, "BP is reached.");
  
  testStep("STEP", "Read last byte of Rte_Ct_MBBL_SsaAppl_Coding_ZZZ_VehicleEquipment_Development --> Byte was read.");
  debugger_readVariable("uint8", "Rte_Ct_MBBL_SsaAppl_Coding_ZZZ_VehicleEquipment_Development,,app.elf", "3");
  ExpectedTestResult(debugger_result, "Rte_Ct_MBBL_SsaAppl_Coding_ZZZ_VehicleEquipment_Development", "Byte was read");
  
  ////====================================================
  testCaseComment("Postcondition");
  testStep("STEP", "Return ECU to default values");
  RunPostTs();
}

testcase SW_Int_DIA_DataServices_ZZZ_Vehicle_Equipment_Development_Read_Bitfield_ReadData_01()
{
  ////***********************************Test report header*********************************
  testReportAddMiscInfoBlock("AUTOLIV ELECTRONICS document");
  TestReportAddMiscInfo("Nightly test", "No");
  TestReportAddMiscInfo("Test type", "Requirement-Based test");
  TestReportAddMiscInfo("Regression Test", "Yes");
  TestReportAddMiscInfo("Fault injection method used", "No");
  TestReportAddMiscInfo("Resource usage evaluation", "No");
  TestReportAddMiscInfo("Priority", "No");
  TestReportAddMiscInfo("Safety relevant", "No");
  
  AddRequirementInfo("Requirement under test", "ARCH_SW_DIA_0029; ARCH_SW_DIA_0144; ARCH_SW_DIA_0145; ARCH_SW_DIA_0146");
  AddRequirementInfo("ARCH_SW_DIA_0029", "Service 0x22 will be implemented for DID 0311.");
  AddRequirementInfo("ARCH_SW_DIA_0144", "Service shall be available in Default, Extended and Development session.");
  AddRequirementInfo("ARCH_SW_DIA_0145", "Response data shall be 2 bytes long.");
  AddRequirementInfo("ARCH_SW_DIA_0146", "Data returned shall represent Bitfield stored in Rte_Ct_MBBL_SsaAppl_Coding_ZZZ_VehicleEquipment_Development.Bitfield.");
  ////***************************************************************************************

  testCaseComment("Preconditions");
  testStep("STEP", "Bench Initialization");
  
  testStep("", "Delete all breakpoint from debugger.");
  debugger_deleteAllBreakpoints();

  testStep("", "Reset the debugger.");
  debugger_reset();
    
  testStep("", "Run the debugger.");
  debugger_run();
  
  RunPreTs();
  ////====================================================

  testStep("STEP", "Set breakpoint in function *DataServices_ZZZ_Vehicle_Equipment_Development_Read_Bitfield_ReadData*.");
  debugger_setRelativeFunctionBpAtLine("DataServices_ZZZ_Vehicle_Equipment_Development_Read_Bitfield_ReadData", "18");
  debugger_run();
 
  testCaseComment("Action: ARCH_SW_DIA_0029; ARCH_SW_DIA_0144; ARCH_SW_DIA_0145; ARCH_SW_DIA_0146");
  testStep("STEP", "Send diag request for 22 0311 and wait for timeout error --> Timeout received.");
  SendDiagnosticRequestNegativeResponse(dZZZVehicleEquipmentReadRequest, dZZZVehicleEquipmentReadResponse, TRUE);

  testStep("STEP", "Check if breakpoint from function DataServices_ZZZ_Vehicle_Equipment_Development_Read_Bitfield_ReadData was reached. --> BP was reached.");
  debugger_waitUntilBPisReached("5000");
  ExpectedTestResult(debugger_result, IS_CPU_STOP_AT_BP_SUCCESFUL, "BP is reached.");
  
  testStep("STEP", "Read first byte of Rte_Ct_MBBL_SsaAppl_Coding_ZZZ_VehicleEquipment_Development --> Byte was read.");
  debugger_readVariable("uint8", "Rte_Ct_MBBL_SsaAppl_Coding_ZZZ_VehicleEquipment_Development,,app.elf", "0");
  ExpectedTestResult(debugger_result, "Rte_Ct_MBBL_SsaAppl_Coding_ZZZ_VehicleEquipment_Development", "Byte was read");
  
  ////====================================================
  testCaseComment("Postcondition");
  testStep("STEP", "Return ECU to default values");
  RunPostTs();
}

testcase SW_Int_DIA_runDidFD08_ResetCauseManagementRead_01()
{
  ////***********************************Test report header*********************************
  testReportAddMiscInfoBlock("AUTOLIV ELECTRONICS document");
  TestReportAddMiscInfo("Nightly test", "No");
  TestReportAddMiscInfo("Test type", "Requirement-Based test");
  TestReportAddMiscInfo("Regression Test", "Yes");
  TestReportAddMiscInfo("Fault injection method used", "No");
  TestReportAddMiscInfo("Resource usage evaluation", "No");
  TestReportAddMiscInfo("Priority", "No");
  TestReportAddMiscInfo("Safety relevant", "No");
  
  AddRequirementInfo("Requirement under test", "ARCH_SW_DIA_0031; ARCH_SW_DIA_0154; ARCH_SW_DIA_0155; ARCH_SW_DIA_0156");
  AddRequirementInfo("ARCH_SW_DIA_0031", "Service 0x22 will be implemented for DID FD08.");
  AddRequirementInfo("ARCH_SW_DIA_0154", "Service shall be available in Development session.");
  AddRequirementInfo("ARCH_SW_DIA_0155", "Response data shall be 1 byte long.");
  AddRequirementInfo("ARCH_SW_DIA_0156", "Response shall return Last SW Reset Cause.");
  ////***************************************************************************************

  testCaseComment("Preconditions");
  testStep("STEP", "Bench Initialization");
  
  testStep("", "Delete all breakpoint from debugger.");
  debugger_deleteAllBreakpoints();

  testStep("", "Reset the debugger.");
  debugger_reset();
    
  testStep("", "Run the debugger.");
  debugger_run();
  
  RunPreTs();
  ////====================================================

  testStep("STEP", "Set breakpoint in function *DIA_runDidFD08_ResetCauseManagementRead*.");
  debugger_setRelativeFunctionBpAtLine("DIA_runDidFD08_ResetCauseManagementRead", "7");
  debugger_run();
 
  testStep("STEP", "Perform a Soft Reset.");
  ResetECU("soft");

  testStep("STEP", "Authenticate ECU and enter diagnostic session.");
    // Security authentification.
  AuthenticateECU(2); // Development_Enhanced
  
  // Enter development session.
  EnterDiagnosticSession("development");
  
  testCaseComment("Action: ARCH_SW_DIA_0031; ARCH_SW_DIA_0154; ARCH_SW_DIA_0155; ARCH_SW_DIA_0156");
  testStep("STEP", "Send diag request for 22 FD08 and wait for timeout error --> Timeout received.");
  SendDiagnosticRequestNegativeResponse(dResetCauseManagementRequest, dResetCauseManagementResponse, TRUE);

  testStep("STEP", "Check if breakpoint from function DIA_runDidFD08_ResetCauseManagementRead was reached. --> BP was reached.");
  debugger_waitUntilBPisReached("5000");
  ExpectedTestResult(debugger_result, IS_CPU_STOP_AT_BP_SUCCESFUL, "BP is reached.");
  
  testStep("STEP", "Evaluate *Data pointer --> Variable equal to 0x1.");
  debugger_readLocalVariable("*Data");
  ExpectedTestResult(debugger_result, "0x1", "Variable equal to 0x1");
  
  ////====================================================
  testCaseComment("Postcondition");
  testStep("STEP", "Return ECU to default values");
  RunPostTs();
}

testcase SW_Int_DIA_runDidFD09_LastWarmResetRead_LastDetectedWarmResetCause_01()
{
  //***********************************Test report header*********************************
  testReportAddMiscInfoBlock("AUTOLIV ELECTRONICS document");
  TestReportAddMiscInfo("Nightly test", "No");
  TestReportAddMiscInfo("Test type", "Requirement-Based test");
  TestReportAddMiscInfo("Regression Test", "Yes");
  TestReportAddMiscInfo("Fault injection method used", "No");
  TestReportAddMiscInfo("Resource usage evaluation", "No");
  TestReportAddMiscInfo("Priority", "No");
  TestReportAddMiscInfo("Safety relevant", "No");
  
  AddRequirementInfo("Requirement under test", "ARCH_SW_DIA_0032; ARCH_SW_DIA_0157; ARCH_SW_DIA_0158; ARCH_SW_DIA_0159, ARCH_SW_NVP_0011");
  AddRequirementInfo("ARCH_SW_DIA_0032", "Service 0x22 will be implemented for DID FD09.");
  AddRequirementInfo("ARCH_SW_DIA_0157", "Service shall be available in Development session.");
  AddRequirementInfo("ARCH_SW_DIA_0158", "Response data shall be 4 bytes long.");
  AddRequirementInfo("ARCH_SW_DIA_0159", "Response shall return Last Detected Warm Reset Cause.");
  AddRequirementInfo("ARCH_SW_NVP_0011", "NVP_BLOCK_ID_WARM_RESET shall be used to store last warm reset cause and counter.");

  
  //***************************************************************************************

  testCaseComment("Preconditions");
  testStep("STEP", "Bench Initialization");
  
  testStep("", "Delete all breakpoint from debugger.");
  debugger_deleteAllBreakpoints();

  testStep("", "Reset the debugger.");
  debugger_reset();
    
  testStep("", "Run the debugger.");
  debugger_run();
  
  RunPreTs();
  //====================================================

  EnterDiagnosticSession("development");
  testStep("STEP", "Set breakpoint in function *DIA_runDidFD09_LastWarmResetRead_LastDetectedWarmResetCause*.");
  debugger_setRelativeFunctionBpAtLine("DIA_runDidFD09_LastWarmResetRead_LastDetectedWarmResetCause", "6");
  debugger_run();
 
  testCaseComment("Action: ARCH_SW_DIA_0032; ARCH_SW_DIA_0157; ARCH_SW_DIA_0158; ARCH_SW_DIA_0159");
  testStep("STEP", "Send diag request for 22 FD09 and wait for timeout error --> Timeout received.");
  SendDiagnosticRequestNegativeResponse(dReadLastWarmResetParametersRequest, dReadLastWarmResetParametersResponse, TRUE);

  testWaitForTimeout(2000);
  testStep("STEP", "Check if breakpoint from function DIA_runDidFD09_LastWarmResetRead_LastDetectedWarmResetCause was reached. --> BP was reached.");
  debugger_waitUntilBPisReached("5000");
  ExpectedTestResult(debugger_result, IS_CPU_STOP_AT_BP_SUCCESFUL, "BP is reached.");
  
  testStep("STEP", "Read first byte of NVP_BLOCK_ID_WARM_RESET_RamBlockData --> Byte was read.");
  debugger_readVariable("uint8", "NVP_BLOCK_ID_EXECUTION_COUNTERS_RamBlockData,,app.elf", "0");
  ExpectedTestResult(debugger_result, "NVP_BLOCK_ID_EXECUTION_COUNTERS_RamBlockData", "Byte was read");
  
  debugger_run();
  //====================================================
  testCaseComment("Postcondition");
  testStep("STEP", "Return ECU to default values");
  RunPostTs();
}

testcase SW_Int_DIA_runDidFD09_LastWarmResetRead_ResetCauseCounter_01()
{
  //***********************************Test report header*********************************
  testReportAddMiscInfoBlock("AUTOLIV ELECTRONICS document");
  TestReportAddMiscInfo("Nightly test", "No");
  TestReportAddMiscInfo("Test type", "Requirement-Based test");
  TestReportAddMiscInfo("Regression Test", "Yes");
  TestReportAddMiscInfo("Fault injection method used", "No");
  TestReportAddMiscInfo("Resource usage evaluation", "No");
  TestReportAddMiscInfo("Priority", "No");
  TestReportAddMiscInfo("Safety relevant", "No");
  
  AddRequirementInfo("Requirement under test", "ARCH_SW_DIA_0032; ARCH_SW_DIA_0160; ARCH_SW_DIA_0161; ARCH_SW_NVP_0011");
  AddRequirementInfo("ARCH_SW_DIA_0032", "Service 0x22 will be implemented for DID FD09.");
  AddRequirementInfo("ARCH_SW_DIA_0160", "Response data shall be 4 bytes long.");
  AddRequirementInfo("ARCH_SW_DIA_0161", "Response shall return Reset Cause Counter.");
  AddRequirementInfo("ARCH_SW_NVP_0011", "NVP_BLOCK_ID_WARM_RESET shall be used to store last warm reset cause and counter.");
  //***************************************************************************************

  testCaseComment("Preconditions");
  testStep("STEP", "Bench Initialization");
  
  testStep("", "Delete all breakpoint from debugger.");
  debugger_deleteAllBreakpoints();

  testStep("", "Reset the debugger.");
  debugger_reset();
    
  testStep("", "Run the debugger.");
  debugger_run();
  
  RunPreTs();
  //====================================================

  EnterDiagnosticSession("development");
  testStep("STEP", "Set breakpoint in function *DIA_runDidFD09_LastWarmResetRead_LastDetectedWarmResetCause*.");
  debugger_setRelativeFunctionBpAtLine("DIA_runDidFD09_LastWarmResetRead_LastDetectedWarmResetCause", "6");
  debugger_run();
 
  testCaseComment("Action: ARCH_SW_DIA_0032; ARCH_SW_DIA_0157; ARCH_SW_DIA_0158; ARCH_SW_DIA_0159");
  testStep("STEP", "Send diag request for 22 FD09 and wait for timeout error --> Timeout received.");
  SendDiagnosticRequestNegativeResponse(dReadLastWarmResetParametersRequest, dReadLastWarmResetParametersResponse, TRUE);

  testStep("STEP", "Check if breakpoint from function DIA_runDidFD09_LastWarmResetRead_LastDetectedWarmResetCause was reached. --> BP was reached.");
  debugger_waitUntilBPisReached("5000");
  ExpectedTestResult(debugger_result, IS_CPU_STOP_AT_BP_SUCCESFUL, "BP is reached.");
  
  testWaitForTimeout(2000);
  testStep("STEP", "Read 3rd byte of NVP_BLOCK_ID_WARM_RESET_RamBlockData --> Byte was read.");
  debugger_readVariable("uint8", "NVP_BLOCK_ID_EXECUTION_COUNTERS_RamBlockData,,app.elf", "2");
  ExpectedTestResult(debugger_result, "NVP_BLOCK_ID_EXECUTION_COUNTERS_RamBlockData", "Byte was read");
  
  debugger_run();
  //====================================================
  testCaseComment("Postcondition");
  testStep("STEP", "Return ECU to default values");
  RunPostTs();

}

testcase SW_Int_DIA_runDidFD31_HBCalibrationRead_01()
{
  ////***********************************Test report header*********************************
  testReportAddMiscInfoBlock("AUTOLIV ELECTRONICS document");
  TestReportAddMiscInfo("Nightly test", "No");
  TestReportAddMiscInfo("Test type", "Requirement-Based test");
  TestReportAddMiscInfo("Regression Test", "Yes");
  TestReportAddMiscInfo("Fault injection method used", "No");
  TestReportAddMiscInfo("Resource usage evaluation", "No");
  TestReportAddMiscInfo("Priority", "No");
  TestReportAddMiscInfo("Safety relevant", "No");
  
  AddRequirementInfo("Requirement under test", "ARCH_SW_DIA_0033; ARCH_SW_DIA_0162; ARCH_SW_DIA_0163; ARCH_SW_DIA_0164, ARCH_SW_NVP_0002");
  AddRequirementInfo("ARCH_SW_DIA_0033", "Service 0x22 will be implemented for DID FD31.");
  AddRequirementInfo("ARCH_SW_DIA_0162", "Service shall be available in Development session.");
  AddRequirementInfo("ARCH_SW_DIA_0163", "Response data shall be 40 bytes long.");
  AddRequirementInfo("ARCH_SW_DIA_0164", "Response data shall return HB Calibration parameters stored in NVP_BLOCK_ID_HB_CALIBRATION.");
  AddRequirementInfo("ARCH_SW_NVP_0002", "NVP_BLOCK_ID_HB_CALIBRATION shall be configured.");

  
  ////***************************************************************************************

  testCaseComment("Preconditions");
  testStep("STEP", "Bench Initialization");
  
  testStep("", "Delete all breakpoint from debugger.");
  debugger_deleteAllBreakpoints();

  testStep("", "Reset the debugger.");
  debugger_reset();
    
  testStep("", "Run the debugger.");
  debugger_run();
  
  RunPreTs();
  ////====================================================

  testStep("STEP", "Set breakpoint in function *DIA_runDidFD31_HBCalibrationRead*.");
  debugger_setRelativeFunctionBpAtLine("DIA_runDidFD31_HBCalibrationRead", "4");
  debugger_run();
 
  testCaseComment("Action: ARCH_SW_DIA_0033; ARCH_SW_DIA_0162; ARCH_SW_DIA_0163; ARCH_SW_DIA_0164");
  testStep("STEP", "Send diag request for 22 FD31 and wait for timeout error --> Timeout received.");
  SendDiagnosticRequestNegativeResponse(dReadECUCalibParamRequest, dReadECUCalibParamResponse, TRUE);

  testStep("STEP", "Check if breakpoint from function DIA_runDidFD31_HBCalibrationRead was reached. --> BP was reached.");
  debugger_waitUntilBPisReached("5000");
  ExpectedTestResult(debugger_result, IS_CPU_STOP_AT_BP_SUCCESFUL, "BP is reached.");
  
  testStep("STEP", "Read first byte of NVP_BLOCK_ID_HB_CALIBRATION_RamBlockData --> Byte was read.");
  debugger_readVariable("uint8", "NVP_BLOCK_ID_HB_CALIBRATION_RamBlockData,,app.elf", "0");
  ExpectedTestResult(debugger_result, "NVP_BLOCK_ID_HB_CALIBRATION_RamBlockData", "Byte was read");
  
  ////====================================================
  testCaseComment("Postcondition");
  testStep("STEP", "Return ECU to default values");
  RunPostTs();
}

testcase SW_Int_DIA_runDidFD31_HBCalibrationRead_02()
{
  diagRequest RBTMFL174.HB_Calibration_Read dHBCalibrationReadRequest;
  diagResponse RBTMFL174.HB_Calibration_Read dHBCalibrationReadResponse;

  //***********************************Test report header*********************************
  testReportAddMiscInfoBlock("AUTOLIV ELECTRONICS document");
  TestReportAddMiscInfo("Nightly test", "No");
  TestReportAddMiscInfo("Test type", "Requirement-Based test");
  TestReportAddMiscInfo("Regression Test", "Yes");
  TestReportAddMiscInfo("Fault injection method used", "No");
  TestReportAddMiscInfo("Resource usage evaluation", "No");
  TestReportAddMiscInfo("Priority", "No");
  TestReportAddMiscInfo("Safety relevant", "No");
  
  AddRequirementInfo("Requirement under test", "ARCH_SW_DIA_0033; ARCH_SW_DIA_0163;");
  AddRequirementInfo("ARCH_SW_DIA_0033", "Service 0x22 will be implemented for DID FD31.");
  AddRequirementInfo("ARCH_SW_DIA_0163", "Response data shall be 40 bytes long.");

  //***************************************************************************************

  testCaseComment("Preconditions");
  testStep("STEP", "Bench Initialization");
  
  testStep("", "Delete all breakpoint from debugger.");
  debugger_deleteAllBreakpoints();

  testStep("", "Reset the debugger.");
  debugger_reset();
    
  testStep("", "Run the debugger.");
  debugger_run();
  
  RunPreTs();
  //====================================================

  EnterDiagnosticSession("development");
  
  testCaseComment("Action: ARCH_SW_DIA_0033, ARCH_SW_DIA_0163");
  testStep("STEP", "Send diag request for 22 FD 31, and evaluate response --> Request sent.");
  SendDiagnosticRequest(dHBCalibrationReadRequest, dHBCalibrationReadResponse);

  testStep("STEP", "Evaluate response data lenght. --> response data lenght is 40.");
  CheckResponseLength(dHBCalibrationReadRequest, dHBCalibrationReadResponse, 40);

  
  //====================================================
  testCaseComment("Postcondition");
  testStep("STEP", "Return ECU to default values");
  RunPostTs();
}



testcase SW_Int_DIA_runDidFE00_AECStatusRead_01()
{
  ////***********************************Test report header*********************************
  testReportAddMiscInfoBlock("AUTOLIV ELECTRONICS document");
  TestReportAddMiscInfo("Nightly test", "No");
  TestReportAddMiscInfo("Test type", "Requirement-Based test");
  TestReportAddMiscInfo("Regression Test", "Yes");
  TestReportAddMiscInfo("Fault injection method used", "No");
  TestReportAddMiscInfo("Resource usage evaluation", "No");
  TestReportAddMiscInfo("Priority", "No");
  TestReportAddMiscInfo("Safety relevant", "No");
  
  AddRequirementInfo("Requirement under test", "ARCH_SW_DIA_0035; ARCH_SW_DIA_0165; ARCH_SW_DIA_0166");
  AddRequirementInfo("ARCH_SW_DIA_0035", "Service 0x22 will be implemented for DID FE00.");
  AddRequirementInfo("ARCH_SW_DIA_0165", "Service shall be available in Development session.");
  AddRequirementInfo("ARCH_SW_DIA_0166", "Response data shall return AEC_ID_X and Status_X of said AEC.");

  
  ////***************************************************************************************

  testCaseComment("Preconditions");
  testStep("STEP", "Bench Initialization");
  
  testStep("", "Delete all breakpoint from debugger.");
  debugger_deleteAllBreakpoints();

  testStep("", "Reset the debugger.");
  debugger_reset();
    
  testStep("", "Run the debugger.");
  debugger_run();
  
  RunPreTs();
  ////====================================================

  testStep("STEP", "Set breakpoint in function *DIA_runDidFE00_AECStatusRead*.");
  debugger_setRelativeFunctionBpAtLine("DIA_runDidFE00_AECStatusRead", "0");
  debugger_run();
 
  testCaseComment("Action: ARCH_SW_DIA_0035; ARCH_SW_DIA_0165; ARCH_SW_DIA_0166");
  testStep("STEP", "Send diag request for 22 FE00 and wait for timeout error --> Timeout received.");
  SendDiagnosticRequestNegativeResponse(dReadAllAECStatusRequest, dReadAllAECStatusResponse, TRUE);

  testwaitforTimeout(1000);
  testStep("STEP", "Check if breakpoint from function DIA_runDidFE00_AECStatusRead was reached. --> BP was reached.");
  debugger_waitUntilBPisReached("5000");
  ExpectedTestResult(debugger_result, IS_CPU_STOP_AT_BP_SUCCESFUL, "BP is reached.");
  
  ////====================================================
  testCaseComment("Postcondition");
  testStep("STEP", "Return ECU to default values");
  RunPostTs();
}

testcase SW_Int_DIA_runDidFE00_AECStatusReadDataLength_01()
{
  ////***********************************Test report header*********************************
  testReportAddMiscInfoBlock("AUTOLIV ELECTRONICS document");
  TestReportAddMiscInfo("Nightly test", "No");
  TestReportAddMiscInfo("Test type", "Requirement-Based test");
  TestReportAddMiscInfo("Regression Test", "Yes");
  TestReportAddMiscInfo("Fault injection method used", "No");
  TestReportAddMiscInfo("Resource usage evaluation", "No");
  TestReportAddMiscInfo("Priority", "No");
  TestReportAddMiscInfo("Safety relevant", "No");
  
  AddRequirementInfo("Requirement under test", "ARCH_SW_DIA_0035; ARCH_SW_DIA_0167");
  AddRequirementInfo("ARCH_SW_DIA_0035", "Service 0x22 will be implemented for DID FE00.");
  AddRequirementInfo("ARCH_SW_DIA_0166", "Runnable shall set response length to 168.");

  
  ////***************************************************************************************

  testCaseComment("Preconditions");
  testStep("STEP", "Bench Initialization");
  
  testStep("", "Delete all breakpoint from debugger.");
  debugger_deleteAllBreakpoints();

  testStep("", "Reset the debugger.");
  debugger_reset();
    
  testStep("", "Run the debugger.");
  debugger_run();
  
  RunPreTs();
  ////====================================================

  testStep("STEP", "Send diag request for 22 FD 31, and evaluate response --> Request sent.");
  SendDiagnosticRequest(dReadAllAECStatusRequest, dReadAllAECStatusResponse);

  testStep("STEP", "Evaluate response data lenght. --> response data lenght is 168.");
  EvaluateDiagResponseSize(dReadAllAECStatusRequest, 168);

  
  ////====================================================
  testCaseComment("Postcondition");
  testStep("STEP", "Return ECU to default values");
  RunPostTs();
}

testcase SW_Int_DIA_runDidFEFF_MeasuruementFrameConfigurationRead_01()
{
  ////***********************************Test report header*********************************
  testReportAddMiscInfoBlock("AUTOLIV ELECTRONICS document");
  TestReportAddMiscInfo("Nightly test", "No");
  TestReportAddMiscInfo("Test type", "Requirement-Based test");
  TestReportAddMiscInfo("Regression Test", "Yes");
  TestReportAddMiscInfo("Fault injection method used", "No");
  TestReportAddMiscInfo("Resource usage evaluation", "No");
  TestReportAddMiscInfo("Priority", "No");
  TestReportAddMiscInfo("Safety relevant", "No");
  
  AddRequirementInfo("Requirement under test", "ARCH_SW_DIA_0036; ARCH_SW_DIA_0168; ARCH_SW_DIA_0169; ARCH_SW_DIA_0170, ARCH_SW_NVP_0012; ARCH_SW_DIA_0038");
  AddRequirementInfo("ARCH_SW_DIA_0036", "Service 0x22 will be implemented for DID FEFF.");
  AddRequirementInfo("ARCH_SW_DIA_0168", "Service shall be available in Development session.");
  AddRequirementInfo("ARCH_SW_DIA_0169", "Response data shall be 4 bytes long.");
  AddRequirementInfo("ARCH_SW_DIA_0170", "Response shall return Timing and Block Config stored in NVP_BLOCK_ID_MEASUREMENT_FRAME_CONFIG.");
  AddRequirementInfo("ARCH_SW_NVP_0012", "NVP_BLOCK_ID_MEASUREMENT_FRAME_CONFIG shall be used to configure measurement frames blocks. ");
  AddRequirementInfo("ARCH_SW_DIA_0038", "Service 0x2E will be implemented for DID FEFF. ");

  
  ////***************************************************************************************

  testCaseComment("Preconditions");
  testStep("STEP", "Bench Initialization");
  
  testStep("", "Delete all breakpoint from debugger.");
  debugger_deleteAllBreakpoints();

  testStep("", "Reset the debugger.");
  debugger_reset();
    
  testStep("", "Run the debugger.");
  debugger_run();
  
  RunPreTs();
  ////====================================================

  testStep("STEP", "Set breakpoint in function *DIA_runDidFEFF_MeasuruementFrameConfigurationRead*.");
  debugger_setRelativeFunctionBpAtLine("DIA_runDidFEFF_MeasuruementFrameConfigurationRead", "4");
  debugger_run();
 
  testCaseComment("Action: ARCH_SW_DIA_0036; ARCH_SW_DIA_0168; ARCH_SW_DIA_0169; ARCH_SW_DIA_0170, ARCH_SW_NVP_0012;");
  testStep("STEP", "Send diag request for 22 FEFF and wait for timeout error --> Timeout received.");
  SendDiagnosticRequestNegativeResponse(dMeasurementFrameReadRequest, dMeasurementFrameReadResponse, TRUE);

  testWaitForTimeout(2000);
  
  testStep("STEP", "Check if breakpoint from function DIA_runDidFEFF_MeasuruementFrameConfigurationRead was reached. --> BP was reached.");
  debugger_waitUntilBPisReached("5000");
  ExpectedTestResult(debugger_result, IS_CPU_STOP_AT_BP_SUCCESFUL, "BP is reached.");
  
  testStep("STEP", "Read first byte of NVP_BLOCK_ID_MEASUREMENT_FRAME_CONFIG_RamBlockData --> Byte was read.");
  debugger_readVariable("uint8", "NVP_BLOCK_ID_MEASUREMENT_FRAME_CONFIG_RamBlockData,,app.elf", "0");
  ExpectedTestResult(debugger_result, "NVP_BLOCK_ID_MEASUREMENT_FRAME_CONFIG_RamBlockData", "Byte was read");
  
  ////====================================================
  testCaseComment("Postcondition");
  testStep("STEP", "Return ECU to default values");
  RunPostTs();
}

testcase SW_Int_DIA_runDidFDFF_MeasurementFrameBlock12ConfigRead_01()
{
  ////***********************************Test report header*********************************
  testReportAddMiscInfoBlock("AUTOLIV ELECTRONICS document");
  TestReportAddMiscInfo("Nightly test", "No");
  TestReportAddMiscInfo("Test type", "Requirement-Based test");
  TestReportAddMiscInfo("Regression Test", "Yes");
  TestReportAddMiscInfo("Fault injection method used", "No");
  TestReportAddMiscInfo("Resource usage evaluation", "No");
  TestReportAddMiscInfo("Priority", "No");
  TestReportAddMiscInfo("Safety relevant", "No");
  
  AddRequirementInfo("Requirement under test", "ARCH_SW_DIA_0037; ARCH_SW_DIA_0171; ARCH_SW_DIA_0172; ARCH_SW_DIA_0173");
  AddRequirementInfo("ARCH_SW_DIA_0037", "Service 0x22 will be implemented for DID FEFF.");
  AddRequirementInfo("ARCH_SW_DIA_0171", "Service shall be available in Development session.");
  AddRequirementInfo("ARCH_SW_DIA_0172", "Response data shall be 4 bytes long.");
  AddRequirementInfo("ARCH_SW_DIA_0173", "Response shall return Ram Address and Size stored in NVP_BLOCK_ID_MEASUREMENT_FRAME_12_CONFIG.");
  
  ////***************************************************************************************

  testCaseComment("Preconditions");
  testStep("STEP", "Bench Initialization");
  
  testStep("", "Delete all breakpoint from debugger.");
  debugger_deleteAllBreakpoints();

  testStep("", "Reset the debugger.");
  debugger_reset();
    
  testStep("", "Run the debugger.");
  debugger_run();
  
  RunPreTs();
  ////====================================================

  testStep("STEP", "Set breakpoint in function *DIA_runDidFDFF_MeasurementFrameBlock12ConfigRead*.");
  debugger_setRelativeFunctionBpAtLine("DIA_runDidFDFF_MeasurementFrameBlock12ConfigRead", "4");
  debugger_run();
 
  testCaseComment("Action: ARCH_SW_DIA_0037; ARCH_SW_DIA_0171; ARCH_SW_DIA_0172; ARCH_SW_DIA_0173");
  testStep("STEP", "Send diag request for 22 FDFF and wait for timeout error --> Timeout received.");
  SendDiagnosticRequestNegativeResponse(dReadMFBlock12ConfigRequest, dReadMFBlock12ConfigResponse, TRUE);

  testWaitForTimeout(2000);
  testStep("STEP", "Check if breakpoint from function DIA_runDidFDFF_MeasurementFrameBlock12ConfigRead was reached. --> BP was reached.");
  debugger_waitUntilBPisReached("5000");
  ExpectedTestResult(debugger_result, IS_CPU_STOP_AT_BP_SUCCESFUL, "BP is reached.");
  
  testStep("STEP", "Read first byte of NVP_BLOCK_ID_MEASUREMENT_FRAME_CONFIG_RamBlockData --> Byte was read.");
  debugger_readVariable("uint8", "NVP_BLOCK_ID_MEASUREMENT_FRAME_CONFIG_RamBlockData,,app.elf", "2");
  ExpectedTestResult(debugger_result, "NVP_BLOCK_ID_MEASUREMENT_FRAME_CONFIG_RamBlockData", "Byte was read");
  
 
  ////====================================================
  testCaseComment("Postcondition");
  testStep("STEP", "Return ECU to default values");
  RunPostTs();
}


testcase SW_Int_DIA_runDid0142_AvailabilityDataRead_01()
{
  ////***********************************Test report header*********************************
  testReportAddMiscInfoBlock("AUTOLIV ELECTRONICS document");
  TestReportAddMiscInfo("Nightly test", "No");
  TestReportAddMiscInfo("Test type", "Requirement-Based test");
  TestReportAddMiscInfo("Regression Test", "Yes");
  TestReportAddMiscInfo("Fault injection method used", "No");
  TestReportAddMiscInfo("Resource usage evaluation", "No");
  TestReportAddMiscInfo("Priority", "No");
  TestReportAddMiscInfo("Safety relevant", "No");
  
  AddRequirementInfo("Requirement under test", "ARCH_SW_DIA_0235; ARCH_SW_DIA_0236; ARCH_SW_DIA_0237; ARCH_SW_DIA_0238; ARCH_SW_DIA_0336; ARCH_SW_DIA_0337");
  AddRequirementInfo("ARCH_SW_DIA_0235", "Service 0x22 (Read Data By Identifier) will be implemented for DID 0x0142 (Availability Data).");
  AddRequirementInfo("ARCH_SW_DIA_0236", "Service shall be available in Default session, Extended session Update session and Development session.");
  AddRequirementInfo("ARCH_SW_DIA_0237", "Service shall be available in the following forms of Authentication: Development ENHANCED, Production After-Sales ENHANCED, After-Sales After-Sales BASIC, Internal Diagnostic Test Tool, ePTI Test Tool .");
  AddRequirementInfo("ARCH_SW_DIA_0238", "Result can have the following values: 0x00, 0x01 and 0x02.");
  AddRequirementInfo("ARCH_SW_DIA_0337", "Positive Response: Green  no DTC or DTC without Warning indicator. Yellow  is not used Red  Display message is requested -> DTC with Warning indicator is set .");
  
  ////***************************************************************************************

  testCaseComment("Preconditions");
  testStep("STEP", "Bench Initialization");
  
  testStep("", "Delete all breakpoint from debugger.");
  debugger_deleteAllBreakpoints();

  testStep("", "Reset the debugger.");
  debugger_reset();
    
  testStep("", "Run the debugger.");
  debugger_run();
  
  RunPreTs();
  ////====================================================

  testStep("STEP", "Set breakpoint in function *DIA_runDid0142_AvailabilityDataRead*.");
  debugger_setRelativeFunctionBpAtLine("DIA_runDid0142_AvailabilityDataRead", "6");
  debugger_run();
 
  testCaseComment("Action: ARCH_SW_DIA_0235; ARCH_SW_DIA_0236; ARCH_SW_DIA_0237; ARCH_SW_DIA_0238; ARCH_SW_DIA_0336; ARCH_SW_DIA_0337");
  testStep("STEP", "Send diag request for 22 0142 and wait for timeout error --> Timeout received.");
  SendDiagnosticRequestNegativeResponse(dAvailabilityDataReadRequest, dAvailabilityDataReadResponse, TRUE);

  testWaitForTimeout(2000);
  testStep("STEP", "Check if breakpoint from function DIA_runDid0142_AvailabilityDataRead was reached. --> BP was reached.");
  debugger_waitUntilBPisReached("5000");
  ExpectedTestResult(debugger_result, IS_CPU_STOP_AT_BP_SUCCESFUL, "BP is reached.");
  
  testStep("STEP", "Evaluate *Data pointer --> Byte was read.");
  debugger_readLocalVariable("*Data");
  ExpectedTestResult(debugger_result, "*Data", "Data read.");
  
 
  ////====================================================
  testCaseComment("Postcondition");
  testStep("STEP", "Return ECU to default values");
  RunPostTs();
}

testcase SW_Int_DIA_runDid0241_PRE_SAFE_Recorder_1_ReadDataLength_01()
{
  diagRequest RBTMFL174.PRE_SAFE_Recorder_1_read_Read dPresafeRecorder1ReadRequest;
  diagResponse RBTMFL174.PRE_SAFE_Recorder_1_read_Read dPresafeRecorder1ReadResponse;
  //***********************************Test report header*********************************
  testReportAddMiscInfoBlock("AUTOLIV ELECTRONICS document");
  TestReportAddMiscInfo("Nightly test", "No");
  TestReportAddMiscInfo("Test type", "Requirement-Based test");
  TestReportAddMiscInfo("Regression Test", "Yes");
  TestReportAddMiscInfo("Fault injection method used", "No");
  TestReportAddMiscInfo("Resource usage evaluation", "No");
  TestReportAddMiscInfo("Priority", "No");
  TestReportAddMiscInfo("Safety relevant", "No");
  
  AddRequirementInfo("Requirement under test", "ARCH_SW_DIA_0240; ARCH_SW_DIA_0246; ARCH_SW_DIA_0247");
  AddRequirementInfo("ARCH_SW_DIA_0240", "Service 0x22 (Read Data By Identifier) & 0x2E (Write Data By Identifier) for DID 0x0241 will be implemented.");
  AddRequirementInfo("ARCH_SW_DIA_0241", "Service shall be available in Default session, Extended session Update session and Development session");
  AddRequirementInfo("ARCH_SW_DIA_0242", "Service shall be available in the following forms of Authentication: Development ENHANCED, Production After-Sales ENHANCED, After-Sales  After-Sales BASIC, Internal Diagnostic Test Tool, ePTI Test Tool");
  AddRequirementInfo("ARCH_SW_DIA_0243", "Response data shall be 22 bytes long.");
  
  //***************************************************************************************

  testCaseComment("Preconditions");
  testStep("STEP", "Bench Initialization");
  
  testStep("", "Delete all breakpoint from debugger.");
  debugger_deleteAllBreakpoints();

  testStep("", "Reset the debugger.");
  debugger_reset();
    
  testStep("", "Run the debugger.");
  debugger_run();
  
  RunPreTs();
  //====================================================

  debugger_setRelativeFunctionBpAtLine("DIA_runDid0241_PRE_SAFE_Recorder_1_ReadDataLength", "0");
  debugger_run();
  
  testStep("STEP", "Send diag request for 22 02 41, and evaluate response --> Request sent.");
  SendDiagnosticRequestNegativeResponse(dPresafeRecorder1ReadRequest, dPresafeRecorder1ReadResponse, TRUE);

  testWaitForTimeout(2000);
  testStep("STEP", "Evaluate response data lenght. --> response data lenght is 22.");
  debugger_waitUntilBPisReached("5000");
  ExpectedTestResult(debugger_result, IS_CPU_STOP_AT_BP_SUCCESFUL, "BP is reached.");

  debugger_run();
  //====================================================
  testCaseComment("Postcondition");
  testStep("STEP", "Return ECU to default values");
  RunPostTs();
}

testcase SW_Int_DIA_runDid0241_PRE_SAFE_Recorder_1_ConditionCheckRead_01()
{
  diagRequest RBTMFL174.PRE_SAFE_Recorder_1_read_Read dPresafeRecorder1ReadRequest;
  diagResponse RBTMFL174.PRE_SAFE_Recorder_1_read_Read dPresafeRecorder1ReadResponse;

  //***********************************Test report header*********************************
  testReportAddMiscInfoBlock("AUTOLIV ELECTRONICS document");
  TestReportAddMiscInfo("Nightly test", "No");
  TestReportAddMiscInfo("Test type", "Requirement-Based test");
  TestReportAddMiscInfo("Regression Test", "Yes");
  TestReportAddMiscInfo("Fault injection method used", "No");
  TestReportAddMiscInfo("Resource usage evaluation", "No");
  TestReportAddMiscInfo("Priority", "No");
  TestReportAddMiscInfo("Safety relevant", "No");
  
  AddRequirementInfo("Requirement under test", "ARCH_SW_DIA_0240; ARCH_SW_DIA_0244; ARCH_SW_DIA_0245;");
  AddRequirementInfo("ARCH_SW_DIA_0240", "Service 0x22 (Read Data By Identifier) & 0x2E (Write Data By Identifier) for DID 0x0241 will be implemented.");
  AddRequirementInfo("ARCH_SW_DIA_0244", "Service shall be available in Default session, Extended session");
  AddRequirementInfo("ARCH_SW_DIA_0245", "Service shall be available in the following forms of Authentication: Development ENHANCED, Production After-Sales ENHANCED, After-Sales After-Sales BASIC, Internal Diagnostic Test Tool, ePTI Test Tool");
  
  //***************************************************************************************

  testCaseComment("Preconditions");
  testStep("STEP", "Bench Initialization");
  
  testStep("", "Delete all breakpoint from debugger.");
  debugger_deleteAllBreakpoints();

  testStep("", "Reset the debugger.");
  debugger_reset();
    
  testStep("", "Run the debugger.");
  debugger_run();
  
  RunPreTs();
  //====================================================

  testStep("STEP", "Set breakpoint in function *DIA_runDid0241_PRE_SAFE_Recorder_1_ConditionCheckRead*.");
  debugger_setRelativeFunctionBpAtLine("DIA_runDid0241_PRE_SAFE_Recorder_1_ConditionCheckRead", "0");
  debugger_run();
 
  testCaseComment("Action: ARCH_SW_DIA_0240; ARCH_SW_DIA_0244; ARCH_SW_DIA_0245;");
  testStep("STEP", "Send diag request for 22 0241 and wait for timeout error --> Timeout received.");
  SendDiagnosticRequestNegativeResponse(dPresafeRecorder1ReadRequest, dPresafeRecorder1ReadResponse, TRUE);

  testWaitForTimeout(2000);
  testStep("STEP", "Check if breakpoint from function DIA_runDid0241_PRE_SAFE_Recorder_1_ConditionCheckRead was reached. --> BP was reached.");
  debugger_waitUntilBPisReached("5000");
  ExpectedTestResult(debugger_result, IS_CPU_STOP_AT_BP_SUCCESFUL, "BP is reached.");

  //====================================================
  testCaseComment("Postcondition");
  testStep("STEP", "Return ECU to default values");
  RunPostTs();
}

testcase SW_Int_DIA_runDid0241_PRE_SAFE_Recorder_1_ReadData_01()
{
  ////***********************************Test report header*********************************
  testReportAddMiscInfoBlock("AUTOLIV ELECTRONICS document");
  TestReportAddMiscInfo("Nightly test", "No");
  TestReportAddMiscInfo("Test type", "Requirement-Based test");
  TestReportAddMiscInfo("Regression Test", "Yes");
  TestReportAddMiscInfo("Fault injection method used", "No");
  TestReportAddMiscInfo("Resource usage evaluation", "No");
  TestReportAddMiscInfo("Priority", "No");
  TestReportAddMiscInfo("Safety relevant", "No");
  
  AddRequirementInfo("Requirement under test", "ARCH_SW_DIA_0240; ARCH_SW_DIA_0246; ARCH_SW_DIA_0247, ARCH_SW_NVP_0015");
  AddRequirementInfo("ARCH_SW_DIA_0240", "Service 0x22 (Read Data By Identifier) & 0x2E (Write Data By Identifier) for DID 0x0241 will be implemented.");
  AddRequirementInfo("ARCH_SW_DIA_0246", "Service shall be available in Default session, Extended session");
  AddRequirementInfo("ARCH_SW_DIA_0247", "Service shall be available in the following forms of Authentication: Development ENHANCED, Production After-Sales ENHANCED, After-Sales After-Sales BASIC, Internal Diagnostic Test Tool, ePTI Test Tool");
  AddRequirementInfo("ARCH_SW_NVP_0015", "NVP_BLOCK_ID_PRE_SAFE_RECORDER_1 should be defined.");

  ////***************************************************************************************

  testCaseComment("Preconditions");
  testStep("STEP", "Bench Initialization");
  
  testStep("", "Delete all breakpoint from debugger.");
  debugger_deleteAllBreakpoints();

  testStep("", "Reset the debugger.");
  debugger_reset();
    
  testStep("", "Run the debugger.");
  debugger_run();
  
  RunPreTs();
  ////====================================================

  testStep("STEP", "Set breakpoint in function *DIA_runDid0241_PRE_SAFE_Recorder_1_ReadData*.");
  debugger_setRelativeFunctionBpAtLine("DIA_runDid0241_PRE_SAFE_Recorder_1_ReadData", "4");
  debugger_run();
 
  testCaseComment("Action: ARCH_SW_DIA_0240; ARCH_SW_DIA_0246; ARCH_SW_DIA_0247, ARCH_SW_NVP_0015");
  testStep("STEP", "Send diag request for 22 0241 and wait for timeout error --> Timeout received.");
  SendDiagnosticRequestNegativeResponse(dPresafeRecorder1ReadRequest, dPresafeRecorder1ReadResponse, TRUE);

  testWaitForTimeout(2000);
  testStep("STEP", "Check if breakpoint from function DIA_runDid0241_PRE_SAFE_Recorder_1_ReadData was reached. --> BP was reached.");
  debugger_waitUntilBPisReached("5000");
  ExpectedTestResult(debugger_result, IS_CPU_STOP_AT_BP_SUCCESFUL, "BP is reached.");
  
  testStep("STEP", "Evaluate NVP_BLOCK_ID_PRE_SAFE_RECORDER_1_RamBlockData --> Byte was read.");
  debugger_readVariable("uint8", "NVP_BLOCK_ID_PRE_SAFE_RECORDER_1_RamBlockData,,app.elf", "0");
  ExpectedTestResult(debugger_result, "NVP_BLOCK_ID_PRE_SAFE_RECORDER_1_RamBlockData", "Variable read.");

  ////====================================================
  testCaseComment("Postcondition");
  testStep("STEP", "Return ECU to default values");
  RunPostTs();
}


testcase SW_Int_DIA_runDid0242_PRE_SAFE_Recorder_2_ReadDataLength_01()
{
  ////***********************************Test report header*********************************
  testReportAddMiscInfoBlock("AUTOLIV ELECTRONICS document");
  TestReportAddMiscInfo("Nightly test", "No");
  TestReportAddMiscInfo("Test type", "Requirement-Based test");
  TestReportAddMiscInfo("Regression Test", "Yes");
  TestReportAddMiscInfo("Fault injection method used", "No");
  TestReportAddMiscInfo("Resource usage evaluation", "No");
  TestReportAddMiscInfo("Priority", "No");
  TestReportAddMiscInfo("Safety relevant", "No");
  
  AddRequirementInfo("Requirement under test", "ARCH_SW_DIA_0250; ARCH_SW_DIA_0251; ARCH_SW_DIA_0252; ARCH_SW_DIA_0253");
  AddRequirementInfo("ARCH_SW_DIA_0250", "Service 0x22 (Read Data By Identifier) & 0x2E (Write Data By Identifier) for DID 0x0242 will be implemented.");
  AddRequirementInfo("ARCH_SW_DIA_0251", "Service shall be available in Default session, Extended session Update session and Development session");
  AddRequirementInfo("ARCH_SW_DIA_0252", "Service shall be available in the following forms of Authentication: Development ENHANCED, Production After-Sales ENHANCED, After-Sales  After-Sales BASIC, Internal Diagnostic Test Tool, ePTI Test Tool");
  AddRequirementInfo("ARCH_SW_DIA_0253", "Response data shall be 22 bytes long.");
  
  ////***************************************************************************************

  testCaseComment("Preconditions");
  testStep("STEP", "Bench Initialization");
  
  testStep("", "Delete all breakpoint from debugger.");
  debugger_deleteAllBreakpoints();

  testStep("", "Reset the debugger.");
  debugger_reset();
    
  testStep("", "Run the debugger.");
  debugger_run();
  
  RunPreTs();
  ////====================================================

  testStep("STEP", "Send diag request for 22 02 42, and evaluate response --> Request sent.");
  SendDiagnosticRequest(dPresafeRecorder2ReadRequest, dPresafeRecorder2ReadResponse);

  testWaitForTimeout(2000);
  testStep("STEP", "Evaluate response data lenght. --> response data lenght is 22.");
  EvaluateDiagResponseSize(dPresafeRecorder2ReadRequest, 22);

  ////====================================================
  testCaseComment("Postcondition");
  testStep("STEP", "Return ECU to default values");
  RunPostTs();
}

testcase SW_Int_DIA_runDid0242_PRE_SAFE_Recorder_2_ConditionCheckRead_01()
{
  diagRequest RBTMFL174.PRE_SAFE_Recorder_2_read_Read dPresafeRecorder2ReadRequest;
  diagResponse RBTMFL174.PRE_SAFE_Recorder_2_read_Read dPresafeRecorder2ReadResponse;
  //***********************************Test report header*********************************
  testReportAddMiscInfoBlock("AUTOLIV ELECTRONICS document");
  TestReportAddMiscInfo("Nightly test", "No");
  TestReportAddMiscInfo("Test type", "Requirement-Based test");
  TestReportAddMiscInfo("Regression Test", "Yes");
  TestReportAddMiscInfo("Fault injection method used", "No");
  TestReportAddMiscInfo("Resource usage evaluation", "No");
  TestReportAddMiscInfo("Priority", "No");
  TestReportAddMiscInfo("Safety relevant", "No");
  
  AddRequirementInfo("Requirement under test", "ARCH_SW_DIA_0250; ARCH_SW_DIA_0254; ARCH_SW_DIA_0255");
  AddRequirementInfo("ARCH_SW_DIA_0250", "Service 0x22 (Read Data By Identifier) & 0x2E (Write Data By Identifier) for DID 0x0242 will be implemented.");
  AddRequirementInfo("ARCH_SW_DIA_0254", "Service shall be available in Default session, Extended session");
  AddRequirementInfo("ARCH_SW_DIA_0255", "Service shall be available in the following forms of Authentication: Development ENHANCED, Production After-Sales ENHANCED, After-Sales After-Sales BASIC, Internal Diagnostic Test Tool, ePTI Test Tool");
  
  //***************************************************************************************

  testCaseComment("Preconditions");
  testStep("STEP", "Bench Initialization");
  
  testStep("", "Delete all breakpoint from debugger.");
  debugger_deleteAllBreakpoints();

  testStep("", "Reset the debugger.");
  debugger_reset();
    
  testStep("", "Run the debugger.");
  debugger_run();
  
  RunPreTs();
  //====================================================

  testStep("STEP", "Set breakpoint in function *DIA_runDid0242_PRE_SAFE_Recorder_2_ConditionCheckRead*.");
  debugger_setRelativeFunctionBpAtLine("DIA_runDid0242_PRE_SAFE_Recorder_2_ConditionCheckRead", "0");
  debugger_run();
 
  testCaseComment("Action: ARCH_SW_DIA_0250; ARCH_SW_DIA_0254; ARCH_SW_DIA_0255");
  testStep("STEP", "Send diag request for 22 0242 and wait for timeout error --> Timeout received.");
  SendDiagnosticRequestNegativeResponse(dPresafeRecorder2ReadRequest, dPresafeRecorder2ReadResponse, TRUE);

  testWaitForTimeout(2000);
  testStep("STEP", "Check if breakpoint from function DIA_runDid0242_PRE_SAFE_Recorder_2_ConditionCheckRead was reached. --> BP was reached.");
  debugger_waitUntilBPisReached("5000");
  ExpectedTestResult(debugger_result, IS_CPU_STOP_AT_BP_SUCCESFUL, "BP is reached.");

  //====================================================
  testCaseComment("Postcondition");
  testStep("STEP", "Return ECU to default values");
  RunPostTs();
}

testcase SW_Int_DIA_runDid0242_PRE_SAFE_Recorder_2_ReadData_01()
{
  ////***********************************Test report header*********************************
  testReportAddMiscInfoBlock("AUTOLIV ELECTRONICS document");
  TestReportAddMiscInfo("Nightly test", "No");
  TestReportAddMiscInfo("Test type", "Requirement-Based test");
  TestReportAddMiscInfo("Regression Test", "Yes");
  TestReportAddMiscInfo("Fault injection method used", "No");
  TestReportAddMiscInfo("Resource usage evaluation", "No");
  TestReportAddMiscInfo("Priority", "No");
  TestReportAddMiscInfo("Safety relevant", "No");
  
  AddRequirementInfo("Requirement under test", "ARCH_SW_DIA_0250; ARCH_SW_DIA_0256; ARCH_SW_DIA_0257, ARCH_SW_NVP_0016");
  AddRequirementInfo("ARCH_SW_DIA_0250", "Service 0x22 (Read Data By Identifier) & 0x2E (Write Data By Identifier) for DID 0x0242 will be implemented.");
  AddRequirementInfo("ARCH_SW_DIA_0256", "Service shall be available in Default session, Extended session");
  AddRequirementInfo("ARCH_SW_DIA_0257", "Service shall be available in the following forms of Authentication: Development ENHANCED, Production After-Sales ENHANCED, After-Sales After-Sales BASIC, Internal Diagnostic Test Tool, ePTI Test Tool");
  AddRequirementInfo("ARCH_SW_NVP_0016", "NVP_BLOCK_ID_PRE_SAFE_RECORDER_2 should be defined.");

  ////***************************************************************************************

  testCaseComment("Preconditions");
  testStep("STEP", "Bench Initialization");
  
  testStep("", "Delete all breakpoint from debugger.");
  debugger_deleteAllBreakpoints();

  testStep("", "Reset the debugger.");
  debugger_reset();
    
  testStep("", "Run the debugger.");
  debugger_run();
  
  RunPreTs();
  ////====================================================

  testStep("STEP", "Set breakpoint in function *DIA_runDid0242_PRE_SAFE_Recorder_2_ReadData*.");
  debugger_setRelativeFunctionBpAtLine("DIA_runDid0242_PRE_SAFE_Recorder_2_ReadData", "4");
  debugger_run();
 
  testCaseComment("Action: ARCH_SW_DIA_0250; ARCH_SW_DIA_0256; ARCH_SW_DIA_0257, ARCH_SW_NVP_0016");
  testStep("STEP", "Send diag request for 22 0242 and wait for timeout error --> Timeout received.");
  SendDiagnosticRequestNegativeResponse(dPresafeRecorder2ReadRequest, dPresafeRecorder2ReadResponse, TRUE);

  testWaitForTimeout(2000);
  testStep("STEP", "Check if breakpoint from function DIA_runDid0242_PRE_SAFE_Recorder_2_ReadData was reached. --> BP was reached.");
  debugger_waitUntilBPisReached("5000");
  ExpectedTestResult(debugger_result, IS_CPU_STOP_AT_BP_SUCCESFUL, "BP is reached.");
  
  testStep("STEP", "Evaluate NVP_BLOCK_ID_PRE_SAFE_RECORDER_2_RamBlockData --> Byte was read.");
  debugger_readVariable("uint8", "NVP_BLOCK_ID_PRE_SAFE_RECORDER_2_RamBlockData,,app.elf", "0");
  ExpectedTestResult(debugger_result, "NVP_BLOCK_ID_PRE_SAFE_RECORDER_2_RamBlockData", "Variable read.");

  ////====================================================
  testCaseComment("Postcondition");
  testStep("STEP", "Return ECU to default values");
  RunPostTs();
}

testcase SW_Int_DIA_ResetServiceExecution_01()
{
  ////***********************************Test report header*********************************
  testReportAddMiscInfoBlock("AUTOLIV ELECTRONICS document");
  TestReportAddMiscInfo("Nightly test", "No");
  TestReportAddMiscInfo("Test type", "Requirement-Based test");
  TestReportAddMiscInfo("Regression Test", "Yes");
  TestReportAddMiscInfo("Fault injection method used", "No");
  TestReportAddMiscInfo("Resource usage evaluation", "No");
  TestReportAddMiscInfo("Priority", "No");
  TestReportAddMiscInfo("Safety relevant", "No");
  
  AddRequirementInfo("Requirement under test", "ARCH_SW_DIA_0265; ARCH_SW_DIA_0266; ARCH_SW_DIA_0267; ARCH_SW_DIA_0268; ARCH_SW_DIA_0269; ARCH_SW_DIA_0270; ARCH_SW_DIA_0271");
  AddRequirementInfo("ARCH_SW_DIA_0265", "Service 0x11 (ECU Reset) will be implemented.");
  AddRequirementInfo("ARCH_SW_DIA_0266", "The ECUReset service shall be available in the following sessions: Supplier Development ENHANCED Production After-Sales ENHANCED After-Sales ");
  AddRequirementInfo("ARCH_SW_DIA_0267", "The ECUReset service shall be available under the following forms of Authentication");
  AddRequirementInfo("ARCH_SW_DIA_0268", "ResetType of the Reset service shall be: 0x01  Hardware Reset.");
  AddRequirementInfo("ARCH_SW_DIA_0269", "ResetType of the Reset service shall be: 0x03  Software Reset.");
  AddRequirementInfo("ARCH_SW_DIA_0270", "Bytes #2:  Reset type should be an echo of the ResetType parameter in the request message.");
  AddRequirementInfo("ARCH_SW_DIA_0271", "After a successful ECU Reset, ECU shall be in DefaultSession.");

  ////***************************************************************************************

  testCaseComment("Preconditions");
  testStep("STEP", "Bench Initialization");
  
  testStep("", "Delete all breakpoint from debugger.");
  debugger_deleteAllBreakpoints();

  testStep("", "Reset the debugger.");
  debugger_reset();
    
  testStep("", "Run the debugger.");
  debugger_run();
  
  RunPreTs();
  ////====================================================

  testStep("STEP", "Set breakpoint in function *ResetServiceExecution*.");
  debugger_setRelativeFunctionBpAtLine("ResetServiceExecution", "0");
  debugger_run();
 
  testCaseComment("Action: ARCH_SW_DIA_0265; ARCH_SW_DIA_0266; ARCH_SW_DIA_0267; ARCH_SW_DIA_0268; ARCH_SW_DIA_0269; ARCH_SW_DIA_0270; ARCH_SW_DIA_0271");
  testStep("STEP", "Send soft reset request.");
  SendDiagnosticRequestNegativeResponse(dSoftResetRequest, dSoftResetResponse, TRUE);

  testWaitForTimeout(2000);
  testStep("STEP", "Check if breakpoint from function ResetServiceExecution was reached. --> BP was reached.");
  debugger_waitUntilBPisReached("5000");
  ExpectedTestResult(debugger_result, IS_CPU_STOP_AT_BP_SUCCESFUL, "BP is reached.");
  ////====================================================
  testCaseComment("Postcondition");
  testStep("STEP", "Return ECU to default values");
  RunPostTs();
}

testcase SW_Int_DIA_ResetServiceExecution_02()
{
  ////***********************************Test report header*********************************
  testReportAddMiscInfoBlock("AUTOLIV ELECTRONICS document");
  TestReportAddMiscInfo("Nightly test", "No");
  TestReportAddMiscInfo("Test type", "Requirement-Based test");
  TestReportAddMiscInfo("Regression Test", "Yes");
  TestReportAddMiscInfo("Fault injection method used", "No");
  TestReportAddMiscInfo("Resource usage evaluation", "No");
  TestReportAddMiscInfo("Priority", "No");
  TestReportAddMiscInfo("Safety relevant", "No");
  
  AddRequirementInfo("Requirement under test", "ARCH_SW_DIA_0265; ARCH_SW_DIA_0266; ARCH_SW_DIA_0267; ARCH_SW_DIA_0268; ARCH_SW_DIA_0269; ARCH_SW_DIA_0270; ARCH_SW_DIA_0271");
  AddRequirementInfo("ARCH_SW_DIA_0265", "Service 0x11 (ECU Reset) will be implemented.");
  AddRequirementInfo("ARCH_SW_DIA_0266", "The ECUReset service shall be available in the following sessions: Supplier Development ENHANCED Production After-Sales ENHANCED After-Sales ");
  AddRequirementInfo("ARCH_SW_DIA_0267", "The ECUReset service shall be available under the following forms of Authentication");
  AddRequirementInfo("ARCH_SW_DIA_0268", "ResetType of the Reset service shall be: 0x01  Hardware Reset.");
  AddRequirementInfo("ARCH_SW_DIA_0269", "ResetType of the Reset service shall be: 0x03  Software Reset.");
  AddRequirementInfo("ARCH_SW_DIA_0270", "Bytes #2:  Reset type should be an echo of the ResetType parameter in the request message.");
  AddRequirementInfo("ARCH_SW_DIA_0271", "After a successful ECU Reset, ECU shall be in DefaultSession.");
  ////***************************************************************************************

  testCaseComment("Preconditions");
  testStep("STEP", "Bench Initialization");
  
  testStep("", "Delete all breakpoint from debugger.");
  debugger_deleteAllBreakpoints();

  testStep("", "Reset the debugger.");
  debugger_reset();
    
  testStep("", "Run the debugger.");
  debugger_run();
  
  RunPreTs();
  ////====================================================

  testStep("STEP", "Set breakpoint in function *ResetServiceExecution*.");
  debugger_setRelativeFunctionBpAtLine("ResetServiceExecution", "0");
  debugger_run();
 
  testCaseComment("Action: ARCH_SW_DIA_0265; ARCH_SW_DIA_0266; ARCH_SW_DIA_0267; ARCH_SW_DIA_0268; ARCH_SW_DIA_0269; ARCH_SW_DIA_0270; ARCH_SW_DIA_0271");
  testStep("STEP", "Send hard reset request.");
  SendDiagnosticRequestNegativeResponse(dSoftResetRequest, dSoftResetResponse, TRUE);

  testWaitForTimeout(2000);
  testStep("STEP", "Check if breakpoint from function ResetServiceExecution was reached. --> BP was reached.");
  debugger_waitUntilBPisReached("5000");
  ExpectedTestResult(debugger_result, IS_CPU_STOP_AT_BP_SUCCESFUL, "BP is reached.");
  ////====================================================
  testCaseComment("Postcondition");
  testStep("STEP", "Return ECU to default values");
  RunPostTs();
}

testcase SW_Int_DIA_Dcm_Svc14Handler_01()
{
  //***********************************Test report header*********************************
  testReportAddMiscInfoBlock("AUTOLIV ELECTRONICS document");
  TestReportAddMiscInfo("Nightly test", "No");
  TestReportAddMiscInfo("Test type", "Requirement-Based test");
  TestReportAddMiscInfo("Regression Test", "Yes");
  TestReportAddMiscInfo("Fault injection method used", "No");
  TestReportAddMiscInfo("Resource usage evaluation", "No");
  TestReportAddMiscInfo("Priority", "No");
  TestReportAddMiscInfo("Safety relevant", "No");
  
  AddRequirementInfo("Requirement under test", "ARCH_SW_DIA_0275; ARCH_SW_DIA_0276; ARCH_SW_DIA_0277; ARCH_SW_DIA_0278; ARCH_SW_DIA_0279; ARCH_SW_DIA_0280;");
  AddRequirementInfo("ARCH_SW_DIA_0275", "Service 0x14 (Clear Diagnostic Information) will be implemented.");
  AddRequirementInfo("ARCH_SW_DIA_0276", "The ClearDiagnosticInformation service shall be available in the following sessions: Default Session (0x01), Extended Session (0x03) Supplier Session/Development Session (0x7E) Update Session (0x42)");
  AddRequirementInfo("ARCH_SW_DIA_0277", "This service shall be available with or without any form of Authentication.");
  AddRequirementInfo("ARCH_SW_DIA_0278", "The ECU shall send a Positive Response when the ClearDiagnosticInformation service is completely processed Explanation: ClearDiagnosticInformation service is considered completely processed when the data used by the ReadDiagnosticInformation (0x19) are cleared.");
  AddRequirementInfo("ARCH_SW_DIA_0279", "ResetType of the Reset service shall be: 0x03  Software Reset.");
  AddRequirementInfo("ARCH_SW_DIA_0279", "The ECU shall send a Positive Response even if no DTCs are stored in the servers memory.");
  AddRequirementInfo("ARCH_SW_DIA_0280", "Each bit mask corresponds to the following DTC Groups.");

  //***************************************************************************************

  testCaseComment("Preconditions");
  testStep("STEP", "Bench Initialization");
  
  testStep("", "Delete all breakpoint from debugger.");
  debugger_deleteAllBreakpoints();

  testStep("", "Reset the debugger.");
  debugger_reset();
    
  testStep("", "Run the debugger.");
  debugger_run();
  
  RunPreTs();
  //====================================================

  testStep("STEP", "Set breakpoint in function *Dcm_Svc14Handler*.");
  debugger_setRelativeFunctionBpAtLine("Dcm_Svc14Handler", "0");
  debugger_run();
 
  testCaseComment("Action: ARCH_SW_DIA_0275; ARCH_SW_DIA_0276; ARCH_SW_DIA_0277; ARCH_SW_DIA_0278; ARCH_SW_DIA_0279; ARCH_SW_DIA_0280;");
  testStep("STEP", "Send fault memory clear request.");
  SendDiagnosticRequestNegativeResponse(dClearAllDTCsRequest, dClearAllDTCsResponse, TRUE);

  testWaitForTimeout(2000);
  testStep("STEP", "Check if  was reached. --> BP was reached.");
  debugger_waitUntilBPisReached("5000");
  ExpectedTestResult(debugger_result, IS_CPU_STOP_AT_BP_SUCCESFUL, "BP is reached.");
  
  debugger_run();
  //====================================================
  testCaseComment("Postcondition");
  testStep("STEP", "Return ECU to default values");
  RunPostTs();
}

testcase SW_Int_DIA_Dcm_Svc19Handler_01()
{
  ////***********************************Test report header*********************************
  testReportAddMiscInfoBlock("AUTOLIV ELECTRONICS document");
  TestReportAddMiscInfo("Nightly test", "No");
  TestReportAddMiscInfo("Test type", "Requirement-Based test");
  TestReportAddMiscInfo("Regression Test", "Yes");
  TestReportAddMiscInfo("Fault injection method used", "No");
  TestReportAddMiscInfo("Resource usage evaluation", "No");
  TestReportAddMiscInfo("Priority", "No");
  TestReportAddMiscInfo("Safety relevant", "No");
  
  AddRequirementInfo("Requirement under test", "ARCH_SW_DIA_0010; ARCH_SW_DIA_0281; ARCH_SW_DIA_0282; ARCH_SW_DIA_0283, ARCH_SW_DIA_0284");
  AddRequirementInfo("ARCH_SW_DIA_0010", "Service Read DTC Information shall be implemented with subfunction 0x02 ReportDTCByStatusMask.");
  AddRequirementInfo("ARCH_SW_DIA_0281", "Service 0x19 (Read DTC Information) will be implemented for ReportDTCByStatusMask.");
  AddRequirementInfo("ARCH_SW_DIA_0282", "The ReportDTCByStatusMask shall be available in the following sessions: Update session");
  AddRequirementInfo("ARCH_SW_DIA_0283", "The byte 3 shall be reserved for the DTCStatusAvailabilityMask of the ReadDiagnosticInformation service.");
  AddRequirementInfo("ARCH_SW_DIA_0284", "DTCStatusAvailabilityMask shall be 0x39.  REVAS supported status bits are the following ones:- Test Failed (bit 0) - Confirmed DTC (bit 3) - Test Not Completed Sin Last Clear (bit 4) - Test Failed this Operation Cycle (bit 5)");

  ////***************************************************************************************

  testCaseComment("Preconditions");
  testStep("STEP", "Bench Initialization");
  
  testStep("", "Delete all breakpoint from debugger.");
  debugger_deleteAllBreakpoints();

  testStep("", "Reset the debugger.");
  debugger_reset();
    
  testStep("", "Run the debugger.");
  debugger_run();
  
  RunPreTs();
  ////====================================================

  testStep("STEP", "Set breakpoint in function *Dcm_Svc19Handler*.");
  debugger_setRelativeFunctionBpAtLine("Dcm_Svc19Handler", "0");
  debugger_run();
 
  testCaseComment("Action: ARCH_SW_DIA_0010; ARCH_SW_DIA_0281; ARCH_SW_DIA_0282; ARCH_SW_DIA_0283; ARCH_SW_DIA_0284;");
  testStep("STEP", "Send fault memory clear request.");
  SendDiagnosticRequestNegativeResponse(dReportDTCByStatusMaskRequest, dReportDTCByStatusMaskResponse, TRUE);

  testWaitForTimeout(2000);
  testStep("STEP", "Check if  was reached. --> BP was reached.");
  debugger_waitUntilBPisReached("5000");
  ExpectedTestResult(debugger_result, IS_CPU_STOP_AT_BP_SUCCESFUL, "BP is reached.");
  ////====================================================
  testCaseComment("Postcondition");
  testStep("STEP", "Return ECU to default values");
  RunPostTs();
}

testcase SW_Int_DIA_runDidFD01_SWVersionRead_01()
{
  diagRequest RBTMFL174.SW_Version_Read dSWVersionReadRequest;
  diagResponse RBTMFL174.SW_Version_Read dSWVersionReadResponse;
  //***********************************Test report header*********************************
  testReportAddMiscInfoBlock("AUTOLIV ELECTRONICS document");
  TestReportAddMiscInfo("Nightly test", "No");
  TestReportAddMiscInfo("Test type", "Requirement-Based test");
  TestReportAddMiscInfo("Regression Test", "Yes");
  TestReportAddMiscInfo("Fault injection method used", "No");
  TestReportAddMiscInfo("Resource usage evaluation", "No");
  TestReportAddMiscInfo("Priority", "No");
  TestReportAddMiscInfo("Safety relevant", "No");
  
  AddRequirementInfo("Requirement under test", "ARCH_SW_DIA_0285; ARCH_SW_DIA_0286; ARCH_SW_DIA_0287; ARCH_SW_DIA_0288; ARCH_SW_DIA_0289; ARCH_SW_DIA_0290; ARCH_SW_DIA_0291");
  AddRequirementInfo("ARCH_SW_DIA_0285", "Service 0x22 (Read Data By Identifier) will be implemented for DID FD01 (SW Version).");
  AddRequirementInfo("ARCH_SW_DIA_0286", "The Read SW Version shall be available in the following sessions:Supplier Session/Development Session (0x7E).");
  AddRequirementInfo("ARCH_SW_DIA_0287", "Service Read SW Version shall be processed with or without Any form of Authentication.");
  AddRequirementInfo("ARCH_SW_DIA_0288", "DataIdentifier of SW Version shall be 0xFD01.");
  AddRequirementInfo("ARCH_SW_DIA_0289", "Read SW Version service Response DataRecord shall have 12 bytes length.");
  AddRequirementInfo("ARCH_SW_DIA_0290", "DataRecord: SW VersionBytes SN1 to SN12 are coded in ASCII and shall reflect the SW Identification (letters and digits allowed).");
  AddRequirementInfo("ARCH_SW_DIA_0291", "SNx shall be ordered from MSB to LSB, ASCI codded i.e., bytes #4 to #15 form a string in that order that can be read directly. It will be formatted as follow:   AABCCZWH.YYYWhere:AA-reflects product code, e.g., ER for ECU PP (a.k.a. ERR)B -reflects BM identification according to current software version, e.g., 0 for PP4G ExtendedCC-reflects customer code, eg. 14 for DAI GroupZ-reflects software type code, 7 for DAI MMAW-Digit subject to change in case the SW release have been modified between SW Freeze and M2 Milestone.H-defines a FLASHED software versionYYY-reflects the software version over 3 digitsInternal SW Version for Target R5.0: ER01470H.P50.");

  //***************************************************************************************

  testCaseComment("Preconditions");
  testStep("STEP", "Bench Initialization");
  
  testStep("", "Delete all breakpoint from debugger.");
  debugger_deleteAllBreakpoints();

  testStep("", "Reset the debugger.");
  debugger_reset();
    
  testStep("", "Run the debugger.");
  debugger_run();
  
  RunPreTs();
  //====================================================

  testStep("STEP", "Set breakpoint in function *DIA_runDidFD01_SWVersionRead*.");
  debugger_setRelativeFunctionBpAtLine("DIA_runDidFD01_SWVersionRead", "4");
  debugger_run();
  
  EnterDiagnosticSession("development");
 
  testCaseComment("Action: ARCH_SW_DIA_0285; ARCH_SW_DIA_0286; ARCH_SW_DIA_0287; ARCH_SW_DIA_0288; ARCH_SW_DIA_0289; ARCH_SW_DIA_0290; ARCH_SW_DIA_0291");
  testStep("STEP", "Send diag request for 22 0242 and wait for timeout error --> Timeout received.");
  SendDiagnosticRequestNegativeResponse(dSWVersionReadRequest, dSWVersionReadResponse, TRUE);

  testWaitForTimeout(2000);
  testStep("STEP", "Check if breakpoint from function DIA_runDidFD01_SWVersionRead was reached. --> BP was reached.");
  debugger_waitUntilBPisReached("5000");
  ExpectedTestResult(debugger_result, IS_CPU_STOP_AT_BP_SUCCESFUL, "BP is reached.");
  
  testStep("STEP", "Evaluate Data Record --> Variable was read.");
  debugger_readLocalVariable("Data");
  ExpectedTestResult(debugger_result, "Data", "Variable read.");

  debugger_run();
  //====================================================
  testCaseComment("Postcondition");
  testStep("STEP", "Return ECU to default values");
  RunPostTs();
}

testcase SW_Int_DIA_Dcm_Service27Processor_01()
{
  //***********************************Test report header*********************************
  testReportAddMiscInfoBlock("AUTOLIV ELECTRONICS document");
  TestReportAddMiscInfo("Nightly test", "No");
  TestReportAddMiscInfo("Test type", "Requirement-Based test");
  TestReportAddMiscInfo("Regression Test", "Yes");
  TestReportAddMiscInfo("Fault injection method used", "No");
  TestReportAddMiscInfo("Resource usage evaluation", "No");
  TestReportAddMiscInfo("Priority", "No");
  TestReportAddMiscInfo("Safety relevant", "No");
  
  AddRequirementInfo("Requirement under test", "ARCH_SW_DIA_0295; ARCH_SW_DIA_0296; ARCH_SW_DIA_0297; ARCH_SW_DIA_0298; ARCH_SW_DIA_0299; ARCH_SW_DIA_0300; ARCH_SW_DIA_0301; ARCH_SW_DIA_0302; ARCH_SW_DIA_0303");
  AddRequirementInfo("ARCH_SW_DIA_0295", "Service 0x27 (Security Access) will be implemented for Get Seed and Send Key.");
  AddRequirementInfo("ARCH_SW_DIA_0296", "The Security Access service shall only be available in the following sessions:Programming Session (0x02).");
  AddRequirementInfo("ARCH_SW_DIA_0297", "Security Access service shall be available under the following forms of Authentication:");
  AddRequirementInfo("ARCH_SW_DIA_0298", "SecurityAccessType of the SecurityAccess service shall be 0x11 for Get Programming Seed.");
  AddRequirementInfo("ARCH_SW_DIA_0299", "Bytes #2-#3:  SecurityAccessType shall be: 0x11.");
  AddRequirementInfo("ARCH_SW_DIA_0300", "Bytes #3-#66:  Shall contain SecuritySeed.");
  AddRequirementInfo("ARCH_SW_DIA_0301", "SecurityAccessType of the SecurityAccess service shall be 0x12 for Get Programming Key.");
  AddRequirementInfo("ARCH_SW_DIA_0302", "The bytes from 3 to 66 shall be reserved for the SecurityKey of the SecurityAccess service.");
  AddRequirementInfo("ARCH_SW_DIA_0303", "Bytes #2-#3:  SecurityAccessType shall be: 0x12.");

  //***************************************************************************************

  testCaseComment("Preconditions");
  testStep("STEP", "Bench Initialization");
  
  testStep("", "Delete all breakpoint from debugger.");
  debugger_deleteAllBreakpoints();

  testStep("", "Reset the debugger.");
  debugger_reset();
    
  testStep("", "Run the debugger.");
  debugger_run();
  
  RunPreTs();
  //====================================================

  EnterDiagnosticSession("development");
  
  testStep("STEP", "Set breakpoint in function *Dcm_Service27Processor*.");
  debugger_setRelativeFunctionBpAtLine("Dcm_Service27Processor", "0");
  debugger_run();
 
  testCaseComment("Action: ARCH_SW_DIA_0295; ARCH_SW_DIA_0296; ARCH_SW_DIA_0297; ARCH_SW_DIA_0298; ARCH_SW_DIA_0299; ARCH_SW_DIA_0300; ARCH_SW_DIA_0301; ARCH_SW_DIA_0302; ARCH_SW_DIA_0303");
  testStep("STEP", "Send diag request for security access --> Timeout received.");
  SendDiagnosticRequestNegativeResponse(dSendKeyReprogrammingRequest, dSendKeyReprogrammingResponse, TRUE);

  testWaitForTimeout(2000);
  testStep("STEP", "Check if breakpoint from function Dcm_Service27Processor was reached. --> BP was reached.");
  debugger_waitUntilBPisReached("5000");
  ExpectedTestResult(debugger_result, IS_CPU_STOP_AT_BP_SUCCESFUL, "BP is reached.");

  debugger_run();
  //====================================================
  testCaseComment("Postcondition");
  testStep("STEP", "Return ECU to default values");
  RunPostTs();
}

testcase SW_Int_DataServices_Current_Operating_Time_Read_Current_Operating_Time_ReadData_01()
{
  ////***********************************Test report header*********************************
  testReportAddMiscInfoBlock("AUTOLIV ELECTRONICS document");
  TestReportAddMiscInfo("Nightly test", "No");
  TestReportAddMiscInfo("Test type", "Requirement-Based test");
  TestReportAddMiscInfo("Regression Test", "Yes");
  TestReportAddMiscInfo("Fault injection method used", "No");
  TestReportAddMiscInfo("Resource usage evaluation", "No");
  TestReportAddMiscInfo("Priority", "No");
  TestReportAddMiscInfo("Safety relevant", "No");
  
  AddRequirementInfo("Requirement under test", "ARCH_SW_DIA_0325; ARCH_SW_DIA_0326; ARCH_SW_DIA_0327; ARCH_SW_DIA_0467; ARCH_SW_DIA_0468; ARCH_SW_DIA_0469; ARCH_SW_DIA_0470");
  AddRequirementInfo("ARCH_SW_DIA_0467", "DataIdentifier shall be 0x0133");
  AddRequirementInfo("ARCH_SW_DIA_0468", "The DID shall be available in the following sessions:?Default Session?Programming?Extended session?Update Session?Development Session");
  AddRequirementInfo("ARCH_SW_DIA_0469", "This service shall be available under the following forms of Authentication:?Supplier?Development ENHANCED ?Production ?After-Sales ENHANCED ?After-Sales ?Internal Diagnostic Test Tool");
  AddRequirementInfo("ARCH_SW_DIA_0326", "Response data shall be 5 bytes long.");
  AddRequirementInfo("ARCH_SW_DIA_0470", "Bytes 0-3 of the positive response shall represent the Current Operating Time.");
  AddRequirementInfo("ARCH_SW_DIA_0327", "Byte 4 of the positive response shall represent the Operating Time Status, defined as follows:?	Bits 0  3: converted value based on timeBaseStatus");

  ////***************************************************************************************

  testCaseComment("Preconditions");
  testStep("STEP", "Bench Initialization");
  
  testStep("", "Delete all breakpoint from debugger.");
  debugger_deleteAllBreakpoints();

  testStep("", "Reset the debugger.");
  debugger_reset();
    
  testStep("", "Run the debugger.");
  debugger_run();
  
  RunPreTs();
  ////====================================================

  testStep("STEP", "Set breakpoint in function *DataServices_Current_Operating_Time_Read_Current_Operating_Time_ReadData*.");
  debugger_setRelativeFunctionBpAtLine("DataServices_Current_Operating_Time_Read_Current_Operating_Time_ReadData", "34");
  debugger_run();
 
  testCaseComment("Action: ARCH_SW_DIA_0325; ARCH_SW_DIA_0326; ARCH_SW_DIA_0327; ARCH_SW_DIA_0467; ARCH_SW_DIA_0468; ARCH_SW_DIA_0469; ARCH_SW_DIA_0470");
  testStep("STEP", "Send diag request for security access --> Timeout received.");
  SendDiagnosticRequestNegativeResponse(dCurrentOperatingTimeReadRequest, dCurrentOperatingTimeReadResponse, TRUE);

  testWaitForTimeout(2000);
  testStep("STEP", "Check if breakpoint from function DataServices_Current_Operating_Time_Read_Current_Operating_Time_ReadData was reached. --> BP was reached.");
  debugger_waitUntilBPisReached("5000");
  ExpectedTestResult(debugger_result, IS_CPU_STOP_AT_BP_SUCCESFUL, "BP is reached.");

  ////====================================================
  testCaseComment("Postcondition");
  testStep("STEP", "Return ECU to default values");
  RunPostTs();
}

testcase SW_Int_DIA_runDid00140_Obsolence_Data_Current_Value_Read_01()
{
  ////***********************************Test report header*********************************
  testReportAddMiscInfoBlock("AUTOLIV ELECTRONICS document");
  TestReportAddMiscInfo("Nightly test", "No");
  TestReportAddMiscInfo("Test type", "Requirement-Based test");
  TestReportAddMiscInfo("Regression Test", "Yes");
  TestReportAddMiscInfo("Fault injection method used", "No");
  TestReportAddMiscInfo("Resource usage evaluation", "No");
  TestReportAddMiscInfo("Priority", "No");
  TestReportAddMiscInfo("Safety relevant", "No");
  
  AddRequirementInfo("Requirement under test", "ARCH_SW_DIA_0330; ARCH_SW_DIA_0331; ARCH_SW_DIA_0332; ARCH_SW_DIA_0333");
  AddRequirementInfo("ARCH_SW_DIA_0330", "DataIdentifier shall be 0x0133");
  AddRequirementInfo("ARCH_SW_DIA_0331", "The Read Obsolescence Data service shall be available in the following sessions:Default Session (0x01)Programming (0x02)Extended Session (0x03)Supplier Session/Development Session (0x7E)Update Session (0x42)");
  AddRequirementInfo("ARCH_SW_DIA_0332", "This service shall be available under the following forms of Authentication:?Supplier?Development ENHANCED ?Production ?After-Sales ENHANCED ?After-Sales ?Internal Diagnostic Test Tool");
  AddRequirementInfo("ARCH_SW_DIA_0333", "DataIdentifier of the Read Obsolescence Data shall be: 0x0140.");

  ////***************************************************************************************

  testCaseComment("Preconditions");
  testStep("STEP", "Bench Initialization");
  
  testStep("", "Delete all breakpoint from debugger.");
  debugger_deleteAllBreakpoints();

  testStep("", "Reset the debugger.");
  debugger_reset();
    
  testStep("", "Run the debugger.");
  debugger_run();
  
  RunPreTs();
  ////====================================================

  testStep("STEP", "Set breakpoint in function *DIA_runDid00140_Obsolescence_Data_BSR_Current_Value_Read*.");
  debugger_setRelativeFunctionBpAtLine("DIA_runDid00140_Obsolescence_Data_BSR_Current_Value_Read", "8");
  debugger_run();
 
  testCaseComment("Action: ARCH_SW_DIA_0330; ARCH_SW_DIA_0331; ARCH_SW_DIA_0332; ARCH_SW_DIA_0333");
  testStep("STEP", "Send diag request for 01 40 --> Timeout received.");
  SendDiagnosticRequestNegativeResponse(dObsolenceDataReadRequest, dObsolenceDataReadResponse, TRUE);

  testWaitForTimeout(2000);
  testStep("STEP", "Check if breakpoint from function DataServices_Current_Operating_Time_Read_Current_Operating_Time_ReadData was reached. --> BP was reached.");
  debugger_waitUntilBPisReached("5000");
  ExpectedTestResult(debugger_result, IS_CPU_STOP_AT_BP_SUCCESFUL, "BP is reached.");

  testStep("STEP", "Read stObsolescenseData --> Variable read.");
  debugger_readLocalVariable("stObsolescenseData.BSR.Current_Value");
  ExpectedTestResult(debugger_result, "stObsolescenseData", "Variable read.");

  ////====================================================
  testCaseComment("Postcondition");
  testStep("STEP", "Return ECU to default values");
  RunPostTs();
}

testcase SW_Int_DIA_runDid00140_Obsolence_Data_Threshold_Read_01()
{
  
  diagRequest RBTMFL174.Obsolescence_Data_Read dObsolenceDataReadRequest;
  diagResponse RBTMFL174.Obsolescence_Data_Read dObsolenceDataReadResponse;
  //***********************************Test report header*********************************
  testReportAddMiscInfoBlock("AUTOLIV ELECTRONICS document");
  TestReportAddMiscInfo("Nightly test", "No");
  TestReportAddMiscInfo("Test type", "Requirement-Based test");
  TestReportAddMiscInfo("Regression Test", "Yes");
  TestReportAddMiscInfo("Fault injection method used", "No");
  TestReportAddMiscInfo("Resource usage evaluation", "No");
  TestReportAddMiscInfo("Priority", "No");
  TestReportAddMiscInfo("Safety relevant", "No");
  
  AddRequirementInfo("Requirement under test", "ARCH_SW_DIA_0330; ARCH_SW_DIA_0334; ARCH_SW_DIA_0335");
  AddRequirementInfo("ARCH_SW_DIA_0330", "DataIdentifier shall be 0x0140");
  AddRequirementInfo("ARCH_SW_DIA_0334", "Response data length shall be 24 bytes long");
  AddRequirementInfo("ARCH_SW_DIA_0335", "Read Obsolescence Data service shall return the number of remaing BSR(Comfort), Low Force, High Force, Max Force possible activation.");
  //***************************************************************************************

  testCaseComment("Preconditions");
  testStep("STEP", "Bench Initialization");
  
  testStep("", "Delete all breakpoint from debugger.");
  debugger_deleteAllBreakpoints();

  testStep("", "Reset the debugger.");
  debugger_reset();
    
  testStep("", "Run the debugger.");
  debugger_run();
  
  RunPreTs();
  //====================================================

  testStep("STEP", "Set breakpoint in function *DIA_runDid00140_Obsolescence_Data_PRE_SAFE_Lvl_4_5_Treshold_Yellow_To_Red_Read*.");
  debugger_setRelativeFunctionBpAtLine("DIA_runDid00140_Obsolescence_Data_PRE_SAFE_Lvl_4_5_Treshold_Yellow_To_Red_Read", "0");
  debugger_run();
 
  testCaseComment("Action: ARCH_SW_DIA_0330; ARCH_SW_DIA_0334; ARCH_SW_DIA_0335");
  testStep("STEP", "Send diag request for 01 40 --> Timeout received.");
  SendDiagnosticRequestNegativeResponse(dObsolenceDataReadRequest, dObsolenceDataReadResponse, TRUE);
  
  testWaitForTimeout(2000);
  testStep("STEP", "Evaluate response data lenght. --> response data lenght is 24.");
  debugger_waitUntilBPisReached("5000");
  ExpectedTestResult(debugger_result, IS_CPU_STOP_AT_BP_SUCCESFUL, "BP is reached.");

  //====================================================
  testCaseComment("Postcondition");
  testStep("STEP", "Return ECU to default values");
  RunPostTs();
}

testcase SW_Int_DIA_DataServices_CPU_Load_Read_CPU_load_histograms_ReadData_01()
{
  ////***********************************Test report header*********************************
  testReportAddMiscInfoBlock("AUTOLIV ELECTRONICS document");
  TestReportAddMiscInfo("Nightly test", "No");
  TestReportAddMiscInfo("Test type", "Requirement-Based test");
  TestReportAddMiscInfo("Regression Test", "Yes");
  TestReportAddMiscInfo("Fault injection method used", "No");
  TestReportAddMiscInfo("Resource usage evaluation", "No");
  TestReportAddMiscInfo("Priority", "No");
  TestReportAddMiscInfo("Safety relevant", "No");
  
  AddRequirementInfo("Requirement under test", "ARCH_SW_DIA_0340; ARCH_SW_DIA_0341; ARCH_SW_DIA_0342; ARCH_SW_DIA_0343; ARCH_SW_DIA_0344");
  AddRequirementInfo("ARCH_SW_DIA_0340", "Service 0x22 (Read Data By Identifier) will be implemented for DID 01E1 (CPU Load).");
  AddRequirementInfo("ARCH_SW_DIA_0341", "The Read CPU Load service shall be available in the following sessions:Default Session (0x01)Programming (0x02) Extended Session (0x03) Supplier Session/Development Session (0x7E) Update Session (0x42)");
  AddRequirementInfo("ARCH_SW_DIA_0342", "Read CPU Load service shall be available under the following forms of Authentication:SupplierDevelopment ENHANCED Internal Diagnostic Test Tool ");
  AddRequirementInfo("ARCH_SW_DIA_0343", "ARCH_SW_DIA_0343	DataIdentifier of the Read CPU Load shall be: 0x01E1.");
  AddRequirementInfo("ARCH_SW_DIA_0344", "Response data length shall be 12 bytes long");


  ////***************************************************************************************

  testCaseComment("Preconditions");
  testStep("STEP", "Bench Initialization");
  
  testStep("", "Delete all breakpoint from debugger.");
  debugger_deleteAllBreakpoints();

  testStep("", "Reset the debugger.");
  debugger_reset();
    
  testStep("", "Run the debugger.");
  debugger_run();
  
  RunPreTs();
  ////====================================================

  testStep("STEP", "Set breakpoint in function *DataServices_CPU_Load_Read_CPU_load_histograms_ReadData*.");
  debugger_setRelativeFunctionBpAtLine("DataServices_CPU_Load_Read_CPU_load_histograms_ReadData", "21");
  debugger_run();
 
  testCaseComment("Action: ARCH_SW_DIA_0340; ARCH_SW_DIA_0341; ARCH_SW_DIA_0342; ARCH_SW_DIA_0343; ARCH_SW_DIA_0344");
  testStep("STEP", "Send diag request for 22 01 E1 --> Timeout received.");
  SendDiagnosticRequestNegativeResponse(dCPULoadReadRequest, dCPULoadReadResponse, TRUE);

  testWaitForTimeout(2000);
  testStep("STEP", "Check if breakpoint from function DataServices_CPU_Load_Read_CPU_load_histograms_ReadData was reached. --> BP was reached.");
  debugger_waitUntilBPisReached("5000");
  ExpectedTestResult(debugger_result, IS_CPU_STOP_AT_BP_SUCCESFUL, "BP is reached.");

  testStep("STEP", "Read Data variable --> Variable read.");
  debugger_readLocalVariable("*Data");
  ExpectedTestResult(debugger_result, "*Data", "Variable read.");

  ////====================================================
  testCaseComment("Postcondition");
  testStep("STEP", "Return ECU to default values");
  RunPostTs();
}

testcase SW_Int_DIA_DataServices_E2E_Timing_Read_Maximum_ReadDataLength_01()
{
  ////***********************************Test report header*********************************
  testReportAddMiscInfoBlock("AUTOLIV ELECTRONICS document");
  TestReportAddMiscInfo("Nightly test", "No");
  TestReportAddMiscInfo("Test type", "Requirement-Based test");
  TestReportAddMiscInfo("Regression Test", "Yes");
  TestReportAddMiscInfo("Fault injection method used", "No");
  TestReportAddMiscInfo("Resource usage evaluation", "No");
  TestReportAddMiscInfo("Priority", "No");
  TestReportAddMiscInfo("Safety relevant", "No");
  
  AddRequirementInfo("Requirement under test", "ARCH_SW_DIA_0345; ARCH_SW_DIA_0346; ARCH_SW_DIA_0347; ARCH_SW_DIA_0348; ARCH_SW_DIA_0349");
  AddRequirementInfo("ARCH_SW_DIA_0345", "Service 0x22 (Read Data By Identifier) will be implemented for DID 01E2 (E2E Timing).");
  AddRequirementInfo("ARCH_SW_DIA_0346", "The Read E2E Timing service shall be available in the following sessions:Default Session (0x01)Programming (0x02) Extended Session (0x03) Supplier Session/Development Session (0x7E) Update Session (0x42)");
  AddRequirementInfo("ARCH_SW_DIA_0347", "Read E2E Timing service shall be available under the following forms of Authentication:SupplierDevelopment ENHANCEDInternal Diagnostic Test Tool");
  AddRequirementInfo("ARCH_SW_DIA_0348", "DataIdentifier of the Read E2E Timing shall be: 0x01E2");
  AddRequirementInfo("ARCH_SW_DIA_0349", "Response data length shall be 2 bytes long: Bytes #2-#3:  DataIdentifier of the Read E2E Timing shall be: 0x01E2");

  ////***************************************************************************************

  testCaseComment("Preconditions");
  testStep("STEP", "Bench Initialization");
  
  testStep("", "Delete all breakpoint from debugger.");
  debugger_deleteAllBreakpoints();

  testStep("", "Reset the debugger.");
  debugger_reset();
    
  testStep("", "Run the debugger.");
  debugger_run();
  
  RunPreTs();
  ////====================================================

  testStep("STEP", "Set breakpoint in function *DataServices_E2E_Timing_Read_Maximum_ReadData*.");
  debugger_setRelativeFunctionBpAtLine("DataServices_E2E_Timing_Read_Maximum_ReadData", "8");
  debugger_run();
 
  testCaseComment("Action: ARCH_SW_DIA_0345; ARCH_SW_DIA_0346; ARCH_SW_DIA_0347; ARCH_SW_DIA_0348; ARCH_SW_DIA_0349");
  testStep("STEP", "Send diag request for 22 01 E2 --> Timeout received.");
  SendDiagnosticRequestNegativeResponse(dE2ETimingReadRequest, dE2ETimingReadResponse, TRUE);

  testWaitForTimeout(2000);
  testStep("STEP", "Check if breakpoint from function DataServices_E2E_Timing_Read_Maximum_ReadData was reached. --> BP was reached.");
  debugger_waitUntilBPisReached("5000");
  ExpectedTestResult(debugger_result, IS_CPU_STOP_AT_BP_SUCCESFUL, "BP is reached.");

  testStep("STEP", "Read Data variable --> Variable read.");
  debugger_readLocalVariable("*Data");
  ExpectedTestResult(debugger_result, "Data", "Variable read.");

  ////====================================================
  testCaseComment("Postcondition");
  testStep("STEP", "Return ECU to default values");
  RunPostTs();
}

testcase SW_Int_DIA_DataServices_Stack_Load_Read_Maximum_ReadData_01()
{
  ////***********************************Test report header*********************************
  testReportAddMiscInfoBlock("AUTOLIV ELECTRONICS document");
  TestReportAddMiscInfo("Nightly test", "No");
  TestReportAddMiscInfo("Test type", "Requirement-Based test");
  TestReportAddMiscInfo("Regression Test", "Yes");
  TestReportAddMiscInfo("Fault injection method used", "No");
  TestReportAddMiscInfo("Resource usage evaluation", "No");
  TestReportAddMiscInfo("Priority", "No");
  TestReportAddMiscInfo("Safety relevant", "No");
  
  AddRequirementInfo("Requirement under test", "ARCH_SW_DIA_0350; ARCH_SW_DIA_0351; ARCH_SW_DIA_0352; ARCH_SW_DIA_0353; ARCH_SW_DIA_0354");
  AddRequirementInfo("ARCH_SW_DIA_0350", "Service 0x22 (Read Data By Identifier) will be implemented for DID 01E3 (Stack Load).");
  AddRequirementInfo("ARCH_SW_DIA_0351", "The Read E2E Timing service shall be available in the following sessions:Default Session (0x01)Programming (0x02) Extended Session (0x03) Supplier Session/Development Session (0x7E) Update Session (0x42)");
  AddRequirementInfo("ARCH_SW_DIA_0352", "Read E2E Timing service shall be available under the following forms of Authentication:SupplierDevelopment ENHANCEDInternal Diagnostic Test Tool");
  AddRequirementInfo("ARCH_SW_DIA_0353", "DataIdentifier of the Read E2E Timing shall be: 0x01E3");
  AddRequirementInfo("ARCH_SW_DIA_0354", "Response data length shall be 2 bytes long:Bytes #2-#3:  DataIdentifier of the Read Stack Load shall be: 0x01E3 Byte #4 = Task Stack ID [1byte][0x00] Core 1Byte #5 = Maximum[1 byte]Note: Full Response length = 3 bytes + Response data length");

  ////***************************************************************************************

  testCaseComment("Preconditions");
  testStep("STEP", "Bench Initialization");
  
  testStep("", "Delete all breakpoint from debugger.");
  debugger_deleteAllBreakpoints();

  testStep("", "Reset the debugger.");
  debugger_reset();
    
  testStep("", "Run the debugger.");
  debugger_run();
  
  RunPreTs();
  ////====================================================

  testStep("STEP", "Set breakpoint in function *DataServices_Stack_Load_Read_Maximum_ReadData*.");
  debugger_setRelativeFunctionBpAtLine("DataServices_Stack_Load_Read_Maximum_ReadData", "22");
  debugger_run();
 
  testCaseComment("Action: ARCH_SW_DIA_0350; ARCH_SW_DIA_0351; ARCH_SW_DIA_0352; ARCH_SW_DIA_0353; ARCH_SW_DIA_0354");
  testStep("STEP", "Send diag request for 22 01 E3 --> Timeout received.");
  SendDiagnosticRequestNegativeResponse(dStackLoadReadRequest, dStackLoadReadResponse, TRUE);

  testWaitForTimeout(2000);
  testStep("STEP", "Check if breakpoint from function DataServices_Stack_Load_Read_Maximum_ReadData was reached. --> BP was reached.");
  debugger_waitUntilBPisReached("5000");
  ExpectedTestResult(debugger_result, IS_CPU_STOP_AT_BP_SUCCESFUL, "BP is reached.");

  testStep("STEP", "Read Data variable --> Variable read.");
  debugger_readLocalVariable("*Data");
  ExpectedTestResult(debugger_result, "Data", "Variable read.");

  ////====================================================
  testCaseComment("Postcondition");
  testStep("STEP", "Return ECU to default values");
  RunPostTs();
}

testcase SW_Int_DIA_DataServices_Memory_Usage_Cycles_Read_Memory_Usage_Cycles_ReadData_01()
{
  ////***********************************Test report header*********************************
  testReportAddMiscInfoBlock("AUTOLIV ELECTRONICS document");
  TestReportAddMiscInfo("Nightly test", "No");
  TestReportAddMiscInfo("Test type", "Requirement-Based test");
  TestReportAddMiscInfo("Regression Test", "Yes");
  TestReportAddMiscInfo("Fault injection method used", "No");
  TestReportAddMiscInfo("Resource usage evaluation", "No");
  TestReportAddMiscInfo("Priority", "No");
  TestReportAddMiscInfo("Safety relevant", "No");
  
  AddRequirementInfo("Requirement under test", "ARCH_SW_DIA_0355; ARCH_SW_DIA_0356; ARCH_SW_DIA_0357; ARCH_SW_DIA_0358; ARCH_SW_DIA_0359");
  AddRequirementInfo("ARCH_SW_DIA_0355", "Service 0x22 (Read Data By Identifier) will be implemented for DID 01E4 (Memory Usage Cycles)");
  AddRequirementInfo("ARCH_SW_DIA_0356", "The Read E2E Timing service shall be available in the following sessions:Default Session (0x01)Programming (0x02) Extended Session (0x03) Supplier Session/Development Session (0x7E) Update Session (0x42)");
  AddRequirementInfo("ARCH_SW_DIA_0357", "Read E2E Timing service shall be available under the following forms of Authentication:SupplierDevelopment ENHANCEDInternal Diagnostic Test Tool");
  AddRequirementInfo("ARCH_SW_DIA_0358", "DataIdentifier of the Read E2E Timing shall be: 0x01E4");
  AddRequirementInfo("ARCH_SW_DIA_0359", "Response data length shall be 5 bytes long:Bytes #2-#3:  DataIdentifier of the Read Memory usage Cycles shall be: 0x01E4 Byte #4 = Memory ID [1byte]:[0x00] Please insert name of memory (e.g. Data Flash Bank0)[0x01] Please insert name of memory (e.g. Data Flash Bank0)[0x02] Please insert name of memory (e.g. Data Flash Bank0)[0x0] Please insert name of memory (e.g. Data Flash Bank0)Bytes #5 - #8= Write Cycles [4 bytes]");

  ////***************************************************************************************

  testCaseComment("Preconditions");
  testStep("STEP", "Bench Initialization");
  
  testStep("", "Delete all breakpoint from debugger.");
  debugger_deleteAllBreakpoints();

  testStep("", "Reset the debugger.");
  debugger_reset();
    
  testStep("", "Run the debugger.");
  debugger_run();
  
  RunPreTs();
  ////====================================================

  testStep("STEP", "Set breakpoint in function *DataServices_Memory_Usage_Cycles_Read_Memory_Usage_Cycles_ReadData*.");
  debugger_setRelativeFunctionBpAtLine("DataServices_Memory_Usage_Cycles_Read_Memory_Usage_Cycles_ReadData", "32");
  debugger_run();
 
  testCaseComment("Action: ARCH_SW_DIA_0355; ARCH_SW_DIA_0356; ARCH_SW_DIA_0357; ARCH_SW_DIA_0358; ARCH_SW_DIA_0359");
  testStep("STEP", "Send diag request for 22 01 E4 --> Timeout received.");
  SendDiagnosticRequestNegativeResponse(dMemoryWriteCyclesReadRequest, dMemoryWriteCyclesReadResponse, TRUE);

  testWaitForTimeout(2000);
  testStep("STEP", "Check if breakpoint from function DataServices_Memory_Usage_Cycles_Read_Memory_Usage_Cycles_ReadData was reached. --> BP was reached.");
  debugger_waitUntilBPisReached("5000");
  ExpectedTestResult(debugger_result, IS_CPU_STOP_AT_BP_SUCCESFUL, "BP is reached.");

  testStep("STEP", "Read Data variable --> Variable read.");
  debugger_readLocalVariable("*Data");
  ExpectedTestResult(debugger_result, "Data", "Variable read.");

  ////====================================================
  testCaseComment("Postcondition");
  testStep("STEP", "Return ECU to default values");
  RunPostTs();
}

testcase SW_Int_DIA_DIA_runDid0200_CAN_input_Read_Neues_Bitfeld_ReadData_01()
{
  //***********************************Test report header*********************************
  testReportAddMiscInfoBlock("AUTOLIV ELECTRONICS document");
  TestReportAddMiscInfo("Nightly test", "No");
  TestReportAddMiscInfo("Test type", "Requirement-Based test");
  TestReportAddMiscInfo("Regression Test", "Yes");
  TestReportAddMiscInfo("Fault injection method used", "No");
  TestReportAddMiscInfo("Resource usage evaluation", "No");
  TestReportAddMiscInfo("Priority", "No");
  TestReportAddMiscInfo("Safety relevant", "No");
  
  AddRequirementInfo("Requirement under test", "ARCH_SW_DIA_0360; ARCH_SW_DIA_0361; ARCH_SW_DIA_0362; ARCH_SW_DIA_0363; ARCH_SW_DIA_0364; ARCH_SW_DIA_0365; ARCH_SW_DIA_0441; ARCH_SW_DIA_0442; ARCH_SW_DIA_0443; ARCH_SW_DIA_0447; ARCH_SW_DIA_0448; ARCH_SW_DIA_0449; ARCH_SW_DIA_0453; ARCH_SW_DIA_0454; ARCH_SW_DIA_0455; ARCH_SW_DIA_0456; ARCH_SW_DIA_0457; ARCH_SW_DIA_0458; ARCH_SW_DIA_0450; ARCH_SW_DIA_0451; ARCH_SW_DIA_0452; ARCH_SW_DIA_0444; ARCH_SW_DIA_0445; ARCH_SW_DIA_0446");
  AddRequirementInfo("ARCH_SW_DIA_0360", "Service 0x22 (Read Data By Identifier) will be implemented for DID 0200 (CAN Input)");
  AddRequirementInfo("ARCH_SW_DIA_0361", "The Read CAN Input service shall be available in the following sessions:Default Session (0x01)Extended Session (0x03)Supplier Session/Development Session (0x7E)Update Session (0x42)");
  AddRequirementInfo("ARCH_SW_DIA_0362", "Read CAN Input service shall be available under the following forms of Authentication:SupplierDevelopment ENHANCEDProductionAfter-Sales ENHANCEDAfter-SalesAfter-Sales BASICInternal Diagnostic Test ToolePTI Test Tool");
  AddRequirementInfo("ARCH_SW_DIA_0363", "DataIdentifier of the Read CAN Input shall be: 0x0200");
  AddRequirementInfo("ARCH_SW_DIA_0364", "Response data length shall be 9 bytes long: Bytes #2-#3: DataIdentifier of the Read CAN Input shall be: 0x0200 Byte #4 : bits 0-2: Ignition switch state (Isw_Stat_ST3 signal) bit 3 : Reserved (set to 0) bits 4-5 : Buckle switch driver state (Bckl_Sw_D_Stat_ST3) bits 6-7 : Buckle switch front passenger state (Bckl_Sw_FP_Stat_ST3) Byte #5 : bits 0-1 : Presafe enabled (Presf_Enbl_ST3) bits 2-3 : Presafe actuator RBTM_FL tensioning suppress request (PresfAct_TensSupp_Rq_ST3) bits 4-7 : Presafe level (Presf_Lvl_ST3) Byte #6 : bits 0-1 : Belt hand over left state (BeltHdOvr_FL_Stat_ST3) bits 2-3 : Belt hand over right state (BeltHdOvr_FR_Stat_ST3) bits 4-6 : Engine start state (PT4_PTCoor_EngStartPN14_Stat_ST3) bit 7 : Reserved (set to 0) Byte #7 : bit 0 : Impact event X (Impact_X_ST3) bit 1 : Reserved (set to 0) bit 2 : Turn over event 1 RO_type1 (Impact_RO_type1_ST3) bit 3 : Turn over event 2 RO_type2 (Impact_RO_type2_ST3) bits 4-5 : Steering variant (EVC_List03_StStyle_ST3) bits 6-7 : Reserved (set to 0) Byte #8 : bits 0-7 : Supply battery voltage ( ngaged ng of PN14_SupBat_Volt_ST3 signal with 0.1V resolution) Byte #9 : bits 0-2: Supply battery cutoff switch status ((PN14_DDP_Sw_Stat_ST3) bits3-5 : Powernet Production mode status (PN14_ProdMd_Stat_ST3) bits 6-7 : Powernet transport mode status (PN14_TransMd_Stat_ST3) Byte #10 : bits 0-1: Belt slack decreasing mode request (BltSlckDec_Md_Rq_HU_ST3) bits 2-3 : Powertrain ready (PT4_PTCoor_PT_Rdy_ST3) bits 4-7 : Reverse gear ngaged (PT4_PTCoor_DrvPosn_Stat_ST3) Byte #11 : bits 0-5: RBTMFL_SP_Lvl_Rq_ST35 bits 6-7: DidA external tester present (DidA_ExtTest_Pres_ST3) Byte #12 : bits 0-5: RBTMFR_SP_Lvl_Rq_ST35 bits 6-7: Presafe acceleration threshold (PresfAccelReset_NotExcd_ST3) Note: Full Response length = 3 bytes + Response data length ");
  AddRequirementInfo("ARCH_SW_DIA_0365", "Read CAN Input service shall return the current values of the mentioned CAN signals.");
  AddRequirementInfo("ARCH_SW_DIA_0441", "Signal PT4_PTCoor_EngStartPN14_Stat_ST3Position: ?	StartByte = 4; ?	StartBit = 4;?	SignalLength = 3;Note:StartByte starts from 1 and StartBit starts from 0.");
  AddRequirementInfo("ARCH_SW_DIA_0442", "Signal Values: 0 = NO_COMBUSTIONSTART_RQ (No combustion start required) 1 = CUSTOMER_START_RQ(Customer start required) 2 = AUTO_START_NO_PN_SUP_RQ(Automatic start without Powernet support required) 3 = AUTO_START_PN_SUP_RQ(Automatic start with Powernet support required) 7 = Signal not Available (SNA) ");
  AddRequirementInfo("ARCH_SW_DIA_0443", "PT4_PTCoor_EngStartPN14_Stat_ST3 signal shall be read by both Front LEFT ECU and Front RIGHT ECU and reported via CAN Input Service (0x0200)");
  AddRequirementInfo("ARCH_SW_DIA_0444", "Signal DidA_ExtTest_Pres_ST3 Position: ? StartByte = 1 ? StartBit = 2; ? SignalLength = 2 Note:StartByte starts from 1 and StartBit starts from 0 ");
  AddRequirementInfo("ARCH_SW_DIA_0445", "Signal Values:0x01= FALSE0x02 = TRUE0x03 = default / Signal not Available (SNA)");
  AddRequirementInfo("ARCH_SW_DIA_0446", "DidA_ExtTest_Pres_ST3 signal shall be read by both Front LEFT ECU and Front RIGHT ECU and reported via CAN Input Service (0x0200)");
  AddRequirementInfo("ARCH_SW_DIA_0447", "Signal PN14_DDP_Sw_Stat_ST3 Position: ? StartByte = 1 ? StartBit = 2; ? SignalLength = 3 ? Note:StartByte starts from 1 and StartBit starts from 0 ");
  AddRequirementInfo("ARCH_SW_DIA_0448", "Signal Values: 0 = CLS TDP (switch is closed) 1 = PRE_RESET (Pre-Reset warning) 2 = RESET (Reset active) 3 = PRE_OPN (Pre-Open warning) 4 = OPN (TDP switch is open) 7 = default / Signal not Available (SNA)  ");
  AddRequirementInfo("ARCH_SW_DIA_0449", "PN14_DDP_Sw_Stat_ST3 signal shall be read by both Front LEFT ECU and Front RIGHT ECU and reported via CAN Input Service (0x0200)");
  AddRequirementInfo("ARCH_SW_DIA_0450", "Signal PN14_SupBat_Volt_ST3 Position: ? StartByte = 3 ? StartBit = 6; ? SignalLength = 10 Note:StartBytes starts from 1 and StartBits starts from 0 ");
  AddRequirementInfo("ARCH_SW_DIA_0451", "Signal Values: 0x00...0x3FE (0..25.55 V) 0x03FF = default / Signal not Available (SNA) unit: 0.025 V  ");
  AddRequirementInfo("ARCH_SW_DIA_0452", "PN14_SupBat_Volt_ST3 signal shall be read by both Front LEFT ECU and Front RIGHT ECU and reported via CAN Input Service (0x0200)");
  AddRequirementInfo("ARCH_SW_DIA_0453", "Signal PN14_ProdMd_Stat_ST3 Position: ? StartByte = 1 ? StartBit = 5; ? SignalLength = 3; Note:StartBytes starts from 1 and StartBits starts from 0 ");
  AddRequirementInfo("ARCH_SW_DIA_0454", "Signal Values: 0 = OFF (Productionmode off) 1 = ON (Productionmode active) 2 = SF01 (Productionmode Special Funcion 1) 3 = SF02 (Productionmode Special Funcion 2) 4 = SF03 (Productionmode Special Funcion 3) 7 = default / Signal not Available (SNA) ");
  AddRequirementInfo("ARCH_SW_DIA_0455", "PN14_ProdMd_Stat_ST3 signal shall be read by both Front LEFT ECU and Front RIGHT ECU and reported via CAN Input Service (0x0200)");
  AddRequirementInfo("ARCH_SW_DIA_0456", "Signal PN14_TransMd_Stat_ST3 Position: ? StartByte = 1 ? StartBit = 0; ? SignalLength = 2; Note:StartBytes starts from 1 and StartBits starts from 0 ");
  AddRequirementInfo("ARCH_SW_DIA_0457", "Signal Values: 0 = OFF (Transport mode permanently off) 1 = TEMP_OFF (Transport mode temporarily off) 2 = ACTV (Transport mode active) 3 = default / Signal not Available (SNA) ");
  AddRequirementInfo("ARCH_SW_DIA_0458", "PN14_TransMd_Stat_ST3 signal shall be read by both Front LEFT ECU and Front RIGHT ECU and reported via CAN Input Service (0x0200)");
  AddRequirementInfo("ARCH_SW_DIA_0497", "CAN Frame DIAG_Stat_ST3 shall be identified with the address 0x6D0");
  AddRequirementInfo("ARCH_SW_DIA_0498", "CAN Frame PN14_Master_Stat1_ST3 shall be identified with the address 0x464");
  AddRequirementInfo("ARCH_SW_DIA_0499", "Diagnostic request frame DIAG_RBTM_FL_03_ExtEth_RQ_ST3 identifier shall be 0x18E1A488 if ECU is configured as FRONT LEFT side");
  AddRequirementInfo("ARCH_SW_DIA_0500", "DIAG_RBTM_FL_03_ExtEth_RQ_ST3Frame size: variable, max 8 bytes");
  AddRequirementInfo("ARCH_SW_DIA_0501", "Diagnostic request frame DIAG_RBTM_FR_03_ExtEth_RQ_ST3 identifier shall be 0x18E1A588 if ECU is configured as FRONT RIGHT side");
  AddRequirementInfo("ARCH_SW_DIA_0502", "DIAG_RBTM_FR_03_ExtEth_RQ_ST3Frame size: variable, max 8 bytes");
  AddRequirementInfo("ARCH_SW_DIA_0503", "If a diagnostic service request is received via CAN Frame DIAG_RBTM_xy_03_ExtEth_RQ_ST3 then RGS shall respond via DIAG_RBTM_FL_03_ExtEth_RS_ST3 (Id: 0x18E1A480) frame");
  AddRequirementInfo("ARCH_SW_DIA_0504", "DIAG_RBTM_FL_03_ExtEth_RS_ST3Frame size: variable max 8 bytes");
  AddRequirementInfo("ARCH_SW_DIA_0505", "If a diagnostic service request is received via CAN Frame DIAG_RBTM_FR_03_ExtEth_RQ_ST3 then RGS shall respond via DIAG_RBTM_FR_03_ExtEth_RS_ST3 (Id: 0x18E1A580) frame");
  AddRequirementInfo("ARCH_SW_DIA_0506", "DIAG_RBTM_FR_03_ExtEth_RS_ST3Frame size: variable max 8 bytes");





  //***************************************************************************************

  testCaseComment("Preconditions");
  testStep("STEP", "Bench Initialization");
  
  testStep("", "Delete all breakpoint from debugger.");
  debugger_deleteAllBreakpoints();

  testStep("", "Reset the debugger.");
  debugger_reset();
    
  testStep("", "Run the debugger.");
  debugger_run();
  
  RunPreTs();
  //====================================================

  testStep("STEP", "Set breakpoint in function *DIA_runDid0200_CAN_input_Read_Neues_Bitfeld_1_ReadData*.");
  debugger_setRelativeFunctionBpAtLine("DIA_runDid0200_CAN_input_Read_Neues_Bitfeld_1_ReadData", "32");
  debugger_run();
 
  testCaseComment("Action: ARCH_SW_DIA_0360; ARCH_SW_DIA_0361; ARCH_SW_DIA_0362; ARCH_SW_DIA_0363; ARCH_SW_DIA_0364; ARCH_SW_DIA_0365");
  testStep("STEP", "Send diag request for 22 02 00 --> Timeout received.");
  SendDiagnosticRequestNegativeResponse(dCANinputReadRequest, dCANinputReadResponse, TRUE);

  testWaitForTimeout(2000);
  testStep("STEP", "Check if breakpoint from function DIA_runDid0200_CAN_input_Read_Neues_Bitfeld_1_ReadData was reached. --> BP was reached.");
  debugger_waitUntilBPisReached("5000");
  ExpectedTestResult(debugger_result, IS_CPU_STOP_AT_BP_SUCCESFUL, "BP is reached.");

  testStep("STEP", "Read Data variable --> Variable read.");
  debugger_readLocalVariable("*Data");
  ExpectedTestResult(debugger_result, "Data", "Variable read.");
  
  debugger_deleteRelativeFunctionBpAtLine("DIA_runDid0200_CAN_input_Read_Neues_Bitfeld_1_ReadData", "32");
  debugger_setRelativeFunctionBpAtLine("DIA_runDid0200_CAN_input_Read_Neues_Bitfeld_2_ReadData", "37");
  debugger_run();
 
  testCaseComment("Action: ARCH_SW_DIA_0360; ARCH_SW_DIA_0361; ARCH_SW_DIA_0362; ARCH_SW_DIA_0363; ARCH_SW_DIA_0364; ARCH_SW_DIA_0365");
  testStep("STEP", "Send diag request for 22 02 00 --> Timeout received.");
  SendDiagnosticRequestNegativeResponse(dCANinputReadRequest, dCANinputReadResponse, TRUE);

  testWaitForTimeout(2000);
  testStep("STEP", "Check if breakpoint from function DIA_runDid0200_CAN_input_Read_Neues_Bitfeld_2_ReadData was reached. --> BP was reached.");
  debugger_waitUntilBPisReached("5000");
  ExpectedTestResult(debugger_result, IS_CPU_STOP_AT_BP_SUCCESFUL, "BP is reached.");

  testStep("STEP", "Read Data variable --> Variable read.");
  debugger_readLocalVariable("*Data");
  ExpectedTestResult(debugger_result, "Data", "Variable read.");
  
  debugger_deleteRelativeFunctionBpAtLine("DIA_runDid0200_CAN_input_Read_Neues_Bitfeld_2_ReadData", "37");
  debugger_setRelativeFunctionBpAtLine("DIA_runDid0200_CAN_input_Read_Neues_Bitfeld_3_ReadData", "41");
  debugger_run();
 
  testCaseComment("Action: ARCH_SW_DIA_0360; ARCH_SW_DIA_0361; ARCH_SW_DIA_0362; ARCH_SW_DIA_0363; ARCH_SW_DIA_0364; ARCH_SW_DIA_0365; ARCH_SW_DIA_0441; ARCH_SW_DIA_0442; ARCH_SW_DIA_0443");
  testStep("STEP", "Send diag request for 22 02 00 --> Timeout received.");
  SendDiagnosticRequestNegativeResponse(dCANinputReadRequest, dCANinputReadResponse, TRUE);

  testWaitForTimeout(2000);
  testStep("STEP", "Check if breakpoint from function DIA_runDid0200_CAN_input_Read_Neues_Bitfeld_3_ReadData was reached. --> BP was reached.");
  debugger_waitUntilBPisReached("5000");
  ExpectedTestResult(debugger_result, IS_CPU_STOP_AT_BP_SUCCESFUL, "BP is reached.");

  testStep("STEP", "Read Data variable --> Variable read.");
  debugger_readLocalVariable("*Data");
  ExpectedTestResult(debugger_result, "Data", "Variable read.");
  
  debugger_deleteRelativeFunctionBpAtLine("DIA_runDid0200_CAN_input_Read_Neues_Bitfeld_3_ReadData", "41");
  debugger_setRelativeFunctionBpAtLine("DIA_runDid0200_CAN_input_Read_Neues_Bitfeld_4_ReadData", "36");
  debugger_run();
 
  testCaseComment("Action: ARCH_SW_DIA_0360; ARCH_SW_DIA_0361; ARCH_SW_DIA_0362; ARCH_SW_DIA_0363; ARCH_SW_DIA_0364; ARCH_SW_DIA_0365");
  testStep("STEP", "Send diag request for 22 02 00 --> Timeout received.");
  SendDiagnosticRequestNegativeResponse(dCANinputReadRequest, dCANinputReadResponse, TRUE);

  testWaitForTimeout(2000);
  testStep("STEP", "Check if breakpoint from function DIA_runDid0200_CAN_input_Read_Neues_Bitfeld_4_ReadData was reached. --> BP was reached.");
  debugger_waitUntilBPisReached("5000");
  ExpectedTestResult(debugger_result, IS_CPU_STOP_AT_BP_SUCCESFUL, "BP is reached.");

  testStep("STEP", "Read Data variable --> Variable read.");
  debugger_readLocalVariable("*Data");
  ExpectedTestResult(debugger_result, "Data", "Variable read.");
  
  debugger_deleteRelativeFunctionBpAtLine("DIA_runDid0200_CAN_input_Read_Neues_Bitfeld_4_ReadData", "36");
  debugger_setRelativeFunctionBpAtLine("DIA_runDid0200_CAN_input_Read_Neues_Bitfeld_5_ReadData", "32");
  debugger_run();
 
  testCaseComment("Action: ARCH_SW_DIA_0360; ARCH_SW_DIA_0361; ARCH_SW_DIA_0362; ARCH_SW_DIA_0363; ARCH_SW_DIA_0364; ARCH_SW_DIA_0365; ARCH_SW_DIA_0447; ARCH_SW_DIA_0448; ARCH_SW_DIA_0449; ARCH_SW_DIA_0453; ARCH_SW_DIA_0454; ARCH_SW_DIA_0455; ARCH_SW_DIA_0456; ARCH_SW_DIA_0457; ARCH_SW_DIA_0458");
  testStep("STEP", "Send diag request for 22 02 00 --> Timeout received.");
  SendDiagnosticRequestNegativeResponse(dCANinputReadRequest, dCANinputReadResponse, TRUE);

  testWaitForTimeout(2000);
  testStep("STEP", "Check if breakpoint from function DIA_runDid0200_CAN_input_Read_Neues_Bitfeld_5_ReadData was reached. --> BP was reached.");
  debugger_waitUntilBPisReached("5000");
  ExpectedTestResult(debugger_result, IS_CPU_STOP_AT_BP_SUCCESFUL, "BP is reached.");

  testStep("STEP", "Read Data variable --> Variable read.");
  debugger_readLocalVariable("*Data");
  ExpectedTestResult(debugger_result, "Data", "Variable read.");
  
  debugger_deleteRelativeFunctionBpAtLine("DIA_runDid0200_CAN_input_Read_Neues_Bitfeld_5_ReadData", "32");
  debugger_setRelativeFunctionBpAtLine("DIA_runDid0200_CAN_input_Read_Neues_Bitfeld_6_ReadData", "33");
  debugger_run();
 
  testCaseComment("Action: ARCH_SW_DIA_0360; ARCH_SW_DIA_0361; ARCH_SW_DIA_0362; ARCH_SW_DIA_0363; ARCH_SW_DIA_0364; ARCH_SW_DIA_0365");
  testStep("STEP", "Send diag request for 22 02 00 --> Timeout received.");
  SendDiagnosticRequestNegativeResponse(dCANinputReadRequest, dCANinputReadResponse, TRUE);

  testWaitForTimeout(2000);
  testStep("STEP", "Check if breakpoint from function DIA_runDid0200_CAN_input_Read_Neues_Bitfeld_6_ReadData was reached. --> BP was reached.");
  debugger_waitUntilBPisReached("5000");
  ExpectedTestResult(debugger_result, IS_CPU_STOP_AT_BP_SUCCESFUL, "BP is reached.");

  testStep("STEP", "Read Data variable --> Variable read.");
  debugger_readLocalVariable("*Data");
  ExpectedTestResult(debugger_result, "Data", "Variable read.");
  
  debugger_deleteRelativeFunctionBpAtLine("DIA_runDid0200_CAN_input_Read_Neues_Bitfeld_6_ReadData", "33");
  debugger_setRelativeFunctionBpAtLine("DIA_runDid0200_CAN_input_Read_Supply_battery_voltage_ReadData", "21");
  debugger_run();
 
  testCaseComment("Action: ARCH_SW_DIA_0360; ARCH_SW_DIA_0361; ARCH_SW_DIA_0362; ARCH_SW_DIA_0363; ARCH_SW_DIA_0364; ARCH_SW_DIA_0365; ARCH_SW_DIA_0450; ARCH_SW_DIA_0451; ARCH_SW_DIA_0452");
  testStep("STEP", "Send diag request for 22 02 00 --> Timeout received.");
  SendDiagnosticRequestNegativeResponse(dCANinputReadRequest, dCANinputReadResponse, TRUE);

  testWaitForTimeout(2000);
  testStep("STEP", "Check if breakpoint from function DIA_runDid0200_CAN_input_Read_Supply_battery_voltage_ReadData was reached. --> BP was reached.");
  debugger_waitUntilBPisReached("5000");
  ExpectedTestResult(debugger_result, IS_CPU_STOP_AT_BP_SUCCESFUL, "BP is reached.");

  testStep("STEP", "Read Data variable --> Variable read.");
  debugger_readLocalVariable("*Data");
  ExpectedTestResult(debugger_result, "Data", "Variable read.");
  
  debugger_deleteRelativeFunctionBpAtLine("DIA_runDid0200_CAN_input_Read_Supply_battery_voltage_ReadData", "21");
  debugger_setRelativeFunctionBpAtLine("DIA_runDid0200_CAN_input_Read_Neues_Bitfeld_7_ReadData", "25");
  debugger_run();
 
  testCaseComment("Action: ARCH_SW_DIA_0360; ARCH_SW_DIA_0361; ARCH_SW_DIA_0362; ARCH_SW_DIA_0363; ARCH_SW_DIA_0364; ARCH_SW_DIA_0365; ARCH_SW_DIA_0444; ARCH_SW_DIA_0445; ARCH_SW_DIA_0446");
  testStep("STEP", "Send diag request for 22 02 00 --> Timeout received.");
  SendDiagnosticRequestNegativeResponse(dCANinputReadRequest, dCANinputReadResponse, TRUE);

  testWaitForTimeout(2000);
  testStep("STEP", "Check if breakpoint from function DIA_runDid0200_CAN_input_Read_Neues_Bitfeld_7_ReadData was reached. --> BP was reached.");
  debugger_waitUntilBPisReached("5000");
  ExpectedTestResult(debugger_result, IS_CPU_STOP_AT_BP_SUCCESFUL, "BP is reached.");

  testStep("STEP", "Read Data variable --> Variable read.");
  debugger_readLocalVariable("*Data");
  ExpectedTestResult(debugger_result, "Data", "Variable read.");
  
  debugger_deleteRelativeFunctionBpAtLine("DIA_runDid0200_CAN_input_Read_Neues_Bitfeld_7_ReadData", "25");
  debugger_setRelativeFunctionBpAtLine("DIA_runDid0200_CAN_input_Read_Neues_Bitfeld_8_ReadData", "25");
  debugger_run();
 
  testCaseComment("Action: ARCH_SW_DIA_0360; ARCH_SW_DIA_0361; ARCH_SW_DIA_0362; ARCH_SW_DIA_0363; ARCH_SW_DIA_0364; ARCH_SW_DIA_0365");
  testStep("STEP", "Send diag request for 22 02 00 --> Timeout received.");
  SendDiagnosticRequestNegativeResponse(dCANinputReadRequest, dCANinputReadResponse, TRUE);

  testWaitForTimeout(2000);
  testStep("STEP", "Check if breakpoint from function DIA_runDid0200_CAN_input_Read_Neues_Bitfeld_8_ReadData was reached. --> BP was reached.");
  debugger_waitUntilBPisReached("5000");
  ExpectedTestResult(debugger_result, IS_CPU_STOP_AT_BP_SUCCESFUL, "BP is reached.");

  testStep("STEP", "Read Data variable --> Variable read.");
  debugger_readLocalVariable("*Data");
  ExpectedTestResult(debugger_result, "Data", "Variable read.");
  
  debugger_run();
  //====================================================
  testCaseComment("Postcondition");
  testStep("STEP", "Return ECU to default values");
  RunPostTs();
}

testcase SW_Int_DIA_DataServices_HardwareVersion_Read_HW_ReadData_01()
{
  ////***********************************Test report header*********************************
  testReportAddMiscInfoBlock("AUTOLIV ELECTRONICS document");
  TestReportAddMiscInfo("Nightly test", "No");
  TestReportAddMiscInfo("Test type", "Requirement-Based test");
  TestReportAddMiscInfo("Regression Test", "Yes");
  TestReportAddMiscInfo("Fault injection method used", "No");
  TestReportAddMiscInfo("Resource usage evaluation", "No");
  TestReportAddMiscInfo("Priority", "No");
  TestReportAddMiscInfo("Safety relevant", "No");
  
  AddRequirementInfo("Requirement under test", "ARCH_SW_DIA_0370; ARCH_SW_DIA_0371; ARCH_SW_DIA_0372; ARCH_SW_DIA_0373; ARCH_SW_DIA_0374; ARCH_SW_DIA_0471; ARCH_SW_DIA_0472; ARCH_SW_DIA_0473");
  AddRequirementInfo("ARCH_SW_DIA_0370", "Service 0x22 (Read Data By Identifier) will be implemented for DID F150 (Hardware Version Information)");
  AddRequirementInfo("ARCH_SW_DIA_0471", "DataIdentifier shall be 0xF150");
  AddRequirementInfo("ARCH_SW_DIA_0472", "The DID shall be available in the following sessions:?Default Session?Programming?Extended session?Update Session?Development Session");
  AddRequirementInfo("ARCH_SW_DIA_0473", "This service shall be available with or without Any form of Authentication.");
  AddRequirementInfo("ARCH_SW_DIA_0371", "Response data shall be 3 bytes long");
  AddRequirementInfo("ARCH_SW_DIA_0372", "Byte 0 of the positive response shall represent the year when the HW was designed.");
  AddRequirementInfo("ARCH_SW_DIA_0373", "Byte 1 of the positive response shall represent the week when the HW was designed..");
  AddRequirementInfo("ARCH_SW_DIA_0374", "Byte 2 of the positive response shall represent .");



  ////***************************************************************************************

  testCaseComment("Preconditions");
  testStep("STEP", "Bench Initialization");
  
  testStep("", "Delete all breakpoint from debugger.");
  debugger_deleteAllBreakpoints();

  testStep("", "Reset the debugger.");
  debugger_reset();
    
  testStep("", "Run the debugger.");
  debugger_run();
  
  RunPreTs();
  ////====================================================

  testStep("STEP", "Set breakpoint in function *DataServices_HardwareVersion_Read_HW_patch_level_ReadData*.");
  debugger_setRelativeFunctionBpAtLine("DataServices_HardwareVersion_Read_HW_patch_level_ReadData", "3");
  debugger_run();
 
  testCaseComment("Action: ARCH_SW_DIA_0370; ARCH_SW_DIA_0371; ARCH_SW_DIA_0372; ARCH_SW_DIA_0373");
  testStep("STEP", "Send diag request for 22 F1 50 --> Timeout received.");
  SendDiagnosticRequestNegativeResponse(dReadHWVersionReadRequest, dReadHWVersionReadResponse, TRUE);

  testWaitForTimeout(2000);
  testStep("STEP", "Check if breakpoint from function DataServices_HardwareVersion_Read_HW_patch_level_ReadData was reached. --> BP was reached.");
  debugger_waitUntilBPisReached("5000");
  ExpectedTestResult(debugger_result, IS_CPU_STOP_AT_BP_SUCCESFUL, "BP is reached.");

  testStep("STEP", "Read Data variable --> Variable read.");
  debugger_readLocalVariable("*Data");
  ExpectedTestResult(debugger_result, "Data", "Variable read.");
  
  debugger_deleteRelativeFunctionBpAtLine("DataServices_HardwareVersion_Read_HW_patch_level_ReadData", "3");
  debugger_setRelativeFunctionBpAtLine("DataServices_HardwareVersion_Read_HW_year_ReadData", "3");
  debugger_run();
 
  testCaseComment("Action: ARCH_SW_DIA_0370; ARCH_SW_DIA_0371; ARCH_SW_DIA_0372; ARCH_SW_DIA_0373; ARCH_SW_DIA_0374; ARCH_SW_DIA_0471; ARCH_SW_DIA_0472; ARCH_SW_DIA_0473");
  testStep("STEP", "Send diag request for 22 F1 50 --> Timeout received.");
  SendDiagnosticRequestNegativeResponse(dReadHWVersionReadRequest, dReadHWVersionReadResponse, TRUE);

  testWaitForTimeout(2000);
  testStep("STEP", "Check if breakpoint from function DataServices_HardwareVersion_Read_HW_year_ReadData was reached. --> BP was reached.");
  debugger_waitUntilBPisReached("5000");
  ExpectedTestResult(debugger_result, IS_CPU_STOP_AT_BP_SUCCESFUL, "BP is reached.");

  testStep("STEP", "Read Data variable --> Variable read.");
  debugger_readLocalVariable("*Data");
  ExpectedTestResult(debugger_result, "Data", "Variable read.");

  ////====================================================
  testCaseComment("Postcondition");
  testStep("STEP", "Return ECU to default values");
  RunPostTs();
}

testcase SW_Int_DIA_DataServices_SoftwareVersion_Read_Software_Logical_Block_Version_Information_ReadData_01()
{
  ////***********************************Test report header*********************************
  testReportAddMiscInfoBlock("AUTOLIV ELECTRONICS document");
  TestReportAddMiscInfo("Nightly test", "No");
  TestReportAddMiscInfo("Test type", "Requirement-Based test");
  TestReportAddMiscInfo("Regression Test", "Yes");
  TestReportAddMiscInfo("Fault injection method used", "No");
  TestReportAddMiscInfo("Resource usage evaluation", "No");
  TestReportAddMiscInfo("Priority", "No");
  TestReportAddMiscInfo("Safety relevant", "No");
  
  AddRequirementInfo("Requirement under test", "ARCH_SW_DIA_0375; ARCH_SW_DIA_0376; ARCH_SW_DIA_0377; ARCH_SW_DIA_0378; ARCH_SW_DIA_0379; ARCH_SW_DIA_0474; ARCH_SW_DIA_0475; ARCH_SW_DIA_0476");
  AddRequirementInfo("ARCH_SW_DIA_0375", "Service 0x22 (Read Data By Identifier) will be implemented for DID F151 (Software Version Information)");
  AddRequirementInfo("ARCH_SW_DIA_0474", "DataIdentifier shall be 0xF151");
  AddRequirementInfo("ARCH_SW_DIA_0475", "The DID shall be available in the following sessions:?Default Session?Programming?Extended session?Update Session?Development Session");
  AddRequirementInfo("ARCH_SW_DIA_0476", "This service shall be available with or without Any form of Authentication.");
  AddRequirementInfo("ARCH_SW_DIA_0376", "Response data shall be 3 bytes long");
  AddRequirementInfo("ARCH_SW_DIA_0377", "Byte 0 of the positive response shall represent the year when the SW was designed.");
  AddRequirementInfo("ARCH_SW_DIA_0378", "Byte 1 of the positive response shall represent the week when the SW was designed.");
  AddRequirementInfo("ARCH_SW_DIA_0379", "Byte 2 of the positive response shall represent the current patch level of the SW.");

  ////***************************************************************************************

  testCaseComment("Preconditions");
  testStep("STEP", "Bench Initialization");
  
  testStep("", "Delete all breakpoint from debugger.");
  debugger_deleteAllBreakpoints();

  testStep("", "Reset the debugger.");
  debugger_reset();
    
  testStep("", "Run the debugger.");
  debugger_run();
  
  RunPreTs();
  ////====================================================

  testStep("STEP", "Set breakpoint in function *DataServices_SoftwareVersion_Read_Software_Logical_Block_Version_Information_ReadData*.");
  debugger_setRelativeFunctionBpAtLine("DataServices_SoftwareVersion_Read_Software_Logical_Block_Version_Information_ReadData", "8");
  debugger_run();
 
  testCaseComment("Action: ARCH_SW_DIA_0375; ARCH_SW_DIA_0376; ARCH_SW_DIA_0377; ARCH_SW_DIA_0378; ARCH_SW_DIA_0379; ARCH_SW_DIA_0474; ARCH_SW_DIA_0475; ARCH_SW_DIA_0476");
  testStep("STEP", "Send diag request for 22 F1 51 --> Timeout received.");
  SendDiagnosticRequestNegativeResponse(dReadSWVersionRequest, dReadSWVersionResponse, TRUE);

  testWaitForTimeout(2000);
  testStep("STEP", "Check if breakpoint from function DataServices_SoftwareVersion_Read_Software_Logical_Block_Version_Information_ReadData was reached. --> BP was reached.");
  debugger_waitUntilBPisReached("5000");
  ExpectedTestResult(debugger_result, IS_CPU_STOP_AT_BP_SUCCESFUL, "BP is reached.");

  testStep("STEP", "Read Data variable --> Variable read.");
  debugger_readLocalVariable("*Data");
  ExpectedTestResult(debugger_result, "Data", "Variable read.");

  ////====================================================
  testCaseComment("Postcondition");
  testStep("STEP", "Return ECU to default values");
  RunPostTs();
}

testcase SW_Int_DIA_DataServices_BootSoftwareVersion_Read_Boot_SW_ReadData_01()
{
  
  diagRequest RBTMFL174.BootSoftwareVersion_Read dBootSWVersionReadRequest;
  diagResponse RBTMFL174.BootSoftwareVersion_Read dBootSWVersionReadResponse;
  //***********************************Test report header*********************************
  testReportAddMiscInfoBlock("AUTOLIV ELECTRONICS document");
  TestReportAddMiscInfo("Nightly test", "No");
  TestReportAddMiscInfo("Test type", "Requirement-Based test");
  TestReportAddMiscInfo("Regression Test", "Yes");
  TestReportAddMiscInfo("Fault injection method used", "No");
  TestReportAddMiscInfo("Resource usage evaluation", "No");
  TestReportAddMiscInfo("Priority", "No");
  TestReportAddMiscInfo("Safety relevant", "No");
  
  AddRequirementInfo("Requirement under test", "ARCH_SW_DIA_0380; ARCH_SW_DIA_0381; ARCH_SW_DIA_0382; ARCH_SW_DIA_0383; ARCH_SW_DIA_0477; ARCH_SW_DIA_0478; ARCH_SW_DIA_0479;");
  AddRequirementInfo("ARCH_SW_DIA_0477", "DataIdentifier shall be 0xF153");
  AddRequirementInfo("ARCH_SW_DIA_0478", "The DID shall be available in the following sessions:?Default Session?Programming?Extended session?Update Session?Development Session");
  AddRequirementInfo("ARCH_SW_DIA_0479", "This service shall be available under the following forms of Authentication:?Supplier?Development ENHANCED?Production?After-Sales ENHANCED?After-Sales?After-Sales BASIC?Internal Diagnostic Test Tool?ePTI Test Tool");
  AddRequirementInfo("ARCH_SW_DIA_0381", "Response data shall be 3 bytes long");
  AddRequirementInfo("ARCH_SW_DIA_0382", "Byte 0 of the positive response shall represent the year when the Boot SW was designed.");
  AddRequirementInfo("ARCH_SW_DIA_0383", "Byte 1 of the positive response shall represent the week when the Boot SW was designed.");
  AddRequirementInfo("ARCH_SW_DIA_0384", "Byte 2 of the positive response shall represent the current patch level of the Boot SW.");

  //***************************************************************************************

  testCaseComment("Preconditions");
  testStep("STEP", "Bench Initialization");
  
  testStep("", "Delete all breakpoint from debugger.");
  debugger_deleteAllBreakpoints();

  testStep("", "Reset the debugger.");
  debugger_reset();
    
  testStep("", "Run the debugger.");
  debugger_run();
  
  RunPreTs();
  //====================================================

  testStep("STEP", "Set breakpoint in function *DataServices_BootSoftwareVersion_Read_Boot_SW_patch_level_ReadData*.");
  debugger_setRelativeFunctionBpAtLine("DataServices_BootSoftwareVersion_Read_Boot_SW_patch_level_ReadData", "3");
  debugger_run();
 
  testCaseComment("Action: ARCH_SW_DIA_0380; ARCH_SW_DIA_0381; ARCH_SW_DIA_0382; ARCH_SW_DIA_0383");
  testStep("STEP", "Send diag request for 22 F1 53 --> Timeout received.");
  SendDiagnosticRequestNegativeResponse(dBootSWVersionReadRequest, dBootSWVersionReadResponse, TRUE);

  testWaitForTimeout(2000);
  testStep("STEP", "Check if breakpoint from function DataServices_BootSoftwareVersion_Read_Boot_SW_patch_level_ReadData was reached. --> BP was reached.");
  debugger_waitUntilBPisReached("5000");
  ExpectedTestResult(debugger_result, IS_CPU_STOP_AT_BP_SUCCESFUL, "BP is reached.");

  testStep("STEP", "Read Data variable --> Variable read.");
  debugger_readLocalVariable("*Data");
  ExpectedTestResult(debugger_result, "Data", "Variable read.");

  debugger_deleteRelativeFunctionBpAtLine("DataServices_BootSoftwareVersion_Read_Boot_SW_patch_level_ReadData", "3");
  debugger_setRelativeFunctionBpAtLine("DataServices_BootSoftwareVersion_Read_Boot_SW_week_ReadData", "3");
  debugger_run();
 
  testCaseComment("Action: ARCH_SW_DIA_0380; ARCH_SW_DIA_0381; ARCH_SW_DIA_0382; ARCH_SW_DIA_0383");
  testStep("STEP", "Send diag request for 22 F1 53 --> Timeout received.");
  SendDiagnosticRequestNegativeResponse(dBootSWVersionReadRequest, dBootSWVersionReadResponse, TRUE);

  testWaitForTimeout(2000);
  testStep("STEP", "Check if breakpoint from function DataServices_BootSoftwareVersion_Read_Boot_SW_patch_level_ReadData was reached. --> BP was reached.");
  debugger_waitUntilBPisReached("5000");
  ExpectedTestResult(debugger_result, IS_CPU_STOP_AT_BP_SUCCESFUL, "BP is reached.");

  testStep("STEP", "Read Data variable --> Variable read.");
  debugger_readLocalVariable("*Data");
  ExpectedTestResult(debugger_result, "Data", "Variable read.");
  
  debugger_deleteRelativeFunctionBpAtLine("DataServices_BootSoftwareVersion_Read_Boot_SW_week_ReadData_ReadData", "3");
  debugger_setRelativeFunctionBpAtLine("DataServices_BootSoftwareVersion_Read_Boot_SW_year_ReadData", "3");
  debugger_run();
 
  testCaseComment("Action: ARCH_SW_DIA_0380; ARCH_SW_DIA_0381; ARCH_SW_DIA_0382; ARCH_SW_DIA_0383; ARCH_SW_DIA_0477; ARCH_SW_DIA_0478; ARCH_SW_DIA_0479");
  testStep("STEP", "Send diag request for 22 F1 53 --> Timeout received.");
  SendDiagnosticRequestNegativeResponse(dBootSWVersionReadRequest, dBootSWVersionReadResponse, TRUE);

  testWaitForTimeout(2000);
  testStep("STEP", "Check if breakpoint from function DataServices_BootSoftwareVersion_Read_Boot_SW_year_ReadData was reached. --> BP was reached.");
  debugger_waitUntilBPisReached("5000");
  ExpectedTestResult(debugger_result, IS_CPU_STOP_AT_BP_SUCCESFUL, "BP is reached.");

  testStep("STEP", "Read Data variable --> Variable read.");
  debugger_readLocalVariable("*Data");
  ExpectedTestResult(debugger_result, "Data", "Variable read.");
  
  debugger_run();
  //====================================================
  testCaseComment("Postcondition");
  testStep("STEP", "Return ECU to default values");
  RunPostTs();
}

testcase SW_Int_DIA_Dcm_Svc28Handler_01()
{
  ////***********************************Test report header*********************************
  testReportAddMiscInfoBlock("AUTOLIV ELECTRONICS document");
  TestReportAddMiscInfo("Nightly test", "No");
  TestReportAddMiscInfo("Test type", "Requirement-Based test");
  TestReportAddMiscInfo("Regression Test", "Yes");
  TestReportAddMiscInfo("Fault injection method used", "No");
  TestReportAddMiscInfo("Resource usage evaluation", "No");
  TestReportAddMiscInfo("Priority", "No");
  TestReportAddMiscInfo("Safety relevant", "No");
  
  AddRequirementInfo("Requirement under test", "ARCH_SW_DIA_0400; ARCH_SW_DIA_0401; ARCH_SW_DIA_0402; ARCH_SW_DIA_0403; ARCH_SW_DIA_0404; ARCH_SW_DIA_0405; ARCH_SW_DIA_0406; ARCH_SW_DIA_0407");
  AddRequirementInfo("ARCH_SW_DIA_0401", "The Communication control service shall be available in the following sessions:Extended Session (0x03)Supplier Session/Development Session (0x7E)");
  AddRequirementInfo("ARCH_SW_DIA_0402", "Communication control service shall be available under the following forms of Authentication:SupplierDevelopment ENHANCEDProductionAfter-Sales ENHANCED");
  AddRequirementInfo("ARCH_SW_DIA_0403", "Control Type = 0x00 correspond to the Enable Rx and Tx Note: This value indicates that the reception and transmission of messages shall be enabled for the specified communicationType. ");
  AddRequirementInfo("ARCH_SW_DIA_0404", "Control Type = 0x01 correspond to the Enable Rx and Disable Tx Note: This value indicates that the reception of messages shall be enabled and the transmission shall be disabled for the specified communicationType ");
  AddRequirementInfo("ARCH_SW_DIA_0405", "Communication Type = 0x01 correspond to Normal Communication type. Note: Normal Communication is referring to all application-related communication signals ");
  AddRequirementInfo("ARCH_SW_DIA_0406", "Byte #2:  Control Type of the Communication control shall be an echo of Control Type parameter from the request message.");
  AddRequirementInfo("ARCH_SW_DIA_0407", "If positive response of the Communication Control service has been received, then the transmission / reception of messages shall be done according the Control Type and Communication Type requested.");

  ////***************************************************************************************

  testCaseComment("Preconditions");
  testStep("STEP", "Bench Initialization");
  
  testStep("", "Delete all breakpoint from debugger.");
  debugger_deleteAllBreakpoints();

  testStep("", "Reset the debugger.");
  debugger_reset();
    
  testStep("", "Run the debugger.");
  debugger_run();
  
  RunPreTs();
  ////====================================================

  testStep("STEP", "Set breakpoint in function *Dcm_Svc28Handler*.");
  debugger_setRelativeFunctionBpAtLine("Dcm_Svc28Handler", "0");
  debugger_run();
 
  testCaseComment("Action: ARCH_SW_DIA_0400; ARCH_SW_DIA_0401; ARCH_SW_DIA_0402; ARCH_SW_DIA_0403; ARCH_SW_DIA_0404; ARCH_SW_DIA_0405; ARCH_SW_DIA_0406; ARCH_SW_DIA_0407;");
  testStep("STEP", "Send request.");
  SendDiagnosticRequestNegativeResponse(dEnableRxAndEnableTxReadRequest, dEnableRxAndEnableTxReadResponse, TRUE);

  testWaitForTimeout(2000);
  testStep("STEP", "Check if  was reached. --> BP was reached.");
  debugger_waitUntilBPisReached("5000");
  ExpectedTestResult(debugger_result, IS_CPU_STOP_AT_BP_SUCCESFUL, "BP is reached.");
  ////====================================================
  testCaseComment("Postcondition");
  testStep("STEP", "Return ECU to default values");
  RunPostTs();
}

testcase SW_Int_DIA_Dcm_Svc85Handler_01()
{
  ////***********************************Test report header*********************************
  testReportAddMiscInfoBlock("AUTOLIV ELECTRONICS document");
  TestReportAddMiscInfo("Nightly test", "No");
  TestReportAddMiscInfo("Test type", "Requirement-Based test");
  TestReportAddMiscInfo("Regression Test", "Yes");
  TestReportAddMiscInfo("Fault injection method used", "No");
  TestReportAddMiscInfo("Resource usage evaluation", "No");
  TestReportAddMiscInfo("Priority", "No");
  TestReportAddMiscInfo("Safety relevant", "No");
  
  AddRequirementInfo("Requirement under test", "ARCH_SW_DIA_0410; ARCH_SW_DIA_0411; ARCH_SW_DIA_0412; ARCH_SW_DIA_0413; ARCH_SW_DIA_0414; ARCH_SW_DIA_0415; ARCH_SW_DIA_0416; ARCH_SW_DIA_0417; ARCH_SW_DIA_0418; ARCH_SW_DIA_0492; ARCH_SW_DIA_0493; ARCH_SW_DIA_0494; ARCH_SW_DIA_0495; ARCH_SW_DIA_0496");
  AddRequirementInfo("ARCH_SW_DIA_0492", "The DID shall be available in the following sessions: ?Extended session ?Development Session ");
  AddRequirementInfo("ARCH_SW_DIA_0493", "This service shall be available under the following forms of Authentication: ?Supplier ?Development ENHANCED ?Production ?After-Sales ENHANCED");
  AddRequirementInfo("ARCH_SW_DIA_0494", "The value 0x85 shall correspond to the SID-RQ of the ControlDTCSetings Service");
  AddRequirementInfo("ARCH_SW_DIA_0495", "The value 0x01 shall correspond to the DTCSettingType: DTC Setting Enabled ");
  AddRequirementInfo("ARCH_SW_DIA_0496", "The value 0x02 shall correspond to the DTCSettingType: DTC Setting Disabled");
  AddRequirementInfo("ARCH_SW_DIA_0411", "The byte 1 shall be reserved for the SID-PR of the ControlDTCSetting service:The value 0xC5 shall correspond to the SID-PR of the ControlDTCSetting service");
  AddRequirementInfo("ARCH_SW_DIA_0412", "The byte 2 shall be reserved for the DTCSettingType of the ControlDTCSetting service: The value 0x01 shall correspond to the DTCSettingType: DTC Setting Enabled. The value 0x02 shall correspond to the DTCSettingType: DTC Setting Disabled. ");
  AddRequirementInfo("ARCH_SW_DIA_0413", "If positive response has been received for DTC Setting Disabled then the status of the DTCs shall be frozen. Note: ControlDTCSetting deactivates only the updating of the StatusOfDTC bits. The service is not used to deactivate substitute functions.");
  AddRequirementInfo("ARCH_SW_DIA_0414", "If positive response has been received for DTC Setting Enabled then the status of the DTCs shall be resumed.");
  AddRequirementInfo("ARCH_SW_DIA_0415", "If a clearDiagnosticInformation (14 hex) service is sent by the client, the ControlDTCSetting shall not prohibit resetting the server's DTC memory. If a successful ECUReset is performed, then this re-enables the setting of DTCs. ");
  AddRequirementInfo("ARCH_SW_DIA_0416", "The byte 1 shall be reserved for the SID-NR of the ControlDTCSetting service:?	The value 0x7F shall correspond to the SID-NR of the ControlDTcSetting service.");
  AddRequirementInfo("ARCH_SW_DIA_0417", "The byte 2 shall be reserved for the SID-RQ-NR of the ControlDTCSetting service: The value 0x85 shall correspond to the SID-RQ-NR of the ControlDTCSetting service. ");
  AddRequirementInfo("ARCH_SW_DIA_0418", "The byte 3 shall be reserved for the NRC-CDTCS of the ControlDTCSetting service: The value 0x12 shall correspond to the NRC-CDTCS: SubFunctionNotSupported The value 0x13 shall correspond to the NRC-CDTCS: IncorrectMessageLengthOrInvalidFormat The value 0x22 shall correspond to the NRC-CDTCS: ConditionsNotCorrect The value 0x7E shall correspond to the NRC-CDTCS: SubfunctionNotSupportedInActiveSession The value 0x7F shall correspond to the NRC-CDTCS: ServiceNotSupportedInActiveSession ");

  ////***************************************************************************************

  testCaseComment("Preconditions");
  testStep("STEP", "Bench Initialization");
  
  testStep("", "Delete all breakpoint from debugger.");
  debugger_deleteAllBreakpoints();

  testStep("", "Reset the debugger.");
  debugger_reset();
    
  testStep("", "Run the debugger.");
  debugger_run();
  
  RunPreTs();
  ////====================================================

  testStep("STEP", "Set breakpoint in function *Dcm_Svc85Handler*.");
  debugger_setRelativeFunctionBpAtLine("Dcm_Svc85Handler", "0");
  debugger_run();
 
  testCaseComment("Action: ARCH_SW_DIA_0410; ARCH_SW_DIA_0411; ARCH_SW_DIA_0412; ARCH_SW_DIA_0413; ARCH_SW_DIA_0414; ARCH_SW_DIA_0415; ARCH_SW_DIA_0416; ARCH_SW_DIA_0417; ARCH_SW_DIA_0418; ARCH_SW_DIA_0492; ARCH_SW_DIA_0493; ARCH_SW_DIA_0494; ARCH_SW_DIA_0495; ARCH_SW_DIA_0496;");
  testStep("STEP", "Send request.");
  SendDiagnosticRequestNegativeResponse(dDTCSettingModeOnControlRequest, dDTCSettingModeOnControlResponse, TRUE);

  testWaitForTimeout(2000);
  testStep("STEP", "Check if  was reached. --> BP was reached.");
  debugger_waitUntilBPisReached("5000");
  ExpectedTestResult(debugger_result, IS_CPU_STOP_AT_BP_SUCCESFUL, "BP is reached.");
  ////====================================================
  testCaseComment("Postcondition");
  testStep("STEP", "Return ECU to default values");
  RunPostTs();
}

testcase SW_Int_DIA_RoELite_ObsolescenceDataHandler_01()
{
  diagRequest RBTMFL174.Obsolescence_Data_Read dObsolenceDataReadRequest;
  diagResponse RBTMFL174.Obsolescence_Data_Read dObsolenceDataReadResponse;

  //***********************************Test report header*********************************
  testReportAddMiscInfoBlock("AUTOLIV ELECTRONICS document");
  TestReportAddMiscInfo("Nightly test", "No");
  TestReportAddMiscInfo("Test type", "Requirement-Based test");
  TestReportAddMiscInfo("Regression Test", "Yes");
  TestReportAddMiscInfo("Fault injection method used", "No");
  TestReportAddMiscInfo("Resource usage evaluation", "No");
  TestReportAddMiscInfo("Priority", "No");
  TestReportAddMiscInfo("Safety relevant", "No");
  
  AddRequirementInfo("Requirement under test", "ARCH_SW_DIA_0420; ARCH_SW_DIA_0421; ARCH_SW_DIA_0422; ARCH_SW_DIA_0423; ARCH_SW_DIA_0424; ARCH_SW_DIA_0425; ARCH_SW_DIA_0426");
  AddRequirementInfo("ARCH_SW_DIA_0420", "RoELite for ObsolescenceData will be implemented");
  AddRequirementInfo("ARCH_SW_DIA_0421", "Frame contents shall be transmitted depending on the event detect (Type). ");
  AddRequirementInfo("ARCH_SW_DIA_0422", "If more than one RoE-lite PDU needs to be transmitted within one Transmission Cycle, the associated RoE-Lite PDUs shall be transmitted as depicted in figure [Transmitting RoE-lite PDUs from the transmission queue].");
  AddRequirementInfo("ARCH_SW_DIA_0423", "ROE_0_RBTM_xy_ST3 (Byte 1) signal shall be transmitted with the value 0x02 - Obsolescence_DATA if availability data has been changed. Byte 2 of the ROE_RBTM_xy_ST3 frame shall contain the block number. Bytes 3-4 of the ROE_RBTM_xy_ST3 frame shall contain the current value Bytes 5-6 of the ROE_RBTM_xy_ST3 frame shall be threshold Green to Yellow Bytes 7-8 of the ROE_RBTM_xy_ST3 frame shall be threshold Yellow to Red");
  AddRequirementInfo("ARCH_SW_DIA_0424", "Block number: BSR: 0x00 PRE-SAFE 1-3: 0x01 PRE-SAFE 4-5: 0x02 PRE-SAFE 6-8: 0x03 ");
  AddRequirementInfo("ARCH_SW_DIA_0425", "Threshold Green to Yellow = Yellow to Red = 0");
  AddRequirementInfo("ARCH_SW_DIA_0426", "Only when the Obsolescence changes from - Green to Red the ECU shall send the corresponding RoE-Lite PDU. ");

  //***************************************************************************************

  testCaseComment("Preconditions");
  testStep("STEP", "Bench Initialization");
  
  testStep("", "Delete all breakpoint from debugger.");
  debugger_deleteAllBreakpoints();

  testStep("", "Reset the debugger.");
  debugger_reset();
    
  testStep("", "Run the debugger.");
  debugger_run();
  
  RunPreTs();
  //====================================================

  testStep("STEP", "Set breakpoint in function *RoELite_ObsolescenceDataHandler*.");
  debugger_setRelativeFunctionBpAtLine("RoELite_ObsolescenceDataHandler", "73");
  debugger_run();
 
  testCaseComment("Action: ARCH_SW_DIA_0420; ARCH_SW_DIA_0421; ARCH_SW_DIA_0422; ARCH_SW_DIA_0423; ARCH_SW_DIA_0424; ARCH_SW_DIA_0425; ARCH_SW_DIA_0426");
  testStep("STEP", "Send diag request for 22 01 40 --> Timeout received.");
  SendDiagnosticRequestNegativeResponse(dObsolenceDataReadRequest, dObsolenceDataReadResponse, TRUE);

  testWaitForTimeout(2000);
  testStep("STEP", "Check if breakpoint from function RoELite_ObsolescenceDataHandler was reached. --> BP was reached.");
  debugger_waitUntilBPisReached("5000");
  ExpectedTestResult(debugger_result, IS_CPU_STOP_AT_BP_SUCCESFUL, "BP is reached.");

  testStep("STEP", "Read Data variable --> Variable read.");
  debugger_readLocalVariable("*Data");
  ExpectedTestResult(debugger_result, "Data", "Variable read.");

  
  //====================================================
  testCaseComment("Postcondition");
  testStep("STEP", "Return ECU to default values");
  RunPostTs();
}

testcase SW_Int_DIA_RoELite_AvailabilityDataHandler_01()
{
  diagRequest RBTMFL174.Availability_Data_Read dAvailabilityDataReadRequest;
  diagResponse RBTMFL174.Availability_Data_Read dAvailabilityDataReadResponse;
  
  //***********************************Test report header*********************************
  testReportAddMiscInfoBlock("AUTOLIV ELECTRONICS document");
  TestReportAddMiscInfo("Nightly test", "No");
  TestReportAddMiscInfo("Test type", "Requirement-Based test");
  TestReportAddMiscInfo("Regression Test", "Yes");
  TestReportAddMiscInfo("Fault injection method used", "No");
  TestReportAddMiscInfo("Resource usage evaluation", "No");
  TestReportAddMiscInfo("Priority", "No");
  TestReportAddMiscInfo("Safety relevant", "No");
  
  AddRequirementInfo("Requirement under test", "ARCH_SW_DIA_0430; ARCH_SW_DIA_0431; ARCH_SW_DIA_0432; ARCH_SW_DIA_0433, ARCH_SW_DIA_0435; ARCH_SW_DIA_0436; ARCH_SW_DIA_0437; ARCH_SW_DIA_0438");
  AddRequirementInfo("ARCH_SW_DIA_0430", "RoELite for AvailabilityData will be implemented");
  AddRequirementInfo("ARCH_SW_DIA_0431", "ROE_0_RBTM_xy_ST3 (Byte 1) signal shall be transmitted with the value 0x04 - AVAILABILITY_DATA if availability data has been changed. Byte 2 of the ROE_RBTM_xy_ST3 frame shall contain the function number. Bytes 3 of the ROE_RBTM_xy_ST3 frame shall contain the category (yelow, green, red) Bytes 4-8 of the ROE_RBTM_xy_ST3 frame shall be 0x0000000000. ");
  AddRequirementInfo("ARCH_SW_DIA_0432", "Function number: BSR: 0x00 PRE-SAFE 1-3: 0x00 PRE-SAFE 4-5: 0x00 PRE-SAFE 6-8: 0x00 ");
  AddRequirementInfo("ARCH_SW_DIA_0433", "Only when the Availability changes from- Green to Redthe ECU shall send the corresponding RoE-Lite PDU.");
  AddRequirementInfo("ARCH_SW_DIA_0435", "RoELite for DiagSessionChange will be implemented.");
  AddRequirementInfo("ARCH_SW_DIA_0436", "ROE_0_RBTM_xy_ST3 (Byte 1) signal shall be transmitted with the value 05 - DIAG_SESSION_CHANGE if diagnostic sesion has been changed. Byte 2 of the ROE_RBTM_xy_ST3 frame shall contain the new Diagnostic session. Bytes 3-8 of the ROE_RBTM_xy_ST3 frame shall be 0x000000000000. ");
  AddRequirementInfo("ARCH_SW_DIA_0437", "On ECU start-up the ECU shall transmit a RoE-lite PDU containing the DiagnosticSessionType of the target session. (This includes ECU start-ups for example due to ECUReset or watchdog resets.)");
  AddRequirementInfo("ARCH_SW_DIA_0438", "RoE-lite PDUs indicating Diagnostic Session Changes shall only be sent from Application Software, not from Boot Software.");

  //***************************************************************************************

  testCaseComment("Preconditions");
  testStep("STEP", "Bench Initialization");
  
  testStep("", "Delete all breakpoint from debugger.");
  debugger_deleteAllBreakpoints();

  testStep("", "Reset the debugger.");
  debugger_reset();
    
  testStep("", "Run the debugger.");
  debugger_run();
  
  RunPreTs();
  //====================================================

  testStep("STEP", "Set breakpoint in function *RoELite_AvailabilityDataHandler*.");
  debugger_setRelativeFunctionBpAtLine("RoELite_AvailabilityDataHandler", "20");
  debugger_run();
 
  testCaseComment("Action: ARCH_SW_DIA_0430; ARCH_SW_DIA_0431; ARCH_SW_DIA_0432; ARCH_SW_DIA_0433, ARCH_SW_DIA_0435; ARCH_SW_DIA_0436; ARCH_SW_DIA_0437; ARCH_SW_DIA_0438");
  testStep("STEP", "Send diag request for 22 01 42 --> Timeout received.");
  SendDiagnosticRequestNegativeResponse(dAvailabilityDataReadRequest, dAvailabilityDataReadResponse, TRUE);

  testWaitForTimeout(2000);
  testStep("STEP", "Check if breakpoint from function RoELite_AvailabilityDataHandler was reached. --> BP was reached.");
  debugger_waitUntilBPisReached("5000");
  ExpectedTestResult(debugger_result, IS_CPU_STOP_AT_BP_SUCCESFUL, "BP is reached.");

  testStep("STEP", "Read roe_AvailabilityData variable --> Variable read.");
  debugger_readLocalVariable("roe_AvailabilityData.ROE_0");
  ExpectedTestResult(debugger_result, "roe_AvailabilityData", "Variable read.");

  
  //====================================================
  testCaseComment("Postcondition");
  testStep("STEP", "Return ECU to default values");
  RunPostTs();
}

  testcase SW_Int_DIA_DataServices_Global_Time_Sync_Measured_Values_ReadData()
{
  diagRequest RBTMFL174.Global_Time_Sync_Measured_Values_Read dGlobalTimeSyncMeasuredValuesReadRequest;
  diagResponse RBTMFL174.Global_Time_Sync_Measured_Values_Read dGlobalTimeSyncMeasuredValuesReadResponse;
  
  //***********************************Test report header*********************************
  testReportAddMiscInfoBlock("AUTOLIV ELECTRONICS document");
  TestReportAddMiscInfo("Nightly test", "No");
  TestReportAddMiscInfo("Test type", "Requirement-Based test");
  TestReportAddMiscInfo("Regression Test", "Yes");
  TestReportAddMiscInfo("Fault injection method used", "No");
  TestReportAddMiscInfo("Resource usage evaluation", "No");
  TestReportAddMiscInfo("Priority", "No");
  TestReportAddMiscInfo("Safety relevant", "No");
  
  AddRequirementInfo("Requirement under test", "ARCH_SW_DIA_0460; ARCH_SW_DIA_0461; ARCH_SW_DIA_0462; ARCH_SW_DIA_0463; ARCH_SW_DIA_0464; ARCH_SW_DIA_0465");
  AddRequirementInfo("ARCH_SW_DIA_0460", "Service 0x22 (Read Data By Identifier) will be implemented for DID 0107 (Global Time Sync Measured Values).");
  AddRequirementInfo("ARCH_SW_DIA_0461", "DataIdentifier shall be 0x0107.");
  AddRequirementInfo("ARCH_SW_DIA_0462", "The DID shall be available in the following sessions:?Default Session?Programming?Extended session?Update Session?Development Session");
  AddRequirementInfo("ARCH_SW_DIA_0463", "This service shall be available with or without Any form of Authentication.");
  AddRequirementInfo("ARCH_SW_DIA_0464", "Byte 0 of the positive response shall represent the Source Domain Information for Interpretation.");
  AddRequirementInfo("ARCH_SW_DIA_0465", "Bytes 1-201 of the positive response shall represent the Global Time Sync Measured Values.");

  //***************************************************************************************

  testCaseComment("Preconditions");
  testStep("STEP", "Bench Initialization");
  
  testStep("", "Delete all breakpoint from debugger.");
  debugger_deleteAllBreakpoints();

  testStep("", "Reset the debugger.");
  debugger_reset();
    
  testStep("", "Run the debugger.");
  debugger_run();
  
  RunPreTs();
  //====================================================

  testStep("STEP", "Set breakpoint in function *DataServices_Global_Time_Sync_Measured_Values_ReadData*.");
  debugger_setRelativeFunctionBpAtLine("DataServices_Global_Time_Sync_Measured_Values_ReadData", "0");
  debugger_run();
 
  testCaseComment("Action: ARCH_SW_DIA_0460; ARCH_SW_DIA_0461; ARCH_SW_DIA_0462; ARCH_SW_DIA_0463; ARCH_SW_DIA_0464; ARCH_SW_DIA_0465");
  testStep("STEP", "Send diag request for 22 0107 and wait for timeout error --> Timeout received.");
  SendDiagnosticRequestNegativeResponse(dGlobalTimeSyncMeasuredValuesReadRequest, dGlobalTimeSyncMeasuredValuesReadResponse, TRUE);

  testStep("STEP", "Check if breakpoint from function DataServices_Global_Time_Sync_Measured_Values_ReadData was reached. --> BP was reached.");
  debugger_waitUntilBPisReached("5000");
  ExpectedTestResult(debugger_result, IS_CPU_STOP_AT_BP_SUCCESFUL, "BP is reached.");
  
  testStep("STEP", "Read Data pointer value --> Byte was read.");
  debugger_readLocalVariable("*Data");
  ExpectedTestResult(debugger_result, "Data", "Byte was read");

  debugger_run();
  //====================================================
  testCaseComment("Postcondition");
  testStep("STEP", "Return ECU to default values");
  RunPostTs();
}


testcase SW_Int_DIA_runDid0340_UniqueSeatbeltSerialNumberWrite_01()
{
  diagRequest RBTMFL174.Seatbelt_Serial_Number_Write dSeatBeltSerialNumberWriteRequest;
  diagResponse RBTMFL174.Seatbelt_Serial_Number_Write dSeatBeltSerialNumberWriteResponse;

  //***********************************Test report header*********************************
  testReportAddMiscInfoBlock("AUTOLIV ELECTRONICS document");
  TestReportAddMiscInfo("Nightly test", "No");
  TestReportAddMiscInfo("Test type", "Requirement-Based test");
  TestReportAddMiscInfo("Regression Test", "Yes");
  TestReportAddMiscInfo("Fault injection method used", "No");
  TestReportAddMiscInfo("Resource usage evaluation", "No");
  TestReportAddMiscInfo("Priority", "No");
  TestReportAddMiscInfo("Safety relevant", "No");
  
  AddRequirementInfo("Requirement under test", "ARCH_SW_DIA_0008; ARCH_SW_DIA_0056; ARCH_SW_DIA_0057; ARCH_SW_NVP_0001");
  AddRequirementInfo("ARCH_SW_DIA_0008", "Service 0x2E will be implemented for DID 0340.");
  AddRequirementInfo("ARCH_SW_DIA_0056", "Service should be available in Default and extended session.");
  AddRequirementInfo("ARCH_SW_DIA_0057", "NVP_BLOCK_ID_BELT_ASSEMBLY_MANUF_DATE_AND_SN_RamBlockData will be written.");
  AddRequirementInfo("ARCH_SW_NVP_0001", "NVP_BLOCK_ID_BELT_ASSEMBLY_MANUF_DATE_AND_SN block shall be configured. Parameter NVP_au8AssemblySerialNumber should have 28 bytes and should store belt assembly Serial Number written at ANG (default values 0xFF).");


  //***************************************************************************************

  testCaseComment("Preconditions");
  testStep("STEP", "Bench Initialization");
  
  testStep("", "Delete all breakpoint from debugger.");
  debugger_deleteAllBreakpoints();

  testStep("", "Reset the debugger.");
  debugger_reset();
    
  testStep("", "Run the debugger.");
  debugger_run();
  
  RunPreTs();
  //====================================================

  testStep("STEP", "Enter default or extended session.");
  EnterDiagnosticSession("extended");
  
  testStep("STEP", "Set breakpoint in function *DIA_runDid0340_UniqueSeatbeltSerialNumberWrite*.");
  debugger_setRelativeFunctionBpAtLine("DIA_runDid0340_UniqueSeatbeltSerialNumberWrite", "6");
  debugger_run();
 
  testCaseComment("Action: ARCH_SW_DIA_0008; ARCH_SW_DIA_0056; ARCH_SW_DIA_0057; ARCH_SW_NVP_0001");
  testStep("STEP", "Send diag request for 2E 0340 and wait for timeout error --> Timeout reached.");
  SendDiagnosticRequestNegativeResponse(dSeatBeltSerialNumberWriteRequest, dSeatBeltSerialNumberWriteResponse, TRUE);

  testStep("STEP", "Check if breakpoint from function DIA_runDid0340_UniqueSeatbeltSerialNumberWrite was reached. --> BP was reached.");
  debugger_waitUntilBPisReached("5000");
  ExpectedTestResult(debugger_result, IS_CPU_STOP_AT_BP_SUCCESFUL, "BP is reached.");
  
  testStep("STEP", "Write first byte of NVP_BLOCK_ID_BELT_ASSEMBLY_MANUF_DATE_AND_SN_RamBlockData --> Variable overwritten with 0x1.");
  debugger_writeVariable("uint8", "NVP_BLOCK_ID_BELT_ASSEMBLY_MANUF_DATE_AND_SN_RamBlockData,,app.elf", "0", "1");
  ExpectedTestResult(debugger_result, "NVP_BLOCK_ID_BELT_ASSEMBLY_MANUF_DATE_AND_SN_RamBlockData", "Variable overwritten with 0x1");

  //====================================================
  testCaseComment("Postcondition");
  testStep("STEP", "Return ECU to default values");
  RunPostTs();
}

testcase SW_Int_DIA_runDidFD10_CycleConfigurationWrite_01()
{
  ////***********************************Test report header*********************************
  testReportAddMiscInfoBlock("AUTOLIV ELECTRONICS document");
  TestReportAddMiscInfo("Nightly test", "No");
  TestReportAddMiscInfo("Test type", "Requirement-Based test");
  TestReportAddMiscInfo("Regression Test", "Yes");
  TestReportAddMiscInfo("Fault injection method used", "No");
  TestReportAddMiscInfo("Resource usage evaluation", "No");
  TestReportAddMiscInfo("Priority", "No");
  TestReportAddMiscInfo("Safety relevant", "No");
  
  AddRequirementInfo("Requirement under test", "ARCH_SW_DIA_0005; ARCH_SW_DIA_0066; ARCH_SW_DIA_0084; ARCH_SW_DIA_0067");
  AddRequirementInfo("ARCH_SW_DIA_0005", "Service 0x2E will be implemented for DID FD10.");
  AddRequirementInfo("ARCH_SW_DIA_0066", "Service should be available in Development Session.");
  AddRequirementInfo("ARCH_SW_DIA_0084", "Data Length shall be 420 bytes long.");
  AddRequirementInfo("ARCH_SW_DIA_0067", "NVP_BLOCK_ID_CYCLE0-34_RamBlockData will be Written.");


  ////***************************************************************************************

  testCaseComment("Preconditions");
  testStep("STEP", "Bench Initialization");
  
  testStep("", "Delete all breakpoint from debugger.");
  debugger_deleteAllBreakpoints();

  testStep("", "Reset the debugger.");
  debugger_reset();
    
  testStep("", "Run the debugger.");
  debugger_run();
  
  RunPreTs();
  ////====================================================
    testStep("STEP", "Enter development session.");
  EnterDiagnosticSession("development");
  
  testStep("STEP", "Set breakpoint in function *DIA_runDidFD10_CycleConfigurationWrite*.");
  debugger_setRelativeFunctionBpAtLine("DIA_runDidFD10_CycleConfigurationWrite", "10");
  debugger_run();
 
  testCaseComment("Action: ARCH_SW_DIA_0005; ARCH_SW_DIA_0066; ARCH_SW_DIA_0084; ARCH_SW_DIA_0067");
  testStep("STEP", "Send diag request for 2E 0340 and wait for timeout error --> Timeout reached.");
  SendDiagnosticRequestNegativeResponse(dCycleConfigWriteRequest, dCycleConfigWriteResponse, TRUE);

  testWaitForTimeout(2000);
  testStep("STEP", "Check if breakpoint from function DIA_runDidFD10_CycleConfigurationWrite was reached. --> BP was reached.");
  debugger_waitUntilBPisReached("5000");
  ExpectedTestResult(debugger_result, IS_CPU_STOP_AT_BP_SUCCESFUL, "BP is reached.");
  
  testStep("STEP", "Write first byte of NVP_BLOCK_ID_CYCLE_0_RamBlockData --> Variable overwritten with 0x1.");
  debugger_writeVariable("uint8", "NVP_BLOCK_ID_CYCLE_0_RamBlockData,,app.elf", "0", "1");
  ExpectedTestResult(debugger_result, "NVP_BLOCK_ID_CYCLE_0_RamBlockData", "Variable overwritten with 0x1");

  ////====================================================
  testCaseComment("Postcondition");
  testStep("STEP", "Return ECU to default values");
  RunPostTs();
}

testcase SW_Int_DIA_runDidFD2A_StepsLibraryWrite_01()
{
  ////***********************************Test report header*********************************
  testReportAddMiscInfoBlock("AUTOLIV ELECTRONICS document");
  TestReportAddMiscInfo("Nightly test", "No");
  TestReportAddMiscInfo("Test type", "Requirement-Based test");
  TestReportAddMiscInfo("Regression Test", "Yes");
  TestReportAddMiscInfo("Fault injection method used", "No");
  TestReportAddMiscInfo("Resource usage evaluation", "No");
  TestReportAddMiscInfo("Priority", "No");
  TestReportAddMiscInfo("Safety relevant", "No");
  
  AddRequirementInfo("Requirement under test", "ARCH_SW_DIA_0007; ARCH_SW_DIA_0070; ARCH_SW_DIA_0085; ARCH_SW_DIA_0071");
  AddRequirementInfo("ARCH_SW_DIA_0007", "Service 0x2E will be implemented for DID FD2A.");
  AddRequirementInfo("ARCH_SW_DIA_0070", "Service should be available in Development Session.");
  AddRequirementInfo("ARCH_SW_DIA_0085", "Data Length shall be 1160 bytes long.");
  AddRequirementInfo("ARCH_SW_DIA_0071", "NVP_BLOCK_ID_STEPS0-144_RamBlockData will be Written..");


  ////***************************************************************************************

  testCaseComment("Preconditions");
  testStep("STEP", "Bench Initialization");
  
  testStep("", "Delete all breakpoint from debugger.");
  debugger_deleteAllBreakpoints();

  testStep("", "Reset the debugger.");
  debugger_reset();
    
  testStep("", "Run the debugger.");
  debugger_run();
  
  RunPreTs();
  ////====================================================
    testStep("STEP", "Enter development session.");
  EnterDiagnosticSession("development");
  
  testStep("STEP", "Set breakpoint in function *DIA_runDidFD2A_StepsLibraryWrite*.");
  debugger_setRelativeFunctionBpAtLine("DIA_runDidFD2A_StepsLibraryWrite", "11");
  debugger_run();
 
  testCaseComment("Action: ARCH_SW_DIA_0007; ARCH_SW_DIA_0070; ARCH_SW_DIA_0085; ARCH_SW_DIA_0071");
  testStep("STEP", "Send diag request for 2E FD2A and wait for timeout error --> Timeout reached.");
  SendDiagnosticRequestNegativeResponse(dWriteStepsConfigRequest, dWriteStepsConfigResponse, TRUE);

  testWaitForTimeout(2000);
  testStep("STEP", "Check if breakpoint from function DIA_runDidFD2A_StepsLibraryWrite was reached. --> BP was reached.");
  debugger_waitUntilBPisReached("5000");
  ExpectedTestResult(debugger_result, IS_CPU_STOP_AT_BP_SUCCESFUL, "BP is reached.");
  
  testStep("STEP", "Write first byte of NVP_BLOCK_ID_STEP_0_RamBlockData --> Variable overwritten with 0x1.");
  debugger_writeVariable("uint8", "NVP_BLOCK_ID_STEP_0_RamBlockData,,app.elf", "0", "1");
  ExpectedTestResult(debugger_result, "NVP_BLOCK_ID_STEP_0_RamBlockData", "Variable overwritten with 0x1");

  ////====================================================
  testCaseComment("Postcondition");
  testStep("STEP", "Return ECU to default values");
  RunPostTs();
}

testcase SW_Int_DIA_runDidFD03_AEETraceabilityNumberWrite_01()
{
  ////***********************************Test report header*********************************
  testReportAddMiscInfoBlock("AUTOLIV ELECTRONICS document");
  TestReportAddMiscInfo("Nightly test", "No");
  TestReportAddMiscInfo("Test type", "Requirement-Based test");
  TestReportAddMiscInfo("Regression Test", "Yes");
  TestReportAddMiscInfo("Fault injection method used", "No");
  TestReportAddMiscInfo("Resource usage evaluation", "No");
  TestReportAddMiscInfo("Priority", "No");
  TestReportAddMiscInfo("Safety relevant", "No");
  
  AddRequirementInfo("Requirement under test", "ARCH_SW_DIA_0009; ARCH_SW_DIA_0074; ARCH_SW_DIA_0075");
  AddRequirementInfo("ARCH_SW_DIA_0009", "Service 0x2E will be implemented for DID FD03.");
  AddRequirementInfo("ARCH_SW_DIA_0074", "Service should be available in Default and extended session.");
  AddRequirementInfo("ARCH_SW_DIA_0075", "NVP_BLOCK_ID_AEE_TRACEABILITY_RamBlockData will be Written..");


  ////***************************************************************************************

  testCaseComment("Preconditions");
  testStep("STEP", "Bench Initialization");
  
  testStep("", "Delete all breakpoint from debugger.");
  debugger_deleteAllBreakpoints();

  testStep("", "Reset the debugger.");
  debugger_reset();
    
  testStep("", "Run the debugger.");
  debugger_run();
  
  RunPreTs();
  ////====================================================
    testStep("STEP", "Enter development session.");
  EnterDiagnosticSession("development");
  
  testStep("STEP", "Set breakpoint in function *DIA_runDidFD03_AEETraceabilityNumbeWrite*.");
  debugger_setRelativeFunctionBpAtLine("DIA_runDidFD03_AEETraceabilityNumbeWrite", "6");
  debugger_run();
 
  testCaseComment("Action: ARCH_SW_DIA_0009; ARCH_SW_DIA_0074; ARCH_SW_DIA_0075");
  testStep("STEP", "Send diag request for 2E FD03 and wait for timeout error --> Timeout reached.");
  SendDiagnosticRequestNegativeResponse(dECUSerialNumberWriteRequest, dECUSerialNumberWriteResponse, TRUE);

  testWaitForTimeout(2000);
  testStep("STEP", "Check if breakpoint from function DIA_runDidFD03_AEETraceabilityNumbeWrite was reached. --> BP was reached.");
  debugger_waitUntilBPisReached("5000");
  ExpectedTestResult(debugger_result, IS_CPU_STOP_AT_BP_SUCCESFUL, "BP is reached.");
  
  testStep("STEP", "Write first byte of NVP_BLOCK_ID_AEE_TRACEABILITY_RamBlockData --> Variable overwritten with 0x1.");
  debugger_writeVariable("uint8", "NVP_BLOCK_ID_AEE_TRACEABILITY_RamBlockData,,app.elf", "0", "1");
  ExpectedTestResult(debugger_result, "NVP_BLOCK_ID_AEE_TRACEABILITY_RamBlockData", "Variable overwritten with 0x1");

  ////====================================================
  testCaseComment("Postcondition");
  testStep("STEP", "Return ECU to default values");
  RunPostTs();
}

testcase SW_Int_DIA_DataServices_PreSafe_Cycles_Level_1_8_CombinedSignal_WriteData_01()
{
  ////***********************************Test report header*********************************
  testReportAddMiscInfoBlock("AUTOLIV ELECTRONICS document");
  TestReportAddMiscInfo("Nightly test", "No");
  TestReportAddMiscInfo("Test type", "Requirement-Based test");
  TestReportAddMiscInfo("Regression Test", "No");
  TestReportAddMiscInfo("Fault injection method used", "No");
  TestReportAddMiscInfo("Resource usage evaluation", "No");
  TestReportAddMiscInfo("Priority", "No");
  TestReportAddMiscInfo("Safety relevant", "No");
  
  AddRequirementInfo("Requirement under test", "ARCH_SW_DIA_0022; ARCH_SW_DIA_0088; ARCH_SW_DIA_0089; ARCH_SW_DIA_0203");
  AddRequirementInfo("ARCH_SW_DIA_0022", "Service 0x2E will be implemented for DID 0300.");
  AddRequirementInfo("ARCH_SW_DIA_0088", "Service shall be available in Default, Extended and Development session.");
  AddRequirementInfo("ARCH_SW_DIA_0089", "Request data shall be 1048 bytes long.");
  AddRequirementInfo("ARCH_SW_DIA_0203", "Blocks NVP_BLOCK_ID_CYCLE_0 to NVP_BLOCK_ID_CYCLE_25 and NVP_BLOCK_ID_STEP_0 to NVP_BLOCK_ID_STEP_91 shall be written.");

  ////***************************************************************************************

  testCaseComment("Preconditions");
  testStep("STEP", "Bench Initialization");
  
  testStep("", "Delete all breakpoint from debugger.");
  debugger_deleteAllBreakpoints();

  testStep("", "Reset the debugger.");
  debugger_reset();
    
  testStep("", "Run the debugger.");
  debugger_run();
  
  RunPreTs();
  ////====================================================
    testStep("STEP", "Enter development session.");
  EnterDiagnosticSession("development");
  
  testStep("STEP", "Set breakpoint in function *DataServices_PreSafe_Cycles_Level_1_8_CombinedSignal_WriteData*.");
  debugger_setRelativeFunctionBpAtLine("DataServices_PreSafe_Cycles_Level_1_8_CombinedSignal_WriteData", "42");
  debugger_run();
 
  testCaseComment("Action: ARCH_SW_DIA_0022; ARCH_SW_DIA_0088; ARCH_SW_DIA_0089; ARCH_SW_DIA_0203");
  testStep("STEP", "Send diag request for 2E 0300 and wait for timeout error --> Timeout reached.");
  SendDiagnosticRequestNegativeResponse(dPresafeCycleWriteRequest, dPresafeCycleWriteResponse, TRUE);

  testWaitForTimeout(2000);
  testStep("STEP", "Check if breakpoint from function DataServices_PreSafe_Cycles_Level_1_8_CombinedSignal_WriteData was reached. --> BP was reached.");
  debugger_waitUntilBPisReached("5000");
  ExpectedTestResult(debugger_result, IS_CPU_STOP_AT_BP_SUCCESFUL, "BP is reached.");
  
  testStep("STEP", "Write first byte of NVP_BLOCK_ID_STEP_0_RamBlockData --> Variable overwritten with 0x1.");
  debugger_writeVariable("uint8", "NVP_BLOCK_ID_STEP_0_RamBlockData,,app.elf", "0", "1");
  ExpectedTestResult(debugger_result, "NVP_BLOCK_ID_STEP_0_RamBlockData", "Variable overwritten with 0x1");

  ////====================================================
  testCaseComment("Postcondition");
  testStep("STEP", "Return ECU to default values");
  RunPostTs();
}

testcase SW_Int_DIA_DataServices_Release_Cycles_BSR_and_PreSafe_CombinedSignal_ReadData_WriteData_01()
{
  diagRequest RBTMFL174.Release_Cycles_BSR_and_PreSafe_Write dReleaseCyclesBSRandPresafeWriteRequest;
  diagResponse RBTMFL174.Release_Cycles_BSR_and_PreSafe_Write dReleaseCyclesBSRandPresafeWriteResponse;
  //***********************************Test report header*********************************
  testReportAddMiscInfoBlock("AUTOLIV ELECTRONICS document");
  TestReportAddMiscInfo("Nightly test", "No");
  TestReportAddMiscInfo("Test type", "Requirement-Based test");
  TestReportAddMiscInfo("Regression Test", "No");
  TestReportAddMiscInfo("Fault injection method used", "No");
  TestReportAddMiscInfo("Resource usage evaluation", "No");
  TestReportAddMiscInfo("Priority", "No");
  TestReportAddMiscInfo("Safety relevant", "No");
  
  AddRequirementInfo("Requirement under test", "ARCH_SW_DIA_0024; ARCH_SW_DIA_0093; ARCH_SW_DIA_0094; ARCH_SW_DIA_0095");
  AddRequirementInfo("ARCH_SW_DIA_0024", "Service 0x2E will be implemented for DID 0301.");
  AddRequirementInfo("ARCH_SW_DIA_0093", "Service shall be available in Default, Extended and Development session.");
  AddRequirementInfo("ARCH_SW_DIA_0094", "Request data shall be 144 bytes long");
  AddRequirementInfo("ARCH_SW_DIA_0095", "Blocks NVP_BLOCK_ID_CYCLE_29 to NVP_BLOCK_ID_CYCLE_32 and NVP_BLOCK_ID_STEP_92 to NVP_BLOCK_ID_STEP_115 shall be written.");

  //***************************************************************************************

  testCaseComment("Preconditions");
  testStep("STEP", "Bench Initialization");
  
  testStep("", "Delete all breakpoint from debugger.");
  debugger_deleteAllBreakpoints();

  testStep("", "Reset the debugger.");
  debugger_reset();
    
  testStep("", "Run the debugger.");
  debugger_run();
  
  RunPreTs();
  //====================================================
  GetSecurityAccess("supplier");
  
  testStep("STEP", "Set breakpoint in function *DataServices_Release_Cycles_BSR_and_PreSafe_CombinedSignal_ReadData_WriteData*.");
  debugger_setRelativeFunctionBpAtLine("DataServices_Release_Cycles_BSR_and_PreSafe_CombinedSignal_ReadData_WriteData", "37");
  debugger_run();
 
  testCaseComment("Action: ARCH_SW_DIA_0024; ARCH_SW_DIA_0093; ARCH_SW_DIA_0094; ARCH_SW_DIA_0095");
  testStep("STEP", "Send diag request for 2E 0301 and wait for timeout error --> Timeout reached.");
  SendDiagnosticRequestNegativeResponse(dReleaseCyclesBSRandPresafeWriteRequest, dReleaseCyclesBSRandPresafeWriteResponse, TRUE);

  testWaitForTimeout(2000);
  testStep("STEP", "Check if breakpoint from function DataServices_Release_Cycles_BSR_and_PreSafe_CombinedSignal_ReadData_WriteData was reached. --> BP was reached.");
  debugger_waitUntilBPisReached("5000");
  ExpectedTestResult(debugger_result, IS_CPU_STOP_AT_BP_SUCCESFUL, "BP is reached.");
  
  testStep("STEP", "Write 29th byte of NVP_BLOCK_ID_CYCLE_0_RamBlockData --> Variable overwritten with 0x1.");
  debugger_writeVariable("uint8", "NVP_BLOCK_ID_CYCLE_0_RamBlockData,,app.elf,,app.elf", "29", "1");
  ExpectedTestResult(debugger_result, "NVP_BLOCK_ID_CYCLE_0_RamBlockData", "Variable overwritten with 0x1");

  //====================================================
  testCaseComment("Postcondition");
  testStep("STEP", "Return ECU to default values");
  RunPostTs();
}

testcase SW_Int_DIA_DataServices_Tensioning_Cycle_BSR_CombinedSignal_WriteData_01()
{
  ////***********************************Test report header*********************************
  testReportAddMiscInfoBlock("AUTOLIV ELECTRONICS document");
  TestReportAddMiscInfo("Nightly test", "No");
  TestReportAddMiscInfo("Test type", "Requirement-Based test");
  TestReportAddMiscInfo("Regression Test", "No");
  TestReportAddMiscInfo("Fault injection method used", "No");
  TestReportAddMiscInfo("Resource usage evaluation", "No");
  TestReportAddMiscInfo("Priority", "No");
  TestReportAddMiscInfo("Safety relevant", "No");
  
  AddRequirementInfo("Requirement under test", "ARCH_SW_DIA_0028; ARCH_SW_DIA_0105; ARCH_SW_DIA_0106; ARCH_SW_DIA_0107;");
  AddRequirementInfo("ARCH_SW_DIA_0028", "Service 0x2E will be implemented for DID 0310.");
  AddRequirementInfo("ARCH_SW_DIA_0105", "Service shall be available in Default, Extended and Development session.");
  AddRequirementInfo("ARCH_SW_DIA_0106", "Request data shall be 1 byte long.");
  AddRequirementInfo("ARCH_SW_DIA_0107", "Blocks NVP_BLOCK_ID_CYCLE_26 to NVP_BLOCK_ID_CYCLE_28 and NVP_BLOCK_ID_STEP_116 to NVP_BLOCK_ID_STEP_144 shall be written");

  ////***************************************************************************************

  testCaseComment("Preconditions");
  testStep("STEP", "Bench Initialization");
  
  testStep("", "Delete all breakpoint from debugger.");
  debugger_deleteAllBreakpoints();

  testStep("", "Reset the debugger.");
  debugger_reset();
    
  testStep("", "Run the debugger.");
  debugger_run();
  
  RunPreTs();
  ////====================================================
    testStep("STEP", "Enter development session.");
  EnterDiagnosticSession("development");
  
  testStep("STEP", "Set breakpoint in function *DataServices_Tensioning_Cycle_BSR_CombinedSignal_WriteData*.");
  debugger_setRelativeFunctionBpAtLine("DataServices_Tensioning_Cycle_BSR_CombinedSignal_WriteData", "37");
  debugger_run();
 
  testCaseComment("Action: ARCH_SW_DIA_0026; ARCH_SW_DIA_0099; ARCH_SW_DIA_0100; ARCH_SW_DIA_0101");
  testStep("STEP", "Send diag request for 2E 0302 and wait for timeout error --> Timeout reached.");
  SendDiagnosticRequestNegativeResponse(dTensioningCycleBSRWriteRequest, dTensioningCycleBSRWriteResponse, TRUE);

  testWaitForTimeout(2000);
  testStep("STEP", "Check if breakpoint from function DataServices_Tensioning_Cycle_BSR_CombinedSignal_WriteData was reached. --> BP was reached.");
  debugger_waitUntilBPisReached("5000");
  ExpectedTestResult(debugger_result, IS_CPU_STOP_AT_BP_SUCCESFUL, "BP is reached.");
  
  testStep("STEP", "Write 26th byte of NVP_BLOCK_ID_CYCLE_0_RamBlockData --> Variable overwritten with 0x1.");
  debugger_writeVariable("uint8", "NVP_BLOCK_ID_CYCLE_0_RamBlockData,,app.elf,,app.elf", "26", "1");
  ExpectedTestResult(debugger_result, "NVP_BLOCK_ID_CYCLE_0_RamBlockData", "Variable overwritten with 0x1");

  ////====================================================
  testCaseComment("Postcondition");
  testStep("STEP", "Return ECU to default values");
  RunPostTs();
}

testcase SW_Int_DIA_DataServices_Vehicle_Equipment_Read_Equipment_1_WriteData_01()
{
  diagRequest RBTMFL174.Vehicle_Equipment_Write dVehicleEquipmentWriteRequest;
  diagResponse RBTMFL174.Vehicle_Equipment_Write dVehicleEquipmentWriteResponse;
  //***********************************Test report header*********************************
  testReportAddMiscInfoBlock("AUTOLIV ELECTRONICS document");
  TestReportAddMiscInfo("Nightly test", "No");
  TestReportAddMiscInfo("Test type", "Requirement-Based test");
  TestReportAddMiscInfo("Regression Test", "No");
  TestReportAddMiscInfo("Fault injection method used", "No");
  TestReportAddMiscInfo("Resource usage evaluation", "No");
  TestReportAddMiscInfo("Priority", "No");
  TestReportAddMiscInfo("Safety relevant", "No");
  
  AddRequirementInfo("Requirement under test", "ARCH_SW_DIA_0028; ARCH_SW_DIA_0105; ARCH_SW_DIA_0106; ARCH_SW_DIA_0107; ARCH_SW_DIA_0393; ARCH_SW_DIA_0046");
  AddRequirementInfo("ARCH_SW_DIA_0028", "Service 0x2E will be implemented for DID 0310.");
  AddRequirementInfo("ARCH_SW_DIA_0105", "Service shall be available in Default, Extended and Development session.");
  AddRequirementInfo("ARCH_SW_DIA_0106", "Request data shall be 1 byte long.");
  AddRequirementInfo("ARCH_SW_DIA_0107", "Runnable shall write Equipment 1 stored in Rte_Ct_MBBL_SsaAppl_Coding_VehicleEquipment.Equipment1");
  AddRequirementInfo("ARCH_SW_DIA_0393", "The new data written by Vehicle Equipment Configuration Data service (0x2E 0310) shall be stored in non-volatile memoy and shall be available only after reset.");
  AddRequirementInfo("ARCH_SW_DIA_0046", "There shall be 2 reserved bytes located between Equipment 6 and Uberspannungsabbruchschwelle for request write of DID 0310.");

  //***************************************************************************************

  testCaseComment("Preconditions");
  testStep("STEP", "Bench Initialization");
  
  testStep("", "Delete all breakpoint from debugger.");
  debugger_deleteAllBreakpoints();

  testStep("", "Reset the debugger.");
  debugger_reset();
    
  testStep("", "Run the debugger.");
  debugger_run();
  
  RunPreTs();
  //====================================================
 
  testStep("STEP", "Enter development session.");
  EnterDiagnosticSession("development");
  
  @SecVarCodingPanel::Button_CodingStart = 1;
  testWaitForTimeout(2000);
  
  testStep("STEP", "Set breakpoint in function *DataServices_Vehicle_Equipment_Read_Equipment_1_WriteData*.");
  debugger_setRelativeFunctionBpAtLine("DataServices_Vehicle_Equipment_Read_Equipment_1_WriteData", "11");
  debugger_run();
 
  testCaseComment("Action: ARCH_SW_DIA_0028; ARCH_SW_DIA_0105; ARCH_SW_DIA_0106; ARCH_SW_DIA_0107; ARCH_SW_DIA_0393;");
  testStep("STEP", "Send diag request for 2E 0310 and wait for timeout error --> Timeout reached.");
  SendDiagnosticRequestNegativeResponse(dVehicleEquipmentWriteRequest, dVehicleEquipmentWriteResponse, TRUE);

  testWaitForTimeout(2000);
  testStep("STEP", "Check if breakpoint from function DataServices_Vehicle_Equipment_Read_Equipment_1_WriteData was reached. --> BP was reached.");
  debugger_waitUntilBPisReached("5000");
  ExpectedTestResult(debugger_result, IS_CPU_STOP_AT_BP_SUCCESFUL, "BP is reached.");
  
  @SecVarCodingPanel::Button_CancelSequence = 1;
  testWaitForTimeout(2000);
  //====================================================
  testCaseComment("Postcondition");
  testStep("STEP", "Return ECU to default values");
  RunPostTs();
}

testcase SW_Int_DIA_DataServices_Vehicle_Equipment_Read_Equipment_2_WriteData_01()
{
  diagRequest RBTMFL174.Vehicle_Equipment_Write dVehicleEquipmentWriteRequest;
  diagResponse RBTMFL174.Vehicle_Equipment_Write dVehicleEquipmentWriteResponse;
  //***********************************Test report header*********************************
  testReportAddMiscInfoBlock("AUTOLIV ELECTRONICS document");
  TestReportAddMiscInfo("Nightly test", "No");
  TestReportAddMiscInfo("Test type", "Requirement-Based test");
  TestReportAddMiscInfo("Regression Test", "No");
  TestReportAddMiscInfo("Fault injection method used", "No");
  TestReportAddMiscInfo("Resource usage evaluation", "No");
  TestReportAddMiscInfo("Priority", "No");
  TestReportAddMiscInfo("Safety relevant", "No");
  
  AddRequirementInfo("Requirement under test", "ARCH_SW_DIA_0028; ARCH_SW_DIA_0110; ARCH_SW_DIA_0111;");
  AddRequirementInfo("ARCH_SW_DIA_0028", "Service 0x2E will be implemented for DID 0310.");
  AddRequirementInfo("ARCH_SW_DIA_0110", "Request data shall be 1 byte long.");
  AddRequirementInfo("ARCH_SW_DIA_0111", "Runnable shall write Equipment 2 stored in Rte_Ct_MBBL_SsaAppl_Coding_VehicleEquipment.Equipment2.");

  //***************************************************************************************

  testCaseComment("Preconditions");
  testStep("STEP", "Bench Initialization");
  
  testStep("", "Delete all breakpoint from debugger.");
  debugger_deleteAllBreakpoints();

  testStep("", "Reset the debugger.");
  debugger_reset();
    
  testStep("", "Run the debugger.");
  debugger_run();
  
  RunPreTs();
  //====================================================
  testStep("STEP", "Enter development session.");
  EnterDiagnosticSession("development");
  
  @SecVarCodingPanel::Button_CodingStart = 1;
  testWaitForTimeout(2000);
  
  testStep("STEP", "Set breakpoint in function *DataServices_Vehicle_Equipment_Read_Equipment_2_WriteData*.");
  debugger_setRelativeFunctionBpAtLine("DataServices_Vehicle_Equipment_Read_Equipment_2_WriteData", "11");
  debugger_run();
 
  testCaseComment("Action: ARCH_SW_DIA_0028; ARCH_SW_DIA_0110; ARCH_SW_DIA_0111;");
  testStep("STEP", "Send diag request for 2E 0310 and wait for timeout error --> Timeout reached.");
  SendDiagnosticRequestNegativeResponse(dVehicleEquipmentWriteRequest, dVehicleEquipmentWriteResponse, TRUE);

  testWaitForTimeout(2000);
  testStep("STEP", "Check if breakpoint from function DataServices_Vehicle_Equipment_Read_Equipment_2_WriteData was reached. --> BP was reached.");
  debugger_waitUntilBPisReached("5000");
  ExpectedTestResult(debugger_result, IS_CPU_STOP_AT_BP_SUCCESFUL, "BP is reached.");
  
    @SecVarCodingPanel::Button_CancelSequence = 1;
  testWaitForTimeout(2000);
  //====================================================
  testCaseComment("Postcondition");
  testStep("STEP", "Return ECU to default values");
  RunPostTs();
}

testcase SW_Int_DIA_DataServices_Vehicle_Equipment_Read_Equipment_3_WriteData_01()
{
  
  diagRequest RBTMFL174.Vehicle_Equipment_Write dVehicleEquipmentWriteRequest;
  diagResponse RBTMFL174.Vehicle_Equipment_Write dVehicleEquipmentWriteResponse;
  
  //***********************************Test report header*********************************
  testReportAddMiscInfoBlock("AUTOLIV ELECTRONICS document");
  TestReportAddMiscInfo("Nightly test", "No");
  TestReportAddMiscInfo("Test type", "Requirement-Based test");
  TestReportAddMiscInfo("Regression Test", "No");
  TestReportAddMiscInfo("Fault injection method used", "No");
  TestReportAddMiscInfo("Resource usage evaluation", "No");
  TestReportAddMiscInfo("Priority", "No");
  TestReportAddMiscInfo("Safety relevant", "No");
  
  AddRequirementInfo("Requirement under test", "ARCH_SW_DIA_0028; ARCH_SW_DIA_0114;");
  AddRequirementInfo("ARCH_SW_DIA_0028", "Service 0x2E will be implemented for DID 0310.");
  AddRequirementInfo("ARCH_SW_DIA_0114", "Request data shall be 1 byte long.");
  AddRequirementInfo("ARCH_SW_DIA_0115", "Runnable shall write Equipment 3 stored in Rte_Ct_MBBL_SsaAppl_Coding_VehicleEquipment.Equipment3.");

  //***************************************************************************************

  testCaseComment("Preconditions");
  testStep("STEP", "Bench Initialization");
  
  testStep("", "Delete all breakpoint from debugger.");
  debugger_deleteAllBreakpoints();

  testStep("", "Reset the debugger.");
  debugger_reset();
    
  testStep("", "Run the debugger.");
  debugger_run();
  
  RunPreTs();
  //====================================================
  testStep("STEP", "Enter development session.");
  EnterDiagnosticSession("development");
  
  @SecVarCodingPanel::Button_CodingStart = 1;
  testWaitForTimeout(2000);
  
  testStep("STEP", "Set breakpoint in function *DataServices_Vehicle_Equipment_Read_Equipment_3_WriteData*.");
  debugger_setRelativeFunctionBpAtLine("DataServices_Vehicle_Equipment_Read_Equipment_3_WriteData", "11");
  debugger_run();
 
  testCaseComment("Action:ARCH_SW_DIA_0028; ARCH_SW_DIA_0114; ARCH_SW_DIA_0115");
  testStep("STEP", "Send diag request for 2E 0310 and wait for timeout error --> Timeout reached.");
  SendDiagnosticRequestNegativeResponse(dVehicleEquipmentWriteRequest, dVehicleEquipmentWriteResponse, TRUE);

  testWaitForTimeout(2000);
  testStep("STEP", "Check if breakpoint from function DataServices_Vehicle_Equipment_Read_Equipment_3_WriteData was reached. --> BP was reached.");
  debugger_waitUntilBPisReached("5000");
  ExpectedTestResult(debugger_result, IS_CPU_STOP_AT_BP_SUCCESFUL, "BP is reached.");
  
    @SecVarCodingPanel::Button_CancelSequence = 1;
  testWaitForTimeout(2000);
  
  //====================================================
  testCaseComment("Postcondition");
  testStep("STEP", "Return ECU to default values");
  RunPostTs();
}

testcase SW_Int_DIA_DataServices_Vehicle_Equipment_Read_Equipment_4_WriteData_01()
{
    diagRequest RBTMFL174.Vehicle_Equipment_Write dVehicleEquipmentWriteRequest;
  diagResponse RBTMFL174.Vehicle_Equipment_Write dVehicleEquipmentWriteResponse;
  //***********************************Test report header*********************************
  testReportAddMiscInfoBlock("AUTOLIV ELECTRONICS document");
  TestReportAddMiscInfo("Nightly test", "No");
  TestReportAddMiscInfo("Test type", "Requirement-Based test");
  TestReportAddMiscInfo("Regression Test", "No");
  TestReportAddMiscInfo("Fault injection method used", "No");
  TestReportAddMiscInfo("Resource usage evaluation", "No");
  TestReportAddMiscInfo("Priority", "No");
  TestReportAddMiscInfo("Safety relevant", "No");
  
  AddRequirementInfo("Requirement under test", "ARCH_SW_DIA_0028; ARCH_SW_DIA_0118; ARCH_SW_DIA_0119;");
  AddRequirementInfo("ARCH_SW_DIA_0028", "Service 0x2E will be implemented for DID 0310.");
  AddRequirementInfo("ARCH_SW_DIA_0118", "Request data shall be 1 byte long.");
  AddRequirementInfo("ARCH_SW_DIA_0119", "Runnable shall write Equipment 4 stored in Rte_Ct_MBBL_SsaAppl_Coding_VehicleEquipment.Equipment4.");

  //***************************************************************************************

  testCaseComment("Preconditions");
  testStep("STEP", "Bench Initialization");
  
  testStep("", "Delete all breakpoint from debugger.");
  debugger_deleteAllBreakpoints();

  testStep("", "Reset the debugger.");
  debugger_reset();
    
  testStep("", "Run the debugger.");
  debugger_run();
  
  RunPreTs();
  //====================================================
  testStep("STEP", "Enter development session.");
  EnterDiagnosticSession("development");
  
  @SecVarCodingPanel::Button_CodingStart = 1;
  testWaitForTimeout(2000);
  
  testStep("STEP", "Set breakpoint in function *DataServices_Vehicle_Equipment_Read_Equipment_4_WriteData*.");
  debugger_setRelativeFunctionBpAtLine("DataServices_Vehicle_Equipment_Read_Equipment_4_WriteData", "11");
  debugger_run();
 
  testCaseComment("Action: ARCH_SW_DIA_0028; ARCH_SW_DIA_0118; ARCH_SW_DIA_0119;");
  testStep("STEP", "Send diag request for 2E 0310 and wait for timeout error --> Timeout reached.");
  SendDiagnosticRequestNegativeResponse(dVehicleEquipmentWriteRequest, dVehicleEquipmentWriteResponse, TRUE);

  testWaitForTimeout(2000);
  testStep("STEP", "Check if breakpoint from function DataServices_Vehicle_Equipment_Read_Equipment_4_WriteData was reached. --> BP was reached.");
  debugger_waitUntilBPisReached("5000");
  ExpectedTestResult(debugger_result, IS_CPU_STOP_AT_BP_SUCCESFUL, "BP is reached.");
  
      @SecVarCodingPanel::Button_CancelSequence = 1;
  testWaitForTimeout(2000);
  //====================================================
  testCaseComment("Postcondition");
  testStep("STEP", "Return ECU to default values");
  RunPostTs();
}

testcase SW_Int_DIA_DataServices_Vehicle_Equipment_Read_Equipment_5_WriteData_01()
{
  diagRequest RBTMFL174.Vehicle_Equipment_Write dVehicleEquipmentWriteRequest;
  diagResponse RBTMFL174.Vehicle_Equipment_Write dVehicleEquipmentWriteResponse;
  //***********************************Test report header*********************************
  testReportAddMiscInfoBlock("AUTOLIV ELECTRONICS document");
  TestReportAddMiscInfo("Nightly test", "No");
  TestReportAddMiscInfo("Test type", "Requirement-Based test");
  TestReportAddMiscInfo("Regression Test", "No");
  TestReportAddMiscInfo("Fault injection method used", "No");
  TestReportAddMiscInfo("Resource usage evaluation", "No");
  TestReportAddMiscInfo("Priority", "No");
  TestReportAddMiscInfo("Safety relevant", "No");
  
  AddRequirementInfo("Requirement under test", "ARCH_SW_DIA_0028; ARCH_SW_DIA_0122; ARCH_SW_DIA_0123;");
  AddRequirementInfo("ARCH_SW_DIA_0028", "Service 0x2E will be implemented for DID 0310.");
  AddRequirementInfo("ARCH_SW_DIA_0122", "Request data shall be 1 byte long.");
  AddRequirementInfo("ARCH_SW_DIA_0123", "Runnable shall write Equipment 5 stored in Rte_Ct_MBBL_SsaAppl_Coding_VehicleEquipment.Equipment5");

  //***************************************************************************************

  testCaseComment("Preconditions");
  testStep("STEP", "Bench Initialization");
  
  testStep("", "Delete all breakpoint from debugger.");
  debugger_deleteAllBreakpoints();

  testStep("", "Reset the debugger.");
  debugger_reset();
    
  testStep("", "Run the debugger.");
  debugger_run();
  
  RunPreTs();
  //====================================================
  testStep("STEP", "Enter development session.");
  EnterDiagnosticSession("development");
  
  @SecVarCodingPanel::Button_CodingStart = 1;
  testWaitForTimeout(2000);
  
  testStep("STEP", "Set breakpoint in function *DataServices_Vehicle_Equipment_Read_Equipment_5_WriteData*.");
  debugger_setRelativeFunctionBpAtLine("DataServices_Vehicle_Equipment_Read_Equipment_5_WriteData", "11");
  debugger_run();
 
  testCaseComment("Action: ARCH_SW_DIA_0028; ARCH_SW_DIA_0122; ARCH_SW_DIA_0123;");
  testStep("STEP", "Send diag request for 2E 0310 and wait for timeout error --> Timeout reached.");
  SendDiagnosticRequestNegativeResponse(dVehicleEquipmentWriteRequest, dVehicleEquipmentWriteResponse, TRUE);

  testWaitForTimeout(2000);
  testStep("STEP", "Check if breakpoint from function DataServices_Vehicle_Equipment_Read_Equipment_5_WriteData was reached. --> BP was reached.");
  debugger_waitUntilBPisReached("5000");
  ExpectedTestResult(debugger_result, IS_CPU_STOP_AT_BP_SUCCESFUL, "BP is reached.");
  
        @SecVarCodingPanel::Button_CancelSequence = 1;
  testWaitForTimeout(2000);
  //====================================================
  testCaseComment("Postcondition");
  testStep("STEP", "Return ECU to default values");
  RunPostTs();
}

testcase SW_Int_DIA_DataServices_Vehicle_Equipment_Read_Equipment_6_WriteData_01()
{
  diagRequest RBTMFL174.Vehicle_Equipment_Write dVehicleEquipmentWriteRequest;
  diagResponse RBTMFL174.Vehicle_Equipment_Write dVehicleEquipmentWriteResponse;
  //***********************************Test report header*********************************
  testReportAddMiscInfoBlock("AUTOLIV ELECTRONICS document");
  TestReportAddMiscInfo("Nightly test", "No");
  TestReportAddMiscInfo("Test type", "Requirement-Based test");
  TestReportAddMiscInfo("Regression Test", "No");
  TestReportAddMiscInfo("Fault injection method used", "No");
  TestReportAddMiscInfo("Resource usage evaluation", "No");
  TestReportAddMiscInfo("Priority", "No");
  TestReportAddMiscInfo("Safety relevant", "No");
  
  AddRequirementInfo("Requirement under test", "ARCH_SW_DIA_0028; ARCH_SW_DIA_0126; ARCH_SW_DIA_0127;");
  AddRequirementInfo("ARCH_SW_DIA_0028", "Service 0x2E will be implemented for DID 0310.");
  AddRequirementInfo("ARCH_SW_DIA_0126", "Request data shall be 1 byte long.");
  AddRequirementInfo("ARCH_SW_DIA_0127", "Runnable shall write Equipment 6 stored in Rte_Ct_MBBL_SsaAppl_Coding_VehicleEquipment.Equipment6");

  //***************************************************************************************

  testCaseComment("Preconditions");
  testStep("STEP", "Bench Initialization");
  
  testStep("", "Delete all breakpoint from debugger.");
  debugger_deleteAllBreakpoints();

  testStep("", "Reset the debugger.");
  debugger_reset();
    
  testStep("", "Run the debugger.");
  debugger_run();
  
  RunPreTs();
  //====================================================
  testStep("STEP", "Enter development session.");
  EnterDiagnosticSession("development");
  
  @SecVarCodingPanel::Button_CodingStart = 1;
  testWaitForTimeout(2000);
  
  testStep("STEP", "Set breakpoint in function *DataServices_Vehicle_Equipment_Read_Equipment_6_WriteData*.");
  debugger_setRelativeFunctionBpAtLine("DataServices_Vehicle_Equipment_Read_Equipment_6_WriteData", "11");
  debugger_run();
 
  testCaseComment("Action: ARCH_SW_DIA_0028; ARCH_SW_DIA_0126; ARCH_SW_DIA_0127;");
  testStep("STEP", "Send diag request for 2E 0310 and wait for timeout error --> Timeout reached.");
  SendDiagnosticRequestNegativeResponse(dVehicleEquipmentWriteRequest, dVehicleEquipmentWriteResponse, TRUE);

  testWaitForTimeout(2000);
  testStep("STEP", "Check if breakpoint from function DataServices_Vehicle_Equipment_Read_Equipment_6_WriteData was reached. --> BP was reached.");
  debugger_waitUntilBPisReached("5000");
  ExpectedTestResult(debugger_result, IS_CPU_STOP_AT_BP_SUCCESFUL, "BP is reached.");
  
  @SecVarCodingPanel::Button_CancelSequence = 1;
  testWaitForTimeout(2000);
  //====================================================
  testCaseComment("Postcondition");
  testStep("STEP", "Return ECU to default values");
  RunPostTs();
}

testcase SW_Int_DIA_DataServices_Vehicle_Equipment_Read_Uberspannungsabbruchschwelle_WriteData_01()
{
    diagRequest RBTMFL174.Vehicle_Equipment_Write dVehicleEquipmentWriteRequest;
  diagResponse RBTMFL174.Vehicle_Equipment_Write dVehicleEquipmentWriteResponse;
  //***********************************Test report header*********************************
  testReportAddMiscInfoBlock("AUTOLIV ELECTRONICS document");
  TestReportAddMiscInfo("Nightly test", "No");
  TestReportAddMiscInfo("Test type", "Requirement-Based test");
  TestReportAddMiscInfo("Regression Test", "No");
  TestReportAddMiscInfo("Fault injection method used", "No");
  TestReportAddMiscInfo("Resource usage evaluation", "No");
  TestReportAddMiscInfo("Priority", "No");
  TestReportAddMiscInfo("Safety relevant", "No");
  
  AddRequirementInfo("Requirement under test", "ARCH_SW_DIA_0028; ARCH_SW_DIA_0130; ARCH_SW_DIA_0131;");
  AddRequirementInfo("ARCH_SW_DIA_0028", "Service 0x2E will be implemented for DID 0310.");
  AddRequirementInfo("ARCH_SW_DIA_0130", "Request data shall be 2 bytes long.");
  AddRequirementInfo("ARCH_SW_DIA_0131", "Runanble shall write Uberspannungsabbruchschwelle stored in Rte_Ct_MBBL_SsaAppl_Coding_VehicleEquipment. Uberspannungsabbruchschwelle");

  //***************************************************************************************

  testCaseComment("Preconditions");
  testStep("STEP", "Bench Initialization");
  
  testStep("", "Delete all breakpoint from debugger.");
  debugger_deleteAllBreakpoints();

  testStep("", "Reset the debugger.");
  debugger_reset();
    
  testStep("", "Run the debugger.");
  debugger_run();
  
  RunPreTs();
  //====================================================
  testStep("STEP", "Enter development session.");
  EnterDiagnosticSession("development");
  
  @SecVarCodingPanel::Button_CodingStart = 1;
  testWaitForTimeout(2000);
  
  testStep("STEP", "Set breakpoint in function *DataServices_Vehicle_Equipment_Read_Uberspannungsabbruchschwelle_WriteData*.");
  debugger_setRelativeFunctionBpAtLine("DataServices_Vehicle_Equipment_Read_Uberspannungsabbruchschwelle_WriteData", "11");
  debugger_run();
 
  testCaseComment("Action: ARCH_SW_DIA_0028; ARCH_SW_DIA_0130; ARCH_SW_DIA_0131;");
  testStep("STEP", "Send diag request for 2E 0310 and wait for timeout error --> Timeout reached.");
  SendDiagnosticRequestNegativeResponse(dVehicleEquipmentWriteRequest, dVehicleEquipmentWriteResponse, TRUE);

  testWaitForTimeout(2000);
  testStep("STEP", "Check if breakpoint from function DataServices_Vehicle_Equipment_Read_Uberspannungsabbruchschwelle_WriteData was reached. --> BP was reached.");
  debugger_waitUntilBPisReached("5000");
  ExpectedTestResult(debugger_result, IS_CPU_STOP_AT_BP_SUCCESFUL, "BP is reached.");
  
    @SecVarCodingPanel::Button_CancelSequence = 1;
  testWaitForTimeout(2000);
  //====================================================
  testCaseComment("Postcondition");
  testStep("STEP", "Return ECU to default values");
  RunPostTs();
}

testcase SW_Int_DIA_DataServices_Vehicle_Equipment_Read_Uberspannungsbereichsschwelle_WriteData_01()
{
  diagRequest RBTMFL174.Vehicle_Equipment_Write dVehicleEquipmentWriteRequest;
  diagResponse RBTMFL174.Vehicle_Equipment_Write dVehicleEquipmentWriteResponse;
  //***********************************Test report header*********************************
  testReportAddMiscInfoBlock("AUTOLIV ELECTRONICS document");
  TestReportAddMiscInfo("Nightly test", "No");
  TestReportAddMiscInfo("Test type", "Requirement-Based test");
  TestReportAddMiscInfo("Regression Test", "No");
  TestReportAddMiscInfo("Fault injection method used", "No");
  TestReportAddMiscInfo("Resource usage evaluation", "No");
  TestReportAddMiscInfo("Priority", "No");
  TestReportAddMiscInfo("Safety relevant", "No");
  
  AddRequirementInfo("Requirement under test", "ARCH_SW_DIA_0028; ARCH_SW_DIA_0134; ARCH_SW_DIA_0135;");
  AddRequirementInfo("ARCH_SW_DIA_0028", "Service 0x2E will be implemented for DID 0310.");
  AddRequirementInfo("ARCH_SW_DIA_0134", "Request data shall be 2 bytes long.");
  AddRequirementInfo("ARCH_SW_DIA_0135", "Runanble shall write Uberspannungsbereichsschwelle stored in Rte_Ct_MBBL_SsaAppl_Coding_VehicleEquipment. Uberspannungsbereichsschwelle.");

  //***************************************************************************************

  testCaseComment("Preconditions");
  testStep("STEP", "Bench Initialization");
  
  testStep("", "Delete all breakpoint from debugger.");
  debugger_deleteAllBreakpoints();

  testStep("", "Reset the debugger.");
  debugger_reset();
    
  testStep("", "Run the debugger.");
  debugger_run();
  
  RunPreTs();
  //====================================================
  testStep("STEP", "Enter development session.");
  EnterDiagnosticSession("development");
  
  @SecVarCodingPanel::Button_CodingStart = 1;
  testWaitForTimeout(2000);
  
  testStep("STEP", "Set breakpoint in function *DataServices_Vehicle_Equipment_Read_Uberspannungsabbruchschwelle_WriteData*.");
  debugger_setRelativeFunctionBpAtLine("DataServices_Vehicle_Equipment_Read_Uberspannungsabbruchschwelle_WriteData", "11");
  debugger_run();
 
  testCaseComment("Action: ARCH_SW_DIA_0028; ARCH_SW_DIA_0130; ARCH_SW_DIA_0131;");
  testStep("STEP", "Send diag request for 2E 0310 and wait for timeout error --> Timeout reached.");
  SendDiagnosticRequestNegativeResponse(dVehicleEquipmentWriteRequest, dVehicleEquipmentWriteResponse, TRUE);

  testWaitForTimeout(2000);
  testStep("STEP", "Check if breakpoint from function DataServices_Vehicle_Equipment_Read_Uberspannungsabbruchschwelle_WriteData was reached. --> BP was reached.");
  debugger_waitUntilBPisReached("5000");
  ExpectedTestResult(debugger_result, IS_CPU_STOP_AT_BP_SUCCESFUL, "BP is reached.");
  
    @SecVarCodingPanel::Button_CancelSequence = 1;
  testWaitForTimeout(2000);
  //====================================================
  testCaseComment("Postcondition");
  testStep("STEP", "Return ECU to default values");
  RunPostTs();
}

testcase SW_Int_DIA_DataServices_Vehicle_Equipment_Read_Unterspannungsabbruchschwelle_WriteData_01()
{
  diagRequest RBTMFL174.Vehicle_Equipment_Write dVehicleEquipmentWriteRequest;
  diagResponse RBTMFL174.Vehicle_Equipment_Write dVehicleEquipmentWriteResponse;
  //***********************************Test report header*********************************
  testReportAddMiscInfoBlock("AUTOLIV ELECTRONICS document");
  TestReportAddMiscInfo("Nightly test", "No");
  TestReportAddMiscInfo("Test type", "Requirement-Based test");
  TestReportAddMiscInfo("Regression Test", "No");
  TestReportAddMiscInfo("Fault injection method used", "No");
  TestReportAddMiscInfo("Resource usage evaluation", "No");
  TestReportAddMiscInfo("Priority", "No");
  TestReportAddMiscInfo("Safety relevant", "No");
  
  AddRequirementInfo("Requirement under test", "ARCH_SW_DIA_0028; ARCH_SW_DIA_0138; ARCH_SW_DIA_0139;");
  AddRequirementInfo("ARCH_SW_DIA_0028", "Service 0x2E will be implemented for DID 0310.");
  AddRequirementInfo("ARCH_SW_DIA_0138", "Request data shall be 2 bytes long.");
  AddRequirementInfo("ARCH_SW_DIA_0139", "Runanble shall write Unterspannungsabbruchschwelle stored in Rte_Ct_MBBL_SsaAppl_Coding_VehicleEquipment. Unterspannungsabbruchschwelle.");

  //***************************************************************************************

  testCaseComment("Preconditions");
  testStep("STEP", "Bench Initialization");
  
  testStep("", "Delete all breakpoint from debugger.");
  debugger_deleteAllBreakpoints();

  testStep("", "Reset the debugger.");
  debugger_reset();
    
  testStep("", "Run the debugger.");
  debugger_run();
  
  RunPreTs();
  //====================================================
  testStep("STEP", "Enter development session.");
  EnterDiagnosticSession("development");
  
  @SecVarCodingPanel::Button_CodingStart = 1;
  testWaitForTimeout(2000);
  
  testStep("STEP", "Set breakpoint in function *DataServices_Vehicle_Equipment_Read_Unterspannungsabbruchschwelle_WriteData*.");
  debugger_setRelativeFunctionBpAtLine("DataServices_Vehicle_Equipment_Read_Unterspannungsabbruchschwelle_WriteData", "11");
  debugger_run();
 
  testCaseComment("Action: ARCH_SW_DIA_0028; ARCH_SW_DIA_0138; ARCH_SW_DIA_0139;");
  testStep("STEP", "Send diag request for 2E 0310 and wait for timeout error --> Timeout reached.");
  SendDiagnosticRequestNegativeResponse(dVehicleEquipmentWriteRequest, dVehicleEquipmentWriteResponse, TRUE);

  testWaitForTimeout(2000);
  testStep("STEP", "Check if breakpoint from function DataServices_Vehicle_Equipment_Read_Unterspannungsabbruchschwelle_WriteData was reached. --> BP was reached.");
  debugger_waitUntilBPisReached("5000");
  ExpectedTestResult(debugger_result, IS_CPU_STOP_AT_BP_SUCCESFUL, "BP is reached.");
  
  @SecVarCodingPanel::Button_CancelSequence = 1;
  testWaitForTimeout(2000);
  //====================================================
  testCaseComment("Postcondition");
  testStep("STEP", "Return ECU to default values");
  RunPostTs();
}

testcase SW_Int_DIA_DataServices_Vehicle_Equipment_Read_Unterspannungsbereichsschwelle_WriteData_01()
{
  diagRequest RBTMFL174.Vehicle_Equipment_Write dVehicleEquipmentWriteRequest;
  diagResponse RBTMFL174.Vehicle_Equipment_Write dVehicleEquipmentWriteResponse;
  //***********************************Test report header*********************************
  testReportAddMiscInfoBlock("AUTOLIV ELECTRONICS document");
  TestReportAddMiscInfo("Nightly test", "No");
  TestReportAddMiscInfo("Test type", "Requirement-Based test");
  TestReportAddMiscInfo("Regression Test", "No");
  TestReportAddMiscInfo("Fault injection method used", "No");
  TestReportAddMiscInfo("Resource usage evaluation", "No");
  TestReportAddMiscInfo("Priority", "No");
  TestReportAddMiscInfo("Safety relevant", "No");
  
  AddRequirementInfo("Requirement under test", "ARCH_SW_DIA_0028; ARCH_SW_DIA_0142; ARCH_SW_DIA_0143");
  AddRequirementInfo("ARCH_SW_DIA_0028", "Service 0x2E will be implemented for DID 0310.");
  AddRequirementInfo("ARCH_SW_DIA_0142", "Request data shall be 2 bytes long.");
  AddRequirementInfo("ARCH_SW_DIA_0143", "Runanble shall write Unterspannungsbereichsschwelle stored in Rte_Ct_MBBL_SsaAppl_Coding_VehicleEquipment. Unterspannungsbereichsschwelle.");

  //***************************************************************************************

  testCaseComment("Preconditions");
  testStep("STEP", "Bench Initialization");
  
  testStep("", "Delete all breakpoint from debugger.");
  debugger_deleteAllBreakpoints();

  testStep("", "Reset the debugger.");
  debugger_reset();
    
  testStep("", "Run the debugger.");
  debugger_run();
  
  RunPreTs();
  //====================================================
  testStep("STEP", "Enter development session.");
  EnterDiagnosticSession("development");
  
  @SecVarCodingPanel::Button_CodingStart = 1;
  testWaitForTimeout(2000);
  
  testStep("STEP", "Set breakpoint in function *DataServices_Vehicle_Equipment_Read_Unterspannungsbereichsschwelle_WriteData*.");
  debugger_setRelativeFunctionBpAtLine("DataServices_Vehicle_Equipment_Read_Unterspannungsbereichsschwelle_WriteData", "11");
  debugger_run();
 
  testCaseComment("Action: ARCH_SW_DIA_0028; ARCH_SW_DIA_0142; ARCH_SW_DIA_0143;");
  testStep("STEP", "Send diag request for 2E 0310 and wait for timeout error --> Timeout reached.");
  SendDiagnosticRequestNegativeResponse(dVehicleEquipmentWriteRequest, dVehicleEquipmentWriteResponse, TRUE);

  testWaitForTimeout(2000);
  testStep("STEP", "Check if breakpoint from function DataServices_Vehicle_Equipment_Read_Unterspannungsbereichsschwelle_WriteData was reached. --> BP was reached.");
  debugger_waitUntilBPisReached("5000");
  ExpectedTestResult(debugger_result, IS_CPU_STOP_AT_BP_SUCCESFUL, "BP is reached.");
  
    @SecVarCodingPanel::Button_CancelSequence = 1;
  testWaitForTimeout(2000);
  //====================================================
  testCaseComment("Postcondition");
  testStep("STEP", "Return ECU to default values");
  RunPostTs();
}

testcase SW_Int_DIA_DataServices_ZZZ_Vehicle_Equipment_Development_Read_Zykluszeit_Messtechnik_WriteData_01()
{
  diagRequest RBTMFL174.ZZZ_Vehicle_Equipment_Development_Write dZZZVehicleEquipmentWriteRequest;
  diagResponse RBTMFL174.ZZZ_Vehicle_Equipment_Development_Write dZZZVehicleEquipmentWriteResponse;
  //***********************************Test report header*********************************
  testReportAddMiscInfoBlock("AUTOLIV ELECTRONICS document");
  TestReportAddMiscInfo("Nightly test", "No");
  TestReportAddMiscInfo("Test type", "Requirement-Based test");
  TestReportAddMiscInfo("Regression Test", "No");
  TestReportAddMiscInfo("Fault injection method used", "No");
  TestReportAddMiscInfo("Resource usage evaluation", "No");
  TestReportAddMiscInfo("Priority", "No");
  TestReportAddMiscInfo("Safety relevant", "No");
  
  AddRequirementInfo("Requirement under test", "ARCH_SW_DIA_0030; ARCH_SW_DIA_0152; ARCH_SW_DIA_0153; ARCH_SW_DIA_0394; ARCH_SW_DIA_0395");
  AddRequirementInfo("ARCH_SW_DIA_0030", "Service 0x2E will be implemented for DID 0311.");
  AddRequirementInfo("ARCH_SW_DIA_0152", "Request data shall be 3 byte long.");
  AddRequirementInfo("ARCH_SW_DIA_0153", "Runnable shall write Zykluszeit Messtechnik stored in Rte_Ct_MBBL_SsaAppl_Coding_ZZZ_VehicleEquipment_Development. Zykluszeit_Messtechnik");
  AddRequirementInfo("ARCH_SW_DIA_0394", "The new data written by Vehicle Equipment Configuration Data service (0x2E 0311) shall be stored in non-volatile memoy and shall be available only after reset.");
  AddRequirementInfo("ARCH_SW_DIA_0395", "Byte 0: Reserved (shall not be used) ----------------------------------------------- Byte1_bit0 - Activation/deactivation of PRE-SAFE function 0x00 - yes - PRE-SAFE function activated 0x01 - no - PRE-SAFE function not activated Byte1_bit1 - Activation/deactivation of Display message (signal RBTM_xy_Disp_Rq_ST3) 0x00 - yes - Display message activated 0x01 - no - Display message not activated Byte1_bit2 - Activation / deactivation of counter limit. 0x00 - yes - counter limit deactivated 0x01 - no - counter limit activated Byte1_bit3 - CRC Fault monitoring 0x00 - yes - deactivated 0x01 - no - Activated Byte1_bits4-7: Reserved ----------------------------------------------- Byte 2: Reserved (shall not be used).");

  //***************************************************************************************

  testCaseComment("Preconditions");
  testStep("STEP", "Bench Initialization");
  
  testStep("", "Delete all breakpoint from debugger.");
  debugger_deleteAllBreakpoints();

  testStep("", "Reset the debugger.");
  debugger_reset();
    
  testStep("", "Run the debugger.");
  debugger_run();
  
  RunPreTs();
  //====================================================
  testStep("STEP", "Enter development session.");
  EnterDiagnosticSession("development");
  
  @SecVarCodingPanel::Button_CodingStart = 1;
  testWaitForTimeout(2000);
  
  testStep("STEP", "Set breakpoint in function *DataServices_ZZZ_Vehicle_Equipment_Development_Read_Zykluszeit_Messtechnik_WriteData*.");
  debugger_setRelativeFunctionBpAtLine("DataServices_ZZZ_Vehicle_Equipment_Development_Read_Zykluszeit_Messtechnik_WriteData", "11");
  debugger_run();
 
  testCaseComment("Action: ARCH_SW_DIA_0028; ARCH_SW_DIA_0142; ARCH_SW_DIA_0143;");
  testStep("STEP", "Send diag request for 2E 0311 and wait for timeout error --> Timeout reached.");
  SendDiagnosticRequestNegativeResponse(dZZZVehicleEquipmentWriteRequest, dZZZVehicleEquipmentWriteResponse, TRUE);

  testWaitForTimeout(2000);
  testStep("STEP", "Check if breakpoint from function DataServices_ZZZ_Vehicle_Equipment_Development_Read_Zykluszeit_Messtechnik_WriteData was reached. --> BP was reached.");
  debugger_waitUntilBPisReached("5000");
  ExpectedTestResult(debugger_result, IS_CPU_STOP_AT_BP_SUCCESFUL, "BP is reached.");
  
  testStep("STEP", "Overwrite Rte_Ct_MBBL_SsaAppl_Coding_ZZZ_VehicleEquipment_Development with 0x1");
  debugger_writeVariable("uint8", "Rte_Ct_MBBL_SsaAppl_Coding_ZZZ_VehicleEquipment_Development,,app.elf", "3", "1");
  ExpectedTestResult(debugger_result, "Rte_Ct_MBBL_SsaAppl_Coding_ZZZ_VehicleEquipment_Development", "Variable was overwritten");
  
  @SecVarCodingPanel::Button_CancelSequence = 1;
  testWaitForTimeout(2000);
  //====================================================
  testCaseComment("Postcondition");
  testStep("STEP", "Return ECU to default values");
  RunPostTs();
}

testcase SW_Int_DIA_DataServices_ZZZ_Vehicle_Equipment_Development_Read_Bitfield_WriteData_01()
{
  diagRequest RBTMFL174.ZZZ_Vehicle_Equipment_Development_Write dZZZVehicleEquipmentWriteRequest;
  diagResponse RBTMFL174.ZZZ_Vehicle_Equipment_Development_Write dZZZVehicleEquipmentWriteResponse;

  //***********************************Test report header*********************************
  testReportAddMiscInfoBlock("AUTOLIV ELECTRONICS document");
  TestReportAddMiscInfo("Nightly test", "No");
  TestReportAddMiscInfo("Test type", "Requirement-Based test");
  TestReportAddMiscInfo("Regression Test", "No");
  TestReportAddMiscInfo("Fault injection method used", "No");
  TestReportAddMiscInfo("Resource usage evaluation", "No");
  TestReportAddMiscInfo("Priority", "No");
  TestReportAddMiscInfo("Safety relevant", "No");
  
  AddRequirementInfo("Requirement under test", "ARCH_SW_DIA_0030; ARCH_SW_DIA_0147; ARCH_SW_DIA_0148; ARCH_SW_DIA_0149");
  AddRequirementInfo("ARCH_SW_DIA_0030", "Service 0x2E will be implemented for DID 0311.");
  AddRequirementInfo("ARCH_SW_DIA_0147", "Service shall be available in Default, Extended and Development session.");
  AddRequirementInfo("ARCH_SW_DIA_0148", "Request data shall be 3 byte long");
  AddRequirementInfo("ARCH_SW_DIA_0149", "Runnable shall write Bitfield stored in Rte_Ct_MBBL_SsaAppl_Coding_ZZZ_VehicleEquipment_Development.Bitfield.");

  //***************************************************************************************

  testCaseComment("Preconditions");
  testStep("STEP", "Bench Initialization");
  
  testStep("", "Delete all breakpoint from debugger.");
  debugger_deleteAllBreakpoints();

  testStep("", "Reset the debugger.");
  debugger_reset();
    
  testStep("", "Run the debugger.");
  debugger_run();
  
  RunPreTs();
  //====================================================
  testStep("STEP", "Enter development session.");
  EnterDiagnosticSession("development");
  
  @SecVarCodingPanel::Button_CodingStart = 1;
  testWaitForTimeout(2000);
  
  testStep("STEP", "Set breakpoint in function *DataServices_ZZZ_Vehicle_Equipment_Development_Read_Bitfield_WriteData*.");
  debugger_setRelativeFunctionBpAtLine("DataServices_ZZZ_Vehicle_Equipment_Development_Read_Bitfield_WriteData", "11");
  debugger_run();
 
  testCaseComment("Action: ARCH_SW_DIA_0030; ARCH_SW_DIA_0147; ARCH_SW_DIA_0148; ARCH_SW_DIA_0149");
  testStep("STEP", "Send diag request for 2E 0311 and wait for timeout error --> Timeout reached.");
  SendDiagnosticRequestNegativeResponse(dZZZVehicleEquipmentWriteRequest, dZZZVehicleEquipmentWriteResponse, TRUE);

  testWaitForTimeout(2000);
  testStep("STEP", "Check if breakpoint from function DataServices_ZZZ_Vehicle_Equipment_Development_Read_Bitfield_WriteData was reached. --> BP was reached.");
  debugger_waitUntilBPisReached("5000");
  ExpectedTestResult(debugger_result, IS_CPU_STOP_AT_BP_SUCCESFUL, "BP is reached.");
  
  testStep("STEP", "Overwrite Rte_Ct_MBBL_SsaAppl_Coding_ZZZ_VehicleEquipment_Development with 0x1");
  debugger_writeVariable("uint8", "Rte_Ct_MBBL_SsaAppl_Coding_ZZZ_VehicleEquipment_Development,,app.elf", "0", "1");
  ExpectedTestResult(debugger_result, "Rte_Ct_MBBL_SsaAppl_Coding_ZZZ_VehicleEquipment_Development", "Variable was overwritten");
  
  //====================================================
  testCaseComment("Postcondition");
  testStep("STEP", "Return ECU to default values");
  RunPostTs();
}

testcase SW_Int_DIA_runDidFDFF_MeasurementFrameBlock12ConfigWrite_01()
{
  ////***********************************Test report header*********************************
  testReportAddMiscInfoBlock("AUTOLIV ELECTRONICS document");
  TestReportAddMiscInfo("Nightly test", "No");
  TestReportAddMiscInfo("Test type", "Requirement-Based test");
  TestReportAddMiscInfo("Regression Test", "No");
  TestReportAddMiscInfo("Fault injection method used", "No");
  TestReportAddMiscInfo("Resource usage evaluation", "No");
  TestReportAddMiscInfo("Priority", "No");
  TestReportAddMiscInfo("Safety relevant", "No");
  
  AddRequirementInfo("Requirement under test", "ARCH_SW_DIA_0039; ARCH_SW_DIA_0174; ARCH_SW_DIA_0175, ARCH_SW_NVP_0012; ARCH_SW_DIA_0176");
  AddRequirementInfo("ARCH_SW_DIA_0039", "Service 0x2E will be implemented for DID FDFF.");
  AddRequirementInfo("ARCH_SW_DIA_0174", "Service shall be available in Development session.");
  AddRequirementInfo("ARCH_SW_DIA_0175", "Request data shall be 5 bytes long.");
  AddRequirementInfo("ARCH_SW_NVP_0012", "Runnable shall write Ram Address and Size stored in NVP_BLOCK_ID_MEASUREMENT_FRAME_12_CONFIG.");
  AddRequirementInfo("ARCH_SW_DIA_0176", "Runnable shall write Ram Address and Size stored in NVP_BLOCK_ID_MEASUREMENT_FRAME_12_CONFIG.");

  ////***************************************************************************************

  testCaseComment("Preconditions");
  testStep("STEP", "Bench Initialization");
  
  testStep("", "Delete all breakpoint from debugger.");
  debugger_deleteAllBreakpoints();

  testStep("", "Reset the debugger.");
  debugger_reset();
    
  testStep("", "Run the debugger.");
  debugger_run();
  
  RunPreTs();
  ////====================================================
    testStep("STEP", "Enter development session.");
  EnterDiagnosticSession("development");
  
  testStep("STEP", "Set breakpoint in function *DIA_runDidFDFF_MeasurementFrameBlock12ConfigWrite*.");
  debugger_setRelativeFunctionBpAtLine("DIA_runDidFDFF_MeasurementFrameBlock12ConfigWrite", "40");
  debugger_run();
 
  testCaseComment("Action: ARCH_SW_DIA_0039; ARCH_SW_DIA_0174; ARCH_SW_DIA_0175, ARCH_SW_NVP_0012; ARCH_SW_DIA_0176");
  testStep("STEP", "Send diag request for 2E FDFF and wait for timeout error --> Timeout reached.");
  SendDiagnosticRequestNegativeResponse(dWriteMFBlock12ConfigRequest, dWriteMFBlock12ConfigResponse, TRUE);

  testWaitForTimeout(2000);
  testStep("STEP", "Check if breakpoint from function DIA_runDidFDFF_MeasurementFrameBlock12ConfigWrite was reached. --> BP was reached.");
  debugger_waitUntilBPisReached("5000");
  ExpectedTestResult(debugger_result, IS_CPU_STOP_AT_BP_SUCCESFUL, "BP is reached.");
    
  ////====================================================
  testCaseComment("Postcondition");
  testStep("STEP", "Return ECU to default values");
  RunPostTs();
}

testcase SW_Int_DIA_runSid23_WriteMemoryByAddress_01()
{
  ////***********************************Test report header*********************************
  testReportAddMiscInfoBlock("AUTOLIV ELECTRONICS document");
  TestReportAddMiscInfo("Nightly test", "No");
  TestReportAddMiscInfo("Test type", "Requirement-Based test");
  TestReportAddMiscInfo("Regression Test", "No");
  TestReportAddMiscInfo("Fault injection method used", "No");
  TestReportAddMiscInfo("Resource usage evaluation", "No");
  TestReportAddMiscInfo("Priority", "No");
  TestReportAddMiscInfo("Safety relevant", "No");
  
  AddRequirementInfo("Requirement under test", "ARCH_SW_DIA_0041; ARCH_SW_DIA_0183; ARCH_SW_DIA_0184; ARCH_SW_DIA_0185; ARCH_SW_DIA_0186; ARCH_SW_DIA_0187");
  AddRequirementInfo("ARCH_SW_DIA_0041", "Service 0x3D will be implemented");
  AddRequirementInfo("ARCH_SW_DIA_0183", "Service shall be available in Development session.");
  AddRequirementInfo("ARCH_SW_DIA_0184", "MemoryIdentifier shall represent Address and Length format identifier .");
  AddRequirementInfo("ARCH_SW_DIA_0185", "MemoryAddress shall represent the address to write to");
  AddRequirementInfo("ARCH_SW_DIA_0186", "MemorySize shall represent the size to writte");
  AddRequirementInfo("ARCH_SW_DIA_0187", "MemoryData shall return data to be written with parameters above");


  ////***************************************************************************************

  testCaseComment("Preconditions");
  testStep("STEP", "Bench Initialization");
  
  testStep("", "Delete all breakpoint from debugger.");
  debugger_deleteAllBreakpoints();

  testStep("", "Reset the debugger.");
  debugger_reset();
    
  testStep("", "Run the debugger.");
  debugger_run();
  
  RunPreTs();
  ////====================================================
    testStep("STEP", "Enter development session.");
  EnterDiagnosticSession("development");
  
  testStep("STEP", "Set breakpoint in function *DIA_runSid23_WriteMemoryByAddress*.");
  debugger_setRelativeFunctionBpAtLine("DIA_runSid23_WriteMemoryByAddress", "999");
  debugger_run();
 
  testCaseComment("Action: ARCH_SW_DIA_0041; ARCH_SW_DIA_0183; ARCH_SW_DIA_0184; ARCH_SW_DIA_0185; ARCH_SW_DIA_0186; ARCH_SW_DIA_0187");
  testStep("STEP", "Send diag request for 3D and wait for timeout error --> Timeout reached.");
  SendDiagnosticRequestNegativeResponse(dWriteMemoryByAddressRequest, dWriteMemoryByAddressResponse, TRUE);

  testWaitForTimeout(2000);
  testStep("STEP", "Check if breakpoint from function DIA_runSid23_WriteMemoryByAddress was reached. --> BP was reached.");
  debugger_waitUntilBPisReached("5000");
  ExpectedTestResult(debugger_result, IS_CPU_STOP_AT_BP_SUCCESFUL, "BP is reached.");
    
  ////====================================================
  testCaseComment("Postcondition");
  testStep("STEP", "Return ECU to default values");
  RunPostTs();
}

testcase SW_Int_DIA_runDid0241_PRE_SAFE_Recorder_1_WriteData_01()
{
  diagRequest RBTMFL174.PRE_SAFE_Recorder_1_reset_Write dPresafeRecorder1WriteRequest;
  diagResponse RBTMFL174.PRE_SAFE_Recorder_1_reset_Write dPresafeRecorder1WriteResponse;

  //***********************************Test report header*********************************
  testReportAddMiscInfoBlock("AUTOLIV ELECTRONICS document");
  TestReportAddMiscInfo("Nightly test", "No");
  TestReportAddMiscInfo("Test type", "Requirement-Based test");
  TestReportAddMiscInfo("Regression Test", "No");
  TestReportAddMiscInfo("Fault injection method used", "No");
  TestReportAddMiscInfo("Resource usage evaluation", "No");
  TestReportAddMiscInfo("Priority", "No");
  TestReportAddMiscInfo("Safety relevant", "No");
  
  AddRequirementInfo("Requirement under test", "ARCH_SW_DIA_0240; ARCH_SW_DIA_0248; ARCH_SW_DIA_0249; ARCH_SW_DIA_0385; ARCH_SW_DIA_0386; ARCH_SW_DIA_0387; ARCH_SW_DIA_0480; ARCH_SW_DIA_0481; ARCH_SW_DIA_0482; ARCH_SW_DIA_0483");
  AddRequirementInfo("ARCH_SW_DIA_0240", "Service 0x22 (Read Data By Identifier) & 0x2E (Write Data By Identifier) for DID 0x0241 will be implemented");
  AddRequirementInfo("ARCH_SW_DIA_0248", "Service shall be available in Default session, Extended sessionUpdate session and Development session.");
  AddRequirementInfo("ARCH_SW_DIA_0249", "Service shall be available in the following forms of Authentication:Development ENHANCED, Production After-Sales ENHANCED, After-Sales After-Sales BASIC, Internal Diagnostic Test Tool, ePTI Test Tool.");
  AddRequirementInfo("ARCH_SW_DIA_0385", "Service 0x2E (Write Data By Identifier) will be implemented for DID 0241 (Reset Pre-Safe Recorder 1).");
  AddRequirementInfo("ARCH_SW_DIA_0386", "Request data shall be 1 byte long.");
  AddRequirementInfo("ARCH_SW_DIA_0387", "Byte 0 shall be defined as the Erase Pre-Safe Memory command and shall always have value 0x01.");
  AddRequirementInfo("ARCH_SW_DIA_0480", "DataIdentifier shall be 0x0241");
  AddRequirementInfo("ARCH_SW_DIA_0481", "Using this service shall lead to the Pre-Safe Recorder 1 to be set to default value.");
  AddRequirementInfo("ARCH_SW_DIA_0482", "The DID shall be available in the following sessions: ?Extended session ?Update Session ?Development Session ");
  AddRequirementInfo("ARCH_SW_DIA_0483", "This service shall be available under the following forms of Authentication: ?Supplier ?Development ENHANCED ?Production ");


  //***************************************************************************************

  testCaseComment("Preconditions");
  testStep("STEP", "Bench Initialization");
  
  testStep("", "Delete all breakpoint from debugger.");
  debugger_deleteAllBreakpoints();

  testStep("", "Reset the debugger.");
  debugger_reset();
    
  testStep("", "Run the debugger.");
  debugger_run();
  
  RunPreTs();
  //====================================================
  testStep("STEP", "Enter development session.");
  EnterDiagnosticSession("development");
  
  @SecVarCodingPanel::Button_CodingStart = 1;
  testWaitForTimeout(2000);
  
  testStep("STEP", "Set breakpoint in function *DIA_runDid0241_PRE_SAFE_Recorder_1_WriteData*.");
  debugger_setRelativeFunctionBpAtLine("DIA_runDid0241_PRE_SAFE_Recorder_1_WriteData", "0");
  debugger_run();
 
  testCaseComment("Action: ARCH_SW_DIA_0240; ARCH_SW_DIA_0248; ARCH_SW_DIA_0249");
  testStep("STEP", "Send diag request for 2E 0241 and wait for timeout error --> Timeout reached.");
  SendDiagnosticRequestNegativeResponse(dPresafeRecorder1WriteRequest, dPresafeRecorder1WriteResponse, TRUE);

  testWaitForTimeout(2000);
  testStep("STEP", "Check if breakpoint from function DIA_runDid0241_PRE_SAFE_Recorder_1_WriteData was reached. --> BP was reached.");
  debugger_waitUntilBPisReached("5000");
  ExpectedTestResult(debugger_result, IS_CPU_STOP_AT_BP_SUCCESFUL, "BP is reached.");
    
  @SecVarCodingPanel::Button_CancelSequence = 1;
  testWaitForTimeout(2000);
  //====================================================
  testCaseComment("Postcondition");
  testStep("STEP", "Return ECU to default values");
  RunPostTs();
}

testcase SW_Int_DIA_runDid0242_PRE_SAFE_Recorder_2_WriteData_01()
{
  ////***********************************Test report header*********************************
  testReportAddMiscInfoBlock("AUTOLIV ELECTRONICS document");
  TestReportAddMiscInfo("Nightly test", "No");
  TestReportAddMiscInfo("Test type", "Requirement-Based test");
  TestReportAddMiscInfo("Regression Test", "No");
  TestReportAddMiscInfo("Fault injection method used", "No");
  TestReportAddMiscInfo("Resource usage evaluation", "No");
  TestReportAddMiscInfo("Priority", "No");
  TestReportAddMiscInfo("Safety relevant", "No");
  
  AddRequirementInfo("Requirement under test", "ARCH_SW_DIA_0250; ARCH_SW_DIA_0258; ARCH_SW_DIA_0259; ARCH_SW_DIA_0390; ARCH_SW_DIA_0391; ARCH_SW_DIA_0392; ARCH_SW_DIA_0484; ARCH_SW_DIA_0485; ARCH_SW_DIA_0486; ARCH_SW_DIA_0487");
  AddRequirementInfo("ARCH_SW_DIA_0250", "Service 0x22 (Read Data By Identifier) & 0x2E (Write Data By Identifier) for DID 0x0242 will be implemented");
  AddRequirementInfo("ARCH_SW_DIA_0258", "Service shall be available in Default session, Extended sessionUpdate session and Development session.");
  AddRequirementInfo("ARCH_SW_DIA_0259", "Service shall be available in the following forms of Authentication:Development ENHANCED, Production After-Sales ENHANCED, After-Sales After-Sales BASIC, Internal Diagnostic Test Tool, ePTI Test Tool");
  AddRequirementInfo("ARCH_SW_DIA_0390", "Service 0x2E (Write Data By Identifier) will be implemented for DID 0242 (Reset Pre-Safe Recorder 2)");
  AddRequirementInfo("ARCH_SW_DIA_0391", "Request data shall be 1 byte long.");
  AddRequirementInfo("ARCH_SW_DIA_0392", "Byte 0 shall be defined as the Erase Pre-Safe Memory command and shall always have value 0x01.");
  AddRequirementInfo("ARCH_SW_DIA_0484", "DataIdentifier shall be 0x0242");
  AddRequirementInfo("ARCH_SW_DIA_0485", "Using this service shall lead to the Pre-Safe Recorder 2 to be set to default value.");
  AddRequirementInfo("ARCH_SW_DIA_0486", "The DID shall be available in the following sessions: ?Extended session ?Update Session ?Development Session.");
  AddRequirementInfo("ARCH_SW_DIA_0487", "This service shall be available under the following forms of Authentication: ?Supplier ?Development ENHANCED ?Production ?After-Sales ENHANCED ?After-Sales ");

  ////***************************************************************************************

  testCaseComment("Preconditions");
  testStep("STEP", "Bench Initialization");
  
  testStep("", "Delete all breakpoint from debugger.");
  debugger_deleteAllBreakpoints();

  testStep("", "Reset the debugger.");
  debugger_reset();
    
  testStep("", "Run the debugger.");
  debugger_run();
  
  RunPreTs();
  ////====================================================
    testStep("STEP", "Enter default session.");
  EnterDiagnosticSession("default");
  
    testStep("STEP", "Enter development session.");
  EnterDiagnosticSession("development");
  
  testStep("STEP", "Get security access.");
  SendDiagnosticRequest(dRequestSeedReprogrammingRequest, dRequestSeedReprogrammingResponse);
  SendDiagnosticRequest(dSendKeyReprogrammingRequest, dSendKeyReprogrammingResponse);
  
  testStep("STEP", "Set breakpoint in function *DIA_runDid0242_PRE_SAFE_Recorder_2_WriteData*.");
  debugger_setRelativeFunctionBpAtLine("DIA_runDid0242_PRE_SAFE_Recorder_2_WriteData", "18");
  debugger_run();
 
  testCaseComment("Action: ARCH_SW_DIA_0240; ARCH_SW_DIA_0248; ARCH_SW_DIA_0249");
  testStep("STEP", "Send diag request for 2E 0242 and wait for timeout error --> Timeout reached.");
  SendDiagnosticRequestNegativeResponse(dPresafeRecorder2WriteRequest, dPresafeRecorder2WriteResponse, TRUE);

  testWaitForTimeout(2000);
  testStep("STEP", "Check if breakpoint from function DIA_runDid0242_PRE_SAFE_Recorder_2_WriteData was reached. --> BP was reached.");
  debugger_waitUntilBPisReached("5000");
  ExpectedTestResult(debugger_result, IS_CPU_STOP_AT_BP_SUCCESFUL, "BP is reached.");
    
  ////====================================================
  testCaseComment("Postcondition");
  testStep("STEP", "Return ECU to default values");
  RunPostTs();
}

testcase SW_Int_DIA_runDidFD31_HBCalibrationWrite_01()
{
  ////***********************************Test report header*********************************
  testReportAddMiscInfoBlock("AUTOLIV ELECTRONICS document");
  TestReportAddMiscInfo("Nightly test", "No");
  TestReportAddMiscInfo("Test type", "Requirement-Based test");
  TestReportAddMiscInfo("Regression Test", "No");
  TestReportAddMiscInfo("Fault injection method used", "No");
  TestReportAddMiscInfo("Resource usage evaluation", "No");
  TestReportAddMiscInfo("Priority", "No");
  TestReportAddMiscInfo("Safety relevant", "No");
  
  AddRequirementInfo("Requirement under test", "ARCH_SW_DIA_0315; ARCH_SW_DIA_0316; ARCH_SW_DIA_0317; ARCH_SW_DIA_0318; ARCH_SW_DIA_0319; ARCH_SW_DIA_0320; ARCH_SW_DIA_0321");
  AddRequirementInfo("ARCH_SW_DIA_0315", "Service 0x2E (Write Data By Identifier) will be implemented for DID FD31 (ECU Calibration Parameters)");
  AddRequirementInfo("ARCH_SW_DIA_0316", "The ECU calibration parameters shall be modified in non-volatile and RAM memories.It means the changes will immediately affect the current SW session (ECU reset is not necessary to take into account the modifications).");
  AddRequirementInfo("ARCH_SW_DIA_0317", "The Write ECU Calibration Parameters service shall be available in the following sessions:Supplier Session/Development Session (0x7E)");
  AddRequirementInfo("ARCH_SW_DIA_0318", "Service Write ECU Location shall be available under the following forms of Authentication:SupplierDevelopment ENHANCEDProduction");
  AddRequirementInfo("ARCH_SW_DIA_0319", "Data Identifier of Write ECU Calibration Parameters shall be: 0xFD31");
  AddRequirementInfo("ARCH_SW_DIA_0320", "Write ECU Calibration Parameters Request data shall be 40 bytes long.");
  AddRequirementInfo("ARCH_SW_DIA_0321", "Bytes #2-#3:  DataIdentifier of the Write ECU Calibration Parameters shall be: 0xFD31");


  ////***************************************************************************************

  testCaseComment("Preconditions");
  testStep("STEP", "Bench Initialization");
  
  testStep("", "Delete all breakpoint from debugger.");
  debugger_deleteAllBreakpoints();

  testStep("", "Reset the debugger.");
  debugger_reset();
    
  testStep("", "Run the debugger.");
  debugger_run();
  
  RunPreTs();
  ////====================================================

    testStep("STEP", "Enter development session.");
  EnterDiagnosticSession("development");
  
  testStep("STEP", "Set breakpoint in function *DIA_runDidFD31_HBCalibrationWrite*.");
  debugger_setRelativeFunctionBpAtLine("DIA_runDidFD31_HBCalibrationWrite", "18");
  debugger_run();
 
  testCaseComment("Action: ARCH_SW_DIA_0305; ARCH_SW_DIA_0306; ARCH_SW_DIA_0307; ARCH_SW_DIA_0308; ARCH_SW_DIA_0309; ARCH_SW_DIA_0310; ARCH_SW_DIA_0311");
  testStep("STEP", "Send diag request for 2E FD31 and wait for timeout error --> Timeout reached.");
  SendDiagnosticRequestNegativeResponse(dWriteECUCalibParamRequest, dWriteECUCalibParamResponse, TRUE);

  testWaitForTimeout(2000);
  testStep("STEP", "Check if breakpoint from function DIA_runDidFD31_HBCalibrationWrite was reached. --> BP was reached.");
  debugger_waitUntilBPisReached("5000");
  ExpectedTestResult(debugger_result, IS_CPU_STOP_AT_BP_SUCCESFUL, "BP is reached.");
    
  ////====================================================
  testCaseComment("Postcondition");
  testStep("STEP", "Return ECU to default values");
  RunPostTs();
}

testcase SW_Int_DIA_runDidFD2F_EcuLocationWrite_01()
{
  ////***********************************Test report header*********************************
  testReportAddMiscInfoBlock("AUTOLIV ELECTRONICS document");
  TestReportAddMiscInfo("Nightly test", "No");
  TestReportAddMiscInfo("Test type", "Requirement-Based test");
  TestReportAddMiscInfo("Regression Test", "No");
  TestReportAddMiscInfo("Fault injection method used", "No");
  TestReportAddMiscInfo("Resource usage evaluation", "No");
  TestReportAddMiscInfo("Priority", "No");
  TestReportAddMiscInfo("Safety relevant", "No");
  
  AddRequirementInfo("Requirement under test", "ARCH_SW_DIA_0305; ARCH_SW_DIA_0306; ARCH_SW_DIA_0307; ARCH_SW_DIA_0308; ARCH_SW_DIA_0309; ARCH_SW_DIA_0310; ARCH_SW_DIA_0311");
  AddRequirementInfo("ARCH_SW_DIA_0305", "Service 0x2E (Write Data By Identifier) will be implemented for DID FD2F (ECU Location)");
  AddRequirementInfo("ARCH_SW_DIA_0306", "The Write ECU Location service shall be available in the following sessions:Supplier Session/Development Session (0x7E)");
  AddRequirementInfo("ARCH_SW_DIA_0307", "Service shall be available in the following forms of Authentication:Development ENHANCED, Production After-Sales ENHANCED, After-Sales After-Sales BASIC, Internal Diagnostic Test Tool, Production");
  AddRequirementInfo("ARCH_SW_DIA_0308", "Data Identifier of Write ECU Location shall be: 0xFD2F");
  AddRequirementInfo("ARCH_SW_DIA_0309", "The SIDE parameter shall be 1 byte and shall correspond to the side the ECU shall be configured to:0x99  RIGHT SIDE0x9C  LEFT SIDE");
  AddRequirementInfo("ARCH_SW_DIA_0310", "Bytes #2-#3:  DataIdentifier of the Write ECU location service shall be: 0xFD2F");
  AddRequirementInfo("ARCH_SW_DIA_0311", "If positive answer is sent, then value of SIDE shall be taken into account after reset.");
  ////***************************************************************************************

  testCaseComment("Preconditions");
  testStep("STEP", "Bench Initialization");
  
  testStep("", "Delete all breakpoint from debugger.");
  debugger_deleteAllBreakpoints();

  testStep("", "Reset the debugger.");
  debugger_reset();
    
  testStep("", "Run the debugger.");
  debugger_run();
  
  RunPreTs();
  ////====================================================

    testStep("STEP", "Enter development session.");
  EnterDiagnosticSession("development");
  
  testStep("STEP", "Set breakpoint in function *DIA_runDidFD2F_EcuLocationWrite*.");
  debugger_setRelativeFunctionBpAtLine("DIA_runDidFD2F_EcuLocationWrite", "10");
  debugger_run();
 
  testCaseComment("Action: ARCH_SW_DIA_0305; ARCH_SW_DIA_0306; ARCH_SW_DIA_0307; ARCH_SW_DIA_0308; ARCH_SW_DIA_0309; ARCH_SW_DIA_0310; ARCH_SW_DIA_0311");
  testStep("STEP", "Send diag request for 2E FD2F and wait for timeout error --> Timeout reached.");
  SendDiagnosticRequestNegativeResponse(dECULocationWriteRequest, dECULocationWriteResponse, TRUE);

  testWaitForTimeout(2000);
  testStep("STEP", "Check if breakpoint from function DIA_runDidFD2F_EcuLocationWrite was reached. --> BP was reached.");
  debugger_waitUntilBPisReached("5000");
  ExpectedTestResult(debugger_result, IS_CPU_STOP_AT_BP_SUCCESFUL, "BP is reached.");
    
  ////====================================================
  testCaseComment("Postcondition");
  testStep("STEP", "Return ECU to default values");
  RunPostTs();
}

testcase SW_Int_DIA_runSid23_ReadMemoryByAddress_01()
{
  diagRequest RBTMFL174.Memory_Read dMemoryReadRequest;
  diagResponse RBTMFL174.Memory_Read dMemoryReadResponse;

  //***********************************Test report header*********************************
  testReportAddMiscInfoBlock("AUTOLIV ELECTRONICS document");
  TestReportAddMiscInfo("Nightly test", "No");
  TestReportAddMiscInfo("Test type", "Requirement-Based test");
  TestReportAddMiscInfo("Regression Test", "No");
  TestReportAddMiscInfo("Fault injection method used", "No");
  TestReportAddMiscInfo("Resource usage evaluation", "No");
  TestReportAddMiscInfo("Priority", "No");
  TestReportAddMiscInfo("Safety relevant", "No");
  
  AddRequirementInfo("Requirement under test", "ARCH_SW_DIA_0040; ARCH_SW_DIA_0177; ARCH_SW_DIA_0178; ARCH_SW_DIA_0179; ARCH_SW_DIA_0180; ARCH_SW_DIA_0181; ARCH_SW_DIA_0182; ARCH_SW_DIA_0042; ARCH_SW_DIA_0043; ARCH_SW_DIA_0044");
  AddRequirementInfo("ARCH_SW_DIA_0040", "Service 0x23 will be implemented");
  AddRequirementInfo("ARCH_SW_DIA_0177", "Service shall be available in Development session");
  AddRequirementInfo("ARCH_SW_DIA_0178", "Runnable shall return data with the length of maximum 300 byes");
  AddRequirementInfo("ARCH_SW_DIA_0179", "MemoryIdentifier shall represent Address and Length format identifier ");
  AddRequirementInfo("ARCH_SW_DIA_0180", "MemoryAddress shall represent the address to read from");
  AddRequirementInfo("ARCH_SW_DIA_0181", "MemorySize shall represent the size to read");
  AddRequirementInfo("ARCH_SW_DIA_0182", "MemoryData shall return data to be read with parameters above.");
  AddRequirementInfo("ARCH_SW_DIA_0042", "Service 10 shall support the following sessions: Default, Programming, Extended and Development Session.");
  AddRequirementInfo("ARCH_SW_DIA_0043", "Service 10 shall be available in the following sessions: Default, Programming, Extended, Development Session and DefaultSession (of the Bootloader).");
  AddRequirementInfo("ARCH_SW_DIA_0044", "Transition to Development Session will be done only with authentication");

  //***************************************************************************************

  testCaseComment("Preconditions");
  testStep("STEP", "Bench Initialization");
  
  testStep("", "Delete all breakpoint from debugger.");
  debugger_deleteAllBreakpoints();

  testStep("", "Reset the debugger.");
  debugger_reset();
    
  testStep("", "Run the debugger.");
  debugger_run();
  
  RunPreTs();
  //====================================================

    testStep("STEP", "Enter development session.");
  EnterDiagnosticSession("development");
  
  testStep("STEP", "Set breakpoint in function *DIA_runSid23_ReadMemoryByAddress*.");
  debugger_setRelativeFunctionBpAtLine("DIA_runSid23_ReadMemoryByAddress", "0");
  debugger_run();
 
  testCaseComment("Action: ARCH_SW_DIA_0040; ARCH_SW_DIA_0177; ARCH_SW_DIA_0178; ARCH_SW_DIA_0179; ARCH_SW_DIA_0180; ARCH_SW_DIA_0181; ARCH_SW_DIA_0182; ARCH_SW_DIA_0042; ARCH_SW_DIA_0043; ARCH_SW_DIA_0044");
  testStep("STEP", "Send diag request for Memory Read and wait for timeout error --> Timeout reached.");
  SendDiagnosticRequestNegativeResponse(dMemoryReadRequest, dMemoryReadResponse, TRUE);

  testWaitForTimeout(2000);
  testStep("STEP", "Check if breakpoint from function DIA_runSid23_ReadMemoryByAddress was reached. --> BP was reached.");
  debugger_waitUntilBPisReached("5000");
  ExpectedTestResult(debugger_result, IS_CPU_STOP_AT_BP_SUCCESFUL, "BP is reached.");
    
  //====================================================
  testCaseComment("Postcondition");
  testStep("STEP", "Return ECU to default values");
  RunPostTs();
}

testcase SW_Int_DIA_RoELight_DTCStatusChanged_Callback_01()
{
  ////***********************************Test report header*********************************
  testReportAddMiscInfoBlock("AUTOLIV ELECTRONICS document");
  TestReportAddMiscInfo("Nightly test", "No");
  TestReportAddMiscInfo("Test type", "Requirement-Based test");
  TestReportAddMiscInfo("Regression Test", "No");
  TestReportAddMiscInfo("Fault injection method used", "No");
  TestReportAddMiscInfo("Resource usage evaluation", "No");
  TestReportAddMiscInfo("Priority", "No");
  TestReportAddMiscInfo("Safety relevant", "No");
  
  AddRequirementInfo("Requirement under test", "ARCH_SW_DIA_0210; ARCH_SW_DIA_0211; ARCH_SW_DIA_0212; ARCH_SW_DIA_0213; ARCH_SW_DIA_0260; ARCH_SW_DIA_0261; ARCH_SW_DIA_0262");
  AddRequirementInfo("ARCH_SW_DIA_0210", "ROE on Dtc Status change implemented.");
  AddRequirementInfo("ARCH_SW_DIA_0211", "This frame shall be identified with the address: Left side: 0x18E1A400  ROE_RBTM_FL_ST3 Right side: 0x18E1A500  ROE_RBTM_FR_ST3");
  AddRequirementInfo("ARCH_SW_DIA_0212", "ROE_0_RBTM_xy_ST3 (Byte 1) signal shall be transmitted with the value 0x01 - DTC_STATUS_CHANGE if DTC status has been changed. Byte 2 of the ROE_RBTM_xy_ST3 frame shall contain the availability mask of the DTC. Bytes 3-5 of the ROE_RBTM_xy_ST3 frame shall contain the DTC code. Byte 6 of the ROE_RBTM_xy_ST3 frame shall contain the status of the DTC. Bytes 7-8 of the ROE_RBTM_xy_ST3 frame shall be 0x0000. ");
  AddRequirementInfo("ARCH_SW_DIA_0213", "Default value: 0");
  AddRequirementInfo("ARCH_SW_DIA_0260", "Clear Diag Request Cycle Function");
  AddRequirementInfo("ARCH_SW_DIA_0261", "Get Diag Request Cycle Function");
  AddRequirementInfo("ARCH_SW_DIA_0262", "Cyclic processing task of the Tensioning Routines");

  ////***************************************************************************************

  testCaseComment("Preconditions");
  testStep("STEP", "Bench Initialization");
  
  testStep("", "Delete all breakpoint from debugger.");
  debugger_deleteAllBreakpoints();

  testStep("", "Reset the debugger.");
  debugger_reset();
    
  testStep("", "Run the debugger.");
  debugger_run();
  
  RunPreTs();
  ////====================================================

    testStep("STEP", "Enter development session.");
  EnterDiagnosticSession("development");
  
  testStep("STEP", "Set breakpoint in function *RoELight_DTCStatusChanged_Callback*.");
  debugger_setRelativeFunctionBpAtLine("RoELight_DTCStatusChanged_Callback", "24");
  debugger_run();
 
  testCaseComment("Action: ARCH_SW_DIA_0210; ARCH_SW_DIA_0211; ARCH_SW_DIA_0212; ARCH_SW_DIA_0213");
  testStep("STEP", "Send diag request for 14 (Fault Memory Clear) and wait for timeout error --> Timeout reached.");
  SendDiagnosticRequestNegativeResponse(dFaultMemoryClearRequest, dFaultMemoryClearResponse, TRUE);

  testWaitForTimeout(2000);
  testStep("STEP", "Check if breakpoint from function RoELight_DTCStatusChanged_Callback was reached. --> BP was reached.");
  debugger_waitUntilBPisReached("5000");
  ExpectedTestResult(debugger_result, IS_CPU_STOP_AT_BP_SUCCESFUL, "BP is reached.");
    
  ////====================================================
  testCaseComment("Postcondition");
  testStep("STEP", "Return ECU to default values");
  RunPostTs();
}


testcase SW_Int_DIA_runRidF703_CycleExecutionStart_01()
{
  diagRequest RBTMFL174.Cycle_Execution_Start dCycleExecutionStartRequest;
  diagResponse RBTMFL174.Cycle_Execution_Start dCycleExecutionStartResponse;

  //***********************************Test report header*********************************
  testReportAddMiscInfoBlock("AUTOLIV ELECTRONICS document");
  TestReportAddMiscInfo("Nightly test", "No");
  TestReportAddMiscInfo("Test type", "Requirement-Based test");
  TestReportAddMiscInfo("Regression Test", "No");
  TestReportAddMiscInfo("Fault injection method used", "No");
  TestReportAddMiscInfo("Resource usage evaluation", "No");
  TestReportAddMiscInfo("Priority", "No");
  TestReportAddMiscInfo("Safety relevant", "No");
  
  AddRequirementInfo("Requirement under test", "ARCH_SW_DIA_0013; ARCH_SW_DIA_0188; ARCH_SW_DIA_0189; ARCH_SW_DIA_0190");
  AddRequirementInfo("ARCH_SW_DIA_0013", "Service 0x31 01 will be implemented for RID F703.");
  AddRequirementInfo("ARCH_SW_DIA_0188", "Service shall be available in Development session");
  AddRequirementInfo("ARCH_SW_DIA_0189", "The RoutineControlOptionRecord shall reflect the selected cycle ");
  AddRequirementInfo("ARCH_SW_DIA_0190", "RoutineInfo can have the following values: 0x00, 0x01, 0x02 and 0xFF.");

  //***************************************************************************************

  testCaseComment("Preconditions");
  testStep("STEP", "Bench Initialization");
  
  testStep("", "Delete all breakpoint from debugger.");
  debugger_deleteAllBreakpoints();

  testStep("", "Reset the debugger.");
  debugger_reset();
    
  testStep("", "Run the debugger.");
  debugger_run();
  
  RunPreTs();
  //====================================================

  
  testStep("STEP", "Enter development session.");
  EnterDiagnosticSession("development");
  
  testStep("STEP", "Set breakpoint in function *DIA_runRidF703_CycleExecutionStart*.");
  debugger_setRelativeFunctionBpAtLine("DIA_runRidF703_CycleExecutionStart", "0");
  debugger_run();
 
  testCaseComment("Action: ARCH_SW_DIA_0013; ARCH_SW_DIA_0188; ARCH_SW_DIA_0189; ARCH_SW_DIA_0190");
  testStep("STEP", "Send diag request for RID F7 03 and wait for timeout error --> Timeout reached.");
  SendDiagnosticRequestNegativeResponse(dCycleExecutionStartRequest, dCycleExecutionStartResponse, TRUE);

  testWaitForTimeout(2000);
  testStep("STEP", "Check if breakpoint from function DIA_runRidF703_CycleExecutionStart was reached. --> BP was reached.");
  debugger_waitUntilBPisReached("5000");
  ExpectedTestResult(debugger_result, IS_CPU_STOP_AT_BP_SUCCESFUL, "BP is reached.");
    
  debugger_run();
  //====================================================
  testCaseComment("Postcondition");
  testStep("STEP", "Return ECU to default values");
  RunPostTs();
}

testcase SW_Int_DIA_runRidF703_CycleExecutionStop_01()
{
  ////***********************************Test report header*********************************
  testReportAddMiscInfoBlock("AUTOLIV ELECTRONICS document");
  TestReportAddMiscInfo("Nightly test", "No");
  TestReportAddMiscInfo("Test type", "Requirement-Based test");
  TestReportAddMiscInfo("Regression Test", "No");
  TestReportAddMiscInfo("Fault injection method used", "No");
  TestReportAddMiscInfo("Resource usage evaluation", "No");
  TestReportAddMiscInfo("Priority", "No");
  TestReportAddMiscInfo("Safety relevant", "No");
  
  AddRequirementInfo("Requirement under test", "ARCH_SW_DIA_0013; ARCH_SW_DIA_0188; ARCH_SW_DIA_0189; ARCH_SW_DIA_0190; ARCH_SW_DIA_0014; ARCH_SW_DIA_0191");
  AddRequirementInfo("ARCH_SW_DIA_0013", "Service 0x31 01 will be implemented for RID F703.");
  AddRequirementInfo("ARCH_SW_DIA_0188", "Service shall be available in Development session");
  AddRequirementInfo("ARCH_SW_DIA_0189", "The RoutineControlOptionRecord shall reflect the selected cycle ");
  AddRequirementInfo("ARCH_SW_DIA_0190", "RoutineInfo can have the following values: 0x00, 0x01, 0x02 and 0xFF.");
  AddRequirementInfo("ARCH_SW_DIA_0014", "Service 0x31 02 will be implemented for RID F703");
  AddRequirementInfo("ARCH_SW_DIA_0191", "Service shall be available in Development session.");

  ////***************************************************************************************

  testCaseComment("Preconditions");
  testStep("STEP", "Bench Initialization");
  
  testStep("", "Delete all breakpoint from debugger.");
  debugger_deleteAllBreakpoints();

  testStep("", "Reset the debugger.");
  debugger_reset();
    
  testStep("", "Run the debugger.");
  debugger_run();
  
  RunPreTs();
  ////====================================================

  testStep("STEP", "Enter development session.");
  EnterDiagnosticSession("development");
  
  testStep("STEP", "Set breakpoint in function *DIA_runRidF703_CycleExecutionStop*.");
  debugger_setRelativeFunctionBpAtLine("DIA_runRidF703_CycleExecutionStop", "0");
  debugger_run();
 
  testCaseComment("Action: ARCH_SW_DIA_0013; ARCH_SW_DIA_0188; ARCH_SW_DIA_0189; ARCH_SW_DIA_0190");
  testStep("STEP", "Send diag request for RID F7 03 Start --> Request Sent.");
  SendDiagnosticRequest(dCycleExecutionStartRequest, dCycleExecutionStartResponse);

  testCaseComment("Action: ARCH_SW_DIA_0014; ARCH_SW_DIA_0191;");
  testStep("STEP", "Send diag request for RID F7 03 stop and wait for timeout error --> Timeout reached.");
  SendDiagnosticRequestNegativeResponse(dCycleExecutionStopRequest, dCycleExecutionStopResponse, TRUE);
  
  testWaitForTimeout(2000);
  testStep("STEP", "Check if breakpoint from function DIA_runRidF703_CycleExecutionStop was reached. --> BP was reached.");
  debugger_waitUntilBPisReached("5000");
  ExpectedTestResult(debugger_result, IS_CPU_STOP_AT_BP_SUCCESFUL, "BP is reached.");
  
  ////====================================================
  testCaseComment("Postcondition");
  testStep("STEP", "Return ECU to default values");
  RunPostTs();
}

testcase SW_Int_DIA_runRid0329_TriggerBSRStart_01()
{
  ////***********************************Test report header*********************************
  testReportAddMiscInfoBlock("AUTOLIV ELECTRONICS document");
  TestReportAddMiscInfo("Nightly test", "No");
  TestReportAddMiscInfo("Test type", "Requirement-Based test");
  TestReportAddMiscInfo("Regression Test", "No");
  TestReportAddMiscInfo("Fault injection method used", "No");
  TestReportAddMiscInfo("Resource usage evaluation", "No");
  TestReportAddMiscInfo("Priority", "No");
  TestReportAddMiscInfo("Safety relevant", "No");
  
  AddRequirementInfo("Requirement under test", "ARCH_SW_DIA_0015; ARCH_SW_DIA_0192; ARCH_SW_DIA_0193");
  AddRequirementInfo("ARCH_SW_DIA_0015", "Service 0x31 01 will be implemented for RID 0329.");
  AddRequirementInfo("ARCH_SW_DIA_0192", "Service shall be available in Extended and Development session.");
  AddRequirementInfo("ARCH_SW_DIA_0193", "Result can have the following values: 0x00, 0x01 and 0x02.");

  ////***************************************************************************************

  testCaseComment("Preconditions");
  testStep("STEP", "Bench Initialization");
  
  testStep("", "Delete all breakpoint from debugger.");
  debugger_deleteAllBreakpoints();

  testStep("", "Reset the debugger.");
  debugger_reset();
    
  testStep("", "Run the debugger.");
  debugger_run();
  
  RunPreTs();
  ////====================================================

  testStep("STEP", "Enter development session.");
  EnterDiagnosticSession("development");
  
  testStep("STEP", "Set BCKL_ON.");
  setSignal(Bckl_Sw_D_Stat_ST3, 0);
  
  testStep("STEP", "Clear fault memory");
  SendDiagnosticRequest(dFaultMemoryClearRequest, dFaultMemoryClearResponse);
  
  testStep("STEP", "Set breakpoint in function *DIA_runRid0329_TriggerBSRStart*.");
  debugger_setRelativeFunctionBpAtLine("DIA_runRid0329_TriggerBSRStart", "0");
  debugger_run();
 
  testCaseComment("Action: ARCH_SW_DIA_0015; ARCH_SW_DIA_0192; ARCH_SW_DIA_0193");
  testStep("STEP", "Send diag request for RID 03 29 Start --> Request Sent.");
  SendDiagnosticRequestNegativeResponse(dTriggerBSRStartRequest, dTriggerBSRStartResponse, TRUE);
  
  testWaitForTimeout(2000);
  testStep("STEP", "Check if breakpoint from function DIA_runRid0329_TriggerBSRStart was reached. --> BP was reached.");
  debugger_waitUntilBPisReached("5000");
  ExpectedTestResult(debugger_result, IS_CPU_STOP_AT_BP_SUCCESFUL, "BP is reached.");
  
  ////====================================================
  testCaseComment("Postcondition");
  testStep("STEP", "Return ECU to default values");
  RunPostTs();
}

testcase SW_Int_DIA_runRid0329_TriggerBSRStop_01()
{
  //***********************************Test report header*********************************
  testReportAddMiscInfoBlock("AUTOLIV ELECTRONICS document");
  TestReportAddMiscInfo("Nightly test", "No");
  TestReportAddMiscInfo("Test type", "Requirement-Based test");
  TestReportAddMiscInfo("Regression Test", "No");
  TestReportAddMiscInfo("Fault injection method used", "No");
  TestReportAddMiscInfo("Resource usage evaluation", "No");
  TestReportAddMiscInfo("Priority", "No");
  TestReportAddMiscInfo("Safety relevant", "No");
  
  AddRequirementInfo("Requirement under test", "ARCH_SW_DIA_0016; ARCH_SW_DIA_0194");
  AddRequirementInfo("ARCH_SW_DIA_0016", "Service 0x31 02 will be implemented for RID 0329.");
  AddRequirementInfo("ARCH_SW_DIA_0194", "Service shall be available in Extended and Development session.");

  //***************************************************************************************

  testCaseComment("Preconditions");
  testStep("STEP", "Bench Initialization");
  
  testStep("", "Delete all breakpoint from debugger.");
  debugger_deleteAllBreakpoints();

  testStep("", "Reset the debugger.");
  debugger_reset();
    
  testStep("", "Run the debugger.");
  debugger_run();
  
  RunPreTs();
  //====================================================

  testStep("STEP", "Enter development session.");
  EnterDiagnosticSession("development");
  
  testStep("STEP", "Set BCKL_ON.");
  setSignal(Bckl_Sw_D_Stat_ST3, 0);
  
  testStep("STEP", "Clear fault memory.");
  SendDiagnosticRequest(dTriggerBSRStartRequest, dTriggerBSRStartResponse);
  
  testStep("STEP", "Set breakpoint in function *DIA_runRid0329_TriggerBSRStop*.");
  debugger_setRelativeFunctionBpAtLine("DIA_runRid0329_TriggerBSRStop", "0");
  debugger_run();
 
  testStep("STEP", "Send diag request for RID 03 29 Start --> Request Sent.");
  SendDiagnosticRequest(dTriggerBSRStartRequest, dTriggerBSRStartResponse);
  
  testStep("STEP", "Send diag request for RID 03 29 Stop --> Timeout error.");
  SendDiagnosticRequestNegativeResponse(dTriggerBSRStopRequest, dTriggerBSRStopResponse, TRUE);
  
  testWaitForTimeout(2000);
  testCaseComment("Action: ARCH_SW_DIA_0016; ARCH_SW_DIA_0194");
  testStep("STEP", "Check if breakpoint from function DIA_runRid0329_TriggerBSRStop was reached. --> BP was reached.");
  debugger_waitUntilBPisReached("5000");
  ExpectedTestResult(debugger_result, IS_CPU_STOP_AT_BP_SUCCESFUL, "BP is reached.");
  
  //====================================================
  testCaseComment("Postcondition");
  testStep("STEP", "Return ECU to default values");
  RunPostTs();
}

testcase SW_Int_DIA_runRid0329_TriggerBSRRequestResults_01()
{
  
  diagRequest RBTMFL174.Trigger_BSR_RequestResults dTriggerBSRRequestRequest;
  diagResponse RBTMFL174.Trigger_BSR_RequestResults dTriggerBSRRequestResponse;

  //***********************************Test report header*********************************
  testReportAddMiscInfoBlock("AUTOLIV ELECTRONICS document");
  TestReportAddMiscInfo("Nightly test", "No");
  TestReportAddMiscInfo("Test type", "Requirement-Based test");
  TestReportAddMiscInfo("Regression Test", "No");
  TestReportAddMiscInfo("Fault injection method used", "No");
  TestReportAddMiscInfo("Resource usage evaluation", "No");
  TestReportAddMiscInfo("Priority", "No");
  TestReportAddMiscInfo("Safety relevant", "No");
  
  AddRequirementInfo("Requirement under test", "ARCH_SW_DIA_0017; ARCH_SW_DIA_0195; ARCH_SW_DIA_0196");
  AddRequirementInfo("ARCH_SW_DIA_0017", "Service 0x31 03 will be implemented for RID 0329.");
  AddRequirementInfo("ARCH_SW_DIA_0195", "Service shall be available in Extended and Development session");
  AddRequirementInfo("ARCH_SW_DIA_0196", "Result can have the following values: 0x00, 0x01 and 0x02");

  //***************************************************************************************

  testCaseComment("Preconditions");
  testStep("STEP", "Bench Initialization");
  
  testStep("", "Delete all breakpoint from debugger.");
  debugger_deleteAllBreakpoints();

  testStep("", "Reset the debugger.");
  debugger_reset();
    
  testStep("", "Run the debugger.");
  debugger_run();
  
  RunPreTs();
  //====================================================

  testStep("STEP", "Enter development session.");
  EnterDiagnosticSession("development");
  
  testStep("STEP", "Set BCKL_ON.");
  setSignal(Bckl_Sw_D_Stat_ST3, 0);
  
  testStep("STEP", "Clear fault memory");
  ClearAll();
  Wait(2000);
  
  testStep("STEP", "Set breakpoint in function *DIA_runRid0329_TriggerBSRRequestResults*.");
  debugger_setRelativeFunctionBpAtLine("DIA_runRid0329_TriggerBSRRequestResults", "0");
  debugger_run();
 
  testStep("STEP", "Send diag request for RID 03 29 Start --> Request Sent.");
  SendDiagnosticRequest(dTriggerBSRStartRequest, dTriggerBSRStartResponse);
  
  testStep("STEP", "Send diag request for RID 03 29 Request Results --> Timeout error.");
  SendDiagnosticRequestNegativeResponse(dTriggerBSRRequestRequest, dTriggerBSRRequestResponse, TRUE);
  
  testWaitForTimeout(2000);
  testCaseComment("Action: ARCH_SW_DIA_0017; ARCH_SW_DIA_0195; ARCH_SW_DIA_0196");
  testStep("STEP", "Check if breakpoint from function DIA_runRid0330_TriggerTensioningCycleRequestResults was reached. --> BP was reached.");
  debugger_waitUntilBPisReached("5000");
  ExpectedTestResult(debugger_result, IS_CPU_STOP_AT_BP_SUCCESFUL, "BP is reached.");
  
  //====================================================
  testCaseComment("Postcondition");
  testStep("STEP", "Return ECU to default values");
  RunPostTs();
  
}

testcase SW_Int_DIA_runRid0330_TriggerTensioningCycleStart_01()
{
  ////***********************************Test report header*********************************
  testReportAddMiscInfoBlock("AUTOLIV ELECTRONICS document");
  TestReportAddMiscInfo("Nightly test", "No");
  TestReportAddMiscInfo("Test type", "Requirement-Based test");
  TestReportAddMiscInfo("Regression Test", "No");
  TestReportAddMiscInfo("Fault injection method used", "No");
  TestReportAddMiscInfo("Resource usage evaluation", "No");
  TestReportAddMiscInfo("Priority", "No");
  TestReportAddMiscInfo("Safety relevant", "No");
  
  AddRequirementInfo("Requirement under test", "ARCH_SW_DIA_0019; ARCH_SW_DIA_0197; ARCH_SW_DIA_0198; ARCH_SW_DIA_0199; ARCH_SW_DIA_0200");
  AddRequirementInfo("ARCH_SW_DIA_0019", "Service 0x31 02 will be implemented for RID 0330.");
  AddRequirementInfo("ARCH_SW_DIA_0197", "Service shall be available in Extended and Development session.");
  AddRequirementInfo("ARCH_SW_DIA_0198", "Type of Tensioning Cycle shall accept only values between 0x01 and 0x05.");
  AddRequirementInfo("ARCH_SW_DIA_0199", "Presafe Duration shall determine the time of the tensioning cycle.");
  AddRequirementInfo("ARCH_SW_DIA_0200", "Result can have the following values: 0x00, 0x01 and 0x02.");

  ////***************************************************************************************

  testCaseComment("Preconditions");
  testStep("STEP", "Bench Initialization");
  
  testStep("", "Delete all breakpoint from debugger.");
  debugger_deleteAllBreakpoints();

  testStep("", "Reset the debugger.");
  debugger_reset();
    
  testStep("", "Run the debugger.");
  debugger_run();
  
  RunPreTs();
  ////====================================================

  testStep("STEP", "Enter development session.");
  EnterDiagnosticSession("development");
  
  testStep("STEP", "Set BCKL_ON.");
  setSignal(Bckl_Sw_D_Stat_ST3, 0);
  
  testStep("STEP", "Clear fault memory");
  SendDiagnosticRequest(dFaultMemoryClearRequest, dFaultMemoryClearResponse);
  
  testStep("STEP", "Set breakpoint in function *DIA_runRid0330_TriggerTensioningCycleStart*.");
  debugger_setRelativeFunctionBpAtLine("DIA_runRid0330_TriggerTensioningCycleStart", "0");
  debugger_run();
 
  testCaseComment("Action: ARCH_SW_DIA_0019; ARCH_SW_DIA_0197; ARCH_SW_DIA_0198; ARCH_SW_DIA_0199; ARCH_SW_DIA_0200");
  testStep("STEP", "Send diag request for RID 03 30 Start --> Request Sent.");
  SendDiagnosticRequestNegativeResponse(dTriggerTensioningCycleStartRequest, dTriggerTensioningCycleStartResponse, TRUE);
  
  testWaitForTimeout(2000);
  testStep("STEP", "Check if breakpoint from function DIA_runRid0330_TriggerTensioningCycleStart was reached. --> BP was reached.");
  debugger_waitUntilBPisReached("5000");
  ExpectedTestResult(debugger_result, IS_CPU_STOP_AT_BP_SUCCESFUL, "BP is reached.");
  
  ////====================================================
  testCaseComment("Postcondition");
  testStep("STEP", "Return ECU to default values");
  RunPostTs();
}

testcase SW_Int_DIA_runRid0330_TriggerTensioningCycleStop_01()
{
  ////***********************************Test report header*********************************
  testReportAddMiscInfoBlock("AUTOLIV ELECTRONICS document");
  TestReportAddMiscInfo("Nightly test", "No");
  TestReportAddMiscInfo("Test type", "Requirement-Based test");
  TestReportAddMiscInfo("Regression Test", "No");
  TestReportAddMiscInfo("Fault injection method used", "No");
  TestReportAddMiscInfo("Resource usage evaluation", "No");
  TestReportAddMiscInfo("Priority", "No");
  TestReportAddMiscInfo("Safety relevant", "No");
  
  AddRequirementInfo("Requirement under test", "ARCH_SW_DIA_0018; ARCH_SW_DIA_0201");
  AddRequirementInfo("ARCH_SW_DIA_0018", "Service 0x31 01 will be implemented for RID 0330.");
  AddRequirementInfo("ARCH_SW_DIA_0201", "Service shall be available in Extended and Development session.");

  ////***************************************************************************************

  testCaseComment("Preconditions");
  testStep("STEP", "Bench Initialization");
  
  testStep("", "Delete all breakpoint from debugger.");
  debugger_deleteAllBreakpoints();

  testStep("", "Reset the debugger.");
  debugger_reset();
    
  testStep("", "Run the debugger.");
  debugger_run();
  
  RunPreTs();
  ////====================================================

  testStep("STEP", "Enter development session.");
  EnterDiagnosticSession("development");
  
  testStep("STEP", "Set BCKL_ON.");
  setSignal(Bckl_Sw_D_Stat_ST3, 0);
  
  testStep("STEP", "Clear fault memory");
  SendDiagnosticRequest(dFaultMemoryClearRequest, dFaultMemoryClearResponse);
  
  testStep("STEP", "Set breakpoint in function *DIA_runRid0330_TriggerTensioningCycleStop*.");
  debugger_setRelativeFunctionBpAtLine("DIA_runRid0330_TriggerTensioningCycleStop", "0");
  debugger_run();
 
  testStep("STEP", "Send diag request for RID 03 30 Start --> Request Sent.");
  SendDiagnosticRequest(dTriggerTensioningCycleStartRequest, dTriggerTensioningCycleStartResponse);
  
  testStep("STEP", "Send diag request for RID 03 30 Stop --> Timeout error.");
  SendDiagnosticRequestNegativeResponse(dTriggerTensioningCycleStopRequest, dTriggerTensioningCycleStopResponse, TRUE);
  
  testCaseComment("Action: ARCH_SW_DIA_0018; ARCH_SW_DIA_0201");
  testStep("STEP", "Check if breakpoint from function DIA_runRid0330_TriggerTensioningCycleStop was reached. --> BP was reached.");
  debugger_waitUntilBPisReached("5000");
  ExpectedTestResult(debugger_result, IS_CPU_STOP_AT_BP_SUCCESFUL, "BP is reached.");
  
  ////====================================================
  testCaseComment("Postcondition");
  testStep("STEP", "Return ECU to default values");
  RunPostTs();
}

testcase SW_Int_DIA_runRid0330_TriggerTensioningCycleRequestResults_01()
{
  
  diagRequest RBTMFL174.Trigger_Tensioning_Cycle_Start dTriggerTensioningCycleStartRequest;
  diagResponse RBTMFL174.Trigger_Presafe_Display_Request_Start dTriggerTensioningCycleStartResponse;
  
  diagRequest RBTMFL174.Trigger_Tensioning_Cycle_RequestResults dTriggerTensioningCycleResponseRequest;
  diagResponse RBTMFL174.Trigger_Tensioning_Cycle_RequestResults dTriggerTensioningCycleResponseResponse;

  //***********************************Test report header*********************************
  testReportAddMiscInfoBlock("AUTOLIV ELECTRONICS document");
  TestReportAddMiscInfo("Nightly test", "No");
  TestReportAddMiscInfo("Test type", "Requirement-Based test");
  TestReportAddMiscInfo("Regression Test", "No");
  TestReportAddMiscInfo("Fault injection method used", "No");
  TestReportAddMiscInfo("Resource usage evaluation", "No");
  TestReportAddMiscInfo("Priority", "No");
  TestReportAddMiscInfo("Safety relevant", "No");
  
  AddRequirementInfo("Requirement under test", "ARCH_SW_DIA_0020; ARCH_SW_DIA_0204; ARCH_SW_DIA_0205");
  AddRequirementInfo("ARCH_SW_DIA_0020", "Service 0x31 03 will be implemented for RID 0330.");
  AddRequirementInfo("ARCH_SW_DIA_0204", "Service shall be available in Extended and Development session");
  AddRequirementInfo("ARCH_SW_DIA_0205", "Result can have the following values: 0x00, 0x01 and 0x02");

  //***************************************************************************************

  testCaseComment("Preconditions");
  testStep("STEP", "Bench Initialization");
  
  testStep("", "Delete all breakpoint from debugger.");
  debugger_deleteAllBreakpoints();

  testStep("", "Reset the debugger.");
  debugger_reset();
    
  testStep("", "Run the debugger.");
  debugger_run();
  
  RunPreTs();
  //====================================================

  testStep("STEP", "Enter development session.");
  EnterDiagnosticSession("development");
  
  testStep("STEP", "Set BCKL_ON.");
  setSignal(Bckl_Sw_D_Stat_ST3, 0);
  
  testStep("STEP", "Clear fault memory");
  ClearAll();
  Wait(2000);
  
  testStep("STEP", "Set breakpoint in function *DIA_runRid0330_TriggerTensioningCycleRequestResults*.");
  debugger_setRelativeFunctionBpAtLine("DIA_runRid0330_TriggerTensioningCycleRequestResults", "0");
  debugger_run();
 
  testStep("STEP", "Send diag request for RID 03 30 Start --> Request Sent.");
  SendDiagnosticRequest(dTriggerTensioningCycleStartRequest, dTriggerTensioningCycleStartResponse);
  
  testStep("STEP", "Send diag request for RID 03 30 Request Results --> Timeout error.");
  SendDiagnosticRequestNegativeResponse(dTriggerTensioningCycleResponseRequest, dTriggerTensioningCycleResponseResponse, TRUE);
  
  testCaseComment("Action: ARCH_SW_DIA_0020; ARCH_SW_DIA_0204; ARCH_SW_DIA_0205");
  testStep("STEP", "Check if breakpoint from function DIA_runRid0330_TriggerTensioningCycleRequestResults was reached. --> BP was reached.");
  debugger_waitUntilBPisReached("5000");
  ExpectedTestResult(debugger_result, IS_CPU_STOP_AT_BP_SUCCESFUL, "BP is reached.");
  
  debugger_run();
  //====================================================
  testCaseComment("Postcondition");
  testStep("STEP", "Return ECU to default values");
  RunPostTs();
  
}

testcase SW_Int_DIA_runRid0302_TriggerPresafeDisplayRequestStart_01()
{
  diagRequest RBTMFL174.Trigger_Presafe_Display_Request_Start dTriggerPresafeDisplayRequestStartRequest;
  diagResponse RBTMFL174.Trigger_Presafe_Display_Request_Start dTriggerPresafeDisplayRequestStartResponse;

  //***********************************Test report header*********************************
  testReportAddMiscInfoBlock("AUTOLIV ELECTRONICS document");
  TestReportAddMiscInfo("Nightly test", "No");
  TestReportAddMiscInfo("Test type", "Requirement-Based test");
  TestReportAddMiscInfo("Regression Test", "No");
  TestReportAddMiscInfo("Fault injection method used", "No");
  TestReportAddMiscInfo("Resource usage evaluation", "No");
  TestReportAddMiscInfo("Priority", "No");
  TestReportAddMiscInfo("Safety relevant", "No");
  
  AddRequirementInfo("Requirement under test", "ARCH_SW_DIA_0220; ARCH_SW_DIA_0225; ARCH_SW_DIA_0226; ARCH_SW_DIA_0227; ARCH_SW_DIA_0228");
  AddRequirementInfo("ARCH_SW_DIA_0220", "0x31 01 0x31 02 0x31 03 for RID 0x0302 (Trigger Pre-Safe Display Request) will be implemented .");
  AddRequirementInfo("ARCH_SW_DIA_0225", "Service shall be available in Default session, Extended session Update session and Development session.");
  AddRequirementInfo("ARCH_SW_DIA_0226", "Service shall be available in the following forms of Authentication:Supplier, Development ENHANCED, Production, After-Sales ENHANCED, After-Sales");
  AddRequirementInfo("ARCH_SW_DIA_0227", "Successful Authentication is a pre-condition for running this Service.");
  AddRequirementInfo("ARCH_SW_DIA_0228", "Result can have the following values: 0x00, 0x01 and 0x02.");

  //***************************************************************************************

  testCaseComment("Preconditions");
  testStep("STEP", "Bench Initialization");
  
  testStep("", "Delete all breakpoint from debugger.");
  debugger_deleteAllBreakpoints();

  testStep("", "Reset the debugger.");
  debugger_reset();
    
  testStep("", "Run the debugger.");
  debugger_run();
  
  RunPreTs();
  //====================================================

  testStep("STEP", "Enter development session.");
  EnterDiagnosticSession("development");
  
  testStep("STEP", "Set BCKL_ON.");
  setSignal(Bckl_Sw_D_Stat_ST3, 0);
  
  testStep("STEP", "Clear fault memory");
  ClearAll();
  Wait(2000);
  
  testStep("STEP", "Set breakpoint in function *DIA_runRid0302_TriggerPresafeDisplayRequestStart*.");
  debugger_setRelativeFunctionBpAtLine("DIA_runRid0302_TriggerPresafeDisplayRequestStart", "0");
  debugger_run();
 
  testCaseComment("Action: ARCH_SW_DIA_0220; ARCH_SW_DIA_0225; ARCH_SW_DIA_0226; ARCH_SW_DIA_0227; ARCH_SW_DIA_0228");
  testStep("STEP", "Send diag request for RID 03 02 Start --> Request Sent.");
  SendDiagnosticRequestNegativeResponse(dTriggerPresafeDisplayRequestStartRequest, dTriggerPresafeDisplayRequestStartResponse, TRUE);
  
  testWaitForTimeout(2000);
  testStep("STEP", "Check if breakpoint from function DIA_runRid0302_TriggerPresafeDisplayRequestStart was reached. --> BP was reached.");
  debugger_waitUntilBPisReached("5000");
  ExpectedTestResult(debugger_result, IS_CPU_STOP_AT_BP_SUCCESFUL, "BP is reached.");
  
  //====================================================
  testCaseComment("Postcondition");
  testStep("STEP", "Return ECU to default values");
  RunPostTs();
}

testcase SW_Int_DIA_runRid0302_TriggerPresafeDisplayRequestStop_01()
{
  ////***********************************Test report header*********************************
  testReportAddMiscInfoBlock("AUTOLIV ELECTRONICS document");
  TestReportAddMiscInfo("Nightly test", "No");
  TestReportAddMiscInfo("Test type", "Requirement-Based test");
  TestReportAddMiscInfo("Regression Test", "No");
  TestReportAddMiscInfo("Fault injection method used", "No");
  TestReportAddMiscInfo("Resource usage evaluation", "No");
  TestReportAddMiscInfo("Priority", "No");
  TestReportAddMiscInfo("Safety relevant", "No");
  
  AddRequirementInfo("Requirement under test", "ARCH_SW_DIA_0220; ARCH_SW_DIA_0229; ARCH_SW_DIA_0230; ARCH_SW_DIA_0231; ARCH_SW_DIA_0232");
  AddRequirementInfo("ARCH_SW_DIA_0220", "Service 0x31 (Routine Control) 0x31 01 0x31 02 0x31 03 for RID 0x0302 (Trigger Pre-Safe Display Request) will be implemented .");
  AddRequirementInfo("ARCH_SW_DIA_0229", "Service shall be available in Default session, Extended sessionUpdate session and Development session.");
  AddRequirementInfo("ARCH_SW_DIA_0230", "Service shall be available in the following forms of Authentication:Supplier, Development ENHANCED, Production, After-Sales ENHANCED, After-Sales.");
  AddRequirementInfo("ARCH_SW_DIA_0231", "Successful Authentication is a pre-condition for running this Service");
  AddRequirementInfo("ARCH_SW_DIA_0232", "Result can have the following values: 0x00, 0x01 and 0x02.");

  ////***************************************************************************************

  testCaseComment("Preconditions");
  testStep("STEP", "Bench Initialization");
  
  testStep("", "Delete all breakpoint from debugger.");
  debugger_deleteAllBreakpoints();

  testStep("", "Reset the debugger.");
  debugger_reset();
    
  testStep("", "Run the debugger.");
  debugger_run();
  
  RunPreTs();
  ////====================================================

  testStep("STEP", "Enter development session.");
  EnterDiagnosticSession("development");
  
  testStep("STEP", "Set BCKL_ON.");
  setSignal(Bckl_Sw_D_Stat_ST3, 0);
  
  testStep("STEP", "Clear fault memory");
  SendDiagnosticRequest(dFaultMemoryClearRequest, dFaultMemoryClearResponse);
  
  testStep("STEP", "Set breakpoint in function *DIA_runRid0302_TriggerPresafeDisplayRequestStop*.");
  debugger_setRelativeFunctionBpAtLine("DIA_runRid0302_TriggerPresafeDisplayRequestStop", "0");
  debugger_run();
 
  testStep("STEP", "Send diag request for RID 03 02 Start --> Request Sent.");
  SendDiagnosticRequest(dTriggerPresafeDisplayStartRequest, TriggerPresafeDisplayStartResponse);
  
  testStep("STEP", "Send diag request for RID 03 02 Stop --> Timeout error.");
  SendDiagnosticRequestNegativeResponse(dTriggerPresafeDisplayStopRequest, dTriggerPresafeDisplayStopResponse, TRUE);
  
  testCaseComment("Action: ARCH_SW_DIA_0220; ARCH_SW_DIA_0229; ARCH_SW_DIA_0230; ARCH_SW_DIA_0231; ARCH_SW_DIA_0232");
  testStep("STEP", "Check if breakpoint from function DIA_runRid0302_TriggerPresafeDisplayRequestStop was reached. --> BP was reached.");
  debugger_waitUntilBPisReached("5000");
  ExpectedTestResult(debugger_result, IS_CPU_STOP_AT_BP_SUCCESFUL, "BP is reached.");
  
  ////====================================================
  testCaseComment("Postcondition");
  testStep("STEP", "Return ECU to default values");
  RunPostTs();
}

testcase SW_Int_DIA_runRid0302_TriggerPresafeDisplayRequestRequestResults_01()
{
  ////***********************************Test report header*********************************
  testReportAddMiscInfoBlock("AUTOLIV ELECTRONICS document");
  TestReportAddMiscInfo("Nightly test", "No");
  TestReportAddMiscInfo("Test type", "Requirement-Based test");
  TestReportAddMiscInfo("Regression Test", "No");
  TestReportAddMiscInfo("Fault injection method used", "No");
  TestReportAddMiscInfo("Resource usage evaluation", "No");
  TestReportAddMiscInfo("Priority", "No");
  TestReportAddMiscInfo("Safety relevant", "No");
  
  AddRequirementInfo("Requirement under test", "ARCH_SW_DIA_0220; ARCH_SW_DIA_0221; ARCH_SW_DIA_0222; ARCH_SW_DIA_0223; ARCH_SW_DIA_0224");
  AddRequirementInfo("ARCH_SW_DIA_0220", "Service 0x31 (Routine Control) 0x31 01 0x31 02 0x31 03 for RID 0x0302 (Trigger Pre-Safe Display Request) will be implemented .");
  AddRequirementInfo("ARCH_SW_DIA_0221", "Service shall be available in Default session, Extended sessionUpdate session and Development session.");
  AddRequirementInfo("ARCH_SW_DIA_0222", "Service shall be available in the following forms of Authentication:Supplier, Development ENHANCED, Production, After-Sales ENHANCED, After-Sales");
  AddRequirementInfo("ARCH_SW_DIA_0231", "Successful Authentication is a pre-condition for running this Service");
  AddRequirementInfo("ARCH_SW_DIA_0232", "Result can have the following values: 0x00, 0x01 and 0x02.");

  ////***************************************************************************************

  testCaseComment("Preconditions");
  testStep("STEP", "Bench Initialization");
  
  testStep("", "Delete all breakpoint from debugger.");
  debugger_deleteAllBreakpoints();

  testStep("", "Reset the debugger.");
  debugger_reset();
    
  testStep("", "Run the debugger.");
  debugger_run();
  
  RunPreTs();
  ////====================================================

  testStep("STEP", "Enter development session.");
  EnterDiagnosticSession("development");
  
  testStep("STEP", "Set BCKL_ON.");
  setSignal(Bckl_Sw_D_Stat_ST3, 0);
  
  testStep("STEP", "Clear fault memory");
  SendDiagnosticRequest(dFaultMemoryClearRequest, dFaultMemoryClearResponse);
  
  testStep("STEP", "Set breakpoint in function *DIA_runRid0302_TriggerPresafeDisplayRequestRequestResults*.");
  debugger_setRelativeFunctionBpAtLine("DIA_runRid0302_TriggerPresafeDisplayRequestRequestResults", "0");
  debugger_run();
 
  testStep("STEP", "Send diag request for RID 03 02 Start --> Request Sent.");
  SendDiagnosticRequest(dTriggerPresafeDisplayStartRequest, dTriggerTensioningCycleStartResponse);
  
  testStep("STEP", "Send diag request for RID 03 02 Request Results --> Timeout error.");
  SendDiagnosticRequestNegativeResponse(dTriggerPresafeDisplayResultsRequest, dTriggerPresafeDisplayResultsResponse, TRUE);
  
  testWaitForTimeout(2000);
  
  testCaseComment("Action: ARCH_SW_DIA_0220; ARCH_SW_DIA_0221; ARCH_SW_DIA_0222; ARCH_SW_DIA_0223; ARCH_SW_DIA_0224");
  testStep("STEP", "Check if breakpoint from function DIA_runRid0302_TriggerPresafeDisplayRequestRequestResults was reached. --> BP was reached.");
  debugger_waitUntilBPisReached("5000");
  ExpectedTestResult(debugger_result, IS_CPU_STOP_AT_BP_SUCCESFUL, "BP is reached.");
  
  ////====================================================
  testCaseComment("Postcondition");
  testStep("STEP", "Return ECU to default values");
  RunPostTs();
}

testcase SW_Int_DIA_DataServices_PRE_SAFE_Counter_read_Read_CombinedDataElement_WriteData_01()
{
  diagRequest RBTMFL174.PRE_SAFE_Request_Counter_reset_Write dPresafeRequestCounterResetWriteRequest;
  diagResponse RBTMFL174.PRE_SAFE_Request_Counter_reset_Write dPresafeRequestCounterResetWriteResponse;

  //***********************************Test report header*********************************
  testReportAddMiscInfoBlock("AUTOLIV ELECTRONICS document");
  TestReportAddMiscInfo("Nightly test", "No");
  TestReportAddMiscInfo("Test type", "Requirement-Based test");
  TestReportAddMiscInfo("Regression Test", "No");
  TestReportAddMiscInfo("Fault injection method used", "No");
  TestReportAddMiscInfo("Resource usage evaluation", "No");
  TestReportAddMiscInfo("Priority", "No");
  TestReportAddMiscInfo("Safety relevant", "No");
  
  AddRequirementInfo("Requirement under test", "ARCH_SW_DIA_0396; ARCH_SW_DIA_0397; ARCH_SW_DIA_0488; ARCH_SW_DIA_0489; ARCH_SW_DIA_0490; ARCH_SW_DIA_0491;");
  AddRequirementInfo("ARCH_SW_DIA_0396", "Request data shall be 1 byte long.");
  AddRequirementInfo("ARCH_SW_DIA_0397", "Byte 0 shall be defined as the Pre-Safe Request Counter Reset command and shall always have value 0x01.");
  AddRequirementInfo("ARCH_SW_DIA_0488", "DataIdentifier shall be 0x0244");
  AddRequirementInfo("ARCH_SW_DIA_0489", "Using this service shall lead to the Pre-Safe Counter to be set to default value (i.e. 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00)");
  AddRequirementInfo("ARCH_SW_DIA_0490", "The DID shall be available in the following sessions: ?Extended session ?Update Session ?Development Session ");
  AddRequirementInfo("ARCH_SW_DIA_0491", "This service shall be available under the following forms of Authentication: ?Supplier ?Development ENHANCED ?Production ");

  //***************************************************************************************

  testCaseComment("Preconditions");
  testStep("STEP", "Bench Initialization");
  
  testStep("", "Delete all breakpoint from debugger.");
  debugger_deleteAllBreakpoints();

  testStep("", "Reset the debugger.");
  debugger_reset();
    
  testStep("", "Run the debugger.");
  debugger_run();
  
  RunPreTs();
  //====================================================
  testStep("STEP", "Set breakpoint in function *DataServices_PRE_SAFE_Counter_read_Read_CombinedDataElement_WriteData*.");
  debugger_setRelativeFunctionBpAtLine("DataServices_PRE_SAFE_Counter_read_Read_CombinedDataElement_WriteData", "0");
  debugger_run();
  
  EnterDiagnosticSession("development");
  
  @SecVarCodingPanel::Button_CodingStart = 1;
  testWaitForTimeout(2000);
  SendDiagnosticRequest(dRequestSeedReprogrammingRequest, dRequestSeedReprogrammingResponse);
  testWaitForTimeout(1000);
  SendDiagnosticRequest(dSendKeyReprogrammingRequest, dSendKeyReprogrammingResponse);
  
 
  testCaseComment("Action: ARCH_SW_DIA_0396; ARCH_SW_DIA_0397; ARCH_SW_DIA_0488; ARCH_SW_DIA_0489; ARCH_SW_DIA_0490; ARCH_SW_DIA_0491;");
  testStep("STEP", "Send diag request for 2E 0244 and wait for timeout error --> Timeout reached.");
  SendDiagnosticRequestNegativeResponse(dPresafeRequestCounterResetWriteRequest, dPresafeRequestCounterResetWriteResponse, TRUE);

  testWaitForTimeout(2000);
  testStep("STEP", "Check if breakpoint from function DataServices_PRE_SAFE_Counter_read_Read_CombinedDataElement_WriteData was reached. --> BP was reached.");
  debugger_waitUntilBPisReached("5000");
  ExpectedTestResult(debugger_result, IS_CPU_STOP_AT_BP_SUCCESFUL, "BP is reached.");
  
  debugger_run();
  //====================================================
  testCaseComment("Postcondition");
  testStep("STEP", "Return ECU to default values");
  RunPostTs();
}

void MainTest()
{
InitTestModule();
  SW_Int_DIA_runDidF18C_EcuSerialNumberRead_01();
  SW_Int_DIA_runDidF18C_EcuSerialNumberReadDataLength_01();
  SW_Int_DIA_runDid0340_UniqueSeatbeltSerialNumberRead_01();
  SW_Int_DIA_runDidFD2F_EcuLocationRead_01();
  SW_Int_DIA_runDidFD10_CycleConfigurationRead_01();
  SW_Int_DIA_runDidFD10_CycleConfigurationRead_02();
  SW_Int_DIA_runDidFD2A_StepsLibraryRead_01();
  SW_Int_DIA_runDidFD2A_StepsLibraryRead_02();
  SW_Int_DIA_runDid0244_PreSafeCounterRead_01();
  SW_Int_DIA_runDid0244_PreSafeCounterReadDataLength_01();
  SW_Int_DIA_runDid0243_BSRCounterRead_01();
  SW_Int_DIA_runDid0243_BSRCounterRead_02();
  SW_Int_DIA_DataServices_PreSafe_Cycles_Level_1_8_CombinedSignal_ReadData_01();
  SW_Int_DIA_DataServices_PreSafe_Cycles_Level_1_8_CombinedSignal_ReadData_02();
  SW_Int_DIA_DataServices_Release_Cycles_BSR_and_PreSafe_CombinedSignal_ReadData_01();
  SW_Int_DIA_DataServices_Release_Cycles_BSR_and_PreSafe_CombinedSignal_ReadData_02();
  SW_Int_DIA_DataServices_Tensioning_Cycle_BSR_CombinedSignal_ReadData_01();
  SW_Int_DIA_DataServices_Tensioning_Cycle_BSR_CombinedSignal_ReadData_02();
  SW_Int_DIA_DataServices_Vehicle_Equipment_Read_Equipment_1_ReadData_01();
  SW_Int_DIA_DataServices_Vehicle_Equipment_Read_Equipment_2_ReadData_01();
  SW_Int_DIA_DataServices_Vehicle_Equipment_Read_Equipment_3_ReadData_01();
  SW_Int_DIA_DataServices_Vehicle_Equipment_Read_Equipment_4_ReadData_01();
  SW_Int_DIA_DataServices_Vehicle_Equipment_Read_Equipment_5_ReadData_01();
  SW_Int_DIA_DataServices_Vehicle_Equipment_Read_Equipment_6_ReadData_01();
  SW_Int_DIA_DataServices_Vehicle_Equipment_Read_Uberspannungsabbruchschwelle_ReadData_01();
  SW_Int_DIA_DataServices_Vehicle_Equipment_Read_Uberspannungsbereichsschwelle_ReadData_01();
  SW_Int_DIA_DataServices_Vehicle_Equipment_Read_Unterspannungsabbruchschwelle_ReadData_01();
  SW_Int_DIA_DataServices_Vehicle_Equipment_Read_Unterspannungsbereichsschwelle_ReadData_01();
  SW_Int_DIA_DataServices_ZZZ_Vehicle_Equipment_Development_Read_Zykluszeit_Messtechnik_ReadData_01();
  SW_Int_DIA_DataServices_ZZZ_Vehicle_Equipment_Development_Read_Bitfield_ReadData_01();
  SW_Int_DIA_runDidFD08_ResetCauseManagementRead_01();
  SW_Int_DIA_runDidFD09_LastWarmResetRead_LastDetectedWarmResetCause_01();
  SW_Int_DIA_runDidFD09_LastWarmResetRead_ResetCauseCounter_01();
  SW_Int_DIA_runDidFD31_HBCalibrationRead_01();
  SW_Int_DIA_runDidFD31_HBCalibrationRead_02();
  SW_Int_DIA_runDidFE00_AECStatusRead_01();
  SW_Int_DIA_runDidFE00_AECStatusReadDataLength_01();
  SW_Int_DIA_runDidFEFF_MeasuruementFrameConfigurationRead_01();
  SW_Int_DIA_runDidFDFF_MeasurementFrameBlock12ConfigRead_01();
  SW_Int_DIA_runDid0142_AvailabilityDataRead_01();
  SW_Int_DIA_runDid0241_PRE_SAFE_Recorder_1_ReadDataLength_01();
  SW_Int_DIA_runDid0241_PRE_SAFE_Recorder_1_ConditionCheckRead_01();
  SW_Int_DIA_runDid0241_PRE_SAFE_Recorder_1_ReadData_01();
  SW_Int_DIA_runDid0242_PRE_SAFE_Recorder_2_ReadDataLength_01();
  SW_Int_DIA_runDid0242_PRE_SAFE_Recorder_2_ConditionCheckRead_01();
  SW_Int_DIA_runDid0242_PRE_SAFE_Recorder_2_ReadData_01();
  SW_Int_DIA_ResetServiceExecution_01();
  SW_Int_DIA_ResetServiceExecution_02();
  SW_Int_DIA_Dcm_Svc14Handler_01();
  SW_Int_DIA_Dcm_Svc19Handler_01();
  SW_Int_DIA_runDidFD01_SWVersionRead_01();
  SW_Int_DIA_Dcm_Service27Processor_01();
  SW_Int_DataServices_Current_Operating_Time_Read_Current_Operating_Time_ReadData_01();
  SW_Int_DIA_runDid00140_Obsolence_Data_Current_Value_Read_01();
  SW_Int_DIA_runDid00140_Obsolence_Data_Threshold_Read_01();
  SW_Int_DIA_DataServices_CPU_Load_Read_CPU_load_histograms_ReadData_01();
  SW_Int_DIA_DataServices_E2E_Timing_Read_Maximum_ReadDataLength_01();
  SW_Int_DIA_DataServices_Stack_Load_Read_Maximum_ReadData_01();
  SW_Int_DIA_DataServices_Memory_Usage_Cycles_Read_Memory_Usage_Cycles_ReadData_01();
  SW_Int_DIA_DIA_runDid0200_CAN_input_Read_Neues_Bitfeld_ReadData_01();
  SW_Int_DIA_DataServices_HardwareVersion_Read_HW_ReadData_01();
  SW_Int_DIA_DataServices_HardwareVersion_Read_HW_ReadData_01();
  SW_Int_DIA_DataServices_SoftwareVersion_Read_Software_Logical_Block_Version_Information_ReadData_01();
  SW_Int_DIA_DataServices_BootSoftwareVersion_Read_Boot_SW_ReadData_01();
  SW_Int_DIA_Dcm_Svc28Handler_01();
  SW_Int_DIA_Dcm_Svc85Handler_01();
  SW_Int_DIA_RoELite_ObsolescenceDataHandler_01();
  SW_Int_DIA_RoELite_AvailabilityDataHandler_01();
  SW_Int_DIA_DataServices_Global_Time_Sync_Measured_Values_ReadData();
  SW_Int_DIA_runDid0340_UniqueSeatbeltSerialNumberWrite_01();
  SW_Int_DIA_runDidFD10_CycleConfigurationWrite_01();
  SW_Int_DIA_runDidFD2A_StepsLibraryWrite_01();
  SW_Int_DIA_DataServices_PreSafe_Cycles_Level_1_8_CombinedSignal_ReadData_01();
  SW_Int_DIA_DataServices_Release_Cycles_BSR_and_PreSafe_CombinedSignal_ReadData_WriteData_01();
  SW_Int_DIA_DataServices_Tensioning_Cycle_BSR_CombinedSignal_WriteData_01();
  SW_Int_DIA_DataServices_Vehicle_Equipment_Read_Equipment_1_WriteData_01();
  SW_Int_DIA_DataServices_Vehicle_Equipment_Read_Equipment_2_WriteData_01();
  SW_Int_DIA_DataServices_Vehicle_Equipment_Read_Equipment_3_WriteData_01();
  SW_Int_DIA_DataServices_Vehicle_Equipment_Read_Equipment_4_WriteData_01();
  SW_Int_DIA_DataServices_Vehicle_Equipment_Read_Equipment_5_WriteData_01();
  SW_Int_DIA_DataServices_Vehicle_Equipment_Read_Equipment_6_WriteData_01();
  SW_Int_DIA_DataServices_Vehicle_Equipment_Read_Uberspannungsabbruchschwelle_WriteData_01();
  SW_Int_DIA_DataServices_Vehicle_Equipment_Read_Uberspannungsbereichsschwelle_WriteData_01();
  SW_Int_DIA_DataServices_Vehicle_Equipment_Read_Unterspannungsabbruchschwelle_WriteData_01();
  SW_Int_DIA_DataServices_Vehicle_Equipment_Read_Unterspannungsbereichsschwelle_WriteData_01();
  SW_Int_DIA_DataServices_ZZZ_Vehicle_Equipment_Development_Read_Zykluszeit_Messtechnik_WriteData_01();
  SW_Int_DIA_DataServices_ZZZ_Vehicle_Equipment_Development_Read_Bitfield_WriteData_01();
  SW_Int_DIA_runDidFDFF_MeasurementFrameBlock12ConfigWrite_01();
  SW_Int_DIA_runSid23_WriteMemoryByAddress_01();
  SW_Int_DIA_runDid0241_PRE_SAFE_Recorder_1_WriteData_01();
  SW_Int_DIA_runDid0242_PRE_SAFE_Recorder_2_WriteData_01();
  SW_Int_DIA_runDidFD2F_EcuLocationWrite_01();
  SW_Int_DIA_runDidFD31_HBCalibrationWrite_01();
  SW_Int_DIA_runSid23_ReadMemoryByAddress_01();
  SW_Int_DIA_RoELight_DTCStatusChanged_Callback_01();
  SW_Int_DIA_runRidF703_CycleExecutionStart_01();
  SW_Int_DIA_runRidF703_CycleExecutionStop_01();
   SW_Int_DIA_runRid0329_TriggerBSRStart_01();
  SW_Int_DIA_runRid0329_TriggerBSRStop_01();
  SW_Int_DIA_runRid0329_TriggerBSRRequestResults_01();
  SW_Int_DIA_runRid0330_TriggerTensioningCycleStart_01();
  SW_Int_DIA_runRid0330_TriggerTensioningCycleStop_01();
  SW_Int_DIA_runRid0330_TriggerTensioningCycleRequestResults_01();
  SW_Int_DIA_runRid0302_TriggerPresafeDisplayRequestStart_01();
  SW_Int_DIA_runRid0302_TriggerPresafeDisplayRequestStop_01();
  SW_Int_DIA_runRid0302_TriggerPresafeDisplayRequestRequestResults_01();
  SW_Int_DIA_DataServices_PRE_SAFE_Counter_read_Read_CombinedDataElement_WriteData_01();

}